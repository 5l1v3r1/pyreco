__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Traits documentation build configuration file, created by
# sphinx-quickstart on Tue Jul 22 10:52:03 2008.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

import sys, os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
sys.path.append(os.path.abspath('_extensions'))
sys.path.append(os.path.abspath('../../'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [ 'refactordoc',
               'sphinx.ext.viewcode',
               'sphinx.ext.autosummary',
               'traits.util.trait_documenter']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'traits'
copyright = '2008-2011, Enthought'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
d = {}
execfile(os.path.join('..', '..', 'traits', '__init__.py'), d)
version = release = d['__version__']

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directories, that shouldn't be searched
# for source files.
#exclude_dirs = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# Options for the autodoc extension.
autodoc_default_flags =['members']

autodoc_member_order = 'bysource'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "Traits 4 User Manual"

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (within the static path) to place at the top of
# the sidebar.
html_logo = "e-logo-rev.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = "et.ico"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = False

# If false, no index is generated.
#html_use_index = False

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Traitsdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [
  ('index', 'Traits.tex', 'Traits 4 User Manual', 'Enthought, Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = "enthought_logo.jpg"
latex_logo = "e-logo-rev.png"

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

# Options for Texinfo output
# --------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'traits', 'Traits 4 User Manual', 'Enthought, Inc.',
   'Traits', 'Explicitly typed attributes for Python.', 'Python'),
]

########NEW FILE########
__FILENAME__ = base_doc
# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
#  file: base_doc.py
#  License: LICENSE.TXT
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import re

from definition_items import DefinitionItem
from line_functions import is_empty, get_indent, fix_backspace, NEW_LINE


underline_regex = re.compile(r'\s*\S+\s*\Z')

#------------------------------------------------------------------------------
#  Classes
#------------------------------------------------------------------------------

class BaseDoc(object):
    """Base abstract docstring refactoring class.

    The class' main purpose is to parse the dosctring and find the
    sections that need to be refactored. Subclasses should provide
    the methods responsible for refactoring the sections.

    Attributes
    ----------
    docstring : list
        A list of strings (lines) that holds docstrings

    index : int
        The current zero-based line number of the docstring that is currently
        proccessed.

    headers : dict
        The sections that the class refactors. Each entry in the
        dictionary should have as key the name of the section in the
        form that it appears in the docstrings. The value should be
        the postfix of the method, in the subclasses, that is
        responsible for refactoring (e.g. {'Methods': 'method'}).

    BaseDoc also provides a number of methods that operate on the docstring to
    help with the refactoring. This is neccessary because the docstring has to
    change inplace and thus it is better to live the docstring manipulation to
    the class methods instead of accessing the lines directly.

    """

    def __init__(self, lines, headers=None):
        """ Initialize the class

        The method setups the class attributes and starts parsing the
        docstring to find and refactor the sections.

        Arguments
        ---------
        lines : list of strings
            The docstring to refactor

        headers : dict
            The sections for which the class has custom refactor methods.
            Each entry in the dictionary should have as key the name of
            the section in the form that it appears in the docstrings.
            The value should be the postfix of the method, in the
            subclasses, that is responsible for refactoring (e.g.
            {'Methods': 'method'}).

        """
        try:
            self._docstring = lines.splitlines()
        except AttributeError:
            self._docstring = lines
        self.headers = {} if headers is None else headers
        self.bookmarks = []

    def parse(self):
        """ Parse the docstring.

        The docstring is parsed for sections. If a section is found then
        the corresponding refactoring method is called.

        """
        self.index = 0
        self.seek_to_next_non_empty_line()
        while not self.eod:
            header = self.is_section()
            if header:
                self._refactor(header)
            else:
                self.index += 1
                self.seek_to_next_non_empty_line()

    def _refactor(self, header):
        """Call the heading refactor method.

        The header is removed from the docstring and the docstring
        refactoring is dispatched to the appropriate refactoring method.

        The name of the refctoring method is constructed using the form
        _refactor_<header>. Where <header> is the value corresponding to
        ``self.headers[header]``. If there is no custom method for the
        section then the self._refactor_header() is called with the
        found header name as input.

        """
        self.remove_lines(self.index, 2)  # Remove header
        self.remove_if_empty(self.index)  # Remove space after header
        refactor_postfix = self.headers.get(header, 'header')
        method_name = ''.join(('_refactor_', refactor_postfix))
        method = getattr(self, method_name)
        lines = method(header)
        self.insert_and_move(lines, self.index)

    def _refactor_header(self, header):
        """ Refactor the header section using the rubric directive.

        The method has been tested and supports refactoring single word
        headers, two word headers and headers that include a backslash
        ''\''.

        Arguments
        ---------
        header : string
            The header string to use with the rubric directive.

        """
        header = fix_backspace(header)
        directive = '.. rubric:: {0}'.format(header)
        lines = []
        lines += [directive, NEW_LINE]
        return lines

    def extract_items(self, item_class=None):
        """ Extract the definition items from a docstring.

        Parse the items in the description of a section into items of the
        provided class time. Given a DefinitionItem or a subclass defined by
        the ``item_class`` parameter. Staring from the current index position,
        the method checks if in the next two lines a valid  header exists.
        If successful, then the lines that belong to the item description
        block (i.e. header + definition) are poped put from the docstring and
        passed to the ``item_class`` parser and create an instance of
        ``item_class``.

        The process is repeated until there is no compatible ``item_class``
        found or we run out of docstring. Then the method returns a list of
        item_class instances.

        The exit conditions allow for two valid section item layouts:

        1. No lines between items::

            <header1>
                <description1>

                <more description>
            <header2>
                <description2>

        2. One line between items::

            <header1>
                <description1>

                <more description>

            <header2>
                <description2>


        Arguments
        ---------
        item_class : DefinitionItem
            A DefinitionItem or a subclass. This argument is used to check
            if a line in the docstring is a valid item and to parse the
            individual list items in the section. When ``None`` (default) the
            base DefinitionItem class is used.


        Returns
        -------
        parameters : list
            List of the parsed item instances of ``item_class`` type.

        """
        item_type = DefinitionItem if (item_class is None) else item_class
        is_item = item_type.is_definition
        item_blocks = []
        while (not self.eod) and \
                (is_item(self.peek()) or is_item(self.peek(1))):
            self.remove_if_empty(self.index)
            item_blocks.append(self.get_next_block())
        items = [item_type.parse(block) for block in item_blocks]
        return items

    def get_next_block(self):
        """ Get the next item block from the docstring.

        The method reads the next item block in the docstring. The first line
        is assumed to be the DefinitionItem header and the following lines to
        belong to the definition::

            <header line>
                <definition>

        The end of the field is designated by a line with the same indent
        as the field header or two empty lines are found in sequence.

        """
        item_header = self.pop()
        sub_indent = get_indent(item_header) + ' '
        block = [item_header]
        while (not self.eod):
            peek_0 = self.peek()
            peek_1 = self.peek(1)
            if (is_empty(peek_0) and (not peek_1.startswith(sub_indent))) \
                    or ((not is_empty(peek_0)) \
                    and (not peek_0.startswith(sub_indent))):
                break
            else:
                line = self.pop()
                block += [line.rstrip()]
        return block

    def is_section(self):
        """ Check if the current line defines a section.

        .. todo:: split and cleanup this method.

        """
        if self.eod:
            return False

        header = self.peek()
        line2 = self.peek(1)

        # check for underline type format
        underline = underline_regex.match(line2)
        if underline is None:
            return False
        # is the nextline an rst underline?
        striped_header = header.rstrip()
        expected_underline1 = re.sub(r'[A-Za-z\\]|\b\s', '-', striped_header)
        expected_underline2 = re.sub(r'[A-Za-z\\]|\b\s', '=', striped_header)
        if ((underline.group().rstrip() == expected_underline1) or
            (underline.group().rstrip() == expected_underline2)):
            return header.strip()
        else:
            return False

    def insert_lines(self, lines, index):
        """ Insert refactored lines

        Arguments
        ---------
        new_lines : list
            The list of lines to insert

        index : int
            Index to start the insertion
        """
        docstring = self.docstring
        for line in reversed(lines):
            docstring.insert(index, line)

    def insert_and_move(self, lines, index):
        """ Insert refactored lines and move current index to the end.

        """
        self.insert_lines(lines, index)
        self.index += len(lines)

    def seek_to_next_non_empty_line(self):
        """ Goto the next non_empty line.

        """
        docstring = self.docstring
        for line in docstring[self.index:]:
            if not is_empty(line):
                break
            self.index += 1

    def get_next_paragraph(self):
        """ Get the next paragraph designated by an empty line.

        """
        lines = []
        while (not self.eod) and (not is_empty(self.peek())):
            line = self.pop()
            lines.append(line)
        return lines

    def read(self):
        """ Return the next line and advance the index.

        """
        index = self.index
        line = self._docstring[index]
        self.index += 1
        return line

    def remove_lines(self, index, count=1):
        """ Removes the lines from the docstring

        """
        docstring = self.docstring
        del docstring[index:(index + count)]

    def remove_if_empty(self, index=None):
        """ Remove the line from the docstring if it is empty.

        """
        if is_empty(self.docstring[index]):
            self.remove_lines(index)

    def bookmark(self):
        """ append the current index to the end of the list of bookmarks.

        """
        self.bookmarks.append(self.index)

    def goto_bookmark(self, bookmark_index=-1):
        """ Move to bookmark.

        Move the current index to the  docstring line given my the
        ``self.bookmarks[bookmark_index]`` and  remove it fromn the bookmark
        list. Default value will pop the last entry.

        Returns
        -------
        bookmark : int

        """
        self.index = self.bookmarks[bookmark_index]
        return self.bookmarks.pop(bookmark_index)

    def peek(self, ahead=0):
        """ Peek ahead a number of lines

        The function retrieves the line that is ahead of the current
        index. If the index is at the end of the list then it returns an
        empty string.

        Arguments
        ---------
        ahead : int
            The number of lines to look ahead.


        """
        position = self.index + ahead
        try:
            line = self.docstring[position]
        except IndexError:
            line = ''
        return line

    def pop(self, index=None):
        """ Pop a line from the dostrings.

        """
        index = self.index if (index is None) else index
        return self._docstring.pop(index)

    @property
    def eod(self):
        """ End of docstring.

        """
        return self.index >= len(self.docstring)

    @property
    def docstring(self):
        """ Get the docstring lines.

        """
        return self._docstring

########NEW FILE########
__FILENAME__ = class_doc
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: class_doc.py
#  License: LICENSE.TXT
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from base_doc import BaseDoc
from line_functions import get_indent, replace_at, add_indent
from definition_items import (MethodItem, AttributeItem, TableLineItem,
                              max_attribute_length, max_attribute_index,
                              ListItem)


class ClassDoc(BaseDoc):
    """ Docstring refactoring for classes.

    The class provides the following refactoring methods.

    Methods
    -------
    _refactor_attributes(self, header) :
        Refactor the attributes section to sphinx friendly format.

    _refactor_methods(self, header) :
        Refactor the methods section to sphinx friendly format.

    _refactor_as_items_list(self, header) :
        Refactor the Keywords section to sphinx friendly format.

    _refactor_notes(self, header) :
        Refactor the note section to use the rst ``.. note`` directive.

    _refactor_example(self, header) :
        Refactor the example section to sphinx friendly format.

    """

    def __init__(self, lines, headers=None):

        if headers is None:
            headers = {'Attributes': 'attributes', 'Methods': 'methods',
                       'Notes': 'notes', 'Keywords': 'as_item_list',
                       'Note': 'notes', 'Example': 'example',
                       'Examples': 'example'}

        super(ClassDoc, self).__init__(lines, headers)
        return

    def _refactor_attributes(self, header):
        """Refactor the attributes section to sphinx friendly format"""
        items = self.extract_items(AttributeItem)
        lines = []
        for item in items:
            lines += item.to_rst()
        return lines

    def _refactor_methods(self, header):
        """Refactor the methods section to sphinx friendly format.

        """
        items = self.extract_items(MethodItem)
        lines = []
        if len(items) > 0 :
            columns = self._get_column_lengths(items)
            border = '{0:=^{1}} {0:=^{2}}'.format('', columns[0], columns[1])
            heading = '{0:<{2}} {1:<{3}}'.format('Method', 'Description',
                                                 columns[0], columns[1])
            lines += [border]
            lines += [heading]
            lines += [border]
            for items in items:
                lines += items.to_rst(columns)
            lines += [border]
            lines += ['']
        lines = [line.rstrip() for line in lines]
        return lines

    def _refactor_notes(self, header):
        """Refactor the note section to use the rst ``.. note`` directive.

        """
        paragraph = self.get_next_paragraph()
        lines = ['.. note::']
        lines += add_indent(paragraph)
        return lines

    def _refactor_as_item_list(self, header):
        """ Refactor the a section to sphinx friendly item list.

        Arguments
        ---------
        header : str
            The header name that is used for the fields (i.e. ``:<header>:``).

        """
        items = self.extract_items(item_class=ListItem)
        lines = [':{0}:'.format(header.lower()), '']
        prefix = None if len(items) == 1 else '-'
        for item in items:
            lines += add_indent(item.to_rst(prefix))
        return lines

    def _refactor_example(self, header) :
        """ Refactor the example section to sphinx friendly format.

        Arguments
        ---------
        header : str
            The header name that is used for the fields (i.e. ``:<header>:``).

        """
        paragraph = self.get_next_paragraph()
        lines = ['.. rubric:: {0}'.format(header), '', '::', '']
        lines += add_indent(paragraph)
        return lines


    def _get_column_lengths(self, items):
        """ Helper function to estimate the column widths for the refactoring of
        the ``Methods`` section.

        The method finds the index of the item that has the largest function
        name (i.e. self.term) and the largest signature. If the indexes are not
        the same then checks to see which of the two items have the largest
        string sum (i.e. self.term + self.signature).

        """
        name_index = max_attribute_index(items, 'term')
        signature_index = max_attribute_index(items, 'signature')
        if signature_index != name_index:
            index = signature_index
            item1_width = len(items[index].term + items[index].signature)
            index = name_index
            item2_width = len(items[index].term + items[index].signature)
            first_column = max(item1_width, item2_width)
        else:
            index = name_index
            first_column = len(items[index].term + items[index].signature)

        first_column += 11  # Add boilerplate characters
        second_column = max_attribute_length(items, 'definition')
        return (first_column, second_column)

########NEW FILE########
__FILENAME__ = definition_items
﻿# -*- coding: utf-8 -*-
#-----------------------------------------------------------------------------
#  file: fields.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#-----------------------------------------------------------------------------
import collections
import re

from line_functions import (add_indent, fix_star, trim_indent, NEW_LINE,
                            fix_trailing_underscore)

header_regex = re.compile(r'\s:\s?')
definition_regex = re.compile(r"""
\*{0,2}            #  no, one or two stars
\w+\s:             #  a word followed by a space and a semicolumn
(.+)?              #  a definition
$                  # match at the end of the line
""", re.VERBOSE)
function_regex = re.compile(r'\w+\(.*\)\s*')
signature_regex = re.compile('\((.*)\)')


class DefinitionItem(collections.namedtuple(
        'DefinitionItem', ('term', 'classifier', 'definition'))):
    """ A docstring definition item

    Syntax diagram::

        +-------------------------------------------------+
        | term [ " : " classifier [ " or " classifier] ]  |
        +--+----------------------------------------------+---+
           | definition                                       |
           | (body elements)+                                 |
           +--------------------------------------------------+

    The Definition class is based on the nametuple class and is responsible
    to check, parse and refactor a docstring definition item into sphinx
    friendly rst.

    Attributes
    ----------
    term : str
        The term usually reflects the name of a parameter or an attribute.

    classifier: str
        The classifier of the definition. Commonly used to reflect the type
        of an argument or the signature of a function.

        .. note:: Currently only one classifier is supported.

    definition : list
        The list of strings that holds the description the definition item.

    .. note:: A Definition item is based on the item of a section definition
        list as it defined in restructured text
        (_http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections).

    """

    @classmethod
    def is_definition(cls, line):
        """ Check if the line is describing a definition item.

        The method is used to check that a line is following the expected
        format for the term and classifier attributes.

        The expected format is::

            +-------------------------------------------------+
            | term [ " : " classifier [ " or " classifier] ]  |
            +-------------------------------------------------+

        Subclasses can subclass to restrict or expand this format.

        """
        return definition_regex.match(line) is not None

    @classmethod
    def parse(cls, lines):
        """Parse a definition item from a set of lines.

        The class method parses the definition list item from the list of
        docstring lines and produces a DefinitionItem with the term,
        classifier and the definition.

        .. note:: The global indention in the definition lines is striped

        The term definition is assumed to be in one of the following formats::

            term
                Definition.

        ::

            term
                Definition, paragraph 1.

                Definition, paragraph 2.

        ::

            term : classifier
                Definition.

        Arguments
        ---------
        lines
            docstring lines of the definition without any empty lines before or
            after.

        Returns
        -------
        definition : DefinitionItem

        """
        header = lines[0].strip()
        term, classifier = header_regex.split(header, maxsplit=1) if \
                           (' :' in header) else (header, '')
        trimed_lines = trim_indent(lines[1:]) if (len(lines) > 1) else ['']
        definition = [line.rstrip() for line in trimed_lines]
        return cls(term.strip(), classifier.strip(), definition)

    def to_rst(self, **kwards):
        """ Outputs the Definition in sphinx friendly rst.

        The method renders the definition into a list of lines that follow
        the rst markup. The default behaviour is to render the definition
        as an sphinx definition item::

            <term>

               (<classifier>) --
               <definition>

        Subclasses will usually override the method to provide custom made
        behaviour. However the signature of the method should hold only
        keyword arguments which have default values. The keyword arguments
        can be used to pass addition rendering information to subclasses.

        Returns
        -------
        lines : list
            A list of string lines rendered in rst.

        Example
        -------

        ::

            >>> item = DefinitionItem('lines', 'list',
                                ['A list of string lines rendered in rst.'])
            >>> item.to_rst()
            lines

                *(list)* --
                A list of string lines rendered in rst.

        .. note:: An empty line is added at the end of the list of strings so
            that the results can be concatenated directly and rendered properly
            by sphinx.


        """
        postfix = ' --' if (len(self.definition) > 0) else ''
        lines = []
        lines += [self.term]
        lines += [NEW_LINE]
        lines += ['    *({0})*{1}'.format(self.classifier, postfix)]
        lines += add_indent(self.definition)  # definition is all ready a list
        lines += [NEW_LINE]
        return lines


class AttributeItem(DefinitionItem):
    """ Definition that renders the rst output using the attribute directive.

    """
    _normal = (".. attribute:: {0}\n"
               "    :annotation: = {1}\n"
               "\n"
               "{2}\n\n")
    _no_definition = (".. attribute:: {0}\n"
                      "    :annotation: = {1}\n\n")
    _no_classifier = (".. attribute:: {0}\n\n"
                      "{2}\n\n")
    _only_term = ".. attribute:: {0}\n\n"

    def to_rst(self, ):
        """ Return the attribute info using the attribute sphinx markup.

        Examples
        --------

        ::

            >>> item = AttributeItem('indent', 'int',
            ... ['The indent to use for the description block.'])
            >>> item.to_rst()
            .. attribute:: indent
                :annotation: = int

                The indent to use for the description block
            >>>

        ::

            >>> item = AttributeItem('indent', '',
            ... ['The indent to use for the description block.'])
            >>> item.to_rst()
            .. attribute:: indent

                The indent to use for the description block
            >>>

        .. note:: An empty line is added at the end of the list of strings so
            that the results can be concatenated directly and rendered properly
            by sphinx.

        """
        definition = '\n'.join(add_indent(self.definition))
        template = self.template.format(self.term, self.classifier, definition)
        return template.splitlines()

    @property
    def template(self):
        if self.classifier == '' and self.definition == ['']:
            template = self._only_term
        elif self.classifier == '':
            template = self._no_classifier
        elif self.definition == ['']:
            template = self._no_definition
        else:
            template = self._normal
        return template


class ArgumentItem(DefinitionItem):
    """ A definition item for function argument sections.

    """
    _normal = (":param {0}:\n"
               "{2}\n"
               ":type {0}: {1}")
    _no_definition = (":param {0}:\n"
                      ":type {0}: {1}")
    _no_classifier = (":param {0}:\n"
                      "{2}")
    _only_term = ":param {0}:"

    def to_rst(self):
        """ Render ArgumentItem in sphinx friendly rst using the ``:param:``
        role.

        Example
        -------

        ::

            >>> item = ArgumentItem('indent', 'int',
            ... ['The indent to use for the description block.',
                 ''
                 'This is the second paragraph of the argument definition.'])
            >>> item.to_rst()
            :param indent:
                The indent to use for the description block.

                This is the second paragraph of the argument definition.
            :type indent: int

        .. note::

            There is no new line added at the last line of the :meth:`to_rst`
            method.

        """
        argument = fix_star(self.term)
        argument = fix_trailing_underscore(argument)
        argument_type = self.classifier
        definition = '\n'.join(add_indent(self.definition))
        template = self.template.format(argument, argument_type, definition)
        return template.splitlines()

    @property
    def template(self):
        if self.classifier == '' and self.definition == ['']:
            template = self._only_term
        elif self.classifier == '':
            template = self._no_classifier
        elif self.definition == ['']:
            template = self._no_definition
        else:
            template = self._normal
        return template


class ListItem(DefinitionItem):
    """ A definition item that is rendered as an ordered/unordered list

    """

    _normal = ("**{0}** (*{1}*) --\n"
               "{2}\n\n")
    _only_term = "**{0}**\n\n"
    _no_definition = "**{0}** (*{1}*)\n\n"
    _no_classifier = ("**{0}** --\n"
                      "{2}\n\n")

    def to_rst(self, prefix=None):
        """ Outputs ListItem in rst using as items in an list.

        Arguments
        ---------
        prefix : str
            The prefix to use. For example if the item is part of a numbered
            list then ``prefix='-'``.

        Example
        -------

        >>> item = ListItem('indent', 'int',
        ... ['The indent to use for the description block.'])
        >>> item.to_rst(prefix='-')
        - **indent** (`int`) --
          The indent to use for the description block.

        >>> item = ListItem('indent', 'int',
        ... ['The indent to use for'
             'the description block.'])
        >>> item.to_rst(prefix='-')
        - **indent** (`int`) --
          The indent to use for
          the description block.


        .. note:: An empty line is added at the end of the list of strings so
            that the results can be concatenated directly and rendered properly
            by sphinx.

        """
        indent = 0 if (prefix is None) else len(prefix) + 1
        definition = '\n'.join(add_indent(self.definition, indent))
        template = self.template.format(self.term, self.classifier, definition)
        if prefix is not None:
            template = prefix + ' ' + template
        return template.splitlines()

    @property
    def template(self):
        if self.classifier == '' and self.definition == ['']:
            template = self._only_term
        elif self.classifier == '':
            template = self._no_classifier
        elif self.definition == ['']:
            template = self._no_definition
        else:
            template = self._normal
        return template


class TableLineItem(DefinitionItem):
    """ A Definition Item that represents a table line.

    """

    def to_rst(self, columns=(0, 0, 0)):
        """ Outputs definition in rst as a line in a table.

        Arguments
        ---------
        columns : tuple
            The three item tuple of column widths for the term, classifier
            and definition fields of the TableLineItem. When the column width
            is 0 then the field

        .. note::
            - The strings attributes are clipped to the column width.

        Example
        -------

        >>> item = TableLineItem('function(arg1, arg2)', '',
        ... ['This is the best function ever.'])
        >>> item.to_rst(columns=(22, 0, 20))
        function(arg1, arg2)   This is the best fun

        """
        definition = ' '.join([line.strip() for line in self.definition])
        term = self.term[:columns[0]]
        classifier = self.classifier[:columns[1]]
        definition = definition[:columns[2]]

        first_column = '' if columns[0] == 0 else '{0:<{first}} '
        second_column = '' if columns[1] == 0 else '{1:<{second}} '
        third_column = '' if columns[2] == 0 else '{2:<{third}}'
        table_line = ''.join((first_column, second_column, third_column))

        lines = []
        lines += [table_line.format(term, classifier, definition,
                  first=columns[0], second=columns[1], third=columns[2])]
        lines += ['']
        return lines


class MethodItem(DefinitionItem):
    """ A TableLineItem subclass to parse and render class methods.

    """
    @classmethod
    def is_definition(cls, line):
        """ Check if the definition header is a function signature.

        """
        match = function_regex.match(line)
        return match

    @classmethod
    def parse(cls, lines):
        """Parse a method definition item from a set of lines.

        The class method parses the method signature and definition from the
        list of docstring lines and produces a MethodItem where the term
        is the method name and the classifier is arguments

        .. note:: The global indention in the definition lines is striped

        The method definition item is assumed to be as follows::

            +------------------------------+
            | term "(" [  classifier ] ")" |
            +--+---------------------------+---+
               | definition                    |
               | (body elements)+              |
               +--------------------- ---------+

        Arguments
        ---------
        lines :
            docstring lines of the method definition item without any empty
            lines before or after.

        Returns
        -------
        definition : MethodItem

        """
        header = lines[0].strip()
        term, classifier, _ = signature_regex.split(header)
        definition = trim_indent(lines[1:]) if (len(lines) > 1) else ['']
        return cls(term, classifier, definition)

    def to_rst(self, columns=(0, 0)):
        """ Outputs definition in rst as a line in a table.

        Arguments
        ---------
        columns : tuple
            The two item tuple of column widths for the :meth: role column
            and the definition (i.e. summary) of the MethodItem

        .. note:: The strings attributes are clipped to the column width.

        Example
        -------

        ::

            >>> item = MethodItem('function', 'arg1, arg2',
            ... ['This is the best function ever.'])
            >>> item.to_rst(columns=(40, 20))
            :meth:`function <function(arg1, arg2)>` This is the best fun

        """
        definition = ' '.join([line.strip() for line in self.definition])
        method_role = ':meth:`{0}({1}) <{0}>`'.format(self.term,
                                                      self.classifier)
        table_line = '{0:<{first}} {1:<{second}}'

        lines = []
        lines += [table_line.format(method_role[:columns[0]],
                                    definition[:columns[1]], first=columns[0],
                                    second=columns[1])]
        return lines

    @property
    def signature(self):
        return '{}({})'.format(self.term, self.classifier)


#------------------------------------------------------------------------------
#  Functions to work with Definition Items
#------------------------------------------------------------------------------

def max_attribute_length(items, attr):
    """ Find the max length of the attribute in a list of DefinitionItems.

    Arguments
    ---------
    items : list
        The list of the DefinitionItem instances (or subclasses).

    attr : str
        Attribute to look at.

    """
    if attr == 'definition':
        maximum = max([len(' '.join(item.definition)) for item in items])
    else:
        maximum = max([len(getattr(item, attr)) for item in items])
    return maximum


def max_attribute_index(items, attr):
    """ Find the index of the attribute with the maximum length in a list of
    DefinitionItems.

    Arguments
    ---------
    items : list
        The list of the DefinitionItems (or subclasses).

    attr : str
        Attribute to look at.

    """
    if attr == 'definition':
        attributes = [len(' '.join(item.definition)) for item in items]
    else:
        attributes = [len(getattr(item, attr)) for item in items]

    maximum = max(attributes)
    return attributes.index(maximum)

########NEW FILE########
__FILENAME__ = function_doc
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: function_doc.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from base_doc import BaseDoc
from line_functions import get_indent, add_indent
from definition_items import ArgumentItem, ListItem


class FunctionDoc(BaseDoc):
    """Docstring refactoring for functions

    The class provides the following refactoring methods.

    Methods
    -------
    _refactor_arguments(self, header) :
        Refactor the Arguments and Parameters section to sphinx friendly format.

    _refactor_as_items_list(self, header) :
        Refactor the Returns, Raises and Yields sections to sphinx friendly
        format.

    _refactor_notes(self, header) :
        Refactor the note section to use the rst ``.. note`` directive.

    """

    def __init__(self, lines, headers=None):

        if headers is None:
            headers = {'Returns': 'as_item_list', 'Arguments': 'arguments',
                       'Parameters': 'arguments', 'Raises': 'as_item_list',
                       'Yields': 'as_item_list', 'Notes':'notes',
                       'Note': 'notes'}

        super(FunctionDoc, self).__init__(lines, headers)
        return

    def _refactor_as_item_list(self, header):
        """ Refactor the a section to sphinx friendly item list.

        Arguments
        ---------
        header : str
            The header name that is used for the fields (i.e. ``:<header>:``).

        """
        items = self.extract_items(item_class=ListItem)
        lines = [':{0}:'.format(header.lower())]
        if len(items) > 0:
            prefix = None if len(items) == 1 else '-'
            for item in items:
                lines += add_indent(item.to_rst(prefix))
        else:
            paragraph = self.get_next_paragraph()
            lines += add_indent(paragraph)

        return lines

    def _refactor_arguments(self, header):
        """ Refactor the argument section to sphinx friendly format.

        Arguments
        ---------
        header : unused
            This parameter is ingnored in thi method.

        """
        items = self.extract_items(item_class=ArgumentItem)
        lines = []
        for item in items:
            lines += item.to_rst()
        return lines

    def _refactor_notes(self, header):
        """ Refactor the notes section to sphinx friendly format.

        Arguments
        ---------
        header : unused
            This parameter is ingnored in this method.

        """
        paragraph = self.get_next_paragraph()
        lines = ['.. note::']
        lines += add_indent(paragraph)
        return lines

########NEW FILE########
__FILENAME__ = line_functions
# -*- coding: utf-8 -*-
#-----------------------------------------------------------------------------
#  file: line_functions.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#-----------------------------------------------------------------------------
import re


#-----------------------------------------------------------------------------
#  Pre-compiled regexes
#-----------------------------------------------------------------------------
indent_regex = re.compile(r'\s+')


#-----------------------------------------------------------------------------
#  Constants
#-----------------------------------------------------------------------------
NEW_LINE = ''


#------------------------------------------------------------------------------
#  Functions to manage indentation
#------------------------------------------------------------------------------

def add_indent(lines, indent=4):
    """ Add spaces to indent a list of lines.

    Arguments
    ---------
    lines : list
        The list of strings to indent.

    indent : int
        The number of spaces to add.

    Returns
    -------
    lines : list
        The indented strings (lines).

    Notes
    -----
    Empty strings are not changed.

    """
    indent_str = ' ' * indent if indent != 0 else ''
    output = []
    for line in lines:
        if is_empty(line):
            output.append(line)
        else:
            output.append(indent_str + line)
    return output


def remove_indent(lines):
    """ Remove all indentation from the lines.

    Returns
    -------
    result : list
        A new list of left striped strings.

    """
    return [line.lstrip() for line in lines]


def trim_indent(lines):
    """ Trim global indentation level from lines.

    """
    non_empty_lines = filter(lambda x: not is_empty(x), lines)
    indent = set(len(get_indent(line)) for line in non_empty_lines)
    indent.discard(0)
    global_indent = min(indent)
    return [line[global_indent:] for line in lines]


def get_indent(line):
    """ Return the indent portion of the line.

    """
    indent = indent_regex.match(line)
    if indent is None:
        return ''
    else:
        return indent.group()


#------------------------------------------------------------------------------
#  Functions to detect line type
#------------------------------------------------------------------------------

def is_empty(line):
    return not line.strip()


#------------------------------------------------------------------------------
#  Functions to adjust strings
#------------------------------------------------------------------------------

def fix_star(word):
    """ Replace ``*`` with ``\*`` so that is will be parse properly by
    docutils.

    """
    return word.replace('*', '\*')


def fix_backspace(word):
    """ Replace ``\\`` with ``\\\\`` so that it will printed properly in the
    documentation.

    """
    return word.replace('\\', '\\\\')


def fix_trailing_underscore(word):
    """ Replace the trailing ``_`` with ``\\_`` so that it will printed
    properly in the documentation.

    """
    if word.endswith('_'):
        word = word.replace('_', '\_')
    return word


def replace_at(word, line, index):
    """ Replace the text in-line.

    The text in line is replaced (not inserted) with the word. The
    replacement starts at the provided index. The result is cliped to
    the input length

    Arguments
    ---------
    word : str
        The text to copy into the line.

    line : str
        The line where the copy takes place.

    index : int
        The index to start coping.

    Returns
    -------
    result : str
        line of text with the text replaced.

    """
    word_length = len(word)
    result = line[:index] + word + line[(index + word_length):]
    return result[:len(line)]

########NEW FILE########
__FILENAME__ = adapt_metadata
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# adapt_metadata.py - Example of using 'adapt' metadata

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Instance
from interface_definition import IName

#--[Code]-----------------------------------------------------------------------

class Apartment( HasTraits ):
    renter = Instance( IName, adapt='no' )


########NEW FILE########
__FILENAME__ = add_class_trait
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# add_class_trait.py --- Example of mutually-referring classes
#                        using add_class_trait()


#--[Imports]--------------------------------------------------------------------

from traits.api import HasTraits, Instance

#--[Code]-----------------------------------------------------------------------

# Defining mutually-referring classes using add_class_trait()

class Chicken ( HasTraits ):

    pass


class Egg ( HasTraits ):

    created_by = Instance( Chicken )

# Now that 'Egg' is defined, we can add the 'hatched_from' trait to
# solve the mutual-reference problem...

Chicken.add_class_trait( 'hatched_from', Instance( Egg ) )


########NEW FILE########
__FILENAME__ = all_traits_features
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# all_traits_features.py --- Shows primary features of the Traits
#                            package

#--[Imports]--------------------------------------------------------------------
from traits.api import Delegate, HasTraits, Instance, Int, Str

#--[Code]-----------------------------------------------------------------------
# Shows the five primary features of the Traits package.

class Parent ( HasTraits ):

    # INITIALIZATION: last_name' is initialized to '':
    last_name = Str( '' )


class Child ( HasTraits ):

    age = Int

    # VALIDATION: 'father' must be a Parent instance:
    father = Instance( Parent )

    # DELEGATION: 'last_name' is delegated to father's 'last_name':
    last_name = Delegate( 'father' )

    # NOTIFICATION: This method is called when 'age' changes:
    def _age_changed ( self, old, new ):
        print 'Age changed from %s to %s ' % ( old, new )

#--[Example*]-------------------------------------------------------------------

# Set up the example:
joe = Parent()
joe.last_name = 'Johnson'
moe = Child()
moe.father = joe

# DELEGATION in action:
print "Moe's last name is %s " % moe.last_name
# Result:
# Moe's last name is Johnson

# NOTIFICATION in action
moe.age = 10
# Result:
# Age changed from 0 to 10

# VISUALIZATION: Displays a UI for editing moe's
# attributes (if a supported GUI toolkit is installed)
moe.configure_traits()


########NEW FILE########
__FILENAME__ = all_wildcard
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# all_wildcard.py --- Example of trait attribute wildcard rules

#--[Imports]--------------------------------------------------------------------
from traits.api import Any, Str, Int, HasTraits, TraitError

#--[Code]-----------------------------------------------------------------------

class Person ( HasTraits ):

    # Normal, explicitly defined trait:
    name = Str

    # By default, let all traits have any value:
    _ = Any

    # Except for this one, which must be an Int:
    age = Int

#--[Example*]-------------------------------------------------------------------

# Create a sample Person:
bill = Person()

# These assignments should all work:
bill.name      = 'William'
bill.address  = '121 Drury Lane'
bill.zip_code = 55212
bill.age      = 49

# This should generate an error (must be an Int):
print 'Attempting to assign a string to an Int trait object...\n'
try:
    bill.age = 'middle age'
except TraitError, c:
    print 'TraitError: ', c, '\n'

# Display the final results:
bill.print_traits()

########NEW FILE########
__FILENAME__ = bad_self_ref
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# bad_self_ref.py -- Non-working example with self-referencing class definition

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Instance

#--[Code]-----------------------------------------------------------------------
# Shows the incorrect way of defining a self-referencing class.
try:
    class Employee ( HasTraits ):

        # This won't work.
        # 'Employee' is not defined until the class definition is complete:
        manager = Instance( Employee )
except NameError, excp:
    print excp

########NEW FILE########
__FILENAME__ = cached_prop
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#-------------------------------------------------------------------------------

# cached_prop.py - Example of @cached_property decorator

#--[Imports]--------------------------------------------------------------------
from traits.api import HasPrivateTraits, List, Int,\
                                 Property, cached_property

#--[Code]-----------------------------------------------------------------------

class TestScores ( HasPrivateTraits ):

    scores  = List( Int )
    average = Property( depends_on = 'scores' )

    @cached_property
    def _get_average ( self ):
        s = self.scores
        return (float( reduce( lambda n1, n2: n1 + n2, s, 0 ) )
                 / len( s ))


########NEW FILE########
__FILENAME__ = circular_definition
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--[Imports]--------------------------------------------------------------------

from traits.api import HasTraits, Trait, Instance

#--[Code]-----------------------------------------------------------------------

# Shows the incorrect way of defining mutually-referring classes.
try:
    class Chicken ( HasTraits ):

        # Won't work: 'Egg' not defined yet:
        hatched_from = Instance( Egg )

    class Egg ( HasTraits ):

        # If we move this class to the top, then this line won't work, because
        # 'Chicken' won't be defined yet:
        created_by = Instance( Chicken )

except NameError, excp:
    print excp


########NEW FILE########
__FILENAME__ = compound
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# compound.py -- Example of multiple criteria in a trait definition

#--[Imports]--------------------------------------------------------------------

from traits.api import HasTraits, Range, Trait, TraitError

#--[Code]-----------------------------------------------------------------------

# Shows the definition of a compound trait.

class Die ( HasTraits ):

    # Define a compound trait definition:
    value = Trait( 1, Range( 1, 6 ),
                  'one', 'two', 'three', 'four', 'five', 'six' )

#--[Example*]-------------------------------------------------------------------

# Create a sample Die:
die = Die()

# Try out some sample valid values:
die.value = 3
die.value = 'three'
die.value = 5
die.value = 'five'

# Now try out some invalid values:
try:
    die.value = 0
except TraitError, excp:
    print excp

try:
    die.value = 'zero'
except TraitError, excp:
    print excp


########NEW FILE########
__FILENAME__ = configure_traits
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# configure_traits.py -- Sample code to demonstrate configure_traits()

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int

#--[Code]-----------------------------------------------------------------------

class SimpleEmployee(HasTraits):
    first_name = Str
    last_name = Str
    department = Str

    employee_number = Str
    salary = Int

sam = SimpleEmployee()
sam.configure_traits()


########NEW FILE########
__FILENAME__ = custom_traithandler
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# custom_traithandler.py --- Example of a custom TraitHandler

#--[Imports]--------------------------------------------------------------------
import types
from traits.api import TraitHandler

#--[Code]-----------------------------------------------------------------------

class TraitOddInteger(TraitHandler):

    def validate(self, object, name, value):
        if ((type(value) is types.IntType) and
            (value > 0) and ((value % 2) == 1)):
            return value
        self.error(object, name, value)

    def info(self):
        return 'a positive odd integer'

########NEW FILE########
__FILENAME__ = deferring_notification
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# deferring_notification.py -- Example of notification with deferring

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Instance, PrototypedFrom, Str

#--[Code]-----------------------------------------------------------------------
class Parent ( HasTraits ):

    first_name = Str
    last_name  = Str

    def _last_name_changed(self, new):
        print "Parent's last name changed to %s." % new

class Child ( HasTraits ):

    father = Instance( Parent )
    first_name = Str
    last_name  = PrototypedFrom( 'father' )

    def _last_name_changed(self, new):
        print "Child's last name changed to %s." % new

#--[Example*]-------------------------------------------------------------------

dad = Parent( first_name='William', last_name='Chase' )
# Output: Parent's last name changed to Chase.

son = Child( first_name='John', father=dad )
# Output: Child's last name changed to Chase.

# Change Parent's last_name
dad.last_name='Jones'
# Output: Parent's last name changed to Jones.
#         Child's last name changed to Jones.

# Override Child's last_name
son.last_name='Thomas'
# Output Child's last name changed to Thomas.

# Change Parent's last_name; Child's is not affected.
dad.last_name='Riley'
# Output: Parent's last name changed to Riley.

# Reset Child's last_name
del son.last_name
# Output: Child's last name changed to Riley.

# Change to Parent now affects Child.
dad.last_name='Simmons'
# Output: Parent's last name changed to Simmons.
#         Child's last name changed to Simmons.



########NEW FILE########
__FILENAME__ = delegate
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# delegate.py --- Example of trait delegation

#--[Imports]--------------------------------------------------------------------
from traits.api import DelegatesTo, HasTraits, Instance, Str, TraitError

#--[Code]-----------------------------------------------------------------------
class Parent(HasTraits):
    first_name = Str
    last_name  = Str

class Child(HasTraits):
    first_name = Str
    last_name  = DelegatesTo('father')
    father     = Instance(Parent)
    mother     = Instance(Parent)

#--[Example*]-------------------------------------------------------------------

tony  = Parent(first_name='Anthony', last_name='Jones')
alice = Parent(first_name='Alice', last_name='Smith')
sally = Child( first_name='Sally', father=tony, mother=alice)

# Child delegates its 'last_name' to its 'father' object's 'last_name'
print sally.last_name
# Output: Jones

# Assign an explicit value to the child's 'last_name'
sally.last_name = 'Cooper'
print tony.last_name
#Output: Cooper

# Validation is still controlled by the father's 'last_name' trait
print 'Attempting to assign a Parent object to a Str trait...\n'
try:
    sally.last_name = sally.mother # ERR: string expected
except TraitError, c:
    print 'TraitError: ', c

"""
The exception printed will look similar to the following:

Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "c:\src\trunk\enthought\traits\trait_handlers.py", line 163, in error
    raise TraitError, ( object, name, self.info(), value )
traits.trait_errors.TraitError: The 'last_name' trait of a Child
instance must be a value of type 'str', but a value of <__main__.Parent object
at 0x009DD6F0> was specified.
"""

########NEW FILE########
__FILENAME__ = disallow
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# disallow.py --- Example of using Disallow with wildcards

#--[Imports]--------------------------------------------------------------------
from traits.api import Disallow, Float, \
                             HasTraits, Int, Str

#--[Code]-----------------------------------------------------------------------

class Person (HasTraits):
    name   = Str
    age    = Int
    weight = Float
    _      = Disallow


########NEW FILE########
__FILENAME__ = dynamic_notification
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# dynamic_notification.py --- Example of dynamic notification

#--[Imports]--------------------------------------------------------------------
from traits.api import Float, HasTraits, Instance

#--[Code]-----------------------------------------------------------------------

class Part (HasTraits):
  cost = Float(0.0)

class Widget (HasTraits):
  part1 = Instance(Part)
  part2 = Instance(Part)
  cost  = Float(0.0)

  def __init__(self):
    self.part1 = Part()
    self.part2 = Part()
    self.part1.on_trait_change(self.update_cost, 'cost')
    self.part2.on_trait_change(self.update_cost, 'cost')

  def update_cost(self):
    self.cost = self.part1.cost + self.part2.cost

#--[Example*]-------------------------------------------------------------------
w = Widget()
w.part1.cost = 2.25
w.part2.cost = 5.31
print w.cost
# Result: 7.56


########NEW FILE########
__FILENAME__ = event
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# event.py --- Example of a trait event

#--<Imports>-------------------------------------------------------------------
from traits.api import Event, HasTraits, List, RGBColor, Tuple

#--[Code]----------------------------------------------------------------------

point_2d = Tuple(0, 0)


class Line2D(HasTraits):
    points = List(point_2d)
    line_color = RGBColor('black')
    updated = Event

    def redraw(self):
        pass  # Not implemented for this example

    def _points_changed(self):
        self.updated = True

    def _updated_fired(self):
        self.redraw()

########NEW FILE########
__FILENAME__ = external_adapter
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# external_adapter.py - Example of declaring a class as an adapter
#                       externally to the class

#--[Imports]--------------------------------------------------------------------
from traits.api import adapts
from interface_definition import IName
from interface_implementation import Person

#--[Code]-----------------------------------------------------------------------

class AnotherPersonAdapter ( object ):

    # Implement the adapter's constructor:
    def __init__ ( self, person ):
        self.person = person

    # Implement the 'IName' interface on behalf of its client:
    def get_name ( self ):
        return ('%s %s' % ( self.person.first_name,
                            self.person.last_name ))

adapts( AnotherPersonAdapter, Person, IName )


########NEW FILE########
__FILENAME__ = interface_definition
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# interface_definition.py - Example of defining an interface

#--[Imports]--------------------------------------------------------------------
from traits.api import Interface

#--[Code]-----------------------------------------------------------------------

class IName(Interface):

    def get_name(self):
        """ Returns a string which is the name of an object. """


########NEW FILE########
__FILENAME__ = interface_implementation
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# interface_implementation.py - Example of implementing an interface

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, implements, Str, Instance
from interface_definition import IName

#--[Code]-----------------------------------------------------------------------

class Person(HasTraits):
    implements(IName)

    first_name = Str( 'John' )
    last_name  = Str( 'Doe' )

    # Implementation of the 'IName' interface:
    def get_name ( self ):
        """ Returns the name of an object. """
        return ('%s %s' % ( self.first_name, self.last_name ))

#--[Example*]-------------------------------------------------------------------

class Apartment(HasTraits):
    renter = Instance(IName)
william = Person(first_name='William', last_name='Adams')
apt1 = Apartment( renter=william )
print 'Renter is: ', apt1.renter.get_name()
# Result: Renter is: William Adams


########NEW FILE########
__FILENAME__ = keywords
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# keywords.py --- Example of trait keywords

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str

#--[Code]-----------------------------------------------------------------------

class Person(HasTraits):
    # 'label' is used for Traits UI field labels;
    # 'desc' can be used for tooltips.
    first_name = Str('',
                     desc='first or personal name',
                     label='First Name')
    last_name =  Str('',
                     desc='last or family name',
                     label='Last Name')

########NEW FILE########
__FILENAME__ = list_notifier
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# list_notifier.py -- Example of zero-parameter handlers for an object
#                     containing a list

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, List

#--[Code]-----------------------------------------------------------------------

class Employee: pass

class Department( HasTraits ):
    employees = List(Employee)

#--[Example*]-------------------------------------------------------------------

def a_handler(): print "A handler"
def b_handler(): print "B handler"
def c_handler(): print "C handler"

fred = Employee()
mary = Employee()
donna = Employee()

dept = Department(employees=[fred, mary])

# "Old style" name syntax
# a_handler is called only if the list is replaced:
dept.on_trait_change( a_handler, 'employees' )
# b_handler is called if the membership of the list changes:
dept.on_trait_change( b_handler, 'employees_items')

# "New style" name syntax
# c_handler is called if 'employees' or its membership change:
dept.on_trait_change( c_handler, '[employees]' )

print "Changing list items"
dept.employees[1] = donna     # Calls B and C
print "Replacing list"
dept.employees = [donna]      # Calls A and C



########NEW FILE########
__FILENAME__ = mapped
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# mapped.py --- Example of a mapped trait

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Trait

#--[Code]-----------------------------------------------------------------------
standard_color = Trait ('black', {
    'black':       ( 0.0, 0.0, 0.0, 1.0 ),
    'blue':        ( 0.0, 0.0, 1.0, 1.0 ),
    'cyan':        ( 0.0, 1.0, 1.0, 1.0 ),
    'green':       ( 0.0, 1.0, 0.0, 1.0 ),
    'magenta':     ( 1.0, 0.0, 1.0, 1.0 ),
    'orange':      ( 0.8, 0.196, 0.196, 1.0 ),
    'purple':      ( 0.69, 0.0, 1.0, 1.0 ),
    'red':         ( 1.0, 0.0, 0.0, 1.0 ),
    'violet':      ( 0.31, 0.184, 0.31, 1.0 ),
    'yellow':      ( 1.0, 1.0, 0.0, 1.0 ),
    'white':       ( 1.0, 1.0, 1.0, 1.0 ),
    'transparent': ( 1.0, 1.0, 1.0, 0.0 )
} )

red_color = Trait( 'red', standard_color )

class GraphicShape( HasTraits ):
    line_color = standard_color
    fill_color = red_color

#--[Example*]-------------------------------------------------------------------

my_shape1 = GraphicShape()

# Default values for normal trait attributes
print my_shape1.line_color, my_shape1.fill_color
# Output: black red

# Default values for shadow trait attributes
print my_shape1.line_color_, my_shape1.fill_color_
# Output: (0.0, 0.0, 0.0, 1.0) (1.0, 0.0, 0.0, 1.0)

# Non-default values
my_shape2 = GraphicShape()
my_shape2.line_color = 'blue'
my_shape2.fill_color = 'green'

print my_shape2.line_color, my_shape2.fill_color
# Output: blue green

print my_shape2.line_color_, my_shape2.fill_color_
# Output: (0.0, 0.0, 1.0, 1.0) (0.0, 1.0, 0.0, 1.0)


########NEW FILE########
__FILENAME__ = metadata
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# metadata.py --- Example of accessing trait metadata attributes

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Int, List, Float, Instance, Any,\
                                 TraitType

#--[Code]-----------------------------------------------------------------------

class Foo( HasTraits ): pass

class Test( HasTraits ):
    i = Int(99)
    lf = List(Float)
    foo = Instance( Foo, () )
    any = Any( [1, 2, 3 ] )

#--[Example*]-------------------------------------------------------------------

t = Test()

# Prints values of various metadata attributes for each of the traits.
print t.trait( 'i' ).default                      # 99
print t.trait( 'i' ).default_kind                 # value
print t.trait( 'i' ).inner_traits                 # ()
print t.trait( 'i' ).is_trait_type( Int )         # True
print t.trait( 'i' ).is_trait_type( Float )       # False

print t.trait( 'lf' ).default                     # []
print t.trait( 'lf' ).default_kind                # list
print t.trait( 'lf' ).inner_traits # (<traits.traits.CTrait object at 0x01B24138>,)
print t.trait( 'lf' ).is_trait_type( List )       # True
print t.trait( 'lf' ).is_trait_type( TraitType )  # True
print t.trait( 'lf' ).is_trait_type( Float )      # False
print t.trait( 'lf' ).inner_traits[0].is_trait_type( Float ) # True

print t.trait( 'foo' ).default                    # <undefined>
print t.trait( 'foo' ).default_kind               # factory
print t.trait( 'foo' ).inner_traits               # ()
print t.trait( 'foo' ).is_trait_type( Instance )  # True
print t.trait( 'foo' ).is_trait_type( List  )     # False

print t.trait( 'any' ).default                    # [1, 2, 3]
print t.trait( 'any' ).default_kind               # list
print t.trait( 'any' ).inner_traits               # ()
print t.trait( 'any' ).is_trait_type( Any )       # True
print t.trait( 'any' ).is_trait_type( List )      # False


########NEW FILE########
__FILENAME__ = minimal
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# minimal.py --- Minimal example of using traits.

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Float, TraitError

#--[Code]-----------------------------------------------------------------------

class Person(HasTraits):
    weight = Float(150.0)

#--[Example*]-------------------------------------------------------------------

# instantiate the class
joe = Person()

# Show the default value
print joe.weight

# Assign new values
joe.weight = 161.9     # OK to assign a float
print joe.weight

joe.weight = 162       # OK to assign an int
print joe.weight

# The following line causes a traceback:
try:
    joe.weight = 'average' # Error to assign a string
    print "You should not see this message."
except TraitError:
    print "You can't assign a string to the 'weight' trait."



########NEW FILE########
__FILENAME__ = object_trait_attrs
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# object_trait_attrs.py --- Example of per-object trait attributes

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Range

#--[Code]-----------------------------------------------------------------------

class GUISlider (HasTraits):

    def __init__(self, eval=None, label='Value',
                 trait=None, min=0.0, max=1.0,
                 initial=None, **traits):
        HasTraits.__init__(self, **traits)
        if trait is None:
            if min > max:
                min, max = max, min
            if initial is None:
                initial = min
            elif not (min <= initial <= max):
                initial = [min, max][
                            abs(initial - min) >
                            abs(initial - max)]
            trait = Range(min, max, value = initial)
        self.add_trait(label, trait)


########NEW FILE########
__FILENAME__ = override_default
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# override_default.py -- Example of overriding a default value for
#                        a trait attribute in a subclass

#--[Imports]--------------------------------------------------------------------

from traits.api \
    import HasTraits, Range, Str

#--[Code]-----------------------------------------------------------------------

# Example of overriding a default value for a trait in a subclass:

# Define the base class:
class Employee ( HasTraits ):

    name         = Str
    salary_grade = Range( value = 1, low = 1, high = 10 )

# Define a subclass:
class Manager ( Employee ):

    # Override the default value for the inherited 'salary_grade' trait:
    salary_grade = 5

#--[Example*]-------------------------------------------------------------------

# Create an employee and display its initial contents:
joe = Employee( name = 'Joe' )
joe.print_traits()

# Now do the same thing for a manager object:
mike = Manager( name = 'Mike' )
mike.print_traits()


########NEW FILE########
__FILENAME__ = prototype_prefix
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# prototype_prefix.py --- Examples of PrototypedFrom() prefix parameter

#--[Imports]--------------------------------------------------------------------
from traits.api import PrototypedFrom, Float, HasTraits, Instance, Str

#--[Code]-----------------------------------------------------------------------

class Parent (HasTraits):
    first_name = Str
    family_name = ''
    favorite_first_name = Str
    child_allowance = Float(1.00)

class Child (HasTraits):
    __prefix__ = 'child_'
    first_name = PrototypedFrom('mother', 'favorite_*')
    last_name  = PrototypedFrom('father', 'family_name')
    allowance  = PrototypedFrom('father', '*')
    father     = Instance(Parent)
    mother     = Instance(Parent)

#--[Example*]-------------------------------------------------------------------

fred = Parent( first_name = 'Fred',
               family_name = 'Lopez',
               favorite_first_name = 'Diego',
               child_allowance = 5.0 )

maria = Parent( first_name = 'Maria',
                family_name = 'Gonzalez',
                favorite_first_name = 'Tomas',
                child_allowance = 10.0 )

nino = Child( father=fred, mother=maria )

print '%s %s gets $%.2f for allowance' % (nino.first_name, nino.last_name, nino.allowance)

########NEW FILE########
__FILENAME__ = scratch_adapter
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# scratch_adapter.py - Example of writing an adapter from scratch

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Instance, adapts
from interface_definition import IName
from interface_implementation import Person

#--[Code]-----------------------------------------------------------------------

class PersonINameAdapter ( HasTraits ):

    # Declare what interfaces this adapter implements,
    # and for what class:
    adapts( Person, IName )

    # Declare the type of client it supports:
    client = Instance( Person )

    # Implement the adapter's constructor:
    def __init__ ( self, client ):
        self.client = client

    # Implement the 'IName' interface on behalf of its client:
    def get_name ( self ):
        return ('%s %s' % ( self.client.first_name,
                            self.client.last_name ))


########NEW FILE########
__FILENAME__ = simple_adapter
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# simple_adapter.py - Example of adaptation using Adapter

#--[Imports]--------------------------------------------------------------------
from traits.api import Adapter, Instance, implements
from interface_definition import IName
from interface_implementation import Person

#--[Code]-----------------------------------------------------------------------

class PersonINameAdapter( Adapter ):

    # Declare what interfaces this adapter implements for its
    # client:
    implements( IName )

    # Declare the type of client it supports:
    adaptee = Instance( Person )

    # Implement the 'IName' interface on behalf of its client:
    def get_name ( self ):
        return ('%s %s' % ( self.adaptee.first_name,
                            self.adaptee.last_name ))


########NEW FILE########
__FILENAME__ = static_notification
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# static_notification.py --- Example of static attribute notification

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Float

#--[Code]-----------------------------------------------------------------------

class Person(HasTraits):
    weight_kg = Float(0.0)
    height_m =  Float(1.0)
    bmi = Float(0.0)

    def _weight_kg_changed(self, old, new):
         print 'weight_kg changed from %s to %s ' % (old, new)
         if self.height_m != 0.0:
             self.bmi = self.weight_kg / (self.height_m**2)

    def _anytrait_changed(self, name, old, new):
         print 'The %s trait changed from %s to %s ' % (name, old, new)

#--[Example*]-------------------------------------------------------------------

bob = Person()
bob.height_m = 1.75
# Output: The height_m trait changed from 1.0 to 1.75
bob.weight_kg = 100.0
# Output:
# The weight_kg trait changed from 0.0 to 100.0
# weight_kg changed from 0.0 to 100.0
# The bmi trait changed from 0.0 to 32.6530612245


########NEW FILE########
__FILENAME__ = temp_wildcard
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# temp_wildcard.py --- Example of using a wildcard with a trait
#                 attribute name

#--[Imports]--------------------------------------------------------------------
from traits.api import Any, HasTraits

#--[Code]-----------------------------------------------------------------------

class Person(HasTraits):
    temp_ = Any

########NEW FILE########
__FILENAME__ = this
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# this.py --- Example of This predefined trait

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, This

#--[Code]-----------------------------------------------------------------------

class Employee(HasTraits):
    manager = This

########NEW FILE########
__FILENAME__ = traitprefixmap
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# traitprefixmap.py --- Example of using the TraitPrefixMap handler

#--[Imports]--------------------------------------------------------------------
from traits.api import Trait, TraitPrefixMap

#--[Code]-----------------------------------------------------------------------
boolean_map = Trait('true', TraitPrefixMap( {
                              'true': 1,
                              'yes':  1,
                              'false': 0,
                              'no':   0 } ) )

########NEW FILE########
__FILENAME__ = trait_reuse
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# trait_reuse.py --- Example of reusing trait definitions

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Range

#--[Code]-----------------------------------------------------------------------
coefficient = Range(-1.0, 1.0, 0.0)

class quadratic(HasTraits):
    c2 = coefficient
    c1 = coefficient
    c0 = coefficient
    x  = Range(-100.0, 100.0, 0.0)

########NEW FILE########
__FILENAME__ = trait_subclass
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# trait_subclass.py -- Example of subclassing a trait class

#--[Imports]--------------------------------------------------------------------
from traits.api import BaseInt

#--[Code]-----------------------------------------------------------------------
class OddInt ( BaseInt ):

    # Define the default value
    default_value = 1

    # Describe the trait type
    info_text = 'an odd integer'

    def validate ( self, object, name, value ):
        value = super(OddInt, self).validate(object, name, value)
        if (value % 2) == 1:
            return value

        self.error( object, name, value )


########NEW FILE########
__FILENAME__ = transient_metadata
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# transient_metadata.py - Example of using 'transient' metadata

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, File, Any

#--[Code]-----------------------------------------------------------------------

class DataBase ( HasTraits ):

    # The name of the data base file:
    file_name = File

    # The open file handle used to access the data base:
    file = Any( transient = True )


########NEW FILE########
__FILENAME__ = use_custom_th
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# use_custom_th.py --- Example of using a custom TraitHandler

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Trait, TraitRange
from custom_traithandler import TraitOddInteger

#--[Code]-----------------------------------------------------------------------
class AnOddClass(HasTraits):
    oddball = Trait(1, TraitOddInteger())
    very_odd = Trait(-1, TraitOddInteger(),
                         TraitRange(-10, -1))

########NEW FILE########
__FILENAME__ = widget
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api import Float, HasTraits, Trait

class Part(HasTraits):
    cost = Trait(0.0)

class Widget(HasTraits):
    part1 = Trait(Part)
    part2 = Trait(Part)
    cost  = Float(0.0)

    def __init__(self):
        self.part1 = Part()
        self.part2 = Part()
        self.part1.on_trait_change(self.update_cost, 'cost')
        self.part2.on_trait_change(self.update_cost, 'cost')

    def update_cost(self):
        self.cost = self.part1.cost + self.part2.cost



########NEW FILE########
__FILENAME__ = wildcard
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# wildcard.py --- Example of using a wildcard with a trait
#                 attribute name
from traits.api import Any, HasTraits

class Person(HasTraits):
    temp_ = Any

########NEW FILE########
__FILENAME__ = wildcard_all
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# wildcard_all.py --- Example of using a wildcard with all trait
#                     attribute names
from traits.api import HasTraits, Any

class Person(HasTraits):
    _ = Any

########NEW FILE########
__FILENAME__ = wildcard_name
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# temp_wildcard.py --- Example of using a wildcard
#                      with a trait attribute name
from traits.api import Any, HasTraits

class Person(HasTraits):
    temp_ = Any

########NEW FILE########
__FILENAME__ = wildcard_rules
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# wildcard_rules.py --- Example of trait attribute wildcard rules

#--[Imports]--------------------------------------------------------------------
from traits.api import Any, HasTraits, Int, Python

#--[Code]-----------------------------------------------------------------------
class Person(HasTraits):
    temp_count = Int(-1)
    temp_      = Any
    _          = Python




########NEW FILE########
__FILENAME__ = wizard
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# wizard.py ---Example of a traits-based wizard UI
from traits.api import HasTraits, Int, Str

class Person(HasTraits):
    name = Str
    age = Int
    street = Str
    city = Str
    state = Str
    pcode = Str

bill = Person()
bill.configure_traits(kind='modal')

########NEW FILE########
__FILENAME__ = cached_property
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(cached_property Decorator)--------------------------------------------------
"""
cached_property Decorator
=========================

New in Traits 3.0 is the *cached_property* method decorator which helps
streamline the process of writing properties which cache their current value.

Defining properties is a very powerful technique for exposing as traits items
whose value depends upon the current state of other object traits. In
particular, this can be very useful for creating synthetic traits which are
editable or displayable in a traits-based user interface.

In some cases however, the cost of computing the current value of a property
may be fairly expensive, so it is often a good idea to *cache* the most recently
computed value of the property, and return it as the value of the property until
one of the traits the property depends upon changes value, at which point the
cache should be cleared and the property value recomputed the next time its
value is requested.

Combined with the **Property** *depends_on* metadata, the *cached_property*
decorator greatly simplifies the process of writing a cached property. Take a
look at the following code for example::

    class TestScores ( HasPrivateTraits ):

        scores  = List( Int )
        average = Property( depends_on = 'scores' )

        @cached_property
        def _get_average ( self ):
            s = self.scores
            return (float( reduce( lambda n1, n2: n1 + n2, s, 0 ) ) / len( s ))

Presumably this is much easier to write and understand that the following
equivalent code written without using *depends_on* and *cached_property*::

    class TestScores ( HasPrivateTraits ):

        scores  = List( Int )
        average = Property

        def _get_average ( self ):
            if self._average is None:
                s = self.scores
                self._average = (float( reduce( lambda n1, n2: n1 + n2, s, 0 ) )
                                 / len( s ))
            return self._average

        def _scores_changed ( self ):
            old, self._average = self._average, None
            self.trait_property_changed( 'average', old, self._average )

        def _scores_items_changed ( self ):
            self._scores_changed()

The *cached_property* decorator takes no arguments, and should simply be
written on the line preceding the property's *getter* method, as shown in the
previous example.

Use of the *cached_property* decorator also eliminates the need to add
*cached = True* metadata to the property declaration, as was previously required
when using *depends_on* metadata with a cached property definition.
"""
#--<Imports>--------------------------------------------------------------------

from traits.api import *
from traitsui.api import *

#--[TestScores Class]-----------------------------------------------------------

class TestScores ( HasPrivateTraits ):

    scores  = List( Int )
    average = Property( depends_on = 'scores' )

    @cached_property
    def _get_average ( self ):
        print "...computing average:",
        s = self.scores
        return (float( reduce( lambda n1, n2: n1 + n2, s, 0 ) ) / len( s ))

#--[Example*]-------------------------------------------------------------------

# Create a sample TestScores object with some sample scores:
test_scores = TestScores( scores = [ 89, 93, 76, 84, 62, 96, 75, 81, 69, 90 ] )

# Display the average:
print 'First average:', test_scores.average
print 'Check that again:', test_scores.average

# Now add a few more late scores into the mix:
test_scores.scores.extend( [ 85, 61, 70 ] )

# And display the new average:
print 'Second average:', test_scores.average

########NEW FILE########
__FILENAME__ = on_trait_change
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(on_trait_change Decorator)--------------------------------------------------
"""
on_trait_change Decorator
=========================

Until Traits 3.0, the only way to define a static trait notification handler
as part of a class definition was to define the method following a certain
naming convention::

    def _name_changed ( self, ... ):
        ...

    or

    def _name_fired ( self, ... ):
        ...

where *name* is the name of the trait to which the notification handler method
applies.

Starting with Traits 3.0, there is now an alternate method for declaring
notification handlers using the **on_trait_change** decorator. The syntax
for the decorator is::

    @on_trait_change( 'extended_trait_name' )
    def any_method_name ( self, ... ):
        ...

where *extended_trait_name* is the name of the trait for which the following
method is the notification handler, and *any_method_name* is an arbitrary
method name, which does not need to follow any particular naming convention.

Although the new syntax is more verbose than the original syntax, it has
several advantages:

- It does not require using special method names.
- It allows using the extended trait naming support added to the
  **on_trait_change** method in Traits 3.0.

The last item is especially important since it allows you to statically
declare notification handlers for many more cases than were previously possible.

For example::

    @on_trait_change( 'foo,bar,baz' )
    def _update ( self ):
        ...perform update logic...

defines an *_update* method that is called whenever the class's *foo*, *bar*
or *baz* traits change. Previously, this would have required writing three
separate notification handlers (one each for the *foo*, *bar* and *baz* traits),
or adding *event* metadata to each of the trait declarations for *foo*, *bar*
and *baz*.

Similarly, the previous technique of writing methods such as::

    def _bar_changed_for_foo ( self, ... ):
        ...

which statically defines a notification handler for changes to the *bar* trait
of the object's *foo* trait can now be written as::

    @on_trait_change( 'foo.bar' )
    def any_method_name ( self, ... ):
        ...

Perhaps even more importantly, this technique can be applied in even more
complex situations, such as::

    @on_trait_change( 'foo.bar.baz' )
    def any_method_name ( self, ... ):
        ...

    or

    @on_trait_change( 'foo.+dirty,foo2.[bar,baz,foogle]' )
    def any_method_name ( self, ... ):
        ...

The first case is a simple extension of the previous example, while the
second is a somewhat far-fetched example which can be interpreted as
defining a method that handles:

- Changes to any trait on the object's *foo* trait which has *dirty* metadata
  defined, or
- Changes to the *bar*, *baz* or *foogle* trait of the object's *foo2* trait.

Note that there is one important semantic difference between writing::

    def _name_changed ( self, ... ):
        ...

and::

    @on_trait_change( 'name' )
    def any_method_name ( self, ... ):
        ...

While both are recognized as being notification handlers for the object's *name*
trait, the interpretation of the argument signature for the first case follows
the static trait change handler pattern, while the second case follows the
dynamic **on_trait_change** method pattern. While this might seem obvious, given
the fact that the decorator is called *on_trait_change*, it is an important
enough difference to note explicitly.

A Complete Example
------------------

Refer to the code tabs of this lesson for a complete example using the
*on_trait_change* decorator. In particular, look at the definition of the
*sick_again* method in the **Corporation Class** tab.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[Employee Class]-------------------------------------------------------------

class Employee ( HasTraits ):

    # The name of the employee:
    name = Str

    # The number of sick days they have taken this year:
    sick_days = Int

#--[Department Class]-----------------------------------------------------------

class Department ( HasTraits ):

    # The name of the department:
    name = Str

    # The employees in the department:
    employees = List( Employee )

#--[Corporation Class]----------------------------------------------------------

class Corporation ( HasTraits ):

    # The name of the corporation:
    name = Str

    # The departments within the corporation:
    departments = List( Department )

    # Define a corporate 'whistle blower' method:
    @on_trait_change( 'departments:employees.sick_days' )
    def sick_again ( self, object, name, old, new ):
        print '%s just took sick day number %d for this year!' % (
              object.name, new )

#--[Example*]-------------------------------------------------------------------

# Create some sample employees:
millie   = Employee( name = 'Millie',   sick_days = 2 )
ralph    = Employee( name = 'Ralph',    sick_days = 3 )
tom      = Employee( name = 'Tom',      sick_days = 1 )
slick    = Employee( name = 'Slick',    sick_days = 16 )
marcelle = Employee( name = 'Marcelle', sick_days = 7 )
reggie   = Employee( name = 'Reggie',   sick_days = 11 )
dave     = Employee( name = 'Dave',     sick_days = 0 )
bob      = Employee( name = 'Bob',      sick_days = 1 )
alphonse = Employee( name = 'Alphonse', sick_days = 5 )

# Create some sample departments:
accounting = Department( name      = 'accounting',
                         employees = [ millie, ralph, tom ] )

sales = Department( name      = 'Sales',
                    employees = [ slick, marcelle, reggie ] )

development = Department( name      = 'Development',
                          employees = [ dave, bob, alphonse ] )

# Create a sample corporation:
acme = Corporation( name        = 'Acme, Inc.',
                    departments = [ accounting, sales, development ] )

# Now let's try out our 'reporting' system:
slick.sick_days  += 1
reggie.sick_days += 1


########NEW FILE########
__FILENAME__ = delegation
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Delegation Fixes and Improvements)------------------------------------------
"""
Delegation Fixes and Improvements
=================================

In previous versions of Traits there were a number of problems (i.e. bugs) in
the delegation support that made delegation virtually unusable in some
situations.

As a result, one of the primary goals of Traits 3.0 was to fix all known
problems with delegation, thus allowing it to reclaim its role as one of the
five keys pillars of the Traits package (those pillars being *initialization*,
*validation*, *notification*, *delegation* and *visualization*).

We are happy to report that not only have all known bugs been fixed, but a
previously unsupported, though often requested, feature has been added as well.

Delegation Event Notification
-----------------------------

Previously, many Traits users implicitly assumed that changes made to a
*delegatee* trait would generate a change notification on any *delegater* trait
(no matter how many such traits there might be). Unfortunately, this was not
the case.

However, starting with Traits 3.0, this feature has now been implemented. An
example of what this means is shown below::

    class Parent ( HasTraits ):

        first_name = Str
        last_name  = Str

    class Child ( HasTraits ):

        mother = Instance( Parent )
        father = Instance( Parent )

        first_name = Str
        last_name  = Delegate( 'father' )

In this example, we've created two classes, **Parent** and **Child**, and the
value of the **Child** class's *last_name* trait delegates its value to its
*father* object's *last_name* trait.

Next, we'll set up a simple set of test objects::

    mom = Parent( first_name = 'Julia', last_name = 'Wilson' )
    dad = Parent( first_name = 'William', last_name = 'Chase' )
    son = Child( mother = mom, father = dad, first_name = 'John' )

Finally, we'll set up a notification handler on the *son* object's *last_name*
trait and then try out various combinations of setting both the *father* and
*son* object's *last_name* trait to see in which cases the notification handler
is called::

    def name_changed ( name ):
        print 'Your last name has been changed to %s.' % name

    # Set up a change notification handler on the son's last name:
    son.on_trait_change( name_changed, 'last_name' )

    # This should cause the son's last name to change as well:
    print "Changing dad's last name to Jones."
    dad.last_name = 'Jones'

    # This change overrides the father's last name for the son:
    print "Changing son's last name to Thomas."
    son.last_name = 'Thomas'

    # This should no longer have any effect on the son's last name:
    print "Changing dad's last name to Riley."
    dad.last_name = 'Riley'

    # Son decides to revert his name back to his father's name:
    print "Reverting son's last name."
    del son.last_name

    # Now changing the father's name should affect the son again:
    print "Changing dad's last name to Simmons."
    dad.last_name = 'Simmons'

For the actual results of running this code, refer to the **Output** tab. Note
that for each case in which an explicit or implicit change is made to the *son*
object's *last_name* trait, a corresponding call is made to the change
notification handler.

"""
# FIXME - this need to be redone without traitsui

#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[Parent Class]---------------------------------------------------------------

class Parent ( HasTraits ):

    first_name = Str
    last_name  = Str

#--[Child Class]----------------------------------------------------------------

class Child ( HasTraits ):

    mother = Instance( Parent )
    father = Instance( Parent )

    first_name = Str
    last_name  = Delegate( 'father' )

#--[Example*]-------------------------------------------------------------------

mom = Parent( first_name = 'Julia', last_name = 'Wilson' )
dad = Parent( first_name = 'William', last_name = 'Chase' )
son = Child( mother = mom, father = dad, first_name = 'John' )

def name_changed ( name ):
    print 'Your last name has been changed to %s.' % name

# Set up a change notification handler on the son's last name:
son.on_trait_change( name_changed, 'last_name' )

# This should cause the son's last name to change as well:
print "Changing dad's last name to Jones."
dad.last_name = 'Jones'

# This change overrides the father's last name for the son:
print "Changing son's last name to Thomas."
son.last_name = 'Thomas'

# This should no longer have any effect on the son's last name:
print "Changing dad's last name to Riley."
dad.last_name = 'Riley'

# Son decides to revert his name back to his father's name:
print "Reverting son's last name."
del son.last_name

# Now changing the father's name should affect the son again:
print "Changing dad's last name to Simmons."
dad.last_name = 'Simmons'

########NEW FILE########
__FILENAME__ = extended_trait_change
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(on_trait_change Method Enhancements)----------------------------------------
"""
on_trait_change Method Enhancements
===================================

In Traits 3.0, the capabilities of the **HasTraits** class's
*on_trait_change* method has been greatly enhanced with the addition of a new
*extended* trait name syntax for specifying the name of the trait the
notification handler applies to.

Previously, the trait name argument to the *on_trait_change* method could only
be one of the following:

Omitted, None, or 'anytrait'
    The notification handler applies to any trait on the object.

name
    The notification handler applies to the trait on the object called *name*.

[ name1, ..., namen ]
    The notification handler applies to each of the traits on the object with
    the specified names.

In Traits 3.0, all of these forms are still supported, but now the syntax for
specifying *name* has been expanded to allow a much broader set of traits that
are *reachable* from the object the *on_trait_change* method is applied to.

New *name* Parameter Syntax
---------------------------

In Traits 3.0, the *name* parameter, in addition to being omitted, None or
*anytrait*, can now be a single *xname* or a list of *xname* names, where
an *xname* is an extended name of the form::

    xname2['.'xname2]*

An *xname2* is of the form::

    ( xname3 | '['xname3[','xname3]*'] ) ['*']

An *xname3* is of the form::

     xname | ['+'|'-'][name] | name['?' | ('+'|'-')[name]]

A *name* is any valid Python attribute name. The semantic meaning of this
notation is as follows:

[ item, item, ..., item ]
    A list which matches any of the specified items. Note that at the topmost
    level, the surrounding square brackets are optional.

name?
    If the current object does not have an attribute called *name*, the
    reference can be ignored. If the '?' character is omitted, the current
    object must have a trait called *name*, otherwise an exception will be
    raised.

prefix+
    Matches any trait on the current object whose name begins with *prefix*.

\+metadata_name
    Matches any trait on the current object having *metadata_name* metadata.

\-metadata_name
    Matches any trait on the current object which does not have *metadata_name*
    metadata.

prefix+metadata_name
    Matches any trait on the current object whose name begins with *prefix* and
    which has *metadata_name* metadata.

prefix-metadata_name
    Matches any trait on the current object whose name begins with *prefix* and
    which does not have *metadata_name* metadata.

\+
    Matches all traits on the current object.

pattern*
    Matches object graphs where *pattern* occurs one or more times (useful for
    setting up listeners on recursive data structures like trees or linked
    lists).

Name Syntax Examples
--------------------

Some examples of valid names and their meaning are as follows:

'foo,bar,baz'
    Listen for trait changes to *object.foo*, *object.bar*, and *object.baz*.

['foo','bar','baz']
    Equivalent to 'foo,bar,baz', but may be more useful in cases where the
    individual items are computed.

'foo.bar.baz'
    Listen for trait changes to *object.foo.bar.baz*.

'foo.[bar,baz]'
    Listen for trait changes to *object.foo.bar* and *object.foo.baz*.

'([left,right]).name'
    Listen for trait changes to the *name* trait of each node of a tree having
    *left* and *right* links to other tree nodes, and where *object* is the
    root node of the tree.

'+dirty'
    Listen for trait changes on any trait in the *object* which has the 'dirty'
    metadata set.

'foo.+dirty'
    Listen for trait changes on any trait in *object.foo* which has the 'dirty'
    metadata set.

'foo.[bar,-dirty]'
    Listen for trait changes on *object.foo.bar* or any trait on *object.foo*
    which does not have 'dirty' metadata set.

Additional Semantic Rules
-------------------------

Note that any of the intermediate (i.e., non-final) links in a pattern can be
traits of type **Instance**, **List** or **Dict**. In the case of **List** and
**Dict** traits, the subsequent portion of the pattern is applied to each item
in the list, or value in the dictionary.

For example, if *self.children* is a list, 'children.name' listens for trait
changes to the *name* trait for each item in the *self.children* list.

Also note that items added to or removed from a list or dictionary in the
pattern will cause the *handler* routine to be invoked as well, since this is
treated as an *implied* change to the item's trait being monitored.

Notification Handler Signatures
-------------------------------

The signature of the *handler* supplied also has an effect on how changes to
intermediate traits are processed. The five valid handler signatures are:

1. handler()
2. handler(new)
3. handler(name,new)
4. handler(object,name,new)
5. handler(object,name,old,new)

For signatures 1, 4 and 5, any change to any element of a path being listened
to invokes the handler with information about the particular element that was
modified (e.g., if the item being  monitored is 'foo.bar.baz', a change to 'bar'
will call *handler* with the following information:

object
    object.foo
name
    bar
old
    old value for object.foo.bar
new
    new value for object.foo.bar

If one of the intermediate links is a **List** or **Dict**, the call to
*handler* may report an *_items* changed event. If in the previous
example, *bar* is a **List**, and a new item is added to *bar*, then
the information passed to *handler* would be:

object
    object.foo
name
    bar_items
old
    **Undefined**
new
    **TraitListEvent** whose *added* trait contains the new item added to *bar*.

For signatures 2 and 3, the *handler* does not receive enough information to
discern between a change to the final trait being listened to and a change to
an intermediate link. In this case, the event dispatcher will attempt to map a
change to an intermediate link to its effective change on the final trait. This
only works if all of the intermediate links are single values (such as an
**Instance** or **Any** trait) and not **Lists** or **Dicts**. If the modified
intermediate trait or any subsequent intermediate trait preceding the final
trait is a **List** or **Dict**, then a **TraitError** is raised, since the
effective value for the final trait cannot in general be resolved unambiguously.

Handler signature 1 also has the special characteristic that if a final trait is
a **List** or **Dict**, it will automatically handle *_items* changed events for
the final trait as well. This can be useful in cases where the *handler* only
needs to know that some aspect of the final trait has been changed. For all
other *handler* signatures, you must explicitly specify the *xxx_items* trait
if you want to be notified of changes to any of the items of the *xxx* trait.

Backward Compatibility
----------------------

The new extended trait name support in Traits 3.0 has one slight semantic
difference with the pre-Traits 3.0 *on_trait_change* method.

Prior to Traits 3.0, it was necessary to make two separate calls to
*on_trait_change* in order to set up listeners on a **List** or **Dict** trait's
value and the contents of its value, as shown in the following example::

    class Department ( HasTraits ):

        employees = List( Employee )

        ...

    a_department.on_trait_change( some_listener, 'employees' )
    a_department.on_trait_change( some_listener_items, 'employees_items' )

In Traits 3.0, this is still the case if the *some_listener* function has one
or more arguments. However, if it has no arguments, the *on_trait_change* method
will automatically call the function either when the trait's value or its
value's contents change. So in Traits 3.0 it is only necessary to write::

    a_department.on_trait_change( some_listener, 'employees' )

if the *some_listener* (and *some_listener_items*) function has no arguments.

The net effect of this difference is that code written prior to Traits 3.0
could set up two listeners (e.g. *some_listener* and *some_listener_items*, as
in the example), and then have *both* methods called when the contents of the
trait are modified if the *some_listener* method takes no arguments. Since no
data is passed to the *some_listener* function, there is probably no harm in
doing this, but it does create unnecessary notification handler calls.

As a result, to avoid creating this unwanted overhead in existing code, the
*on_trait_change* method applies pre-Traits 3.0 semantics to all simple names
passed to it (e.g. 'employees'). If you are writing new code and want to
take advantage of the new Traits 3.0 *on_trait_change* semantics for a simple
trait name, you will need to modify the name to use some recognizable aspect of
the new extended trait name syntax.

For example, either of the following lines would cause *new style* semantics to
be applied to the *employees* trait::

    a_department.on_trait_change( some_listener, ' employees' )

    a_department.on_trait_change( some_listener, '[employees]' )

A Complete Example
------------------

Refer to the code tabs of this lesson for a complete example using
*on_trait_change* with an extended trait name. In particular, check near the
bottom of the **Example** tab for the code that sets up an extended trait change
notification handler using *on_trait_change*.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[Employee Class]-------------------------------------------------------------

class Employee ( HasTraits ):

    # The name of the employee:
    name = Str

    # The number of sick days they have taken this year:
    sick_days = Int

#--[Department Class]-----------------------------------------------------------

class Department ( HasTraits ):

    # The name of the department:
    name = Str

    # The employees in the department:
    employees = List( Employee )

#--[Corporation Class]----------------------------------------------------------

class Corporation ( HasTraits ):

    # The name of the corporation:
    name = Str

    # The departments within the corporation:
    departments = List( Department )

#--[Example*]-------------------------------------------------------------------

# Create some sample employees:
millie   = Employee( name = 'Millie',   sick_days = 2 )
ralph    = Employee( name = 'Ralph',    sick_days = 3 )
tom      = Employee( name = 'Tom',      sick_days = 1 )
slick    = Employee( name = 'Slick',    sick_days = 16 )
marcelle = Employee( name = 'Marcelle', sick_days = 7 )
reggie   = Employee( name = 'Reggie',   sick_days = 11 )
dave     = Employee( name = 'Dave',     sick_days = 0 )
bob      = Employee( name = 'Bob',      sick_days = 1 )
alphonse = Employee( name = 'Alphonse', sick_days = 5 )

# Create some sample departments:
accounting = Department( name      = 'accounting',
                         employees = [ millie, ralph, tom ] )

sales = Department( name      = 'Sales',
                    employees = [ slick, marcelle, reggie ] )

development = Department( name      = 'Development',
                          employees = [ dave, bob, alphonse ] )

# Create a sample corporation:
acme = Corporation( name        = 'Acme, Inc.',
                    departments = [ accounting, sales, development ] )

# Define a corporate 'whistle blower' function:
def sick_again ( object, name, old, new ):
    print '%s just took sick day number %d for this year!' % (
          object.name, new )

# Set up the function as a listener:
acme.on_trait_change( sick_again, 'departments.employees.sick_days' )

# Now let's try it out:
slick.sick_days  += 1
reggie.sick_days += 1


########NEW FILE########
__FILENAME__ = properties
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Extended Property depends_on References)------------------------------------
"""
Extended Property *depends_on* References
=========================================

In Traits 3.0, the **Property** *depends_on* metadata has been extended to
take advantage of the new extended trait name support offered by the
*on_trait_change* method.

Previously, the *depends_on* metadata for a *Property* was restricted to
referencing traits defined either on the same object as the **Property**, or
on an object immediately reachable from the object. For example::

    class Wheel ( Part ):

        axel     = Instance( Axel )
        position = Property( depends_on = 'axel.position' )

        ...

Starting with Traits 3.0, the *depends_on* metadata may now include any
extended trait reference that is allowed by the enhanced *on_trait_change*
method. So, for example it is now legal to write things like::

    class Wheel ( Part ):

        axel     = Instance( Axel )
        position = Property( depends_on = 'axel.chassis.position' )

or::

    class Child ( Person ):

        mother = Instance( Person )
        father = Instance( Person )
        mood   = Property( depends_on = [ 'mother.+mood_affecting',
                                          'father.+mood_affecting' ] )

In particular, in the last example we are declaring that the **Child** class's
*mood* property depends upon the values of any of either its mother or
father object's traits that have *mood_affecting* metadata defined.

Thus, a **Child** object's *mood* property will fire a trait change notification
whenever any of the its mother's or father's mood affecting traits change.

Refer also to the code tabs for this lesson for a complete example using a
**Property** definition using *depends_on* metadata containing an extended trait
reference. In particular, take a look at the **LeagueModelView Class** tab's
*total_hits* trait definition.
"""

# FIXME redo example without traitsui
#--<Imports>--------------------------------------------------------------------

from traits.api \
    import *

from traitsui.api \
    import *

from traitsui.table_column \
    import *

#--[Player Class]---------------------------------------------------------------

# Define a baseball player:
class Player ( HasTraits ):

    # The name of the player:
    name = Str( '<new player>' )

    # The number of hits the player made this season:
    hits = Int

#--[Team Class]-----------------------------------------------------------------

# Define a baseball team:
class Team ( HasTraits ):

    # The name of the team:
    name = Str( '<new team>' )

    # The players on the team:
    players = List( Player )

    # The number of players on the team:
    num_players = Property( depends_on = 'players' )

    def _get_num_players ( self ):
        """ Implementation of the 'num_players' property.
        """
        return len( self.players )

#--[League Class]---------------------------------------------------------------

# Define a baseball league model:
class League ( HasTraits ):

    # The name of the league:
    name = Str( '<new league>' )

    # The teams in the league:
    teams = List( Team )

#--[LeagueModelView Class]-----------------------------------------------------

# Define a ModelView for a League model:
class LeagueModelView ( ModelView ):

    # The currently selected team:
    team = Instance( Team )

    # The currently selected player:
    player = Instance( Player )

    # Button to add a hit to the current player:
    got_hit = Button( 'Got a Hit' )

    # The total number of hits (note the 'depends_on' extended trait reference):
    total_hits = Property( depends_on = 'model.teams.players.hits' )

    @cached_property
    def _get_total_hits ( self ):
        """ Returns the total number of hits across all teams and players.
        """
        return reduce( add, [ reduce( add, [ p.hits for p in t.players ], 0 )
                              for t in self.model.teams ], 0 )

    view = View(
        VGroup(
            HGroup(
                Item( 'total_hits', style = 'readonly' ),
                      label       = 'League Statistics',
                      show_border = True
            ),
            VGroup(
                Item( 'model.teams',
                      show_label = False,
                      editor = TableEditor(
                                columns = [ ObjectColumn( name  = 'name',
                                                          width = 0.70 ),
                                            ObjectColumn( name  = 'num_players',
                                                          label = '# Players',
                                                          editable = False,
                                                          width = 0.29 ) ],
                                selected     = 'object.team',
                                auto_add     = True,
                                row_factory  = Team,
                                configurable = False,
                                sortable     = False )
                ),
                label       = 'League Teams',
                show_border = True
            ),
            VGroup(
                Item( 'object.team.players',
                      show_label = False,
                      editor = TableEditor(
                                   columns  = [ ObjectColumn( name  = 'name',
                                                              width = 0.70 ),
                                                ObjectColumn( name  = 'hits',
                                                              editable = False,
                                                              width = 0.29 ) ],
                                   selected     = 'object.player',
                                   auto_add     = True,
                                   row_factory  = Player,
                                   configurable = False,
                                   sortable     = False )
                ),
                '_',
                HGroup(
                    Item( 'got_hit',
                          show_label   = False,
                          enabled_when = 'player is not None'
                    )
                ),
                label       = 'Team Players',
                show_labels = False,
                show_border = True
            )
        ),
        resizable = True
    )

    def _model_changed ( self, model ):
        """ Handles the 'league' model being initialized.
        """
        if len( model.teams ) > 0:
            self.team = model.teams[0]

    def _got_hit_changed ( self ):
        """ Handles the currently selected player making a hit.
        """
        self.player.hits += 1

    def _team_changed ( self, team ):
        """ Handles a new team being selected.
        """
        if len( team.players ) > 0:
            self.player = team.players[0]
        else:
            self.player = None

# Function to add two numbers (used with 'reduce'):
add = lambda a, b: a + b

#--[Example*]-------------------------------------------------------------------

# Define some sample teams and players:
blue_birds = Team( name = 'Blue Birds', players = [
    Player( name = 'Mike Scott',     hits = 25 ),
    Player( name = 'Willy Shofield', hits = 37 ),
    Player( name = 'Tony Barucci',   hits = 19 ) ] )

chicken_hawks = Team( name = 'Chicken Hawks', players = [
    Player( name = 'Jimmy Domore',   hits = 34 ),
    Player( name = 'Bill Janks',     hits = 16 ),
    Player( name = 'Tim Saunders',   hits = 27 ) ] )

eagles = Team( name = 'Eagles', players = [
    Player( name = 'Joe Peppers',    hits = 33 ),
    Player( name = 'Sam Alone',      hits = 12 ),
    Player( name = 'Roger Clemson',  hits = 23 ) ] )

# Create a league and its corresponding model view:
demo = LeagueModelView(
    League( name  = 'National Baseball Conference',
            teams = [ blue_birds, chicken_hawks, eagles ] )
)


########NEW FILE########
__FILENAME__ = getstate
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(__getstate__/__setstate__ Changes and Improvements)-------------------------
"""
__getstate__/__setstate__ Changes and Improvements
==================================================

Originally, the **HasTraits** class did not define specific *__getstate__* or
*__setstate__* methods for dealing with *pickling* and *unpickling* of
traits-based objects. However, in the course of developing a number of fairly
large-scale applications using Traits, experience has shown that some traits
specific support in this area would be of benefit to most application
developers.

Accordingly, Traits 3.0 introduces *__getstate__* and *__setstate__* methods
that implement several traits aware serialization and deserialization policies.

The *__getstate__* Method
-------------------------

One of the most frequently occurring requirements for serializing an object is
the ability to control which parts of the object's state are saved, and which
parts are discarded.

One typical approach is to define a *__getstate__* method which makes a copy of
the object's *__dict__* attribute and deletes those items which should not be
saved. While this approach works, there are some drawbacks, especially in cases
where heavy use of subclassing is used.

The **HasTraits** *__getstate__* method uses a somewhat different approach by
providing a generic implementation which implements *policies* that developers
can customize through the use of traits *metadata*, in many cases completely
eliminating the need to override or define a *__getstate__* method in their
application classes.

In particular, the **HasTraits** *__getstate__* method saves the value of all
traits which do not have *transient = True* metadata defined. This policy allows
developers to easily mark which trait values should not be saved simply by
adding *transient = True* metadata to them. Besides avoiding having to write a
*__getstate__* method for their class, this approach also provides good
documentation about the *pickling* behavior of the class.

For example::

    class DataBase ( HasTraits ):

        # The name of the data base file:
        file_name = File

        # The open file handle used to access the data base:
        file = Any( transient = True )

In this example, the **DataBase** class's *file* trait has been mark as
*transient* because it normally contains an open file handle used to access a
data base. Since file handles typically cannot be pickled and restored, the file
handle should not be saved as part of the object's persistent state. Normally,
the file handle would be re-opened by application code after the object has been
restored from its persisted state.

Predefined *transient* Traits
-----------------------------

The Traits package automatically assigns *transient = True* metadata to a number
of predefined traits, thus avoiding the need to explicitly mark them as
transient yourself.

The predefined traits marked as *transient* are:

- **Constant**.
- **Event**.
- *read-only* or *write-only* **Property** traits.
- The *xxx_* trait for *mapped* traits.
- All *_xxx* traits for classes that subclass **HasPrivateTraits**.

Also, by default, delegated traits are only saved if they have a local value
which overrides the value defined by its delegate. You can set
*transient = True* on the delegate trait if you do not want its value to ever be
saved.

Overriding *__getstate__*
-------------------------

In general, you should avoid overriding *__getstate__* in subclasses of
**HasTraits**. Instead, mark traits that should not be pickled with
*transient = True* metadata.

However, in cases where this strategy is insufficient, we recommend
overriding *__getstate__* using the follow pattern to remove items that should
not be persisted::

    def __getstate__ ( self ):
        state = super( XXX, self ).__getstate__()

        for key in [ 'foo', 'bar' ]:
            if key in state:
                del state[ key ]

        return state

The *__setstate__* Method
-------------------------

The main difference between the default Python *__setstate__*-like behavior and
the new **HasTraits** class *__setstate__* method is that the **HasTraits**
*__setstate__* method actually *sets* the value of each trait using the values
passed to it via its state dictionary argument instead of simply storing or
copying the state dictionary to its *__dict__* attribute.

While slower, this has the advantage of causing trait change notifications to be
generated, which can be very useful for classes which rely of receiving
notifications in order to ensure that their internal object state remains
consistent and up to date.

Overriding *__setstate__*
-------------------------

For classes which do not want to receive change notifications during
*__setstate__*, it is possible to override *__setstate__* and update the
object's *__dict__* attribute directly.

However, in such cases it is important to either call the *__setstate__* super
method (with an empty state dictionary, for example), or to call the
**HasTraits** class's private *_init_trait_listeners* method directly. This
method has no arguments and does not return a result, but it must be called
during *__setstate__* in order to ensure that all dynamic trait change
notifications managed by traits are correctly initialized for the object.
Failure to call this method may result in lost change notifications.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *

from time import time, sleep

from cPickle import dumps, loads

#--[Session Class]--------------------------------------------------------------

class Session ( HasTraits ):

    # The name of the session:
    name = Str

    # The time the session was created:
    created = Any( transient = True )

    def _name_changed ( self ):
        self.created = time()

#--[Example*]-------------------------------------------------------------------

# The following shows an example of pickling and unpickling a Session object.
# Unfortunately, it is not possible to successfully pickle objects created as
# part of a tutorial, because of problems with pickling objects derived from
# classes dynamically defined using 'exec'. So just use your imagination on this
# one...

# Create a new session:
session = Session( name = 'session_1' )

# Display its contents:
print 'Session name:',    session.name
print 'Session created:', session.created

# # Simulate saving the session to a file/database:
# saved_session = dumps( session )
#
# # Simulate the passage of time (zzzzZZZZ...):
# sleep( 1 )
#
# # Simulate restoring the session from a file/database:
# restored_session = loads( saved_session )
#
# # Display the restored sessions contents (note that the 'created'
# # time should be different from the original session):
# print 'Restored session name:',    restored_session.name
# print 'Restored session created:', restored_session.created



########NEW FILE########
__FILENAME__ = adaptation
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Adaptation)-----------------------------------------------------------------
"""
Adaptation
==========

*Adaptation* is the process of transforming an object that does not implement
a specific interface, or set of interfaces, into one that does.

Defining Adapters
-----------------

In traits, an *adapter* is a special type of class whose role is to *transform*
some type of object which does not implement a specific interface, or set of
interfaces, into one that does.

Traits provides several different ways of writing adapters. We'll begin with
the simplest way, which is to create a subclass of **Adapter**.

Subclassing Adapter
-------------------

The **Adapter** base class is designed specifically for creating adapter classes.
It is actually a very simple class which streamlines the process of creating
new adapter classes by:

- Providing a standard constructor which normally does not need to be
  overridden by subclasses.

- Only requiring use of the **adapts** function to define the adapter.

The standard constructor for the **Adapter** class has the form::

    adapter_subclass_name( object_to_be_adapted )

where *adapter_subclass_name* is the name of the **Adapter** subclass.

The only thing the constructor does is::

    self.adaptee = object_to_be_adapted

which assigns the object being adapted to the *adaptee* trait.

As an adapter writer, the only things you need to add to the subclass definition
are:

- An **adapts** function call declaring which interfaces the adapter class
  implements on behalf of the object it is adapting.

  The form of the **adapts** function is as follows::

    adapts( client_class, interface [, interface2, ..., interfacen] )

- A declaration for the *adaptee* trait (usually as an **Instance** of a
  particular class).

- The actual implementations of the interfaces declared in the **adapts**
  call. Usually the implementation code will be written in terms of the
  adapter class's *adaptee* trait assigned by the class constructor.

The following shows the definition of a simple adapter class::

  from traits.api import Adapter, Instance, implements

  class PersonINameAdapter ( Adapter ):

      # Declare what interfaces this adapter implements for its client:
      adapts( Person, IName )

      # Declare the type of client it supports:
      adaptee = Instance( Person )

      # Implement the 'IName' interface on behalf of its client:
      def get_name ( self ):
          return ('%s %s' % ( self.adaptee.first_name, self.adaptee.last_name ))

Rolling You Own Adapter Classes
-------------------------------

Note that using the **Adapter** base class is simply a convenience. It is not
necessary for an adapter class to derive from **Adapter**. However, if you do
not derive your adapter class from **Adapter**, then it is your responsibility
to provide all of the same information and setup implicitly provided by
**Adapter**.

In particular, in addition to using the *adapts* function to declare the set of
interfaces the class implements for its client object, you must also define the
constructor, or whatever means you define for binding the object to be adapted
to the adapter.

Creating an adapter class from scratch, we can re-write the previous adapter
example as follows::

  from traits.api import HasTraits, Instance, adapts

  class PersonINameAdapter ( HasTraits ):

      # Declare what interfaces this adapter implements, and for who:
      adapts( Person, IName )

      # Declare the type of client it supports:
      client = Instance( Person )

      # Implement the adapter's constructor:
      def __init__ ( self, client ):
          self.client = client

      # Implement the 'IName' interface on behalf of its client:
      def get_name ( self ):
          return ('%s %s' % ( self.client.first_name, self.client.last_name ))

As you can see, the main difference between this example and the last is:

- Explicit implementation of the adapter constructor.

Yet Another Way To Define Adapters
----------------------------------

It is also possible to declare a class to be an adapter class external to the
class definition itself, as shown in the following example::

    class AnotherPersonAdapter ( object ):

        # Implement the adapter's constructor:
        def __init__ ( self, person ):
            self.person = person

        # Implement the 'IName' interface on behalf of its client:
        def get_name ( self ):
            return ('%s %s' % ( self.person.first_name, self.person.last_name ))

    ...

    adapts( AnotherPersonAdapter, Person, IName )

When used in this way, the form of the **adapts** function is::

    adapts( adapter_class, client_class, interface [, interface2, ..., interfacen] )

This form simply inserts the adapter class as the first argument (when
**adapts** is used inside of a class definition, this information is implicitly
available from the class itself).

Using Adapters
--------------

Now for the good part... how do you use adapters?

And the answer is... you don't. At least not explicitly.

In traits, adapters are created automatically whenever you assign an object to
an *interface* **AdaptsTo** or **AdaptedTo** trait and the object being assigned
does not implement the required interface. In this case, if an adapter class
exists that can adapt the specified object to the required interface, an
instance of the adapter class will be created for the object, and the resulting
adapter object is what ends up being assigned to the trait, along with the
original object. When using the **AdaptedTo** trait, the adapter is assigned as
the value of the trait, and the original object is assigned as its *mapped*
value. For the **AdaptsTo** trait, the original object is assigned as the trait
value, and the adapter is assigned as its *mapped* value. In the case where the
object does not require an adapter, the object and adapted value are the same.

Note that it might happen that no adapter class exists that will adapt the
object to the required interface, but a pair, or series, of adapter classes
exist that will together adapt the object to the needed interface. In this case,
the required set of adapters will automatically be created for the object and
the final link in the chain adapter object (the one that actually implements
the required interface for some object class) will be used.

Whenever a situation like this arises, the adapted object used will always
contain the smallest set of available adapter objects needed to adapt the
original object.

The following code shows a simple example of using adaptation::

    # Create a Person object (which does not implement the 'IName' interface):
    william = Person( first_name = 'William', last_name = 'Adams' )

    # Create an apartment, and assign 'renter' the previous object. Since
    # the value of 'renter' must implement 'IName', a 'PersonINameAdapter'
    # object is automatically created and assigned:
    apt = Apartment( renter = william )

    # Verify that the resulting value implements 'IName' correctly:
    print 'Renter is: ', apt.renter.get_name()

    # Check the type of object actually assigned to 'renter':
    print apt.renter

Refer to the **Output** tab for the actual result of running this example.

Controlling Adaptation
----------------------

The **AdaptedTo** and **AdaptsTo** traits are actually subclasses of the
**Instance** trait. Normally, adaptation occurs automatically when values are
assigned to an **AdaptedTo** or **AdaptsTo** trait. However, any of the
**Instance**, **AdaptedTo** and **AdaptsTo** traits allow you to control how
adaptation is performed by means of the *adapt* metadata, which can have one of
the following values:

no
    Adaptation is not allowed (This is the default for the **Instance** trait).

yes
    Adaptation is allowed. If adaptation fails, an exception is raised (This is
    the default for both the **AdaptedTo** and **AdaptsTo** traits).

default
    Adapation is allowed. If adaptation fails, the default value for the trait
    is assigned instead.

As an example of modifying the adaptation behavior of an **AdaptedTo** trait,
we could rewrite the example **Apartment** class as follows::

    class Apartment ( HasTraits ):

        renter = AdaptedTo( IName, adapt = 'no' )

Using this definition, any value assigned to *renter* must itself implement
the **IName** interface, otherwise an exception is raised. Try modifying and
re-running the example code to verify that this is indeed the case.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[IName Interface]------------------------------------------------------------

# Define the 'IName' interface:
class IName ( Interface ):

    def get_name ( self ):
        """ Returns the name of an object. """

#--[Person Class]---------------------------------------------------------------

class Person ( HasTraits ):

    first_name = Str( 'John' )
    last_name  = Str( 'Doe' )

#--[PersonINameAdapter Class]---------------------------------------------------

class PersonINameAdapter ( Adapter ):

    # Declare what interfaces this adapter implements for its client:
    adapts( Person, IName )

    # Declare the type of client it supports:
    adaptee = Instance( Person )

    # Implementation of the 'IName' interface on behalf of its client:
    def get_name ( self ):
        """ Returns the name of an object. """
        return ('%s %s' % ( self.adaptee.first_name, self.adaptee.last_name ))

#--[Apartment Class]------------------------------------------------------------

# Define a class using an object that implements the 'IName' interface:
class Apartment ( HasTraits ):

    renter = AdaptedTo( IName )

#--[Example*]--------------------------------------------------------------------

# Create an object implementing the 'IName' interface:
william = Person( first_name = 'William', last_name = 'Adams' )

# Create an apartment, and assign 'renter' an object implementing 'IName':
apt = Apartment( renter = william )

# Verify that the object works correctly:
print 'Renter is:', apt.renter.get_name()

# Check the type of object actually assigned to 'renter':
print apt.renter


########NEW FILE########
__FILENAME__ = interfaces
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Interfaces)-----------------------------------------------------------------
"""
Interfaces
==========

In Traits 3.0, the ability to define, implement and use *interfaces* has been
added to the package.

Defining Interfaces
-------------------

Interfaces are defined by subclassing from the **Interface** class, as shown
in the example below::

    from traits.api import Interface

    class IName ( Interface ):

        def get_name ( self ):
            " Returns the name of an object. "

This same code is shown in the **IName Interface** tab of the code.

Interface classes are intended mainly as documentation of the methods and
traits that the interface defines, and should not contain any actual
implementation code, although no check is performed to enforce this currently.

Implementing Interfaces
-----------------------

A class declares that it implements one or more interfaces using the
**implements** function, which has the form::

    implements( interface [, interface2, ..., interfacen] )

The semantics of this function is that the class declares that it implements
each of the *interfaces* specified as an argument to **implements**.

Also, the call to **implements** must occur at class scope within the class
definition, as shown in the following example::

    from traits.api import HasTraits, implements

    class Person ( HasTraits ):

        implements( IName )

        ...

Only a single call to **implements** should occur within a class definition.

Refer to the **Person Class** tab in the code for a complete example of using
**implements**.

Note that in the current version, traits does not check to ensure that the
class containing the **implements** function actually implements the interfaces
it says it does.

Using Interfaces
----------------

Being able to define and implement interfaces would be of little use without
the ability to *use* interfaces in your code. In traits, using an interface is
accomplished using the **Instance** trait, as shown in the following example::

    from traits.api import HasTraits, Instance

    class Apartment ( HasTraits ):

        renter = Instance( IName )

Using an interface class in an **Instance** trait definition declares that the
trait only accepts values which are objects that either:

- Implement the specified interface.
- Can be adapted to an object that implements the specified interface.

Additional information on what it means to *adapt* an object to implement an
interface is presented in the next section of the tutorial.

As before, the **Instance** trait can also be used with classes that are not
interfaces, such as::

    from traits.api import HasTraits, Instance

    class Apartment ( HasTraits ):

        renter = Instance( Person )

In this case, the value of the trait must be an object which is an instance of
the specified class or one of its subclasses.
"""
#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[IName Interface]------------------------------------------------------------

# Define the 'IName' interface:
class IName ( Interface ):

    def get_name ( self ):
        """ Returns the name of an object. """

#--[Person Class]---------------------------------------------------------------

class Person ( HasTraits ):

    implements( IName )

    first_name = Str( 'John' )
    last_name  = Str( 'Doe' )

    # Implementation of the 'IName' interface:
    def get_name ( self ):
        """ Returns the name of an object. """
        return ('%s %s' % ( self.first_name, self.last_name ))

#--[Apartment Class]------------------------------------------------------------

# Define a class using an object that implements the 'IName' interface:
class Apartment ( HasTraits ):

    renter = Instance( IName )

#--[Example*]--------------------------------------------------------------------

# Create an object implementing the 'IName' interface:
william = Person( first_name = 'William', last_name = 'Adams' )

# Create an apartment, and assign 'renter' an object implementing 'IName':
apt = Apartment( renter = william )

# Verify that the object works correctly:
print 'Renter is:', apt.renter.get_name()


########NEW FILE########
__FILENAME__ = core_traits
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Rewritten Core Traits)------------------------------------------------------
"""
Rewritten Core Traits
=====================

For several reasons, including the ability to subclass types, many of the
previous core Traits package types have been entirely rewritten as subclasses
of **TraitType**, the new base class for subclassable trait types.

The core trait types which have been rewritten as subclasses of **TraitType**
are:

- Any
- Bool
- CBool
- CComplex
- CInt
- CFloat
- CLong
- Code
- Complex
- CStr
- CUnicode
- Dict
- Directory
- Enum
- Expression
- File
- Float
- HTML
- Instance
- Int
- List
- Long
- Password
- PythonValue
- Range
- Regex
- Str
- String
- Tuple
- Unicode
- WeakRef

This may be useful information if you find yourself in need of creating a new
trait type with behavior similar to any of these core trait types.
"""

########NEW FILE########
__FILENAME__ = new_types
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Creating New Trait Types)---------------------------------------------------
"""
Creating New Trait Types
========================

You create a *new style* trait type by subclassing the **TraitType** class or
one of its subclasses, such as **Float** or **Str**. **TraitType** provides the
infrastructure for creating a trait type and allows subclasses to define
specific methods and class constants used to create either a new trait *type* or
*property*.

In the next section, we'll cover the methods and class constants used to define
a new trait *type*, and in the section following that we'll show how to define
a new trait *property*.

Defining a New Trait Type
-------------------------

The thing that distinguishes a trait *type* from a *property* is the existence
of a *validate* method in the subclass. The *validate* method should have the
following signature:

validate ( self, object, name, value )
    This method validates, coerces, or adapts the specified *value* as the value
    of the *name* trait of the *object* object. This method is called when a
    value is assigned to an object trait that is based on this subclass of
    *TraitType* and the class does not  contain a definition for either the
    *get()* or *set()* methods.

    The method must return the original *value* or any suitably coerced or
    adapted value that is a legal value for the trait. If *value* is  not a
    legal value for the trait, and cannot be coerced or adapted to a legal
    value, the method should either raise a **TraitError** or  call the
    *error()* method to raise a **TraitError** on its behalf.

In addition to *validate*, the subclass can also define the *post_setattr*
method, which should have the following signature:

post_setattr ( self, object, name, value )
    This method allows the trait to do additional processing after *value* has
    been successfully assigned to the *name* trait of the *object* object. For
    most traits there is no additional processing that needs to be done, and
    this method need not be defined. It is normally used for creating *shadow*
    (i.e., *mapped* traits), but other uses may arise as well. This method does
    not need to return a value, and should normally not raise any exceptions.

The subclass can also define a constant default value by setting the class-level
*default_value* attribute to the desired constant value. For example::

    class OddInt ( Int ):

        default_value = 1

        ...

If a non-constant default value is desired, you should override the
**TraitType** class's *get_default_value* method. Refer to the documentation
for the **TraitType** class for more information on what this method does.

If you have a constant string that can be used as the type's *info* value, you
can provide it by simple setting the string as the value of the class-level
*info_text* attribute::

    class OddInt ( Int ):

        info_text = 'an odd integer'

        ...

If you have a type info string which depends upon the internal state of the
trait, then you should override the **TraitType's** *info* method. This method
has no arguments, and should return a string describing the values accepted by
the trait type (e.g. 'an integer in the range from 1 to 5').

If you also have some type specific initialization that needs to be performed
when the trait type is created, you can also override the **TraitType** class's
*init* method. This method has no arguments and is automatically called from
the **TraitType** class constructor.

If you would like to specify a default Traits UI editor for your new trait type,
you can also override the **TraitType** class's *create_editor* method, which
has no arguments and should return the default **TraitEditor** for any
instances of the type to use.

This provides a basic overview of the basic methods and class constants needed
to define a new trait type. Refer to the complete documentation for the
**TraitType** and **BaseTraitHandler** classes for more information on other
methods that can be overridden if necessary.

Defining a New Trait Property
-----------------------------

You can also define new trait *properties* by subclassing from **TraitType** or
one of its subclasses. A *property* is distinguished from a *type* by the
existence of a *get* and/or *set* method in the **TraitType** subclass. The
signature for these two methods is as follows:

get ( self, object, name )
    This is the *getter* method of a trait that behaves like a property. It has
    the following arguments:

    object
        The object that the property applies to.
    name
        The name of the *object* property.

    If this method is not defined, but the *set* method is defined, the trait
    behaves like a *write-only* property. This method should return the value of
    the *name* property for the *object* object.

set ( self, object, name, value )
    This is the *setter* method of a trait that behaves like a property. It has
    the following arguments:

    object
        The object the property applies to.
    name
        The name of the property on *object*.
    value
        The value being assigned as the value of the property.

    If this method is not defined, but the *get* method is defined, the trait
    behaves like a *read-only* property. This method does not need to return a
    value, but it should raise a **TraitError** exception if the specified
    *value* is not valid and cannot be  coerced or adapted to a valid value.

Because the value of a *property* is determined by the *get* method, the
*default_value* class constant and *get_default_value* method are not used.

However, all other values and methods, such as the *info_text* class attribute
and *info* method apply to a *property* as well as a normal type. Please refer
to the preceding section on defining a trait type for additional information
that applies to properties as well.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[DiceRoll Type]--------------------------------------------------------------

# Define a type whose value represents the roll of a pair of dice:
class DiceRoll ( TraitType ):

    # Set default value to 'snake-eyes':
    default_value = ( 1, 1 )

    # Describe the type:
    info_text = ('a tuple of the form (n,m), where both n and m are integers '
                 'in the range from 1 to 6 representing a roll of a pair of '
                 'dice')

    # Validate any value assigned to the trait to make sure it is a valid
    # dice roll:
    def validate ( self, object, name, value ):
        if (isinstance( value, tuple ) and (len( value ) == 2) and
            (1 <= value[0] <= 6) and (1 <= value[1] <= 6)):
            return value

        self.error( object, name, value )

#--[RandInt Property]-----------------------------------------------------------

from random import randint

# Define a read-only property whose value is a random integer in a specified
# range:
class RandInt ( TraitType ):

    # Define the type's constructor:
    def __init__( self, low = 1, high = 10, **metadata ):
        super( RandInt, self ).__init__( **metadata )
        self.low  = int( low )
        self.high = int( high )

    # Define the property's getter:
    def get ( self ):
        return randint( self.low, self.high )

    # Define the type's type information:
    def info ( self ):
        return ('a random integer in the range from %d to %d' %
                ( self.low, self.high))

#--[Craps Class]----------------------------------------------------------------

# Define a test class containing both new trait types/properties:
class Craps ( HasTraits ):

    rolls = List( DiceRoll )
    die   = RandInt( 1, 6 )

#--[Example*]--------------------------------------------------------------------

# Create a test object:
craps = Craps()

# Add a number of test dice rolls:
for i in range( 10 ):
    craps.rolls.append( ( craps.die, craps.die ) )

# Display the results:
print craps.rolls

# Try to assign an invalid dice roll:
try:
    craps.rolls.append( ( 0, 0 ) )
except TraitError:
    print 'Assigning an invalid dice roll failed.'

########NEW FILE########
__FILENAME__ = trait_types
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(New Trait Definition Style)-------------------------------------------------
"""
New Trait Definition Style
==========================

The Traits package comes with a number of predefined traits, such as **Str**,
**Int**, **Float**, **Range** and so on. While these core traits suffice for
most common programming situations, quite often the need arises to create a
new *custom* trait.

Traits has always supported creating new traits, but in the past this has
typically involved creating a new **TraitHandler** subclass and invoking the
**Trait** function to define a new trait based on that subclass, as shown in
the following example::

    class OddIntHandler ( TraitHandler ):

        def validate ( self, object, name, value ):
            if isinstance( value, int ) and ((value % 2) == 1):
                return value

            self.error( object, name, value )

        def info ( self ):
            return 'an odd integer'

    OddInt = Trait( 1, OddIntHandler )

    OddInt = TraitFactory( OddInt )

While not overly complex, nevertheless several developers have complained that
that:

- The process of creating a new trait is not overly intuitive.
- The resulting trait cannot be subclassed to derive a new trait with slightly
  different behavior.

As a result, in Traits 3.0 a new method of defining traits has been added that
hopefully addresses both of these issues. Note that this new style of creating
traits does not replace the old style of creating traits, but is simply a new
technique that can be used instead of the original method. Both old and new
style traits can be defined, used and interoperate in the same program without
any adverse side effects.

OddInt Redux
------------

Using the new style of defining traits, we can rewrite our previous **OddInt**
example as follows::

    class OddInt ( Int ):

        # Define the default value:
        default_value = 1

        # Describe the trait type:
        info_text = 'an odd integer'

        def validate ( self, object, name, value ):
            value = super( OddInt, self ).validate( object, name, value )
            if (value % 2) == 1:
                return value

            self.error( object, name, value )

This provides the exact same functionality as the previous definition of
**OddInt**. There are several points to make about the new definition however:

- The **OddInt** class derives from **Int** (not **TraitHandler**). This
  has several important side effects:

  * **OddInt** can re-use and change any part of the **Int** class behavior
    that it needs to. Note in this case the re-use of the **Int** class's
    *validate* method via the *super* call in **OddInt's** *validate* method.

  * As a subclass of **Int**, it is related to **Int**, which can be
    important both from a documentation and programming point of view. The
    original definition of **OddInt** was related to **Int** only in that their
    names were similar.

- The default value and trait description information are declared as class
  constants. Although there are more dynamic techniques that allow computing
  these values (which will be described in another tutorials), this provides
  a very simple means of defining these values.

- No use of **TraitHandler**, **Trait** or **TraitFactory** is required, just
  good old OO programming techniques. Hopefully this will make the process of
  creating a new trait type a little more understandable to a wider group of
  developers.
"""
#--<Imports>--------------------------------------------------------------------

from traits.api import *

#--[OddInt Definition]----------------------------------------------------------

class OddInt ( Int ):

    # Define the default value:
    default_value = 1

    # Describe the trait type:
    info_text = 'an odd integer'

    def validate ( self, object, name, value ):
        value = super( OddInt, self ).validate( object, name, value )
        if (value % 2) == 1:
            return value

        self.error( object, name, value )

#--[Test Class]-----------------------------------------------------------------

class Test ( HasTraits ):

    any_int = Int
    odd_int = OddInt

#--[Example*]-------------------------------------------------------------------

# Create a test object:
t = Test()

# Set both traits to an odd integer value:
t.any_int = 1
print "t.any_int:", t.any_int

t.odd_int = 1
print "t.odd_int:", t.odd_int

# Now set them both to an even value (and see what happens):
t.any_int = 2
print "t.any_int:", t.any_int

t.odd_int = 2
print "t.odd_int:", t.odd_int # Should never get here!


########NEW FILE########
__FILENAME__ = tutor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/30/2007
#
#  fixme:
#  - Get custom tree view images.
#  - Write a program to create a directory structure from a lesson plan file.
#
#-------------------------------------------------------------------------------

""" A framework for creating interactive Python tutorials.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import sys
import os
import re

from string \
    import capwords

from traits.api \
    import HasPrivateTraits, HasTraits, File, Directory, Instance, Int, Str, \
           List, Bool, Dict, Any, Property, Delegate, Button, cached_property

from traitsui.api \
    import View, VGroup, HGroup, VSplit, HSplit, Tabbed, Item, Heading, \
           Handler, ListEditor, CodeEditor, EnumEditor, HTMLEditor, \
           TreeEditor, TitleEditor, ValueEditor, ShellEditor

from traitsui.menu \
    import NoButtons

from traitsui.tree_node \
    import TreeNode

from pyface.image_resource \
    import ImageResource

try:
    from traitsui.wx.extra.windows.ie_html_editor \
        import IEHTMLEditor

    from traitsui.wx.extra.windows.flash_editor \
        import FlashEditor
except:
    IEHTMLEditor = FlashEditor = None

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Correct program usage information:
Usage = """
Correct usage is: tutor.py [root_dir]
where:
    root_dir = Path to root of the tutorial tree

If omitted, 'root_dir' defaults to the current directory."""

# The standard list editor used:
list_editor = ListEditor(
    use_notebook = True,
    deletable    = False,
    page_name    = '.title',
    export       = 'DockWindowShell',
    dock_style   = 'fixed'
)

# The standard code snippet editor used:
snippet_editor = ListEditor(
    use_notebook = True,
    deletable    = False,
    page_name    = '.title',
    export       = 'DockWindowShell',
    dock_style   = 'tab',
    selected     = 'snippet'
)

# Regular expressions used to match section directories:
dir_pat1 = re.compile( r'^(\d\d\d\d)_(.*)$' )
dir_pat2 = re.compile( r'^(.*)_(\d+\.\d+)$' )

# Regular expression used to match section header in a Python source file:
section_pat1 = re.compile( r'^#-*\[(.*)\]' )  # Normal
section_pat2 = re.compile( r'^#-*<(.*)>' )    # Hidden
section_pat3 = re.compile( r'^#-*\((.*)\)' )  # Description

# Regular expression used to extract item titles from URLs:
url_pat1 = re.compile( r'^(.*)\[(.*)\](.*)$' )  # Normal

# Is this running on the Windows platform?
is_windows = (sys.platform in ( 'win32', 'win64' ))

# Python file section types:
IsCode        = 0
IsHiddenCode  = 1
IsDescription = 2

# HTML template for a default lecture:
DefaultLecture = """<html>
  <head>
  </head>
  <body>
    <p>This section contains the following topics:</p>
    <ul>
    %s
    </ul>
  </body>
</html>
"""

# HTML template for displaying a .wmv/.avi movie file:
WMVMovieTemplate = """<html>
<head>
</head>
<body>
<p><object classid="clsid:22D6F312-B0F6-11D0-94AB-0080C74C7E95" codebase="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,5,715">
<param name="FileName" value="%s">
<param name="AutoStart" value="true">
<param name="ShowTracker" value="true">
<param name="ShowControls" value="true">
<param name="ShowGotoBar" value="false">
<param name="ShowDisplay" value="false">
<param name="ShowStatusBar" value="false">
<param name="AutoSize" value="true">
<embed src="%s" AutoStart="true" ShowTracker="true" ShowControls="true" ShowGotoBar="false" ShowDisplay="false" ShowStatusBar="false" AutoSize="true" pluginspage="http://www.microsoft.com/windows/windowsmedia/download/"></object></p>
</body>
</html>
"""

# HTML template for displaying a QuickTime.mov movie file:
QTMovieTemplate = """<html>
<head>
</head>
<body>
<p><object classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" codebase="http://www.apple.com/qtactivex/qtplugin.cab" width="100%%" height="100%%">
<param name="src" value="file:///%s">
<param name="scale" value="aspect">
<param name="autoplay" value="true">
<param name="loop" value="false">
<param name="controller" value="true">
<embed src="file:///%s" width="100%%" height="100%%" scale="aspect" autoplay="true" loop="false" controller="true" pluginspage="http://www.apple.com/quicktime/download"></object></p>
</body>
</html>
"""

# HTML template for displaying an image file:
ImageTemplate = """<html>
<head>
</head>
<body>
<img src="%s">
</body>
</html>
"""

# HTML template for playing an MP3 audio file:
MP3Template = """<html>
<head>
<bgsound src="%s">
</head>
<body>
<p>&nbsp;</p>
</body>
</html>
"""

#-------------------------------------------------------------------------------
#  Returns the contents of a specified text file (or None):
#-------------------------------------------------------------------------------

def read_file ( path, mode = 'rb' ):
    """ Returns the contents of a specified text file (or None).
        """
    fh = result = None

    try:
        fh     = file( path, mode )
        result = fh.read()
    except:
        pass

    if fh is not None:
        try:
            fh.close()
        except:
            pass

    return result

#-------------------------------------------------------------------------------
#  Creates a title from a specified string:
#-------------------------------------------------------------------------------

def title_for ( title ):
    """ Creates a title from a specified string.
    """
    return capwords( title.replace( '_', ' ' ) )

#-------------------------------------------------------------------------------
#  Returns a relative CSS style sheet path for a specified path and parent
#  section:
#-------------------------------------------------------------------------------

def css_path_for ( path, parent ):
    """ Returns a relative CSS style sheet path for a specified path and parent
        section.
    """
    if os.path.isfile( os.path.join( path, 'default.css' ) ):
        return 'default.css'

    if parent is not None:
        result = parent.css_path
        if result != '':
            if path != parent.path:
                result = os.path.join( '..', result )

            return result

    return ''

#-------------------------------------------------------------------------------
#  'StdOut' class:
#-------------------------------------------------------------------------------

class StdOut ( object ):
    """ Simulate stdout, but redirect the output to the 'output' string
        supplied by some 'owner' object.
    """

    def __init__ ( self, owner ):
        self.owner = owner

    def write ( self, data ):
        """ Adds the specified data to the output log.
        """
        self.owner.output += data

    def flush ( self ):
        """ Flushes all current data to the output log.
        """
        pass

#-------------------------------------------------------------------------------
#  'NoDemo' class:
#-------------------------------------------------------------------------------

class NoDemo ( HasPrivateTraits ):

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Heading( 'No demo defined for this lab.' ),
        resizable = True
    )

#-------------------------------------------------------------------------------
#  'DemoPane' class:
#-------------------------------------------------------------------------------

class DemoPane ( HasPrivateTraits ):
    """ Displays the contents of a Python lab's *demo* value.
    """

    #-- Trait Definitions ------------------------------------------------------

    demo = Instance( HasTraits, factory = NoDemo )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'demo',
              id         = 'demo',
              show_label = False,
              style      = 'custom',
              resizable  = True
        ),
        id        = 'enthought.tutor.demo',
        resizable = True
    )

#-------------------------------------------------------------------------------
#  'ATutorialItem' class:
#-------------------------------------------------------------------------------

class ATutorialItem ( HasPrivateTraits ):
    """ Defines the abstract base class for each type of item (HTML, Flash,
        text, code) displayed within the tutor.
    """

    #-- Traits Definitions -----------------------------------------------------

    # The title for the item:
    title = Str

    # The path to the item:
    path = File

    # The displayable content for the item:
    content = Property

#-------------------------------------------------------------------------------
#  'ADescriptionItem' class:
#-------------------------------------------------------------------------------

class ADescriptionItem ( ATutorialItem ):
    """ Defines a common base class for all description items.
    """

    #-- Event Handlers ---------------------------------------------------------

    def _path_changed ( self, path ):
        """ Sets the title for the item based on the item's path name.
        """
        self.title = title_for( os.path.splitext( os.path.basename(
                                                  path ) )[0] )

#-------------------------------------------------------------------------------
#  'HTMLItem' class:
#-------------------------------------------------------------------------------

class HTMLItem ( ADescriptionItem ):
    """ Defines a class used for displaying a single HTML page within the tutor
        using the default Traits HTML editor.
    """

    #-- Traits Definitions -----------------------------------------------------

    url = Str

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = HTMLEditor()
        )
    )

    #-- Event Handlers ---------------------------------------------------------

    def _url_changed ( self, url ):
        """ Sets the item title when the 'url' is changed.
        """
        match = url_pat1.match( url )
        if match is not None:
            title = match.group(2).strip()
        else:
            title = url.strip()
            col   = title.rfind( '/' )
            if col >= 0:
                title = os.path.splitext( title[ col + 1: ] )[0]

        self.title = title

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_content ( self ):
        """ Returns the item content.
        """
        url = self.url
        if url != '':
            match = url_pat1.match( url )
            if match is not None:
                url = match.group(1) + match.group(3)

            return url

        return read_file( self.path )

    def _set_content ( self, content ):
        """ Sets the item content.
        """
        self._content = content

#-------------------------------------------------------------------------------
#  'HTMLStrItem' class:
#-------------------------------------------------------------------------------

class HTMLStrItem ( HTMLItem ):
    """ Defines a class used for displaying a single HTML text string within
        the tutor using the default Traits HTML editor.
    """

    # Make the content a real trait rather than a property:
    content = Str

#-------------------------------------------------------------------------------
#  'IEHTMLItem' class:
#-------------------------------------------------------------------------------

class IEHTMLItem ( HTMLItem ):
    """ Defines a class used for displaying a single HTML page within the tutor
        using the Traits Internet Explorer HTML editor.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = IEHTMLEditor()
        )
    )

#-------------------------------------------------------------------------------
#  'IEHTMLStrItem' class:
#-------------------------------------------------------------------------------

class IEHTMLStrItem ( IEHTMLItem ):
    """ Defines a class used for displaying a single HTML text string within
        the tutor using the Traits Internet Explorer HTML editor.
    """

    # Make the content a real trait rather than a property:
    content = Str

#-------------------------------------------------------------------------------
#  'FlashItem' class:
#-------------------------------------------------------------------------------

class FlashItem ( HTMLItem ):
    """ Defines a class used for displaying a Flash-based animation or video
        within the tutor.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = FlashEditor()
        )
    )

#-------------------------------------------------------------------------------
#  'TextItem' class:
#-------------------------------------------------------------------------------

class TextItem ( ADescriptionItem ):
    """ Defines a class used for displaying a text file within the tutor.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = CodeEditor( show_line_numbers = False,
                                       selected_color    = 0xFFFFFF )
        )
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_content ( self ):
        """ Returns the item content.
        """
        return read_file( self.path )

#-------------------------------------------------------------------------------
#  'TextStrItem' class:
#-------------------------------------------------------------------------------

class TextStrItem ( TextItem ):
    """ Defines a class used for displaying a text file within the tutor.
    """

    # Make the content a real trait, rather than a property:
    content = Str

#-------------------------------------------------------------------------------
#  'CodeItem' class:
#-------------------------------------------------------------------------------

class CodeItem ( ATutorialItem ):
    """ Defines a class used for displaying a Python source code fragment
        within the tutor.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The displayable content for the item (override):
    content = Str

    # The starting line of the code snippet within the original file:
    start_line = Int

    # The currently selected line:
    selected_line = Int

    # Should this section normally be hidden?
    hidden = Bool

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'custom',
              show_label = False,
              editor     = CodeEditor( selected_line = 'selected_line' )
        )
    )

#-------------------------------------------------------------------------------
#  'ASection' abstract base class:
#-------------------------------------------------------------------------------

class ASection ( HasPrivateTraits ):
    """ Defines an abstract base class for a single section of a tutorial.
    """

    #-- Traits Definitions -----------------------------------------------------

    # The title of the section:
    title = Str

    # The path to this section:
    path = Directory

    # The parent section of this section (if any):
    parent = Instance( 'ASection' )

    # Optional table of contents (can be used to define/locate the subsections):
    toc = List( Str )

    # The path to the CSS style sheet to use for this section:
    css_path = Property

    # The list of subsections contained in this section:
    subsections = Property # List( ASection )

    # This section can be executed:
    is_runnable = Bool( True )

    # Should the Python code be automatically executed on start-up?
    auto_run = Bool( False )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_subsections ( self ):
        """ Returns the subsections for this section:
        """
        if len( self.toc ) > 0:
            self._load_toc()
        else:
            self._load_dirs()

        # Return the cached list of sections:
        return self._subsections

    @cached_property
    def _get_css_path ( self ):
        """ Returns the path to the CSS style sheet for this section.
        """
        return css_path_for( self.path, self.parent )

    #-- Private Methods --------------------------------------------------------

    def _load_dirs ( self ):
        """ Defines the section's subsections by analyzing all of the section's
            sub-directories.
        """
        # No value cached yet:
        dirs = []
        path = self.path

        # Find every sub-directory whose name begins with a number of the
        # form ddd, or ends with a number of the form _ddd.ddd (used for
        # sorting them into the correct presentation order):
        for name in os.listdir( path ):
            dir = os.path.join( path, name )
            if os.path.isdir( dir ):
               match = dir_pat1.match( name )
               if match is not None:
                   dirs.append( ( float( match.group(1) ),
                                  match.group(2), dir ) )
               else:
                   match = dir_pat2.match( name )
                   if match is not None:
                       dirs.append( ( float( match.group(2) ),
                                      match.group(1), dir ) )

        # Sort the directories by their index value:
        dirs.sort( lambda l, r: cmp( l[0], r[0] ) )

        # Create the appropriate type of section for each valid directory:
        self._subsections = [
            sf.section for sf in [
                SectionFactory( title  = title_for( title ),
                                parent = self ).set(
                                path   = dir )
                for index, title, dir in dirs
            ] if sf.section is not None
        ]

    def _load_toc ( self ):
        """ Defines the section's subsections by finding matches for the items
            defined in the section's table of contents.
        """
        toc         = self.toc
        base_names  = [ item.split( ':', 1 )[0] for item in toc ]
        subsections = [ None ] * len( base_names )
        path        = self.path

        # Classify all file names that match a base name in the table of
        # contents:
        for name in os.listdir( path ):
            try:
                base_name = os.path.splitext( os.path.basename( name ) )[0]
                index     = base_names.index( base_name )
                if subsections[ index ] is None:
                    subsections[ index ] = []
                subsections[ index ].append( name )
            except:
                pass

        # Try to convert each group of names into a section:
        for i, names in enumerate( subsections ):

            # Only process items for which we found at least one matching file
            # name:
            if names is not None:

                # Get the title for the section from its table of contents
                # entry:
                parts = toc[i].split( ':', 1 )
                if len( parts ) == 1:
                    title = title_for( parts[0].strip() )
                else:
                    title = parts[1].strip()

                # Handle an item with one file which is a directory as a normal
                # section:
                if len( names ) == 1:
                    dir = os.path.join( path, names[0] )
                    if os.path.isdir( dir ):
                        subsections[i] = SectionFactory( title  = title,
                                                         parent = self ).set(
                                                         path   = dir ).section
                        continue

                # Otherwise, create a section from the list of matching files:
                subsections[i] = SectionFactory( title  = title,
                                                 parent = self,
                                                 files  = names ).set(
                                                 path   = path ).section

        # Set the subsections to the non-None values that are left:
        self._subsections = [ subsection for subsection in subsections
                                         if subsection is not None ]

#-------------------------------------------------------------------------------
#  'Lecture' class:
#-------------------------------------------------------------------------------

class Lecture ( ASection ):
    """ Defines a lecture, which is a section of a tutorial with descriptive
        information, but no associated Python code. Can be used to provide
        course overviews, introductory sections, or lead-ins to follow-on
        lessons or labs.
    """

    #-- Trait Definitions-------------------------------------------------------

    # The list of descriptive items for the lecture:
    descriptions = List( ATutorialItem )

    # This section can be executed (override):
    is_runnable = False

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'descriptions',
              style      = 'custom',
              show_label = False,
              editor     = list_editor
        ),
        id = 'enthought.tutor.lecture'
    )

#-------------------------------------------------------------------------------
#  'LabHandler' class:
#-------------------------------------------------------------------------------

class LabHandler ( Handler ):
    """ Defines the controller functions for the Lab view.
    """

    def init ( self, info ):
        """ Handles initialization of the view.
        """
        # Run the associated Python code if the 'auto-run' feature is enabled:
        if info.object.auto_run:
            info.object.run_code()

#-------------------------------------------------------------------------------
#  'Lab' class:
#-------------------------------------------------------------------------------

class Lab ( ASection ):
    """ Defines a lab, which is a section of a tutorial with only Python code.
        This type of section might typically follow a lecture which introduced
        the code being worked on in the lab.
    """

    #-- Trait Definitions-------------------------------------------------------

    # The set-up code (if any) for the lab:
    setup = Instance( CodeItem )

    # The list of code items for the lab:
    snippets = List( CodeItem )

    # The list of visible code items for the lab:
    visible_snippets = Property( depends_on = 'visible', cached = True )

    # The currently selected snippet:
    snippet = Instance( CodeItem )

    # Should normally hidden code items be shown?
    visible = Bool( False )

    # The dictionary containing the items from the Python code execution:
    values = Dict #Any( {} )

    # The run Python code button:
    run = Button( image = ImageResource( 'run' ), height_padding = 1 )

    # User error message:
    message = Str

    # The output produced while the program is running:
    output = Str

    # The current demo pane (if any):
    demo = Instance( DemoPane, () )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VSplit(
            VGroup(
                Item( 'visible_snippets',
                      style      = 'custom',
                      show_label = False,
                      editor     = snippet_editor
                ),
                HGroup(
                    Item( 'run',
                          style      = 'custom',
                          show_label = False,
                          tooltip    = 'Run the Python code'
                    ),
                    '_',
                    Item( 'message',
                          springy    = True,
                          show_label = False,
                          editor     = TitleEditor()
                    ),
                    '_',
                    Item( 'visible',
                          label = 'View hidden sections'
                    )
                ),
            ),
            Tabbed(
                Item( 'values',
                      id     = 'values_1',
                      label  = 'Shell',
                      editor = ShellEditor( share = True ),
                      dock   = 'tab',
                      export = 'DockWindowShell'
                ),
                Item( 'values',
                      id     = 'values_2',
                      editor = ValueEditor(),
                      dock   = 'tab',
                      export = 'DockWindowShell'
                ),
                Item( 'output',
                      style  = 'readonly',
                      editor = CodeEditor( show_line_numbers = False,
                                           selected_color    = 0xFFFFFF ),
                      dock   = 'tab',
                      export = 'DockWindowShell'
                ),
                Item( 'demo',
                      id        = 'demo',
                      style     = 'custom',
                      resizable = True,
                      dock      = 'tab',
                      export    = 'DockWindowShell'
                ),
                show_labels = False,
            ),
            id = 'splitter',
        ),
        id      = 'enthought.tutor.lab',
        handler = LabHandler
    )

    #-- Event Handlers ---------------------------------------------------------

    def _run_changed ( self ):
        """ Runs the current set of snippet code.
        """
        self.run_code()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_visible_snippets ( self ):
        """ Returns the list of code items that are currently visible.
        """
        if self.visible:
            return self.snippets

        return [ snippet for snippet in self.snippets if (not snippet.hidden) ]

    #-- Public Methods ---------------------------------------------------------

    def run_code ( self ):
        """ Runs all of the code snippets associated with the section.
        """
        # Reconstruct the lab code from the current set of code snippets:
        start_line = 1
        module     = ''
        for snippet in self.snippets:
            snippet.start_line = start_line
            module      = '%s\n\n%s' % ( module, snippet.content )
            start_line += (snippet.content.count( '\n' ) + 2)

        # Reset any syntax error and message log values:
        self.message   = self.output = ''

        # Redirect standard out and error to the message log:
        stdout, stderr = sys.stdout, sys.stderr
        sys.stdout     = sys.stderr = StdOut( self )

        try:
            try:
                # Get the execution context dictionary:
                values = self.values

                # Clear out any special variables defined by the last run:
                for name in ( 'demo', 'popup' ):
                    if isinstance( values.get( name ), HasTraits ):
                        del values[ name ]

                # Execute the current lab code:
                exec module[2:] in values, values

                # fixme: Hack trying to update the Traits UI view of the dict.
                self.values = {}
                self.values = values

                # Handle a 'demo' value being defined:
                demo = values.get( 'demo' )
                if not isinstance( demo, HasTraits ):
                    demo = NoDemo()
                self.demo.demo = demo

                # Handle a 'popup' value being defined:
                popup = values.get( 'popup' )
                if isinstance( popup, HasTraits ):
                    popup.edit_traits( kind = 'livemodal' )

            except SyntaxError, excp:
                # Convert the line number of the syntax error from one in the
                # composite module to one in the appropriate code snippet:
                line = excp.lineno
                if line is not None:
                    snippet = self.snippets[0]
                    for s in self.snippets:
                        if s.start_line > line:
                            break
                        snippet = s
                    line -= (snippet.start_line - 1)

                    # Highlight the line in error:
                    snippet.selected_line = line

                    # Select the correct code snippet:
                    self.snippet = snippet

                    # Display the syntax error message:
                    self.message = '%s in column %s of line %s' % (
                                   excp.msg.capitalize(), excp.offset, line )
                else:
                    # Display the syntax error message without line # info:
                    self.message = excp.msg.capitalize()
            except:
                import traceback
                traceback.print_exc()
        finally:
            # Restore standard out and error to their original values:
            sys.stdout, sys.stderr = stdout, stderr

#-------------------------------------------------------------------------------
#  'Lesson' class:
#-------------------------------------------------------------------------------

class Lesson ( Lab ):
    """ Defines a lesson, which is a section of a tutorial with both descriptive
        information and associated Python code.
    """

    #-- Trait Definitions-------------------------------------------------------

    # The list of descriptive items for the lesson:
    descriptions = List( ATutorialItem )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HSplit(
            Item( 'descriptions',
                  label      = 'Lesson',
                  style      = 'custom',
                  show_label = False,
                  dock       = 'horizontal',
                  editor     = list_editor
            ),
            VSplit(
                VGroup(
                    Item( 'visible_snippets',
                          style      = 'custom',
                          show_label = False,
                          editor     = snippet_editor
                    ),
                    HGroup(
                        Item( 'run',
                              style      = 'custom',
                              show_label = False,
                              tooltip    = 'Run the Python code'
                        ),
                        '_',
                        Item( 'message',
                              springy    = True,
                              show_label = False,
                              editor     = TitleEditor()
                        ),
                        '_',
                        Item( 'visible',
                              label = 'View hidden sections'
                        )
                    ),
                    label = 'Lab',
                    dock  = 'horizontal'
                ),
                Tabbed(
                    Item( 'values',
                          id     = 'values_1',
                          label  = 'Shell',
                          editor = ShellEditor( share = True ),
                          dock   = 'tab',
                          export = 'DockWindowShell'

                    ),
                    Item( 'values',
                          id     = 'values_2',
                          editor = ValueEditor(),
                          dock   = 'tab',
                          export = 'DockWindowShell'
                    ),
                    Item( 'output',
                          style  = 'readonly',
                          editor = CodeEditor( show_line_numbers = False,
                                               selected_color    = 0xFFFFFF ),
                          dock   = 'tab',
                          export = 'DockWindowShell'
                    ),
                    Item( 'demo',
                          id        = 'demo',
                          style     = 'custom',
                          resizable = True,
                          dock      = 'tab',
                          export    = 'DockWindowShell'
                    ),
                    show_labels = False,
                ),
                label = 'Lab',
                dock  = 'horizontal'
            ),
            id = 'splitter',
        ),
        id      = 'enthought.tutor.lesson',
        handler = LabHandler
    )

#-------------------------------------------------------------------------------
#  'Demo' class:
#-------------------------------------------------------------------------------

class Demo ( Lesson ):
    """ Defines a demo, which is a section of a tutorial with both descriptive
        information and associated Python code which is executed but not
        shown.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HSplit(
            Item( 'descriptions',
                  label      = 'Lesson',
                  style      = 'custom',
                  show_label = False,
                  dock       = 'horizontal',
                  editor     = list_editor
            ),
            Item( 'demo',
                  id         = 'demo',
                  style      = 'custom',
                  show_label = False,
                  resizable  = True,
                  dock       = 'horizontal',
                  export     = 'DockWindowShell'
            ),
            id = 'splitter',
        ),
        id      = 'enthought.tutor.demo',
        handler = LabHandler
    )

#-------------------------------------------------------------------------------
#  'SectionFactory' class:
#-------------------------------------------------------------------------------

class SectionFactory ( HasPrivateTraits ):
    """ Defines a class that creates Lecture, Lesson or Lab sections (or None),
        based on the content of a specified directory. None is returned if the
        directory does not contain any recognized files.
    """

    #-- Traits Definitions -----------------------------------------------------

    # The path the section is to be created for:
    path = Directory

    # The list of files contained in the section:
    files = List( Str )

    # The parent of the section being created:
    parent = Instance( ASection )

    # The section created from the path:
    section = Instance( ASection )

    # The title for the section:
    title = Str

    # The optional table of contents for the section:
    toc = List( Str )

    # The list of descriptive items for the section:
    descriptions = List( ADescriptionItem )

    # The list of code snippet items for the section:
    snippets = List( CodeItem )

    # The path to the CSS style sheet for the section:
    css_path = Property

    # Should the Python code be automatically executed on start-up?
    auto_run = Bool( False )

    #-- Event Handlers ---------------------------------------------------------

    def _path_changed ( self, path ):
        """ Creates the appropriate section based on the value of the path.
        """
        # Get the list of files to process:
        files = self.files
        if len( files ) == 0:
            # If none were specified, then use all files in the directory:
            files = os.listdir( path )

            # Process the description file (if any) first:
            for name in files:
                if os.path.splitext( name )[1] == '.desc':
                    self._add_desc_item( os.path.join( path, name ) )
                    break

        # Try to convert each file into one or more 'xxxItem' objects:
        toc = [ item.split( ':', 1 )[0].strip() for item in self.toc ]
        for name in files:
            file_name = os.path.join( path, name )

            # Only process the ones that are actual files:
            if os.path.isfile( file_name ):

                # Use the file extension to determine the file's type:
                root, ext = os.path.splitext( name )
                if (root not in toc) and (len( ext ) > 1):

                    # If we have a handler for the file type, invoke it:
                    method = getattr( self, '_add_%s_item' % ext[1:].lower(),
                                      None )
                    if method is not None:
                        method( file_name )

        # Based on the type of items created (if any), create the corresponding
        # type of section:
        if len( self.descriptions ) > 0:
            if len( self.snippets ) > 0:
                if len( [ snippet for snippet in self.snippets
                                  if (not snippet.hidden) ] ) > 0:
                    self.section = Lesson(
                        title        = self.title,
                        path         = path,
                        toc          = self.toc,
                        parent       = self.parent,
                        descriptions = self.descriptions,
                        snippets     = self.snippets,
                        auto_run     = self.auto_run
                    )
                else:
                    self.section = Demo(
                        title        = self.title,
                        path         = path,
                        toc          = self.toc,
                        parent       = self.parent,
                        descriptions = self.descriptions,
                        snippets     = self.snippets,
                        auto_run     = True
                    )
            else:
                self.section = Lecture(
                    title        = self.title,
                    path         = path,
                    toc          = self.toc,
                    parent       = self.parent,
                    descriptions = self.descriptions
                )
        elif len( self.snippets ) > 0:
            self.section = Lab(
                title    = self.title,
                path     = path,
                toc      = self.toc,
                parent   = self.parent,
                snippets = self.snippets,
                auto_run = self.auto_run
            )
        else:
            # No descriptions or code snippets were found. Create a lecture
            # anyway:
            section = Lecture(
                title  = self.title,
                path   = path,
                toc    = self.toc,
                parent = self.parent
            )

            # If the lecture has subsections, then return the lecture and add
            # a default item containing a description of the subsections of the
            # lecture:
            if len( section.subsections ) > 0:
                self._create_html_item( path = path, content =
                         DefaultLecture % ( '\n'.join(
                             [ '<li>%s</li>' % subsection.title
                               for subsection in section.subsections ] ) ) )
                section.descriptions = self.descriptions
                self.section = section

    #-- Property Implementations -----------------------------------------------

    def _get_css_path ( self ):
        """ Returns the path to the CSS style sheet for the section.
        """
        return css_path_for( self.path, self.parent )

    #-- Factory Methods for Creating Section Items Based on File Type ----------

    def _add_py_item ( self, path ):
        """ Creates the code snippets for a Python source file.
        """
        source = read_file( path )
        if source is not None:
            lines      = source.replace( '\r', '' ).split( '\n' )
            start_line = 0
            title      = 'Prologue'
            type       = IsCode

            for i, line in enumerate( lines ):
                match = section_pat1.match( line )
                if match is not None:
                    next_type = IsCode
                else:
                    match = section_pat2.match( line )
                    if match is not None:
                        next_type = IsHiddenCode
                    else:
                        next_type = IsDescription
                        match     = section_pat3.match( line )

                if match is not None:
                    self._add_snippet( title, path, lines, start_line, i - 1,
                                       type )
                    start_line = i + 1
                    title      = match.group(1).strip()
                    type       = next_type

            self._add_snippet( title, path, lines, start_line, i, type )

    def _add_txt_item ( self, path ):
        """ Creates a description item for a normal text file.
        """
        self.descriptions.append( TextItem( path = path ) )

    def _add_htm_item ( self, path ):
        """ Creates a description item for an HTML file.
        """
        # Check if there is a corresponding .rst (restructured text) file:
        dir, base_name = os.path.split( path )
        rst = os.path.join( dir, os.path.splitext( base_name )[0] + '.rst' )

        # If no .rst file exists, just add the file as a normal HTML file:
        if not os.path.isfile( rst ):
            self._create_html_item( path = path )

    def _add_html_item ( self, path ):
        """ Creates a description item for an HTML file.
        """
        self._add_htm_item( path )

    def _add_url_item ( self, path ):
        """ Creates a description item for a file containing URLs.
        """
        data = read_file( path )
        if data is not None:
            for url in [ line for line in data.split( '\n' )
                              if line.strip()[:1] not in ( '', '#' ) ]:
                self._create_html_item( url = url.strip() )

    def _add_rst_item ( self, path ):
        """ Creates a description item for a ReSTructured text file.
        """
        # If docutils is not installed, just process the file as an ordinary
        # text file:
        try:
            from docutils.core import publish_cmdline
        except:
            self._add_txt_item( path )
            return

        # Get the name of the HTML file we will write to:
        dir, base_name = os.path.split( path )
        html = os.path.join( dir, os.path.splitext( base_name )[0] + '.htm' )

        # Try to find a CSS style sheet, and set up the docutil overrides if
        # found:
        settings = {}
        css_path = self.css_path
        if css_path != '':
            css_path = os.path.join( self.path, css_path )
            settings[ 'stylesheet_path' ]  = css_path
            settings[ 'embed_stylesheet' ] = True
            settings[ 'stylesheet' ]       = None
        else:
            css_path = path

        # If the HTML file does not exist, or is older than the restructured
        # text file, then let docutils convert it to HTML:
        is_file = os.path.isfile( html )
        if ((not is_file) or
            (os.path.getmtime( path )     > os.path.getmtime( html )) or
            (os.path.getmtime( css_path ) > os.path.getmtime( html ))):

            # Delete the current HTML file (if any):
            if is_file:
                os.remove( html )

            # Let docutils create a new HTML file from the restructured text
            # file:
            publish_cmdline( writer_name        = 'html',
                             argv               = [ path, html ],
                             settings_overrides = settings )

        if os.path.isfile( html ):
            # If there is now a valid HTML file, use it:
            self._create_html_item( path = html )

        else:
            # Otherwise, just use the original restructured text file:
            self._add_txt_item( path )

    def _add_swf_item ( self, path ):
        """ Creates a description item for a Flash file.
        """
        if is_windows:
            self.descriptions.append( FlashItem( path = path ) )

    def _add_mov_item ( self, path ):
        """ Creates a description item for a QuickTime movie file.
        """
        path2 = path.replace( ':', '|' )
        self._create_html_item( path    = path,
                                content = QTMovieTemplate % ( path2, path2 ) )

    def _add_wmv_item ( self, path ):
        """ Creates a description item for a Windows movie file.
        """
        self._create_html_item( path    = path,
                                content = WMVMovieTemplate % ( path, path ) )

    def _add_avi_item ( self, path ):
        """ Creates a description item for an AVI movie file.
        """
        self._add_wmv_item( path )

    def _add_jpg_item ( self, path ):
        """ Creates a description item for a JPEG image file.
        """
        self._create_html_item( path    = path,
                                content = ImageTemplate % path )

    def _add_jpeg_item ( self, path ):
        """ Creates a description item for a JPEG image file.
        """
        self._add_jpg_item( path )

    def _add_png_item ( self, path ):
        """ Creates a description item for a PNG image file.
        """
        self._add_jpg_item( path )

    def _add_mp3_item ( self, path ):
        """ Creates a description item for an mp3 audio file.
        """
        self._create_html_item( path    = path,
                                content = MP3Template % path )

    def _add_desc_item ( self, path ):
        """ Creates a section title from a description file.
        """
        # If we've already processed a description file, then we're done:
        if len( self.toc ) > 0:
            return

        lines = []
        desc  = read_file( path )
        if desc is not None:
            # Split the file into lines and save the non-empty, non-comment
            # lines:
            for line in desc.split( '\n' ):
                line = line.strip()
                if (len( line ) > 0) and (line[0] != '#'):
                    lines.append( line )

        if len( lines ) == 0:
            # If the file didn't have anything useful in it, set a title based
            # on the description file name:
            self.title = title_for(
                             os.path.splitext( os.path.basename( path ) )[0] )
        else:
            # Otherwise, set the title and table of contents from the lines in
            # the file:
            self.title = lines[0]
            self.toc   = lines[1:]

    #-- Private Methods --------------------------------------------------------

    def _add_snippet ( self, title, path, lines, start_line, end_line, type ):
        """ Adds a new code snippet or restructured text item to the list of
            code snippet or description items.
        """
        # Trim leading and trailing blank lines from the snippet:
        while start_line <= end_line:
            if lines[ start_line ].strip() != '':
                break
            start_line += 1

        while end_line >= start_line:
            if lines[ end_line ].strip() != '':
                break
            end_line -= 1

        # Only add if the snippet is not empty:
        if start_line <= end_line:

            # Check for the title containing the 'auto-run' flag ('*'):
            if title[:1] == '*':
                self.auto_run = True
                title = title[1:].strip()

            if title[-1:] == '*':
                self.auto_run = True
                title = title[:-1].strip()

            # Extract out just the lines we will use:
            content_lines = lines[ start_line: end_line + 1 ]

            if type == IsDescription:
                # Add the new restructured text description:
                self._add_description( content_lines, title )
            else:
                # Add the new code snippet:
                self.snippets.append( CodeItem(
                    title   = title or 'Code',
                    path    = path,
                    hidden  = (type == IsHiddenCode),
                    content = '\n'.join( content_lines )
                ) )

    def _add_description ( self, lines, title ):
        """ Converts a restructured text string to HTML and adds it as
            description item.
        """
        # Scan the lines for any imbedded Python code that should be shown as
        # a separate snippet:
        i = 0
        while i < len( lines ):
            if lines[i].strip()[-2:] == '::':
                i = self._check_embedded_code( lines, i + 1 )
            else:
                i += 1

        # Strip off any docstring style triple quotes (if necessary):
        content = '\n'.join( lines ).strip()
        if content[:3] in ( '"""', "'''" ):
            content = content[3:]

        if content[-3:] in ( '"""', "'''" ):
            content = content[:-3]

        content = content.strip()

        # If docutils is not installed, just add it as a text string item:
        try:
            from docutils.core import publish_string
        except:
            self.descriptions.append( TextStrItem( content = content,
                                                   title   = title ) )
            return

        # Try to find a CSS style sheet, and set up the docutil overrides if
        # found:
        settings = {}
        css_path = self.css_path
        if css_path != '':
            css_path = os.path.join( self.path, css_path )
            settings[ 'stylesheet_path' ]  = css_path
            settings[ 'embed_stylesheet' ] = True
            settings[ 'stylesheet' ]       = None

        # Convert it from restructured text to HTML:
        html = publish_string( content, writer_name        = 'html',
                                        settings_overrides = settings )

        # Choose the right HTML renderer:
        if is_windows:
            item = IEHTMLStrItem( content = html, title = title )
        else:
            item = HTMLStrItem( content = html, title = title )

        # Add the resulting item to the descriptions list:
        self.descriptions.append( item )

    def _create_html_item ( self, **traits ):
        """ Creates a platform specific html item and adds it to the list of
            descriptions.
        """
        if is_windows:
            item = IEHTMLItem( **traits )
        else:
            item = HTMLItem( **traits )

        self.descriptions.append( item )

    def _check_embedded_code ( self, lines, start ):
        """ Checks for an embedded Python code snippet within a description.
        """
        n = len( lines )
        while start < n:
            line = lines[ start ].strip()

            if line == '':
                start += 1
                continue

            if (line[:1] != '[') or (line[-1:] != ']'):
                break

            del lines[ start ]

            n     -= 1
            title  = line[1:-1].strip()
            line   = lines[ start ] + '.'
            pad    = len( line ) - len( line.strip() )
            clines = []

            while start < n:
                line     = lines[ start ] + '.'
                len_line = len( line.strip() )
                if (len_line > 1) and ((len( line ) - len_line) < pad):
                    break

                if (len( clines ) > 0) or (len_line > 1):
                    clines.append( line[ pad: -1 ] )

                start += 1

            # Add the new code snippet:
            self.snippets.append( CodeItem(
                title   = title or 'Code',
                content = '\n'.join( clines )
            ) )

            break

        return start

#-------------------------------------------------------------------------------
#  Tutor tree editor:
#-------------------------------------------------------------------------------

tree_editor = TreeEditor(
    nodes = [
        TreeNode(
            children   = 'subsections',
            label      = 'title',
            rename     = False,
            copy       = False,
            delete     = False,
            delete_me  = False,
            insert     = False,
            auto_open  = True,
            auto_close = False,
            node_for   = [ ASection ],
            icon_group = '<group>'
        )
    ],
    editable  = False,
    auto_open = 1,
    selected = 'section'
)

#-------------------------------------------------------------------------------
#  'Tutor' class:
#-------------------------------------------------------------------------------

class Tutor ( HasPrivateTraits ):
    """ The main tutorial class which manages the presentation and navigation
        of the entire tutorial.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The path to the files distributed with the tutor:
    home = Directory

    # The path to the root of the tutorial tree:
    path = Directory

    # The root of the tutorial lesson tree:
    root = Instance( ASection )

    # The current section of the tutorial being displayed:
    section = Instance( ASection )

    # The next section:
    next_section = Property( depends_on = 'section', cached = True )

    # The previous section:
    previous_section = Property( depends_on = 'section', cached = True )

    # The previous section button:
    previous = Button( image = ImageResource( 'previous' ), height_padding = 1 )

    # The next section button:
    next = Button( image = ImageResource( 'next' ), height_padding = 1 )

    # The parent section button:
    parent = Button( image = ImageResource( 'parent' ), height_padding = 1 )

    # The reload tutor button:
    reload = Button( image = ImageResource( 'reload' ), height_padding = 1 )

    # The title of the current session:
    title = Property( depends_on = 'section' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            HGroup(
                Item( 'previous',
                      style        = 'custom',
                      enabled_when = 'previous_section is not None',
                      tooltip      = 'Go to previous section'
                ),
                Item( 'parent',
                      style        = 'custom',
                      enabled_when = '(section is not None) and '
                                     '(section.parent is not None)',
                      tooltip      = 'Go up one level'
                ),
                Item( 'next',
                      style        = 'custom',
                      enabled_when = 'next_section is not None',
                      tooltip      = 'Go to next section'
                ),
                '_',
                Item( 'title',
                      springy = True,
                      editor  = TitleEditor()
                ),
                '_',
                Item( 'reload',
                      style   = 'custom',
                      tooltip = 'Reload the tutorial'
                ),
                show_labels = False
            ),
            '_',
            HSplit(
                Item( 'root',
                      label  = 'Table of Contents',
                      editor = tree_editor,
                      dock   = 'horizontal',
                      export = 'DockWindowShell'
                ),
                Item( 'section',
                      id        = 'section',
                      label     = 'Current Lesson',
                      style     = 'custom',
                      resizable = True,
                      dock      = 'horizontal'
                ),
                id          = 'splitter',
                show_labels = False
            )
        ),
        title     = 'Python Tutor',
        id        = 'dmorrill.tutor.tutor:1.0',
        buttons   = NoButtons,
        resizable = True,
        width     = 0.8,
        height    = 0.8
    )

    #-- Event Handlers ---------------------------------------------------------

    def _path_changed ( self, path ):
        """ Handles the tutorial root path being changed.
        """
        self.init_tutor()

    def _next_changed ( self ):
        """ Displays the next tutorial section.
        """
        self.section = self.next_section

    def _previous_changed ( self ):
        """ Displays the previous tutorial section.
        """
        self.section = self.previous_section

    def _parent_changed ( self ):
        """ Displays the parent of the current tutorial section.
        """
        self.section = self.section.parent

    def _reload_changed ( self ):
        """ Reloads the tutor from the original path specified.
        """
        self.init_tutor()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_next_section ( self ):
        """ Returns the next section of the tutorial.
        """
        next    = None
        section = self.section
        if len( section.subsections ) > 0:
            next = section.subsections[0]
        else:
            parent = section.parent
            while parent is not None:
                index = parent.subsections.index( section )
                if index < (len( parent.subsections ) - 1):
                    next = parent.subsections[ index + 1 ]
                    break

                parent, section = parent.parent, parent

        return next

    @cached_property
    def _get_previous_section ( self ):
        """ Returns the previous section of the tutorial.
        """
        previous = None
        section  = self.section
        parent   = section.parent
        if parent is not None:
            index = parent.subsections.index( section )
            if index > 0:
                previous = parent.subsections[ index - 1 ]
                while len( previous.subsections ) > 0:
                    previous = previous.subsections[-1]
            else:
                previous = parent

        return previous

    def _get_title ( self ):
        """ Returns the title of the current section.
        """
        section = self.section
        if section is None:
            return ''

        return ('%s: %s' % ( section.__class__.__name__, section.title ))

    #-- Public Methods ---------------------------------------------------------

    def init_tutor ( self ):
        """ Initials the tutor by creating the root section from the specified
            path.
        """
        path    = self.path
        title   = title_for( os.path.splitext( os.path.basename( path ) )[0] )
        section = SectionFactory( title = title ).set( path = path ).section
        if section is not None:
            self.section = self.root = section

#-------------------------------------------------------------------------------
#  Run the program:
#-------------------------------------------------------------------------------

# Only run the program if we were invoked from the command line:
if __name__ == '__main__':

    # Validate the command line arguments:
    if len( sys.argv ) > 2:
        print Usage
        sys.exit( 1 )

    # Determine the root path to use for the tutorial files:
    if len( sys.argv ) == 2:
        path = sys.argv[1]
    else:
        path = os.getcwd()

    # Create a tutor and display the tutorial:
    tutor = Tutor( home = os.path.dirname( sys.argv[0] ) ).set(
                   path = path )
    if tutor.root is not None:
        tutor.configure_traits()
    else:
        print """No traits tutorial found in %s.

Correct usage is: python tutor.py [tutorial_path]
where: tutorial_path = Path to the root of the traits tutorial.

If tutorial_path is omitted, the current directory is assumed to be the root of
the tutorial.""" % path


########NEW FILE########
__FILENAME__ = fix_unicode_methods
from lib2to3 import fixer_base
from lib2to3.fixer_util import Name


class FixUnicodeMethods(fixer_base.BaseFix):
    """ Custom fixer for the __unicode__ method

    Renames __unicode__ methods to __str__.

    Code used from:
    http://lucumr.pocoo.org/2010/2/11/porting-to-python-3-a-guide/

    """
    PATTERN = r"funcdef< 'def' name='__unicode__' parameters< '(' NAME ')' > any+ >"  # noqa

    def transform(self, node, results):
        name = results['name']
        name.replace(Name('__str__', prefix=name.prefix))

########NEW FILE########
__FILENAME__ = adaptation_error
#------------------------------------------------------------------------------
# Copyright (c) 2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
#------------------------------------------------------------------------------
""" Exception raised when a requested adaptation is not possible. """

class AdaptationError(TypeError):
    """ Exception raised when a requested adaptation is not possible. """

    pass

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = adaptation_manager
#------------------------------------------------------------------------------
# Copyright (c) 2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
#------------------------------------------------------------------------------
""" Manages all registered adaptations. """


from heapq import heappop, heappush
import inspect
import itertools
import sys
import functools

from traits.adaptation.adaptation_error import AdaptationError
from traits.has_traits import HasTraits
from traits.trait_types import Dict, List, Str


def no_adapter_necessary(adaptee):
    """ An adapter factory used to register that a protocol provides another.

    See 'register_provides' for details.

    """

    return adaptee


class AdaptationManager(HasTraits):
    """ Manages all registered adaptations. """

    #### 'AdaptationManager' class protocol ###################################

    @staticmethod
    def mro_distance_to_protocol(from_type, to_protocol):
        """ Return the distance in the MRO from 'from_type' to 'to_protocol'.

        If `from_type` provides `to_protocol`, returns the distance between
        `from_type` and the super-most class in the MRO hierarchy providing
        `to_protocol` (that's where the protocol was provided in the first
        place).

        If `from_type` does not provide `to_protocol`, return None.

        """

        if not AdaptationManager.provides_protocol(from_type, to_protocol):
            return None

        # We walk up the MRO hierarchy until the point where the `to_protocol`
        # is *no longer* provided. When we reach that point we know that the
        # previous class in the MRO is the one that provided the protocol in
        # the first place (e.g., the first super-class implementing an
        # interface).
        supertypes = inspect.getmro(from_type)[1:]

        distance = 0
        for t in supertypes:
            if AdaptationManager.provides_protocol(t, to_protocol):
                distance += 1

            # We have reached the point in the MRO where the protocol is no
            # longer provided.
            else:
                break

        return distance

    @staticmethod
    def provides_protocol(type_, protocol):
        """ Does the given type provide (i.e implement) a given protocol?

        'type_'    is a Python 'type'.
        'protocol' is either a regular Python class or a traits Interface.

        Return True if the object provides the protocol, otherwise False.

        """

        # We do the 'is' check first as a performance improvement to save us
        # a call to 'issubclass'.
        return type_ is protocol or issubclass(type_, protocol)

    #### 'AdaptationManager' protocol ##########################################

    def adapt(self, adaptee, to_protocol, default=AdaptationError):
        """ Attempt to adapt an object to a given protocol.

        `adaptee`     is the object that we want to adapt.
        `to_protocol` is the protocol that the want to adapt the object to.

        If `adaptee` already provides (i.e. implements) the given protocol
        then it is simply returned unchanged.

        Otherwise, we try to build a chain of adapters that adapt `adaptee`
        to `to_protocol`.

        If no such adaptation is possible then either an AdaptationError is
        raised (if default=Adaptation error), or `default` is returned (as
        in the default value passed to 'getattr' etc).

        """

        # If the object already provides the given protocol then it is
        # simply returned.
        # We use adaptee.__class__ instead of type(adaptee) as a courtesy to
        # old-style classes.
        if self.provides_protocol(adaptee.__class__, to_protocol):
            result = adaptee

        # Otherwise, try adapting the object.
        else:
            result = self._adapt(adaptee, to_protocol)

        if result is None:
            if default is AdaptationError:
                raise AdaptationError(
                    'Could not adapt %r to %r' % (adaptee, to_protocol))
            else:
                result = default

        return result

    def register_offer(self, offer):
        """ Register an offer to adapt from one protocol to another. """

        offers = self._adaptation_offers.setdefault(
            offer.from_protocol_name, []
        )
        offers.append(offer)

        return

    def register_factory(self, factory, from_protocol, to_protocol):
        """ Register an adapter factory.

        This is a simply a convenience method that creates and registers an
        'AdaptationOffer' from the given arguments.

        """

        from traits.adaptation.adaptation_offer import AdaptationOffer

        self.register_offer(
            AdaptationOffer(
                factory       = factory,
                from_protocol = from_protocol,
                to_protocol   = to_protocol
            )
        )

        return

    def register_provides(self, provider_protocol, protocol):
        """ Register that a protocol provides another. """

        self.register_factory(no_adapter_necessary, provider_protocol, protocol)

        return

    def supports_protocol(self, obj, protocol):
        """ Does the object support a given protocol?

        An object "supports" a protocol if either it "provides" it directly,
        or it can be adapted to it.

        """

        return self.adapt(obj, protocol, None) is not None

    #### Private protocol #####################################################

    #: All registered adaptation offers.
    #: Keys are the type name of the offer's from_protocol; values are a
    #: list of adaptation offers.
    _adaptation_offers = Dict(Str, List)

    def _adapt(self, adaptee, to_protocol):
        """ Returns an adapter that adapts an object to the target class.

        Returns None if no such adapter exists.

        """

        # The algorithm for finding a sequence of adapters adapting 'adaptee'
        # to 'to_protocol' is based on a weighted graph.

        # Nodes on the graphs are protocols (types or interfaces).
        # Edges are adaptation offers that connect a offer.from_protocol to a
        # offer.to_protocol.
        # Edges connect protocol A to protocol B and are weighted by two
        # numbers in this priority:
        # 1) a unit weight (1) representing the fact that we use 1 adaptation
        #    offer to go from A to B
        # 2) the number of steps up the type hierarchy that we need to take
        #    to go from A to offer.from_protocol, so that more specific
        #    adapters are always preferred

        # The algorithm finds the shortest weighted path between 'adaptee'
        # and 'to_protocol'. Once a candidate path is found, it tries to
        # create the adapters using the factories in the adaptation offers
        # that compose the path. If this fails because of conditional
        # adaptation (i.e., an adapter factory returns None), the path
        # is discarded and the algorithm looks for the next shortest path.

        # Cycles in adaptation are avoided by only considering path were
        # every adaptation offer is used at most once.

        # The implementation of the algorithm is based on a priority queue,
        # 'offer_queue'.
        #
        # Each value in the queue has got two parts,
        # one is the adaptation path, i.e., the sequence of adaptation offers
        # followed so far; the second value is the protocol of the last
        # visited node.
        #
        # The priority in the queue is the sum of all the weights for the
        # edges traversed in the path.

        # Unique sequence counter to make the priority list stable
        # w.r.t the sequence of insertion.
        counter = itertools.count()

        # The priority queue containing entries of the form
        # (cumulative weight, path, current protocol) describing an
        # adaptation path starting at `adaptee`, following a sequence
        # of adaptation offers, `path`, and having weight `cumulative_weight`.
        #
        # 'cumulative weight' is a tuple of the form
        # (number of traversed adapters,
        #  number of steps up protocol hierarchies,
        #  counter)
        #
        # The counter is an increasing number, and is used to make the
        # priority queue stable w.r.t insertion time
        # (see http://bit.ly/13VxILn).
        offer_queue = [((0, 0, next(counter)), [], type(adaptee))]

        while len(offer_queue) > 0:
            # Get the most specific candidate path for adaptation.
            weight, path, current_protocol = heappop(offer_queue)

            edges = self._get_applicable_offers(current_protocol, path)

            # Sort by weight first, then by from_protocol type.
            if sys.version_info[0] < 3:
                edges.sort(cmp=_by_weight_then_from_protocol_specificity)
            else:
                # functools.cmp_to_key is available from 2.7 and 3.2
                edges.sort(key=functools.cmp_to_key(_by_weight_then_from_protocol_specificity))
                

            # At this point, the first edges are the shortest ones. Within
            # edges with the same distance, interfaces which are subclasses
            # of other interfaces in that group come first. The rest of
            # the order is unspecified.

            for mro_distance, offer in edges:
                new_path = path + [offer]

                # Check if we arrived at the target protocol.
                if self.provides_protocol(offer.to_protocol, to_protocol):
                    # Walk path and create adapters
                    adapter = adaptee
                    for offer in new_path:
                        adapter = offer.factory(adapter)
                        if adapter is None:
                            # This adaptation attempt failed (e.g. because of
                            # conditional adaptation).
                            # Discard this path and continue.
                            break

                    else:
                        # We're done!
                        return adapter

                else:
                    # Push the new path on the priority queue.
                    adapter_weight, mro_weight, _ = weight
                    new_weight = (adapter_weight + 1,
                                  mro_weight + mro_distance,
                                  next(counter))
                    heappush(
                        offer_queue,
                        (new_weight, new_path, offer.to_protocol)
                    )

        return None

    def _get_applicable_offers(self, current_protocol, path):
        """ Find all adaptation offers that can be applied to a protocol.

        Return all the applicable offers together with the number of steps
        up the MRO hierarchy that need to be taken from the protocol
        to the offer's from_protocol.
        The returned object is a list of tuples (mro_distance, offer) .

        In terms of our graph algorithm, we're looking for all outgoing edges
        from the current node.
        """

        edges = []

        for from_protocol_name, offers in self._adaptation_offers.items():
            from_protocol = offers[0].from_protocol
            mro_distance = self.mro_distance_to_protocol(
                current_protocol, from_protocol
            )

            if mro_distance is not None:

                for offer in offers:
                    # Avoid cycles by checking that we did not consider this
                    # offer in this path.
                    if offer not in path:
                        edges.append((mro_distance, offer))

        return edges

def _by_weight_then_from_protocol_specificity(edge_1, edge_2):
    """ Comparison function for graph edges.

    Each edge is of the form (mro distance, adaptation offer).

    Comparison is done by mro distance first, and by offer's from_protocol
    issubclass next.

    If two edges have the same mro distance, and the from_protocols of the
    two edges are not subclasses of one another, they are considered "equal".

    """

    # edge_1 and edge_2 are edges, of the form (mro_distance, offer)

    mro_distance_1, offer_1 = edge_1
    mro_distance_2, offer_2 = edge_2

    # First, compare the MRO distance.
    if mro_distance_1 < mro_distance_2:
        return -1
    elif mro_distance_1 > mro_distance_2:
        return 1

    # The distance is equal, prefer more specific 'from_protocol's
    if offer_1.from_protocol is offer_2.from_protocol:
        return 0

    if issubclass(offer_1.from_protocol, offer_2.from_protocol):
        return -1
    elif issubclass(offer_2.from_protocol, offer_1.from_protocol):
        return 1

    return 0


# The default global adaptation manager.
# PROVIDED FOR BACKWARD COMPATIBILITY ONLY, IT SHOULD NEVER BE USED DIRECTLY.
# If you must use a global adaptation manager, use the functions
# `get_global_adaptation_manager`, `reset_global_adaptation_manager`,
# `set_global_adaptation_manager`.
adaptation_manager = AdaptationManager()


def set_global_adaptation_manager(new_adaptation_manager):
    """ Set the global adaptation manager to the given instance. """
    global adaptation_manager
    adaptation_manager = new_adaptation_manager


def reset_global_adaptation_manager():
    """ Set the global adaptation manager to a new AdaptationManager instance.
    """
    global adaptation_manager
    adaptation_manager = AdaptationManager()


def get_global_adaptation_manager():
    """ Set a reference to the global adaptation manager. """
    global adaptation_manager
    return adaptation_manager


# Convenience references to methods on the default adaptation manager.
#
# If you add a public method to the adaptation manager protocol then don't
# forget to add a convenience function here!

def adapt(adaptee, to_protocol, default=AdaptationError):
    """ Attempt to adapt an object to a given protocol. """
    manager = get_global_adaptation_manager()
    return manager.adapt(adaptee, to_protocol, default)


def register_factory(factory, from_protocol, to_protocol):
    """ Register an adapter factory. """
    manager = get_global_adaptation_manager()
    return manager.register_factory(factory, from_protocol, to_protocol)


def register_offer(offer):
    """ Register an offer to adapt from one protocol to another. """
    manager = get_global_adaptation_manager()
    return manager.register_offer(offer)


def register_provides(provider_protocol, protocol):
    """ Register that a protocol provides another. """
    manager = get_global_adaptation_manager()
    return manager.register_provides(provider_protocol, protocol)


def supports_protocol(obj, protocol):
    """ Does the object support a given protocol? """
    manager = get_global_adaptation_manager()
    return manager.supports_protocol(obj, protocol)


def provides_protocol(type_, protocol):
    """ Does the given type provide (i.e implement) a given protocol? """
    return AdaptationManager.provides_protocol(type_, protocol)

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = adaptation_offer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
#------------------------------------------------------------------------------
""" An offer to provide adapters from one protocol to another. """


from traits.api import Any, Bool, HasTraits, Property

from traits.util.api import import_symbol


class AdaptationOffer(HasTraits):
    """ An offer to provide adapters from one protocol to another.

    An adaptation offer consists of a factory that can create adapters, and the
    protocols that define what the adapters adapt from and to.

    """

    #### 'object' protocol ####################################################

    def __repr__(self):
        """ Return a string representation of the object. """

        template = "<AdaptationOffer: '{from_}' -> '{to}'>"

        from_ = self.from_protocol_name
        to    = self.to_protocol_name

        return template.format(from_=from_, to=to)

    #### 'AdaptationOffer' protocol ###########################################

    #: A factory for creating adapters.
    #:
    #: The factory must ba callable that takes exactly one argument which is
    #: the object to be adapted (known as the adaptee), and returns an
    #: adapter from the `from_protocol` to the `to_protocol`.
    #:
    #: The factory can be specified as either a callable, or a string in the
    #: form 'foo.bar.baz' which is turned into an import statement
    #: 'from foo.bar import baz' and imported when the trait is first accessed.
    factory = Property(Any)

    #: Adapters created by the factory adapt *from* this protocol.
    #:
    #: The protocol can be specified as a protocol (class/Interface), or a
    #: string in the form 'foo.bar.baz' which is turned into an import
    #: statement 'from foo.bar import baz' and imported when the trait is
    #: accessed.
    from_protocol = Property(Any)
    from_protocol_name = Property(Any)
    def _get_from_protocol_name(self):
        return self._get_type_name(self._from_protocol)

    #: Adapters created by the factory adapt *to* this protocol.
    #:
    #: The protocol can be specified as a protocol (class/Interface), or a
    #: string in the form 'foo.bar.baz' which is turned into an import
    #: statement 'from foo.bar import baz' and imported when the trait is
    #: accessed.
    to_protocol = Property(Any)
    to_protocol_name = Property(Any)
    def _get_to_protocol_name(self):
        return self._get_type_name(self._to_protocol)

    #### Private protocol ######################################################

    #: Shadow trait for the corresponding property.
    _factory = Any
    _factory_loaded = Bool(False)

    def _get_factory(self):
        """ Trait property getter. """

        if not self._factory_loaded:
            if isinstance(self._factory, basestring):
                self._factory = import_symbol(self._factory)

            self._factory_loaded = True

        return self._factory

    def _set_factory(self, factory):
        """ Trait property setter. """

        self._factory = factory

        return

    #: Shadow trait for the corresponding property.
    _from_protocol = Any
    _from_protocol_loaded = Bool(False)

    def _get_from_protocol(self):
        """ Trait property getter. """

        if not self._from_protocol_loaded:
            if isinstance(self._from_protocol, basestring):
                self._from_protocol = import_symbol(self._from_protocol)

            self._from_protocol_loaded = True

        return self._from_protocol

    def _set_from_protocol(self, from_protocol):
        """ Trait property setter. """

        self._from_protocol = from_protocol

        return

    #: Shadow trait for the corresponding property.
    _to_protocol = Any
    _to_protocol_loaded = Bool(False)

    def _get_to_protocol(self):
        """ Trait property getter. """

        if not self._to_protocol_loaded:
            if isinstance(self._to_protocol, basestring):
                self._to_protocol = import_symbol(self._to_protocol)

            self._to_protocol_loaded = True

        return self._to_protocol

    def _set_to_protocol(self, to_protocol):
        """ Trait property setter. """

        self._to_protocol = to_protocol

        return

    def _get_type_name(self, type_or_type_name):
        """ Returns the full dotted path for a type.

        For example:
        from traits.api import HasTraits
        _get_type_name(HasTraits) == 'traits.has_traits.HasTraits'

        If the type is given as a string (e.g., for lazy loading), it is just
        returned.

        """

        if isinstance(type_or_type_name, basestring):
            type_name = type_or_type_name

        else:
            type_name = "{module}.{name}".format(
                module = type_or_type_name.__module__,
                name   = type_or_type_name.__name__
            )

        return type_name

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = adapter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
#------------------------------------------------------------------------------
""" Base classes for adapters.

Adapters do not have to inherit from these classes, as long as their
constructor takes the object to be adapted as the first and only
*positional* argument.

"""


from traits.has_traits import HasTraits
from traits.trait_types import Any
from traits.util.deprecated import deprecated


class PurePythonAdapter(object):
    """ Base class for pure Python adapters. """

    def __init__(self, adaptee):
        """ Constructor. """

        self.adaptee = adaptee

        return


class Adapter(HasTraits):
    """ Base class for adapters with traits. """

    def __init__(self, adaptee, **traits):
        """ Constructor. """

        traits['adaptee'] = adaptee
        super(Adapter, self).__init__(**traits)

        return

    adaptee = Any


def adapts(from_, to, extra=None, factory=None, cached=False, when=''):
    """ A class advisor for declaring adapters.

    Parameters
    ----------
    from_ : type or interface
        What the adapter adapts *from*, or a list of such types or interfaces
        (the '_' suffix is used because 'from' is a Python keyword).
    to : type or interface
        What the adapter adapts *to*, or a list of such types or interfaces.
    factory : callable
        An (optional) factory for actually creating the adapters. This is
        any callable that takes a single argument which is the object to
        be adapted. The factory should return an adapter if it can
        perform the adaptation and **None** if it cannot.
    cached : bool
        Should the adapters be cached? If an adapter is cached, then the
        factory will produce at most one adapter per instance.
    when : str
        A Python expression that selects which instances of a particular type
        can be adapted by this factory. The expression is evaluated in a
        namespace that contains a single name *adaptee*, which is bound to the
        object to be adapted (e.g., 'adaptee.is_folder').

    Note
    ----
    The ``cached`` and ``when`` arguments are ignored if ``factory`` is
    specified.

    """

    from traits.adaptation.api import register_factory
    from traits.adaptation.cached_adapter_factory import CachedAdapterFactory
    from traits.protocols.advice import addClassAdvisor

    if extra is not None:
        adapter, from_, to = from_, to, extra
    else:
        adapter = None

    @deprecated("use the 'register_factory' function from 'traits.api' instead")
    def callback(klass):
        """ Called when the class has been created. """

        # At this point:-
        #
        # klass is the callable (usually a class) that takes one argument (the
        # adaptee) and returns an appropriate adapter (or None if the adaptation
        # is not possible).

        # What the adapters created by the factory will adapt from.
        if type(from_) is not list:
            from_protocols = [from_]

        else:
            from_protocols = from_

        # What the adapters created by the factory will adapt to.
        if type(to) is not list:
            to_protocols = [to]

        else:
            to_protocols = to

        if factory is None:
            # If the adapter is cached or has a 'when' expression then create a
            # default factory:

            adapter_factory = klass

            if when != '':
                def _conditional_factory(adaptee, *args, **kw):
                    namespace = {'adaptee': adaptee}

                    if eval(when, namespace, namespace):
                        return klass(adaptee, *args, **kw)

                    return None

                adapter_factory = _conditional_factory

            if cached:
                adapter_factory = CachedAdapterFactory(factory=adapter_factory)

        else:
            adapter_factory = factory

        for from_protocol in from_protocols:
            for to_protocol in to_protocols:
                register_factory(adapter_factory, from_protocol, to_protocol)

        for to_protocol in to_protocols:
            # We cannot register adapter factories that are functions. (This is
            # ony relevant when using 'adapts' as a function.
            if isinstance(klass, type):
                # We use type(to_protocol) in case the to_protocols implements
                # its own 'register' method which overrides the ABC method.
                type(to_protocol).register(to_protocol, klass)

        return klass

    if adapter is not None:
        callback(adapter)

    else:
        addClassAdvisor(callback)

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = api
from .adapter import Adapter, adapts, PurePythonAdapter

from .adaptation_error import AdaptationError

from .adaptation_manager import adapt, AdaptationManager, \
    get_global_adaptation_manager, provides_protocol, register_factory, \
    register_offer, register_provides, reset_global_adaptation_manager, \
    set_global_adaptation_manager, supports_protocol

from .adaptation_offer import AdaptationOffer

########NEW FILE########
__FILENAME__ = cached_adapter_factory
#------------------------------------------------------------------------------
# Copyright (c) 2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
#------------------------------------------------------------------------------
""" An adapter factory that caches adapters per instance. """


import weakref

from traits.api import Any, Bool, HasTraits, Property
from traits.util.api import import_symbol


class CachedAdapterFactory(HasTraits):
    """ An adapter factory that caches adapters per instance.

    We provide this class to provide the caching functionality of the
    old traits 'adapts' implementation. However, note that the cache will
    not be cleared unless you take care of cleaning the 'adaptee' trait once
    your adapter are deleted.

    This class will be removed when the 'adapts' function is removed.

    """

    #### 'object' protocol #####################################################

    def __call__(self, adaptee):
        """ The adapter manager uses callables for adapter factories. """

        adapter = self._adapter_cache.get(adaptee, None)
        if adapter is None:
            adapter = self.factory(adaptee)
            self._adapter_cache[adaptee] = adapter

        return adapter

    #### 'CachedAdapterFactory' protocol #######################################

    #: A callable that actually creates the adapters!
    #:
    #: The factory must ba callable that takes exactly one argument which is
    #: the object to be adapted (known as the adaptee), and returns an
    #: adapter from the `from_protocol` to the `to_protocol`.
    #:
    #: The factory can be specified as either a callable, or a string in the
    #: form 'foo.bar.baz' which is turned into an import statement
    #: 'from foo.bar import baz' and imported when the trait is first accessed.
    factory = Property(Any)

    #: True if the cache is empty, otherwise False.
    #:
    #: This method is mostly here to help testing - the framework does not
    #: rely on it for any other purpose.
    is_empty = Property(Bool)
    def _get_is_empty(self):
        return len(self._adapter_cache) == 0

    #### Private protocol ######################################################

    _adapter_cache = Any
    def __adapter_cache_default(self):
        return weakref.WeakKeyDictionary()

    #: Shadow trait for the corresponding property.
    _factory = Any
    _factory_loaded = Bool(False)

    def _get_factory(self):
        """ Trait property getter. """

        if not self._factory_loaded:
            if isinstance(self._factory, basestring):
                self._factory = import_symbol(self._factory)

            self._factory_loaded = True

        return self._factory

    def _set_factory(self, factory):
        """ Trait property setter. """

        self._factory = factory

        return

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = abc_examples
""" Test data for testing the protocol manager with ABCs. """


from abc import ABCMeta

from traits.adaptation.api import PurePythonAdapter as Adapter


#### 'Power plugs' metaphor ###################################################

#### Protocols ################################################################

class UKStandard(object):
    __metaclass__ = ABCMeta

class EUStandard(object):
    __metaclass__ = ABCMeta

class JapanStandard(object):
    __metaclass__ = ABCMeta

class IraqStandard(object):
    __metaclass__ = ABCMeta

#### Implementations ##########################################################

class UKPlug(object):
    pass

UKStandard.register(UKPlug)

class EUPlug(object):
    pass

EUStandard.register(EUPlug)

class JapanPlug(object):
    pass

JapanStandard.register(JapanPlug)

class IraqPlug(object):
    pass

IraqStandard.register(IraqPlug)

class TravelPlug(object):

    def __init__(self, mode):
        self.mode = mode

#### Adapters #################################################################

# UK->EU
class UKStandardToEUStandard(Adapter):
    pass

EUStandard.register(UKStandardToEUStandard)

# EU->Japan
class EUStandardToJapanStandard(Adapter):
    pass

JapanStandard.register(EUStandardToJapanStandard)

# Japan->Iraq
class JapanStandardToIraqStandard(Adapter):
    pass

IraqStandard.register(JapanStandardToIraqStandard)

# EU->Iraq
class EUStandardToIraqStandard(Adapter):
    pass

IraqStandard.register(EUStandardToIraqStandard)

# UK->Japan
class UKStandardToJapanStandard(Adapter):
    pass

JapanStandard.register(UKStandardToJapanStandard)

# Travel->Japan
class TravelPlugToJapanStandard(Adapter):
    pass

JapanStandard.register(TravelPlugToJapanStandard)

# Travel->EU
class TravelPlugToEUStandard(Adapter):
    pass

EUStandard.register(TravelPlugToEUStandard)


#### 'Editor, Scriptable, Undoable' metaphor ##################################

class FileType(object):
    pass

class IEditor(object):
    __metaclass__ = ABCMeta

class IScriptable(object):
    __metaclass__ = ABCMeta

class IUndoable(object):
    __metaclass__ = ABCMeta


class FileTypeToIEditor(Adapter):
    pass

IEditor.register(FileTypeToIEditor)
IScriptable.register(FileTypeToIEditor)

class IScriptableToIUndoable(Adapter):
    pass

IUndoable.register(IScriptableToIUndoable)


#### Hierarchy example ########################################################

class IPrintable(object):
    __metaclass__ = ABCMeta

class Editor(object):
    pass

class TextEditor(Editor):
    pass

class EditorToIPrintable(Adapter):
    pass

IPrintable.register(EditorToIPrintable)

class TextEditorToIPrintable(Adapter):
    pass

IPrintable.register(TextEditorToIPrintable)


#### Interface hierarchy example ##############################################

class IPrimate(object):
    __metaclass__ = ABCMeta

class IHuman(IPrimate):
    pass

class IChild(IHuman):
    pass

class IIntermediate(object):
    __metaclass__ = ABCMeta

class ITarget(object):
    __metaclass__ = ABCMeta

class Source(object):
    pass

IChild.register(Source)

class IChildToIIntermediate(Adapter):
    pass

IIntermediate.register(IChildToIIntermediate)

class IHumanToIIntermediate(Adapter):
    pass

IIntermediate.register(IHumanToIIntermediate)

class IPrimateToIIntermediate(Adapter):
    pass

IIntermediate.register(IPrimateToIIntermediate)

class IIntermediateToITarget(Adapter):
    pass

ITarget.register(IIntermediateToITarget)


#### Non-trivial chaining example #############################################

class IStart(object):
    __metaclass__ = ABCMeta

class IGeneric(object):
    __metaclass__ = ABCMeta

class ISpecific(IGeneric):
    pass

class IEnd(object):
    __metaclass__ = ABCMeta

class Start(object):
    pass

IStart.register(Start)

class IStartToISpecific(Adapter):
    pass

ISpecific.register(IStartToISpecific)

class IGenericToIEnd(Adapter):
    pass

IEnd.register(IGenericToIEnd)

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = benchmark
""" Simple benchmarking of the adaptation manager.

This is not 'enforced' by any tests (i.e. we currently aren't bound to satisfy
any performance criteria - but in the future we might be ;^).

"""


import abc
from pprint import pprint
import time

from traits.adaptation.adaptation_manager import AdaptationManager
from traits.api import Adapter, HasTraits, Interface, provides


N_SOURCES    = 3
N_ITERATIONS = 100
N_PROTOCOLS  = 50

# Create some classes to adapt.
create_classes_to_adapt = """
class IFoo{i}(Interface):
    pass

@provides(IFoo{i})
class Foo{i}(HasTraits):
    pass
"""
for i in range(N_SOURCES):
    exec create_classes_to_adapt.format(i=i)

# The object that we will try to adapt!
foo = Foo1()

# Create a lot of other interfaces that we will adapt to.
for i in range(N_PROTOCOLS):
    exec 'class I{i}(Interface): pass'.format(i=i)

create_traits_adapter_class = """
@provides(I{target})
class IFoo{source}ToI{target}(Adapter):
    pass
"""

#  Create adapters from each 'IFooX' to all of the interfaces.
for source in range(N_SOURCES):
    for target in range(N_PROTOCOLS):
        exec create_traits_adapter_class.format(source=source, target=target)


#### traits.adaptation with Interfaces ########################################

adaptation_manager = AdaptationManager()

register_ifoox_to_ix = """

adaptation_manager.register_factory(
    factory       = IFoo{source}ToI{target},
    from_protocol = IFoo{source},
    to_protocol   = I{target}
)

"""

# We register the adapters in reversed order, so that looking for the one
# with index 0 will need traversing the whole list.
# I.e., we're considering the worst case scenario.
for source in range(N_SOURCES):
    for target in reversed(range(N_PROTOCOLS)):
        exec register_ifoox_to_ix.format(source=source, target=target)

start_time = time.time()
for _ in range(N_ITERATIONS):
    adaptation_manager.adapt(foo, I0)
time_per_iter = (time.time() - start_time) / float(N_ITERATIONS) * 1000.0
print 'apptools using Interfaces: %.3f msec per iteration' % time_per_iter


#### traits.adaptation with ABCs ##############################################

# Create some classes to adapt (using ABCs!).
for i in range(N_SOURCES):
    exec 'class FooABC{i}(object): __metaclass__ = abc.ABCMeta'.format(i=i)
    exec 'class Foo{i}(object): pass'.format(i=i)
    exec 'FooABC{i}.register(Foo{i})'.format(i=i)

# The object that we will try to adapt!
foo = Foo0()

# Create a lot of other ABCs!
for i in range(N_PROTOCOLS):
    exec 'class ABC{i}(object): __metaclass__ = abc.ABCMeta'.format(i=i)

# Create adapters from 'FooABC' to all of the ABCs.
create_abc_adapter_class = """
class FooABC{source}ToABC{target}(object):
    def __init__(self, adaptee):
        pass

ABC{target}.register(FooABC{source}ToABC{target})
"""

for source in range(N_SOURCES):
    for target in range(N_PROTOCOLS):
        exec create_abc_adapter_class.format(source=source, target=target)

# Register all of the adapters.
adaptation_manager = AdaptationManager()

register_fooxabc_to_abcx = """
adaptation_manager.register_factory(
    factory       = FooABC{source}ToABC{target},
    from_protocol = FooABC{source},
    to_protocol   = ABC{target}
)
"""

# We register the adapters in reversed order, so that looking for the one
# with index 0 will need traversing the whole list.
# I.e., we're considering the worst case scenario.
for source in range(N_SOURCES):
    for target in reversed(range(N_PROTOCOLS)):
        exec register_fooxabc_to_abcx.format(source=source, target=target)

start_time = time.time()
for _ in range(N_ITERATIONS):
    adaptation_manager.adapt(foo, ABC0)
time_per_iter = (time.time() - start_time) / float(N_ITERATIONS) * 1000.0
print 'apptools using ABCs: %.3f msec per iteration' % time_per_iter

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = interface_examples
""" Test data for testing the protocol manager with interfaces. """


from traits.api import Adapter, Enum, HasTraits, Interface, provides


#### 'Power plugs' metaphor ###################################################

#### Protocols ################################################################

class UKStandard(Interface):
    pass

class EUStandard(Interface):
    pass

class JapanStandard(Interface):
    pass

class IraqStandard(Interface):
    pass

#### Implementations ##########################################################

@provides(UKStandard)
class UKPlug(HasTraits):
    pass

@provides(EUStandard)
class EUPlug(HasTraits):
    pass

@provides(JapanStandard)
class JapanPlug(HasTraits):
    pass

@provides(IraqStandard)
class IraqPlug(HasTraits):
    pass

class TravelPlug(HasTraits):

    mode = Enum(['Europe', 'Asia'])

#### Adapters #################################################################

@provides(EUStandard)
class UKStandardToEUStandard(Adapter):
    pass

@provides(JapanStandard)
class EUStandardToJapanStandard(Adapter):
    pass

@provides(IraqStandard)
class JapanStandardToIraqStandard(Adapter):
    pass

@provides(IraqStandard)
class EUStandardToIraqStandard(Adapter):
    pass

@provides(JapanStandard)
class UKStandardToJapanStandard(Adapter):
    pass

@provides(JapanStandard)
class TravelPlugToJapanStandard(Adapter):
    pass

@provides(EUStandard)
class TravelPlugToEUStandard(Adapter):
    pass


#### 'Editor, Scriptable, Undoable' metaphor ##################################

class FileType(HasTraits):
    pass

class IEditor(Interface):
    pass

class IScriptable(Interface):
    pass

class IUndoable(Interface):
    pass

@provides(IEditor, IScriptable)
class FileTypeToIEditor(Adapter):
    pass

@provides(IUndoable)
class IScriptableToIUndoable(Adapter):
    pass


#### Hierarchy example ########################################################

class IPrintable(Interface):
    pass

class Editor(HasTraits):
    pass

class TextEditor(Editor):
    pass

@provides(IPrintable)
class EditorToIPrintable(Adapter):
    pass

@provides(IPrintable)
class TextEditorToIPrintable(Adapter):
    pass


#### Interface hierarchy example ##############################################

class IPrimate(Interface):
    pass

class IHuman(IPrimate):
    pass

class IChild(IHuman):
    pass

class IIntermediate(Interface):
    pass

class ITarget(Interface):
    pass

@provides(IChild)
class Source(HasTraits):
    pass

@provides(IIntermediate)
class IChildToIIntermediate(Adapter):
    pass

@provides(IIntermediate)
class IHumanToIIntermediate(Adapter):
    pass

@provides(IIntermediate)
class IPrimateToIIntermediate(Adapter):
    pass

@provides(ITarget)
class IIntermediateToITarget(Adapter):
    pass


#### Non-trivial chaining example #############################################

class IStart(Interface):
    pass

class IGeneric(Interface):
    pass

class ISpecific(IGeneric):
    pass

class IEnd(Interface):
    pass

@provides(IStart)
class Start(HasTraits):
    pass

@provides(ISpecific)
class IStartToISpecific(Adapter):
    pass

@provides(IEnd)
class IGenericToIEnd(Adapter):
    pass

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = lazy_examples
""" Examples for lazy adapter factories.

This module should be only imported when the adaptation takes place.
"""


class IBar(object):
    pass

class IBarToIFoo(object):
    pass

class IFoo(object):
    pass

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_adaptation_manager
""" Test the adaptation manager. """

import sys

from traits.adaptation.api import AdaptationManager, adapt
import traits.adaptation.tests.abc_examples
import traits.adaptation.tests.interface_examples
from traits.testing.unittest_tools import unittest


class TestAdaptationManagerWithABC(unittest.TestCase):
    """ Test the adaptation manager. """

    #: Class attribute pointing at the module containing the example data
    examples = traits.adaptation.tests.abc_examples

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        """ Prepares the test fixture before each test method is called. """

        self.adaptation_manager = AdaptationManager()

        return

    def tearDown(self):
        """ Called immediately after each test method has been called. """

        return

    #### Tests ################################################################

    def test_no_adapter_required(self):

        ex = self.examples

        plug = ex.UKPlug()

        # Try to adapt it to its own concrete type.
        uk_plug = self.adaptation_manager.adapt(plug, ex.UKPlug)

        # The adaptation manager should simply return the same object.
        self.assertIs(uk_plug, plug)

        # Try to adapt it to an ABC that is registered for its type.
        uk_plug = self.adaptation_manager.adapt(plug, ex.UKStandard)

        # The adaptation manager should simply return the same object.
        self.assertIs(uk_plug, plug)

        return

    def test_no_adapter_available(self):

        ex = self.examples

        plug = ex.UKPlug()

        # Try to adapt it to a concrete type.
        eu_plug = self.adaptation_manager.adapt(plug, ex.EUPlug, None)

        # There should be no way to adapt a UKPlug to a EUPlug.
        self.assertEqual(eu_plug, None)

        # Try to adapt it to an ABC.
        eu_plug = self.adaptation_manager.adapt(plug, ex.EUStandard, None)

        # There should be no way to adapt a UKPlug to a EUPlug.
        self.assertEqual(eu_plug, None)

        return

    def test_one_step_adaptation(self):

        ex = self.examples

        # UKStandard->EUStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        plug = ex.UKPlug()

        # Adapt it to an ABC.
        eu_plug = self.adaptation_manager.adapt(plug, ex.EUStandard)
        self.assertIsNotNone(eu_plug)
        self.assertIsInstance(eu_plug, ex.UKStandardToEUStandard)

        # We shouldn't be able to adapt it to a *concrete* 'EUPlug' though.
        eu_plug = self.adaptation_manager.adapt(plug, ex.EUPlug, None)
        self.assertIsNone(eu_plug)

        return

    def test_adapter_chaining(self):

        ex = self.examples

        # UKStandard->EUStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        # EUStandard->JapanStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.EUStandardToJapanStandard,
            from_protocol = ex.EUStandard,
            to_protocol   = ex.JapanStandard
        )

        # Create a UKPlug.
        uk_plug = ex.UKPlug()

        # Adapt it to a JapanStandard via the chain.
        japan_plug = self.adaptation_manager.adapt(uk_plug, ex.JapanStandard)
        self.assertIsNotNone(japan_plug)
        self.assertIsInstance(japan_plug, ex.EUStandardToJapanStandard)
        self.assertIs(japan_plug.adaptee.adaptee, uk_plug)

        return

    def test_multiple_paths_unambiguous(self):

        ex = self.examples

        # UKStandard->EUStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        # EUStandard->JapanStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.EUStandardToJapanStandard,
            from_protocol = ex.EUStandard,
            to_protocol   = ex.JapanStandard
        )

        # JapanStandard->IraqStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.JapanStandardToIraqStandard,
            from_protocol = ex.JapanStandard,
            to_protocol   = ex.IraqStandard
        )

        # EUStandard->IraqStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.EUStandardToIraqStandard,
            from_protocol = ex.EUStandard,
            to_protocol   = ex.IraqStandard
        )

        # Create a UKPlug.
        uk_plug = ex.UKPlug()

        # Adapt it to a IraqStandard via the chain.
        iraq_plug = self.adaptation_manager.adapt(uk_plug, ex.IraqStandard)
        self.assertIsNotNone(iraq_plug)
        self.assertIsInstance(iraq_plug, ex.EUStandardToIraqStandard)
        self.assertIs(iraq_plug.adaptee.adaptee, uk_plug)

        return

    def test_multiple_paths_ambiguous(self):

        ex = self.examples

        # UKStandard->EUStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        # UKStandard->JapanStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.UKStandardToJapanStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.JapanStandard
        )

        # JapanStandard->IraqStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.JapanStandardToIraqStandard,
            from_protocol = ex.JapanStandard,
            to_protocol   = ex.IraqStandard
        )

        # EUStandard->IraqStandard.
        self.adaptation_manager.register_factory(
            factory       = ex.EUStandardToIraqStandard,
            from_protocol = ex.EUStandard,
            to_protocol   = ex.IraqStandard
        )

        # Create a UKPlug.
        uk_plug = ex.UKPlug()

        # Adapt it to a IraqStandard via the chain.
        iraq_plug = self.adaptation_manager.adapt(uk_plug, ex.IraqStandard)
        self.assertIsNotNone(iraq_plug)
        self.assertIn(
            type(iraq_plug),
            [ex.EUStandardToIraqStandard, ex.JapanStandardToIraqStandard]
        )
        self.assertIs(iraq_plug.adaptee.adaptee, uk_plug)

        return

    def test_conditional_adaptation(self):

        ex = self.examples

        # TravelPlug->EUStandard.
        def travel_plug_to_eu_standard(adaptee):
            if adaptee.mode == 'Europe':
                return ex.TravelPlugToEUStandard(adaptee=adaptee)

            else:
                return None

        self.adaptation_manager.register_factory(
            factory       = travel_plug_to_eu_standard,
            from_protocol = ex.TravelPlug,
            to_protocol   = ex.EUStandard
        )

        # Create a TravelPlug.
        travel_plug = ex.TravelPlug(mode='Europe')

        # Adapt it to a EUStandard.
        eu_plug = self.adaptation_manager.adapt(travel_plug, ex.EUStandard)
        self.assertIsNotNone(eu_plug)
        self.assertIsInstance(eu_plug, ex.TravelPlugToEUStandard)

        # Create a TravelPlug.
        travel_plug = ex.TravelPlug(mode='Asia')

        # Adapt it to a EUStandard.
        eu_plug = self.adaptation_manager.adapt(travel_plug, ex.EUStandard, None)
        self.assertIsNone(eu_plug)

        return

    def test_spillover_adaptation_behavior(self):

        ex = self.examples

        # FileType->IEditor.
        self.adaptation_manager.register_factory(
            factory       = ex.FileTypeToIEditor,
            from_protocol = ex.FileType,
            to_protocol   = ex.IEditor
        )

        # Meanwhile, in a plugin far, far away ...
        # IScriptable->IPrintable.
        self.adaptation_manager.register_factory(
            factory       = ex.IScriptableToIUndoable,
            from_protocol = ex.IScriptable,
            to_protocol   = ex.IUndoable
        )

        # Create a file type.
        file_type = ex.FileType()

        # Try to adapt to IPrintable: since we did not define an adapter
        # chain that goes from FileType to IPrintable, this should fail.
        printable = self.adaptation_manager.adapt(file_type, ex.IUndoable, None)
        self.assertIsNone(printable)

        return

    def test_adaptation_prefers_subclasses(self):

        ex = self.examples

        # TextEditor->IPrintable.
        self.adaptation_manager.register_factory(
            factory       = ex.TextEditorToIPrintable,
            from_protocol = ex.TextEditor,
            to_protocol   = ex.IPrintable
        )

        # Editor->IPrintable.
        self.adaptation_manager.register_factory(
            factory       = ex.EditorToIPrintable,
            from_protocol = ex.Editor,
            to_protocol   = ex.IPrintable
        )

        # Create a text editor.
        text_editor = ex.TextEditor()

        # Adapt to IPrintable: we should get the TextEditorToIPrintable
        # adapter, not the EditorToIPrintable one.
        printable = self.adaptation_manager.adapt(text_editor, ex.IPrintable)
        self.assertIsNotNone(printable)
        self.assertIs(type(printable), ex.TextEditorToIPrintable)

        return

    def test_adaptation_prefers_subclasses_other_registration_order(self):
        # This test is identical to `test_adaptation_prefers_subclasses`
        # with adapters registered in the opposite order. Both of them
        # should pass

        ex = self.examples

        # Editor->IPrintable.
        self.adaptation_manager.register_factory(
            factory       = ex.EditorToIPrintable,
            from_protocol = ex.Editor,
            to_protocol   = ex.IPrintable
        )

        # TextEditor->IPrintable.
        self.adaptation_manager.register_factory(
            factory       = ex.TextEditorToIPrintable,
            from_protocol = ex.TextEditor,
            to_protocol   = ex.IPrintable
        )

        # Create a text editor.
        text_editor = ex.TextEditor()

        # Adapt to IPrintable: we should get the TextEditorToIPrintable
        # adapter, not the EditorToIPrintable one.
        printable = self.adaptation_manager.adapt(text_editor, ex.IPrintable)
        self.assertIsNotNone(printable)
        self.assertIs(type(printable), ex.TextEditorToIPrintable)

        return

    def test_circular_adaptation(self):
        # Circles in the adaptation graph should not lead to infinite loops
        # when it is impossible to reach the target.

        class Foo(object):
            pass

        class Bar(object):
            pass

        # object->Foo
        self.adaptation_manager.register_factory(
            factory = lambda adaptee: Foo(),
            from_protocol = object,
            to_protocol   = Foo
        )

        # Foo->object
        self.adaptation_manager.register_factory(
            factory = lambda adaptee: [],
            from_protocol = Foo,
            to_protocol   = object
        )

        # Create an object.
        obj = []

        # Try to adapt to an unreachable target.
        bar = self.adaptation_manager.adapt(obj, Bar, None)
        self.assertIsNone(bar)

        return

    def test_default_argument_in_adapt(self):

        from traits.adaptation.adaptation_manager import AdaptationError

        # Without a default argument, a failed adaptation raises an error.
        with self.assertRaises(AdaptationError):
            self.adaptation_manager.adapt('string', int)

        # With a default argument, a failed adaptation returns the default.
        default = 'default'
        result = self.adaptation_manager.adapt('string', int, default=default)
        self.assertIs(result, default)

        return

    def test_prefer_specific_interfaces(self):

        ex = self.examples

        # IIntermediate -> ITarget.
        self.adaptation_manager.register_factory(
            factory       = ex.IIntermediateToITarget,
            from_protocol = ex.IIntermediate,
            to_protocol   = ex.ITarget
        )

        # IHuman -> IIntermediate.
        self.adaptation_manager.register_factory(
            factory       = ex.IHumanToIIntermediate,
            from_protocol = ex.IHuman,
            to_protocol   = ex.IIntermediate
        )

        # IChild -> IIntermediate.
        self.adaptation_manager.register_factory(
            factory       = ex.IChildToIIntermediate,
            from_protocol = ex.IChild,
            to_protocol   = ex.IIntermediate
        )

        # IPrimate -> IIntermediate.
        self.adaptation_manager.register_factory(
            factory       = ex.IPrimateToIIntermediate,
            from_protocol = ex.IPrimate,
            to_protocol   = ex.IIntermediate
        )

        # Create a source.
        source = ex.Source()

        # Adapt to ITarget: we should get the adapter for the most specific
        # interface, i.e. IChildToITarget.
        target = self.adaptation_manager.adapt(source, ex.ITarget)
        self.assertIsNotNone(target)
        self.assertIs(type(target.adaptee), ex.IChildToIIntermediate)

        return

    def test_chaining_with_intermediate_mro_climbing(self):

        ex = self.examples

        # IStart -> ISpecific.
        self.adaptation_manager.register_factory(
            factory       = ex.IStartToISpecific,
            from_protocol = ex.IStart,
            to_protocol   = ex.ISpecific
        )

        # IGeneric -> IEnd.
        self.adaptation_manager.register_factory(
            factory       = ex.IGenericToIEnd,
            from_protocol = ex.IGeneric,
            to_protocol   = ex.IEnd
        )

        # Create a start.
        start = ex.Start()

        # Adapt to IEnd; this should succeed going from IStart to ISpecific,
        # climbing up the MRO to IGeneric, then crossing to IEnd.
        end = self.adaptation_manager.adapt(start, ex.IEnd)
        self.assertIsNotNone(end)
        self.assertIs(type(end), ex.IGenericToIEnd)

        return

    def test_conditional_recycling(self):
        # Test that an offer that has been considered but failed if considered
        # again at a later time, when it might succeed because of conditional
        # adaptation.

        # C -- A -fails- B
        # C -- D -- A -succeeds- B

        class A(object):
            def __init__(self, allow_adaptation):
                self.allow_adaptation = allow_adaptation

        class B(object):
            pass

        class C(object):
            pass

        class D(object):
            pass

        self.adaptation_manager.register_factory(
            factory=lambda adaptee: A(False), from_protocol=C, to_protocol=A
        )
        self.adaptation_manager.register_factory(
            factory=lambda adaptee: A(True),  from_protocol=D, to_protocol=A
        )
        self.adaptation_manager.register_factory(
            factory=lambda adaptee: D(),      from_protocol=C, to_protocol=D
        )

        # Conditional adapter
        def a_to_b_adapter(adaptee):
            if adaptee.allow_adaptation:
                b = B()
                b.marker = True
            else:
                b = None
            return b

        self.adaptation_manager.register_factory(
            factory=a_to_b_adapter, from_protocol=A, to_protocol=B
        )

        # Create a A
        c = C()

        # Adaptation to B should succeed through D
        b = self.adaptation_manager.adapt(c, B)
        self.assertIsNotNone(b)
        self.assertTrue(hasattr(b, 'marker'))

        return

    def test_provides_protocol_for_interface_subclass(self):

        from traits.api import Interface

        class IA(Interface):
            pass

        class IB(IA):
            pass

        self.assertTrue(self.adaptation_manager.provides_protocol(IB, IA))

        return

    def test_register_provides(self):

        from traits.api import Interface

        class IFoo(Interface):
            pass

        obj = {}
        self.assertEqual(None, self.adaptation_manager.adapt(obj, IFoo, None))
        self.adaptation_manager.register_provides(dict, IFoo)
        self.assertEqual(obj, self.adaptation_manager.adapt(obj, IFoo))

        return


class TestAdaptationManagerWithInterfaces(TestAdaptationManagerWithABC):
    """ Test the adaptation manager with Interfaces. """

    examples = traits.adaptation.tests.interface_examples

    def test_adapts_should_register_class_as_providing_the_to_protocol(self):

        if sys.version_info[0] >= 3:
            self.skipTest("""
                Currently, under Python 3, class advisors do not work anymore.
                Therefore, this test will fail due to the use of "adapts".
            """)

        from traits.api import Adapter, adapts, HasTraits, Instance, \
             Int, Interface

        class IFoo(Interface):
            x = Int

        class Bar(HasTraits):
            foo = Instance(IFoo)

        class Baz(HasTraits):
            pass

        # Warning: because we are trying to test the 'adapts' class advisor,
        # this will effect the global adaptation manager and hence may
        # interfere with any other tests that rely on it (all of the tests
        # in this package use a separate adaptation manager so there should
        # be no clashes here ;^).
        #
        # 'adapts' is also deprecated, so expect a warning message when you
        # run the tests.
        class BazToIFooAdapter(Adapter):
            adapts(Baz, IFoo)

        baz = Baz()
        bar = Bar()
        bar.foo = adapt(baz, IFoo)

        self.assertEqual(bar.foo.adaptee, baz)

        return

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_adaptation_offer
""" Test the adaptation offers. """


import sys

from traits.adaptation.adaptation_offer import AdaptationOffer
from traits.testing.unittest_tools import unittest


class TestAdaptationOffer(unittest.TestCase):
    """ Test the adaptation offers. """

    def test_lazy_loading(self):

        LAZY_EXAMPLES = 'traits.adaptation.tests.lazy_examples'
        if LAZY_EXAMPLES in sys.modules:
            del sys.modules[LAZY_EXAMPLES]

        offer = AdaptationOffer(
            factory       =(LAZY_EXAMPLES + '.IBarToIFoo'),
            from_protocol =(LAZY_EXAMPLES + '.IBar'),
            to_protocol   =(LAZY_EXAMPLES + '.IFoo'),
        )

        self.assertNotIn(LAZY_EXAMPLES, sys.modules)

        factory = offer.factory

        self.assertIn(LAZY_EXAMPLES, sys.modules)

        from traits.adaptation.tests.lazy_examples import IBarToIFoo
        self.assertIs(factory, IBarToIFoo)


        del sys.modules[LAZY_EXAMPLES]

        from_protocol = offer.from_protocol

        from traits.adaptation.tests.lazy_examples import IBar
        self.assertIs(from_protocol, IBar)


        del sys.modules[LAZY_EXAMPLES]

        to_protocol = offer.to_protocol

        from traits.adaptation.tests.lazy_examples import IFoo
        self.assertIs(to_protocol, IFoo)


if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_adapter
""" Test the Adapter class. """


from traits.api import on_trait_change
from traits.adaptation.api import Adapter
from traits.testing.unittest_tools import unittest


class TestAdapter(unittest.TestCase):
    """ Test the Adapter class. """

    #### Tests #################################################################

    def test_initializing_adaptee(self):
        # Regression test: The `adaptee` trait used to be initialized after
        # all other traits, which caused "post_init" listeners to be
        # incorrectly triggered.

        class FooAdapter(Adapter):
            # True if a trait change notification for `adaptee` is fired.
            adaptee_notifier_called = False
            # True if a  post-init trait change notification for `adaptee`
            # is fired.
            post_init_notifier_called = False

            @on_trait_change('adaptee', post_init=True)
            def check_that_adaptee_start_can_be_accessed(self):
                self.post_init_notifier_called = True

            @on_trait_change('adaptee')
            def check_that_adaptee_change_is_notified(self):
                self.adaptee_notifier_called = True

        foo_adapter = FooAdapter(adaptee='1234')
        self.assertEqual(foo_adapter.adaptee_notifier_called, True)
        self.assertEqual(foo_adapter.post_init_notifier_called, False)


if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_cached_adapter_factory
""" Test the cached adapter factory. """


import sys

import traits.adaptation.tests.interface_examples
from traits.adaptation.api import AdaptationManager
from traits.adaptation.cached_adapter_factory import CachedAdapterFactory
from traits.testing.unittest_tools import unittest


class TestCachedAdapterFactory(unittest.TestCase):
    """ Test the cached adapter factory. """


    examples = traits.adaptation.tests.interface_examples

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        """ Prepares the test fixture before each test method is called. """

        self.adaptation_manager = AdaptationManager()

        return

    def tearDown(self):
        """ Called immediately after each test method has been called. """

        return

    #### Tests #################################################################

    def test_cached_adapters(self):

        ex = self.examples

        factory = CachedAdapterFactory(factory=ex.EditorToIPrintable)

        self.adaptation_manager.register_factory(
            factory       = factory,
            from_protocol = ex.Editor,
            to_protocol   = ex.IPrintable
        )

        editor = ex.Editor()

        adapter_1 = self.adaptation_manager.adapt(editor, ex.IPrintable)
        self.assertIsNotNone(adapter_1)
        self.assertIs(type(adapter_1), ex.EditorToIPrintable)

        adapter_2 = self.adaptation_manager.adapt(editor, ex.IPrintable)
        self.assertIsNotNone(adapter_2)
        self.assertIs(type(adapter_2), ex.EditorToIPrintable)

        self.assertIs(adapter_1, adapter_2)

        return

    @unittest.skip("Cache cleaning is broken: see GitHub issue #169")
    def test_cached_adapters_should_be_cleaned_up(self):

        ex = self.examples

        factory = CachedAdapterFactory(factory=ex.EditorToIPrintable)

        self.adaptation_manager.register_factory(
            factory       = factory,
            from_protocol = ex.Editor,
            to_protocol   = ex.IPrintable
        )

        editor = ex.Editor()

        adapter_1 = self.adaptation_manager.adapt(editor, ex.IPrintable)
        self.assertIsNotNone(adapter_1)
        self.assertIs(type(adapter_1), ex.EditorToIPrintable)

        del adapter_1
        del editor

        self.assertTrue(factory.is_empty)

        return

    def test_cached_adapters_with_lazy_loaded_factory(self):

        LAZY_EXAMPLES = 'traits.adaptation.tests.lazy_examples'
        if LAZY_EXAMPLES in sys.modules:
            del sys.modules[LAZY_EXAMPLES]

        factory = CachedAdapterFactory(factory=LAZY_EXAMPLES + '.IBarToIFoo')

        self.adaptation_manager.register_factory(
            factory       = factory,
            from_protocol = LAZY_EXAMPLES + '.IBar',
            to_protocol   = LAZY_EXAMPLES + '.IFoo',
        )

        self.assertNotIn(LAZY_EXAMPLES, sys.modules)

        # The *actual* factory is loaded on-demand.
        bogus = factory.factory

        self.assertIn(LAZY_EXAMPLES, sys.modules)

        return

    @unittest.skip("Cache cleaning is broken: see GitHub issue #169")
    def test_cached_adapter_that_was_garbage_collected(self):

        ex = self.examples

        factory = CachedAdapterFactory(factory=ex.EditorToIPrintable)

        self.adaptation_manager.register_factory(
            factory       = factory,
            from_protocol = ex.Editor,
            to_protocol   = ex.IPrintable
        )

        editor = ex.Editor()

        adapter_1 = self.adaptation_manager.adapt(editor, ex.IPrintable)
        self.assertIs(type(adapter_1), ex.EditorToIPrintable)
        adapter_1.marker = 'marker'

        del adapter_1

        adapter_2 = self.adaptation_manager.adapt(editor, ex.IPrintable)
        self.assertIsNotNone(adapter_2)
        self.assertTrue(hasattr(adapter_2, 'marker'))

        del adapter_2
        del editor

        self.assertTrue(factory.is_empty)

if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_global_adaptation_manager
""" Test the setting/getting/resetting/using the global adaptation manager. """

from traits.adaptation.api import adapt, AdaptationError, AdaptationManager, \
    AdaptationOffer, get_global_adaptation_manager, provides_protocol, \
    register_factory, register_provides, register_offer, \
    reset_global_adaptation_manager, set_global_adaptation_manager, \
    supports_protocol
import traits.adaptation.tests.abc_examples
from traits.testing.unittest_tools import unittest


class TestGlobalAdaptationManager(unittest.TestCase):
    """ Test the setting/getting/resetting/using the global adaptation manager.
    """

    #: Class attribute pointing at the module containing the example data
    examples = traits.adaptation.tests.abc_examples

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        """ Prepares the test fixture before each test method is called. """

        reset_global_adaptation_manager()

    #### Tests ################################################################

    def test_reset_adaptation_manager(self):
        ex = self.examples
        adaptation_manager = get_global_adaptation_manager()

        # UKStandard->EUStandard.
        adaptation_manager.register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard,
        )

        # Create a UKPlug.
        uk_plug = ex.UKPlug()

        reset_global_adaptation_manager()
        adaptation_manager = get_global_adaptation_manager()

        with self.assertRaises(AdaptationError):
            adaptation_manager.adapt(uk_plug, ex.EUStandard)

    def test_set_adaptation_manager(self):
        ex = self.examples
        adaptation_manager = AdaptationManager()

        # UKStandard->EUStandard.
        adaptation_manager.register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        # Create a UKPlug.
        uk_plug = ex.UKPlug()

        set_global_adaptation_manager(adaptation_manager)
        global_adaptation_manager = get_global_adaptation_manager()

        eu_plug = global_adaptation_manager.adapt(uk_plug, ex.EUStandard)
        self.assertIsNotNone(eu_plug)
        self.assertIsInstance(eu_plug, ex.UKStandardToEUStandard)

    def test_global_convenience_functions(self):
        ex = self.examples

        # Global `register_factory`.
        register_factory(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        uk_plug = ex.UKPlug()
        # Global `adapt`.
        eu_plug = adapt(uk_plug, ex.EUStandard)
        self.assertIsNotNone(eu_plug)
        self.assertIsInstance(eu_plug, ex.UKStandardToEUStandard)

        # Global `provides_protocol`.
        self.assertTrue(provides_protocol(ex.UKPlug, ex.UKStandard))

        # Global `supports_protocol`.
        self.assertTrue(supports_protocol(uk_plug, ex.EUStandard))

    def test_global_register_provides(self):
        from traits.api import Interface

        class IFoo(Interface):
            pass

        obj = {}
        # Global `register_provides`.
        register_provides(dict, IFoo)
        self.assertEqual(obj, adapt(obj, IFoo))

    def test_global_register_offer(self):
        ex = self.examples

        offer = AdaptationOffer(
            factory       = ex.UKStandardToEUStandard,
            from_protocol = ex.UKStandard,
            to_protocol   = ex.EUStandard
        )

        # Global `register_offer`.
        register_offer(offer)

        uk_plug = ex.UKPlug()
        eu_plug = adapt(uk_plug, ex.EUStandard)
        self.assertIsNotNone(eu_plug)
        self.assertIsInstance(eu_plug, ex.UKStandardToEUStandard)


if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = adapter
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Martin Chilvers
#  Date:   07/18/2007
#
#-------------------------------------------------------------------------------

""" An extension to PyProtocols to simplify the declaration of adapters.
"""


from __future__ import absolute_import


import traits.adaptation.adapter
from .util.deprecated import deprecated


class Adapter(traits.adaptation.adapter.Adapter):

    @deprecated("use 'Adapter' in 'traits.api' instead")
    def __init__(self, adaptee, **traits):
        super(Adapter, self).__init__(adaptee, **traits)


adapts = deprecated("use 'adapts' in 'traits.api' instead")(
    traits.adaptation.adapter.adapts
)

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/06/2005
#
#------------------------------------------------------------------------------

""" Pseudo-package for all of the core symbols from Traits and TraitsUI.
Use this module for importing Traits names into your namespace. For example::

    from traits.api import HasTraits
"""

from __future__ import absolute_import

from .trait_base import Uninitialized, Undefined, Missing, Self, python_version

from .trait_errors import TraitError, TraitNotificationError, DelegationError

from .trait_notifiers import (push_exception_handler, pop_exception_handler,
        TraitChangeNotifyWrapper)

from .category import Category

from .traits import (CTrait, Trait, Property, TraitFactory, Default, Color,
        RGBColor, Font)

from .trait_types import (Any, Generic, Int, Long, Float, Complex, Str, Title,
        Unicode, Bool, CInt, CLong, CFloat, CComplex, CStr, CUnicode, CBool,
        String, Regex, Code, HTML, Password, Callable, This, self, Function,
        Method, Module, Python, ReadOnly, Disallow, Constant,
        Delegate, DelegatesTo, PrototypedFrom, Expression, PythonValue, File,
        Directory, Range, Enum, Tuple, List, CList, Set, CSet, Dict, Instance,
        AdaptedTo, AdaptsTo, Event, Button, ToolbarButton, Either, Type,
        Symbol, WeakRef, Date, Time, false, true, undefined, Supports)

from .trait_types import (ListInt, ListFloat, ListStr, ListUnicode,
        ListComplex, ListBool, ListFunction, ListMethod, 
        ListThis, DictStrAny, DictStrStr, DictStrInt,
        DictStrLong, DictStrFloat, DictStrBool, DictStrList)

try:
    from .trait_types import Class, ListClass, ListInstance
except ImportError:
    # Python 3 does not have old-style classes anymore, so Class does not exist
    # interestingly, ListInstance is not equivalent to List(Instance), but
    # rather only allows old-style instances.
    pass

from .trait_types import (BaseInt, BaseLong, BaseFloat, BaseComplex, BaseStr,
        BaseUnicode, BaseBool, BaseCInt, BaseCLong, BaseCFloat, BaseCComplex,
        BaseCStr, BaseCUnicode, BaseCBool, BaseFile, BaseDirectory, BaseRange,
        BaseEnum, BaseTuple, BaseInstance)

from .trait_types import UUID

from .has_traits import (HasTraits, HasStrictTraits, HasPrivateTraits,
        Interface, SingletonHasTraits, SingletonHasStrictTraits,
        SingletonHasPrivateTraits, MetaHasTraits, Vetoable, VetoableEvent,
        implements, traits_super, on_trait_change, cached_property,
        property_depends_on, provides, isinterface)

try:
    from .has_traits import ABCHasTraits, ABCHasStrictTraits, ABCMetaHasTraits
except ImportError:
    pass

from .trait_handlers import (BaseTraitHandler, TraitType, TraitHandler,
        TraitRange, TraitString, TraitCoerceType, TraitCastType, TraitInstance,
        ThisClass, TraitClass, TraitFunction, TraitEnum, TraitPrefixList,
        TraitMap, TraitPrefixMap, TraitCompound, TraitList, TraitListObject,
        TraitListEvent, TraitSetObject, TraitSetEvent, TraitDict,
        TraitDictObject, TraitDictEvent, TraitTuple, NO_COMPARE,
        OBJECT_IDENTITY_COMPARE, RICH_COMPARE)

from .trait_value import (BaseTraitValue, TraitValue, SyncValue,
        TypeValue, DefaultValue)

from .adaptation.adapter import Adapter, adapts
from .adaptation.adaptation_error import AdaptationError
from .adaptation.adaptation_manager import adapt, register_factory, \
     register_provides

from .trait_numeric import Array, CArray

try:
    from . import has_traits as has_traits
    #---------------------------------------------------------------------------
    #  Patch the main traits module with the correct definition for the
    #  ViewElements class:
    #  NOTE: We do this in a try..except block because traits.ui depends on
    #  the pyface module (part of the TraitsGUI package) which may not
    #  necessarily be installed. Not having TraitsGUI means that the 'ui'
    #  features of traits will not work.
    #---------------------------------------------------------------------------

    from traitsui import view_elements
    has_traits.ViewElements = view_elements.ViewElements

    #-------------------------------------------------------------------------------
    #  Patch the main traits module with the correct definition for the
    #  ViewElement and ViewSubElement class:
    #-------------------------------------------------------------------------------

    has_traits.ViewElement = view_elements.ViewElement
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = category
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/06/2004
#
#------------------------------------------------------------------------------

""" Adds a "category" capability to Traits-based classes, similar to that
    provided by the Cocoa (Objective-C) environment for the Macintosh.

    You can use categories to extend an existing HasTraits class, as an
    alternative to subclassing. An advantage of categories over subclassing is
    that you can access the added members on instances of the original class,
    without having to change them to instances of a subclass. Unlike
    subclassing, categories do not allow overriding trait attributes.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .has_traits import MetaHasTraits, MetaHasTraitsObject

#-------------------------------------------------------------------------------
#  'MetaCategory' class:
#-------------------------------------------------------------------------------

class MetaCategory ( MetaHasTraits ):

    def __new__ ( cls, class_name, bases, class_dict ):

        # Make sure the correct usage is being applied:
        if len( bases ) > 2:
            raise TypeError, \
                  "Correct usage is: class FooCategory(Category,Foo):"

        # Process any traits-related information in the class dictionary:
        MetaCategoryObject( cls, class_name, bases, class_dict, True )

        # Move all remaining items in our class dictionary to the base class's
        # dictionary:
        if len( bases ) == 2:
            category_class = bases[1]
            for name, value in class_dict.items():
                if not hasattr( category_class, name ):
                    setattr( category_class, name, value )
                    del class_dict[ name ]

        # Finish building the class using the updated class dictionary:
        return type.__new__( cls, class_name, bases, class_dict )

#-------------------------------------------------------------------------------
#  'MetaCategoryObject' class:
#-------------------------------------------------------------------------------

class MetaCategoryObject ( MetaHasTraitsObject ):

    #---------------------------------------------------------------------------
    #  Adds the traits meta-data to the class:
    #---------------------------------------------------------------------------

    def add_traits_meta_data ( self, bases, class_dict, base_traits,
                               class_traits, instance_traits, prefix_traits,
                               listeners, view_elements ):
        if len( bases ) == 2:
            # Update the class and each of the existing subclasses:
            bases[1]._add_trait_category( base_traits, class_traits,
                      instance_traits, prefix_traits, listeners,
                      view_elements )
        else:
            MetaHasTraitsObject.add_traits_meta_data( self, bases,
                   class_dict, base_traits, class_traits, instance_traits,
                   prefix_traits, listeners, view_elements )

#-------------------------------------------------------------------------------
#  'Category' class:
#-------------------------------------------------------------------------------

class Category ( object ):
    """ Used for defining "category" extensions to existing classes.

    To define a class as a category, specify "Category," followed by the name
    of the base class name in the base class list.

    The following example demonstrates defining a category::

        from traits.api import HasTraits, Str, Category

        class Base(HasTraits):
            x = Str("Base x")
            y = Str("Base y")

        class BaseExtra(Category, Base):
            z = Str("BaseExtra z")
    """

    __metaclass__ = MetaCategory


########NEW FILE########
__FILENAME__ = api
from etsconfig import ETSConfig

########NEW FILE########
__FILENAME__ = etsconfig
""" Enthought Tool Suite configuration information. """


# Standard library imports.
import sys
import os
from os import path


class ETSConfig(object):
    """
    Enthought Tool Suite configuration information.

    This class should not use ANY other package in the tool suite so that it
    will always work no matter which other packages are present.

    """

    ###########################################################################
    # 'object' interface.
    ###########################################################################

    #### operator methods #####################################################

    def __init__(self):
        """
        Constructor.

        Note that this constructor can only ever be called from within this
        module, since we don't expose the class.

        """

        # Shadow attributes for properties.
        self._application_data = None
        self._application_home = None
        self._company          = None
        self._toolkit          = None
        self._kiva_backend     = None
        self._user_data        = None

        return


    ###########################################################################
    # 'ETSConfig' interface.
    ###########################################################################

    #### properties ###########################################################

    def get_application_data(self, create=False):
        """ Return the application data directory path.

            Parameters
            ----------
            create: bool
                Create the corresponding directory or not.

            Notes
            -----
            - This is a directory that applications and packages can safely
              write non-user accessible data to i.e. configuration
              information, preferences etc.

            - Do not put anything in here that the user might want to
              navigate to e.g. projects, user data files etc.

            - The actual location differs between operating systems.

       """
        if self._application_data is None:
            self._application_data = \
                    self._initialize_application_data(create=create)

        return self._application_data


    def _get_application_data(self):
        """ Property getter, see get_application_data's docstring.
        """
        return self.get_application_data(create=True)


    def _set_application_data(self, application_data):
        """
        Property setter.

        """

        self._application_data = application_data

        return

    def get_application_home(self, create=False):
        """ Return the application home directory path.

            Parameters
            ----------
            create: bool
                Create the corresponding directory or not.

            Note
            ----
            - This is a directory named after the current, running
              application that imported this module that applications and
              packages can safely write non-user accessible data to i.e.
              configuration information, preferences etc.  It is a
              sub-directory of self.application_data, named after the
              directory that contains the "main" python script that started
              the process.  For example, if application foo is started with
              a script named "run.py" in a directory named "foo", then the
              application home would be: <ETSConfig.application_data>/foo,
              regardless of if it was launched with "python
              <path_to_foo>/run.py" or "cd <path_to_foo>; python run.py"

            - This is useful for library modules used in apps that need to
              store state, preferences, etc. for the specific app only, and
              not for all apps which use that library module.  If the
              library module uses ETSConfig.application_home, they can
              store prefs for the app all in one place and do not need to
              know the details of where each app might reside.

            - Do not put anything in here that the user might want to
              navigate to e.g. projects, user home files etc.

            - The actual location differs between operating systems.

       """
        if self._application_home is None:
            self._application_home = path.join(
                                self.get_application_data(create=create),
                                self._get_application_dirname())

        return self._application_home



    application_data = property(_get_application_data, _set_application_data)


    def _get_application_home(self):
        """ Property getter, see get_application_home's docstring.
        """
        return self.get_application_home(create=True)


    def _set_application_home(self, application_home):
        """
        Property setter.

        """

        self._application_home = application_home

        return


    application_home = property(_get_application_home, _set_application_home)


    def _get_company(self):
        """
        Property getter.

        """

        if self._company is None:
            self._company = self._initialize_company()

        return self._company


    def _set_company(self, company):
        """
        Property setter for the company name.

        """

        self._company = company

        return


    company = property(_get_company, _set_company)


    def _get_toolkit(self):
        """
        Property getter for the GUI toolkit.  The value returned is, in order
        of preference: the value set by the application; the value passed on
        the command line using the '-toolkit' option; the value specified by
        the 'ETS_TOOLKIT' environment variable; otherwise the empty string.

        """

        if self._toolkit is None:
            self._toolkit = self._initialize_toolkit()

        return self._toolkit.split('.')[0]


    def _set_toolkit(self, toolkit):
        """
        Property setter for the GUI toolkit.  The toolkit can be set more than
        once, but only if it is the same one each time.  An application that is
        written for a particular toolkit can explicitly set it before any other
        module that gets the value is imported.

        """

        if self._toolkit and self._toolkit != toolkit:
            raise ValueError, "cannot set toolkit to %s because it has "\
                            "already been set to %s" % (toolkit, self._toolkit)

        self._toolkit = toolkit

        return


    toolkit = property(_get_toolkit, _set_toolkit)

    def _get_enable_toolkit(self):
        """
        Deprecated: This property is no longer used.

        Property getter for the Enable backend.  The value returned is, in order
        of preference: the value set by the application; the value passed on
        the command line using the '-toolkit' option; the value specified by
        the 'ENABLE_TOOLKIT' environment variable; otherwise the empty string.
        """
        from warnings import warn
        warn('Use of the enable_toolkit attribute is deprecated.')

        return self.toolkit


    def _set_enable_toolkit(self, toolkit):
        """
        Deprecated.

        Property setter for the Enable toolkit.  The toolkit can be set more than
        once, but only if it is the same one each time.  An application that is
        written for a particular toolkit can explicitly set it before any other
        module that gets the value is imported.
        """
        from warnings import warn
        warn('Use of the enable_toolkit attribute is deprecated.')

        return


    enable_toolkit = property(_get_enable_toolkit, _set_enable_toolkit)

    def _get_kiva_backend(self):
        """
        Property getter for the Kiva backend. The value returned is dependent
        on the value of the toolkit property. If toolkit specifies a kiva backend
        using the extended syntax: <enable toolkit>[.<kiva backend>] then the
        value of the property will be whatever was specified. Otherwise the
        value will be a reasonable default for the given enable backend.
        """
        if self._toolkit is None:
            raise AttributeError, "The kiva_backend attribute is dependent on toolkit, which has not been set."

        if self._kiva_backend is None:
            try:
                self._kiva_backend = self._toolkit.split('.')[1]
            except IndexError:
                # Pick a reasonable default based on the toolkit
                if self.toolkit == "wx":
                    self._kiva_backend = "quartz" if sys.platform == "darwin" else "image"
                elif self.toolkit == "qt4":
                    self._kiva_backend = "image"
                elif self.toolkit == "pyglet":
                    self._kiva_backend = "gl"
                else:
                    self._kiva_backend = "image"

        return self._kiva_backend

    kiva_backend = property(_get_kiva_backend)

    def _get_user_data(self):
        """
        Property getter.

        This is a directory that users can safely write user accessible data
        to i.e. user-defined functions, edited functions, etc.

        The actual location differs between operating systems.

        """

        if self._user_data is None:
            self._user_data = self._initialize_user_data()

        return self._user_data


    def _set_user_data(self, user_data):
        """
        Property setter.

        """

        self._user_data = user_data

        return


    user_data = property(_get_user_data, _set_user_data)


    #### private methods #####################################################

    # fixme: In future, these methods could allow the properties to be set
    # via the (as yet non-existent) preference/configuration mechanism. This
    # would allow configuration via (in order of precedence):-
    #
    # - a configuration file
    # - environment variables
    # - the command line

    def _get_application_dirname(self):
        """
        Return the name of the directory (not a path) that the "main"
        Python script which started this process resides in, or "" if it could
        not be determined or is not appropriate.

        For example, if the script that started the current process was named
        "run.py" in a directory named "foo", and was launched with "python
        run.py", the name "foo" would be returned (this assumes the directory
        name is the name of the app, which seems to be as good of an assumption
        as any).

        """

        dirname = ""

        main_mod = sys.modules.get('__main__', None)
        if main_mod is not None:
            if hasattr(main_mod, '__file__'):
                main_mod_file = path.abspath(main_mod.__file__)
                dirname = path.basename(path.dirname(main_mod_file))

        return dirname


    def _initialize_application_data(self, create=True):
        """
        Initializes the (default) application data directory.

        """

        if sys.platform == 'win32':
            environment_variable = 'APPDATA'
            directory_name       = self.company

        else:
            environment_variable = 'HOME'
            directory_name       = '.' + self.company.lower()

        # Lookup the environment variable.
        parent_directory = os.environ.get(environment_variable, None)
        if parent_directory is None or parent_directory == '/root':
            import tempfile
            from warnings import warn
            parent_directory = tempfile.gettempdir()
            user = os.environ.get('USER', None)
            if user is not None:
                directory_name += "_%s" % user
            warn('Environment variable "%s" not set, setting home directory to %s' % \
                (environment_variable, parent_directory))

        application_data = os.path.join(parent_directory, directory_name)

        if create:
            # If a file already exists with this name then make sure that it is
            # a directory!
            if os.path.exists(application_data):
                if not os.path.isdir(application_data):
                    raise ValueError('File "%s" already exists'
                                                    % application_data)

            # Otherwise, create the directory.
            else:
                os.makedirs(application_data)

        return application_data


    def _initialize_company(self):
        """
        Initializes the (default) company.

        """

        return 'Enthought'


    def _initialize_toolkit(self):
        """
        Initializes the toolkit.

        """
        # We handle the command line option even though it doesn't have the
        # highest precedence because we always want to remove it from the
        # command line.
        if '-toolkit' in sys.argv:
            opt_idx = sys.argv.index('-toolkit')

            try:
                opt_toolkit = sys.argv[opt_idx + 1]
            except IndexError:
                raise ValueError, "the -toolkit command line argument must be followed by a toolkit name"

            # Remove the option.
            del sys.argv[opt_idx:opt_idx + 1]
        else:
            opt_toolkit = None

        if self._toolkit is not None:
            toolkit = self._toolkit
        elif opt_toolkit is not None:
            toolkit = opt_toolkit
        else:
            toolkit = os.environ.get('ETS_TOOLKIT', '')

        return toolkit


    def _initialize_user_data(self):
        """
        Initializes the (default) user data directory.

        """

        # We check what the os.path.expanduser returns
        parent_directory = os.path.expanduser('~')
        directory_name = self.company


        if sys.platform == 'win32':
            try:
                from win32com.shell import shell, shellcon

                # Due to the fact that the user's My Documents directory can
                # be in some pretty strange places, it's safest to just ask
                # Windows where it is.
                MY_DOCS = shellcon.CSIDL_PERSONAL
                parent_directory = shell.SHGetFolderPath(0, MY_DOCS, 0, 0)
            except ImportError:
                # But if they don't have pywin32 installed, just do it the
                # naive way...

                # Check if the usr_dir is C:\\John Doe\\Documents and Settings.
                # If yes, then we should modify the usr_dir to be 'My Documents'.
                # If no, then the user must have modified the os.environ
                # variables and the directory chosen is a desirable one.
                desired_dir = os.path.join(parent_directory, 'My Documents')

                if os.path.exists(desired_dir):
                    parent_directory = desired_dir

        else:
            directory_name = directory_name.lower()

        # The final directory.
        usr_dir = os.path.join(parent_directory, directory_name)

        # If a file already exists with this name then make sure that it is
        # a directory!
        if os.path.exists(usr_dir):
            if not os.path.isdir(usr_dir):
                raise ValueError('File "%s" already exists' % usr_dir)

        # Otherwise, create the directory.
        else:
            os.makedirs(usr_dir)

        return usr_dir



# We very purposefully only have one object and do not export the class. We
# could have just made everything class methods, but that always seems a bit
# gorpy, especially with properties etc.
ETSConfig = ETSConfig()


#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_etsconfig
""" Tests the 'ETSConfig' configuration object. """


# Standard library imports.
import os, time, unittest

# Enthought library imports.
from traits.etsconfig.api import ETSConfig


# FIXME: Unit tests should not touch files/directories outside of a staging area.

class ETSConfigTestCase(unittest.TestCase):
    """ Tests the 'ETSConfig' configuration object. """

    ###########################################################################
    # 'TestCase' interface.
    ###########################################################################

    #### public methods #######################################################

    def setUp(self):
        """
        Prepares the test fixture before each test method is called.

        """

        # Make a fresh instance each time.
        self.ETSConfig = type(ETSConfig)()

    ###########################################################################
    # 'ETSConfigTestCase' interface.
    ###########################################################################

    #### public methods #######################################################

    def test_application_data(self):
        """
        application data

        """

        dirname = self.ETSConfig.application_data

        self.assertEqual(os.path.exists(dirname), True)
        self.assertEqual(os.path.isdir(dirname), True)

        return

    def test_set_application_data(self):
        """
        set application data

        """

        old = self.ETSConfig.application_data

        self.ETSConfig.application_data = 'foo'
        self.assertEqual('foo', self.ETSConfig.application_data)

        self.ETSConfig.application_data = old
        self.assertEqual(old, self.ETSConfig.application_data)

        return


    def test_application_data_is_idempotent(self):
        """
        application data is idempotent

        """

        # Just do the previous test again!
        self.test_application_data()
        self.test_application_data()

        return


    def test_write_to_application_data_directory(self):
        """
        write to application data directory

        """

        self.ETSConfig.company = 'Blah'
        dirname = self.ETSConfig.application_data

        path = os.path.join(dirname, 'dummy.txt')
        data = str(time.time())

        f = open(path, 'w')
        f.write(data)
        f.close()

        self.assertEqual(os.path.exists(path), True)

        f = open(path)
        result = f.read()
        f.close()

        os.remove(path)

        self.assertEqual(data, result)

        return


    def test_default_company(self):
        """
        default company

        """

        self.assertEqual(self.ETSConfig.company, 'Enthought')

        return


    def test_set_company(self):
        """
        set company

        """

        old = self.ETSConfig.company

        self.ETSConfig.company = 'foo'
        self.assertEqual('foo', self.ETSConfig.company)

        self.ETSConfig.company = old
        self.assertEqual(old, self.ETSConfig.company)

        return


    def _test_default_application_home(self):
        """
        application home

        """

        # This test is only valid when run with the 'main' at the end of this
        # file: "python app_dat_locator_test_case.py", in which case the
        # app_name will be the directory this file is in ('tests').
        app_home = self.ETSConfig.application_home
        (dirname, app_name) = os.path.split(app_home)

        self.assertEqual(dirname, self.ETSConfig.application_data)
        self.assertEqual(app_name, 'tests')


    def test_user_data(self):
        """
        user data

        """

        dirname = self.ETSConfig.user_data

        self.assertEqual(os.path.exists(dirname), True)
        self.assertEqual(os.path.isdir(dirname), True)

        return


    def test_set_user_data(self):
        """
        set user data

        """

        old = self.ETSConfig.user_data

        self.ETSConfig.user_data = 'foo'
        self.assertEqual('foo', self.ETSConfig.user_data)

        self.ETSConfig.user_data = old
        self.assertEqual(old, self.ETSConfig.user_data)

        return


    def test_user_data_is_idempotent(self):
        """
        user data is idempotent

        """

        # Just do the previous test again!
        self.test_user_data()

        return


    def test_write_to_user_data_directory(self):
        """
        write to user data directory

        """

        self.ETSConfig.company = 'Blah'
        dirname = self.ETSConfig.user_data

        path = os.path.join(dirname, 'dummy.txt')
        data = str(time.time())

        f = open(path, 'w')
        f.write(data)
        f.close()

        self.assertEqual(os.path.exists(path), True)

        f = open(path)
        result = f.read()
        f.close()

        os.remove(path)

        self.assertEqual(data, result)

        return


# For running as an individual set of tests.
if __name__ == '__main__':

    # Add the non-default test of application_home...non-default because it must
    # be run using this module as a script to be valid.
    suite = unittest.TestLoader().loadTestsFromTestCase(ETSConfigTestCase)
    suite.addTest(ETSConfigTestCase('_test_default_application_home'))

    unittest.TextTestRunner(verbosity=2).run(suite)


#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = has_dynamic_views
#-----------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Dave Peterson <dpeterson@enthought.com>
#
#-----------------------------------------------------------------------------

"""
Provides a framework that assembles Traits UI Views at run time,
when the view is requested, rather than at the time a class is written.

This capability is particularly useful when the object being 'viewed' with a
Traits UI is part of a plug-in application -- such as Envisage.  In general,
this capability allows:

*  The GUI for an object can be extendable by contributions
   other than from the original code writer.
*  The view can be dynamic in that the elements it is composed
   of can change each time it is requested.
*  Registration of a handler can be associated with the view contributions.

Either the original object writer, or a contributor, can use this framework to
declare one or more dynamic views that are composed of sub-elements that only
need to exist at the time the view is requested.

Users of this framework create a dynamic view by registering a DynamicView
declaration.  That declaration includes a name that forms the basis for the
metadata attributes that are used to identify and order the desired view
sub-elements into the view's composition.  In addition, the declaration
includes any data to be passed into the constructor of the dynamic view and
the id that should be used to persist the user's customization of the view.

Additionally, this framework allows sub-elements themselves to also be
dynamically composed of further sub-elements.

For example, a dynamic view could be composed of two sub-elements:

1. The first is a dynamically composed HFlow, which represents a toolbar
   that can be extended through contributions of toolbar buttons.
2. The second could be a dynamic tabset where each page is also a
   contribution.

Programmers include dynamic sub-elements within their dynamic views by
contributing a DynamicViewSubElement into that view.  When the framework comes
across this contribution while building the view, it replaces that
DynamicViewSubElement with a fully initialized Traits ViewSubElement composed
in a manner similar to how the elements of the View itself were composed.

Each contribution to a dynamic view or sub-element must be an instance of a
Traits ViewSubElement and must have associated metadata like the following for
each dynamic view or sub-element it will display in:

_<dynamic name>_order : A float value.
    The framework uses only ViewSubElements with this metadata
    instantiated when building the dynamic view or sub-element with
    the specified name.  The elements are sorted by ascending
    order of this value using the standard list sort function.
_<dynamic name>_priority : A float value.
    The framework resolves any overloading of an order value by
    picking the first element encountered that has the highest
    priority value. The other elements with the same view order are
    not displayed at all.

In addition, dynamic view contributions can also provide a 'handler', which
behaves like a normal Traits Handler.  That is, it can contain methods that
are called when model values change and can access  the Traits UIInfo
object representing the actual UI instances.  To provide a handler, append the
following metadata to your view sub-element:

_<dynamic_name>_handler : A HasTraits instance.
    The framework will connect listeners to call the handler methods as
    part of the handler for the dynamic view.


"""

from __future__ import absolute_import

# Enthought library imports:
from traitsui.delegating_handler import DelegatingHandler

# Local imports:
from .has_traits import HasTraits
from .trait_types import Any, Bool, Dict, Instance, Str
from traitsui.api import View, ViewSubElement, ViewElement

# Set up a logger:
import logging
logger = logging.getLogger( __name__ )

#-------------------------------------------------------------------------------
#  'DynamicViewSubElement' class:
#-------------------------------------------------------------------------------

class DynamicViewSubElement ( ViewSubElement ):
    """
    Declares a dynamic sub-element of a dynamic view.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #-- Public 'DynamicViewSubElement' Interface -------------------------------

    #: Keyword arguments passed in during construction of the actual
    #: ViewSubElement instance.
    keywords = Dict

    # FIXME: Should be the 'Class' trait but I couldn't get that to work.
    #: The class of the actual ViewSubElement we are dynamically creating.
    klass = Any

    #: The name of this dynamic sub-element.  This controls the metadata
    #: names identifying the sub-elements that compose this element.
    name = Str

#-------------------------------------------------------------------------------
#  'DynamicView' class:
#-------------------------------------------------------------------------------

class DynamicView ( HasTraits ):
    """
    Declares a dynamic view.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #-- Public 'DynamicView' Interface -----------------------------------------

    #: The ID of the view.  This is the ID that the view's preferences will be
    #: saved under.
    id = Str

    #: The name of the view.  This is the name that should be requested when
    #: calling edit_traits() or configure_traits().
    name = Str

    #: Keyword arguments passed in during construction of the actual view
    #: instance.
    keywords = Dict

    #: Indicates whether this view should be the default traits view for objects
    #: it is contributed to.
    use_as_default = Bool( False )


#-------------------------------------------------------------------------------
#  'HasDynamicViews' class:
#-------------------------------------------------------------------------------

class HasDynamicViews ( HasTraits ):
    """
    Provides of a framework that builds Traits UI Views at run time,
    when the view is requested, rather than at the time a class is written.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #-- Protected 'HasDynamicViews' Interface ----------------------------------

    #: The registry of dynamic views.  The key is the view name and the value
    #: is the declaration of the dynamic view.
    _dynamic_view_registry = Dict( Str, Instance( DynamicView ) )

    #---------------------------------------------------------------------------
    #  'HasTraits' interface:
    #---------------------------------------------------------------------------

    #-- Public Interface -------------------------------------------------------

    def trait_view ( self, name = None, view_element = None ):
        """ Gets or sets a ViewElement associated with an object's class.

            Extended here to build dynamic views and sub-elements.
        """

        result = None

        # If a view element was passed instead of a name or None, do not handle
        # this as a request for a dynamic view and let the standard Traits
        # trait_view method be called with it.  Otherwise, compose the dynamic
        # view here.
        if not isinstance( name, ViewElement ):

            # If this is a request for the default view, see if one of our
            # dynamic views should be the default view:
            if (view_element is None) and (name is None or len( name ) < 1):
                for dname, declaration in self._dynamic_view_registry.items():
                    if declaration.use_as_default:
                        result = self._compose_dynamic_view( dname )
                        break

            # Otherwise, handle if this is a request for a dynamic view:
            elif ((view_element is None) and
                  (name in self._dynamic_view_registry)):
                result = self._compose_dynamic_view(name)

        # If we haven't created a dynamic view so far, then do the standard
        # traits thing to retrieve the UI element:
        if result is None:
            result = super( HasDynamicViews, self ).trait_view( name,
                                                                view_element )

        return result

    #---------------------------------------------------------------------------
    #  'HasDynamicViews' interface:
    #---------------------------------------------------------------------------

    #-- Public Interface -------------------------------------------------------

    def declare_dynamic_view ( self, declaration ):
        """ A convenience method to add a new dynamic view declaration to this
            instance.
        """
        self._dynamic_view_registry[ declaration.name ] = declaration

    #-- Protected Interface ----------------------------------------------------

    def _build_dynamic_sub_element ( self, definition, sub_elements ):
        """ Returns the fully composed ViewSubElement from the sub-element
            contributions to the dynamic sub-element identified by the
            definition.
        """
        logger.debug( '\tBuilding dynamic sub-element [%s] with elements [%s]',
                      definition.name, sub_elements )

        return definition.klass( *sub_elements, **definition.keywords )


    def _build_dynamic_view (self, declaration, sub_elements, handler ):
        """ Returns a Traits View representing the specified dynamic view
            composed out of the provided view sub-elements.

            Implemented as a separate method to allow implementors to override
            the way in which the instantiated view is configured.
        """
        logger.debug( '\tBuilding dynamic view [%s] with elements [%s]',
                      declaration.name, sub_elements )

        return View(
            # The view id allows the user's customization of this view, if any,
            # to be persisted when the view is closed and then that persisted
            # configuration to be applied when the view is next shown:
            id = declaration.id,

            # Include the specified handler:
            handler = handler,

            # Build the view out of the sub-elements:
            *sub_elements,

            # Include the declaration's keywords.
            **declaration.keywords
        )


    def _compose_dynamic_sub_element ( self, definition ):
        """ Returns a dynamic UI element composed from its contributed parts.
        """
        logger.debug( 'Composing dynamic sub-element named [%s] for [%s]',
                      definition.name, self )

        # Retrieve the set of elements that make up this sub-element:
        elements = self._get_dynamic_elements( definition.name )

        # Build the sub-element:
        return self._build_dynamic_sub_element( definition, elements )

    def _compose_dynamic_view ( self, name ):
        """ Returns a dynamic view composed from its contributed parts.
        """
        logger.debug( 'Composing dynamic view [%s] for [%s]', name, self )

        # Retrieve the declaration of this dynamic view:
        declaration = self._dynamic_view_registry[ name ]

        # Retrieve the set of elements that make up the view:
        elements = self._get_dynamic_elements( declaration.name )

        # Build a handler that delegates to the contribution handlers if any
        # exist:
        handler  = None
        handlers = self._get_dynamic_handlers( declaration.name, elements )
        if len( handlers ) > 0:
            handler = DelegatingHandler( sub_handlers = handlers )

        # Build the view:
        return self._build_dynamic_view( declaration, elements, handler )

    def _get_dynamic_elements ( self, name ):
        """ Returns a list of the current elements meant to go into the
            composition of a dynamic view or subelement with the specified
            name.
        """

        # Determine the metadata names used to find the sub-elements included
        # within this dynamic element:
        name                = name.replace(' ', '_')
        order_trait_name    = '_%s_order' % name
        priority_trait_name = '_%s_priority' % name

        # Now find all of the current sub-elements that we will use when
        # composing our element:
        all_elements = [ self.trait_view( g )
                         for g in self.trait_views( klass = ViewSubElement ) ]
        elements = [ e for e in all_elements
                     if hasattr( e, order_trait_name ) and
                        (getattr( e, order_trait_name ) is not None) ]

        # Filter out any overridden elements.  This means taking out the
        # element with the lower priority whenever two elements have the
        # same order value:
        filtered = {}
        for e in elements:
            order    = getattr( e, order_trait_name )
            priority = getattr( e, priority_trait_name ) or 0
            current  = filtered.setdefault( order, e )
            if current is not e:
                current_priority = getattr( current, priority_trait_name )
                if current_priority < priority:
                    filtered[ order ] = e

        # Sort the contributed elements by their display ordering values:
        ordering = filtered.keys()
        ordering.sort()
        elements = [ filtered[ order ] for order in ordering ]

        # Replace any dynamic sub-element with their full composition.
        # NOTE: We can't do this in the override of 'trait_view' because
        # then we get into infinite loops when a dynamic view subelement is
        # found as a child:
        for i in range( len( elements ) ):
            if isinstance( elements[i], DynamicViewSubElement ):
                e = elements.pop( i )
                composed = self._compose_dynamic_sub_element( e )
                elements.insert( i, composed )

        return elements

    def _get_dynamic_handlers( self, name, elements ):
        """ Return a list of the handlers associated with the current elements
            meant to go into the dynamic view of the specified name.
        """

        # Determine the metadata name used to declare a handler:
        name         = name.replace(' ', '_')
        handler_name = '_%s_handler' % name

        handlers = [ getattr(e, handler_name) for e in elements
                     if hasattr( e, handler_name ) and
                        (getattr( e, handler_name ) is not None) ]
        logger.debug( '\tFound sub-handlers: %s', handlers )

        return handlers


########NEW FILE########
__FILENAME__ = has_traits
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author:        David C. Morrill
#  Original Date: 06/21/2002
#
#  Rewritten as a C-based type extension: 06/21/2004
#
#------------------------------------------------------------------------------

""" Defines the HasTraits class, along with several useful subclasses and
    associated metaclasses.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import, division

import copy as copy_module
import weakref
import re
import sys

from types import FunctionType, MethodType

from . import __version__ as TraitsVersion

from .adaptation.adaptation_error import AdaptationError

from .ctraits import CHasTraits, _HasTraits_monitors

from .traits import (CTrait, ForwardProperty, Property, SpecialNames, Trait,
    TraitFactory, __newobj__, generic_trait, trait_factory)

from .trait_types import Any, Bool, Disallow, Enum, Event, Python, This

from .trait_notifiers import (ExtendedTraitChangeNotifyWrapper,
    FastUITraitChangeNotifyWrapper, NewTraitChangeNotifyWrapper,
    StaticAnyTraitChangeNotifyWrapper, StaticTraitChangeNotifyWrapper,
    TraitChangeNotifyWrapper)

from .trait_handlers import TraitType

from .trait_base import (Missing, SequenceTypes, TraitsCache, Undefined,
    add_article, is_none, not_event, not_false)

from .trait_errors import TraitError

from .protocols.advice import addClassAdvisor

from .util.deprecated import deprecated

#-------------------------------------------------------------------------------
#  Set CHECK_INTERFACES to one of the following values:
#
#  - 0: Does not check to see if classes implement their declared interfaces.
#  - 1: Ensures that classes implement the interfaces they say they do, and
#       logs a warning if they don't.
#  - 2: Ensures that classes implement the interfaces they say they do, and
#       raises an InterfaceError if they don't.
#-------------------------------------------------------------------------------

CHECK_INTERFACES = 0

#-------------------------------------------------------------------------------
#  Deferred definitions:
#
#  The following classes have a 'chicken and the egg' definition problem. They
#  require Traits to work, because they subclass Traits, but the Traits
#  meta-class programming support uses them, so Traits can't be subclassed
#  until they are defined.
#
#  Note: We need to look at whether the Category support could be used to
#        allow us to implement this better.
#-------------------------------------------------------------------------------

class ViewElement ( object ):
    pass

def ViewElements ( ):
    return None

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

WrapperTypes   = ( StaticAnyTraitChangeNotifyWrapper,
                   StaticTraitChangeNotifyWrapper )

if sys.version_info[0] >= 3:
    # in python 3, unbound methods do not exist anymore, they're just functions
    BoundMethodTypes    = ( MethodType, )
    UnboundMethodTypes  = ( FunctionType, )
else:
    BoundMethodTypes    = ( MethodType, )
    UnboundMethodTypes  = ( MethodType, )

FunctionTypes  = ( FunctionType, )

# Class dictionary entries used to save trait, listener and view information and
# definitions:

BaseTraits      = '__base_traits__'
ClassTraits     = '__class_traits__'
PrefixTraits    = '__prefix_traits__'
ListenerTraits  = '__listener_traits__'
ViewTraits      = '__view_traits__'
InstanceTraits  = '__instance_traits__'

# The default Traits View name
DefaultTraitsView = 'traits_view'

# Trait types which cannot have default values
CantHaveDefaultValue = ( 'event', 'delegate', 'constant' )

# An empty list
EmptyList = []

# The trait types that should be copied last when doing a 'copy_traits':
DeferredCopy = ( 'delegate', 'property' )

# Quick test for normal vs extended trait name
extended_trait_pat = re.compile( r'.*[ :\+\-,\.\*\?\[\]]' )

# Generic 'Any' trait:
any_trait = Any().as_ctrait()

#-------------------------------------------------------------------------------
#  Creates a clone of a specified trait:
#-------------------------------------------------------------------------------

def _clone_trait ( clone, metadata = None ):
    """ Creates a clone of a specified trait.
    """
    trait = CTrait( 0 )
    trait.clone( clone )

    if clone.__dict__ is not None:
        trait.__dict__ = clone.__dict__.copy()

    if metadata is not None:
        trait.__dict__.update( metadata )

    return trait

#-------------------------------------------------------------------------------
#  Gets the definition of a specified method (if any):
#-------------------------------------------------------------------------------

def _get_method ( cls, method ):
    result = getattr( cls, method, None )
    if (result is not None) and is_unbound_method_type(result):
        return result
    return None


if sys.version_info[0] >= 3:
    def _get_def ( class_name, class_dict, bases, method ):
        """ Gets the definition of a specified method (if any).
        """
        if method[0:2] == '__':
            method = '_%s%s' % ( class_name, method )
    
        result = class_dict.get( method )
        if ((result is not None) and
            is_function_type(result) and
            (getattr( result, 'on_trait_change', None ) is None)):
            return result
    
        for base in bases:
            result = getattr( base, method, None )
            if ((result is not None) and
                is_unbound_method_type(result) and \
                (getattr( result, 'on_trait_change', None ) is None)):
                return result
    
        return None
else:
    def _get_def ( class_name, class_dict, bases, method ):
        """ Gets the definition of a specified method (if any).
        """
        if method[0:2] == '__':
            method = '_%s%s' % ( class_name, method )
    
        result = class_dict.get( method )
        if ((result is not None) and
            is_function_type(result) and
            (getattr( result, 'on_trait_change', None ) is None)):
            return result
    
        for base in bases:
            result = getattr( base, method, None )
            if ((result is not None) and
                is_unbound_method_type(result) and \
                (getattr( result.im_func, 'on_trait_change', None ) is None)):
                return result
    
        return None


def is_cython_func_or_method(method):
    """ Test if the given input is a Cython method or function. """
    # The only way to get the type from the method with str comparison ...
    return 'cython_function_or_method' in str(type(method))

def is_bound_method_type(method):
    """ Test if the given input is a Python method or a Cython method. """
    return isinstance(method, BoundMethodTypes ) or is_cython_func_or_method(method)

def is_unbound_method_type(method):
    """ Test if the given input is a Python method or a Cython method. """
    return isinstance(method, UnboundMethodTypes ) or is_cython_func_or_method(method)

def is_function_type(function):
    """ Test if the given input is a Python function or a Cython method. """
    return isinstance(function, FunctionTypes ) or \
           is_cython_func_or_method(function)

#-------------------------------------------------------------------------------
#  Returns whether or not a specified value is serializable:
#-------------------------------------------------------------------------------

def _is_serializable ( value ):
    """ Returns whether or not a specified value is serializable.
    """
    if isinstance( value, ( list, tuple ) ):
        for item in value:
            if not _is_serializable( item ):
                return False

        return True

    if isinstance( value, dict ):
        for name, item in value.items():
            if ((not _is_serializable( name )) or
                (not _is_serializable( item ))):
                return False

        return True

    return ((not isinstance( value, HasTraits )) or
            value.has_traits_interface( ISerializable ))

#-------------------------------------------------------------------------------
#  Returns a dictionary of potential 'Instance' or 'List(Instance)' handlers:
#-------------------------------------------------------------------------------

def _get_instance_handlers ( class_dict, bases ):
    """ Returns a dictionary of potential 'Instance' or 'List(Instance)'
        handlers.
    """
    # Create the results dictionary:
    instance_traits = {}

    # Merge all of the base class information into the result:
    for base in bases:
        for name, base_arg_lists in base.__dict__.get( InstanceTraits ).items():
            arg_lists = instance_traits.get( name )
            if arg_lists is None:
                instance_traits[ name ] = base_arg_lists[:]
            else:
                for arg_list in base_arg_lists:
                    if arg_list not in arg_lists:
                        arg_lists.append( arg_list )

    # Merge in the information from the class dictionary:
    for name, value in class_dict.items():
        if (name[:1] == '_') and is_function_type(value):
            n   = 13
            col = name.find( '_changed_for_' )
            if col < 2:
                 n   = 11
                 col = name.find( '_fired_for_' )
            if col >= 2:
                key = name[ col + n: ]
                if key != '':
                    arg_list  = ( name, name[ 1: col ] )
                    arg_lists = instance_traits.setdefault( key, [] )
                    if arg_list not in arg_lists:
                        arg_lists.append( arg_list )

    # Return the dictionary of possible arg_lists:
    return instance_traits

#-------------------------------------------------------------------------------
#  Returns the correct 'delegate' listener pattern for a specified name and
#  delegate trait:
#-------------------------------------------------------------------------------

def get_delegate_pattern ( name, trait ):
    """ Returns the correct 'delegate' listener pattern for a specified name and
        delegate trait.
    """
    prefix = trait._prefix
    if prefix == '':
        prefix = name
    elif (len( prefix ) > 1) and (prefix[-1] == '*'):
        prefix = prefix[:-1] + name

    return ' %s:%s' % ( trait._delegate, prefix )

#-------------------------------------------------------------------------------
#  '_SimpleTest' class:
#-------------------------------------------------------------------------------

class _SimpleTest:
    def __init__ ( self, value ): self.value = value
    def __call__ ( self, test  ): return test == self.value

#-------------------------------------------------------------------------------
#  Returns either the original value or a valid CTrait if the value can be
#  converted to a CTrait:
#-------------------------------------------------------------------------------

def _check_trait ( trait ):
    """ Returns either the original value or a valid CTrait if the value can be
        converted to a CTrait.
    """
    if isinstance( trait, CTrait ):
        return trait

    if isinstance( trait, TraitFactory ):
        return trait_factory( trait )

    if isinstance( trait, type ) and issubclass( trait, TraitType ):
        trait = trait()

    if isinstance( trait, TraitType ):
        return trait.as_ctrait()

    return trait

#-------------------------------------------------------------------------------
#  Returns the trait corresponding to a specified value:
#-------------------------------------------------------------------------------

def _trait_for ( trait ):
    """ Returns the trait corresponding to a specified value.
    """
    trait = _check_trait( trait )
    if isinstance( trait, CTrait ):
        return trait

    return Trait( trait )

#-------------------------------------------------------------------------------
#  Returns the 'mapped trait' definition for a mapped trait:
#-------------------------------------------------------------------------------

def _mapped_trait_for ( trait ):
    """ Returns the 'mapped trait' definition for a mapped trait.
    """
    default_value = trait.default_value()[1]
    try:
        default_value = trait.handler.mapped_value( default_value )
    except:
        pass

    return Any( default_value, is_base  = False, transient = True,
                               editable = False ).as_ctrait()

#-------------------------------------------------------------------------------
#  Adds a list of handlers to a specified notifiers list:
#-------------------------------------------------------------------------------

def _add_notifiers ( notifiers, handlers ):
    """ Adds a list of handlers to a specified notifiers list.
    """
    for handler in handlers:
        if not isinstance( handler, WrapperTypes ):
            handler = StaticTraitChangeNotifyWrapper( handler )
        notifiers.append( handler )

#-------------------------------------------------------------------------------
#  Adds any specified event handlers defined for a trait by a class:
#-------------------------------------------------------------------------------

def _add_event_handlers ( trait, cls, handlers ):
    """ Adds any specified event handlers defined for a trait by a class.
    """
    events = trait.event
    if events is not None:
        if isinstance(events, basestring):
            events = [ events ]

        for event in events:
            handlers.append( _get_method( cls, '_%s_changed' % event ) )
            handlers.append( _get_method( cls, '_%s_fired'   % event ) )

#-------------------------------------------------------------------------------
#  Returns the method associated with a particular class property getter/setter:
#-------------------------------------------------------------------------------

def _property_method ( class_dict, name ):
    """ Returns the method associated with a particular class property
    getter/setter.
    """
    return class_dict.get( name )

#-------------------------------------------------------------------------------
#  'MetaHasTraits' class:
#-------------------------------------------------------------------------------

# This really should be 'HasTraits', but it's not defined yet:
_HasTraits = None

class MetaHasTraits ( type ):
    ### JMS: Need a docstring here.
    # All registered class creation listeners.
    #
    # { Str class_name : Callable listener }
    _listeners = {}

    def __new__ ( cls, class_name, bases, class_dict ):
        mhto = MetaHasTraitsObject( cls, class_name, bases, class_dict, False )

        # Finish building the class using the updated class dictionary:
        klass = type.__new__( cls, class_name, bases, class_dict )

        # Fix up all self referential traits to refer to this class:
        for trait in mhto.self_referential:
            trait.set_validate( ( 11, klass ) )

        # Call all listeners that registered for this specific class:
        name = '%s.%s' % ( klass.__module__, klass.__name__ )
        for listener in MetaHasTraits._listeners.get( name, [] ):
            listener( klass )

        # Call all listeners that registered for ANY class:
        for listener in MetaHasTraits._listeners.get( '', [] ):
            listener( klass )

        return klass

    def add_listener ( cls, listener, class_name = '' ):
        """ Adds a class creation listener.

        If the class name is the empty string then the listener will be called
        when *any* class is created.
        """
        MetaHasTraits._listeners.setdefault( class_name, [] ).append( listener )

    add_listener = classmethod( add_listener )

    def remove_listener ( cls, listener, class_name = '' ):
        """ Removes a class creation listener.
        """
        MetaHasTraits._listeners[ class_name ].remove( listener )

    remove_listener = classmethod( remove_listener )

#-------------------------------------------------------------------------------
#  'MetaHasTraitsObject' class:
#-------------------------------------------------------------------------------

class MetaHasTraitsObject ( object ):
    """ Performs all of the meta-class processing needed to convert any
        subclass of HasTraits into a well-formed traits class.
    """

    def __init__ ( self, cls, class_name, bases, class_dict, is_category ):
        """ Processes all of the traits related data in the class dictionary.
        """
        # Create the various class dictionaries, lists and objects needed to
        # hold trait and view information and definitions:
        base_traits      = {}
        class_traits     = {}
        prefix_traits    = {}
        listeners        = {}
        prefix_list      = []
        override_bases   = bases
        view_elements    = ViewElements()
        self_referential = []

        # Create a list of just those base classes that derive from HasTraits:
        hastraits_bases = [ base for base in bases
                            if base.__dict__.get( ClassTraits ) is not None ]

        # Create a list of all inherited trait dictionaries:
        inherited_class_traits = [ base.__dict__.get( ClassTraits )
                                   for base in hastraits_bases ]

        # Move all trait definitions from the class dictionary to the
        # appropriate trait class dictionaries:
        for name, value in class_dict.items():
            value = _check_trait( value )
            rc    = isinstance( value, CTrait )

            if (not rc) and isinstance( value, ForwardProperty ):
                rc     = True
                getter = _property_method( class_dict, '_get_' + name )
                setter = _property_method( class_dict, '_set_' + name )
                if (setter is None) and (getter is not None):
                    if getattr( getter, 'settable', False ):
                        setter = HasTraits._set_traits_cache
                    elif getattr( getter, 'flushable', False ):
                        setter = HasTraits._flush_traits_cache
                validate = _property_method( class_dict, '_validate_' + name )
                if validate is None:
                    validate = value.validate

                value = Property( getter, setter, validate, True,
                                  value.handler, **value.metadata )
            if rc:
                del class_dict[ name ]
                if name[-1:] != '_':
                    base_traits[ name ] = class_traits[ name ] = value
                    value_type = value.type
                    if value_type == 'trait':
                       handler = value.handler
                       if handler is not None:
                           if handler.has_items:
                               items_trait = _clone_trait(
                                   handler.items_event(), value.__dict__ )

                               if items_trait.instance_handler == \
                                   '_list_changed_handler':
                                   items_trait.instance_handler = \
                                       '_list_items_changed_handler'

                               class_traits[ name + '_items' ] = items_trait

                           if handler.is_mapped:
                               class_traits[ name + '_' ] = _mapped_trait_for(
                                                                         value )

                           if isinstance( handler, This ):
                               handler.info_text = \
                                   add_article( class_name ) + ' instance'
                               self_referential.append( value )

                    elif value_type == 'delegate':
                        # Only add a listener if the trait.listenable metadata
                        # is not False:
                        if value._listenable is not False:
                            listeners[ name ] = ( 'delegate',
                                           get_delegate_pattern( name, value ) )
                    elif value_type == 'event':
                        on_trait_change = value.on_trait_change
                        if isinstance( on_trait_change, basestring ):
                            listeners[ name ] = ( 'event', on_trait_change )
                else:
                    name = name[:-1]
                    prefix_list.append( name )
                    prefix_traits[ name ] = value

            elif isinstance( value, FunctionType ) or is_cython_func_or_method(value):
                pattern = getattr( value, 'on_trait_change', None )
                if pattern is not None:
                    listeners[ name ] = ( 'method', pattern )

            elif isinstance( value, property ):
                class_traits[ name ] = generic_trait

            # Handle any view elements found in the class:
            elif isinstance( value, ViewElement ):

                # Add the view element to the class's 'ViewElements' if it is
                # not already defined (duplicate definitions are errors):
                if name in view_elements.content:
                    raise TraitError(
                        "Duplicate definition for view element '%s'" % name )

                view_elements.content[ name ] = value

                # Replace all substitutable view sub elements with 'Include'
                # objects, and add the substituted items to the
                # 'ViewElements':
                value.replace_include( view_elements )

                # Remove the view element from the class definition:
                del class_dict[ name ]

            else:
                for ct in inherited_class_traits:
                    if name in ct:
                        # The subclass is providing a default value for the
                        # trait defined in a superclass.
                        ictrait = ct[ name ]
                        if ictrait.type in CantHaveDefaultValue:
                            raise TraitError( "Cannot specify a default value "
                                "for the %s trait '%s'. You must override the "
                                "the trait definition instead." %
                                ( ictrait.type, name ) )

                        default_value = value
                        class_traits[ name ] = value = ictrait( default_value )
                        # Make sure that the trait now has the default value
                        # has the correct initializer.
                        value.default_value(1, value.default)
                        del class_dict[ name ]
                        override_bases = []
                        handler        = value.handler
                        if (handler is not None) and handler.is_mapped:
                            class_traits[ name + '_' ] = _mapped_trait_for(
                                                                         value )
                        break

        # Process all HasTraits base classes:
        migrated_properties = {}
        implements          = []
        for base in hastraits_bases:
            base_dict = base.__dict__

            # Merge listener information:
            for name, value in base_dict.get( ListenerTraits ).items():
                if (name not in class_traits) and (name not in class_dict):
                    listeners[ name ] = value

            # Merge base traits:
            for name, value in base_dict.get( BaseTraits ).items():
                if name not in base_traits:
                    property_info = value.property()
                    if property_info is not None:
                        key = id( value )
                        migrated_properties[ key ] = value = \
                            self.migrate_property( name, value, property_info,
                                                   class_dict )
                    base_traits[ name ] = value

                elif is_category:
                    raise TraitError, ("Cannot override '%s' trait "
                                       "definition in a category" % name)

            # Merge class traits:
            for name, value in base_dict.get( ClassTraits ).items():
                if name not in class_traits:
                    property_info = value.property()
                    if property_info is not None:
                        new_value = migrated_properties.get( id( value ) )
                        if new_value is not None:
                            value = new_value
                        else:
                            value = self.migrate_property( name, value,
                                                     property_info, class_dict )
                    class_traits[ name ] = value

                elif is_category:
                    raise TraitError, ("Cannot override '%s' trait "
                                       "definition in a category" % name)

            # Merge prefix traits:
            base_prefix_traits = base_dict.get( PrefixTraits )
            for name in base_prefix_traits['*']:
                if name not in prefix_list:
                    prefix_list.append( name )
                    prefix_traits[ name ] = base_prefix_traits[ name ]
                elif is_category:
                    raise TraitError, ("Cannot override '%s_' trait "
                                       "definition in a category" % name)

            # If the base class has a 'ViewElements' object defined, add it to
            # the 'parents' list of this class's 'ViewElements':
            parent_view_elements = base_dict.get( ViewTraits )
            if parent_view_elements is not None:
                view_elements.parents.append( parent_view_elements )

        # Make sure there is a definition for 'undefined' traits:
        if (prefix_traits.get( '' ) is None) and (not is_category):
            prefix_list.append( '' )
            prefix_traits[''] = Python().as_ctrait()

        # Save a link to the prefix_list:
        prefix_traits['*'] = prefix_list

        # Make sure the trait prefixes are sorted longest to shortest
        # so that we can easily bind dynamic traits to the longest matching
        # prefix:
        prefix_list.sort( key = lambda x: -len(x) )

        # Get the list of all possible 'Instance'/'List(Instance)' handlers:
        instance_traits = _get_instance_handlers( class_dict, hastraits_bases )

        # If there is an 'anytrait_changed' event handler, wrap it so that
        # it can be attached to all traits in the class:
        anytrait = _get_def( class_name, class_dict, bases,
                             '_anytrait_changed' )
        if anytrait is not None:
            anytrait = StaticAnyTraitChangeNotifyWrapper( anytrait )

            # Save it in the prefix traits dictionary so that any dynamically
            # created traits (e.g. 'prefix traits') can re-use it:
            prefix_traits['@'] = anytrait

        # Make one final pass over the class traits dictionary, making sure
        # all static trait notification handlers are attached to a 'cloned'
        # copy of the original trait:
        cloned = set()
        for name in class_traits.keys():
            trait    = class_traits[ name ]
            handlers = [ anytrait,
                         _get_def( class_name, class_dict, bases,
                                   '_%s_changed' % name ),
                         _get_def( class_name, class_dict, bases,
                                   '_%s_fired' % name ) ]

            # Check for an 'Instance' or 'List(Instance)' trait with defined
            # handlers:
            instance_handler = trait.instance_handler
            if ((instance_handler is not None) and
                (name in instance_traits) or
                ((instance_handler == '_list_items_changed_handler') and
                 (name[-6:] == '_items') and
                 (name[:-6] in instance_traits))):
                handlers.append( getattr( HasTraits, instance_handler ) )

            events = trait.event
            if events is not None:

                if isinstance(events, basestring):
                    events = [ events ]

                for event in events:
                    handlers.append( _get_def( class_name, class_dict, bases,
                                               '_%s_changed' % event ) )
                    handlers.append( _get_def( class_name, class_dict, bases,
                                               '_%s_fired' % event ) )

            handlers = [ h for h in handlers if h is not None ]
            default  = _get_def( class_name, class_dict, [],
                                 '_%s_default' % name )
            if (len( handlers ) > 0) or (default is not None):

                if name not in cloned:
                    cloned.add( name )
                    class_traits[ name ] = trait = _clone_trait( trait )

                if len( handlers ) > 0:
                    _add_notifiers( trait._notifiers( 1 ), handlers )

                if default is not None:
                    trait.default_value( 8, default )

            # Handle the case of properties whose value depends upon the value
            # of other traits:
            if (trait.type == 'property') and (trait.depends_on is not None):

                cached = trait.cached
                if cached is True:
                    cached = TraitsCache + name

                depends_on = trait.depends_on
                if isinstance( depends_on, SequenceTypes ):
                    depends_on = ','.join( depends_on )
                else:
                    # Note: We add the leading blank to force it to be treated
                    # as using the extended trait notation so that it will
                    # automatically add '_items' listeners to lists/dicts:
                    depends_on = ' ' + depends_on

                listeners[ name ] = ( 'property', cached, depends_on )

        # Save the list of self referential traits:
        self.self_referential = self_referential

        # Add the traits meta-data to the class:
        self.add_traits_meta_data(
            bases, class_dict, base_traits, class_traits, instance_traits,
            prefix_traits, listeners, view_elements )

    #---------------------------------------------------------------------------
    #  Adds the traits meta-data to the class:
    #---------------------------------------------------------------------------

    def add_traits_meta_data ( self, bases, class_dict, base_traits,
                               class_traits,  instance_traits, prefix_traits,
                               listeners, view_elements ):
        """ Adds the Traits metadata to the class dictionary.
        """
        class_dict[ BaseTraits      ] = base_traits
        class_dict[ ClassTraits     ] = class_traits
        class_dict[ InstanceTraits  ] = instance_traits
        class_dict[ PrefixTraits    ] = prefix_traits
        class_dict[ ListenerTraits  ] = listeners
        class_dict[ ViewTraits      ] = view_elements

    #---------------------------------------------------------------------------
    #  Migrates an existing property to the class being defined (allowing for
    #  method overrides):
    #---------------------------------------------------------------------------

    def migrate_property ( self, name, property, property_info, class_dict ):
        """ Migrates an existing property to the class being defined
        (allowing for method overrides).
        """
        get = _property_method( class_dict, '_get_' + name )
        set = _property_method( class_dict, '_set_' + name )
        val = _property_method( class_dict,
                                '_validate_' + name )
        if ((get is not None) or (set is not None) or (val is not None)):
            old_get, old_set, old_val = property_info
            return Property( get or old_get, set or old_set, val or old_val,
                             True, **property.__dict__ )

        return property

#-------------------------------------------------------------------------------
#  Manages the list of trait instance monitors:
#-------------------------------------------------------------------------------

def _trait_monitor_index ( cls, handler ):
    global _HasTraits_monitors

    type_handler = type( handler )
    for i, _cls, _handler in enumerate( _HasTraits_monitors ):
        if type_handler is type( _handler ):
            if (((type_handler is MethodType)  or
                'cython_function_or_method' in str(type_handler)) and \
                (handler.im_self is not None)):
                if ((handler.__name__ == _handler.__name__) and
                    (handler.im_self is _handler.im_self)):
                   return i

            elif handler == _handler:
                return i

    return -1

#-------------------------------------------------------------------------------
#  'HasTraits' decorators:
#-------------------------------------------------------------------------------

def on_trait_change ( name, post_init = False, *names ):
    """ Marks the following method definition as being a handler for the
        extended trait change specified by *name(s)*.

        Refer to the documentation for the on_trait_change() method of
        the **HasTraits** class for information on the correct syntax for
        the *name(s)* argument.

        A handler defined using this decorator is normally effective
        immediately. However, if *post_init* is **True**, then the handler only
        become effective after all object constructor arguments have been
        processed. That is, trait values assigned as part of object construction
        will not cause the handler to be invoked.
    """
    def decorator ( function ):
        prefix = '<'
        if post_init:
            prefix = '>'

        function.on_trait_change = prefix + \
                                   (','.join( [ name ] + list( names ) ))

        return function

    return decorator

def cached_property ( function ):
    """ Marks the following method definition as being a "cached property".
        That is, it is a property getter which, for performance reasons, caches
        its most recently computed result in an attribute whose name is of the
        form: *_traits_cache_name*, where *name* is the name of the property. A
        method marked as being a cached property needs only to compute and
        return its result. The @cached_property decorator automatically wraps
        the decorated method in cache management code, eliminating the need to
        write boilerplate cache management code explicitly. For example::

            file_name = File
            file_contents = Property( depends_on = 'file_name' )

            @cached_property
            def _get_file_contents(self):
                fh = open(self.file_name, 'rb')
                result = fh.read()
                fh.close()
                return result

        In this example, accessing the *file_contents* trait calls the
        _get_file_contents() method only once each time after the **file_name**
        trait is modified. In all other cases, the cached value
        **_file_contents**, which maintained by the @cached_property wrapper
        code, is returned.

        Note the use, in the example, of the **depends_on** metadata attribute
        to specify that the value of **file_contents** depends on **file_name**,
        so that _get_file_contents() is called only when **file_name** changes.
        For details, see the traits.traits.Property() function.
    """
    name = TraitsCache + function.__name__[ 5: ]

    def decorator ( self ):
        result = self.__dict__.get( name, Undefined )
        if result is Undefined:
            self.__dict__[ name ] = result = function( self )

        return result

    decorator.cached_property = True

    return decorator

def property_depends_on ( dependency, settable = False, flushable = False ):
    """ Marks the following method definition as being a "cached property"
        that depends on the specified extended trait names. That is, it is a
        property getter which, for performance reasons, caches its most recently
        computed result in an attribute whose name is of the form:
        *_traits_cache_name*, where *name* is the name of the property. A method
        marked as being a cached property needs only to compute and return its
        result. The @property_depends_on decorator automatically wraps the
        decorated method in cache management code that will cache the most
        recently computed value and flush the cache when any of the specified
        dependencies are modified, thus eliminating the need to write
        boilerplate cache management code explicitly. For example::

            file_name = File
            file_contents = Property

            @property_depends_on( 'file_name' )
            def _get_file_contents(self):
                fh = open(self.file_name, 'rb')
                result = fh.read()
                fh.close()
                return result

        In this example, accessing the *file_contents* trait calls the
        _get_file_contents() method only once each time after the **file_name**
        trait is modified. In all other cases, the cached value
        **_file_contents**, which is maintained by the @cached_property wrapper
        code, is returned.
    """
    def decorator ( function ):
        name = TraitsCache + function.__name__[ 5: ]

        def wrapper ( self ):
            result = self.__dict__.get( name, Undefined )
            if result is Undefined:
                self.__dict__[ name ] = result = function( self )

            return result

        wrapper.cached_property = True
        wrapper.depends_on      = dependency
        wrapper.settable        = settable
        wrapper.flushable       = flushable

        return wrapper

    return decorator

def weak_arg(arg):
    """ Create a weak reference to arg and wrap the function so that the
    dereferenced weakref is passed as the first argument. If arg has been
    deleted then the function is not called.
    """
    # Create the weak reference
    weak_arg = weakref.ref(arg)
    def decorator(function):
        # We need multiple wrappers to traits can find the number of arguments.
        # The all just dereference the weak reference and the call the
        # function if it is not None.
        def wrapper0():
            arg = weak_arg()
            if arg is not None:
                return function(arg)
        def wrapper1(arg1):
            arg = weak_arg()
            if arg is not None:
                return function(arg, arg1)
        def wrapper2(arg1, arg2):
            arg = weak_arg()
            if arg is not None:
                return function(arg, arg1, arg2)
        def wrapper3(arg1, arg2, arg3):
            arg = weak_arg()
            if arg is not None:
                return function(arg, arg1, arg2, arg3)
        def wrapper4(arg1, arg2, arg3, arg4):
            arg = weak_arg()
            if arg is not None:
                return function(arg, arg1, arg2, arg3, arg4)
        def wrappern(*args):
            arg = weak_arg()
            if arg is not None:
                function(arg, *args)
        # Return the correct wrapper depending on the arg count
        args = function.func_code.co_argcount-1
        if args == 0:
            return wrapper0
        elif args == 1:
            return wrapper1
        elif args == 2:
            return wrapper2
        elif args == 3:
            return wrapper3
        elif args == 4:
            return wrapper4
        else:
            return wrappern

    return decorator

#-------------------------------------------------------------------------------
#  'HasTraits' class:
#-------------------------------------------------------------------------------

class HasTraits ( CHasTraits ):
    """ Enables any Python class derived from it to have trait attributes.

    Most of the methods of HasTraits operated by default only on the trait
    attributes explicitly defined in the class definition. They do not operate
    on trait attributes defined by way of wildcards or by calling
    **add_trait()**.
    For example::

        >>>class Person(HasTraits):
        ...    name = Str
        ...    age  = Int
        ...    temp_ = Any
        >>>bob = Person()
        >>>bob.temp_lunch = 'sandwich'
        >>>bob.add_trait('favorite_sport', Str('football'))
        >>>print bob.trait_names()
        ['trait_added', 'age', 'name']

    In this example, the trait_names() method returns only the *age* and
    *name* attributes defined on the Person class. (The **trait_added**
    attribute is an explicit trait event defined on the HasTraits class.)
    The wildcard attribute *temp_lunch* and the dynamically-added trait
    attribute *favorite_sport* are not listed.
    """
    __metaclass__ = MetaHasTraits

    #-- Trait Prefix Rules -----------------------------------------------------

    #: Make traits 'property cache' values private with no type checking:
    _traits_cache__ = Any( private = True, transient = True )

    #-- Class Variables --------------------------------------------------------

    #: Mapping from dispatch type to notification wrapper class type
    wrappers = {
        'same':     TraitChangeNotifyWrapper,
        'extended': ExtendedTraitChangeNotifyWrapper,
        'new':      NewTraitChangeNotifyWrapper,
        'fast_ui':  FastUITraitChangeNotifyWrapper,
        'ui':       FastUITraitChangeNotifyWrapper
    }

    #-- Trait Definitions ------------------------------------------------------

    #: An event fired when a new trait is dynamically added to the object
    trait_added = Event( basestring )

    #: An event that can be fired to indicate that the state of the object has
    #: been modified
    trait_modified = Event

    #---------------------------------------------------------------------------
    #  Handles a 'trait_added' event being fired:
    #---------------------------------------------------------------------------

    def _trait_added_changed ( self, name ):
        """ Handles a 'trait_added' event being fired.
        """
        # fixme: This test should be made more comprehensive by also verifying
        # that if the trait name does end in '_items', its base trait is also
        # a list or dictionary (in order to eliminate a false positive on an
        # unfortunately named trait:
        trait = self.trait( name )
        if (trait.type == 'delegate') and (name[-6:] != '_items'):
            self._init_trait_delegate_listener( name, 'delegate',
                                           get_delegate_pattern( name, trait ) )

    #---------------------------------------------------------------------------
    #  Adds/Removes a trait instance creation monitor:
    #---------------------------------------------------------------------------

    def trait_monitor ( cls, handler, remove = False ):
        """Adds or removes the specified *handler* from the list of active
        monitors.

        Parameters
        ----------
        handler : function
            The function to add or remove as a monitor.
        remove : bool
            Flag indicating whether to remove (True) or add the specified
            handler as a monitor for this class.

        Description
        -----------
        If *remove* is omitted or False, the specified handler is added to
        the list of active monitors; if *remove* is True, the handler is
        removed from the active monitor list.

        """
        global _HasTraits_monitors

        index = _trait_monitor_index( cls, handler )
        if remove:
            if index >= 0:
                del _HasTraits_monitors[ index ]
            return

        if index < 0:
            _HasTraits_monitors.append( ( cls, handler ) )

    trait_monitor = classmethod( trait_monitor )

    #---------------------------------------------------------------------------
    #  Add a new class trait (i.e. applies to all instances and subclasses):
    #---------------------------------------------------------------------------

    def add_class_trait ( cls, name, *trait ):
        """ Adds a named trait attribute to this class.

        Parameters
        ----------
        name : str
            Name of the attribute to add.
        *trait :
            A trait or a value that can be converted to a trait using Trait()
            Trait definition of the attribute. It can be a single value or
            a list equivalent to an argument list for the Trait() function.

        """

        # Make sure a trait argument was specified:
        if len( trait ) == 0:
            raise ValueError, 'No trait definition was specified.'

        # Make sure only valid traits get added:
        if len( trait ) > 1:
            trait = Trait( *trait )
        else:
            trait = _trait_for( trait[0] )

        # Add the trait to the class:
        cls._add_class_trait( name, trait, False )

        # Also add the trait to all subclasses of this class:
        for subclass in cls.trait_subclasses( True ):
            subclass._add_class_trait( name, trait, True )

    add_class_trait = classmethod( add_class_trait )

    def _add_class_trait ( cls, name, trait, is_subclass ):
        # Get a reference to the class's dictionary and 'prefix' traits:
        class_dict    = cls.__dict__
        prefix_traits = class_dict[ PrefixTraits ]

        # See if the trait is a 'prefix' trait:
        if name[-1:] == '_':
            name = name[:-1]
            if name in prefix_traits:
                if is_subclass:
                    return
                raise TraitError( "The '%s_' trait is already defined." % name )
            prefix_traits[ name ] = trait

            # Otherwise, add it to the list of known prefixes:
            prefix_list = prefix_traits['*']
            prefix_list.append( name )

            # Resort the list from longest to shortest:
            prefix_list.sort( lambda x, y: len( y ) - len( x ) )

            return

        # Check to see if the trait is already defined:
        class_traits = class_dict[ ClassTraits ]
        if class_traits.get( name ) is not None:
            if is_subclass:
                return
            raise TraitError( "The '%s' trait is already defined." % name )

        # Check to see if the trait has additional sub-traits that need to be
        # defined also:
        handler = trait.handler
        if handler is not None:
            if handler.has_items:
                cls.add_class_trait( name + '_items', handler.items_event() )
            if handler.is_mapped:
                cls.add_class_trait( name + '_', _mapped_trait_for( trait ) )

        # Make the new trait inheritable (if allowed):
        if trait.is_base is not False:
            class_dict[ BaseTraits ][ name ] = trait

        # See if there are any static notifiers defined:
        handlers = [ _get_method( cls, '_%s_changed' % name ),
                     _get_method( cls, '_%s_fired'   % name ) ]

        # Add any special trait defined event handlers:
        _add_event_handlers( trait, cls, handlers )

        # Add the 'anytrait' handler (if any):
        handlers.append( prefix_traits.get( '@' ) )

        # Filter out any 'None' values:
        handlers = [ h for h in handlers if h is not None ]

        # If there are and handlers, add them to the trait's notifier's list:
        if len( handlers ) > 0:
            trait = _clone_trait( trait )
            _add_notifiers( trait._notifiers( 1 ), handlers )

        # Finally, add the new trait to the class trait dictionary:
        class_traits[ name ] = trait

    _add_class_trait = classmethod( _add_class_trait )

    #---------------------------------------------------------------------------
    #  Adds a 'category' to the class:
    #---------------------------------------------------------------------------

    def add_trait_category ( cls, category ):
        """ Adds a trait category to a class.
        """
        if issubclass( category, HasTraits ):
            cls._add_trait_category(
                getattr( category, BaseTraits ),
                getattr( category, ClassTraits ),
                getattr( category, InstanceTraits ),
                getattr( category, PrefixTraits ),
                getattr( category, ListenerTraits ),
                getattr( category, ViewTraits, None ) )

        # Copy all methods that are not already in the class from the category:
        for subcls in category.__mro__:
            for name, value in subcls.__dict__.items():
                if not hasattr( cls, name ):
                    setattr( cls, name, value )

    add_trait_category = classmethod( add_trait_category )

    #---------------------------------------------------------------------------
    #  Adds a 'category' to the class:
    #---------------------------------------------------------------------------

    def _add_trait_category ( cls, base_traits, class_traits, instance_traits,
                              prefix_traits, listeners, view_elements ):
        # Update the class and each of the existing subclasses:
        for subclass in [ cls ] + cls.trait_subclasses( True ):

            # Merge the 'base_traits':
            subclass_traits = getattr( subclass, BaseTraits )
            for name, value in base_traits.items():
                subclass_traits.setdefault( name, value )

            # Merge the 'class_traits':
            subclass_traits = getattr( subclass, ClassTraits )
            for name, value in class_traits.items():
                subclass_traits.setdefault( name, value )

            # Merge the 'instance_traits':
            subclass_traits = getattr( subclass, InstanceTraits )
            for name, arg_lists in instance_traits.items():
                subclass_arg_lists = subclass_traits.get( name )
                if subclass_arg_lists is None:
                    subclass_traits[ name ] = arg_lists[:]
                else:
                    for arg_list in arg_lists:
                        if arg_list not in subclass_arg_lists:
                            subclass_arg_lists.append( arg_list )

            # Merge the 'prefix_traits':
            subclass_traits = getattr( subclass, PrefixTraits )
            subclass_list   = subclass_traits['*']
            changed         = False
            for name, value in prefix_traits.items():
                if name not in subclass_traits:
                    subclass_traits[ name ] = value
                    subclass_list.append( name )
                    changed = True

            # Resort the list from longest to shortest (if necessary):
            if changed:
                subclass_list.sort( key = lambda x: -len( x ) )

            # Merge the 'listeners':
            subclass_traits = getattr( subclass, ListenerTraits )
            for name, value in listeners.items():
                subclass_traits.setdefault( name, value )

        # Copy all our new view elements into the base class's ViewElements:
        if view_elements is not None:
            content = view_elements.content
            if len( content ) > 0:
                base_ve = getattr( cls, ViewTraits, None )
                if base_ve is None:
                    base_ve = ViewElements()
                    setattr( cls, ViewTraits, base_ve )
                base_ve_content = base_ve.content
                for name, value in content.items():
                    base_ve_content.setdefault( name, value )

    _add_trait_category = classmethod( _add_trait_category )

    #---------------------------------------------------------------------------
    #  Sets a trait notification dispatch handler:
    #---------------------------------------------------------------------------

    def set_trait_dispatch_handler ( cls, name, klass, override = False ):
        """ Sets a trait notification dispatch handler.
        """
        try:
            if issubclass( klass, TraitChangeNotifyWrapper ):
                if (not override) and (name in cls.wrappers):
                    raise TraitError, ("A dispatch handler called '%s' has "
                                       "already been defined." % name)
                cls.wrappers[ name ] = klass
                return
        except TypeError:
            pass
        raise TraitError, ('%s is not a subclass of TraitChangeNotifyWrapper.' %
                           klass)

    set_trait_dispatch_handler = classmethod( set_trait_dispatch_handler )

    #---------------------------------------------------------------------------
    #  Returns the immediate (or all) subclasses of this class:
    #---------------------------------------------------------------------------

    def trait_subclasses ( cls, all = False ):
        """ Returns a list of the immediate (or all) subclasses of this class.

        Parameters
        ----------
        all : bool
            Indicates whether to return all subclasses of this class. If
            False, only immediate subclasses are returned.

        """
        if not all:
            return cls.__subclasses__()
        return cls._trait_subclasses( [] )

    trait_subclasses = classmethod( trait_subclasses )

    def _trait_subclasses ( cls, subclasses ):
        for subclass in cls.__subclasses__():
            if subclass not in subclasses:
                subclasses.append( subclass )
                subclass._trait_subclasses( subclasses )
        return subclasses

    _trait_subclasses = classmethod( _trait_subclasses )

    #---------------------------------------------------------------------------
    #  Returns whether the object implements a specified traits interface:
    #---------------------------------------------------------------------------

    def has_traits_interface ( self, *interfaces ):
        """Returns whether the object implements a specified traits interface.

           Parameters
           ----------
           *interfaces :
                One or more traits Interface (sub)classes.

           Description
           -----------
           Tests whether the object implements one or more of the interfaces
           specified by *interfaces*. Return **True** if it does, and **False**
           otherwise.
        """
        return isinstance(self, interfaces)

    #---------------------------------------------------------------------------
    #  Prepares an object to be pickled:
    #---------------------------------------------------------------------------

    def __getstate__ ( self ):
        """ Returns a dictionary of traits to pickle.

        In general, avoid overriding __getstate__ in subclasses. Instead, mark
        traits that should not be pickled with 'transient = True' metadata.

        In cases where this strategy is not sufficient, override __getstate__
        in subclasses using the following pattern to remove items that should
        not be persisted::

            def __getstate__(self):
                state = super(X,self).__getstate__()
                for key in ['foo', 'bar']:
                    if key in state:
                        del state[key]
                return state
        """
        # Save all traits which do not have any 'transient' metadata:
        result = self.trait_get( transient = is_none )

        # Add all delegate traits that explicitly have 'transient = False'
        # metadata:
        dic    = self.__dict__
        result.update( dict( [ ( name, dic[ name ] )
                             for name in self.trait_names( type = 'delegate',
                                                           transient = False )
                             if name in dic ] ) )

        # If this object implements ISerializable, make sure that all
        # contained HasTraits objects in its persisted state also implement
        # ISerializable:
        if self.has_traits_interface( ISerializable ):
            for name, value in result.items():
                if not _is_serializable( value ):
                    raise TraitError( "The '%s' trait of a '%s' instance "
                                      "contains the unserializable value: %s" %
                                      ( name, self.__class__.__name__, value ) )

        # Store the traits version in the state dictionary (if possible):
        result.setdefault( '__traits_version__', TraitsVersion )

        # Return the final state dictionary:
        return result

    def __reduce_ex__ ( self, protocol ):
        return ( __newobj__, ( self.__class__, ), self.__getstate__() )

    #---------------------------------------------------------------------------
    #  Restores the previously pickled state of an object:
    #---------------------------------------------------------------------------

    def __setstate__ ( self, state, trait_change_notify = True ):
        """ Restores the previously pickled state of an object.
        """
        pop = state.pop
        if pop( '__traits_version__', None ) is None:
            # If the state was saved by a version of Traits prior to 3.0, then
            # use Traits 2.0 compatible code to restore it:
            values = [ ( name, pop( name ) )
                       for name in pop( '__HasTraits_restore__', [] ) ]
            self.__dict__.update( state )
            self.trait_set( trait_change_notify=trait_change_notify,
                            **dict( values ) )
        else:
            # Otherwise, apply the Traits 3.0 restore logic:
            self._init_trait_listeners()
            self.trait_set( trait_change_notify = trait_change_notify, **state )
            self._post_init_trait_listeners()
            self.traits_init()

        self.traits_inited( True )

    #---------------------------------------------------------------------------
    #  Shortcut for retrieving the value of a list of traits:
    #---------------------------------------------------------------------------

    def trait_get ( self, *names, **metadata ):
        """ Shortcut for getting object trait attributes.

        Parameters
        ----------
        names : list of strings
            A list of trait attribute names whose values are requested.

        Returns
        -------
        result : dict
            A dictionary whose keys are the names passed as arguments and whose
            values are the corresponding trait values.

        Description
        -----------
        Looks up the value of each trait whose name is passed as an argument
        and returns a dictionary containing the resulting name/value pairs.
        If any name does not correspond to a defined trait, it is not included
        in the result.

        If no names are specified, the result is a dictionary containing
        name/value pairs for *all* traits defined on the object.
        """

        result = {}
        n      = len( names )
        if (n == 1) and (type( names[0] ) in SequenceTypes):
            names = names[0]
        elif n == 0:
            names = self.trait_names( **metadata )

        for name in names:
            value = getattr( self, name, Missing )
            if value is not Missing:
                result[ name ] = value

        return result

    # Defines the deprecated alias for 'trait_get'
    get = trait_get

    #---------------------------------------------------------------------------
    #  Shortcut for setting object traits:
    #---------------------------------------------------------------------------

    def trait_set ( self, trait_change_notify = True, **traits ):
        """ Shortcut for setting object trait attributes.

        Parameters
        ----------
        trait_change_notify : bool
            If **True** (the default), then each value assigned may generate a
            trait change notification. If **False**, then no trait change
            notifications will be generated. (see also: trait_setq)
        **traits :
            Key/value pairs, the trait attributes and their values to be
            set

        Returns
        -------
        self :
            The method returns this object, after setting attributes.

        Description
        -----------
        Treats each keyword argument to the method as the name of a trait
        attribute and sets the corresponding trait attribute to the value
        specified. This is a useful shorthand when a number of trait attributes
        need to be set on an object, or a trait attribute value needs to be set
        in a lambda function. For example, you can write::

            person.trait_set(name='Bill', age=27)

        instead of::

            person.name = 'Bill'
            person.age = 27

        """
        if not trait_change_notify:
            self._trait_change_notify( False )
            try:
                for name, value in traits.items():
                    setattr( self, name, value )
            finally:
                self._trait_change_notify( True )
        else:
            for name, value in traits.items():
                setattr( self, name, value )

        return self

    # Defines the deprecated alias for 'trait_set'
    set = trait_set

    def trait_setq ( self, **traits ):
        """ Shortcut for setting object trait attributes.

        Parameters
        ----------
        **traits :
            Key/value pairs, the trait attributes and their values to be set.
            No trait change notifications will be generated for any values
            assigned (see also: trait_set).

        Returns
        -------
        self :
            The method returns this object, after setting attributes.

        Description
        -----------
        Treats each keyword argument to the method as the name of a trait
        attribute and sets the corresponding trait attribute to the value
        specified. This is a useful shorthand when a number of trait attributes
        need to be set on an object, or a trait attribute value needs to be set
        in a lambda function. For example, you can write::

            person.trait_setq(name='Bill', age=27)

        instead of::

            person.name = 'Bill'
            person.age = 27

        """
        return self.trait_set( trait_change_notify = False, **traits )

    #---------------------------------------------------------------------------
    #  Resets some or all of an object's traits to their default values:
    #---------------------------------------------------------------------------

    def reset_traits ( self, traits = None, **metadata ):
        """ Resets some or all of an object's trait attributes to their default
        values.

        Parameters
        ----------
        traits : list of strings
            Names of trait attributes to reset.

        Returns
        -------
        unresetable : list of strings
            A list of attributes that the method was unable to reset, which is
            empty if all the attributes were successfully reset.

        Description
        -----------
        Resets each of the traits whose names are specified in the *traits*
        list to their default values. If *traits* is None or omitted, the
        method resets all explicitly-defined object trait attributes to their
        default values. Note that this does not affect wildcard trait
        attributes or trait attributes added via add_trait(), unless they are
        explicitly named in *traits*.

        """
        unresetable = []

        if traits is None:
            traits = self.trait_names( **metadata )

        for name in traits:
            try:
                delattr( self, name )
            except ( AttributeError, TraitError ):
                unresetable.append( name )

        return unresetable

    #---------------------------------------------------------------------------
    #  Returns the list of trait names to copy/clone by default:
    #---------------------------------------------------------------------------

    def copyable_trait_names ( self, **metadata ):
        """ Returns the list of trait names to copy or clone by default.
        """

        metadata.setdefault('transient', lambda t: t is not True)
        return self.trait_names( **metadata )

    #---------------------------------------------------------------------------
    #  Returns the list of all trait names, including implicitly defined
    #  traits:
    #---------------------------------------------------------------------------

    def all_trait_names ( self ):
        """ Returns the list of all trait names, including implicitly defined
            traits.
        """
        return self.__class_traits__.keys()

    #---------------------------------------------------------------------------
    #  Copies another object's traits into this one:
    #---------------------------------------------------------------------------

    def copy_traits ( self, other, traits = None, memo = None, copy = None,
                            **metadata ):
        """ Copies another object's trait attributes into this one.

        Parameters
        ----------
        other : object
            The object whose trait attribute values should be copied.
        traits : list of strings
            A list of names of trait attributes to copy. If None or
            unspecified, the set of names returned by trait_names() is used.
            If 'all' or an empty list, the set of names returned by
            all_trait_names() is used.
        memo : dict
            A dictionary of objects that have already been copied.
        copy : None | 'deep' | 'shallow'
            The type of copy to perform on any trait that does not have
            explicit 'copy' metadata. A value of None means 'copy reference'.

        Returns
        -------
        unassignable : list of strings
            A list of attributes that the method was unable to copy, which is
            empty if all the attributes were successfully copied.

        """

        if traits is None:
            traits = self.copyable_trait_names( **metadata )
        elif (traits == 'all') or (len( traits ) == 0):
            traits = self.all_trait_names()
            if memo is not None:
                memo[ 'traits_to_copy' ] = 'all'

        unassignable = []
        deferred     = []
        deep_copy    = (copy == 'deep')
        shallow_copy = (copy == 'shallow')

        for name in traits:
            try:
                trait = self.trait( name )
                if trait.type in DeferredCopy:
                    deferred.append( name )
                    continue

                base_trait = other.base_trait( name )
                if base_trait.type == 'event':
                    continue

                value     = getattr( other, name )
                copy_type = base_trait.copy
                if copy_type == 'shallow':
                    value = copy_module.copy( value )
                elif copy_type == 'ref':
                    pass
                elif (copy_type == 'deep') or deep_copy:
                    if memo is None:
                        value = copy_module.deepcopy( value )
                    else:
                        value = copy_module.deepcopy( value, memo )
                elif shallow_copy:
                    value = copy_module.copy( value )

                setattr( self, name, value )
            except:
                unassignable.append( name )

        for name in deferred:
            try:
                value     = getattr( other, name )
                copy_type = other.base_trait( name ).copy
                if copy_type == 'shallow':
                    value = copy_module.copy( value )
                elif copy_type == 'ref':
                    pass
                elif (copy_type == 'deep') or deep_copy:
                    if memo is None:
                        value = copy_module.deepcopy( value )
                    else:
                        value = copy_module.deepcopy( value, memo )
                elif shallow_copy:
                    value = copy_module.copy( value )

                setattr( self, name, value )
            except:
                unassignable.append( name )

        return unassignable

    #---------------------------------------------------------------------------
    #  Clones a new object from this one, optionally copying only a specified
    #  set of traits:
    #---------------------------------------------------------------------------

    def clone_traits ( self, traits = None, memo = None, copy = None,
                             **metadata ):
        """ Clones a new object from this one, optionally copying only a
        specified set of traits.

        Parameters
        ----------
        traits : list of strings
            The list of names of the trait attributes to copy.
        memo : dict
            A dictionary of objects that have already been copied.
        copy : str
            The type of copy ``deep`` or ``shallow`` to perform on any trait
            that does not have explicit 'copy' metadata. A value of None means
            'copy reference'.

        Returns
        -------
        new :
            The newly cloned object.

        Description
        -----------
        Creates a new object that is a clone of the current object. If *traits*
        is None (the default), then all explicit trait attributes defined
        for this object are cloned. If *traits* is 'all' or an empty list, the
        list of traits returned by all_trait_names() is used; otherwise,
        *traits* must be a list of the names of the trait attributes to be
        cloned.
        """
        if memo is None:
            memo = {}

        if traits is None:
            traits = self.copyable_trait_names( **metadata )
        elif (traits == 'all') or (len( traits ) == 0):
            traits = self.all_trait_names()
            memo[ 'traits_to_copy' ] = 'all'

        memo[ 'traits_copy_mode' ] = copy
        new = self.__new__( self.__class__ )
        memo[ id( self ) ] = new
        new._init_trait_listeners()
        new.copy_traits( self, traits, memo, copy, **metadata )
        new._post_init_trait_listeners()
        new.traits_init()
        new.traits_inited( True )

        return new

    #---------------------------------------------------------------------------
    #  Creates a deep copy of the object:
    #---------------------------------------------------------------------------

    def __deepcopy__ ( self, memo ):
        """ Creates a deep copy of the object.
        """
        id_self = id( self )
        if id_self in memo:
            return memo[ id_self ]

        result = self.clone_traits( memo   = memo,
                                    traits = memo.get( 'traits_to_copy' ),
                                    copy   = memo.get( 'traits_copy_mode' ) )

        return result

    #---------------------------------------------------------------------------
    #  Edits the object's traits:
    #---------------------------------------------------------------------------

    def edit_traits ( self, view       = None, parent  = None,
                            kind       = None, context = None,
                            handler    = None, id      = '',
                            scrollable = None, **args ):
        """ Displays a user interface window for editing trait attribute values.

        Parameters
        ----------
        view : View or string
            A View object (or its name) that defines a user interface for
            editing trait attribute values of the current object. If the view is
            defined as an attribute on this class, use the name of the attribute.
            Otherwise, use a reference to the view object. If this attribute is
            not specified, the View object returned by trait_view() is used.
        parent : toolkit control
            The reference to a user interface component to use as the parent
            window for the object's UI window.
        kind : str
            The type of user interface window to create. See the
            **traitsui.view.kind_trait** trait for values and
            their meanings. If *kind* is unspecified or None, the **kind**
            attribute of the View object is used.
        context : object or dictionary
            A single object or a dictionary of string/object pairs, whose trait
            attributes are to be edited. If not specified, the current object is
            used.
        handler : Handler
            A handler object used for event handling in the dialog box. If
            None, the default handler for Traits UI is used.
        id : str
            A unique ID for persisting preferences about this user interface,
            such as size and position. If not specified, no user preferences
            are saved.
        scrollable : bool
            Indicates whether the dialog box should be scrollable. When set to
            True, scroll bars appear on the dialog box if it is not large enough
            to display all of the items in the view at one time.
        """
        if context is None:
            context = self

        view = self.trait_view( view )

        return view.ui( context, parent, kind, self.trait_view_elements(),
                        handler, id, scrollable, args )

    #---------------------------------------------------------------------------
    #  Returns the default context to use for editing/configuring traits:
    #---------------------------------------------------------------------------

    def trait_context ( self ):
        """ Returns the default context to use for editing or configuring
            traits.
        """
        return { 'object': self }

    #---------------------------------------------------------------------------
    #  Gets or sets a ViewElement associated with an object's class:
    #---------------------------------------------------------------------------

    def trait_view ( self, name = None, view_element = None ):
        """ Gets or sets a ViewElement associated with an object's class.

        Parameters
        ----------
        name : str
            Name of a view element
        view_element : ViewElement
            View element to associate

        Returns
        -------
        A view element.

        Description
        -----------
        If both *name* and *view_element* are specified, the view element is
        associated with *name* for the current object's class. (That is,
        *view_element* is added to the ViewElements object associated with
        the current object's class, indexed by *name*.)

        If only *name* is specified, the function returns the view element
        object associated with *name*, or None if *name* has no associated
        view element. View elements retrieved by this function are those that
        are bound to a class attribute in the class definition, or that are
        associated with a name by a previous call to this method.

        If neither *name* nor *view_element* is specified, the method returns a
        View object, based on the following order of preference:

        1. If there is a View object named ``traits_view`` associated with the
           current object, it is returned.
        2. If there is exactly one View object associated the current
           object, it is returned.
        3. Otherwise, it returns a View object containing items for all the
           non-event trait attributes on the current object.

        """
        return self.__class__._trait_view( name, view_element,
                            self.default_traits_view, self.trait_view_elements,
                            self.editable_traits, self )

    def class_trait_view ( cls, name = None, view_element = None ):
        return cls._trait_view( name, view_element,
                  cls.class_default_traits_view, cls.class_trait_view_elements,
                  cls.class_editable_traits, None )

    class_trait_view = classmethod( class_trait_view )

    #---------------------------------------------------------------------------
    #  Gets or sets a ViewElement associated with an object's class:
    #---------------------------------------------------------------------------

    def _trait_view ( cls, name, view_element, default_name, view_elements,
                           editable_traits, handler ):
        """ Gets or sets a ViewElement associated with an object's class.
        """
        # If a view element was passed instead of a name or None, return it:
        if isinstance( name, ViewElement ):
            return name

        # Get the ViewElements object associated with the class:
        view_elements = view_elements()

        # The following test should only succeed for objects created before
        # traits has been fully initialized (such as the default Handler):
        if view_elements is None:
            return None

        if name:
            if view_element is None:
                # If only a name was specified, return the ViewElement it
                # matches, if any:
                result = view_elements.find( name )
                if (result is None) and (handler is not None):
                    method = getattr( handler, name, None )
                    if callable( method ):
                        result = method()

                return result

            # Otherwise, save the specified ViewElement under the name
            # specified:
            view_elements.content[ name ] = view_element

            return None

        # Get the default view/view name:
        name = default_name()

        # If the default is a View, return it:
        if isinstance( name, ViewElement ):
            return name

        # Otherwise, get all View objects associated with the object's class:
        names = view_elements.filter_by()

        # If the specified default name is in the list, return its View:
        if name in names:
            return view_elements.find( name )

        if handler is not None:
            method = getattr( handler, name, None )
            if callable( method ):
                result = method()
                if isinstance( result, ViewElement ):
                    return result

        # If there is only one View, return it:
        if len( names ) == 1:
            return view_elements.find( names[0] )

        # Otherwise, create and return a View based on the set of editable
        # traits defined for the object:
        from traitsui.api import View

        return View( editable_traits(), buttons = [ 'OK', 'Cancel' ] )

    _trait_view = classmethod( _trait_view )

    #---------------------------------------------------------------------------
    #  Return the default traits view/name:
    #---------------------------------------------------------------------------

    def default_traits_view ( self ):
        """ Returns the name of the default traits view for the object's class.
        """
        return self.__class__.class_default_traits_view()

    #---------------------------------------------------------------------------
    #  Return the default traits view/name:
    #---------------------------------------------------------------------------

    def class_default_traits_view ( cls ):
        """ Returns the name of the default traits view for the class.
        """
        return DefaultTraitsView

    class_default_traits_view = classmethod( class_default_traits_view )

    #---------------------------------------------------------------------------
    #  Gets the list of names of ViewElements associated with the object's
    #  class that are of a specified ViewElement type:
    #---------------------------------------------------------------------------

    def trait_views ( self, klass = None ):
        """ Returns a list of the names of all view elements associated with the
        current object's class.

        Parameters
        ----------
        klass : class
            A class, such that all returned names must correspond to instances
            of this class. Possible values include:

            * Group
            * Item
            * View
            * ViewElement
            * ViewSubElement

        Description
        -----------
        If *klass* is specified, the list of names is filtered such that only
        objects that are instances of the specified class are returned.
        """
        return self.__class__.__dict__[ ViewTraits ].filter_by( klass )

    #---------------------------------------------------------------------------
    #  Returns the ViewElements object associated with the object's class:
    #---------------------------------------------------------------------------

    def trait_view_elements ( self ):
        """ Returns the ViewElements object associated with the object's
        class.

        The returned object can be used to access all the view elements
        associated with the class.
        """
        return self.__class__.class_trait_view_elements()

    def class_trait_view_elements ( cls ):
        """ Returns the ViewElements object associated with the class.

        The returned object can be used to access all the view elements
        associated with the class.
        """
        return cls.__dict__[ ViewTraits ]

    class_trait_view_elements = classmethod( class_trait_view_elements )

    #---------------------------------------------------------------------------
    #  Configure the object's traits:
    #---------------------------------------------------------------------------

    def configure_traits ( self, filename = None, view       = None,
                                 kind     = None, edit       = True,
                                 context  = None, handler    = None,
                                 id       = '',   scrollable = None, **args ):
        ### JMS: Is it correct to assume that non-modal options for 'kind'
        ###      behave modally when called from this method?
        """Creates and displays a dialog box for editing values of trait
        attributes, as if it were a complete, self-contained GUI application.

        Parameters
        ----------
        filename : str
            The name (including path) of a file that contains a pickled
            representation of the current object. When this parameter is
            specified, the method reads the corresponding file (if it exists)
            to restore the saved values of the object's traits before displaying
            them. If the user confirms the dialog box (by clicking **OK**),
            the new values are written to the file. If this parameter is not
            specified, the values are loaded from the in-memory object, and are
            not persisted when the dialog box is closed.
        view : View or str
            A View object (or its name) that defines a user interface for
            editing trait attribute values of the current object. If the view is
            defined as an attribute on this class, use the name of the attribute.
            Otherwise, use a reference to the view object. If this attribute is
            not specified, the View object returned by trait_view() is used.
        kind : str
            The type of user interface window to create. See the
            **traitsui.view.kind_trait** trait for values and
            their meanings. If *kind* is unspecified or None, the **kind**
            attribute of the View object is used.
        edit : bool
            Indicates whether to display a user interface. If *filename*
            specifies an existing file, setting *edit* to False loads the
            saved values from that file into the object without requiring
            user interaction.
        context : object or dictionary
            A single object or a dictionary of string/object pairs, whose trait
            attributes are to be edited. If not specified, the current object is
            used
        handler : Handler
            A handler object used for event handling in the dialog box. If
            None, the default handler for Traits UI is used.
        id : str
            A unique ID for persisting preferences about this user interface,
            such as size and position. If not specified, no user preferences
            are saved.
        scrollable : bool
            Indicates whether the dialog box should be scrollable. When set to
            True, scroll bars appear on the dialog box if it is not large enough
            to display all of the items in the view at one time.

        Description
        -----------
        This method is intended for use in applications that do not normally
        have a GUI. Control does not resume in the calling application until
        the user closes the dialog box.

        The method attempts to open and unpickle the contents of *filename*
        before displaying the dialog box. When editing is complete, the method
        attempts to pickle the updated contents of the object back to *filename*.
        If the file referenced by *filename* does not exist, the object is not
        modified before displaying the dialog box. If *filename* is unspecified
        or None, no pickling or unpickling occurs.

        If *edit* is True (the default), a dialog box for editing the
        current object is displayed. If *edit* is False or None, no
        dialog box is displayed. You can use ``edit=False`` if you want the
        object to be restored from the contents of *filename*, without being
        modified by the user.
        """
        if filename is not None:
            fd = None
            try:
                import cPickle
                fd = open( filename, 'rb' )
                self.copy_traits( cPickle.Unpickler( fd ).load() )
            except:
                if fd is not None:
                    fd.close()

        if edit:
            from traitsui.api import toolkit
            if context is None:
                context = self
            rc = toolkit().view_application( context, self.trait_view( view ),
                                           kind, handler, id, scrollable, args )
            if rc and (filename is not None):
                fd = None
                try:
                    import cPickle
                    fd = open( filename, 'wb' )
                    cPickle.Pickler( fd, True ).dump( self )
                finally:
                    if fd is not None:
                        fd.close()
            return rc

        return True

    #---------------------------------------------------------------------------
    #  Return the list of editable traits:
    #---------------------------------------------------------------------------

    def editable_traits ( self ):
        """Returns an alphabetically sorted list of the names of non-event
        trait attributes associated with the current object.
        """
        names = self.trait_names( type = not_event, editable = not_false )
        names.sort()
        return names

    def class_editable_traits ( cls ):
        """Returns an alphabetically sorted list of the names of non-event
        trait attributes associated with the current class.
        """
        names = cls.class_trait_names( type = not_event, editable = not_false )
        names.sort()
        return names

    class_editable_traits = classmethod( class_editable_traits )

    #---------------------------------------------------------------------------
    #  Pretty print the traits of an object:
    #---------------------------------------------------------------------------

    def print_traits ( self, show_help = False, **metadata ):
        """Prints the values of all explicitly-defined, non-event trait
        attributes on the current object, in an easily readable format.

        Parameters
        ----------
        show_help : bool
            Indicates whether to display additional descriptive information.
        """

        if len( metadata ) > 0:
            names = self.trait_names( **metadata )
        else:
            names = self.trait_names( type = not_event )

        if len( names ) == 0:
            print ''
            return

        result = []
        pad    = max( [ len( x ) for x in names ] ) + 1
        maxval = 78 - pad
        names.sort()

        for name in names:
            try:
                value = repr( getattr( self, name ) ).replace( '\n', '\\n' )
                if len( value ) > maxval:
                    value = '%s...%s' % ( value[: (maxval - 2) // 2 ],
                                          value[ -((maxval - 3) // 2): ] )
            except:
                value = '<undefined>'
            lname = (name + ':').ljust( pad )
            if show_help:
                result.append( '%s %s\n   The value must be %s.' % (
                       lname, value, self.base_trait( name ).setter.info() ) )
            else:
                result.append( '%s %s' % ( lname, value ) )

        print '\n'.join( result )

    #---------------------------------------------------------------------------
    #  Add/Remove a handler for a specified trait being changed:
    #
    #  If no name is specified, the handler will be invoked for any trait
    #  change.
    #---------------------------------------------------------------------------

    def _on_trait_change ( self, handler, name = None, remove = False,
                                 dispatch = 'same', priority = False,
                                 target = None):
        """Causes the object to invoke a handler whenever a trait attribute
        is modified, or removes the association.

        Parameters
        ----------
        handler : function
            A trait notification function for the attribute specified by *name*.
        name : str
            Specifies the trait attribute whose value changes trigger the
            notification.
        remove : bool
            If True, removes the previously-set association between
            *handler* and *name*; if False (the default), creates the
            association.

        Description
        -----------
        Multiple handlers can be defined for the same object, or even for the
        same trait attribute on the same object. If *name* is not specified or
        is None, *handler* is invoked when any trait attribute on the
        object is changed.
        """

        if type( name ) is list:
            for name_i in name:
                self._on_trait_change( handler, name_i, remove, dispatch,
                                       priority, target )

            return

        name = name or 'anytrait'

        if remove:
            if name == 'anytrait':
                notifiers = self._notifiers( 0 )
            else:
                trait = self._trait( name, 1 )
                if trait is None:
                    return
                notifiers = trait._notifiers( 0 )

            if notifiers is not None:
                for i, notifier in enumerate( notifiers ):
                    if notifier.equals( handler ):
                        del notifiers[i]
                        notifier.dispose()
                        break

            return

        if name == 'anytrait':
            notifiers = self._notifiers( 1 )
        else:
            notifiers = self._trait( name, 2 )._notifiers( 1 )

        for notifier in notifiers:
            if notifier.equals( handler ):
                break
        else:
            wrapper = self.wrappers[ dispatch ]( handler, notifiers, target )

            if priority:
                notifiers.insert( 0, wrapper )
            else:
                notifiers.append( wrapper )

    #---------------------------------------------------------------------------
    #  Add/Remove handlers for an extended set of one or more traits being
    #  changed:
    #
    #  If no name is specified, the handler will be invoked for any trait
    #  change.
    #---------------------------------------------------------------------------

    def on_trait_change ( self, handler, name = None, remove = False,
                                dispatch = 'same', priority = False,
                                deferred = False, target = None ):
        """Causes the object to invoke a handler whenever a trait attribute
        matching a specified pattern is modified, or removes the association.

        Parameters
        ----------
        handler : function
            A trait notification function for the *name* trait attribute, with
            one of the signatures described below.
        name : str
            The name of the trait attribute whose value changes trigger the
            notification. The *name* can specify complex patterns of trait
            changes using an extended *name* syntax, which is described below.
        remove : bool
            If True, removes the previously-set association between
            *handler* and *name*; if False (the default), creates the
            association.
        dispatch : str
            A string indicating the thread on which notifications must be run.
            Possible values are:

            =========== =======================================================
            value       dispatch
            =========== =======================================================
            ``same``    Run notifications on the same thread as this one.
            ``ui``      Run notifications on the UI thread. If the current
                        thread is the UI thread, the notifications are executed
                        immediately; otherwise, they are placed on the UI
                        event queue.
            ``fast_ui`` Alias for ``ui``.
            ``new``     Run notifications in a new thread.
            =========== =======================================================

        Description
        -----------
        Multiple handlers can be defined for the same object, or even for the
        same trait attribute on the same object. If *name* is not specified or
        is None, *handler* is invoked when any trait attribute on the
        object is changed.

        The *name* parameter is a single *xname* or a list of *xname* names,
        where an *xname* is an extended name of the form::

            xname2[('.'|':') xname2]*

        An *xname2* is of the form::

            ( xname3 | '['xname3[','xname3]*']' ) ['*']

        An *xname3* is of the form::

             xname | ['+'|'-'][name] | name['?' | ('+'|'-')[name]]

        A *name* is any valid Python attribute name. The semantic meaning of
        this notation is as follows:

        ================================ ======================================
        expression                       meaning
        ================================ ======================================
        ``item1.item2``                  means *item1* is a trait containing an
                                         object (or objects if *item1* is a
                                         list or dict) with a trait called
                                         *item2*. Changes to either *item1* or
                                         *item2* cause a notification to be
                                         generated.
        ``item1:item2``                  means *item1* is a trait containing an
                                         object (or objects if *item1* is a
                                         list or dict) with a trait called
                                         *item2*. Changes to *item2* cause a
                                         notification to be generated, while
                                         changes to *item1* do not (i.e., the
                                         ':' indicates that changes to the
                                         *link* object should not be reported).
        ``[ item1, item2, ..., itemN ]`` A list which matches any of the
                                         specified items. Note that at the
                                         topmost level, the surrounding square
                                         brackets are optional.
        ``name?``                        If the current object does not have an
                                         attribute called *name*, the reference
                                         can be ignored. If the '?' character
                                         is omitted, the current object must
                                         have a trait called *name*, otherwise
                                         an exception will be raised.
        ``prefix+``                      Matches any trait on the object whose
                                         name begins with *prefix*.
        ``+metadata_name``               Matches any trait on the object having
                                         *metadata_name* metadata.
        ``-metadata_name``               Matches any trait on the object which
                                         does not have *metadata_name*
                                         metadata.
        ``prefix+metadata_name``         Matches any trait on the object whose
                                         name begins with *prefix* and which
                                         has *metadata_name* metadata.
        ``prefix-metadata_name``         Matches any trait on the object
                                         whose name begins with *prefix* and
                                         which does not have *metadata_name*
                                         metadata.
        ``+``                            Matches all traits on the object.
        ``pattern*``                     Matches object graphs where *pattern*
                                         occurs one or more times (useful for
                                         setting up listeners on recursive data
                                         structures like trees or linked
                                         lists).
        ================================ ======================================

        Some examples of valid names and their meaning are as follows:

        ======================= ===============================================
        example                 meaning
        ======================= ===============================================
        ``foo,bar,baz``         Listen for trait changes to *object.foo*,
                                *object.bar*, and *object.baz*.
        ``['foo','bar','baz']`` Equivalent to 'foo,bar,baz', but may be more
                                useful in cases where the individual items are
                                computed.
        ``foo.bar.baz``         Listen for trait changes to
                                *object.foo.bar.baz* and report changes to
                                *object.foo*, *object.foo.bar* or
                                *object.foo.bar.baz*.
        ``foo:bar:baz``         Listen for changes to *object.foo.bar.baz*, and
                                only report changes to *object.foo.bar.baz*.
        ``foo.[bar,baz]``       Listen for trait changes to *object.foo.bar*
                                and *object.foo.baz*.
        ``[left,right]*.name``  Listen for trait changes to the *name* trait of
                                each node of a tree having *left* and *right*
                                links to other tree nodes, and where *object*
                                the method is applied to the root node of the
                                tree.
        ``+dirty``              Listen for trait changes on any trait in the
                                *object* which has the 'dirty' metadata set.
        ``foo.+dirty``          Listen for trait changes on any trait in
                                *object.foo* which has the 'dirty' metadata
                                set.
        ``foo.[bar,-dirty]``    Listen for trait changes on *object.foo.bar* or
                                any trait on *object.foo* which does not have
                                'dirty' metadata set.
        ======================= ===============================================


        Note that any of the intermediate (i.e., non-final) links in a
        pattern can be traits of type Instance, List or Dict. In the case
        of List and Dict traits, the subsequent portion of the pattern is
        applied to each item in the list, or value in the dictionary.

        For example, if the self.children is a list, 'children.name'
        listens for trait changes to the *name* trait for each item in the
        self.children list.

        Note that items added to or removed from a list or dictionary in
        the pattern will cause the *handler* routine to be invoked as well,
        since this is treated as an *implied* change to the item's trait
        being monitored.

        The signature of the *handler* supplied also has an effect on
        how changes to intermediate traits are processed. The five valid
        handler signatures are:

        1. handler()
        2. handler(new)
        3. handler(name,new)
        4. handler(object,name,new)
        5. handler(object,name,old,new)

        For signatures 1, 4 and 5, any change to any element of a path
        being listened to invokes the handler with information about the
        particular element that was modified (e.g., if the item being
        monitored is 'foo.bar.baz', a change to 'bar' will call *handler*
        with the following information:

        - object: object.foo
        - name:   bar
        - old:    old value for object.foo.bar
        - new:    new value for object.foo.bar

        If one of the intermediate links is a List or Dict, the call to
        *handler* may report an *_items* changed event. If in the previous
        example, *bar* is a List, and a new item is added to *bar*, then
        the information passed to *handler* would be:

        - object: object.foo
        - name:   bar_items
        - old:    Undefined
        - new:    TraitListEvent whose *added* trait contains the new item
                  added to *bar*.

        For signatures 2 and 3, the *handler* does not receive enough
        information to discern between a change to the final trait being
        listened to and a change to an intermediate link. In this case,
        the event dispatcher will attempt to map a change to an
        intermediate link to its effective change on the final trait. This
        only works if all of the intermediate links are single values (such
        as an Instance or Any trait) and not Lists or Dicts. If the modified
        intermediate trait or any subsequent intermediate trait preceding
        the final trait is a List or Dict, then a TraitError is raised,
        since the effective value for the final trait cannot in general be
        resolved unambiguously. To prevent TraitErrors in this case, use the
        ':' separator to suppress notifications for changes to any of the
        intermediate links.

        Handler signature 1 also has the special characteristic that if a
        final trait is a List or Dict, it will automatically handle '_items'
        changed events for the final trait as well. This can be useful in
        cases where the *handler* only needs to know that some aspect of the
        final trait has been changed. For all other *handler* signatures,
        you must explicitly specify the 'xxx_items' trait if you want to
        be notified of changes to any of the items of the 'xxx' trait.

        """
        # Check to see if we can do a quick exit to the basic trait change
        # handler:
        if ((isinstance( name, basestring ) and
            (extended_trait_pat.match( name ) is None)) or (name is None)):
            self._on_trait_change( handler, name, remove, dispatch, priority, target )

            return

        from .traits_listener \
            import TraitsListener, ListenerParser, ListenerHandler, \
                   ListenerNotifyWrapper

        if isinstance( name, list ):
            for name_i in name:
                self.on_trait_change( handler, name_i, remove, dispatch,
                                      priority, target )

            return

        # Make sure we have a name string:
        name = (name or 'anytrait').strip()

        if remove:
            dict = self.__dict__.get( TraitsListener )
            if dict is not None:
                listeners = dict.get( name )
                if listeners is not None:
                    for i, wrapper in enumerate( listeners ):
                        if wrapper.equals( handler ):
                            del listeners[i]
                            if len( listeners ) == 0:
                                del dict[ name ]
                                if len( dict ) == 0:
                                    del self.__dict__[ TraitsListener ]
                            wrapper.listener.unregister( self )
                            wrapper.dispose()
                            break
        else:
            dict      = self.__dict__.setdefault( TraitsListener, {} )
            listeners = dict.setdefault( name, [] )
            for wrapper in listeners:
                if wrapper.equals( handler ):
                    break
            else:
                listener = ListenerParser( name ).listener
                lnw = ListenerNotifyWrapper( handler, self, name, listener, target )
                listeners.append( lnw )
                listener.set( handler         = ListenerHandler( handler ),
                              wrapped_handler_ref = weakref.ref(lnw),
                              type            = lnw.type,
                              dispatch        = dispatch,
                              priority        = priority,
                              deferred        = deferred )
                listener.register( self )

    # A synonym for 'on_trait_change'
    on_trait_event = on_trait_change

    #---------------------------------------------------------------------------
    #  Synchronize the value of two traits:
    #---------------------------------------------------------------------------

    def sync_trait ( self, trait_name, object, alias = None, mutual = True,
                           remove = False ):
        """Synchronizes the value of a trait attribute on this object with a
        trait attribute on another object.

        Parameters
        ----------
        name : str
            Name of the trait attribute on this object.
        object : object
            The object with which to synchronize.
        alias : str
            Name of the trait attribute on *other*; if None or omitted, same
            as *name*.
        mutual : bool or int
            Indicates whether synchronization is mutual (True or non-zero)
            or one-way (False or zero)
        remove : bool or int
            Indicates whether synchronization is being added (False or zero)
            or removed (True or non-zero)

        Description
        -----------
        In mutual synchronization, any change to the value of the specified
        trait attribute of either object results in the same value being
        assigned to the corresponding trait attribute of the other object.
        In one-way synchronization, any change to the value of the attribute
        on this object causes the corresponding trait attribute of *object* to
        be updated, but not vice versa.
        """
        if alias is None:
            alias = trait_name

        is_list = (self._is_list_trait( trait_name ) and
                   object._is_list_trait( alias ))

        if remove:
            info = self._get_sync_trait_info()
            dic  = info.get( trait_name )
            if dic is not None:
                key = ( id( object ), alias )
                if key in dic:
                    del dic[ key ]

                    if len( dic ) == 0:
                        del info[ trait_name ]
                        self._on_trait_change( self._sync_trait_modified,
                            trait_name, remove = True )

                        if is_list:
                            self._on_trait_change(
                                self._sync_trait_items_modified,
                                trait_name + '_items', remove = True )

            if mutual:
                object.sync_trait( alias, self, trait_name, False, True )

            return

        value = ( weakref.ref( object, self._sync_trait_listener_deleted ),
                  alias )
        dic   = self._get_sync_trait_info().setdefault( trait_name, {} )
        key   = ( id( object ), alias )
        if key not in dic:
            if len( dic ) == 0:
                self._on_trait_change( self._sync_trait_modified, trait_name )
                if is_list:
                    self._on_trait_change( self._sync_trait_items_modified,
                                           trait_name + '_items' )
            dic[ key ] = value
            setattr( object, alias, getattr( self, trait_name ) )

        if mutual:
            object.sync_trait( alias, self, trait_name, False )

    def _get_sync_trait_info ( self ):
        info = getattr( self, '__sync_trait__', None )
        if info is None:
            self.__dict__[ '__sync_trait__' ] = info = {}
            info[ '' ] = {}

        return info

    def _sync_trait_modified ( self, object, name, old, new ):
        info   = self.__sync_trait__
        locked = info[ '' ]
        locked[ name ] = None
        for object, object_name in info[ name ].values():
            object = object()
            if object_name not in object._get_sync_trait_info()[ '' ]:
                try:
                    setattr( object, object_name, new )
                except:
                    pass

        del locked[ name ]

    def _sync_trait_items_modified ( self, object, name, old, event ):
        n0     = event.index
        n1     = n0 + len( event.removed )
        name   = name[:-6]
        info   = self.__sync_trait__
        locked = info[ '' ]
        locked[ name ] = None
        for object, object_name in info[ name ].values():
            object = object()
            if object_name not in object._get_sync_trait_info()[ '' ]:
                try:
                    getattr( object, object_name )[ n0: n1 ] = event.added
                except:
                    pass

        del locked[ name ]

    def _sync_trait_listener_deleted ( self, ref ):
        info = self.__sync_trait__
        for key, dic in info.items():
            if key != '':
                for name, value in dic.items():
                    if ref is value[0]:
                        del dic[ name ]
                        if len( dic ) == 0:
                            del info[ key ]

    def _is_list_trait ( self, trait_name ):
        handler = self.base_trait( trait_name ).handler

        return ((handler is not None) and (handler.default_value_type == 5))

    #---------------------------------------------------------------------------
    #  Add a new trait:
    #---------------------------------------------------------------------------

    def add_trait ( self, name, *trait ):
        """Adds a trait attribute to this object.

        Parameters
        ----------
        name : str
            Name of the attribute to add.
        *trait :
            Trait or a value that can be converted to a trait by Trait().
            Trait definition for *name*. If more than one value is specified,
            it is equivalent to passing the entire list of values to Trait().

        """

        # Make sure a trait argument was specified:
        if len( trait ) == 0:
            raise ValueError, 'No trait definition was specified.'

        # Make sure only valid traits get added:
        if len( trait ) > 1:
            trait = Trait( *trait )
        else:
            trait = _trait_for( trait[0] )

        # Check to see if the trait has additional sub-traits that need to be
        # defined also:
        handler = trait.handler
        if handler is not None:
            if handler.has_items:
                self.add_trait( name + '_items', handler.items_event() )
            if handler.is_mapped:
                self.add_trait( name + '_', _mapped_trait_for( trait ) )

        # See if there already is a class or instance trait with the same name:
        old_trait = self._trait( name, 0 )

        # Get the object's instance trait dictionary and add a clone of the new
        # trait to it:
        itrait_dict = self._instance_traits()
        itrait_dict[ name ] = trait = _clone_trait( trait )

        # If there already was a trait with the same name:
        if old_trait is not None:
            # Copy the old traits notifiers into the new trait:
            old_notifiers = old_trait._notifiers( 0 )
            if old_notifiers is not None:
                trait._notifiers( 1 ).extend( old_notifiers )
        else:
            # Otherwise, see if there are any static notifiers that should be
            # applied to the trait:
            cls      = self.__class__
            handlers = [ _get_method( cls, '_%s_changed' % name ),
                         _get_method( cls, '_%s_fired'   % name ) ]

            # Add any special trait defined event handlers:
            _add_event_handlers( trait, cls, handlers )

            # Add the 'anytrait' handler (if any):
            handlers.append( self.__prefix_traits__.get( '@' ) )

            # Filter out any 'None' values:
            handlers = [ h for h in handlers if h is not None ]

            # If there are any static notifiers, attach them to the trait:
            if len( handlers ) > 0:
                _add_notifiers( trait._notifiers( 1 ), handlers )

        # If this was a new trait, fire the 'trait_added' event:
        if old_trait is None:
            self.trait_added = name

    #---------------------------------------------------------------------------
    #  Remove an existing trait:
    #---------------------------------------------------------------------------

    def remove_trait ( self, name ):
        """Removes a trait attribute from this object.

        Parameters
        ----------
        name : str
            Name of the attribute to remove.

        Returns
        -------
        result : bool
            True if the trait was successfully removed.
        """
        # Get the trait definition:
        trait = self._trait( name, 0 )
        if trait is not None:

            # Check to see if the trait has additional sub-traits that need to
            # be removed also:
            handler = trait.handler
            if handler is not None:
                if handler.has_items:
                    self.remove_trait( name + '_items' )
                if handler.is_mapped:
                    self.remove_trait( name + '_' )

            # Remove the trait value from the object dictionary as well:
            if name in self.__dict__:
                del self.__dict__[ name ]

            # Get the object's instance trait dictionary and remove the trait
            # from it:
            itrait_dict = self._instance_traits()
            if name in itrait_dict:
                del itrait_dict[ name ]
                return True

        return False

    #---------------------------------------------------------------------------
    #  Returns the trait definition of a specified trait:
    #---------------------------------------------------------------------------

    def trait ( self, name, force = False, copy = False ):
        """Returns the trait definition for the *name* trait attribute.

        Parameters
        ----------
        name : str
            Name of the attribute whose trait definition is to be returned.
        force : bool
            Indicates whether to return a trait definition if *name* is
            not explicitly defined.
        copy : bool
            Indicates whether to return the original trait definition or a
            copy.

        Description
        -----------
        If *force* is False (the default) and *name* is the name of an
        implicitly defined trait attribute that has never been referenced
        explicitly (i.e., has not yet been defined), the result is None. In
        all other cases, the result is the trait definition object associated
        with *name*.

        If *copy* is True, and a valid trait definition is found for *name*,
        a copy of the trait found is returned. In all other cases, the trait
        definition found is returned unmodified (the default).
        """
        mode = 0
        if force:
            mode = -1
        result = self._trait( name, mode )
        if (not copy) or (result is None):
            return result

        return  _clone_trait( result )

    #---------------------------------------------------------------------------
    #  Returns the base trait definition of a specified trait:
    #---------------------------------------------------------------------------

    def base_trait ( self, name ):
        """Returns the base trait definition for a trait attribute.

        Parameters
        ----------
        name : str
            Name of the attribute whose trait definition is returned.

        Description
        -----------
        This method is similar to the trait() method, and returns a
        different result only in the case where the trait attribute defined by
        *name* is a delegate. In this case, the base_trait() method follows the
        delegation chain until a non-delegated trait attribute is reached, and
        returns the definition of that attribute's trait as the result.
        """
        return self._trait( name, -2 )

    #---------------------------------------------------------------------------
    #  Validates whether or not a specified value is legal for a specified
    # trait and returns the validated value if valid:
    #---------------------------------------------------------------------------

    def validate_trait ( self, name, value ):
        """ Validates whether a value is legal for a trait.

        Returns the validated value if it is valid.
        """
        return self.base_trait( name ).validate( self, name, value )

    #---------------------------------------------------------------------------
    #  Return a dictionary of all traits which match a set of metadata:
    #---------------------------------------------------------------------------

    def traits ( self, **metadata ):
        """Returns a dictionary containing the definitions of all of the trait
        attributes of this object that match the set of *metadata* criteria.

        Parameters
        ----------
        **metadata :
            Criteria for selecting trait attributes.

        Description
        -----------
        The keys of the returned dictionary are the trait attribute names, and
        the values are their corresponding trait definition objects.

        If no *metadata* information is specified, then all explicitly defined
        trait attributes defined for the object are returned.

        Otherwise, the *metadata* keyword dictionary is assumed to define a set
        of search criteria for selecting trait attributes of interest. The
        *metadata* dictionary keys correspond to the names of trait metadata
        attributes to examine, and the values correspond to the values the
        metadata attribute must have in order to be included in the search
        results.

        The *metadata* values either may be simple Python values like strings or
        integers, or may be lambda expressions or functions that return True
        if the trait attribute is to be included in the result. A lambda
        expression or function must receive a single argument, which is the
        value of the trait metadata attribute being tested. If more than one
        metadata keyword is specified, a trait attribute must match the metadata
        values of all keywords to be included in the result.
        """
        traits = self.__base_traits__.copy()
        for name in self.__dict__.keys():
            if name not in traits:
                trait = self.trait( name )
                if trait is not None:
                    traits[ name ] = trait

        if len( metadata ) == 0:
            return traits

        for meta_name, meta_eval in metadata.items():
            if type( meta_eval ) is not FunctionType:
                metadata[ meta_name ] = _SimpleTest( meta_eval )

        result = {}
        for name, trait in traits.items():
            for meta_name, meta_eval in metadata.items():
                if not meta_eval( getattr( trait, meta_name ) ):
                    break
            else:
                result[ name ] = trait

        return result

    #---------------------------------------------------------------------------
    #  Return a dictionary of all traits which match a set of metadata:
    #---------------------------------------------------------------------------

    def class_traits ( cls, **metadata ):
        """Returns a dictionary containing the definitions of all of the trait
        attributes of the class that match the set of *metadata* criteria.

        Parameters
        ----------
        **metadata :
            Criteria for selecting trait attributes.

        Description
        -----------
        The keys of the returned dictionary are the trait attribute names, and
        the values are their corresponding trait definition objects.

        If no *metadata* information is specified, then all explicitly defined
        trait attributes defined for the class are returned.

        Otherwise, the *metadata* keyword dictionary is assumed to define a set
        of search criteria for selecting trait attributes of interest. The
        *metadata* dictionary keys correspond to the names of trait metadata
        attributes to examine, and the values correspond to the values the
        metadata attribute must have in order to be included in the search
        results.

        The *metadata* values either may be simple Python values like strings or
        integers, or may be lambda expressions or functions that return **True**
        if the trait attribute is to be included in the result. A lambda
        expression or function must receive a single argument, which is the
        value of the trait metadata attribute being tested. If more than one
        metadata keyword is specified, a trait attribute must match the metadata
        values of all keywords to be included in the result.
        """
        if len( metadata ) == 0:
            return cls.__base_traits__.copy()

        result = {}

        for meta_name, meta_eval in metadata.items():
            if type( meta_eval ) is not FunctionType:
                metadata[ meta_name ] = _SimpleTest( meta_eval )

        for name, trait in cls.__base_traits__.items():
            for meta_name, meta_eval in metadata.items():
                if not meta_eval( getattr( trait, meta_name ) ):
                    break
            else:
                result[ name ] = trait

        return result

    class_traits = classmethod( class_traits )

    #---------------------------------------------------------------------------
    #  Return a list of all trait names which match a set of metadata:
    #---------------------------------------------------------------------------

    def trait_names ( self, **metadata ):
        """Returns a list of the names of all trait attributes whose definitions
        match the set of *metadata* criteria specified.

        Parameters
        ----------
        **metadata :
            Criteria for selecting trait attributes.

        Description
        -----------
        This method is similar to the traits() method, but returns only the
        names of the matching trait attributes, not the trait definitions.
        """
        return self.traits( **metadata ).keys()

    def class_trait_names ( cls, **metadata ):
        """Returns a list of the names of all trait attributes whose definitions
        match the set of *metadata* criteria specified.

        Parameters
        ----------
        **metadata :
            Criteria for selecting trait attributes.

        Description
        -----------
        This method is similar to the traits() method, but returns only the
        names of the matching trait attributes, not the trait definitions.
        """
        return cls.class_traits( **metadata ).keys()

    class_trait_names = classmethod( class_trait_names )

    #---------------------------------------------------------------------------
    #  Explicitly sets the value of a cached property:
    #---------------------------------------------------------------------------

    def _set_traits_cache ( self, name, value ):
        """ Explicitly sets the value of a cached property.
        """
        cached    = TraitsCache + name
        old_value = self.__dict__.get( cached, Undefined )
        self.__dict__[ cached ] = value
        if old_value != value:
            self.trait_property_changed( name, old_value, value )

    #---------------------------------------------------------------------------
    #  Explicitly flushes the value of a cached property:
    #---------------------------------------------------------------------------

    def _flush_traits_cache ( self, name, value ):
        """ Explicitly flushes the value of a cached property.
        """
        self.trait_property_changed(
            name, self.__dict__.pop( TraitsCache + name, Undefined ) )

    #---------------------------------------------------------------------------
    #  Returns the trait definition for a specified name when there is no
    #  explicit definition in the class:
    #---------------------------------------------------------------------------

    def __prefix_trait__ ( self, name, is_set ):
        # Check to see if the name is of the form '__xxx__':
        if (name[:2] == '__') and (name[-2:] == '__'):
            if name == '__class__':
                return generic_trait

            # If this is for purposes of performing a 'setattr', always map the
            # name to an 'Any' trait:
            if is_set:
                return any_trait

            # Otherwise, it is a 'getattr' request, so indicate that no such
            # attribute exists:
            raise AttributeError, "'%s' object has no attribute '%s'" % (
                                  self.__class__.__name__, name )

        # Handle the special case of 'delegated' traits:
        if name[-1:] == '_':
           trait = self._trait( name[:-1], 0 )
           if (trait is not None) and (trait.type == 'delegate'):
               return _clone_trait( trait )

        prefix_traits = self.__prefix_traits__
        for prefix in prefix_traits['*']:
            if prefix == name[ :len( prefix ) ]:
                # If we found a match, use its trait as a template for a new
                # trait:
                trait = prefix_traits[ prefix ]

                # Get any change notifiers that apply to the trait:
                cls      = self.__class__
                handlers = [ _get_method( cls, '_%s_changed' % name ),
                             _get_method( cls, '_%s_fired'   % name ) ]

                # Add any special trait defined event handlers:
                _add_event_handlers( trait, cls, handlers )

                # Add the 'anytrait' handler (if any):
                handlers.append( prefix_traits.get( '@' ) )

                # Filter out any 'None' values:
                handlers = [ h for h in handlers if h is not None ]

                # If there are any handlers, add them to the trait's notifier's
                # list:
                if len( handlers ) > 0:
                    trait = _clone_trait( trait )
                    _add_notifiers( trait._notifiers( 1 ), handlers )

                return trait

        # There should ALWAYS be a prefix match in the trait classes, since ''
        # is at the end of the list, so we should never get here:
        raise SystemError, ("Trait class look-up failed for attribute '%s' "
                            "for an object of type '%s'") % (
                            name, self.__class__.__name__ )

    #---------------------------------------------------------------------------
    #  Adds/Removes (Java-style) event listeners to an object:
    #---------------------------------------------------------------------------

    def add_trait_listener ( self, object, prefix = '' ):
        self._trait_listener( object, prefix, False )

    def remove_trait_listener ( self, object, prefix = '' ):
        self._trait_listener( object, prefix, True )

    def _trait_listener ( self, object, prefix, remove ):
        if prefix[-1:] != '_':
            prefix += '_'
        n      = len( prefix )
        traits = self.__base_traits__
        for name in self._each_trait_method( object ):
            if name[:n] == prefix:
                if name[-8:] == '_changed':
                    short_name = name[n:-8]
                    if short_name in traits:
                        self._on_trait_change( getattr( object, name ),
                                               short_name, remove = remove )
                    elif short_name == 'anytrait':
                        self._on_trait_change( getattr( object, name ),
                                               remove = remove )
                elif name[:-6] == '_fired':
                    short_name = name[n:-6]
                    if short_name in traits:
                        self._on_trait_change( getattr( object, name ),
                                               short_name, remove = remove )
                    elif short_name == 'anytrait':
                        self._on_trait_change( getattr( object, name ),
                                               remove = remove )

    #---------------------------------------------------------------------------
    #  Generates each (name, method) pair for a specified object:
    #---------------------------------------------------------------------------

    def _each_trait_method ( self, object ):
        """ Generates each (name, method) pair for a specified object.
        """
        dic = {}
        for klass in object.__class__.__mro__:
            for name, method in klass.__dict__.items():
                if (type( method ) is FunctionType) and (name not in dic):
                    dic[ name ] = True
                    yield name

    #---------------------------------------------------------------------------
    #  Handles adding/removing listeners for a generic 'Instance' trait:
    #---------------------------------------------------------------------------

    def _instance_changed_handler ( self, name, old, new ):
        """ Handles adding/removing listeners for a generic 'Instance' trait.
        """
        arg_lists = self._get_instance_handlers( name )

        if old is not None:
            for args in arg_lists:
                old.on_trait_change( remove = True, *args )

        if new is not None:
            for args in arg_lists:
                new.on_trait_change( *args )

    #---------------------------------------------------------------------------
    #  Handles adding/removing listeners for a generic 'List( Instance )' trait:
    #---------------------------------------------------------------------------

    def _list_changed_handler ( self, name, old, new ):
        """ Handles adding/removing listeners for a generic 'List( Instance )'
            trait.
        """
        arg_lists = self._get_instance_handlers( name )

        for item in old:
            for args in arg_lists:
                item.on_trait_change( remove = True, *args )

        for item in new:
            for args in arg_lists:
                item.on_trait_change( *args )

    def _list_items_changed_handler ( self, name, not_used, event ):
        """ Handles adding/removing listeners for a generic 'List( Instance )'
            trait.
        """
        arg_lists = self._get_instance_handlers( name[:-6] )

        for item in event.removed:
            for args in arg_lists:
                item.on_trait_change( remove = True, *args )

        for item in event.added:
            for args in arg_lists:
                item.on_trait_change( *args )

    #---------------------------------------------------------------------------
    #  Returns a list of ( name, method ) pairs for a specified 'Instance' or
    #  'List( Instance )' trait name:
    #---------------------------------------------------------------------------

    def _get_instance_handlers ( self, name ):
        """ Returns a list of ( name, method ) pairs for a specified 'Instance'
            or 'List( Instance )' trait name:
        """
        return [ ( getattr( self, method_name ), item_name )
                 for method_name, item_name in
                     self.__class__.__instance_traits__[ name ] ]

    #---------------------------------------------------------------------------
    #  Initializes the object's statically parsed, but dynamically registered,
    #  traits listeners (called at object creation and unpickling times):
    #---------------------------------------------------------------------------

    def _post_init_trait_listeners ( self ):
        """ Initializes the object's statically parsed, but dynamically
            registered, traits listeners (called at object creation and
            unpickling times).
        """
        for name, data in self.__class__.__listener_traits__.items():
            if data[0] == 'method':
                pattern = data[1]
                if pattern[:1] == '>':
                    self.on_trait_change( getattr( self, name ), pattern[1:],
                                          deferred = True )

    def _init_trait_listeners ( self ):
        """ Initializes the object's statically parsed, but dynamically
            registered, traits listeners (called at object creation and
            unpickling times).
        """
        for name, data in self.__class__.__listener_traits__.items():
            getattr( self, '_init_trait_%s_listener' % data[0] )( name, *data )

    def _init_trait_method_listener ( self, name, kind, pattern ):
        """ Sets up the listener for a method with the @on_trait_change
            decorator.
        """
        if pattern[:1] == '<':
            self.on_trait_change( getattr( self, name ), pattern[1:],
                                  deferred = True )

    def _init_trait_event_listener ( self, name, kind, pattern ):
        """ Sets up the listener for an event with on_trait_change metadata.
        """
        @weak_arg(self)
        def notify ( self ):
            setattr( self, name, True )

        self.on_trait_change( notify, pattern, target=self )

    def _init_trait_property_listener ( self, name, kind, cached, pattern ):
        """ Sets up the listener for a property with 'depends_on' metadata.
        """
        if cached is None:
            @weak_arg(self)
            def notify ( self ):
                self.trait_property_changed( name, None )
        else:
            cached_old = cached + ':old'
            @weak_arg(self)
            def pre_notify ( self ):
                dict = self.__dict__
                old  = dict.get( cached_old, Undefined )
                if old is Undefined:
                    dict[ cached_old ] = dict.pop( cached, None )
            self.on_trait_change( pre_notify, pattern, priority = True, target=self )

            @weak_arg(self)
            def notify ( self ):
                old = self.__dict__.pop( cached_old, Undefined )
                if old is not Undefined:
                    self.trait_property_changed( name, old )

        self.on_trait_change( notify, pattern, target=self )

    def _init_trait_delegate_listener ( self, name, kind, pattern ):
        """ Sets up the listener for a delegate trait.
        """
        name_pattern    = self._trait_delegate_name( name, pattern )
        target_name_len = len( name_pattern.split( ':' )[-1] )

        @weak_arg(self)
        def notify ( self, object, notify_name, old, new ):
            self.trait_property_changed( name + notify_name[ target_name_len: ],
                                         old, new )

        self.on_trait_change( notify, name_pattern, target=self )
        self.__dict__.setdefault( ListenerTraits, {} )[ name ] = notify

    def _remove_trait_delegate_listener ( self, name, remove ):
        """ Removes a delegate listener when the local delegate value is set.
        """
        dict = self.__dict__.setdefault( ListenerTraits, {} )

        if remove:
            # Although the name should be in the dict, it may not be if a value
            # was assigned to a delegate in a constructor or setstate:
            if name in dict:
                # Remove the delegate listener:
                self.on_trait_change( dict[ name ], self._trait_delegate_name(
                         name, self.__class__.__listener_traits__[ name ][1] ),
                         remove = True )
                del dict[ name ]
                if len( dict ) == 0:
                    del self.__dict__[ ListenerTraits ]

            return

        # Otherwise the local copy of the delegate value was deleted, restore
        # the delegate listener (unless it's already there):
        if name not in dict:
            self._init_trait_delegate_listener(
                     name, 0, self.__class__.__listener_traits__[ name ][1] )

    def _trait_delegate_name ( self, name, pattern ):
        """ Returns the fully-formed 'on_trait_change' name for a specified
            delegate.
        """
        if pattern[-1] == '*':
            pattern = '%s%s%s' % ( pattern[:-1], self.__class__.__prefix__,
                                    name )

        return pattern

# Patch the definition of _HasTraits to be the real 'HasTraits':
_HasTraits = HasTraits

#-------------------------------------------------------------------------------
#  'HasStrictTraits' class:
#-------------------------------------------------------------------------------

class HasStrictTraits ( HasTraits ):
    """ This class guarantees that any object attribute that does not have an
    explicit or wildcard trait definition results in an exception.

    This feature can be useful in cases where a more rigorous software
    engineering approach is being used than is typical for Python programs. It
    also helps prevent typos and spelling mistakes in attribute names from
    going unnoticed; a misspelled attribute name typically causes an exception.
    """
    _ = Disallow   # Disallow access to any traits not explicitly defined

#-------------------------------------------------------------------------------
#  'HasPrivateTraits' class:
#-------------------------------------------------------------------------------

class HasPrivateTraits ( HasTraits ):
    """ This class ensures that any public object attribute that does not have
    an explicit or wildcard trait definition results in an exception, but
    "private" attributes (whose names start with '_') have an initial value of
    **None**, and are not type-checked.

    This feature is useful in cases where a class needs private attributes to
    keep track of its internal object state, which are not part of the class's
    public API. Such attributes do not need to be type-checked, because they are
    manipulated only by the (presumably correct) methods of the class itself.
    """
    # Make 'private' traits (leading '_') have no type checking:
    __ = Any( private = True, transient = True )

    # Disallow access to all other traits not explicitly defined:
    _  = Disallow


#------------------------------------------------------------------------------
# ABC classes with traits: (where available)
#------------------------------------------------------------------------------
try:

    import abc


    class ABCMetaHasTraits(abc.ABCMeta, MetaHasTraits):
        """ A MetaHasTraits subclass which also inherits from
        abc.ABCMeta.

        .. note:: The ABCMeta class is cooperative and behaves nicely
            with MetaHasTraits, provided it is inherited first.
        """
        pass


    class ABCHasTraits(HasTraits):
        """ A HasTraits subclass which enables the features of Abstract
        Base Classes (ABC). See the 'abc' module in the standard library
        for more information.

        """
        __metaclass__ = ABCMetaHasTraits


    class ABCHasStrictTraits(ABCHasTraits):
        """ A HasTraits subclass which behaves like HasStrictTraits but
        also enables the features of Abstract Base Classes (ABC). See the
        'abc' module in the standard library for more information.

        """
        _ = Disallow

except ImportError:
    pass

#-------------------------------------------------------------------------------
#  Singleton classes with traits:
#
#  This code is based on a recipe taken from:
#      http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66531
#  Specifically, the implementation of Oren Tirosh is used.
#-------------------------------------------------------------------------------

class SingletonHasTraits ( HasTraits ):
    """ Singleton class that support trait attributes.
    """
    def __new__ ( cls, *args, **traits ):
        if not '_the_instance' in cls.__dict__:
            cls._the_instance = HasTraits.__new__( cls, *args, **traits )
        return cls._the_instance

class SingletonHasStrictTraits ( HasStrictTraits ):
    """ Singleton class that supports strict trait attributes.

        Non-trait attributes generate an exception.
    """
    def __new__ ( cls, *args, **traits ):
        return SingletonHasTraits.__new__( cls, *args, **traits )

class SingletonHasPrivateTraits ( HasPrivateTraits ):
    """ Singleton class that supports trait attributes, with private attributes
        being unchecked.
    """
    def __new__ ( cls, *args, **traits ):
        return SingletonHasTraits.__new__( cls, *args, **traits )

#-------------------------------------------------------------------------------
#  Defines a 'vetoable' request object and an associated event:
#-------------------------------------------------------------------------------

class Vetoable ( HasStrictTraits ):
    """ Defines a 'vetoable' request object and an associated event.
    """
    # Should the request be vetoed? (Can only be set to 'True')
    veto = Bool( False )

    def _veto_changed ( self, state ):
        self._trait_veto_notify( state )

VetoableEvent = Event( Vetoable )

#-------------------------------------------------------------------------------
#  'MetaInterface' class:
#-------------------------------------------------------------------------------

class MetaInterface ( ABCMetaHasTraits ):
    """ Meta class for interfaces.

    Interfaces are simple ABCs with the following features:-

    1) They cannot be instantiated (they are interfaces, not implementations!).
    2) Calling them is equivalent to calling 'adapt'.

    """

    @deprecated('use "adapt(adaptee, protocol)" instead.')
    def __call__ ( self, adaptee, default=AdaptationError ):
        """ Attempt to adapt the adaptee to this interface.

        Note that this means that (intentionally ;^) that interfaces
        cannot be instantiated!

        """

        from traits.adaptation.api import adapt

        return adapt(adaptee, self, default=default)

#-------------------------------------------------------------------------------
#  'Interface' class:
#-------------------------------------------------------------------------------

class Interface ( HasTraits ):
    """ The base class for all interfaces.
    """

    __metaclass__ = MetaInterface

#-------------------------------------------------------------------------------
#  Class decorator to declare the protocols that a class provides.
#-------------------------------------------------------------------------------

def provides( *protocols ):
    """ Class decorator to declare the protocols that a class provides.

    Parameters
    ----------
    *protocols :
        A list of protocols (Interface classes or Python ABCs) that the
        decorated class provides.

    """

    from abc import ABCMeta

    # Exit immediately if there is nothing to do.
    if len(protocols) == 0:
        return lambda klass: klass

    # Verify that each argument is a valid protocol.
    for protocol in protocols:
        if not issubclass(type(protocol), ABCMeta):
            raise TraitError(
                "All arguments to 'provides' must be "
                "subclasses of Interface or be a Python ABC."
            )

    def wrapped_class(klass):
        for protocol in protocols:
            # We use 'type(protocol)' in case the 'protocol' implements
            # its own 'register' method that overrides the ABC method.
            type(protocol).register(protocol, klass)

        # Make sure the class does provide the protocols it claims to.
        if CHECK_INTERFACES:
            from .interface_checker import check_implements
            check_implements(klass, protocols, CHECK_INTERFACES)

        return klass

    return wrapped_class

#-------------------------------------------------------------------------------
#  Return True if the class is an Interface.
#-------------------------------------------------------------------------------

def isinterface( klass ):
    """ Return True if the class is an Interface. """

    return isinstance(klass, MetaInterface)

#-------------------------------------------------------------------------------
#  Declares the interfaces that a class implements.
#-------------------------------------------------------------------------------

def implements( *interfaces ):
    """ Declares the interfaces that a class implements.

    Parameters
    ----------
    *interfaces :
        A list of interface classes that the containing class implements.

    Description
    -----------
    Registers each specified interface with the interface manager as an
    interface that the containing class implements. Each specified interface
    must be a subclass of **Interface**. This function should only be
    called from directly within a class body.

    .. deprecated:: 4.4
       Use the ``provides`` class decorator instead.

    """

    callback = provides(*interfaces)
    callback = deprecated(
        "'the 'implements' class advisor has been deprecated. "
        "Use the 'provides' class decorator."
    )(callback)

    addClassAdvisor(callback)

#-------------------------------------------------------------------------------
#  'ISerializable' interface:
#-------------------------------------------------------------------------------

class ISerializable ( Interface ):
    """ A class that implemented ISerializable requires that all HasTraits
        objects saved as part of its state also implement ISerializable.
    """
#-------------------------------------------------------------------------------
#  'traits_super' class:
#-------------------------------------------------------------------------------

class traits_super ( super ):

    def __getattribute__ ( self, name ):
        try:
            return super( traits_super, self ).__getattribute__( name )
        except:
            return self._noop

    def _noop ( self, *args, **kw ):
        pass

########NEW FILE########
__FILENAME__ = interface_checker
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Martin Chilvers
#  Date:   03/20/2008
#
#------------------------------------------------------------------------------

""" An attempt at type-safe casting.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from types import FunctionType

from inspect import getargspec, getmro

from .has_traits import HasTraits

#-------------------------------------------------------------------------------
#  Logging:
#-------------------------------------------------------------------------------

import logging

logger = logging.getLogger( __name__ )

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Message templates for interface errors.
BAD_SIGNATURE  = ("The '%s' class signature for the '%s' method is different "
                  "from that of the '%s' interface.")
MISSING_METHOD = ("The '%s' class does not implement the '%s' method of the "
                  "'%s' interface.")
MISSING_TRAIT  = ("The '%s' class does not implement the %s trait(s) of the "
                  "'%s' interface.")

#-------------------------------------------------------------------------------
#  'InterfaceError' class:
#-------------------------------------------------------------------------------

class InterfaceError ( Exception ):
    """ The exception raised if a class does not really implement an interface.
    """
    pass

#-------------------------------------------------------------------------------
#  'InterfaceChecker' class:
#-------------------------------------------------------------------------------

class InterfaceChecker ( HasTraits ):
    """ Checks that interfaces are actually implemented.
    """

    #---------------------------------------------------------------------------
    #  'InterfaceChecker' interface:
    #---------------------------------------------------------------------------

    def check_implements ( self, cls, interfaces, error_mode ):
        """ Checks that the class implements the specified interfaces.

            'interfaces' can be a single interface or a list of interfaces.
        """
        # If a single interface was specified then turn it into a list:
        try:
            iter( interfaces )
        except TypeError:
            interfaces = [ interfaces ]

        # If the class has traits then check that it implements all traits and
        # methods on the specified interfaces:
        if issubclass( cls, HasTraits ):
            for interface in interfaces:
                if not self._check_has_traits_class( cls, interface,
                                                     error_mode ):
                    return False

        # Otherwise, just check that the class implements all methods on the
        # specified interface:
        else:
            for interface in interfaces:
                if not self._check_non_has_traits_class( cls, interface,
                                                         error_mode ):
                    return False

        return True

    #---------------------------------------------------------------------------
    #  Private interface:
    #---------------------------------------------------------------------------

    def _check_has_traits_class ( self, cls, interface, error_mode ):
        """ Checks that a 'HasTraits' class implements an interface.
        """
        return (self._check_traits(  cls, interface, error_mode ) and
                self._check_methods( cls, interface, error_mode ))

    def _check_non_has_traits_class ( self, cls, interface, error_mode ):
        """ Checks that a non-'HasTraits' class implements an interface.
        """
        return self._check_methods( cls, interface, error_mode )

    def _check_methods ( self, cls, interface, error_mode ):
        """ Checks that a class implements the methods on an interface.
        """
        cls_methods       = self._get_public_methods( cls )
        interface_methods = self._get_public_methods( interface )

        for name in interface_methods:
            if name not in cls_methods:
                return self._handle_error( MISSING_METHOD %
                           ( self._class_name( cls ), name,
                             self._class_name( interface ) ), error_mode )


            # Check that the method signatures are the same:
            cls_argspec       = getargspec( cls_methods[ name ] )
            interface_argspec = getargspec( interface_methods[ name ] )

            if cls_argspec != interface_argspec:
                return self._handle_error( BAD_SIGNATURE %
                           ( self._class_name( cls ), name,
                             self._class_name( interface ) ), error_mode )

        return True

    def _check_traits ( self, cls, interface, error_mode ):
        """ Checks that a class implements the traits on an interface.
        """
        missing = set( interface.class_traits() ).difference(
                  set( cls.class_traits() ) )

        if len( missing ) > 0:
            return self._handle_error( MISSING_TRAIT %
                       ( self._class_name( cls ), `list( missing )`[1:-1],
                         self._class_name( interface ) ), error_mode )

        return True

    def _get_public_methods ( self, cls ):
        """ Returns all public methods on a class.

            Returns a dictionary containing all public methods keyed by name.
        """
        public_methods = {}
        for c in getmro( cls ):
            # Stop when we get to 'HasTraits'!:
            if c is HasTraits:
                break

            for name, value in c.__dict__.items():
                if ((not name.startswith( '_' )) and
                    (type( value ) is FunctionType)):
                    public_methods[ name ] = value

        return public_methods

    def _class_name ( self, cls ):
        return cls.__name__

    def _handle_error ( self, msg, error_mode ):
        if error_mode > 1:
            raise InterfaceError( msg )

        if error_mode == 1:
            logger.warning( msg )

        return False


# A default interface checker:
checker = InterfaceChecker()

def check_implements ( cls, interfaces, error_mode = 0 ):
    """ Checks that the class implements the specified interfaces.

        'interfaces' can be a single interface or a list of interfaces.
    """
    return checker.check_implements( cls, interfaces, error_mode )


########NEW FILE########
__FILENAME__ = advice
""" This module implements functionality similar to class decorators.

At the moment it is used for the 'implements' and 'adapts' functions, which
have been deprecated together with the 'traits.protocols' package.

Please don't import anything from this module!

"""

from __future__ import absolute_import

from types import FunctionType

import sys

from .. import _py2to3

__all__ = ['addClassAdvisor']


def metamethod(func):
    """Wrapper for metaclass method that might be confused w/instance method"""
    return property(lambda ob: func.__get__(ob,ob.__class__))


if sys.version_info[0] < 3:
    from types import ClassType, InstanceType
    
    ClassicTypes = ClassType
    
    def classicMRO(ob, extendedClassic=False):
        stack = []
        push = stack.insert
        pop = stack.pop
        push(0,ob)
        while stack:
            cls = pop()
            yield cls
            p = len(stack)
            for b in cls.__bases__: push(p,b)
        if extendedClassic:
            yield InstanceType
            yield object
    
    
    def getMRO(ob, extendedClassic=False):
    
        if isinstance(ob,ClassicTypes):
            return classicMRO(ob,extendedClassic)
    
        elif isinstance(ob,type):
            return ob.__mro__
    
        return ob,
else:
    def getMRO(ob, *args, **kwargs):
        if args or kwargs:
            kwargs.pop('extendedClassic',None)
            if len(args)>1 or kwargs:
                raise TypeError
            import warnings
            warnings.warn(DeprecationWarning(
                """In Python 3 there are no more ols-style classes.
                Therefore, extendedClassic has no meaning and should not be used.
                """
            ))
        if isinstance(ob,type):
            return ob.__mro__
    
        return ob,

try:
    from ._speedups import metamethod, getMRO, classicMRO
except ImportError:
    pass


# property-safe 'super()' for Python 2.2; 2.3 can use super() instead

def supermeta(typ,ob):

    starttype = type(ob)
    mro = starttype.__mro__
    if typ not in mro:
        starttype = ob
        mro = starttype.__mro__

    mro = iter(mro)
    for cls in mro:
        if cls is typ:
            mro = [cls.__dict__ for cls in mro]
            break
    else:
        raise TypeError("Not sub/supertypes:", starttype, typ)

    typ = type(ob)

    class theSuper(object):

        def __getattribute__(self,name):
            for d in mro:
                if name in d:
                    descr = d[name]
                    try:
                        descr = descr.__get__
                    except AttributeError:
                        return descr
                    else:
                        return descr(ob,typ)
            return object.__getattribute__(self,name)

    return theSuper()


def getFrameInfo(frame):
    """Return (kind,module,locals,globals) for a frame

    'kind' is one of "exec", "module", "class", "function call", or "unknown".
    """

    f_locals = frame.f_locals
    f_globals = frame.f_globals

    sameNamespace = f_locals is f_globals
    hasModule = '__module__' in f_locals
    hasName = '__name__' in f_globals

    sameName = hasModule and hasName
    sameName = sameName and f_globals['__name__']==f_locals['__module__']

    module = hasName and sys.modules.get(f_globals['__name__']) or None

    namespaceIsModule = module and module.__dict__ is f_globals

    if not namespaceIsModule:
        # some kind of funky exec
        kind = "exec"
    elif sameNamespace and not hasModule:
        kind = "module"
    elif sameName and not sameNamespace:
        kind = "class"
    elif not sameNamespace:
        kind = "function call"
    else:
        # How can you have f_locals is f_globals, and have '__module__' set?
        # This is probably module-level code, but with a '__module__' variable.
        kind = "unknown"

    return kind,module,f_locals,f_globals


def addClassAdvisor(callback, depth=2):

    """Set up 'callback' to be passed the containing class upon creation

    This function is designed to be called by an "advising" function executed
    in a class suite.  The "advising" function supplies a callback that it
    wishes to have executed when the containing class is created.  The
    callback will be given one argument: the newly created containing class.
    The return value of the callback will be used in place of the class, so
    the callback should return the input if it does not wish to replace the
    class.

    The optional 'depth' argument to this function determines the number of
    frames between this function and the targeted class suite.  'depth'
    defaults to 2, since this skips this function's frame and one calling
    function frame.  If you use this function from a function called directly
    in the class suite, the default will be correct, otherwise you will need
    to determine the correct depth yourself.

    This function works by installing a special class factory function in
    place of the '__metaclass__' of the containing class.  Therefore, only
    callbacks *after* the last '__metaclass__' assignment in the containing
    class will be executed.  Be sure that classes using "advising" functions
    declare any '__metaclass__' *first*, to ensure all callbacks are run.

    Moreover, since starting from Python 3, metaclasses are specified
    differently, this function does not work anymore. Worse, as the metaclass
    is selected even before running the class's body, there is no way to
    fix this in a general way. As long as the metaclass provides some hooks
    to run code at class creation time, we can use them, but standard "type"
    does not.    
    """
    if sys.version_info[0] >= 3:
        raise NotImplementedError("Class advisors are not possible in python 3.")


    frame = sys._getframe(depth)
    kind, module, caller_locals, caller_globals = getFrameInfo(frame)

    if kind not in ("class", "exec"):
        raise SyntaxError(
            "Advice must be in the body of a class statement"
        )

    previousMetaclass = caller_locals.get('__metaclass__')
    defaultMetaclass  = caller_globals.get('__metaclass__', type)  #TODO: This used to be ClassType, but I think this was errornous. Check it!


    def advise(name,bases,cdict):

        if '__metaclass__' in cdict:
            del cdict['__metaclass__']

        if previousMetaclass is None:
             if bases:
                 # find best metaclass or use global __metaclass__ if no bases
                 meta = determineMetaclass(bases)
             else:
                 meta = defaultMetaclass

        elif isClassAdvisor(previousMetaclass):
            # special case: we can't compute the "true" metaclass here,
            # so we need to invoke the previous metaclass and let it
            # figure it out for us (and apply its own advice in the process)
            meta = previousMetaclass

        else:
            meta = determineMetaclass(bases, previousMetaclass)

        newClass = meta(name,bases,cdict)

        # this lets the callback replace the class completely, if it wants to
        return callback(newClass)

    # introspection data only, not used by inner function
    advise.previousMetaclass = previousMetaclass
    advise.callback = callback

    # install the advisor
    caller_locals['__metaclass__'] = advise


def isClassAdvisor(ob):
    """True if 'ob' is a class advisor function"""
    return isinstance(ob,FunctionType) and hasattr(ob,'previousMetaclass')


def determineMetaclass(bases, explicit_mc=None):

    """Determine metaclass from 1+ bases and optional explicit __metaclass__"""

    meta = [getattr(b,'__class__',type(b)) for b in bases]

    if explicit_mc is not None:
        # The explicit metaclass needs to be verified for compatibility
        # as well, and allowed to resolve the incompatible bases, if any
        meta.append(explicit_mc)

    if len(meta)==1:
        # easy case
        return meta[0]

    candidates = minimalBases(meta) # minimal set of metaclasses

    if not candidates:
        # they're all "classic" classes
        # should never happen in Python 3, so this should be fine
        from types import ClassType
        return ClassType

    elif len(candidates)>1:
        # We could auto-combine, but for now we won't...
        raise TypeError("Incompatible metatypes",bases)

    # Just one, return it
    return candidates[0]


def minimalBases(classes):
    """Reduce a list of base classes to its ordered minimum equivalent"""

    classes = [c for c in classes if not _py2to3.is_old_style_class(c)]
    candidates = []

    for m in classes:
        for n in classes:
            if issubclass(n,m) and m is not n:
                break
        else:
            # m has no subclasses in 'classes'
            if m in candidates:
                candidates.remove(m)    # ensure that we're later in the list
            candidates.append(m)

    return candidates


from weakref import ref

class StrongRef(object):

    """Like a weakref, but for non-weakrefable objects"""

    __slots__ = 'referent'

    def __init__(self,referent):
        self.referent = referent

    def __call__(self):
        return self.referent

    def __hash__(self):
        return hash(self.referent)

    def __eq__(self,other):
        return self.referent==other

    def __repr__(self):
        return 'StrongRef(%r)' % self.referent


def mkRef(ob,*args):
    """Return either a weakref or a StrongRef for 'ob'

    Note that extra args are forwarded to weakref.ref() if applicable."""

    try:
        return ref(ob,*args)
    except TypeError:
        return StrongRef(ob)


########NEW FILE########
__FILENAME__ = api
"""Trivial Interfaces and Adaptation from PyProtocols.

This package used to be a subset of the files from Phillip J. Eby's PyProtocols
package. The package has been substituted by :mod:`traits.adaptation` as of
Traits 4.4.0.

Currently, the package contains deprecated aliases for backward compatibility,
and will be removed in Traits 5.0 .

"""


from traits.util.api import deprecated

@deprecated("use the 'adapt' function in 'traits.adaptation' instead")
def adapt(*args, **kw):
    from traits.adaptation.api import adapt

    return adapt(*args, **kw)

@deprecated("use the 'register_factory' function in 'traits.adaptation' instead")
def declareAdapter(factory, provides,
                   forTypes=(), forProtocols=(), forObjects=()):

    from traits.adaptation.api import register_factory
    from itertools import chain

    for from_protocol in chain(forTypes, forProtocols, forObjects):
        for to_protocol in provides:
            register_factory(factory, from_protocol, to_protocol)

@deprecated("use the 'register_provides' function in 'traits.adaptation' instead")
def declareImplementation(protocol,
                          instancesProvide=(), instancesDoNotProvide=()):

    from traits.adaptation.api import register_provides

    for to_protocol in instancesProvide:
        register_provides(protocol, to_protocol)

from traits.adaptation.adaptation_error import AdaptationError \
    as AdaptationFailure

# We will provide decorators as replacements for 'implements' and 'adapts'
# in the future.
from .advice import addClassAdvisor

########NEW FILE########
__FILENAME__ = api
from doctest_tools import doctest_for_module
from nose_tools import deprecated, performance, skip
from unittest_tools import UnittestTools

########NEW FILE########
__FILENAME__ = doctest_tools
""" Tools for having doctest and unittest work together more nicely.

    Eclipse's PyDev plugin will run your unittest files for you very nicely.
    The doctest_for_module function allows you to easily run the doctest for a
    module along side your standard unit tests within Eclipse.
"""

# Standard library imports
import doctest
from traits.testing.unittest_tools import unittest
import sys

def doctest_for_module(module):
    """ Create a TestCase from a module's doctests that will be run by the
        standard unittest.main().

        Example tests/test_foo.py::

            import unittest

            import foo
            from traits.testing.api import doctest_for_module

            class FooTestCase(unittest.TestCase):
                ...

            class FooDocTest(doctest_for_module(foo)):
                pass

            if __name__ == "__main__":
                # This will run and report both FooTestCase and the doctests in
                # module foo.
                unittest.main()

        Alternatively, you can say::

            FooDocTest = doctest_for_module(foo)

        instead of::

            class FooDocTest(doctest_for_module(foo)):
                pass
    """

    class C(unittest.TestCase):
        def test_dummy(self): pass # Make the test case loader find us
        def run(self, result=None):
            # doctest doesn't like nose.result.TextTestResult objects,
            # so we try to determine if thats what we're dealing
            # with and use its internal result attribute instead
            if hasattr(result, 'result'):
                doctest.DocTestSuite(module).run(result.result)
            else:
                doctest.DocTestSuite(module).run(result)
    return C

########NEW FILE########
__FILENAME__ = nose_tools
"Non-standard functions for the 'nose' testing framework."

try:
    from nose import DeprecatedTest, SkipTest
    from nose.tools import make_decorator


    def skip(f):
        """ Decorator to indicate a test should be skipped.
        """
        def g(*args, **kw):
            raise SkipTest()
        return make_decorator(f)(g)

    def deprecated(f):
        """ Decorator to indicate a test is deprecated.
        """
        def g(*args, **kw):
            raise DeprecatedTest()
        return make_decorator(f)(g)

except ImportError:
    # Define stubs in case nose isn't installed.

    import warnings


    def skip(f):
        """ Stub replacement for marking a unit test to be skipped in the
        absence of 'nose'.
        """

        warnings.warn("skipping unit tests requires the package 'nose'")
        return f

    def deprecated(f):
        """ Stub replacement for marking a unit test deprecated in the absence
        of 'nose'.
        """

        warnings.warn("skipping deprecated unit tests requires the package 'nose'")
        return f

def performance(f):
    """ Decorator to add an attribute to the test to mark it as
    a performance-measuring test.
    """
    f.performance = True
    return f

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = test_unittest_tools
#------------------------------------------------------------------------------
# Copyright (c) 2005-2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#------------------------------------------------------------------------------
import threading
import time

from traits import _py2to3

from traits.testing.unittest_tools import unittest
from traits.api import (Bool, Event, Float, HasTraits, Int, List,
                        on_trait_change)
from traits.testing.api import UnittestTools


class TestObject(HasTraits):

    number = Float(2.0)
    list_of_numbers = List(Float)
    flag = Bool

    @on_trait_change('number')
    def _add_number_to_list(self, value):
        self.list_of_numbers.append(value)

    def add_to_number(self, value):
        self.number += value


class UnittestToolsTestCase(unittest.TestCase, UnittestTools):

    def setUp(self):
        self.test_object = TestObject()

    def test_when_using_with(self):
        """ Check normal use cases as a context manager.
        """
        test_object = self.test_object

        # Change event should NOT BE detected
        with self.assertTraitDoesNotChange(test_object, 'number') as result:
            test_object.flag = True
            test_object.number = 2.0

        msg = 'The assertion result is not None: {0}'.format(result.event)
        self.assertIsNone(result.event, msg=msg)

        # Change event should BE detected
        with self.assertTraitChanges(test_object, 'number') as result:
            test_object.flag = False
            test_object.number = 5.0

        expected = (test_object, 'number', 2.0, 5.0)
        self.assertSequenceEqual(expected, result.event)

        # Change event should BE detected exactly 2 times
        with self.assertTraitChanges(test_object, 'number', count=2) as result:
            test_object.flag = False
            test_object.number = 4.0
            test_object.number = 3.0

        expected = [(test_object, 'number', 5.0, 4.0),
                    (test_object, 'number', 4.0, 3.0)]
        self.assertSequenceEqual(expected, result.events)
        self.assertSequenceEqual(expected[-1], result.event)

        # Change event should BE detected
        with self.assertTraitChanges(test_object, 'number') as result:
            test_object.flag = True
            test_object.add_to_number(10.0)

        expected = (test_object, 'number', 3.0, 13.0)
        self.assertSequenceEqual(expected, result.event)

        # Change event should BE detected exactly 3 times
        with self.assertTraitChanges(test_object, 'number', count=3) as result:
            test_object.flag = True
            test_object.add_to_number(10.0)
            test_object.add_to_number(10.0)
            test_object.add_to_number(10.0)

        expected = [(test_object, 'number', 13.0, 23.0),
                    (test_object, 'number', 23.0, 33.0),
                    (test_object, 'number', 33.0, 43.0)]
        self.assertSequenceEqual(expected, result.events)
        self.assertSequenceEqual(expected[-1], result.event)

    def test_assert_multi_changes(self):
        test_object = self.test_object

        # Change event should NOT BE detected
        with self.assertMultiTraitChanges([test_object], [],
                ['flag', 'number', 'list_of_numbers[]']) as results:
            test_object.number = 2.0

        events = filter(bool, (result.event for result in results))
        msg = 'The assertion result is not None: {0}'.format(", ".join(events))
        self.assertFalse(events, msg=msg)

        # Change event should BE detected
        with self.assertMultiTraitChanges(
                [test_object], ['number', 'list_of_numbers[]'],
                ['flag']) as results:
            test_object.number = 5.0

        events = filter(bool, (result.event for result in results))
        msg = 'The assertion result is None'
        self.assertTrue(events, msg=msg)

    def test_when_using_functions(self):
        test_object = self.test_object

        # Change event should BE detected
        self.assertTraitChanges(test_object, 'number', 1,
                                test_object.add_to_number, 13.0)

        # Change event should NOT BE detected
        self.assertTraitDoesNotChange(test_object, 'flag',
                                      test_object.add_to_number, 13.0)

    def test_indirect_events(self):
        """ Check catching indirect change events.
        """
        test_object = self.test_object

        # Change event should BE detected
        with self.assertTraitChanges(test_object, 'list_of_numbers[]') as \
                result:
            test_object.flag = True
            test_object.number = -3.0

        expected = (test_object, 'list_of_numbers_items', [], [-3.0])
        self.assertSequenceEqual(expected, result.event)

    def test_exception_inside_context(self):
        """ Check that exception inside the context statement block are
        propagated.

        """
        test_object = self.test_object

        with self.assertRaises(AttributeError):
            with self.assertTraitChanges(test_object, 'number'):
                test_object.i_do_exist

        with self.assertRaises(AttributeError):
            with self.assertTraitDoesNotChange(test_object, 'number'):
                test_object.i_do_exist

    def test_non_change_on_failure(self):
        """ Check behaviour when assertion should be raised for non trait
        change.

        """
        test_object = self.test_object
        traits = 'flag, number'
        with self.assertRaises(AssertionError):
            with self.assertTraitDoesNotChange(test_object, traits) as result:
                test_object.flag = True
                test_object.number = -3.0
        expected = [(test_object, 'flag', False, True),
                    (test_object, 'number', 2.0, -3.0)]
        self.assertEqual(result.events, expected)

    def test_change_on_failure(self):
        """ Check behaviour when assertion should be raised for trait change.
        """
        test_object = self.test_object
        with self.assertRaises(AssertionError):
            with self.assertTraitChanges(test_object, 'number') as result:
                test_object.flag = True
        self.assertEqual(result.events, [])

        # Change event will not be fired 3 times
        with self.assertRaises(AssertionError):
            with self.assertTraitChanges(test_object, 'number', count=3) as \
                    result:
                test_object.flag = True
                test_object.add_to_number(10.0)
                test_object.add_to_number(10.0)

        expected = [(test_object, 'number', 2.0, 12.0),
                    (test_object, 'number', 12.0, 22.0)]
        self.assertSequenceEqual(expected, result.events)

    def test_asserts_in_context_block(self):
        """ Make sure that the traits context manager does not stop
        regular assertions inside the managed code block from happening.
        """
        test_object = TestObject(number=16.0)

        with self.assertTraitDoesNotChange(test_object, 'number'):
            self.assertEqual(test_object.number, 16.0)

        with self.assertRaisesRegexp(AssertionError, '16\.0 != 12\.0'):
            with self.assertTraitDoesNotChange(test_object, 'number'):
                self.assertEqual(test_object.number, 12.0)

    def test_special_case_for_count(self):
        """ Count equal to 0 should be valid but it is discouraged.
        """
        test_object = TestObject(number=16.0)

        with self.assertTraitChanges(test_object, 'number', count=0):
            test_object.flag = True

    def test_assert_trait_changes_async(self):
        # Exercise assertTraitChangesAsync.
        thread_count = 10
        events_per_thread = 1000

        class A(HasTraits):
            event = Event

        a = A()

        def thread_target(obj, count):
            "Fire obj.event 'count' times."
            for _ in xrange(count):
                obj.event = True

        threads = [
            threading.Thread(target=thread_target, args=(a, events_per_thread))
            for _ in xrange(thread_count)
        ]

        expected_count = thread_count * events_per_thread
        with self.assertTraitChangesAsync(
            a, 'event', expected_count, timeout=60.0):
            for t in threads:
                t.start()

        for t in threads:
            t.join()

    def test_assert_trait_changes_async_events(self):
        # Check access to the events after the with
        # block completes.
        thread_count = 10
        events_per_thread = 100

        class A(HasTraits):
            event = Event(Int)

        a = A()

        def thread_target(obj, count):
            "Fire obj.event 'count' times."
            for n in xrange(count):
                time.sleep(0.001)
                obj.event = n

        threads = [
            threading.Thread(target=thread_target, args=(a, events_per_thread))
            for _ in xrange(thread_count)
        ]

        expected_count = thread_count * events_per_thread
        with self.assertTraitChangesAsync(
            a, 'event', expected_count, timeout=60.0) as event_collector:
            for t in threads:
                t.start()

        for t in threads:
            t.join()

        _py2to3.assertCountEqual(
            self,
            event_collector.events,
            range(events_per_thread) * thread_count,
        )

    def test_assert_trait_changes_async_failure(self):
        # Exercise assertTraitChangesAsync.
        thread_count = 10
        events_per_thread = 10000

        class A(HasTraits):
            event = Event

        a = A()

        def thread_target(obj, count):
            "Fire obj.event 'count' times."
            for _ in xrange(count):
                obj.event = True

        threads = [
            threading.Thread(target=thread_target, args=(a, events_per_thread))
            for _ in xrange(thread_count)
        ]

        expected_count = thread_count * events_per_thread
        with self.assertRaises(AssertionError):
            with self.assertTraitChangesAsync(a, 'event', expected_count + 1):
                for t in threads:
                    t.start()

        for t in threads:
            t.join()

    def test_assert_eventually_true_fails_on_timeout(self):
        class A(HasTraits):
            foo = Bool(False)

        a = A()

        def condition(a_object):
            return a_object.foo

        with self.assertRaises(self.failureException):
            self.assertEventuallyTrue(
                condition=condition,
                obj=a,
                trait='foo',
                timeout=1.0,
            )

    def test_assert_eventually_true_passes_when_condition_becomes_true(self):
        class A(HasTraits):
            foo = Bool(False)

        def condition(a_object):
            return a_object.foo

        a = A()

        def thread_target(a):
            time.sleep(1.0)
            a.foo = True

        t = threading.Thread(target=thread_target, args=(a,))
        t.start()
        self.assertEventuallyTrue(
            condition=condition,
            obj=a,
            trait='foo',
            timeout=10.0,
        )
        t.join()

    def test_assert_eventually_true_passes_when_condition_starts_true(self):
        class A(HasTraits):
            foo = Bool(True)

        def condition(a_object):
            return a_object.foo

        a = A()
        self.assertEventuallyTrue(
            condition=condition,
            obj=a,
            trait='foo',
            timeout=10.0,
        )


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = unittest_tools
#------------------------------------------------------------------------------
# Copyright (c) 2005-2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#------------------------------------------------------------------------------
""" Trait assert mixin class to simplify test implementation for Trait
Classes.

"""

import contextlib
import threading

from traits.api import (Any, Event, HasStrictTraits, Instance, Int, List,
        Property, Str)
from traits.util.async_trait_wait import wait_for_condition

# Compatibility layer for Python 2.6: try loading unittest2
import sys
from traits import _py2to3
if sys.version_info[:2] == (2, 6):
    import unittest2 as unittest
else:
    import unittest


class _AssertTraitChangesContext(object):
    """ A context manager used to implement the trait change assert methods.

    Attributes
    ----------
    obj : HasTraits
        The HasTraits class instance who's class trait will change.

    xname : str
        The extended trait name of trait changes to listen to.

    count : int, optional
        The expected number of times the event should be fired. When None
        (default value) there is no check for the number of times the
        change event was fired.

    events : list of tuples
        A list with tuple elements containing the arguments of an
        `on_trait_change` event signature (<object>, <name>, <old>, <new>).

    Raises
    ------
    AssertionError :
          When the desired number of trait changed did not take place or when
          `count = None` and no trait change took place.

    """

    def __init__(self, obj, xname, count, test_case):
        """ Initialize the trait change assertion context manager.

        Parameters
        ----------
        obj : HasTraits
            The HasTraits class instance who's class trait will change.

        xname : str
            The extended trait name of trait changes to listen to.

        count : int, optional
            The expected number of times the event should be fired. When None
            (default value) there is no check for the number of times the
            change event was fired.

        test_case : TestCase
            A unittest TestCase where to raise the failureException if
            necessary.

        Notes
        -----
        - Checking if the provided xname corresponds to valid traits in
          the class is not implemented yet.

        """
        self.obj = obj
        self.xname = xname
        self.count = count
        self.event = None
        self.events = []
        self.failureException = test_case.failureException

    def _listener(self, obj, name, old, new):
        """ Dummy trait listener.
        """
        self.event = (obj, name, old, new)
        self.events.append(self.event)

    def __enter__(self):
        """ Bind the trait listener.
        """
        self.obj.on_trait_change(self._listener, self.xname)
        return self

    def __exit__(self, exc_type, exc_value, tb):
        """ Remove the trait listener.
        """
        if exc_type is not None:
            return False

        self.obj.on_trait_change(self._listener, self.xname, remove=True)
        if self.count is not None and len(self.events) != self.count:
            msg = 'Change event for {0} was fired {1} times instead of {2}'
            items = self.xname, len(self.events), self.count
            raise self.failureException(msg.format(*items))
        elif self.count is None and not self.events:
            msg = 'A change event was not fired for: {0}'.format(self.xname)
            raise self.failureException(msg)
        return False


@contextlib.contextmanager
def reverse_assertion(context, msg):
    context.__enter__()
    try:
        yield context
    finally:
        try:
            context.__exit__(None, None, None)
        except AssertionError:
            pass
        else:
            raise context.failureException(msg)


class _TraitsChangeCollector(HasStrictTraits):
    """ Class allowing thread-safe recording of events.
    """
    # The object we're listening to.
    obj = Any

    # The (possibly extended) trait name.
    trait = Str

    # Read-only event count.
    event_count = Property(Int)

    # Event that's triggered when the event count is updated.
    event_count_updated = Event

    # Private list of events.
    events = List(Any)

    # Lock used to allow access to events by multiple threads
    # simultaneously.
    _lock = Instance(threading.Lock, ())

    def start_collecting(self):
        self.obj.on_trait_change(
            self._event_handler,
            self.trait,
        )

    def stop_collecting(self):
        self.obj.on_trait_change(
            self._event_handler,
            self.trait,
            remove=True,
        )

    def _event_handler(self, new):
        with self._lock:
            self.events.append(new)
        self.event_count_updated = True

    def _get_event_count(self):
        """ Traits property getter.

        Thread-safe access to event count.

        """
        with self._lock:
            return len(self.events)


class UnittestTools(object):
    """ Mixin class to augment the unittest.TestCase class with useful trait
    related assert methods.

    """

    def assertTraitChanges(self, obj, trait, count=None, callableObj=None,
                           *args, **kwargs):
        """ Assert an object trait changes a given number of times.

        Assert that the class trait changes exactly `count` times during
        execution of the provided function.

        Method can also be used in a with statement to assert that the
        a class trait has changed during the execution of the code inside
        the with statement (similar to the assertRaises method). Please note
        that in that case the context manager returns itself and the user
        can introspect the information of:

        - The last event fired by accessing the ``event`` attribute of the
          returned object.

        - All the fired events by accessing the ``events`` attribute of
          the return object.

        **Example**::

            class MyClass(HasTraits):
                number = Float(2.0)

            my_class = MyClass()

            with self.assertTraitChangesExactly(my_class, 'number', count=1):
                my_class.number = 3.0

        Parameters
        ----------
        obj : HasTraits
            The HasTraits class instance whose class trait will change.

        trait : str
            The extended trait name of trait changes to listen to.

        count : int or None, optional
            The expected number of times the event should be fired. When None
            (default value) there is no check for the number of times the
            change event was fired.

        callableObj : callable, optional
            A callable object that will trigger the expected trait change.
            When None (default value) a trigger is expected to be called
            under the context manger returned by this method.

        *args :
            List of positional arguments for ``callableObj``

        **kwargs :
            Dict of keyword value pairs to be passed to the ``callableObj``


        Returns
        -------
        context : context manager or None
            If ``callableObj`` is None, an assertion context manager is returned,
            inside of which a trait-change trigger can be invoked. Otherwise,
            the context is used internally with ``callableObj`` as the trigger,
            in which case None is returned.


        Notes
        -----
        - Checking if the provided ``trait`` corresponds to valid traits in
          the class is not implemented yet.
        - Using the functional version of the assert method requires the
          ``count`` argument to be given even if it is None.

        """
        context = _AssertTraitChangesContext(obj, trait, count, self)
        if callableObj is None:
            return context
        with context:
            callableObj(*args, **kwargs)

    def assertTraitDoesNotChange(self, obj, trait, callableObj=None,
                                 *args, **kwargs):
        """ Assert an object trait does not change.

        Assert that the class trait does not change during
        execution of the provided function.

        Parameters
        ----------
        obj : HasTraits
            The HasTraits class instance whose class trait will change.

        trait : str
            The extended trait name of trait changes to listen to.

        callableObj : callable, optional
            A callable object that should not trigger a change in the
            passed trait.  When None (default value) a trigger is expected
            to be called under the context manger returned by this method.

        *args :
            List of positional arguments for ``callableObj``

        **kwargs :
            Dict of keyword value pairs to be passed to the ``callableObj``


        Returns
        -------
        context : context manager or None
            If ``callableObj`` is None, an assertion context manager is returned,
            inside of which a trait-change trigger can be invoked. Otherwise,
            the context is used internally with ``callableObj`` as the trigger,
            in which case None is returned.


        """
        msg = 'A change event was fired for: {0}'.format(trait)
        context = _AssertTraitChangesContext(obj, trait, None, self)
        if callableObj is None:
            return reverse_assertion(context, msg)
        with reverse_assertion(context, msg):
            callableObj(*args, **kwargs)
        return

    def assertMultiTraitChanges(self, objects, traits_modified,
            traits_not_modified):
        """ Assert that traits on multiple objects do or do not change.

        This combines some of the functionality of `assertTraitChanges` and
        `assertTraitDoesNotChange`.

        Parameters
        ----------
        objects : list of HasTraits
            The HasTraits class instances whose traits will change.

        traits_modified : list of str
            The extended trait names of trait expected to change.

        traits_not_modified : list of str
            The extended trait names of traits not expected to change.

        """
        args = []
        for obj in objects:
            for trait in traits_modified:
                args.append(self.assertTraitChanges(obj, trait))
            for trait in traits_not_modified:
                args.append(self.assertTraitDoesNotChange(obj, trait))
        return _py2to3.nested_context_mgrs(*args)
        

    @contextlib.contextmanager
    def assertTraitChangesAsync(self, obj, trait, count=1, timeout=5.0):
        """ Assert an object trait eventually changes.

        Context manager used to assert that the given trait changes at
        least `count` times within the given timeout, as a result of
        execution of the body of the corresponding with block.

        The trait changes are permitted to occur asynchronously.

        **Example usage**::

            with self.assertTraitChangesAsync(my_object, 'SomeEvent', count=4):
                <do stuff that should cause my_object.SomeEvent to be
                fired at least 4 times within the next 5 seconds>


        Parameters
        ----------
        obj : HasTraits
            The HasTraits class instance whose class trait will change.

        trait : str
            The extended trait name of trait changes to listen to.

        count : int, optional
            The expected number of times the event should be fired.

        timeout : float or None, optional
            The amount of time in seconds to wait for the specified number
            of changes. None can be used to indicate no timeout.

        """
        collector = _TraitsChangeCollector(obj=obj, trait=trait)

        # Pass control to body of the with statement.
        collector.start_collecting()
        try:
            yield collector

            # Wait for the expected number of events to arrive.
            try:
                wait_for_condition(
                    condition=lambda obj: obj.event_count >= count,
                    obj=collector,
                    trait='event_count_updated',
                    timeout=timeout,
                )
            except RuntimeError:
                actual_event_count = collector.event_count
                msg = ("Expected {0} event on {1} to be fired at least {2} "
                       "times, but the event was only fired {3} times "
                       "before timeout ({4} seconds).").format(
                    trait,
                    obj,
                    count,
                    actual_event_count,
                    timeout,
                )
                self.fail(msg)

        finally:
            collector.stop_collecting()

    def assertEventuallyTrue(self, obj, trait, condition, timeout=5.0):
        """ Assert that the given condition is eventually true.

        Parameters
        ----------
        obj : HasTraits
            The HasTraits class instance who's traits will change.

        trait : str
            The extended trait name of trait changes to listen to.

        condition : callable
            A function that will be called when the specified trait
            changes.  This should accept ``obj`` and should return a
            Boolean indicating whether the condition is satisfied or not.

        timeout : float or None, optional
            The amount of time in seconds to wait for the condition to
            become true.  None can be used to indicate no timeout.

        """
        try:
            wait_for_condition(
                condition=condition,
                obj=obj,
                trait=trait,
                timeout=timeout,
            )
        except RuntimeError:
            # Helpful to know whether we timed out because the
            # condition never became true, or because the expected
            # event was never issued.
            condition_at_timeout = condition(obj)
            self.fail(
                "Timed out waiting for condition. "
                "At timeout, condition was {0}.".format(condition_at_timeout))

########NEW FILE########
__FILENAME__ = check_timing
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Date: 03/03/2003
# Description: Perform timing tests on various trait styles to determine the
#              amount of overhead that traits add.

from __future__ import absolute_import

from time import time
from ..api import Any, DelegatesTo, HasTraits, Int, Range

# Number of iterations to perform:
n = 1000000

# Loop overhead time (actual value determined first time a measurement is made)
t0 = -1.0


#  Measure how long it takes to execute a specified function:
def measure(func):
    now = time()
    func()
    return time() - now


#  'Old style' Python attribute get/set:
class old_style_value:

    def measure(self, reference_get=1.0, reference_set=1.0):
        global t0
        self.init()

        if t0 < 0.0:
            t0 = measure(self.null)
        t1 = measure(self.do_get)
        t2 = measure(self.do_set)

        scale = 1.0e6 / n
        get_time = max(t1 - t0, 0.0) * scale
        set_time = max(t2 - t0, 0.0) * scale

        return get_time, set_time

    def null(self):
        for i in range(n):
            pass

    def init(self):
        self.value = -1

    def do_set(self):
        for i in range(n):
            self.value = i

    def do_get(self):
        for i in range(n):
            self.value


#  'New style' Python attribute get/set:
class new_style_value(object):

    def measure(self):
        global t0
        self.init()

        if t0 < 0.0:
            t0 = measure(self.null)
        t1 = measure(self.do_get)
        t2 = measure(self.do_set)

        scale = 1.0e6 / n
        get_time = max(t1 - t0, 0.0) * scale
        set_time = max(t2 - t0, 0.0) * scale

        return get_time, set_time

    def null(self):
        for i in range(n):
            pass

    def init(self):
        self.value = -1

    def do_set(self):
        for i in range(n):
            self.value = i

    def do_get(self):
        for i in range(n):
            self.value


#  Python 'property' get/set:
class property_value(new_style_value):

    def get_value(self):
        return self._value

    def set_value(self, value):
        self._value = value

    value = property(get_value, set_value)


#  Python 'global' get/set:
class global_value(new_style_value):

    def init(self):
        global gvalue
        gvalue = -1

    def do_set(self):
        global gvalue
        for i in range(n):
            gvalue = i

    def do_get(self):
        global gvalue
        for i in range(n):
            gvalue


#  Trait that can have any value:
class any_value(HasTraits, new_style_value):

    value = Any


#  Trait that can only have 'float' values:
class int_value(any_value):

    value = Int


#  Trait that can only have 'range' values:
class range_value(any_value):

    value = Range(-1, 2000000000)


#  Executes method when float trait is changed:
class change_value(int_value):

    def _value_changed(self, old, new):
        pass


#  Notifies handler when float trait is changed:
class monitor_value(int_value):

    def init(self):
        self.on_trait_change(self.on_value_change, 'value')

    def on_value_change(self, object, trait_name, old, new):
        pass


#  Float trait is delegated to another object:
class delegate_value(HasTraits, new_style_value):

    value = DelegatesTo('delegate')
    delegate = Any

    def init(self):
        self.delegate = int_value()


#  Float trait is delegated through one object to another object:
class delegate_2_value(delegate_value):

    def init(self):
        delegate = delegate_value()
        delegate.init()
        self.delegate = delegate


#  Float trait is delegated through two objects to another object:
class delegate_3_value(delegate_value):

    def init(self):
        delegate = delegate_2_value()
        delegate.init()
        self.delegate = delegate


#  Run the timing measurements:
def report(name, get_time, set_time, ref_get_time, ref_set_time):
    """ Return string containing a benchmark report.

    The arguments are the name of the benchmark case, the times to do a 'get'
    or a 'set' operation for that benchmark case in usec, and the
    corresponding times for a reference operation (e.g., getting and
    setting an attribute on a new-style instance.
    """

    template = (
        '{name:^30}: Get {get_time:02.3f} us (x {get_speed_up:02.3f}), '
        'Set {set_time:02.3f} us (x {set_speed_up:02.3f})'
        )

    report = template.format(
        name=name,
        get_time=get_time,
        get_speed_up=ref_get_time / get_time,
        set_time=set_time,
        set_speed_up=ref_set_time / set_time,
        )

    return report


def run_benchmark(klass, ref_get_time, ref_set_time):
    benchmark_name = klass.__name__
    get_time, set_time = klass().measure()
    print report(benchmark_name,
                 get_time, set_time,
                 ref_get_time, ref_set_time)


def main():
    ref_get_time, ref_set_time = new_style_value().measure()

    benchmarks = [
        global_value,
        old_style_value,
        new_style_value,
        property_value,
        any_value,
        int_value,
        range_value,
        change_value,
        monitor_value,
        delegate_value,
        delegate_2_value,
        delegate_3_value
    ]

    for benchmark in benchmarks:
        run_benchmark(benchmark, ref_get_time, ref_set_time)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_abc
""" Test the ABC functionality.
"""
import abc
import warnings

from traits.testing.unittest_tools import unittest

from ..api import ABCHasTraits, ABCMetaHasTraits, HasTraits, Int, Float


class TestNew(unittest.TestCase):
    """ Test that __new__ works correctly.
    """

    def setUp(self):
        self.old_filters = warnings.filters[:]
        warnings.simplefilter('error', DeprecationWarning)

    def tearDown(self):
        warnings.filters[:] = self.old_filters

    def test_new(self):
        # Should not raise DeprecationWarning.
        HasTraits(x=10)


class AbstractFoo(ABCHasTraits):
    x = Int(10)
    y = Float(20.0)

    @abc.abstractmethod
    def foo(self):
        raise NotImplementedError()

    @abc.abstractproperty
    def bar(self):
        raise NotImplementedError()


class ConcreteFoo(AbstractFoo):
    def foo(self):
        return 'foo'

    @property
    def bar(self):
        return 'bar'


class FooLike(HasTraits):
    x = Int(10)
    y = Float(20.0)

    def foo(self):
        return 'foo'

    @property
    def bar(self):
        return 'bar'


AbstractFoo.register(FooLike)


class AbstractBar(object):
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def bar(self):
        raise NotImplementedError()


class TestABC(unittest.TestCase):
    def test_basic_abc(self):
        self.assertRaises(TypeError, AbstractFoo)
        concrete = ConcreteFoo()
        self.assertEqual(concrete.foo(), 'foo')
        self.assertEqual(concrete.bar, 'bar')
        self.assertEqual(concrete.x, 10)
        self.assertEqual(concrete.y, 20.0)
        self.assertTrue(isinstance(concrete, AbstractFoo))

    def test_registered(self):
        foolike = FooLike()
        self.assertTrue(isinstance(foolike, AbstractFoo))

    def test_post_hoc_mixing(self):
        class TraitedBar(HasTraits, AbstractBar):
            __metaclass__ = ABCMetaHasTraits
            x = Int(10)

            def bar(self):
                return 'bar'

        traited = TraitedBar()
        self.assertTrue(isinstance(traited, AbstractBar))
        self.assertEqual(traited.x, 10)

########NEW FILE########
__FILENAME__ = test_anytrait_static_notifiers
""" Tests for the the "anytrait" static notifiers. """
from traits.api import Float, HasTraits, Undefined
from traits.testing.unittest_tools import unittest

from traits import trait_notifiers

anycalls_0 = []


class AnytraitStaticNotifiers0(HasTraits):
    ok = Float

    def _anytrait_changed():
        anycalls_0.append(True)


class AnytraitStaticNotifiers0Fail(HasTraits):
    fail = Float

    def _anytrait_changed():
        raise Exception('error')


class AnytraitStaticNotifiers1(HasTraits):
    ok = Float

    def _anytrait_changed(self):
        if not hasattr(self, 'anycalls'):
            self.anycalls = []
        self.anycalls.append(True)


class AnytraitStaticNotifiers1Fail(HasTraits):
    fail = Float

    def _anytrait_changed(self):
        raise Exception('error')


class AnytraitStaticNotifiers2(HasTraits):
    ok = Float

    def _anytrait_changed(self, name):
        if not hasattr(self, 'anycalls'):
            self.anycalls = []
        self.anycalls.append(name)


class AnytraitStaticNotifiers2Fail(HasTraits):
    fail = Float

    def _anytrait_changed(self, name):
        raise Exception('error')


class AnytraitStaticNotifiers3(HasTraits):
    ok = Float

    def _anytrait_changed(self, name, new):
        if not hasattr(self, 'anycalls'):
            self.anycalls = []
        self.anycalls.append((name, new))


class AnytraitStaticNotifiers3Fail(HasTraits):
    fail = Float

    def _anytrait_changed(self, name, new):
        raise Exception('error')


class AnytraitStaticNotifiers4(HasTraits):
    ok = Float

    def _anytrait_changed(self, name, old, new):
        if not hasattr(self, 'anycalls'):
            self.anycalls = []
        self.anycalls.append((name, old, new))


class AnytraitStaticNotifiers4Fail(HasTraits):
    fail = Float

    def _anytrait_changed(self, name, old, new):
        raise Exception('error')


class TestNotifiers(unittest.TestCase):
    """ Tests for the static notifiers, and the "anytrait" static notifiers.
    """

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        self.exceptions = []
        trait_notifiers.push_exception_handler(self._handle_exception)

    def tearDown(self):
        trait_notifiers.pop_exception_handler()

    #### Private protocol #####################################################

    def _handle_exception(self, obj, name, old, new):
        self.exceptions.append((obj, name, old, new))

    #### Tests ################################################################

    def test_anytrait_static_notifiers_0(self):
        obj = AnytraitStaticNotifiers0(ok=2)
        obj.ok = 3

        self.assertEqual(len(anycalls_0), 2)

    def test_anytrait_static_notifiers_1(self):
        obj = AnytraitStaticNotifiers1(ok=2)
        obj.ok = 3

        # 3 calls (see test_anytrait_static_notifiers_4):
        # 1 to add trait 'anycalls',
        # 1 from the constructor,
        # 1 to set ok to 3
        self.assertEqual(len(obj.anycalls), 3)

    def test_anytrait_static_notifiers_2(self):
        obj = AnytraitStaticNotifiers2(ok=2)
        obj.ok = 3

        expected = ['trait_added', 'ok', 'ok']
        self.assertEqual(expected, obj.anycalls)

    def test_anytrait_static_notifiers_3(self):
        obj = AnytraitStaticNotifiers3(ok=2)
        obj.ok = 3

        expected = [('trait_added', 'anycalls'),
                    ('ok', 2),
                    ('ok', 3)]
        self.assertEqual(expected, obj.anycalls)

    def test_anytrait_static_notifiers_4(self):
        obj = AnytraitStaticNotifiers4(ok=2)
        obj.ok = 3

        expected = [('trait_added', Undefined, 'anycalls'),
                    ('ok', 0, 2),
                    ('ok', 2, 3)]
        self.assertEqual(expected, obj.anycalls)

    def test_anytrait_static_notifiers_0_fail(self):
        obj = AnytraitStaticNotifiers0Fail()
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_anytrait_static_notifiers_1_fail(self):
        obj = AnytraitStaticNotifiers1Fail()
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_anytrait_static_notifiers_2_fail(self):
        obj = AnytraitStaticNotifiers2Fail()
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_anytrait_static_notifiers_3_fail(self):
        obj = AnytraitStaticNotifiers3Fail()
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_anytrait_static_notifiers_4_fail(self):
        obj = AnytraitStaticNotifiers4Fail()
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_array
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

try:
    import numpy
except ImportError:
    numpy_available = False
else:
    numpy_available = True

from ..api import Array, Bool, HasTraits


if numpy_available:
    # Use of `Array` requires NumPy to be installed.

    class Foo(HasTraits):
        a = Array()
        event_fired = Bool(False)

        def _a_changed(self):
            self.event_fired = True


class ArrayTestCase(unittest.TestCase):
    """ Test cases for delegated traits. """

    @unittest.skipUnless(numpy_available, "numpy not available")
    def test_zero_to_one_element(self):
        """ Test that an event fires when an Array trait changes from zero to
        one element.
        """

        f = Foo()
        f.a = numpy.zeros((2,), float)
        f.event_fired = False

        # Change the array.
        f.a = numpy.concatenate((f.a, numpy.array([100])))

        # Confirm that the static trait handler was invoked.
        self.assertEqual(f.event_fired, True)

        return

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_automatic_adaptation
###############################################################################
# Copyright 2014 Enthought, Inc.
###############################################################################

from traits.adaptation.api import reset_global_adaptation_manager
from traits.api import HasTraits, Instance, List, register_factory, TraitError
from traits.testing.unittest_tools import unittest


class Foo(HasTraits):
    pass


class Bar(HasTraits):
    pass


def bar_to_foo_adapter(bar):
    return Foo()


class FooContainer(HasTraits):
    not_adapting_foo = Instance(Foo)
    adapting_foo = Instance(Foo, adapt='yes')

    not_adapting_foo_list = List(Foo)
    adapting_foo_list = List(Instance(Foo, adapt='yes'))


class TestAutomaticAdaptation(unittest.TestCase):

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        reset_global_adaptation_manager()

    #### Tests ################################################################

    def test_instance_trait_automatic_adaptation(self):
        bar = Bar()
        foo_container = FooContainer()

        # Before a Bar->Foo adapter is registered.
        with self.assertRaises(TraitError):
            foo_container.not_adapting_foo = bar

        with self.assertRaises(TraitError):
            foo_container.adapting_foo = bar

        # After a Bar->Foo adapter is registered.
        register_factory(bar_to_foo_adapter, Bar, Foo)

        with self.assertRaises(TraitError):
            foo_container.not_adapting_foo = bar

        foo_container.adapting_foo = bar
        self.assertIsInstance(foo_container.adapting_foo, Foo)

    def test_list_trait_automatic_adaptation(self):
        bar = Bar()
        foo_container = FooContainer()

        # Before a Bar->Foo adapter is registered.
        with self.assertRaises(TraitError):
            foo_container.not_adapting_foo_list = [bar]

        with self.assertRaises(TraitError):
            foo_container.adapting_foo_list = [bar]

        # After a Bar->Foo adapter is registered.
        register_factory(bar_to_foo_adapter, Bar, Foo)

        with self.assertRaises(TraitError):
            foo_container.not_adapting_foo_list = [bar]

        foo_container.adapting_foo_list = [bar]
        self.assertIsInstance(foo_container.adapting_foo_list[0], Foo)

########NEW FILE########
__FILENAME__ = test_category
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Description: <Traits component>
#------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Category, Str


class Base(HasTraits):
    y = Str("Base y")
    z = Str("Base z")


class BaseExtra(Category, Base):
    x = Str("BaseExtra x")


class BasePlus(Category, Base):
    p = Str("BasePlus p")
#   z = Str("BasePlus z")    overrides not allowed.


class BasePlusPlus(BasePlus):
    pp = Str("BasePlusPlus pp")


class CategoryTestCase(unittest.TestCase):
    """ Test cases for traits category """

    def setUp(self):
        self.base = Base()
        return

    def test_base_category(self):
        """ Base class with traits """
        self.assertEqual(self.base.y, "Base y", msg="y != 'Base y'")
        self.assertEqual(self.base.z, "Base z", msg="z != 'Base z'")
        return

    def test_extra_extension_category(self):
        """ Base class extended with a category subclass """
        self.assertEqual(self.base.x, "BaseExtra x", msg="x != 'BaseExtra x'")
        return

    def test_plus_extension_category(self):
        """ Base class extended with two category subclasses """
        self.assertEqual(self.base.x, "BaseExtra x", msg="x != 'BaseExtra x'")
        self.assertEqual(self.base.p, "BasePlus p", msg="p != 'BasePlus p'")
        return

    def test_subclass_extension_category(self):
        """ Category subclass does not extend base class.
        This test demonstrates that traits allows subclassing of a category
        class, but that the traits from the subclass are not actually added
        to the base class of the Category.
        Seems like the declaration of the subclass (BasePlusPlus) should fail.
        """
        try:
            x = self.base.pp
            self.fail(msg="base.pp should have thrown AttributeError "
                          "as Category subclassing is not supported.")
        except AttributeError:
            pass

        basepp = BasePlusPlus()
        return

    def test_subclass_instance_category(self):
        """ Category subclass instantiation not supported.
        This test demonstrates that traits allows subclassing of a category
        class, that subclass can be instantiated, but the traits of the parent
        class are not inherited.
        Seems like the declaration of the subclass (BasePlusPlus) should fail.
        """
        bpp = BasePlusPlus()
        self.assertEqual(bpp.pp, "BasePlusPlus pp",
                         msg="pp != 'BasePlusPlus pp'")

        try:
            self.assertEqual(bpp.p, "BasePlus p", msg="p != 'BasePlus p'")
            self.fail(msg="bpp.p should have thrown SystemError as "
                          "instantiating a subclass of a category is not "
                          "supported.")
        except SystemError:
            pass
        return

#
# support running this test individually, from the command-line as a script
#
if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_class_traits
"""
Unit tests for the `HasTraits.class_traits` class function.

"""

from __future__ import absolute_import

from traits import _py2to3

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Int, List, Str


class A(HasTraits):

    x = Int

    name = Str(marked=True)


class B(A):

    pass


class C(B):

    lst = List(marked=False)

    y = Int(marked=True)


class TestClassTraits(unittest.TestCase):

    def test_all_class_traits(self):
        expected = ['x', 'name', 'trait_added', 'trait_modified']
        _py2to3.assertCountEqual(self, A.class_traits(), expected)

        # Check that derived classes report the correct traits.
        _py2to3.assertCountEqual(self, B.class_traits(), expected)

        expected.extend(('lst', 'y'))
        _py2to3.assertCountEqual(self, C.class_traits(), expected)

    def test_class_traits_with_metadata(self):

        # Retrieve all traits that have the `marked` metadata
        # attribute set to True.
        traits = C.class_traits(marked=True)
        _py2to3.assertCountEqual(self, traits.keys(), ('y', 'name'))

        # Retrieve all traits that have a `marked` metadata attribute,
        # regardless of its value.
        marked_traits = C.class_traits(marked=lambda attr: attr is not None)
        _py2to3.assertCountEqual(self, marked_traits, ('y', 'name', 'lst'))

########NEW FILE########
__FILENAME__ = test_clone
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Description: <Traits component>

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Instance, Str, Any, Property


class Foo(HasTraits):
    s = Str


class ClassWithAny(HasTraits):
    x = Property
    _x = Any

    def _get_x(self):
        return self._x

    def _set_x(self, x):
        self._x = x


class ClassWithInstance(HasTraits):
    x = Property
    _x = Instance(Foo)

    def _get_x(self):
        return self._x

    def _set_x(self, x):
        self._x = x


class ClassWithClassAttribute(HasTraits):
    name = 'class defined name'
    foo = Str


class BazAny(HasTraits):
    other = Any


class BarAny(HasTraits):
    other = Any


class BazInstance(HasTraits):
    # A BarInstance owned by this object.
    other = Instance('BarInstance')

    # A Foo owned by this object and not referenced by others.
    unique = Instance(Foo)

    # A Foo owned by this object and referenced by others.
    shared = Instance(Foo)

    # A Foo not owned by this object, may or may not be shared with other
    # objects found via owned references (e.g. other.ref). For the tests,
    # ref will always reference a Foo that is not owned by any of the objects
    # reachable via owned references, and therefore, that Foo object should
    # not be cloned.
    ref = Instance(Foo, copy='ref')


class BarInstance(HasTraits):
    # used as circular reference back to owning BazInstance
    # NOTE: Setting copy to  'ref' will mean that when BarInstance is cloned,
    # the 'other' trait will not be copied, and will still point to the
    # 'other' attribute of the original BarInstance.
    other = Instance('BazInstance', copy='ref')

    # A Foo owned by this object and not referenced by others.
    unique = Instance(Foo)

    # A Foo owned by the 'other' object and referenced by this object.
    shared = Instance(Foo)

    # A Foo not owned by this object, may or may not be shared with other
    # objects found via owned references (e.g. other.ref). For the tests,
    # ref will always reference a Foo that is not owned by any of the objects
    # reachable via owned references, and therefore, that Foo object should
    # not be cloned.
    ref = Instance(Foo, copy='ref')


class CloneTestCase(unittest.TestCase):
    """ Test cases for traits clone """

    def test_any(self):
        b = ClassWithAny()

        f = Foo()
        f.s = 'the f'

        b.x = f

        bc = b.clone_traits(traits='all', copy='deep')
        self.assertNotEqual(id(bc.x), id(f), 'Foo x not cloned')

        return

    def test_instance(self):
        b = ClassWithInstance()

        f = Foo()
        f.s = 'the f'

        b.x = f

        bc = b.clone_traits(traits='all', copy='deep')
        self.assertNotEqual(id(bc.x), id(f), 'Foo x not cloned')

        return

    def test_class_attribute_missing(self):
        """ This test demonstrates a problem with Traits objects with class
        attributes.  A change to the value of a class attribute via one
        instance causes the attribute to be removed from other instances.

        AttributeError: 'ClassWithClassAttribute' object has no attribute
        'name'
        """

        s = 'class defined name'

        c = ClassWithClassAttribute()

        self.assertEqual(s, c.name)

        c2 = ClassWithClassAttribute()
        self.assertEqual(s, c.name)
        self.assertEqual(s, c2.name)

        s2 = 'name class attribute changed via clone'
        c2.name = s2
        self.assertEqual(s2, c2.name)

        # this is failing with AttributeError: 'ClassWithClassAttribute'
        # object has no attribute 'name'
        self.assertEqual(s, c.name)

        return

    def test_Any_circular_references(self):

        # Demonstrates that Any traits default to copy='ref'
        bar = BarAny()

        baz = BazAny()

        bar.other = baz
        baz.other = bar

        bar_copy = bar.clone_traits()

        self.assertIsNot(bar_copy, bar)
        self.assertIs(bar_copy.other, baz)
        self.assertIs(bar_copy.other.other, bar)

    def test_Any_circular_references_deep(self):

        # Demonstrates that Any traits can be forced to deep copy.
        bar = BarAny()
        baz = BazAny()
        bar.other = baz
        baz.other = bar

        bar_copy = bar.clone_traits(copy='deep')

        self.assertIsNot(bar_copy, bar)
        self.assertIsNot(bar_copy.other, baz)
        self.assertIsNot(bar_copy.other.other, bar)
        self.assertIs(bar_copy.other.other, bar_copy)

    def test_Instance_circular_references(self):

        ref = Foo(s='ref')
        bar_unique = Foo(s='bar.foo')
        shared = Foo(s='shared')
        baz_unique = Foo(s='baz.unique')

        baz = BazInstance()
        baz.unique = baz_unique
        baz.shared = shared
        baz.ref = ref

        bar = BarInstance()
        bar.unique = bar_unique
        bar.shared = shared
        bar.ref = ref

        bar.other = baz
        baz.other = bar

        baz_copy = baz.clone_traits()

        # Check Baz and Baz attributes....
        self.assertIsNot(baz_copy, baz)
        self.assertIsNot(baz_copy.other, bar)
        self.assertIsNot(baz_copy.unique, baz.unique)
        self.assertIsNot(baz_copy.shared, baz.shared)
        self.assertIs(baz_copy.ref, ref)

        # Check Bar and Bar attributes....
        bar_copy = baz_copy.other

        # Check the Bar owned object
        self.assertIsNot(bar_copy.unique, bar.unique)

        # Check the Bar reference to an object 'outside' the cloned graph.
        self.assertIs(bar_copy.ref, ref)

        # Check references to objects that where cloned, they should reference
        # the new clones not the original objects, except when copy is set
        # to 'ref' (as in the case of the 'other' trait).
        # When copy is set to ref, the trait does not get cloned. Therefore,
        # baz_copy.other.other is baz (and not baz_copy).
        self.assertIsNot(bar_copy.other, baz_copy)
        self.assertIs(bar_copy.other, baz)

        # 'shared' does not have copy set to 'ref', and so bar_copy.shared
        # should reference the new clone.
        # should reference the new clones
        self.assertIsNot(bar_copy.shared, baz.shared)
        self.assertIs(bar_copy.shared, baz_copy.shared)

    def test_Instance_circular_references_deep(self):

        ref = Foo(s='ref')
        bar_unique = Foo(s='bar.foo')
        shared = Foo(s='shared')
        baz_unique = Foo(s='baz.unique')

        baz = BazInstance()
        baz.unique = baz_unique
        baz.shared = shared
        baz.ref = ref

        bar = BarInstance()
        bar.unique = bar_unique
        bar.shared = shared
        bar.ref = ref

        bar.other = baz
        baz.other = bar

        baz_copy = baz.clone_traits(copy='deep')

        # Check Baz and Baz attributes....
        self.assertIsNot(baz_copy, baz)
        self.assertIsNot(baz_copy.other, bar)
        self.assertIsNot(baz_copy.unique, baz.unique)
        self.assertIsNot(baz_copy.shared, baz.shared)
        # baz_copy.ref is checked below with bar_copy.ref.

        # Check Bar and Bar attributes....
        bar_copy = baz_copy.other

        # Check the Bar owned object
        self.assertIsNot(bar_copy.unique, bar.unique)

        # Since the two original 'ref' links were to a shared object,
        # the cloned links should be to a shared object. Also, the shared
        # object should be the original 'ref' object, since copy was set to
        # 'ref'.
        self.assertIs(baz_copy.ref, bar_copy.ref)
        self.assertIs(bar_copy.ref,ref)

        # Check references to objects that where cloned, they should reference
        # the new clones not the original objects, except when copy is set
        # to 'ref' (as in the case of the 'other' trait). That is, the 'deep'
        # flag on clone_traits should not override the 'copy' metadata on
        # the trait.
        self.assertIsNot(bar_copy.other, baz_copy)
        self.assertIs(bar_copy.other, baz)

        # 'shared' does not have copy set to 'ref', and so bar_copy.shared
        # should reference the new clone.
        self.assertIsNot(bar_copy.shared, baz.shared)
        self.assertIs(bar_copy.shared, baz_copy.shared)

#
# support running this test individually, from the command-line as a script
#
if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_container_events
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

"""
Tests for Dict items_changed events
"""

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Dict


class MyClass(HasTraits):
    """ A dummy HasTraits class with a Dict """
    d = Dict({"a": "apple", "b": "banana", "c": "cherry", "d": "durian"})

    def __init__(self, callback):
        "The callback is called with the TraitDictEvent instance"
        self.callback = callback
        return

    def _d_items_changed(self, event):
        if self.callback:
            self.callback(event)
        return


class MyOtherClass(HasTraits):
    """ A dummy HasTraits class with a Dict """
    d = Dict({"a": "apple", "b": "banana", "c": "cherry", "d": "durian"})


class Callback:
    """
    A stateful callback that gets initialized with the values to check for
    """
    def __init__(self, obj, added={}, changed={}, removed={}):
        self.obj = obj
        self.added = added
        self.changed = changed
        self.removed = removed
        self.called = False
        return

    def __call__(self, event):
        if event.added != self.added:
            print "\n\n******Error\nevent.added:", event.added
        else:
            self.obj.assertEqual(event.added, self.added)
        self.obj.assertEqual(event.changed, self.changed)
        self.obj.assertEqual(event.removed, self.removed)
        self.called = True
        return


class DictEventTestCase(unittest.TestCase):

    def test_setitem(self):
        # overwriting an existing item
        cb = Callback(self, changed={"c": "cherry"})
        foo = MyClass(cb)
        foo.d["c"] = "coconut"
        self.assertTrue(cb.called)
        # adding a new item
        cb = Callback(self, added={"g": "guava"})
        bar = MyClass(cb)
        bar.d["g"] = "guava"
        self.assertTrue(cb.called)
        return

    def test_delitem(self):
        cb = Callback(self, removed={"b": "banana"})
        foo = MyClass(cb)
        del foo.d["b"]
        self.assertTrue(cb.called)
        return

    def test_clear(self):
        removed = MyClass(None).d.copy()
        cb = Callback(self, removed=removed)
        foo = MyClass(cb)
        foo.d.clear()
        self.assertTrue(cb.called)
        return

    def test_update(self):
        update_dict = {"a": "artichoke", "f": "fig"}
        cb = Callback(self, changed={"a": "apple"}, added={"f": "fig"})
        foo = MyClass(cb)
        foo.d.update(update_dict)
        self.assertTrue(cb.called)
        return

    def test_setdefault(self):
        # Test retrieving an existing value
        cb = Callback(self)
        foo = MyClass(cb)
        self.assertEqual(foo.d.setdefault("a", "dummy"), "apple")
        self.assertFalse(cb.called)

        # Test adding a new value
        cb = Callback(self, added={"f": "fig"})
        bar = MyClass(cb)
        self.assertTrue(bar.d.setdefault("f", "fig") == "fig")
        self.assertTrue(cb.called)
        return

    def test_pop(self):
        # Test popping a non-existent key
        cb = Callback(self)
        foo = MyClass(cb)
        self.assertEqual(foo.d.pop("x", "dummy"), "dummy")
        self.assertFalse(cb.called)

        # Test popping a regular item
        cb = Callback(self, removed={"c": "cherry"})
        bar = MyClass(cb)
        self.assertEqual(bar.d.pop("c"), "cherry")
        self.assertTrue(cb.called)
        return

    def test_popitem(self):
        foo = MyClass(None)
        foo.d.clear()
        foo.d["x"] = "xylophone"
        cb = Callback(self, removed={"x": "xylophone"})
        foo.callback = cb
        self.assertEqual(foo.d.popitem(), ("x", "xylophone"))
        self.assertTrue(cb.called)
        return

    def test_dynamic_listener(self):
        foo = MyOtherClass()
        # Test adding
        func = Callback(self, added={"g": "guava"})
        foo.on_trait_change(func.__call__, "d_items")
        foo.d["g"] = "guava"
        foo.on_trait_change(func.__call__, "d_items", remove=True)
        self.assertTrue(func.called)

        # Test removing
        func2 = Callback(self, removed={"a": "apple"})
        foo.on_trait_change(func2.__call__, "d_items")
        del foo.d["a"]
        foo.on_trait_change(func2.__call__, "d_items", remove=True)
        self.assertTrue(func2.called)

        # Test changing
        func3 = Callback(self, changed={"b": "banana"})
        foo.on_trait_change(func3.__call__, "d_items")
        foo.d["b"] = "broccoli"
        foo.on_trait_change(func3.__call__, "d_items", remove=True)
        self.assertTrue(func3.called)
        return

########NEW FILE########
__FILENAME__ = test_copyable_trait_names
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import (HasTraits, Any, Bool, Delegate, Event, Instance, Property,
                   Str)


class Foo(HasTraits):

    a = Any
    b = Bool
    s = Str
    i = Instance(HasTraits)
    e = Event
    d = Delegate('i')

    p = Property

    def _get_p(self):
        return self._p

    def _set_p(self, p):
        self._p = p

    # Read Only Property
    p_ro = Property

    def _get_p_ro(self):
        return id(self)

    # Write-only property
    p_wo = Property

    def _set_p_wo(self, p_wo):
        self._p_wo = p_wo


class TestCopyableTraitNames(unittest.TestCase):
    """ Validate that copyable_trait_names returns the appropriate result.
    """

    def setUp(self):
        foo = Foo()
        self.names = foo.copyable_trait_names()

    def test_events_not_copyable(self):
        self.assertNotIn('e', self.names)

    def test_read_only_property_not_copyable(self):
        self.assertNotIn('p_ro', self.names)

    def test_write_only_property_not_copyable(self):
        self.assertNotIn('p_wo', self.names)

    def test_any_copyable(self):
        self.assertIn('a', self.names)

    def test_bool_copyable(self):
        self.assertIn('b', self.names)

    def test_str_copyable(self):
        self.assertIn('s', self.names)

    def test_instance_copyable(self):
        self.assertIn('i', self.names)

    def test_delegate_copyable(self):
        self.assertIn('d', self.names)

    def test_property_copyable(self):
        self.assertIn('p', self.names)


class TestCopyableTraitNameQueries(unittest.TestCase):

    def setUp(self):
        self.foo = Foo()

    def test_type_query(self):
        names = self.foo.copyable_trait_names(**{
            'type': 'trait'
        })

        self.assertEqual(['a', 'b', 'i', 's'], sorted(names))

        names = self.foo.copyable_trait_names(**{
            'type': lambda t: t in ('trait', 'property',)
        })

        self.assertEqual(['a', 'b', 'i', 'p', 's'], sorted(names))

    def test_property_query(self):
        names = self.foo.copyable_trait_names(**{
            'property': lambda p: p() and p()[1].__name__ == '_set_p',
        })

        self.assertEqual(['p'], names)

    def test_unmodified_query(self):
        names = self.foo.copyable_trait_names(**{
            'is_trait_type': lambda f: f(Str)
        })

        self.assertEqual(['s'], names)

    def test_queries_not_combined(self):
        """ Verify that metadata is not merged with metadata to find the
            copyable traits.
        """

        eval_true = lambda x: True

        names = self.foo.copyable_trait_names(property=eval_true,
                                              type=eval_true,
                                              transient=eval_true)

        self.assertEqual(['a', 'b', 'd', 'e', 'i', 'p',
                           'p_ro', 'p_wo', 's',
                           'trait_added',
                           'trait_modified'
                           ], sorted(names))

### EOF

########NEW FILE########
__FILENAME__ = test_copy_traits
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Instance, Str


class Shared(HasTraits):
    s = Str('new instance of Shared')


class Foo(HasTraits):
    s = Str('new instance of Foo')
    shared = Instance(Shared)


class Bar(HasTraits):
    s = Str('new instance of Bar')
    foo = Instance(Foo)
    shared = Instance(Shared)


class Baz(HasTraits):
    s = Str('new instance of Baz')
    bar = Instance(Bar)
    shared = Instance(Shared)


class CopyTraitsBase(unittest.TestCase):
    """ Validate that copy_traits
    """
    __test__ = False

    def setUp(self):
        print '\n**CopyTraitsBase.setUp ',
        super(CopyTraitsBase, self).setUp()
        self.shared = Shared(s='shared')
        self.foo = Foo(shared=self.shared, s='foo')
        self.bar = Bar(shared=self.shared, foo=self.foo, s='bar')
        self.baz = Baz(shared=self.shared, bar=self.bar, s='baz')

        self.shared2 = Shared(s='shared2')
        self.foo2 = Foo(shared=self.shared2, s='foo2')
        self.bar2 = Bar(shared=self.shared2, foo=self.foo2, s='bar2')
        self.baz2 = Baz(shared=self.shared2, bar=self.bar2, s='baz2')

        return

    def print_copy(self):
        print '\nfoo.copy:', self.foo.base_trait('shared').copy
        print 'bar.copy:', self.bar.base_trait('shared').copy
        print 'baz.copy:', self.baz.base_trait('shared').copy
        print 'foo2.copy:', self.foo2.base_trait('shared').copy
        print 'bar2.copy:', self.bar2.base_trait('shared').copy
        print 'baz2.copy:', self.baz2.base_trait('shared').copy

    def set_shared_copy(self, value):
        """ Change the copy style for the 'shared' traits. """
        #self.print_copy()
        self.foo.base_trait('shared').copy = value
        self.bar.base_trait('shared').copy = value
        self.baz.base_trait('shared').copy = value

        # copy is metadata and therefore a shared  a class attribute
        # self.foo2.base_trait('shared').copy = value
        # self.bar2.base_trait('shared').copy = value
        # self.baz2.base_trait('shared').copy = value
        #self.print_copy()


class TestCopyTraitsSetup(CopyTraitsBase):
    __test__ = True

    def setUp(self):
        super(TestCopyTraitsSetup, self).setUp()
        print '\nshared', self.shared
        print 'foo', self.foo
        print 'bar', self.bar
        print 'baz', self.baz
        print '\nshared2', self.shared2
        print 'foo2', self.foo2
        print 'bar2', self.bar2
        print 'baz2', self.baz2

        return

    def test_setup(self):
        self.assertIs(self.foo, self.bar.foo)
        self.assertIs(self.bar, self.baz.bar)
        self.assertIs(self.foo.shared, self.shared)
        self.assertIs(self.bar.shared, self.shared)
        self.assertIs(self.baz.shared, self.shared)

        self.assertIs(self.foo2, self.bar2.foo)
        self.assertIs(self.bar2, self.baz2.bar)
        self.assertIs(self.foo2.shared, self.shared2)
        self.assertIs(self.bar2.shared, self.shared2)
        self.assertIs(self.baz2.shared, self.shared2)
        return


class CopyTraits:

    def test_baz2_s(self):
        self.assertEqual(self.baz2.s, 'baz')
        self.assertEqual(self.baz2.s, self.baz.s)

    def test_baz2_bar_s(self):
        self.assertEqual(self.baz2.bar.s, 'bar')
        self.assertEqual(self.baz2.bar.s, self.baz.bar.s)

    def test_baz2_bar_foo_s(self):
        self.assertEqual(self.baz2.bar.foo.s, 'foo')
        self.assertEqual(self.baz2.bar.foo.s, self.baz.bar.foo.s)

    def test_baz2_shared_s(self):
        self.assertEqual(self.baz2.shared.s, 'shared')
        self.assertEqual(self.baz2.bar.shared.s, 'shared')
        self.assertEqual(self.baz2.bar.foo.shared.s, 'shared')

    def test_baz2_bar(self):
        # First hand Instance trait is different and
        # is not the same object as the source.

        self.assertIsNot(self.baz2.bar, None)
        self.assertIsNot(self.baz2.bar, self.bar2)
        self.assertIsNot(self.baz2.bar, self.baz.bar)

    def test_baz2_bar_foo(self):
        # Second hand Instance trait is a different object and
        # is not the same object as the source.

        self.assertIsNot(self.baz2.bar.foo, None)
        self.assertIsNot(self.baz2.bar.foo, self.foo2)
        self.assertIsNot(self.baz2.bar.foo, self.baz.bar.foo)


class CopyTraitsSharedCopyNone:
    def test_baz2_shared(self):
        # First hand Instance trait is a different object and
        # is not the same object as the source.

        self.assertIsNot(self.baz2.shared, None)
        self.assertIsNot(self.baz2.shared, self.shared2)
        self.assertIsNot(self.baz2.shared, self.shared)

    def test_baz2_bar_shared(self):
        # Second hand Instance that was shared is a different object and
        # not the same object as the source and
        # not the same object as the new first hand instance that was the same.
        # I.e. There are now (at least) two copies of one original object.

        self.assertIsNot(self.baz2.bar.shared, None)
        self.assertIsNot(self.baz2.bar.shared, self.shared2)
        self.assertIsNot(self.baz2.bar.shared, self.shared)
        self.assertIsNot(self.baz2.bar.shared, self.baz2.shared)

    def test_baz2_bar_foo_shared(self):
        # Third hand Instance that was shared is a different object and
        # not the same object as the source and
        # not the same object as the new first hand instance that was the same.
        # I.e. There are now (at least) two copies of one original object.

        self.assertIsNot(self.baz2.bar.foo.shared, None)
        self.assertIsNot(self.baz2.bar.foo.shared, self.shared2)
        self.assertIsNot(self.baz2.bar.foo.shared, self.shared)
        self.assertIsNot(self.baz2.bar.foo.shared, self.baz2.shared)

    def test_baz2_bar_and_foo_shared(self):
        #
        # THE BEHAVIOR DEMONSTRATED BY THIS TEST CASE DOES NOT SEEM TO BE
        # CORRECT.
        #
        # Second and Third hand Instance object that was shared with first hand
        # instance are the same as each other but
        # Every reference to the same original object has been replace by
        # a reference to the same copy of the same source object except the
        # first hand reference which is a different copy.
        # I.e. The shared relationship has been fubarred by copy_traits: it's
        # not maintained, but not completely destroyed.
        self.assertIs(self.baz2.bar.shared, self.baz2.bar.foo.shared)
        self.assertIsNot(self.baz2.shared, self.baz2.bar.foo.shared)


class TestCopyTraitsSharedCopyNone(CopyTraits,
                                   CopyTraitsSharedCopyNone):
    __test__ = False

    def setUp(self):
        print '\n***TestCopyTraitsSharedCopyNone',
        #super(TestCopyTraitsSharedCopyNone,self).setUp()

        # deep is the default value for Instance trait copy
        self.set_shared_copy('deep')
        return


class TestCopyTraitsCopyNotSpecified(CopyTraitsBase,
                                     TestCopyTraitsSharedCopyNone):
    __test__ = True

    def setUp(self):
        print '\n*TestCopyTraitsCopyNotSpecified',
#        super(TestCopyTraitsCopyNotSpecified,self).setUp()
        CopyTraitsBase.setUp(self)
        TestCopyTraitsSharedCopyNone.setUp(self)
        self.baz2.copy_traits(self.baz)
        return


class TestCopyTraitsCopyShallow(CopyTraitsBase, TestCopyTraitsSharedCopyNone):
    __test__ = True

    def setUp(self):
        print '\n*TestCopyTraitsCopyShallow',
#        super(TestCopyTraitsCopyShallow,self).setUp()
        CopyTraitsBase.setUp(self)
        TestCopyTraitsSharedCopyNone.setUp(self)
        self.baz2.copy_traits(self.baz, copy='shallow')
        return


class TestCopyTraitsCopyDeep(CopyTraitsBase, TestCopyTraitsSharedCopyNone):
    __test__ = True

    def setUp(self):
        print '\n*TestCopyTraitsCopyDeep',
#        super(TestCopyTraitsCopyDeep,self).setUp()
        CopyTraitsBase.setUp(self)
        TestCopyTraitsSharedCopyNone.setUp(self)
        self.baz2.copy_traits(self.baz, copy='deep')
        return


class CopyTraitsSharedCopyRef:
    def test_baz2_shared(self):
        # First hand Instance trait is a different object and
        # is the same object as the source.

        self.assertIsNot(self.baz2.shared, None)
        self.assertIsNot(self.baz2.shared, self.shared2)
        self.assertIs(self.baz2.shared, self.shared)

    def test_baz2_bar_shared(self):
        self.assertIsNot(self.baz2.bar.shared, None)
        self.assertIsNot(self.baz2.bar.shared, self.shared2)
        self.assertIs(self.baz2.bar.shared, self.shared)
        self.assertIs(self.baz2.bar.shared, self.baz2.shared)

    def test_baz2_bar_foo_shared(self):
        self.assertIsNot(self.baz2.bar.foo.shared, None)
        self.assertIsNot(self.baz2.bar.foo.shared, self.shared2)
        self.assertIs(self.baz2.bar.foo.shared, self.shared)
        self.assertIs(self.baz2.bar.foo.shared, self.baz2.shared)

    def test_baz2_bar_and_foo_shared(self):
        self.assertIs(self.baz2.bar.shared, self.baz2.bar.foo.shared)
        self.assertIs(self.baz2.shared, self.baz2.bar.foo.shared)


class TestCopyTraitsSharedCopyRef(CopyTraits,
                                  CopyTraitsSharedCopyRef):
    __test__ = False

    def setUp(self):
        print '\n***TestCopyTraitsSharedCopyRef.setUp ',
        #super(TestCopyTraitsSharedCopyRef,self).setUp()
        self.set_shared_copy('ref')
        return


# The next three tests demonstrate that a 'ref' trait is always copied as a
# reference regardless of the copy argument to copy_traits.  That is, shallow
# and deep are indistinguishable.
class TestCopyTraitsCopyNotSpecifiedSharedRef(CopyTraitsBase,
                                              TestCopyTraitsSharedCopyRef):
    __test__ = True

    def setUp(self):
        print '\n*TestCopyTraitsCopyNotSpecifiedSharedRef.setUp',
        CopyTraitsBase.setUp(self)
        TestCopyTraitsSharedCopyRef.setUp(self)
        self.baz2.copy_traits(self.baz)
        return


class TestCopyTraitsCopyShallowSharedRef(CopyTraitsBase,
                                         TestCopyTraitsSharedCopyRef):
    __test__ = True

    def setUp(self):
        print '\n*TestCopyTraitsCopyShallowSharedRef.setUp',
        CopyTraitsBase.setUp(self)
        TestCopyTraitsSharedCopyRef.setUp(self)
        self.baz2.copy_traits(self.baz, copy='shallow')
        return


class TestCopyTraitsCopyDeepSharedRef(CopyTraitsBase,
                                      TestCopyTraitsSharedCopyRef):
    __test__ = True

    def setUp(self):
        print '\n*TestCopyTraitsCopyDeepSharedRef.setUp',
        CopyTraitsBase.setUp(self)
        TestCopyTraitsSharedCopyRef.setUp(self)
        self.baz2.copy_traits(self.baz, copy='deep')
        return
### EOF

########NEW FILE########
__FILENAME__ = test_cythonized_traits
""" Test some usage of Trait classes when the code is cythonized.

The tests reflects some of the patterns needed in different applications. They
probably don't cover all of the user case.

Each test case is written as if the test code was in a separate module then
compiled with Cython Inline before evaluation the produced object behaves
properly.

The tests need a Cython version > 0.19 and a compiler.

"""
try:
    import cython
    no_cython = False
except ImportError:
    no_cython = True


from ..testing.unittest_tools import unittest, UnittestTools


def has_no_compiler():
    if no_cython:
        return True
    # Easy way to check if we have access to a compiler
    code = "return 1+1"
    try:
        cython.inline(code)
        return False
    except:
        return True


def cython_version():
    if no_cython:
        return None
    from Cython.Compiler.Version import version
    return tuple(int(v) for v in version.split('.'))

SKIP_TEST = has_no_compiler()


# Cython 0.19 implementation of safe_type fails while parsing some of the
# code. We provide a very basic implementation that always returns object
# (we don't need any particular optimizations)
def _always_object_type(arg, context):
    return 'object'


class CythonizedTraitsTestCase(unittest.TestCase, UnittestTools):

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_simple_default_methods(self):

        code = """
from traits.api import HasTraits, Str

class Test(HasTraits):
    name = Str

    def _name_default(self):
        return 'Joe'

return Test()
"""

        obj = cython.inline(code)

        self.assertEqual(obj.name, 'Joe')

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_basic_events(self):

        code = """
from traits.api import HasTraits, Str

class Test(HasTraits):
    name = Str

return Test()
"""

        obj = cython.inline(code)

        with self.assertTraitChanges(obj, 'name', count=1):
            obj.name = 'changing_name'

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_static_handlers(self):

        code = """
from traits.api import HasTraits, Str, Int

class Test(HasTraits):
    name = Str
    value = Int

    def _name_changed(self):
        self.value += 1

return Test()
"""

        obj = cython.inline(code, get_type=_always_object_type, force=True)

        with self.assertTraitChanges(obj, 'value', count=1):
            obj.name = 'changing_name'

        self.assertEqual(obj.value, 1)

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_on_trait_change_decorator(self):

        code = """
from traits.api import HasTraits, Str, Int, on_trait_change

class Test(HasTraits):
    name = Str
    value = Int

    @on_trait_change('name')
    def _update_value(self):
        self.value += 1

return Test()
"""

        obj = cython.inline(code, get_type=_always_object_type, force=True,
                            locals={}, globals={})

        with self.assertTraitChanges(obj, 'value', count=1):
            obj.name = 'changing_name'

        self.assertEqual(obj.value, 1)

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_properties(self):

        code = """
from traits.api import HasTraits, Str, Int, Property, cached_property

class Test(HasTraits):
    name = Str
    name_len = Property(depends_on='name')

    @cached_property
    def _get_name_len(self):
        return len(self.name)

return Test()
"""

        obj = cython.inline(code, get_type=_always_object_type, force=True,
                            locals={}, globals={})

        self.assertEqual(obj.name_len, len(obj.name))

        # Assert dependency works
        obj.name = 'Bob'
        self.assertEqual(obj.name_len, len(obj.name))

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_properties_with_standard_getter(self):

        code = """
from traits.api import HasTraits, Str, Int, Property

class Test(HasTraits):
    name = Str

    def _get_name_length(self):
        return len(self.name)

    name_len = Property(_get_name_length)

return Test()
"""

        obj = cython.inline(code, get_type=_always_object_type, force=True,
                            locals={}, globals={})

        self.assertEqual(obj.name_len, len(obj.name))

        # Assert dependency works
        obj.name = 'Bob'
        self.assertEqual(obj.name_len, len(obj.name))

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_aliasing(self):

        code = """
from traits.api import HasTraits, Str, Int, Property

def Alias(name):
    def _get_value(self):
        return getattr(self, name)
    def _set_value(self, value):
        return setattr(self, name, value)

    return Property(_get_value, _set_value)

class Test(HasTraits):
    name = Str

    funky_name = Alias('name')

return Test()
"""

        obj = cython.inline(code, get_type=_always_object_type, force=True,
                            locals={}, globals={})

        self.assertEqual(obj.funky_name, obj.name)

        # Assert dependency works
        obj.name = 'Bob'
        self.assertEqual(obj.funky_name, obj.name)

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_aliasing_different_scope(self):

        code = """
from traits.api import HasTraits, Str, Int, Property

def _get_value(self, name):
    return getattr(self, 'name')
def _set_value(self, name, value):
    return setattr(self, 'name', value)


class Test(HasTraits):
    name = Str

    funky_name = Property(_get_value, _set_value)

return Test()
"""

        obj = cython.inline(code, get_type=_always_object_type)

        self.assertEqual(obj.funky_name, obj.name)

        # Assert dependency works
        obj.name = 'Bob'
        self.assertEqual(obj.funky_name, obj.name)

    @unittest.skipIf(SKIP_TEST, 'Missing Cython and/or compiler')
    def test_on_trait_lambda_failure(self):

        # Lambda function are converted like builtins when cythonized which
        # causes the following code to fail

        code = """
from traits.api import HasTraits, Str, Int, Property

def Alias(name):
    return Property(
        lambda obj: getattr(obj, name),
        lambda obj, value: setattr(obj, name, value)
    )

class Test(HasTraits):
    name = Str

    funky_name = Alias('name')

return Test()
"""

        try:
            cython.inline(code, get_type=_always_object_type, force=True,
                          locals={}, globals={})
        except:
            # We suppose we have an exception. Because of the usage of the
            # skipIf decorator on the test, we can't use an expectedFailure
            # decorator as they don't play well together.
            pass
        else:
            self.fail(
                'Unexpected results. Cython was not managing lambda as regular'
                ' functions. Behaviour changed ...'
            )

########NEW FILE########
__FILENAME__ = test_delegate
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import Delegate, HasTraits, Instance, Str

# global because event handlers are being called with wrong value for self
baz_s_handler_self = None
baz_sd_handler_self = None
baz_u_handler_self = None
baz_t_handler_self = None
foo_s_handler_self = None
foo_t_handler_self = None


class Foo(HasTraits):
    s = Str('foo')
    t = Str('foo.t')
    u = Str('foo.u')

    def _s_changed(self, name, old, new):
        print 'Foo._s_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global foo_s_handler_self
        foo_s_handler_self = self
        return

    def _t_changed(self, name, old, new):
        print 'Foo._t_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global foo_t_handler_self
        foo_t_handler_self = self
        return


class Bar(HasTraits):
    foo = Instance(Foo, ())
    s = Delegate('foo')


class BazModify(HasTraits):
    foo = Instance(Foo, ())
    sd = Delegate('foo', prefix='s', modify=True)
    t = Delegate('foo', modify=True)
    u = Delegate('foo', listenable=False, modify=True)

    def _s_changed(self, name, old, new):
        # should never be called
        print 'BazModify._s_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_s_handler_self
        baz_s_handler_self = self
        return

    def _sd_changed(self, name, old, new):
        print 'BazModify._sd_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_sd_handler_self
        baz_sd_handler_self = self
        return

    def _t_changed(self, name, old, new):
        print 'BazModify._t_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_t_handler_self
        baz_t_handler_self = self
        return

    def _u_changed(self, name, old, new):
        print 'BazModify._u_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_u_handler_self
        baz_u_handler_self = self
        return


class BazNoModify(HasTraits):
    foo = Instance(Foo, ())
    sd = Delegate('foo', prefix='s')
    t = Delegate('foo')
    u = Delegate('foo', listenable=False)

    def _s_changed(self, name, old, new):
        print 'BazNoModify._s_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_s_handler_self
        baz_s_handler_self = self
        return

    def _sd_changed(self, name, old, new):
        print 'BazNoModify._sd_changed(%s, %s, %s, %s)' % (self, name, old,
                                                           new)
        global baz_sd_handler_self
        baz_sd_handler_self = self
        return

    def _t_changed(self, name, old, new):
        print 'BazNoModify._t_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_t_handler_self
        baz_t_handler_self = self
        return

    def _u_changed(self, name, old, new):
        print 'BazNoModify._u_changed(%s, %s, %s, %s)' % (self, name, old, new)
        global baz_u_handler_self
        baz_u_handler_self = self
        return


class DelegateTestCase(unittest.TestCase):
    """ Test cases for delegated traits. """

    def setUp(self):
        """ Reset all of the globals.
        """
        global baz_s_handler_self, baz_sd_handler_self, baz_u_handler_self
        global baz_t_handler_self, foo_s_handler_self, foo_t_handler_self
        baz_s_handler_self = None
        baz_sd_handler_self = None
        baz_u_handler_self = None
        baz_t_handler_self = None
        foo_s_handler_self = None
        foo_t_handler_self = None

    def test_reset(self):
        """ Test that a delegated trait may be reset.

        Deleting the attribute should reset the trait back to its initial
        delegation behavior.
        """

        f = Foo()
        b = Bar(foo=f)

        # Check initial delegation.
        self.assertEqual(f.s, b.s)

        # Check that an override works.
        b.s = 'bar'
        self.assertNotEqual(f.s, b.s)

        # Check that we can reset back to delegation.  This is what we are
        # really testing for.
        del b.s
        self.assertEqual(f.s, b.s)
        return

    # Below are 8 tests to check the calling of change notification handlers.
    # There are 8 cases for the 2x2x2 matrix with axes:
    # Delegate with prefix or not
    # Delegate with modify write through or not
    # Handler in the delegator and delegatee
    def test_modify_prefix_handler_on_delegator(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.s, b.sd)

        b.sd = 'changed'
        self.assertEqual(f.s, b.sd)

        # Don't expect _s_changed to be called because from Baz's perspective
        # the trait is named 'sd'
        self.assertEqual(baz_s_handler_self, None)

        # Do expect '_sd_changed' to be called with b as self
        self.assertEqual(baz_sd_handler_self, b)
        return

    def test_modify_prefix_handler_on_delegatee(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.s, b.sd)

        b.sd = 'changed'
        self.assertEqual(f.s, b.sd)

        # Foo expects its '_s_changed' handler to be called with f as self
        self.assertEqual(foo_s_handler_self, f)
        return

    def test_no_modify_prefix_handler_on_delegator(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.s, b.sd)

        b.sd = 'changed'
        self.assertNotEqual(f.s, b.sd)

        # Don't expect _s_changed to be called because from Baz's perspective
        # the trait is named 'sd'
        self.assertEqual(baz_s_handler_self, None)

        # Do expect '_sd_changed' to be called with b as self
        self.assertEqual(baz_sd_handler_self, b)
        return

    def test_no_modify_prefix_handler_on_delegatee_not_called(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.s, b.sd)

        b.sd = 'changed'
        self.assertNotEqual(f.s, b.sd)

        # Foo expects its '_s_changed' handler to be called with f as self
        self.assertEqual(foo_s_handler_self, None)
        return

    def test_modify_handler_on_delegator(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.t, b.t)

        b.t = 'changed'
        self.assertEqual(f.t, b.t)

        # Do expect '_t_changed' to be called with b as self
        self.assertEqual(baz_t_handler_self, b)
        return

    def test_modify_handler_on_delegatee(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.t, b.t)

        b.t = 'changed'
        self.assertEqual(f.t, b.t)

        # Foo t did change so '_t_changed' handler should be called
        self.assertEqual(foo_t_handler_self, f)
        return

    def test_no_modify_handler_on_delegator(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.t, b.t)

        b.t = 'changed'
        self.assertNotEqual(f.t, b.t)

        # Do expect '_t_changed' to be called with b as self
        self.assertEqual(baz_t_handler_self, b)
        return

    def test_no_modify_handler_on_delegatee_not_called(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.t, b.t)

        b.t = 'changed'
        self.assertNotEqual(f.t, b.t)

        # Foo t did not change so '_t_changed' handler should not be called
        self.assertEqual(foo_t_handler_self, None)
        return

    # Below are 4 tests for notification when the delegated trait is changed
    # directly rather than through the delegator.
    def test_no_modify_handler_on_delegatee_direct_change(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.t, b.t)

        f.t = 'changed'
        self.assertEqual(f.t, b.t)

        # Foo t did change so '_t_changed' handler should be called
        self.assertEqual(foo_t_handler_self, f)
        return

    def test_no_modify_handler_on_delegator_direct_change(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.t, b.t)

        f.t = 'changed'
        self.assertEqual(f.t, b.t)

        # Do expect '_t_changed' to be called with b as self
        self.assertEqual(baz_t_handler_self, b)
        return

    def test_modify_handler_on_delegatee_direct_change(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.t, b.t)

        f.t = 'changed'
        self.assertEqual(f.t, b.t)

        # Foo t did change so '_t_changed' handler should be called
        self.assertEqual(foo_t_handler_self, f)
        return

    def test_modify_handler_on_delegator_direct_change(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.t, b.t)

        f.t = 'changed'
        self.assertEqual(f.t, b.t)

        # Do expect '_t_changed' to be called with b as self
        self.assertEqual(baz_t_handler_self, b)
        return

    # Below are tests which check that we can turn off listenableness.
    def test_modify_handler_not_listenable(self):
        f = Foo()
        b = BazModify(foo=f)

        self.assertEqual(f.u, b.u)

        f.u = 'changed'
        self.assertEqual(f.u, b.u)

        # Do not expect '_u_changed' to be called.
        self.assertEqual(baz_u_handler_self, None)
        return

    def test_no_modify_handler_not_listenable(self):
        f = Foo()
        b = BazNoModify(foo=f)

        self.assertEqual(f.u, b.u)

        f.u = 'changed'
        self.assertEqual(f.u, b.u)

        # Do not expect '_u_changed' to be called.
        self.assertEqual(baz_u_handler_self, None)
        return

if __name__ == '__main__':
    unittest.main()
# EOF #

########NEW FILE########
__FILENAME__ = test_dict
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
""" Test cases for dictionary (Dict) traits. """

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..trait_types import Dict, Event, Str, TraitDictObject
from ..has_traits import HasTraits, on_trait_change
from ..trait_errors import TraitError


# fixme: We'd like to use a callable instance for the listener so that we
# can maintain state, but traits barfs trying to determine the signature 8^()
def create_listener():
    """ Create a listener for testing trait notifications. """

    def listener(obj, trait_name, old, new):

        listener.obj = obj
        listener.trait_name = trait_name
        listener.new = new
        listener.old = old
        listener.called += 1
        return

    listener.initialize = lambda: initialize_listener(listener)
    return initialize_listener(listener)


def initialize_listener(listener):
    """ Initialize a listener so it looks like it hasn't been called.

    This allows us to re-use the listener without having to create and
    wire-up a new one.

    """

    listener.obj = None
    listener.trait_name = None
    listener.old = None
    listener.new = None
    listener.called = 0

    return listener  # For convenience


class TestDict(unittest.TestCase):
    """ Test cases for dictionary (Dict) traits. """

    def test_modified_event(self):

        class Foo(HasTraits):
            name = Str
            modified = Event

            @on_trait_change('name')
            def _fire_modified_event(self):
                self.modified = True
                return

        class Bar(HasTraits):
            foos = Dict(Str, Foo)
            modified = Event

            @on_trait_change('foos_items,foos.modified')
            def _fire_modified_event(self, obj, trait_name, old, new):
                self.modified = True
                return

        bar = Bar()
        listener = create_listener()
        bar.on_trait_change(listener, 'modified')

        # Assign a completely new dictionary.
        bar.foos = {'dino': Foo(name='dino')}
        self.assertEqual(1, listener.called)
        self.assertEqual('modified', listener.trait_name)

        # Add an item to an existing dictionary.
        listener.initialize()
        fred = Foo(name='fred')
        bar.foos['fred'] = fred
        self.assertEqual(1, listener.called)
        self.assertEqual('modified', listener.trait_name)

        # Modify an item already in the dictionary.
        listener.initialize()
        fred.name = 'barney'
        self.assertEqual(1, listener.called)
        self.assertEqual('modified', listener.trait_name)

        # Overwrite an item in the dictionary. This is the one that fails!
        listener.initialize()
        bar.foos['fred'] = Foo(name='wilma')
        self.assertEqual(1, listener.called)
        self.assertEqual('modified', listener.trait_name)

        return

    def test_validate(self):
        """ Check the validation method.

        """
        foo = Dict()

        # invalid value
        with self.assertRaises(TraitError):
            foo.validate(object=HasTraits(), name='bar', value=None)

        # valid value
        result = foo.validate(object=HasTraits(), name='bar', value={})
        self.assertIsInstance(result, TraitDictObject)

        # object is None (check for issue #71)
        result = foo.validate(object=None, name='bar', value={})
        self.assertEqual(result, {})


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_dynamic_notifiers
""" Tests for the dynamic notifiers. """
import gc

from traits import _py2to3

from traits.api import Float, HasTraits, List, on_trait_change
from traits.testing.unittest_tools import unittest

from traits import trait_notifiers


class DynamicNotifiers(HasTraits):

    ok = Float
    fail = Float

    # Lists where we accumulate the arguments of calls to the traits notifiers.
    rebind_calls_0 = List
    rebind_calls_1 = List
    rebind_calls_2 = List
    rebind_calls_3 = List
    rebind_calls_4 = List
    exceptions_from = List

    #### 'ok' trait listeners

    @on_trait_change('ok')
    def method_listener_0(self):
        self.rebind_calls_0.append(True)

    @on_trait_change('ok')
    def method_listener_1(self, new):
        self.rebind_calls_1.append(new)

    @on_trait_change('ok')
    def method_listener_2(self, name, new):
        self.rebind_calls_2.append((name, new))

    @on_trait_change('ok')
    def method_listener_3(self, obj, name, new):
        self.rebind_calls_3.append((obj, name, new))

    @on_trait_change('ok')
    def method_listener_4(self, obj, name, old, new):
        self.rebind_calls_4.append((obj, name, old, new))

    #### 'fail' trait listeners

    @on_trait_change('fail')
    def failing_method_listener_0(self):
        self.exceptions_from.append(0)
        raise Exception('error')

    @on_trait_change('fail')
    def failing_method_listener_1(self, new):
        self.exceptions_from.append(1)
        raise Exception('error')

    @on_trait_change('fail')
    def failing_method_listener_2(self, name, new):
        self.exceptions_from.append(2)
        raise Exception('error')

    @on_trait_change('fail')
    def failing_method_listener_3(self, obj, name, new):
        self.exceptions_from.append(3)
        raise Exception('error')

    @on_trait_change('fail')
    def failing_method_listener_4(self, obj, name, old, new):
        self.exceptions_from.append(4)
        raise Exception('error')


# 'ok' function listeners

calls_0 = []


def function_listener_0():
    calls_0.append(True)


calls_1 = []


def function_listener_1(new):
    calls_1.append(new)


calls_2 = []


def function_listener_2(name, new):
    calls_2.append((name, new))


calls_3 = []


def function_listener_3(obj, name, new):
    calls_3.append((obj, name, new))


calls_4 = []


def function_listener_4(obj, name, old, new):
    calls_4.append((obj, name, old, new))


# 'fail' function listeners

exceptions_from = []


def failing_function_listener_0():
    exceptions_from.append(0)
    raise Exception('error')


def failing_function_listener_1(new):
    exceptions_from.append(1)
    raise Exception('error')


def failing_function_listener_2(name, new):
    exceptions_from.append(2)
    raise Exception('error')


def failing_function_listener_3(obj, name, new):
    exceptions_from.append(3)
    raise Exception('error')


def failing_function_listener_4(obj, name, old, new):
    exceptions_from.append(4)
    raise Exception('error')


class TestDynamicNotifiers(unittest.TestCase):

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        self.exceptions = []
        trait_notifiers.push_exception_handler(self._handle_exception)

    def tearDown(self):
        trait_notifiers.pop_exception_handler()

    #### Private protocol #####################################################

    def _handle_exception(self, obj, name, old, new):
        self.exceptions.append((obj, name, old, new))

    #### Tests ################################################################

    def test_dynamic_notifiers_methods(self):
        obj = DynamicNotifiers(ok=2)
        obj.ok = 3

        self.assertEqual(len(obj.rebind_calls_0), 2)

        expected_1 = [2, 3]
        self.assertEqual(expected_1, obj.rebind_calls_1)

        expected_2 = [('ok', 2), ('ok', 3)]
        self.assertEqual(expected_2, obj.rebind_calls_2)

        expected_3 = [(obj, 'ok', 2), (obj, 'ok', 3)]
        self.assertEqual(expected_3, obj.rebind_calls_3)

        expected_4 = [(obj, 'ok', 0, 2), (obj, 'ok', 2, 3)]
        self.assertEqual(expected_4, obj.rebind_calls_4)

    def test_dynamic_notifiers_methods_failing(self):
        obj = DynamicNotifiers()
        obj.fail = 1

        _py2to3.assertCountEqual(self, [0, 1, 2, 3, 4], obj.exceptions_from)
        self.assertEqual([(obj, 'fail', 0, 1)]*5, self.exceptions)

    def test_dynamic_notifiers_functions(self):
        obj = DynamicNotifiers()

        obj.on_trait_change(function_listener_0, 'ok')
        obj.on_trait_change(function_listener_1, 'ok')
        obj.on_trait_change(function_listener_2, 'ok')
        obj.on_trait_change(function_listener_3, 'ok')
        obj.on_trait_change(function_listener_4, 'ok')

        obj.ok = 2
        obj.ok = 3

        expected_1 = [2, 3]
        self.assertEqual(expected_1, calls_1)

        expected_2 = [('ok', 2), ('ok', 3)]
        self.assertEqual(expected_2, calls_2)

        expected_3 = [(obj, 'ok', 2), (obj, 'ok', 3)]
        self.assertEqual(expected_3, calls_3)

        expected_4 = [(obj, 'ok', 0, 2), (obj, 'ok', 2, 3)]
        self.assertEqual(expected_4, calls_4)

    def test_dynamic_notifiers_functions_failing(self):
        obj = DynamicNotifiers()

        obj.on_trait_change(failing_function_listener_0, 'fail')
        obj.on_trait_change(failing_function_listener_1, 'fail')
        obj.on_trait_change(failing_function_listener_2, 'fail')
        obj.on_trait_change(failing_function_listener_3, 'fail')
        obj.on_trait_change(failing_function_listener_4, 'fail')

        obj.fail = 1

        _py2to3.assertCountEqual(self, [0, 1, 2, 3, 4], obj.exceptions_from)
        # 10 failures: 5 are from the internal dynamic listeners, see
        # test_dynamic_notifiers_methods_failing
        self.assertEqual([(obj, 'fail', 0, 1)] * 10, self.exceptions)

    def test_object_can_be_garbage_collected(self):
        # Make sure that a trait object can be garbage collected even though
        # there are listener to its traits.

        import weakref

        obj = DynamicNotifiers()
        obj.on_trait_change(function_listener_0, 'ok')

        # Create a weak reference to `obj` with a callback that flags when the
        # object is finalized.
        obj_collected = []

        def obj_collected_callback(weakref):
            obj_collected.append(True)

        obj_weakref = weakref.ref(obj, obj_collected_callback)

        # Remove reference to `obj`, and check that the weak reference
        # callback has been called, indicating that it has been collected.
        del obj

        self.assertEqual(obj_collected, [True])

    def test_creating_notifiers_dont_create_cyclic_garbage(self):
        gc.collect()
        DynamicNotifiers()
        # When an object with dynamic listeners has no more references,
        # it should not create cyclic garbage.
        self.assertEqual(gc.collect(), 0)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_dynamic_trait_definition
from traits.testing.unittest_tools import unittest

from traits.api import Float, HasTraits, Int, List


class Foo(HasTraits):
    x = Float

    y_changes = List

    def _y_changed(self, new):
        self.y_changes.append(new)


class TestDynamicTraitDefinition(unittest.TestCase):
    """ Test demonstrating special change events using the 'event' metadata.
    """

    def test_add_trait(self):
        foo = Foo(x=3)
        foo.add_trait('y', Int)

        self.assertTrue(hasattr(foo, 'y'))
        self.assertEqual(type(foo.y), int)

        foo.y = 4
        self.assertEqual(foo.y_changes, [4])

    def test_remove_trait(self):
        foo = Foo(x=3)

        # We can't remove a "statically" added trait (i.e., a trait defined
        # in the Foo class).
        result = foo.remove_trait('x')
        self.assertFalse(result)

        # We can remove dynamically added traits.
        foo.add_trait('y', Int)
        foo.y = 70

        result = foo.remove_trait('y')
        self.assertTrue(result)

        self.assertFalse(hasattr(foo, 'y'))
        foo.y = 10
        self.assertEqual(foo.y_changes, [70])

########NEW FILE########
__FILENAME__ = test_enum
from traits.testing.unittest_tools import unittest

from traits.api import Enum, HasTraits, List, Property, TraitError


class ExampleModel(HasTraits):
    valid_models = Property(List)
    root = Enum(values='valid_models')

    def _get_valid_models(self):
        return ['model1', 'model2', 'model3']


class EnumTestCase(unittest.TestCase):
    def test_valid_enum(self):
        example_model = ExampleModel(root='model1')
        example_model.root = 'model2'

    def test_invalid_enum(self):
        example_model = ExampleModel(root='model1')

        def assign_invalid():
            example_model.root = 'not_valid_model'

        self.assertRaises(TraitError, assign_invalid)

########NEW FILE########
__FILENAME__ = test_events
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill Date: 10/22/2003 Description: Unit test case for
# Traits event notification handling.

from __future__ import absolute_import

from ..api import HasTraits


class TestBase(HasTraits):
    __traits__ = {
        't1': 0,
        't2': 0
    }

    def test(self):
        print '---------- Begin %s test ----------' % self.__class__.__name__
        print 'normal changes'
        self.t1 = 1
        self.t2 = 2

        print '---------- End %s test ----------\n' % self.__class__.__name__


class Test1(TestBase):

    def t1_changed(self, old, new):
        print 't1 changed:', old, new

    def t2_changed(self, old, new):
        print 't2 changed:', old, new


class Test2(Test1):

    def anytrait_changed(self, name, old, new):
        print 'anytrait changed:', name, old, new


class Test3(TestBase):

    def anytrait_changed(self, name, old, new):
        print 'anytrait changed:', name, old, new


class Test4(TestBase):

    def __init__(self, **traits):
        TestBase.__init__(self, **traits)
        self.on_trait_change(self.on_anytrait)

    def on_anytrait(self, object, name, old, new):
        print 'on anytrait changed:', name, old, new


class Test5(TestBase):

    def __init__(self, **traits):
        TestBase.__init__(self, **traits)
        self.on_trait_change(self.t1_trait, 't1')
        self.on_trait_change(self.t2_trait, 't2')

    def t1_trait(self, object, name, old, new):
        print 'on t1 changed:', old, new

    def t2_trait(self, object, name, old, new):
        print 'on t2 changed:', old, new


class Test6(Test5):

    def __init__(self, **traits):
        Test5.__init__(self, **traits)
        self.on_trait_change(self.on_anytrait)

    def on_anytrait(self, object, name, old, new):
        print 'on anytrait changed:', name, old, new


class Test7(Test1):

    def __init__(self, **traits):
        Test1.__init__(self, **traits)
        self.on_trait_change(self.t1_trait, 't1')
        self.on_trait_change(self.t2_trait, 't2')

    def t1_trait(self, object, name, old, new):
        print 'on t1 changed:', old, new

    def t2_trait(self, object, name, old, new):
        print 'on t2 changed:', old, new


class Test8(Test2):

    def __init__(self, **traits):
        Test1.__init__(self, **traits)
        self.on_trait_change(self.t1_trait, 't1')
        self.on_trait_change(self.t2_trait, 't2')
        self.on_trait_change(self.on_anytrait)

    def on_anytrait(self, object, name, old, new):
        print 'on anytrait changed:', name, old, new

    def t1_trait(self, object, name, old, new):
        print 'on t1 changed:', old, new

    def t2_trait(self, object, name, old, new):
        print 'on t2 changed:', old, new


test1 = Test1()
test1.test()

test2 = Test2()
test2.test()

test3 = Test3()
test3.test()

test4 = Test4()
test4.test()

test5 = Test5()
test5.test()

test6 = Test6()
test6.test()

test7 = Test7()
test7.test()

test8 = Test8()
test8.test()

########NEW FILE########
__FILENAME__ = test_event_order
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This Software is provided without warranty under the terms of the
#  BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The
#  license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Str, Instance, Any


class TestEventOrder(unittest.TestCase):
    """ Tests that demonstrate that trait events are delivered in LIFO
    order rather than FIFO order.

    Baz receives the "effect" event before it receives the "cause" event.
    """
    def setUp(self):
        foo = Foo(cause='ORIGINAL')
        bar = Bar(foo=foo, test=self)
        baz = Baz(bar=bar, test=self)

        self.events_delivered = []
        foo.cause = 'CHANGE'
        return

    def test_lifo_order(self):
        lifo = ['Bar._caused_changed',
                'Baz._effect_changed',
                'Baz._caused_changed']

        self.assertEqual(self.events_delivered, lifo)
        return

    def test_not_fifo_order(self):
        fifo = ['Bar._caused_changed',
                'Baz._caused_changed',
                'Baz._effect_changed']

        self.assertNotEqual(self.events_delivered, fifo)
        return


class Foo(HasTraits):
    cause = Str


class Bar(HasTraits):
    foo = Instance(Foo)
    effect = Str
    test = Any

    def _foo_changed(self, obj, old, new):
        if old is not None and old is not new:
            old.on_trait_change(self._cause_changed, name='cause', remove=True)

        if new is not None:
            new.on_trait_change(self._cause_changed, name='cause')

        return

    def _cause_changed(self, obj, name, old, new):
        self.test.events_delivered.append('Bar._caused_changed')
        self.effect = new.lower()
        return


class Baz(HasTraits):
    bar = Instance(Bar)
    test = Any

    def _bar_changed(self, obj, old, new):
        if old is not None and old is not new:
            old.on_trait_change(self._effect_changed, name='effect',
                                remove=True)
            old.foo.on_trait_change(self._cause_changed, name='cause',
                                    remove=True)

        if new is not None:
            new.foo.on_trait_change(self._cause_changed, name='cause')
            new.on_trait_change(self._effect_changed, name='effect')

        return

    def _cause_changed(self, obj, name, old, new):
        self.test.events_delivered.append('Baz._caused_changed')
        return

    def _effect_changed(self, obj, name, old, new):
        self.test.events_delivered.append('Baz._effect_changed')
        return

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = test_extended_notifiers
""" Tests for the extended notifiers.

The "extended notifiers" are set up internally when using extended traits, to
add/remove traits listeners when one of the intermediate traits changes.

For example, in a listener for the extended trait `a.b`, we need to add/remove
listeners to `a:b` when `a` changes.
"""
from traits import _py2to3

from traits.api import Float, HasTraits, List
from traits.testing.unittest_tools import unittest

from traits import trait_notifiers


class ExtendedNotifiers(HasTraits):

    def __init__(self, **traits):
        # Set up the 'extended' internal notifiers (see module docstring)

        ok_listeners = [self.method_listener_0,
                        self.method_listener_1,
                        self.method_listener_2,
                        self.method_listener_3,
                        self.method_listener_4]

        for listener in ok_listeners:
            self._on_trait_change(listener, 'ok', dispatch='extended')

        fail_listeners = [self.failing_method_listener_0,
                          self.failing_method_listener_1,
                          self.failing_method_listener_2,
                          self.failing_method_listener_3,
                          self.failing_method_listener_4]

        for listener in fail_listeners:
            self._on_trait_change(listener, 'fail', dispatch='extended')

        super(ExtendedNotifiers, self).__init__(**traits)

    ok = Float
    fail = Float

    # Lists where we accumulate the arguments of calls to the traits notifiers.
    rebind_calls_0 = List
    rebind_calls_1 = List
    rebind_calls_2 = List
    rebind_calls_3 = List
    rebind_calls_4 = List
    exceptions_from = List

    #### 'ok' trait listeners

    def method_listener_0(self):
        self.rebind_calls_0.append(True)

    def method_listener_1(self, new):
        self.rebind_calls_1.append(new)

    def method_listener_2(self, name, new):
        self.rebind_calls_2.append((name, new))

    def method_listener_3(self, obj, name, new):
        self.rebind_calls_3.append((obj, name, new))

    def method_listener_4(self, obj, name, old, new):
        self.rebind_calls_4.append((obj, name, old, new))

    #### 'fail' trait listeners

    def failing_method_listener_0(self):
        self.exceptions_from.append(0)
        raise Exception('error')

    def failing_method_listener_1(self, new):
        self.exceptions_from.append(1)
        raise Exception('error')

    def failing_method_listener_2(self, name, new):
        self.exceptions_from.append(2)
        raise Exception('error')

    def failing_method_listener_3(self, obj, name, new):
        self.exceptions_from.append(3)
        raise Exception('error')

    def failing_method_listener_4(self, obj, name, old, new):
        self.exceptions_from.append(4)
        raise Exception('error')


# 'ok' function listeners
calls_0 = []


def function_listener_0():
    calls_0.append(True)

calls_1 = []


def function_listener_1(new):
    calls_1.append(new)

calls_2 = []


def function_listener_2(name, new):
    calls_2.append((name, new))

calls_3 = []


def function_listener_3(obj, name, new):
    calls_3.append((obj, name, new))

calls_4 = []


def function_listener_4(obj, name, old, new):
    calls_4.append((obj, name, old, new))


# 'fail' function listeners

exceptions_from = []


def failing_function_listener_0():
    exceptions_from.append(0)
    raise Exception('error')


def failing_function_listener_1(new):
    exceptions_from.append(1)
    raise Exception('error')


def failing_function_listener_2(name, new):
    exceptions_from.append(2)
    raise Exception('error')


def failing_function_listener_3(obj, name, new):
    exceptions_from.append(3)
    raise Exception('error')


def failing_function_listener_4(obj, name, old, new):
    exceptions_from.append(4)
    raise Exception('error')


class TestExtendedNotifiers(unittest.TestCase):

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        self.exceptions = []
        trait_notifiers.push_exception_handler(self._handle_exception)

    def tearDown(self):
        trait_notifiers.pop_exception_handler()

    #### Private protocol #####################################################

    def _handle_exception(self, obj, name, old, new):
        self.exceptions.append((obj, name, old, new))

    #### Tests ################################################################

    def test_extended_notifiers_methods(self):
        obj = ExtendedNotifiers(ok=2)
        obj.ok = 3

        self.assertEqual(len(obj.rebind_calls_0), 2)

        expected_1 = [2, 3]
        self.assertEqual(expected_1, obj.rebind_calls_1)

        expected_2 = [('ok', 2), ('ok', 3)]
        self.assertEqual(expected_2, obj.rebind_calls_2)

        expected_3 = [(obj, 'ok', 2), (obj, 'ok', 3)]
        self.assertEqual(expected_3, obj.rebind_calls_3)

        expected_4 = [(obj, 'ok', 0, 2), (obj, 'ok', 2, 3)]
        self.assertEqual(expected_4, obj.rebind_calls_4)

    def test_extended_notifiers_methods_failing(self):
        obj = ExtendedNotifiers()
        obj.fail = 1

        _py2to3.assertCountEqual(self, [0, 1, 2, 3, 4], obj.exceptions_from)
        self.assertEqual([(obj, 'fail', 0, 1)]*5, self.exceptions)

    def test_extended_notifiers_functions(self):
        obj = ExtendedNotifiers()

        obj._on_trait_change(function_listener_0, 'ok', dispatch='extended')
        obj._on_trait_change(function_listener_1, 'ok', dispatch='extended')
        obj._on_trait_change(function_listener_2, 'ok', dispatch='extended')
        obj._on_trait_change(function_listener_3, 'ok', dispatch='extended')
        obj._on_trait_change(function_listener_4, 'ok', dispatch='extended')

        obj.ok = 2
        obj.ok = 3

        expected_1 = [2, 3]
        self.assertEqual(expected_1, calls_1)

        expected_2 = [('ok', 2), ('ok', 3)]
        self.assertEqual(expected_2, calls_2)

        expected_3 = [(obj, 'ok', 2), (obj, 'ok', 3)]
        self.assertEqual(expected_3, calls_3)

        expected_4 = [(obj, 'ok', 0, 2), (obj, 'ok', 2, 3)]
        self.assertEqual(expected_4, calls_4)

    def test_extended_notifiers_functions_failing(self):
        obj = ExtendedNotifiers()

        obj._on_trait_change(failing_function_listener_0, 'fail',
                             dispatch='extended')
        obj._on_trait_change(failing_function_listener_1, 'fail',
                             dispatch='extended')
        obj._on_trait_change(failing_function_listener_2, 'fail',
                             dispatch='extended')
        obj._on_trait_change(failing_function_listener_3, 'fail',
                             dispatch='extended')
        obj._on_trait_change(failing_function_listener_4, 'fail',
                             dispatch='extended')

        obj.fail = 1

        _py2to3.assertCountEqual(self, [0, 1, 2, 3, 4], obj.exceptions_from)
        # 10 failures: 5 are from the internal extended listeners, see
        # test_extended_notifiers_methods_failing
        self.assertEqual([(obj, 'fail', 0, 1)] * 10, self.exceptions)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_extended_trait_change
#  Unit test case for testing HasTraits 'on_trait_change' support.
#
#  Written by: David C. Morrill
#
#  Date: 4/10/2007
#
#  (c) Copyright 2007 by Enthought, Inc.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

""" Unit test case for testing HasTraits 'on_trait_change' support.
"""

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import (Any, Dict, HasTraits, Instance, Int, List, Property,
                   TraitDictEvent, TraitError, TraitListEvent, Undefined,
                   cached_property, on_trait_change, pop_exception_handler,
                   push_exception_handler)

from ..trait_handlers import TraitListObject, TraitDictObject


class ArgCheckBase(HasTraits):

    value = Int(0)
    int1 = Int(0, test=True)
    int2 = Int(0)
    int3 = Int(0, test=True)
    tint1 = Int(0)
    tint2 = Int(0, test=True)
    tint3 = Int(0)

    calls = Int(0)
    tc = Any


class ArgCheckSimple(ArgCheckBase):

    def arg_check0(self):
        self.calls += 1

    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.value)

    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, 'value')
        self.tc.assertEqual(new, self.value)

    def arg_check3(self, object, name, new):
        self.calls += 1
        self.tc.assertIs(object, self)
        self.tc.assertEqual(name, 'value')
        self.tc.assertEqual(new, self.value)

    def arg_check4(self, object, name, old, new):
        self.calls += 1
        self.tc.assertIs(object, self)
        self.tc.assertEqual(name, 'value')
        self.tc.assertEqual(old, (self.value - 1))
        self.tc.assertEqual(new, self.value)


class ArgCheckDecorator(ArgCheckBase):

    @on_trait_change('value')
    def arg_check0(self):
        self.calls += 1

    @on_trait_change('value')
    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.value)

    @on_trait_change('value')
    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, 'value')
        self.tc.assertEqual(new, self.value)

    @on_trait_change('value')
    def arg_check3(self, object, name, new):
        self.calls += 1
        self.tc.assertIs(object, self)
        self.tc.assertEqual(name, 'value')
        self.tc.assertEqual(new, self.value)

    @on_trait_change('value')
    def arg_check4(self, object, name, old, new):
        self.calls += 1
        self.tc.assertIs(object, self)
        self.tc.assertEqual(name, 'value')
        self.tc.assertEqual(old, (self.value - 1))
        self.tc.assertEqual(new, self.value)


class Instance1(HasTraits):

    ref = Instance(ArgCheckBase, ())

    calls = Int(0)
    exp_object = Any
    exp_name = Any
    dst_name = Any
    exp_old = Any
    exp_new = Any
    dst_new = Any
    tc = Any

    @on_trait_change('ref.value')
    def arg_check0(self):
        self.calls += 1

    @on_trait_change('ref.value')
    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.dst_new)

    @on_trait_change('ref.value')
    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, self.dst_name)
        self.tc.assertEqual(new, self.dst_new)

    @on_trait_change('ref.value')
    def arg_check3(self, object, name, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)

    @on_trait_change('ref.value')
    def arg_check4(self, object, name, old, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(old, self.exp_old)
        self.tc.assertEqual(new, self.exp_new)


class List1(HasTraits):

    refs = List(ArgCheckBase)
    calls = Int(0)

    exp_object = Any
    exp_name = Any
    type_old = Any
    exp_old = Any
    type_new = Any
    exp_new = Any
    tc = Any

    @on_trait_change('refs.value')
    def arg_check0(self):
        self.calls += 1

    @on_trait_change('refs.value')
    def arg_check3(self, object, name, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        if self.type_new is None:
            self.tc.assertEqual(new, self.exp_new)
        else:
            self.tc.assertIsInstance(new, self.type_new)

    @on_trait_change('refs.value')
    def arg_check4(self, object, name, old, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        if self.type_old is None:
            self.tc.assertEqual(old, self.exp_old)
        else:
            self.tc.assertIsInstance(old, self.type_old)
        if self.type_new is None:
            self.tc.assertEqual(new, self.exp_new)
        else:
            self.tc.assertIsInstance(new, self.type_new)


class List2(HasTraits):

    refs = List(ArgCheckBase)

    calls = Int(0)
    exp_new = Any
    tc = Any

    @on_trait_change('refs.value')
    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.exp_new)


class List3(HasTraits):

    refs = List(ArgCheckBase)

    calls = Int(0)
    exp_name = Any
    exp_new = Any
    tc = Any

    @on_trait_change('refs.value')
    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)


class Dict1(List1):
    refs = Dict(Int, ArgCheckBase)


class Dict2(HasTraits):

    refs = Dict(Int, ArgCheckBase)

    calls = Int(0)
    exp_new = Any
    tc = Any

    @on_trait_change('refs.value')
    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.exp_new)


class Dict3(HasTraits):

    refs = Dict(Int, ArgCheckBase)

    calls = Int(0)
    exp_name = Any
    exp_new = Any
    tc = Any

    @on_trait_change('refs.value')
    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)


class Complex(HasTraits):

    int1 = Int(0, test=True)
    int2 = Int(0)
    int3 = Int(0, test=True)
    tint1 = Int(0)
    tint2 = Int(0, test=True)
    tint3 = Int(0)
    ref = Instance(ArgCheckBase, ())

    calls = Int(0)
    exp_object = Any
    exp_name = Any
    dst_name = Any
    exp_old = Any
    exp_new = Any
    dst_new = Any
    tc = Any

    def arg_check0(self):
        self.calls += 1

    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.exp_new)

    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)

    def arg_check3(self, object, name, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)

    def arg_check4(self, object, name, old, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(old, self.exp_old)
        self.tc.assertEqual(new, self.exp_new)


class Link(HasTraits):

    next = Any
    prev = Any
    value = Int(0)


class LinkTest(HasTraits):

    head = Instance(Link)

    calls = Int(0)
    exp_object = Any
    exp_name = Any
    dst_name = Any
    exp_old = Any
    exp_new = Any
    dst_new = Any
    tc = Any

    def arg_check0(self):
        self.calls += 1

    def arg_check1(self, new):
        self.calls += 1
        self.tc.assertEqual(new, self.exp_new)

    def arg_check2(self, name, new):
        self.calls += 1
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)

    def arg_check3(self, object, name, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(new, self.exp_new)

    def arg_check4(self, object, name, old, new):
        self.calls += 1
        self.tc.assertIs(object, self.exp_object)
        self.tc.assertEqual(name, self.exp_name)
        self.tc.assertEqual(old, self.exp_old)
        self.tc.assertEqual(new, self.exp_new)


class PropertyDependsOn(HasTraits):

    sum = Property(depends_on='ref.[int1,int2,int3]')
    ref = Instance(ArgCheckBase, ())

    pcalls = Int(0)
    calls = Int(0)
    exp_old = Any
    exp_new = Any
    tc = Any

    @cached_property
    def _get_sum(self):
        self.pcalls += 1
        r = self.ref
        return (r.int1 + r.int2 + r.int3)

    def _sum_changed(self, old, new):
        self.calls += 1
        self.tc.assertEqual(old, self.exp_old)
        self.tc.assertEqual(new, self.exp_new)


class OnTraitChangeTest(unittest.TestCase):

    def setUp(self):
        def ignore(*args):
            pass
        push_exception_handler(handler=ignore, reraise_exceptions=True)

    def tearDown(self):
        pop_exception_handler()

    def test_arg_check_simple(self):
        ac = ArgCheckSimple(tc=self)
        ac.on_trait_change(ac.arg_check0, 'value')
        ac.on_trait_change(ac.arg_check1, 'value')
        ac.on_trait_change(ac.arg_check2, 'value')
        ac.on_trait_change(ac.arg_check3, 'value')
        ac.on_trait_change(ac.arg_check4, 'value')
        for i in range(3):
            ac.value += 1
        self.assertEqual(ac.calls, (3 * 5))
        ac.on_trait_change(ac.arg_check0, 'value', remove=True)
        ac.on_trait_change(ac.arg_check1, 'value', remove=True)
        ac.on_trait_change(ac.arg_check2, 'value', remove=True)
        ac.on_trait_change(ac.arg_check3, 'value', remove=True)
        ac.on_trait_change(ac.arg_check4, 'value', remove=True)
        for i in range(3):
            ac.value += 1
        self.assertEqual(ac.calls, (3 * 5))
        self.assertEqual(ac.value, (2 * 3))

    def test_arg_check_decorator(self):
        ac = ArgCheckDecorator(tc=self)
        for i in range(3):
            ac.value += 1
        self.assertEqual(ac.calls, (3 * 5))
        self.assertEqual(ac.value, 3)

    def test_instance1(self):
        i1 = Instance1(tc=self)
        for i in range(3):
            i1.set(exp_object=i1.ref, exp_name='value', dst_name='value',
                   exp_old=i, exp_new=(i + 1), dst_new=(i + 1))
            i1.ref.value = (i + 1)
        self.assertEqual(i1.calls, (3 * 5))
        self.assertEqual(i1.ref.value, 3)
        ref = ArgCheckBase()
        i1.set(exp_object=i1, exp_name='ref', dst_name='value',
               exp_old=i1.ref, exp_new=ref, dst_new=0)
        i1.ref = ref
        self.assertEqual(i1.calls, (4 * 5))
        self.assertEqual(i1.ref.value, 0)
        for i in range(3):
            i1.set(exp_object=i1.ref, exp_name='value', dst_name='value',
                   exp_old=i, exp_new=(i + 1), dst_new=(i + 1))
            i1.ref.value = (i + 1)
        self.assertEqual(i1.calls, (7 * 5))
        self.assertEqual(i1.ref.value, 3)

    def test_list1(self):
        l1 = List1(tc=self)
        for i in range(3):
            ac = ArgCheckBase()
            l1.set(exp_object=l1, exp_name='refs_items', type_old=None,
                   exp_old=Undefined, type_new=TraitListEvent)
            l1.refs.append(ac)
        #self.assertEqual(l1.calls, (3 * 3))  # FIXME
        for i in range(3):
            self.assertEqual(l1.refs[i].value, 0)
        refs = [ArgCheckBase(), ArgCheckBase(), ArgCheckBase()]
        l1.set(exp_object=l1, exp_name='refs', type_old=None,
               exp_old=l1.refs, type_new=TraitListObject)
        l1.refs = refs
        #self.assertEqual(l1.calls, (4 * 3))
        for i in range(3):
            self.assertEqual(l1.refs[i].value, 0)
        for i in range(3):
            for j in range(3):
                l1.set(exp_object=l1.refs[j], exp_name='value',
                       type_old=None, exp_old=i,
                       type_new=None, exp_new=(i + 1))
                l1.refs[j].value = (i + 1)
        #self.assertEqual(l1.calls, (13 * 3))
        for i in range(3):
            self.assertEqual(l1.refs[i].value, 3)

    def test_list2(self):
        self.check_list(List2(tc=self))

    def test_list3(self):
        self.check_list(List3(tc=self))

    def test_dict1(self):
        d1 = Dict1(tc=self)
        for i in range(3):
            ac = ArgCheckBase()
            d1.set(exp_object=d1, exp_name='refs_items', type_old=None,
                   exp_old=Undefined, type_new=TraitDictEvent)
            d1.refs[i] = ac
        #self.assertEqual(d1.calls, (3 * 3))  # FIXME
        for i in range(3):
            self.assertEqual(d1.refs[i].value, 0)
        refs = {0: ArgCheckBase(), 1: ArgCheckBase(), 2: ArgCheckBase()}
        d1.set(exp_object=d1, exp_name='refs', type_old=None,
               exp_old=d1.refs, type_new=TraitDictObject)
        d1.refs = refs
        #self.assertEqual(d1.calls, (4 * 3))
        for i in range(3):
            self.assertEqual(d1.refs[i].value, 0)
        for i in range(3):
            for j in range(3):
                d1.set(exp_object=d1.refs[j], exp_name='value',
                       type_old=None, exp_old=i,
                       type_new=None, exp_new=(i + 1))
                d1.refs[j].value = (i + 1)
        #self.assertEqual(d1.calls, (13 * 3))
        for i in range(3):
            self.assertEqual(d1.refs[i].value, 3)

    def test_dict2(self):
        self.check_dict(Dict2(tc=self))

    def test_dict3(self):
        self.check_dict(Dict3(tc=self))

    def test_pattern_list1(self):
        c = Complex(tc=self)
        self.check_complex(c, c, 'int1, int2, int3',
                           ['int1', 'int2', 'int3'],
                           ['tint1', 'tint2', 'tint3'])

    def test_pattern_list2(self):
        c = Complex(tc=self)
        self.check_complex(c, c, ['int1', 'int2', 'int3'],
                           ['int1', 'int2', 'int3'],
                           ['tint1', 'tint2', 'tint3'])

    def test_pattern_list3(self):
        c = Complex(tc=self)
        self.check_complex(c, c.ref, 'ref.[int1, int2, int3]',
                           ['int1', 'int2', 'int3'],
                           ['tint1', 'tint2', 'tint3'])

    def test_pattern_list4(self):
        c = Complex(tc=self)
        handlers = [c.arg_check0, c.arg_check3, c.arg_check4]
        n = len(handlers)
        pattern = 'ref.[int1,int2,int3]'
        self.multi_register(c, handlers, pattern)
        r0 = c.ref
        r1 = ArgCheckBase()
        c.set(exp_object=c, exp_name='ref', exp_old=r0, exp_new=r1)
        c.ref = r1
        c.set(exp_old=r1, exp_new=r0)
        c.ref = r0
        self.assertEqual(c.calls, 2 * n)
        self.multi_register(c, handlers, pattern, remove=True)
        c.ref = r1
        c.ref = r0
        self.assertEqual(c.calls, 2 * n)

    def test_pattern_list5(self):
        c = Complex(tc=self)
        c.on_trait_change(c.arg_check1, 'ref.[int1,int2,int3]')
        self.assertRaises(TraitError, c.set, ref=ArgCheckBase())

    def test_pattern_list6(self):
        c = Complex(tc=self)
        c.on_trait_change(c.arg_check2, 'ref.[int1,int2,int3]')
        self.assertRaises(TraitError, c.set, ref=ArgCheckBase())

    def test_pattern_list7(self):
        c = Complex(tc=self)
        self.check_complex(c, c, '+test', ['int1', 'int3', 'tint2'],
                           ['int2', 'tint1', 'tint3'])

    def test_pattern_list8(self):
        c = Complex(tc=self)
        self.check_complex(c, c, 'int+test',
                           ['int1', 'int3'],
                           ['int2', 'tint1', 'tint2', 'tint3'])

    def test_pattern_list9(self):
        c = Complex(tc=self)
        self.check_complex(c, c, 'int-test', ['int2'],
                           ['int1', 'int3', 'tint4', 'tint5', 'tint6'])

    def test_pattern_list10(self):
        c = Complex(tc=self)
        self.check_complex(c, c, 'int+',
                           ['int1', 'int2', 'int3'],
                           ['tint1', 'tint2', 'tint3'])

    def test_pattern_list11(self):
        c = Complex(tc=self)
        self.check_complex(c, c, 'int-',
                           ['int1', 'int2', 'int3'],
                           ['tint1', 'tint2', 'tint3'])

    def test_pattern_list12(self):
        c = Complex(tc=self)
        self.check_complex(c, c, 'int+test,tint-test',
                           ['int1', 'int3', 'tint1', 'tint3'],
                           ['int2', 'tint2'])

    def test_pattern_list13(self):
        c = Complex(tc=self)
        self.check_complex(c, c.ref, 'ref.[int+test,tint-test]',
                           ['int1', 'int3', 'tint1', 'tint3'],
                           ['int2', 'tint2'])

    def test_cycle1(self):
        lt = LinkTest(tc=self, head=self.build_list())
        handlers = [lt.arg_check0, lt.arg_check1, lt.arg_check2, lt.arg_check3,
                    lt.arg_check4]
        nh = len(handlers)
        self.multi_register(lt, handlers, 'head.next*.value')
        cur = lt.head
        for i in range(4):
            lt.set(exp_object=cur, exp_name='value', exp_old=10 * i,
                   exp_new=(10 * i) + 1)
            cur.value = (10 * i) + 1
            cur = cur.next
        self.assertEqual(lt.calls, 4 * nh)
        self.multi_register(lt, handlers, 'head.next*.value', remove=True)
        cur = lt.head
        for i in range(4):
            cur.value = (10 * i) + 2
            cur = cur.next
        self.assertEqual(lt.calls, 4 * nh)

    def test_cycle2(self):
        lt = LinkTest(tc=self, head=self.build_list())
        handlers = [lt.arg_check0, lt.arg_check1, lt.arg_check2, lt.arg_check3,
                    lt.arg_check4]
        nh = len(handlers)
        self.multi_register(lt, handlers, 'head.[next,prev]*.value')
        cur = lt.head
        for i in range(4):
            lt.set(exp_object=cur, exp_name='value', exp_old=10 * i,
                   exp_new=(10 * i) + 1)
            cur.value = (10 * i) + 1
            cur = cur.next
        self.assertEqual(lt.calls, 4 * nh)
        self.multi_register(lt, handlers, 'head.[next,prev]*.value',
                            remove=True)
        cur = lt.head
        for i in range(4):
            cur.value = (10 * i) + 2
            cur = cur.next
        self.assertEqual(lt.calls, 4 * nh)

    def test_cycle3(self):
        lt = LinkTest(tc=self, head=self.build_list())
        handlers = [lt.arg_check0, lt.arg_check3, lt.arg_check4]
        nh = len(handlers)
        self.multi_register(lt, handlers, 'head.next*.value')
        link = self.new_link(lt, lt.head, 1)
        self.assertEqual(lt.calls, nh)
        link = self.new_link(lt, link, 2)
        self.assertEqual(lt.calls, 2 * nh)
        self.multi_register(lt, handlers, 'head.next*.value', remove=True)
        link = self.new_link(lt, link, 3)
        self.assertEqual(lt.calls, 2 * nh)

    def test_property(self):
        pdo = PropertyDependsOn(tc=self)
        sum = pdo.sum
        self.assertEqual(sum, 0)
        for n in ['int1', 'int2', 'int3']:
            for i in range(3):
                pdo.set(exp_old=sum, exp_new=sum + 1)
                setattr(pdo.ref, n, i + 1)
                sum += 1
        self.assertEqual(pdo.pcalls, (3 * 3) + 1)
        self.assertEqual(pdo.calls, 3 * 3)
        for i in range(10):
            x = pdo.sum
        self.assertEqual(pdo.pcalls, (3 * 3) + 1)
        pdo.set(exp_old=sum, exp_new=60)
        old_ref = pdo.ref
        pdo.ref = ArgCheckBase(int1=10, int2=20, int3=30)
        self.assertEqual(pdo.pcalls, (3 * 3) + 2)
        self.assertEqual(pdo.calls, (3 * 3) + 1)
        sum = 60
        for n in ['int1', 'int2', 'int3']:
            for i in range(3):
                pdo.set(exp_old=sum, exp_new=sum + 1)
                setattr(pdo.ref, n, getattr(pdo.ref, n) + 1)
                sum += 1
        self.assertEqual(pdo.pcalls, (2 * 3 * 3) + 2)
        self.assertEqual(pdo.calls, (2 * 3 * 3) + 1)
        for n in ['int1', 'int2', 'int3']:
            for i in range(3):
                setattr(old_ref, n, getattr(old_ref, n) + 1)
        self.assertEqual(pdo.pcalls, (2 * 3 * 3) + 2)
        self.assertEqual(pdo.calls, (2 * 3 * 3) + 1)
        self.assertEqual(pdo.sum, sum)
        self.assertEqual(pdo.pcalls, (2 * 3 * 3) + 2)

    def check_list(self, l):
        for i in range(3):
            ac = ArgCheckBase()
            self.assertRaises(TraitError, l.refs.append, ac)
        self.assertEqual(l.calls, 0)
        for i in range(3):
            self.assertEqual(l.refs[i].value, 0)
        refs = [ArgCheckBase(), ArgCheckBase(), ArgCheckBase()]
        self.assertRaises(TraitError, l.set, refs=refs)
        self.assertEqual(l.calls, 0)
        for i in range(3):
            self.assertEqual(l.refs[i].value, 0)
        for i in range(3):
            for j in range(3):
                l.exp_new = (i + 1)
                l.refs[j].value = (i + 1)
        self.assertEqual(l.calls, 0)
        for i in range(3):
            self.assertEqual(l.refs[i].value, 3)

    def check_dict(self, d):
        for i in range(3):
            ac = ArgCheckBase()
            self.assertRaises(TraitError, d.refs.setdefault, i, ac)
        self.assertEqual(d.calls, 0)
        for i in range(3):
            self.assertEqual(d.refs[i].value, 0)
        refs = {0: ArgCheckBase(), 1: ArgCheckBase(), 2: ArgCheckBase()}
        self.assertRaises(TraitError, d.set, refs=refs)
        self.assertEqual(d.calls, 0)
        for i in range(3):
            self.assertEqual(d.refs[i].value, 0)
        for i in range(3):
            for j in range(3):
                d.exp_new = (i + 1)
                d.refs[j].value = (i + 1)
        self.assertEqual(d.calls, 0)
        for i in range(3):
            self.assertEqual(d.refs[i].value, 3)

    def check_complex(self, c, r, pattern, names, other=[]):
        handlers = [c.arg_check0, c.arg_check1, c.arg_check2, c.arg_check3,
                    c.arg_check4]
        nh = len(handlers)
        nn = len(names)
        self.multi_register(c, handlers, pattern)
        for i in range(3):
            for n in names:
                c.set(exp_object=r, exp_name=n, exp_old=i,
                      exp_new=(i + 1))
                setattr(r, n, i + 1)
            for n in other:
                c.set(exp_object=r, exp_name=n, exp_old=i,
                      exp_new=(i + 1))
                setattr(r, n, i + 1)
        self.assertEqual(c.calls, 3 * nn * nh)
        self.multi_register(c, handlers, pattern, remove=True)
        for i in range(3):
            for n in names:
                setattr(r, n, i + 1)
            for n in other:
                setattr(r, n, i + 1)
        self.assertEqual(c.calls, 3 * nn * nh)

    def multi_register(self, object, handlers, pattern, remove=False):
        for handler in handlers:
            object.on_trait_change(handler, pattern, remove=remove)

    def build_list(self):
        l1 = Link(value=00)
        l2 = Link(value=10)
        l3 = Link(value=20)
        l4 = Link(value=30)
        l1.set(next=l2, prev=l4)
        l2.set(next=l3, prev=l1)
        l3.set(next=l4, prev=l2)
        l4.set(next=l1, prev=l3)
        return l1

    def new_link(self, lt, cur, value):
        link = Link(value=value, next=cur.next, prev=cur)
        cur.next.prev = link
        lt.set(exp_object=cur, exp_name='next', exp_old=cur.next,
               exp_new=link)
        cur.next = link
        return link

# Run the unit tests (if invoked from the command line):
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_integer
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------
"""
Tests for the Int trait type.

"""

from __future__ import absolute_import

import decimal
import sys

try:
    import numpy
except ImportError:
    numpy_available = False
else:
    numpy_available = True

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Int, TraitError


class A(HasTraits):
    integral = Int


class IntegerLike(object):
    def __index__(self):
        return 42


class Truncatable(object):
    def __int__(self):
        return 42


class TestInt(unittest.TestCase):
    def test_default(self):
        a = A()
        self.assertEqual(a.integral, 0)
        self.assertIs(type(a.integral), int)

    def test_accepts_int(self):
        a = A()
        a.integral = 23
        self.assertEqual(a.integral, 23)
        self.assertIs(type(a.integral), int)

    def test_accepts_small_long(self):
        a = A()
        a.integral = 23L
        # Check that type is stored as int where possible.
        self.assertEqual(a.integral, 23)
        self.assertIs(type(a.integral), int)

    def test_accepts_large_long(self):
        a = A()
        a.integral = long(sys.maxint)
        self.assertEqual(a.integral, sys.maxint)
        self.assertIs(type(a.integral), int)

        a.integral = sys.maxint + 1
        self.assertEqual(a.integral, sys.maxint + 1)
        self.assertIs(type(a.integral), long)

    def test_accepts_bool(self):
        a = A()
        a.integral = True
        self.assertEqual(a.integral, 1)
        self.assertIs(type(a.integral), int)

    def test_respects_dunder_index(self):
        a = A()
        a.integral = IntegerLike()
        self.assertEqual(a.integral, 42)
        self.assertIs(type(a.integral), int)

    def test_rejects_dunder_int(self):
        a = A()
        with self.assertRaises(TraitError):
            a.integral = Truncatable()

    def test_rejects_floating_point_types(self):
        a = A()
        with self.assertRaises(TraitError):
            a.integral = 23.0
        with self.assertRaises(TraitError):
            a.integral = decimal.Decimal(23)

    def test_rejects_string(self):
        a = A()
        with self.assertRaises(TraitError):
            a.integral = "23"

    @unittest.skipUnless(numpy_available, "numpy not available")
    def test_numpy_types(self):
        a = A()
        a.integral = numpy.int32(23)
        self.assertEqual(a.integral, 23)
        self.assertIn(type(a.integral), (int, long))

        a.integral = numpy.uint64(2**63 + 2)
        self.assertEqual(a.integral, 2**63 + 2)
        self.assertIs(type(a.integral), long)

        with self.assertRaises(TraitError):
            a.integral = numpy.float32(4.0)
        with self.assertRaises(TraitError):
            a.integral = numpy.float64(4.0)

########NEW FILE########
__FILENAME__ = test_interfaces
#  Unit test case for testing interfaces and adaptation.
#
#  Written by: David C. Morrill
#
#  Date: 4/10/2007
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
""" Unit test case for testing interfaces and adaptation.
"""

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from traits.api import (HasTraits, Adapter, AdaptsTo, Instance, Int, Interface,
                        List, provides, register_factory, Supports, TraitError)
from traits.adaptation.api import reset_global_adaptation_manager


class IFoo(Interface):

    def get_foo(self):
        """ Returns the current foo. """


class IFooPlus(IFoo):

    def get_foo_plus(self):
        """ Returns even more foo. """


class IAverage(Interface):

    def get_average(self):
        """ Returns the average value for the object. """


class IList(Interface):

    def get_list(self):
        """ Returns the list value for the object. """


class Sample(HasTraits):

    s1 = Int(1, sample=True)
    s2 = Int(2, sample=True)
    s3 = Int(3, sample=True)
    i1 = Int(4)
    i2 = Int(5)
    i3 = Int(6)


@provides(IList)
class SampleList(HasTraits):
    """SampleList docstring."""

    data = List(Int, [10, 20, 30])

    def get_list(self):
        return self.data


@provides(IList, IAverage)
class SampleAverage(HasTraits):

    data = List(Int, [100, 200, 300])

    def get_list(self):
        return self.data

    def get_average(self):
        value = self.get_list()
        if len(value) == 0:
            return 0.0

        average = 0.0
        for item in value:
            average += item
        return (average / len(value))


class SampleBad(HasTraits):
    pass


class TraitsHolder(HasTraits):

    a_no = Instance(IAverage, adapt='no')
    a_yes = Instance(IAverage, adapt='yes')
    a_default = Instance(IAverage, adapt='default')
    list_adapted_to = Supports(IList)
    foo_adapted_to = Supports(IFoo)
    foo_plus_adapted_to = Supports(IFooPlus)
    list_adapts_to = AdaptsTo(IList)
    foo_adapts_to = AdaptsTo(IFoo)
    foo_plus_adapts_to = AdaptsTo(IFooPlus)


class SampleListAdapter(Adapter):
    def get_list(self):
        obj = self.adaptee
        return [getattr(obj, name)
                for name in obj.trait_names(sample=True)]


class ListAverageAdapter(Adapter):
    def get_average(self):
        value = self.adaptee.get_list()
        if len(value) == 0:
            return 0.0

        average = 0.0
        for item in value:
            average += item
        return (average / len(value))


class SampleFooAdapter(HasTraits):

    object = Instance(Sample)

    def __init__(self, object):
        self.object = object

    def get_foo(self):
        object = self.object
        return (object.s1 + object.s2 + object.s3)


class FooPlusAdapter(object):

    def __init__(self, obj):
        self.obj = obj

    def get_foo(self):
        return self.obj.get_foo()

    def get_foo_plus(self):
        return (self.obj.get_foo() + 1)


class InterfacesTest(unittest.TestCase):

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        reset_global_adaptation_manager()

        # Register adapters.
        register_factory(SampleListAdapter, Sample, IList)
        register_factory(ListAverageAdapter, IList, IAverage)
        register_factory(SampleFooAdapter, Sample, IFoo)
        register_factory(FooPlusAdapter, IFoo, IFooPlus)

    #### Tests ################################################################

    def test_provides_none(self):
        @provides()
        class Test(HasTraits):
            pass

    def test_provides_one(self):
        @provides(IFoo)
        class Test(HasTraits):
            pass

    def test_provides_multi(self):
        @provides(IFoo, IAverage, IList)
        class Test (HasTraits):
            pass

    def test_provides_extended(self):
        """ Ensure that subclasses of Interfaces imply the superinterface.
        """
        @provides(IFooPlus)
        class Test(HasTraits):
            pass

        ta = TraitsHolder()
        ta.foo_adapted_to = Test()

    def test_provides_bad(self):
        with self.assertRaises(Exception):
            @provides(Sample)
            class Test(HasTraits):
                pass

    def test_instance_adapt_no(self):
        ta = TraitsHolder()

        # Verify that SampleAverage() does not raise an error (it is an
        # instance of the IAverage interface).
        try:
            ta.a_no = SampleAverage()
        except TraitError:
            self.fail("Setting instance of interface should not require "
                      "adaptation")

        # These are not instances of the IAverage interface, and therefore
        # cannot be set to the trait.
        self.assertRaises(TraitError, ta.set, a_no=SampleList())
        self.assertRaises(TraitError, ta.set, a_no=Sample())
        self.assertRaises(TraitError, ta.set, a_no=SampleBad())

    def test_instance_adapt_yes(self):
        ta = TraitsHolder()

        ta.a_yes = object = SampleAverage()
        self.assertEqual(ta.a_yes.get_average(), 200.0)
        self.assertIsInstance(ta.a_yes, SampleAverage)
        self.assertFalse(hasattr(ta, 'a_yes_'))

        ta.a_yes = object = SampleList()
        self.assertEqual(ta.a_yes.get_average(), 20.0)
        self.assertIsInstance(ta.a_yes, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_yes_'))

        ta.a_yes = object = Sample()
        self.assertEqual(ta.a_yes.get_average(), 2.0)
        self.assertIsInstance(ta.a_yes, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_yes_'))

        self.assertRaises(TraitError, ta.set, a_yes=SampleBad())

    def test_instance_adapt_default(self):
        ta = TraitsHolder()

        ta.a_default = object = SampleAverage()
        self.assertEqual(ta.a_default.get_average(), 200.0)
        self.assertIsInstance(ta.a_default, SampleAverage)
        self.assertFalse(hasattr(ta, 'a_default_'))

        ta.a_default = object = SampleList()
        self.assertEqual(ta.a_default.get_average(), 20.0)
        self.assertIsInstance(ta.a_default, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_default_'))

        ta.a_default = object = Sample()
        self.assertEqual(ta.a_default.get_average(), 2.0)
        self.assertIsInstance(ta.a_default, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_default_'))

        ta.a_default = object = SampleBad()
        self.assertEqual(ta.a_default, None)
        self.assertFalse(hasattr(ta, 'a_default_'))

    def test_adapted_to(self):
        ta = TraitsHolder()

        ta.list_adapted_to = object = Sample()
        result = ta.list_adapted_to.get_list()
        self.assertEqual(len(result), 3)
        for n in [1, 2, 3]:
            self.assertIn(n, result)
        self.assertIsInstance(ta.list_adapted_to, SampleListAdapter)
        self.assertEqual(ta.list_adapted_to_, object)

        ta.foo_adapted_to = object = Sample()
        self.assertEqual(ta.foo_adapted_to.get_foo(), 6)
        self.assertIsInstance(ta.foo_adapted_to, SampleFooAdapter)
        self.assertEqual(ta.foo_adapted_to_, object)

        ta.foo_plus_adapted_to = object = Sample(s1=5, s2=10, s3=15)
        self.assertEqual(ta.foo_plus_adapted_to.get_foo(), 30)
        self.assertEqual(ta.foo_plus_adapted_to.get_foo_plus(), 31)
        self.assertIsInstance(ta.foo_plus_adapted_to, FooPlusAdapter)
        self.assertEqual(ta.foo_plus_adapted_to_, object)

    def test_adapts_to(self):
        ta = TraitsHolder()

        ta.list_adapts_to = object = Sample()
        self.assertEqual(ta.list_adapts_to, object)
        result = ta.list_adapts_to_.get_list()
        self.assertEqual(len(result), 3)
        for n in [1, 2, 3]:
            self.assertIn(n, result)
        self.assertIsInstance(ta.list_adapts_to_, SampleListAdapter)

        ta.foo_adapts_to = object = Sample()
        self.assertEqual(ta.foo_adapts_to, object)
        self.assertEqual(ta.foo_adapts_to_.get_foo(), 6)
        self.assertIsInstance(ta.foo_adapts_to_, SampleFooAdapter)

        ta.foo_plus_adapts_to = object = Sample(s1=5, s2=10, s3=15)
        self.assertEqual(ta.foo_plus_adapts_to, object)
        self.assertEqual(ta.foo_plus_adapts_to_.get_foo(), 30)
        self.assertEqual(ta.foo_plus_adapts_to_.get_foo_plus(), 31)
        self.assertIsInstance(ta.foo_plus_adapts_to_, FooPlusAdapter)

    def test_decorated_class_name_and_docstring(self):
        self.assertEqual(SampleList.__name__, 'SampleList')
        self.assertEqual(SampleList.__doc__, "SampleList docstring.")

# Run the unit tests (if invoked from the command line):
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_interfaces_with_implements
#  Unit test case for testing interfaces and adaptation.
#
#  Written by: David C. Morrill
#
#  Date: 4/10/2007
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
""" Unit test case for testing interfaces and adaptation.

This file is equivalent to test_interfaces.py, only using the deprecated
'implements' and 'adapts' functions.

"""

from __future__ import absolute_import

import sys

from traits.testing.unittest_tools import unittest
from traits.adaptation.api import get_global_adaptation_manager, \
    set_global_adaptation_manager
from traits.api import HasTraits, Adapter, adapts, AdaptsTo, \
    implements, Instance, Int, Interface, List, Supports, TraitError


# Using the deprecated class advisor "adapts", the registration of adapters
# occurs globally at class definition time. Since other tests will reset the
# global adaptation manager, the registration will be lost.
# That's why we save a reference to the current global adaptation manager.
_adaptation_manager = get_global_adaptation_manager()


#------------------------------------------------------------------------------
#  Test 'Interface' definitions:
#------------------------------------------------------------------------------

# 'adapts' and 'implements' are not supported in Python 3.
if sys.version_info < (3,):

    class IFoo(Interface):

        def get_foo(self):
            """ Returns the current foo. """


    class IFooPlus(IFoo):

        def get_foo_plus(self):
            """ Returns even more foo. """


    class IAverage(Interface):

        def get_average(self):
            """ Returns the average value for the object. """


    class IList(Interface):

        def get_list(self):
            """ Returns the list value for the object. """


    class Sample(HasTraits):
        s1 = Int(1, sample=True)
        s2 = Int(2, sample=True)
        s3 = Int(3, sample=True)
        i1 = Int(4)
        i2 = Int(5)
        i3 = Int(6)


    class SampleList(HasTraits):

        implements(IList)

        data = List(Int, [10, 20, 30])

        def get_list(self):
            return self.data


    class SampleAverage(HasTraits):

        implements(IList, IAverage)

        data = List(Int, [100, 200, 300])

        def get_list(self):
            return self.data

        def get_average(self):
            value = self.get_list()
            if len(value) == 0:
                return 0.0

            average = 0.0
            for item in value:
                average += item
            return (average / len(value))


    class SampleBad(HasTraits):
        pass


    class TraitsHolder(HasTraits):

        a_no = Instance(IAverage, adapt='no')
        a_yes = Instance(IAverage, adapt='yes')
        a_default = Instance(IAverage, adapt='default')
        list_adapted_to = Supports(IList)
        foo_adapted_to = Supports(IFoo)
        foo_plus_adapted_to = Supports(IFooPlus)
        list_adapts_to = AdaptsTo(IList)
        foo_adapts_to = AdaptsTo(IFoo)
        foo_plus_adapts_to = AdaptsTo(IFooPlus)


    class SampleListAdapter(Adapter):
        adapts(Sample, IList)

        def get_list(self):
            obj = self.adaptee
            return [getattr(obj, name)
                    for name in obj.trait_names(sample=True)]


    class ListAverageAdapter(Adapter):

        adapts(IList, IAverage)

        def get_average(self):
            value = self.adaptee.get_list()
            if len(value) == 0:
                return 0.0

            average = 0.0
            for item in value:
                average += item
            return (average / len(value))


    class SampleFooAdapter(HasTraits):

        adapts(Sample, IFoo)

        object = Instance(Sample)

        def __init__(self, object):
            self.object = object

        def get_foo(self):
            object = self.object
            return (object.s1 + object.s2 + object.s3)


    class FooPlusAdapter(object):

        def __init__(self, obj):
            self.obj = obj

        def get_foo(self):
            return self.obj.get_foo()

        def get_foo_plus(self):
            return (self.obj.get_foo() + 1)

    adapts(FooPlusAdapter, IFoo, IFooPlus)


@unittest.skipUnless(sys.version_info < (3,),
                     "The 'adapts' and 'implements' class advisors "
                     "are not supported in Python 3.")
class InterfacesTest(unittest.TestCase):

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        set_global_adaptation_manager(_adaptation_manager)

    #### Tests ################################################################

    def test_implements_none(self):
        class Test(HasTraits):
            implements()

    def test_implements_one(self):
        class Test(HasTraits):
            implements(IFoo)

    def test_implements_multi(self):
        class Test(HasTraits):
            implements(IFoo, IAverage, IList)

    def test_implements_extended(self):
        """ Ensure that subclasses of Interfaces imply the superinterface.
        """
        class Test(HasTraits):
            implements(IFooPlus)

        ta = TraitsHolder()
        ta.foo_adapted_to = Test()

    def test_implements_bad(self):
        self.assertRaises(TraitError, self.implements_bad)

    def test_instance_adapt_no(self):
        ta = TraitsHolder()

        # Verify that SampleAverage() does not raise an error (it is an
        # instance of the IAverage interface).
        try:
            ta.a_no = SampleAverage()
        except TraitError:
            self.fail("Setting instance of interface should not require "
                      "adaptation")

        # These are not instances of the IAverage interface, and therefore
        # cannot be set to the trait.
        self.assertRaises(TraitError, ta.set, a_no=SampleList())
        self.assertRaises(TraitError, ta.set, a_no=Sample())
        self.assertRaises(TraitError, ta.set, a_no=SampleBad())

    def test_instance_adapt_yes(self):
        ta = TraitsHolder()

        ta.a_yes = object = SampleAverage()
        self.assertEqual(ta.a_yes.get_average(), 200.0)
        self.assertIsInstance(ta.a_yes, SampleAverage)
        self.assertFalse(hasattr(ta, 'a_yes_'))

        ta.a_yes = object = SampleList()
        self.assertEqual(ta.a_yes.get_average(), 20.0)
        self.assertIsInstance(ta.a_yes, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_yes_'))

        ta.a_yes = object = Sample()
        self.assertEqual(ta.a_yes.get_average(), 2.0)
        self.assertIsInstance(ta.a_yes, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_yes_'))

        self.assertRaises(TraitError, ta.set, a_yes=SampleBad())

    def test_instance_adapt_default(self):
        ta = TraitsHolder()

        ta.a_default = object = SampleAverage()
        self.assertEqual(ta.a_default.get_average(), 200.0)
        self.assertIsInstance(ta.a_default, SampleAverage)
        self.assertFalse(hasattr(ta, 'a_default_'))

        ta.a_default = object = SampleList()
        self.assertEqual(ta.a_default.get_average(), 20.0)
        self.assertIsInstance(ta.a_default, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_default_'))

        ta.a_default = object = Sample()
        self.assertEqual(ta.a_default.get_average(), 2.0)
        self.assertIsInstance(ta.a_default, ListAverageAdapter)
        self.assertFalse(hasattr(ta, 'a_default_'))

        ta.a_default = object = SampleBad()
        self.assertEqual(ta.a_default, None)
        self.assertFalse(hasattr(ta, 'a_default_'))

    def test_adapted_to(self):
        ta = TraitsHolder()

        ta.list_adapted_to = object = Sample()
        result = ta.list_adapted_to.get_list()
        self.assertEqual(len(result), 3)
        for n in [1, 2, 3]:
            self.assertIn(n, result)
        self.assertIsInstance(ta.list_adapted_to, SampleListAdapter)
        self.assertEqual(ta.list_adapted_to_, object)

        ta.foo_adapted_to = object = Sample()
        self.assertEqual(ta.foo_adapted_to.get_foo(), 6)
        self.assertIsInstance(ta.foo_adapted_to, SampleFooAdapter)
        self.assertEqual(ta.foo_adapted_to_, object)

        ta.foo_plus_adapted_to = object = Sample(s1=5, s2=10, s3=15)
        self.assertEqual(ta.foo_plus_adapted_to.get_foo(), 30)
        self.assertEqual(ta.foo_plus_adapted_to.get_foo_plus(), 31)
        self.assertIsInstance(ta.foo_plus_adapted_to, FooPlusAdapter)
        self.assertEqual(ta.foo_plus_adapted_to_, object)

    def test_adapts_to(self):
        ta = TraitsHolder()

        ta.list_adapts_to = object = Sample()
        self.assertEqual(ta.list_adapts_to, object)
        result = ta.list_adapts_to_.get_list()
        self.assertEqual(len(result), 3)
        for n in [1, 2, 3]:
            self.assertIn(n, result)
        self.assertIsInstance(ta.list_adapts_to_, SampleListAdapter)

        ta.foo_adapts_to = object = Sample()
        self.assertEqual(ta.foo_adapts_to, object)
        self.assertEqual(ta.foo_adapts_to_.get_foo(), 6)
        self.assertIsInstance(ta.foo_adapts_to_, SampleFooAdapter)

        ta.foo_plus_adapts_to = object = Sample(s1=5, s2=10, s3=15)
        self.assertEqual(ta.foo_plus_adapts_to, object)
        self.assertEqual(ta.foo_plus_adapts_to_.get_foo(), 30)
        self.assertEqual(ta.foo_plus_adapts_to_.get_foo_plus(), 31)
        self.assertIsInstance(ta.foo_plus_adapts_to_, FooPlusAdapter)

    #-- Helper Methods --------------------------------------------------------

    def implements_bad(self):
        class Test(HasTraits):
            implements(Sample)

# Run the unit tests (if invoked from the command line):
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_interface_checker
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

""" Tests to help find out if we can do type-safe casting. """

from __future__ import absolute_import

# Standard library imports.
from traits.testing.unittest_tools import unittest

# Enthought library imports.
from traits.adaptation.api import reset_global_adaptation_manager
from traits.api import Adapter, HasTraits, Instance, Int, Interface, \
    provides, register_factory

# Local imports.
from traits.interface_checker import InterfaceError, check_implements

# Make sure implicit interface checking is turned off, so that we can make the
# checks explicitly:
from traits import has_traits
has_traits.CHECK_INTERFACES = 0


class InterfaceCheckerTestCase(unittest.TestCase):
    """ Tests to help find out if we can do type-safe casting. """

    ###########################################################################
    # 'TestCase' interface.
    ###########################################################################

    def setUp(self):
        """ Prepares the test fixture before each test method is called. """
        reset_global_adaptation_manager()

        return

    def tearDown(self):
        """ Called immediately after each test method has been called. """

        return

    ###########################################################################
    # Tests.
    ###########################################################################

    def test_non_traits_class(self):
        """ non-traits class """

        class IFoo(Interface):
            def foo(self):
                pass

        # A class that *does* implement the interface.
        @provides(IFoo)
        class Foo(object):

            def foo(self):
                pass

        # The checker will raise an exception if the class does not implement
        # the interface.
        check_implements(Foo, IFoo, 2)

        return

    def test_single_interface(self):
        """ single interface """

        class IFoo(Interface):
            x = Int

        # A class that *does* implement the interface.
        @provides(IFoo)
        class Foo(HasTraits):

            x = Int

        # The checker will raise an exception if the class does not implement
        # the interface.
        check_implements(Foo, IFoo, 2)

        return

    def test_single_interface_with_invalid_method_signature(self):
        """ single interface with invalid method signature """

        class IFoo(Interface):
            def foo(self):
                pass

        # A class that does *not* implement the interface.
        @provides(IFoo)
        class Foo(HasTraits):
            # Extra argument!
            def foo(self, x):
                pass

        self.assertRaises(InterfaceError, check_implements, Foo, IFoo, 2)

        return

    def test_single_interface_with_missing_trait(self):
        """ single interface with missing trait """

        class IFoo(Interface):
            x = Int

        # A class that does *not* implement the interface.
        @provides(IFoo)
        class Foo(HasTraits):
            pass

        self.assertRaises(InterfaceError, check_implements, Foo, IFoo, 2)
        return

    def test_single_interface_with_missing_method(self):
        """ single interface with missing method """

        class IFoo(Interface):
            def method(self):
                pass

        # A class that does *not* implement the interface.
        @provides(IFoo)
        class Foo(HasTraits):
            pass

        self.assertRaises(InterfaceError, check_implements, Foo, IFoo, 2)

        return

    def test_multiple_interfaces(self):
        """ multiple interfaces """

        class IFoo(Interface):
            x = Int

        class IBar(Interface):
            y = Int

        class IBaz(Interface):
            z = Int

        # A class that *does* implement the interface.
        @provides(IFoo, IBar, IBaz)
        class Foo(HasTraits):
            x = Int
            y = Int
            z = Int

        # The checker will raise an exception if the class does not implement
        # the interface.
        check_implements(Foo, [IFoo, IBar, IBaz], 2)

        return

    def test_multiple_interfaces_with_invalid_method_signature(self):
        """ multiple interfaces with invalid method signature """

        class IFoo(Interface):
            def foo(self):
                pass

        class IBar(Interface):
            def bar(self):
                pass

        class IBaz(Interface):
            def baz(self):
                pass

        # A class that does *not* implement the interface.
        @provides(IFoo, IBar, IBaz)
        class Foo(HasTraits):

            def foo(self):
                pass

            def bar(self):
                pass

            # Extra argument!
            def baz(self, x):
                pass

        self.assertRaises(
            InterfaceError, check_implements, Foo, [IFoo, IBar, IBaz], 2
        )

        return

    def test_multiple_interfaces_with_missing_trait(self):
        """ multiple interfaces with missing trait """

        class IFoo(Interface):
            x = Int

        class IBar(Interface):
            y = Int

        class IBaz(Interface):
            z = Int

        # A class that does *not* implement the interface.
        @provides(IFoo, IBar, IBaz)
        class Foo(HasTraits):

            x = Int
            y = Int

        self.assertRaises(
            InterfaceError, check_implements, Foo, [IFoo, IBar, IBaz], 2
        )

        return

    def test_multiple_interfaces_with_missing_method(self):
        """ multiple interfaces with missing method """

        class IFoo(Interface):
            def foo(self):
                pass

        class IBar(Interface):
            def bar(self):
                pass

        class IBaz(Interface):
            def baz(self):
                pass

        # A class that does *not* implement the interface.
        @provides(IFoo, IBar, IBaz)
        class Foo(HasTraits):

            def foo(self):
                pass

            def bar(self):
                pass

        self.assertRaises(
            InterfaceError, check_implements, Foo, [IFoo, IBar, IBaz], 2
        )

        return

    def test_inherited_interfaces(self):
        """ inherited interfaces """

        class IFoo(Interface):
            x = Int

        class IBar(IFoo):
            y = Int

        class IBaz(IBar):
            z = Int

        # A class that *does* implement the interface.
        @provides(IBaz)
        class Foo(HasTraits):
            x = Int
            y = Int
            z = Int

        # The checker will raise an exception if the class does not implement
        # the interface.
        check_implements(Foo, IBaz, 2)

        return

    def test_inherited_interfaces_with_invalid_method_signature(self):
        """ inherited with invalid method signature """

        class IFoo(Interface):
            def foo(self):
                pass

        class IBar(IFoo):
            def bar(self):
                pass

        class IBaz(IBar):
            def baz(self):
                pass

        # A class that does *not* implement the interface.
        @provides(IBaz)
        class Foo(HasTraits):

            def foo(self):
                pass

            def bar(self):
                pass

            # Extra argument!
            def baz(self, x):
                pass

        self.assertRaises(InterfaceError, check_implements, Foo, IBaz, 2)

        return

    def test_inherited_interfaces_with_missing_trait(self):
        """ inherited interfaces with missing trait """

        class IFoo(Interface):
            x = Int

        class IBar(IFoo):
            y = Int

        class IBaz(IBar):
            z = Int

        # A class that does *not* implement the interface.
        @provides(IBaz)
        class Foo(HasTraits):

            x = Int
            y = Int

        self.assertRaises(InterfaceError, check_implements, Foo, IBaz, 2)

        return

    def test_inherited_interfaces_with_missing_method(self):
        """ inherited interfaces with missing method """

        class IFoo(Interface):
            def foo(self):
                pass

        class IBar(IFoo):
            def bar(self):
                pass

        class IBaz(IBar):
            def baz(self):
                pass

        # A class that does *not* implement the interface.
        @provides(IBaz)
        class Foo(HasTraits):

            def foo(self):
                pass

            def bar(self):
                pass

        self.assertRaises(InterfaceError, check_implements, Foo, IBaz, 2)

        return

    # Make sure interfaces and adaptation etc still work with the 'HasTraits'
    # version of 'Interface'!
    def test_instance(self):
        """ instance """

        class IFoo(Interface):
            pass

        @provides(IFoo)
        class Foo(HasTraits):
            pass

        class Bar(HasTraits):
            foo = Instance(IFoo)

        b = Bar(foo=Foo())

        return

    def test_callable(self):
        """ callable """

        class IFoo(Interface):
            pass

        @provides(IFoo)
        class Foo(HasTraits):
            pass

        f = Foo()
        self.assertEqual(f, IFoo(f))

        return

    def test_adaptation(self):
        """ adaptation """

        class IFoo(Interface):
            pass

        class Foo(HasTraits):
            pass

        @provides(IFoo)
        class FooToIFooAdapter(Adapter):
            pass

        register_factory(FooToIFooAdapter, Foo, IFoo)

        f = Foo()

        # Make sure adaptation works.
        i_foo = IFoo(f)

        self.assertNotEqual(None, i_foo)
        self.assertEqual(FooToIFooAdapter, type(i_foo))
        return


# Entry point for stand-alone testing.
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_int_range_long
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Int, Range, Long, TraitError


class A(HasTraits):
    i = Int
    l = Long
    r = Range(2L, 9223372036854775807L)


class TraitIntRangeLong(unittest.TestCase):
    def test_int(self):
        "Test to make sure it is legal to set an Int trait to a long value"
        a = A()
        a.i = 1
        a.i = 10L

    def test_long(self):
        "Test if it is legal to set a Long trait to an int value"
        a = A()
        a.l = 10
        a.l = 100L

    def test_range(self):
        "Test a range trait with longs being set to an int value"
        a = A()
        a.r = 256
        a.r = 20L
        self.assertRaises(TraitError, a.set, r=1L)
        self.assertRaises(TraitError, a.set, r=9223372036854775808L)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_keyword_args
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from ..api import HasTraits, Instance, Int

from traits.testing.unittest_tools import unittest


class Bar(HasTraits):
    b = Int(3)


class Foo(HasTraits):
    bar = Instance(Bar)


class KeyWordArgsTest(unittest.TestCase):
    def test_using_kw(self):
        bar = Bar(b=5)
        foo = Foo(bar=bar)
        self.assertEqual(foo.bar.b, 5)

    def test_not_using_kw(self):
        foo = Foo()
        self.assertEqual(foo.bar, None)

########NEW FILE########
__FILENAME__ = test_list
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

import sys

from traits.testing.unittest_tools import unittest

from ..api import CList, HasTraits, Instance, Int, List, Str, TraitError


class Foo(HasTraits):
    l = List(Str)


class Bar(HasTraits):
    name = Str


class Baz(HasTraits):
    bars = List(Bar)


class BazRef(HasTraits):
    bars = List(Bar, copy='ref')


class DeepBaz(HasTraits):
    baz = Instance(Baz)


class DeepBazBazRef(HasTraits):
    baz = Instance(BazRef)


class CFoo(HasTraits):
    ints = CList(Int)
    strs = CList(Str)


class ListTestCase(unittest.TestCase):

    def test_initialized(self):
        f = Foo()
        self.assertNotEqual(f.l, None)
        self.assertEqual(len(f.l), 0)
        return

    def test_initializer(self):
        f = Foo(l=['a', 'list'])
        self.assertNotEqual(f.l, None)
        self.assertEqual(f.l, ['a', 'list'])
        return

    def test_type_check(self):
        f = Foo()
        f.l.append('string')

        self.assertRaises(TraitError, f.l.append, 123.456)
        return

    def test_append(self):
        f = Foo()
        f.l.append('bar')
        self.assertEqual(f.l, ['bar'])
        return

    def test_remove(self):
        f = Foo()
        f.l.append('bar')
        f.l.remove('bar')
        self.assertEqual(f.l, [])
        return

    def test_slice(self):
        f = Foo(l=['zero', 'one', 'two', 'three'])
        self.assertEqual(f.l[0], 'zero')
        self.assertEqual(f.l[:0], [])
        self.assertEqual(f.l[:1], ['zero'])
        self.assertEqual(f.l[0:1], ['zero'])
        self.assertEqual(f.l[1:], ['one', 'two', 'three'])
        self.assertEqual(f.l[-1], 'three')
        self.assertEqual(f.l[-2], 'two')
        self.assertEqual(f.l[:-1], ['zero', 'one', 'two'])
        return

    def test_retrieve_reference(self):
        f = Foo(l=['initial', 'value'])

        l = f.l
        self.assertIs(l, f.l)

        # no copy on change behavior, l is always a reference
        l.append('change')
        self.assertEqual(f.l, ['initial', 'value', 'change'])

        f.l.append('more change')
        self.assertEqual(l, ['initial', 'value', 'change', 'more change'])
        return

    def test_assignment_makes_copy(self):
        f = Foo(l=['initial', 'value'])
        l = ['new']

        f.l = l
        # same content
        self.assertEqual(l, f.l)

        # different objects
        self.assertIsNot(l, f.l)

        # which means behaviorally...
        l.append('l change')
        self.assertNotIn('l change', f.l)

        f.l.append('f.l change')
        self.assertNotIn('f.l change', l)

        return

    def test_should_not_allow_none(self):
        f = Foo(l=['initial', 'value'])
        try:
            f.l = None
            self.fail('None assigned to List trait.')
        except TraitError:
            pass

    def test_clone(self):
        baz = Baz()
        for name in ['a', 'b', 'c', 'd']:
            baz.bars.append(Bar(name=name))

        # Clone will clone baz, the bars list, and the objects in the list
        baz_copy = baz.clone_traits()

        self.assertIsNot(baz_copy, baz)
        self.assertIsNot(baz_copy.bars, baz.bars)

        self.assertEqual(len(baz_copy.bars), len(baz.bars))
        for bar in baz.bars:
            self.assertNotIn(bar, baz_copy.bars)

        baz_bar_names = [bar.name for bar in baz.bars]
        baz_copy_bar_names = [bar.name for bar in baz_copy.bars]
        baz_bar_names.sort()
        baz_copy_bar_names.sort()
        self.assertEqual(baz_copy_bar_names, baz_bar_names)

        return

    def test_clone_ref(self):
        baz = BazRef()
        for name in ['a', 'b', 'c', 'd']:
            baz.bars.append(Bar(name=name))

        # Clone will clone baz, the bars list, but the objects in the list
        # will not be cloned because the copy metatrait of the List is 'ref'
        baz_copy = baz.clone_traits()

        self.assertIsNot(baz_copy, baz)
        self.assertIsNot(baz_copy.bars, baz.bars)

        self.assertEqual(len(baz_copy.bars), len(baz.bars))
        for bar in baz.bars:
            self.assertIn(bar, baz_copy.bars)

        return

    def test_clone_deep_baz(self):
        baz = Baz()
        for name in ['a', 'b', 'c', 'd']:
            baz.bars.append(Bar(name=name))

        deep_baz = DeepBaz(baz=baz)

        # Clone will clone deep_baz, deep_baz.baz, the bars list,
        # and the objects in the list
        deep_baz_copy = deep_baz.clone_traits()

        self.assertIsNot(deep_baz_copy, deep_baz)
        self.assertIsNot(deep_baz_copy.baz, deep_baz.baz)

        baz_copy = deep_baz_copy.baz

        self.assertIsNot(baz_copy, baz)
        self.assertIsNot(baz_copy.bars, baz.bars)

        self.assertEqual(len(baz_copy.bars), len(baz.bars))
        for bar in baz.bars:
            self.assertNotIn(bar, baz_copy.bars)

        baz_bar_names = [bar.name for bar in baz.bars]
        baz_copy_bar_names = [bar.name for bar in baz_copy.bars]
        baz_bar_names.sort()
        baz_copy_bar_names.sort()
        self.assertEqual(baz_copy_bar_names, baz_bar_names)
        return

    def test_clone_deep_baz_ref(self):
        baz = BazRef()
        for name in ['a', 'b', 'c', 'd']:
            baz.bars.append(Bar(name=name))

        deep_baz = DeepBazBazRef(baz=baz)

        deep_baz_copy = deep_baz.clone_traits()

        self.assertIsNot(deep_baz_copy, deep_baz)
        self.assertIsNot(deep_baz_copy.baz, deep_baz.baz)

        baz_copy = deep_baz_copy.baz

        self.assertIsNot(baz_copy, baz)
        self.assertIsNot(baz_copy.bars, baz.bars)

        self.assertEqual(len(baz_copy.bars), len(baz.bars))
        for bar in baz.bars:
            self.assertIn(bar, baz_copy.bars)
        return

    def test_coercion(self):
        f = CFoo()

        # Test coercion from basic built-in types
        f.ints = [1, 2, 3]
        desired = [1, 2, 3]
        self.assertEqual(f.ints, desired)
        f.ints = (1, 2, 3)
        self.assertEqual(f.ints, desired)

        f.strs = ("abc", "def", "ghi")
        self.assertEqual(f.strs, ["abc", "def", "ghi"])
        f.strs = "abcdef"
        self.assertEqual(f.strs, list("abcdef"))

        try:
            from numpy import array
        except ImportError:
            pass
        else:
            if sys.version_info[0] < 3:
                f.ints = array([1, 2, 3])
                self.assertEqual(f.ints, [1, 2, 3])
            else:
                # These would fail due to np.int_ being an invalid vallue
                # for the Int-trait.
                pass

            f.strs = array(("abc", "def", "ghi"))
            self.assertEqual(f.strs, ["abc", "def", "ghi"])

    def test_extend(self):
        f = Foo()
        f.l = ['4', '5', '6']
        f.l.extend(['1', '2', '3'])
        self.assertEqual(f.l, ['4', '5', '6', '1', '2', '3'])

    def test_iadd(self):
        f = Foo()
        f.l = ['4', '5', '6']
        f.l += ['1', '2', '3']
        self.assertEqual(f.l, ['4', '5', '6', '1', '2', '3'])

    def test_imul(self):
        f = Foo()
        f.l = list('123')
        f.l *= 4
        self.assertEqual(f.l, list('123123123123'))

    def test_sort_no_args(self):
        f = Foo()
        f.l = ["a", "c", "b", "d"]
        f.l.sort()
        self.assertEqual(f.l, ["a", "b", "c", "d"])

    def test_sort_key(self):
        f = Foo()
        f.l = ["a", "c", "b", "d"]
        f.l.sort(key=lambda x: -ord(x))
        self.assertEqual(f.l, ["d", "c", "b", "a"])

    def test_sort_reverse(self):
        f = Foo()
        f.l = ["a", "c", "b", "d"]
        f.l.sort(reverse=True)
        self.assertEqual(f.l, ["d", "c", "b", "a"])

    def test_sort_key_reverse(self):
        f = Foo()
        f.l = ["a", "c", "b", "d"]
        f.l.sort(key=lambda x: -ord(x), reverse=True)
        self.assertEqual(f.l, ["a", "b", "c", "d"])

    @unittest.skipIf(sys.version_info[0] >= 3, "Not for Python 3")
    def test_sort_cmp(self):
        f = Foo()
        f.l = ["a", "c", "b", "d"]
        f.l.sort(cmp=lambda x, y: ord(x) - ord(y))
        self.assertEqual(f.l, ["a", "b", "c", "d"])

    @unittest.skipIf(sys.version_info[0] < 3, "Not for Python 2")
    def test_sort_cmp_error(self):
        f = Foo()
        f.l = ["a", "c", "b", "d"]
        with self.assertRaises(TypeError):
            f.l.sort(cmp=lambda x, y: ord(x) - ord(y))

########NEW FILE########
__FILENAME__ = test_listeners
#  Test the 'add_trait_listener', 'remove_trait_listener' interface to
#  the HasTraits class.
#
#  Written by: David C. Morrill
#
#  Date: 09/07/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  License included in /LICENSE.txt and may be redistributed only under the
#  conditions described in the aforementioned license.  The license is also
#  available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!

from __future__ import absolute_import

import contextlib
import cStringIO
import sys
import threading
import time

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Str, Int, Float, Any, Event
from ..api import push_exception_handler, pop_exception_handler


@contextlib.contextmanager
def captured_stderr():
    """
    Return a context manager that directs all stderr output to a string.

    """
    new_stderr = cStringIO.StringIO()
    original_stderr = sys.stderr
    sys.stderr = new_stderr
    try:
        yield new_stderr
    finally:
        sys.stderr = original_stderr


class GenerateEvents(HasTraits):
    name = Str
    age = Int
    weight = Float

events = {}  # dict of events


class ListenEvents(HasTraits):

    #  'GenerateEvents' event interface:
    #  the events are stored in the dict 'events'

    def _name_changed(self, object, name, old, new):
        events["_name_changed"] = (name, old, new)

    def _age_changed(self, object, name, old, new):
        events["_age_changed"] = (name, old, new)

    def _weight_changed(self, object, name, old, new):
        events["_weight_changed"] = (name, old, new)

    def alt_name_changed(self, object, name, old, new):
        events["alt_name_changed"] = (name, old, new)

    def alt_weight_changed(self, object, name, old, new):
        events["alt_weight_changed"] = (name, old, new)


class Test_Listeners(unittest.TestCase):

    def test(self):
        global events

        # FIXME: comparing floats
        ge = GenerateEvents()
        le = ListenEvents()

        # Starting test: No Listeners
        ge.set(name='Joe', age=22, weight=152.0)

        # Adding default listener
        ge.add_trait_listener(le)
        events = {}
        ge.set(name='Mike', age=34, weight=178.0)
        self.assertEqual(events, {
            '_age_changed': ('age', 22, 34),
            '_weight_changed': ('weight', 152.0, 178.0),
            '_name_changed': ('name', 'Joe', 'Mike'),
            })

        # Adding alternate listener
        ge.add_trait_listener(le, 'alt')
        events = {}
        ge.set(name='Gertrude', age=39, weight=108.0)
        self.assertEqual(events, {
            '_age_changed': ('age', 34, 39),
            '_name_changed': ('name', 'Mike', 'Gertrude'),
            '_weight_changed': ('weight', 178.0, 108.0),
            'alt_name_changed': ('name', 'Mike', 'Gertrude'),
            'alt_weight_changed': ('weight', 178.0, 108.0),
            })

        # Removing default listener
        ge.remove_trait_listener(le)
        events = {}
        ge.set(name='Sally', age=46, weight=118.0)
        self.assertEqual(events, {
            'alt_name_changed': ('name', 'Gertrude', 'Sally'),
            'alt_weight_changed': ('weight', 108.0, 118.0),
            })

        # Removing alternate listener
        ge.remove_trait_listener(le, 'alt')
        events = {}
        ge.set(name='Ralph', age=29, weight=198.0)
        self.assertEqual(events, {})


class A(HasTraits):
    exception = Any

    foo = Event

    def foo_changed_handler(self):
        pass


def foo_writer(a, stop_event):
    while not stop_event.is_set():
        try:
            a.foo = True
        except Exception as e:
            a.exception = e


class TestRaceCondition(unittest.TestCase):
    def setUp(self):
        push_exception_handler(
            handler=lambda *args: None,
            reraise_exceptions=True,
            main=True,
            )

    def tearDown(self):
        pop_exception_handler()

    def test_listener_thread_safety(self):
        # Regression test for GitHub issue #56
        a = A()
        stop_event = threading.Event()

        t = threading.Thread(target=foo_writer, args=(a, stop_event))
        t.start()

        for _ in xrange(100):
            a.on_trait_change(a.foo_changed_handler, 'foo')
            time.sleep(0.0001)  # encourage thread-switch
            a.on_trait_change(a.foo_changed_handler, 'foo', remove=True)

        stop_event.set()
        t.join()

        self.assertTrue(a.exception is None)

    def test_listener_deleted_race(self):
        # Regression test for exception that occurred when the listener_deleted
        # method is called after the dispose method on a
        # TraitsChangeNotifyWrapper.
        class SlowListener(HasTraits):
            def handle_age_change(self):
                time.sleep(1.0)

        def worker_thread(event_source, start_event):
            # Wait until the listener is set up on the main thread, then fire
            # the event.
            start_event.wait()
            event_source.age = 11

        def main_thread(event_source, start_event):
            listener = SlowListener()
            event_source.on_trait_change(listener.handle_age_change, 'age')
            start_event.set()
            # Allow time to make sure that we're in the middle of handling an
            # event.
            time.sleep(0.5)
            event_source.on_trait_change(
                listener.handle_age_change, 'age', remove=True)

        # Previously, a ValueError would be raised on the worker thread
        # during (normal refcount-based) garbage collection.  That
        # ValueError is ignored by the Python system, so the only
        # visible effect is the output to stderr.
        with captured_stderr() as s:
            start_event = threading.Event()
            event_source = GenerateEvents(age=10)
            t = threading.Thread(
                target=worker_thread,
                args=(event_source, start_event),
                )
            t.start()
            main_thread(event_source, start_event)
            t.join()

        self.assertNotIn('Exception', s.getvalue())


# Run the unit tests (if invoked from the command line):
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_list_events
#------------------------------------------------------------------------------
#
#  Copyright (c) 2014, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------
"""
Tests for List items_changed events.

"""
from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Int, List


class MyClass(HasTraits):
    l = List(Int, [1, 2, 3])

    l_events = List

    def _l_items_changed(self, event):
        self.l_events.append(event)


class ListEventTestCase(unittest.TestCase):
    def test_initialization(self):
        # Just creating an instance of MyClass shouldn't cause
        # the items_changed handler to fire.
        foo = MyClass()
        self.assertEqual(foo.l, [1, 2, 3])
        self.assertEqual(len(foo.l_events), 0)

    def test_append(self):
        foo = MyClass()
        foo.l.append(4)
        self.assertEqual(foo.l, [1, 2, 3, 4])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [4])
        self.assertEqual(event.removed, [])
        self.assertEqual(event.index, 3)

    def test_extend(self):
        foo = MyClass()
        foo.l.extend([4, 5, 6])
        self.assertEqual(foo.l, [1, 2, 3, 4, 5, 6])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [4, 5, 6])
        self.assertEqual(event.removed, [])
        self.assertEqual(event.index, 3)

    def test_extend_via_inplace_addition(self):
        foo = MyClass()
        foo.l += [4, 5, 6]
        self.assertEqual(foo.l, [1, 2, 3, 4, 5, 6])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [4, 5, 6])
        self.assertEqual(event.removed, [])
        self.assertEqual(event.index, 3)

    def test_insert(self):
        foo = MyClass()
        foo.l.insert(1, 99)
        self.assertEqual(foo.l, [1, 99, 2, 3])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [99])
        self.assertEqual(event.removed, [])
        self.assertEqual(event.index, 1)

    def test_insert_with_negative_argument(self):
        foo = MyClass()
        foo.l.insert(-1, 99)
        self.assertEqual(foo.l, [1, 2, 99, 3])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [99])
        self.assertEqual(event.removed, [])
        self.assertEqual(event.index, 2)

    def test_insert_index_invariants(self):
        # Note that Python's list.insert allows indices outside
        # the range [-len(my_list), len(my_list)].
        for index in range(-10, 10):
            foo = MyClass()
            foo.l.insert(index, 1729)
            self.assertEqual(len(foo.l_events), 1)
            event = foo.l_events[0]
            self.assertEqual(event.added, [1729])
            self.assertEqual(event.removed, [])
            self.assertGreaterEqual(event.index, 0)
            self.assertEqual(foo.l[event.index], 1729)

    def test_pop_with_no_argument(self):
        foo = MyClass()
        item = foo.l.pop()
        self.assertEqual(item, 3)
        self.assertEqual(foo.l, [1, 2])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [])
        self.assertEqual(event.removed, [3])
        self.assertEqual(event.index, 2)

    def test_pop(self):
        foo = MyClass()
        item = foo.l.pop(0)
        self.assertEqual(item, 1)
        self.assertEqual(foo.l, [2, 3])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [])
        self.assertEqual(event.removed, [1])
        self.assertEqual(event.index, 0)

    def test_pop_with_negative_argument(self):
        foo = MyClass()
        item = foo.l.pop(-2)
        self.assertEqual(item, 2)
        self.assertEqual(foo.l, [1, 3])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [])
        self.assertEqual(event.removed, [2])
        self.assertEqual(event.index, 1)

    def test_pop_out_of_range(self):
        foo = MyClass()
        with self.assertRaises(IndexError):
            foo.l.pop(-4)
        with self.assertRaises(IndexError):
            foo.l.pop(3)
        self.assertEqual(foo.l, [1, 2, 3])
        self.assertEqual(len(foo.l_events), 0)

    def test_remove(self):
        foo = MyClass()
        foo.l.remove(2)
        self.assertEqual(foo.l, [1, 3])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [])
        self.assertEqual(event.removed, [2])
        self.assertEqual(event.index, 1)

    def test_remove_item_not_present(self):
        foo = MyClass()
        with self.assertRaises(ValueError):
            foo.l.remove(1729)
        self.assertEqual(foo.l, [1, 2, 3])
        self.assertEqual(len(foo.l_events), 0)

    def test_inplace_multiply(self):
        foo = MyClass()
        foo.l *= 2
        self.assertEqual(foo.l, [1, 2, 3, 1, 2, 3])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [1, 2, 3])
        self.assertEqual(event.removed, [])
        self.assertEqual(event.index, 3)

    def test_inplace_multiply_by_zero(self):
        foo = MyClass()
        foo.l *= 0
        self.assertEqual(foo.l, [])
        self.assertEqual(len(foo.l_events), 1)
        event = foo.l_events[0]
        self.assertEqual(event.added, [])
        self.assertEqual(event.removed, [1, 2, 3])
        self.assertEqual(event.index, 0)

########NEW FILE########
__FILENAME__ = test_new_notifiers
""" Tests for dynamic notifiers with `dispatch='new'`.

Dynamic notifiers created with the `dispatch='new'` option dispatch event
notifications on a new thread. The class handling the dispatch,
`NewTraitChangeNotifyWrapper`, is a subclass of `TraitChangeNotifyWrapper`.
Most of the functionality of the class is thus already covered by the
`TestDynamicNotifiers` test case, and we only need to test that the
notification really occurs on a separate thread.

"""
import thread
import time

from traits.api import Float, HasTraits
from traits.testing.unittest_tools import unittest


class Foo(HasTraits):
    foo = Float


class TestNewNotifiers(unittest.TestCase):
    """ Tests for dynamic notifiers with `dispatch='new'`. """

    def test_notification_on_separate_thread(self):
        notifications = []

        def on_foo_notifications(obj, name, old, new):
            thread_id = thread.get_ident()
            event = (thread_id, obj, name, old, new)
            notifications.append(event)

        obj = Foo()
        obj.on_trait_change(on_foo_notifications, 'foo', dispatch='new')

        obj.foo = 3
        # Wait for a while to make sure the notification has finished.
        time.sleep(0.1)

        self.assertEqual(len(notifications), 1)
        self.assertEqual(notifications[0][1:], (obj, 'foo', 0, 3))

        this_thread_id = thread.get_ident()
        self.assertNotEqual(this_thread_id, notifications[0][0])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pickle_validated_dict
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from cPickle import dumps, loads
from traits.testing.unittest_tools import unittest

from ..api import Dict, HasTraits, Int, List


class C(HasTraits):
    # A dict trait containing a list trait
    a = Dict(Int, List(Int))

    # And we must initialize it to something non-trivial
    def __init__(self):
        super(C, self).__init__()
        self.a = {1: [2, 3]}


class PickleValidatedDictTestCase(unittest.TestCase):
    def test(self):

        # And we must unpickle one
        x = dumps(C())
        try:
            loads(x)
        except AttributeError, e:
            self.fail('Unpickling raised an AttributeError: %s' % e)

########NEW FILE########
__FILENAME__ = test_property_delete
"""
Unit tests to ensure that we can call reset_traits/delete on a
property trait (regression tests for Github issue #67).

"""

from traits import _py2to3
from traits.api import Any, HasTraits, Int, Property, TraitError
from traits.testing.unittest_tools import unittest


class E(HasTraits):

    a = Property(Any)

    b = Property(Int)


class TestPropertyDelete(unittest.TestCase):

    def test_property_delete(self):
        e = E()
        with self.assertRaises(TraitError):
            del e.a
        with self.assertRaises(TraitError):
            del e.b

    def test_property_reset_traits(self):
        e = E()
        unresetable = e.reset_traits()
        _py2to3.assertCountEqual(self, unresetable, ['a', 'b'])

########NEW FILE########
__FILENAME__ = test_property_notifications
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Description: <Traits component>
#------------------------------------------------------------------------------

from __future__ import absolute_import

from ..api import HasTraits, Property


class Test(HasTraits):

    __traits__ = {}

    def __value_get(self):
        return self.__dict__.get('_value', 0)

    def __value_set(self, value):
        old_value = self.__dict__.get('_value', 0)
        if value != old_value:
            self._value = value
            self.trait_property_changed('value', old_value, value)

    __traits__['value'] = Property(__value_get, __value_set)


class Test_1 (Test):

    def value_changed(self, value):
        print 'value_changed:', value


class Test_2 (Test):

    def anytrait_changed(self, name, value):
        print 'anytrait_changed for %s: %s' % (name, value)


class Test_3 (Test_2):

    def value_changed(self, value):
        print 'value_changed:', value


def on_value_changed(value):
    print 'on_value_changed:', value


def on_anyvalue_changed(value):
    print 'on_anyvalue_changed:', value


def test_property_notifications():
    Test_1().value = 'test 1'
    Test_2().value = 'test 2'
    Test_3().value = 'test 3'

    test_4 = Test()
    test_4.on_trait_change(on_value_changed, 'value')
    test_4.value = 'test 4'

    test_5 = Test()
    test_5.on_trait_change(on_anyvalue_changed)
    test_5.value = 'test 5'

    test_6 = Test()
    test_6.on_trait_change(on_value_changed, 'value')
    test_6.on_trait_change(on_anyvalue_changed)
    test_6.value = 'test 6'

    test_7 = Test_3()
    test_7.on_trait_change(on_value_changed, 'value')
    test_7.on_trait_change(on_anyvalue_changed)
    test_7.value = 'test 7'

########NEW FILE########
__FILENAME__ = test_protocols_usage
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

""" Tests for protocols usage. """

from __future__ import absolute_import


# Standard library imports.
import os
import pickle
import sys
from traits.testing.unittest_tools import unittest

# Enthought library imports.
from ..api import (Bool, HasTraits, Int, Interface, Str, Adapter, adapts,
                   Property)

# NOTE: There is a File class in apptools.io module, but since we want to
# eliminate dependencies of Traits on other modules, we create another
# minimal File class here to test the adapter implementation.


# Test class
class File(HasTraits):

    # The path name of this file/folder.
    path = Str

    # Is this an existing file?
    is_file = Property(Bool)

    # Is this an existing folder?
    is_folder = Property(Bool)

    def _get_is_file(self):
        """ Returns True if the path exists and is a file. """

        return os.path.exists(self.path) and os.path.isfile(self.path)

    def _get_is_folder(self):
        """ Returns True if the path exists and is a folder. """

        return os.path.exists(self.path) and os.path.isdir(self.path)


# Test class.
class Person(HasTraits):
    """ A person! """

    name = Str
    age = Int


@unittest.skipUnless(sys.version_info < (3,),
                     "The 'adapts' and 'implements' class advisors "
                     "are not supported in Python 3.")
class ProtocolsUsageTestCase(unittest.TestCase):
    """ Tests for protocols usage. """
    def test_adapts(self):
        """ adapts """
        class IFoo(Interface):
            """ A simple interface. """
            def foo(self):
                """ The only method for the IFoo interface. """

        class Bar(HasTraits):
            """ A type that *doesn't* implement 'IFoo'. """

        class BarToIFooAdapter(Adapter):
            """ Adapts from Bar to IFoo. """
            adapts(Bar, to=IFoo)

            def foo(self):
                """ An implementation of the single method in the interface."""
                return 'foo'

        b = Bar()

        # Make sure that the Bar instance can be adapted to 'IFoo'.
        self.assertNotEqual(None, IFoo(b))
        self.assertEqual('foo', IFoo(b).foo())

    def test_factory(self):
        """ factory """

        class IInputStream(Interface):
            """ Fake interface for input stream. """

            def get_input_stream(self):
                """ Get an input stream. """

        def factory(obj):
            """ A factory for File to IInputStream adapters. """

            if not obj.is_folder:
                adapter = FileToIInputStreamAdapter(adaptee=obj)

            else:
                adapter = None

            return adapter

        class FileToIInputStreamAdapter(Adapter):
            """ An adapter from 'File' to 'IInputStream'. """

            adapts(File, to=IInputStream, factory=factory)

            ###################################################################
            # 'IInputStream' interface.
            ###################################################################

            def get_input_stream(self):
                """ Get an input stream. """

                return file(self.adaptee.path, 'r')

        # Create a reference to this file
        cwd = os.path.dirname(os.path.abspath(__file__))
        f = File(path=os.path.join(cwd, 'test_protocols_usage.py'))
        self.assertTrue(f.is_file)

        # A reference to the parent folder
        g = File(path='..')
        self.assertTrue(g.is_folder)

        # We should be able to adapt the file to an input stream...
        self.assertNotEqual(None, IInputStream(f, None))

        # ... but not the folder.
        self.assertEqual(None, IInputStream(g, None))

        # Make sure we can use the stream (this reads this module and makes
        # sure that it contains the right doc string).
        stream = IInputStream(f).get_input_stream()
        self.assertIn('"""' + __doc__, stream.read())

        return

    def test_when_expression(self):
        """ when expression """

        class IInputStream(Interface):
            """ Fake interface for input stream. """

            def get_input_stream(self):
                """ Get an input stream. """

        class FileToIInputStreamAdapter(Adapter):
            """ An adapter from 'File' to 'IInputStream'. """

            adapts(File, to=IInputStream, when='not adaptee.is_folder')

            ###################################################################
            # 'IInputStream' interface.
            ###################################################################

            def get_input_stream(self):
                """ Get an input stream. """

                return file(self.adaptee.path, 'r')

        # Create a reference to this file
        cwd = os.path.dirname(os.path.abspath(__file__))
        f = File(path=os.path.join(cwd, 'test_protocols_usage.py'))
        self.assertTrue(f.is_file)

        # A reference to the parent folder
        g = File(path='..')
        self.assertTrue(g.is_folder)

        # We should be able to adapt the file to an input stream...
        self.assertNotEqual(None, IInputStream(f, None))

        # ... but not the folder.
        self.assertEqual(None, IInputStream(g, None))

        # Make sure we can use the stream (this reads this module and makes
        # sure that it contains the right doc string).
        stream = IInputStream(f).get_input_stream()
        self.assertIn('"""' + __doc__, stream.read())

        return

    def test_cached(self):
        """ cached """

        class ISaveable(Interface):
            """ Fake interface for saveable. """

            # Is the object 'dirty'?
            dirty = Bool(False)

            def save(self, output_stream):
                """ Save the object to an output stream. """

        class HasTraitsToISaveableAdapter(Adapter):
            """ An adapter from 'HasTraits' to 'ISaveable'. """

            adapts(HasTraits, to=ISaveable, cached=True)

            #### 'ISaveable' interface ########################################

            # Is the object 'dirty'?
            dirty = Bool(False)

            def save(self, output_stream):
                """ Save the object to an output stream. """

                pickle.dump(self.adaptee, output_stream)
                self.dirty = False

                return

            #### Private interface ############################################

            def _adaptee_changed(self, old, new):
                """ Static trait change handler. """

                if old is not None:
                    old.on_trait_change(self._set_dirty, remove=True)

                if new is not None:
                    new.on_trait_change(self._set_dirty)

                self._set_dirty()

                return

            def _set_dirty(self):
                """ Sets the dirty flag to True. """

                self.dirty = True

                return

        # Create some people!
        fred = Person(name='fred', age=42)
        wilma = Person(name='wilma', age=35)

        fred_saveable = ISaveable(fred)
        self.assertEqual(True, fred_saveable.dirty)

        wilma_saveable = ISaveable(wilma)
        self.assertEqual(True, wilma_saveable.dirty)

        # Make sure that Fred and Wilma have got their own saveable.
        self.assertNotEqual(id(fred_saveable), id(wilma_saveable))

        # But make sure that their saveable's are cached.
        self.assertEqual(id(ISaveable(fred)), id(fred_saveable))
        self.assertEqual(id(ISaveable(wilma)), id(wilma_saveable))

        # Save Fred and Wilma and make sure that the dirty flag is cleared.
        fred_saveable.save(file('fred.pickle', 'w'))
        self.assertEqual(False, ISaveable(fred).dirty)

        wilma_saveable.save(file('wilma.pickle', 'w'))
        self.assertEqual(False, ISaveable(wilma).dirty)

        # Clean up.
        for path in ['fred.pickle', 'wilma.pickle']:
            if os.access(path, os.W_OK):
                os.remove(path)

        return

    def test_multiple_factories_for_type(self):
        """ multiple factories for type """

        # There was a bug that prevented more than one adapter factory being
        # registered for the same class.
        class IFoo(Interface):
            pass

        class HasTraitsToIFooAdapter(Adapter):
            adapts(HasTraits, to=IFoo, cached=True)

        class IBar(Interface):
            pass

        class HasTraitsToIBarAdapter(Adapter):
            adapts(HasTraits, to=IBar, cached=True)

        return

    def test_multiple_factories_for_interface(self):
        """ multiple factories for interfaces """

        # There was a bug that prevented more than one adapter factory being
        # registered for the same class. This test just makes sure that it
        # still works for interfaces too!
        class IBaz(Interface):
            pass

        class IFoo(Interface):
            pass

        class IBazToIFooAdapter(Adapter):
            adapts(IBaz, to=IFoo, cached=True)

        class IBar(Interface):
            pass

        class IBazToIBarAdapter(Adapter):
            adapts(IBaz, to=IBar, cached=True)

        return


# Run the unit tests (if invoked from the command line):
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_range
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Int, Range, Str, TraitError


class WithFloatRange(HasTraits):
    r = Range(0.0, 100.0)
    r_copied_on_change = Str

    _changed_handler_calls = Int

    def _r_changed(self, old, new):
        self._changed_handler_calls += 1
        self.r_copied_on_change = str(self.r)

        if (self.r % 10) > 0:
            self.r += 10 - (self.r % 10)


class WithLargeIntRange(HasTraits):
    r = Range(0, 1000)
    r_copied_on_change = Str

    _changed_handler_calls = Int

    def _r_changed(self, old, new):
        self._changed_handler_calls += 1
        self.r_copied_on_change = str(self.r)

        if self.r > 100:
            self.r = 0


class WithDynamicRange(HasTraits):
    low = Int(0)
    high = Int(10)
    value = Int(3)

    r = Range(value='value', low='low', high='high', exclude_high=True)

    def _r_changed(self, old, new):
        self._changed_handler_calls += 1


class RangeTestCase(unittest.TestCase):

    def test_non_ui_events(self):

        obj = WithFloatRange()
        obj._changed_handler_calls = 0

        obj.r = 10
        self.assertEqual(1, obj._changed_handler_calls)

        obj._changed_handler_calls = 0
        obj.r = 34.56
        self.assertEqual(obj._changed_handler_calls, 2)
        self.assertEqual(obj.r, 40)

    def test_non_ui_int_events(self):

        # Even though the range is configured for 0..1000, the handler resets
        # the value to 0 when it exceeds 100.
        obj = WithLargeIntRange()
        obj._changed_handler_calls = 0

        obj.r = 10
        self.assertEqual(obj._changed_handler_calls, 1)
        self.assertEqual(obj.r, 10)

        obj.r = 100
        self.assertEqual(obj._changed_handler_calls, 2)
        self.assertEqual(obj.r, 100)

        obj.r = 101
        self.assertEqual(obj._changed_handler_calls, 4)
        self.assertEqual(obj.r, 0)

    def test_dynamic_events(self):

        obj = WithDynamicRange()
        obj._changed_handler_calls = 0

        obj.r = 5
        self.assertEqual(obj._changed_handler_calls, 1)
        self.assertEqual(obj.r, 5)

        with self.assertRaises(TraitError):
            obj.r = obj.high
        self.assertEqual(obj.r, 5)

########NEW FILE########
__FILENAME__ = test_regression
""" General regression tests for a variety of bugs. """
import gc
import sys

from ..has_traits import HasTraits, Property, on_trait_change
from ..trait_types import Bool, DelegatesTo, Instance, Int
from ..testing.unittest_tools import unittest


class Dummy(HasTraits):
    x = Int(10)


def _create_subclass():
    class Subclass(HasTraits):
        pass
    return Subclass


class Dummy2(HasTraits):
    y = Int(20)
    dummy = Instance(Dummy)


class DelegateMess(HasTraits):
    dummy1 = Instance(Dummy, args=())
    dummy2 = Instance(Dummy2)

    y = DelegatesTo('dummy2')

    handler_called = Bool(False)

    def _dummy2_default(self):
        # Create `self.dummy1`
        return Dummy2(dummy=self.dummy1)

    @on_trait_change('dummy1.x')
    def _on_dummy1_x(self):
        self.handler_called = True

    def _init_trait_listeners(self):
        """ Force the DelegatesTo listener to hook up first to exercise the
        worst case.
        """
        for name in ['y', '_on_dummy1_x']:
            data = self.__class__.__listener_traits__[name]
            getattr(self, '_init_trait_%s_listener' % data[0])(name, *data)


class Presenter(HasTraits):
    obj = Instance(Dummy)
    y = Property(Int(), depends_on='obj.x')

    def _get_y(self):
        return self.obj.x


class TestRegression(unittest.TestCase):

    def test_default_value_for_no_cache(self):
        """ Make sure that CTrait.default_value_for() does not cache the
        result.
        """
        dummy = Dummy()
        # Nothing in the __dict__ yet.
        self.assertEqual(dummy.__dict__, {})
        ctrait = dummy.trait('x')
        default = ctrait.default_value_for(dummy, 'x')
        self.assertEqual(default, 10)
        self.assertEqual(dummy.__dict__, {})

    def test_subclasses_weakref(self):
        """ Make sure that dynamically created subclasses are not held
        strongly by HasTraits.
        """
        previous_subclasses = HasTraits.__subclasses__()
        _create_subclass()
        _create_subclass()
        _create_subclass()
        _create_subclass()
        gc.collect()
        self.assertEqual(previous_subclasses, HasTraits.__subclasses__())

    def test_leaked_property_tuple(self):
        """ the property ctrait constructor shouldn't leak a tuple. """
        class A(HasTraits):
            prop = Property()
        a = A()
        self.assertEqual(sys.getrefcount(a.trait('prop').property()), 1)

    def test_delegate_initializer(self):
        mess = DelegateMess()
        self.assertFalse(mess.handler_called)
        mess.dummy1.x = 20
        self.assertTrue(mess.handler_called)

    def test_no_leaking_notifiers(self):
        """ Extended trait change notifications should not leaf
        TraitChangeNotifyWrappers.
        """
        dummy = Dummy()
        ctrait = dummy._trait('x', 2)
        self.assertEqual(len(ctrait._notifiers(1)), 0)
        presenter = Presenter(obj=dummy)
        self.assertEqual(len(ctrait._notifiers(1)), 1)
        del presenter
        self.assertEqual(len(ctrait._notifiers(1)), 0)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_rich_compare
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Any, Str


class IdentityCompare(HasTraits):
    bar = Any(rich_compare=False)


class RichCompare(HasTraits):
    bar = Any(rich_compare=True)


class RichCompareTests:

    def bar_changed(self, object, trait, old, new):
        self.changed_object = object
        self.changed_trait = trait
        self.changed_old = old
        self.changed_new = new
        self.changed_count += 1

    def reset_change_tracker(self):
        self.changed_object = None
        self.changed_trait = None
        self.changed_old = None
        self.changed_new = None
        self.changed_count = 0

    def check_tracker(self, object, trait, old, new, count):
        self.assertEqual(count, self.changed_count)
        self.assertIs(object, self.changed_object)
        self.assertEqual(trait, self.changed_trait)
        self.assertIs(old, self.changed_old)
        self.assertIs(new, self.changed_new)
        return

    def test_id_first_assignment(self):
        ic = IdentityCompare()
        ic.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = ic.bar
        ic.bar = self.a
        self.check_tracker(ic, 'bar', default_value, self.a, 1)
        return

    def test_rich_first_assignment(self):
        rich = RichCompare()
        rich.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = rich.bar
        rich.bar = self.a
        self.check_tracker(rich, 'bar', default_value, self.a, 1)
        return

    def test_id_same_object(self):
        ic = IdentityCompare()
        ic.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = ic.bar
        ic.bar = self.a
        self.check_tracker(ic, 'bar', default_value, self.a, 1)

        ic.bar = self.a
        self.check_tracker(ic, 'bar', default_value, self.a, 1)
        return

    def test_rich_same_object(self):
        rich = RichCompare()
        rich.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = rich.bar
        rich.bar = self.a
        self.check_tracker(rich, 'bar', default_value, self.a, 1)

        rich.bar = self.a
        self.check_tracker(rich, 'bar', default_value, self.a, 1)
        return

    def test_id_different_object(self):
        ic = IdentityCompare()
        ic.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = ic.bar
        ic.bar = self.a
        self.check_tracker(ic, 'bar', default_value, self.a, 1)

        ic.bar = self.different_from_a
        self.check_tracker(ic, 'bar', self.a, self.different_from_a, 2)
        return

    def test_rich_different_object(self):
        rich = RichCompare()
        rich.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = rich.bar
        rich.bar = self.a
        self.check_tracker(rich, 'bar', default_value, self.a, 1)

        rich.bar = self.different_from_a
        self.check_tracker(rich, 'bar', self.a, self.different_from_a, 2)
        return

    def test_id_different_object_same_as(self):
        ic = IdentityCompare()
        ic.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = ic.bar
        ic.bar = self.a
        self.check_tracker(ic, 'bar', default_value, self.a, 1)

        ic.bar = self.same_as_a
        self.check_tracker(ic, 'bar', self.a, self.same_as_a, 2)
        return

    def test_rich_different_object_same_as(self):
        rich = RichCompare()
        rich.on_trait_change(self.bar_changed, 'bar')

        self.reset_change_tracker()

        default_value = rich.bar
        rich.bar = self.a
        self.check_tracker(rich, 'bar', default_value, self.a, 1)

        # Values of a and same_as_a are the same and should therefore not
        # be considered a change.
        rich.bar = self.same_as_a
        self.check_tracker(rich, 'bar', default_value, self.a, 1)
        return


class Foo(HasTraits):
    name = Str

    def __ne__(self, other):
        # Traits uses != to do the rich compare.  The default implementation
        # of __ne__ is to compare the object identities.
        return self.name != other.name

    def __eq__(self, other):
        # Not required, but a good idea to make __eq__ and __ne__ compatible
        return self.name == other.name


class RichCompareHasTraitsTestCase(unittest.TestCase, RichCompareTests):

    def setUp(self):
        self.a = Foo(name='a')
        self.same_as_a = Foo(name='a')
        self.different_from_a = Foo(name='not a')
        return

    def test_assumptions(self):
        self.assertIsNot(self.a, self.same_as_a)
        self.assertIsNot(self.a, self.different_from_a)

        self.assertEqual(self.a.name, self.same_as_a.name)
        self.assertNotEqual(self.a.name, self.different_from_a.name)
        return
### EOF

########NEW FILE########
__FILENAME__ = test_special_event_handlers
from traits.testing.unittest_tools import unittest

from traits.api import Any, HasStrictTraits, Str


class TestSpecialEvent(unittest.TestCase):
    """ Test demonstrating special change events using the 'event' metadata.
    """

    def setUp(self):
        self.change_events = []
        self.foo = Foo(test=self)

    def test_events(self):
        self.foo.val = 'CHANGE'

        values = ['CHANGE']
        self.assertEqual(self.change_events, values)

    def test_instance_events(self):
        foo = self.foo
        foo.add_trait('val2', Str(event='the_trait'))
        foo.val2 = 'CHANGE2'

        values = ['CHANGE2']
        self.assertEqual(self.change_events, values)


class Foo(HasStrictTraits):
    val = Str(event='the_trait')
    test = Any(None)

    def _the_trait_changed(self, new):
        if self.test is not None:
            self.test.change_events.append(new)

########NEW FILE########
__FILENAME__ = test_static_notifiers
##############################################################################
# Copyright 2014 Enthought, Inc.
##############################################################################

""" Tests for the static notifiers. """
from traits.api import Float, HasTraits
from traits.testing.unittest_tools import unittest

from traits import trait_notifiers

calls_0 = []


class StaticNotifiers0(HasTraits):
    ok = Float

    def _ok_changed():
        calls_0.append(True)

    fail = Float

    def _fail_changed():
        raise Exception('error')


class StaticNotifiers1(HasTraits):
    ok = Float

    def _ok_changed(self):
        if not hasattr(self, 'calls'):
            self.calls = []
        self.calls.append(True)

    fail = Float

    def _fail_changed(self):
        raise Exception('error')


class StaticNotifiers2(HasTraits):
    ok = Float

    def _ok_changed(self, new):
        if not hasattr(self, 'calls'):
            self.calls = []
        self.calls.append(new)

    fail = Float

    def _fail_changed(self, new):
        raise Exception('error')


class StaticNotifiers3(HasTraits):
    ok = Float

    def _ok_changed(self, old, new):
        if not hasattr(self, 'calls'):
            self.calls = []
        self.calls.append((old, new))

    fail = Float

    def _fail_changed(self, old, new):
        raise Exception('error')


class StaticNotifiers4(HasTraits):
    ok = Float

    def _ok_changed(self, name, old, new):
        if not hasattr(self, 'calls'):
            self.calls = []
        self.calls.append((name, old, new))

    fail = Float

    def _fail_changed(self, name, old, new):
        raise Exception('error')


class TestNotifiers(unittest.TestCase):
    """ Tests for the static notifiers, and the "anytrait" static notifiers.
    """

    def setUp(self):
        self.exceptions = []
        trait_notifiers.push_exception_handler(self._handle_exception)

    def tearDown(self):
        trait_notifiers.pop_exception_handler()

    def _handle_exception(self, obj, name, old, new):
        self.exceptions.append((obj, name, old, new))

    def test_static_notifiers_0(self):
        obj = StaticNotifiers0(ok=2)
        obj.ok = 3
        self.assertEqual(len(calls_0), 2)

        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_static_notifiers_1(self):
        obj = StaticNotifiers1(ok=2)
        obj.ok = 3
        self.assertEqual(len(obj.calls), 2)

        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_static_notifiers_2(self):
        obj = StaticNotifiers2(ok=2)
        obj.ok = 3
        self.assertEqual(obj.calls, [2, 3])
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_static_notifiers_3(self):
        obj = StaticNotifiers3(ok=2)
        obj.ok = 3
        self.assertEqual(obj.calls, [(0, 2), (2, 3)])
        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])

    def test_static_notifiers_4(self):
        obj = StaticNotifiers4(ok=2)
        obj.ok = 3
        self.assertEqual(obj.calls, [('ok', 0, 2), ('ok', 2, 3)])

        obj.fail = 1
        self.assertEqual(self.exceptions, [(obj, 'fail', 0, 1)])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_str_handler
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Trait, TraitError, TraitHandler
from ..trait_base import strx


# Validation via function
def validator(object, name, value):
    if isinstance(value, basestring):
        # arbitrary rule for testing
        if value.find('fail') < 0:
            return value
        else:
            raise TraitError
    else:
        raise TraitError


# Validation via Handler
class MyHandler(TraitHandler):
    def validate(self, object, name, value):
        #print 'myvalidate "%s" %s' % (value, type(value))
        try:
            value = strx(value)
            if value.find('fail') < 0:
                return value
        except:
            pass
        self.error(object, name, value)

        return

    def info(self):
        msg = "a string not containing the character sequence 'fail'"
        return msg


class Foo(HasTraits):
    s = Trait('', validator)


class Bar(HasTraits):
    s = Trait('', MyHandler())


class StrHandlerCase(unittest.TestCase):

    def test_validator_function(self):
        f = Foo()
        self.assertEqual(f.s, '')

        f.s = 'ok'
        self.assertEqual(f.s, 'ok')

        self.assertRaises(TraitError, setattr, f, 's', 'should fail.')
        self.assertEqual(f.s, 'ok')

        return

    def test_validator_handler(self):
        b = Bar()
        self.assertEqual(b.s, '')

        b.s = 'ok'
        self.assertEqual(b.s, 'ok')

        self.assertRaises(TraitError, setattr, b, 's', 'should fail.')
        self.assertEqual(b.s, 'ok')

        return

### EOF

########NEW FILE########
__FILENAME__ = test_sync_traits
""" Test that the `sync_trait` member function of `HasTraits` instances
functions correctly.

"""

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest, UnittestTools

from ..api import HasTraits, Int, List


class A(HasTraits):

    t = Int

    l = List(Int)


class B(HasTraits):

    t = Int

    u = Int

    l = List(Int)


class TestSyncTraits(unittest.TestCase, UnittestTools):

    def test_mutual_sync(self):
        """ Test that two traits can be mutually synchronized.
        """

        a = A()
        b = B()

        a.sync_trait('t', b)

        b.t = 10
        self.assertEqual(a.t, b.t)
        a.t = 20
        self.assertEqual(b.t, a.t)

        # Check that we can remove the synchronization
        a.sync_trait('t', b, remove=True)

        with self.assertTraitDoesNotChange(a, 't'):
            b.t = 5
        with self.assertTraitDoesNotChange(b, 't'):
            a.t = 7

    def test_sync_alias(self):
        """ Test synchronization of a trait with an aliased trait.
        """

        a = A()
        b = B()

        a.sync_trait('t', b, 'u')

        with self.assertTraitDoesNotChange(b, 't'):
            a.t = 5

        self.assertEqual(a.t, b.u)

        b.u = 7
        self.assertEqual(a.t, b.u)

    def test_one_way_sync(self):
        """ Test one-way synchronization of two traits.
        """

        a = A(t=3)
        b = B(t=4)

        a.sync_trait('t', b, mutual=False)
        self.assertEqual(b.t, 3)

        a.t = 5
        self.assertEqual(b.t, a.t)

        with self.assertTraitDoesNotChange(a, 't'):
            b.t = 7

        # Remove synchronization
        a.sync_trait('t', b, remove=True)

        with self.assertTraitDoesNotChange(b, 't'):
            a.t = 12

    def test_sync_lists(self):
        """ Test synchronization of list traits.
        """

        a = A()
        b = B()

        a.sync_trait('l', b)

        # Change entire list.
        a.l = [1, 2, 3]
        self.assertEqual(a.l, b.l)
        b.l = [4, 5]
        self.assertEqual(a.l, b.l)

        # Change list items.
        a.l = [7, 8, 9]
        with self.assertTraitChanges(b, 'l_items'):
            a.l[-1] = 20
        self.assertEqual(b.l, [7, 8, 20])

        # Remove synchronization
        a.sync_trait('l', b, remove=True)

        with self.assertTraitDoesNotChange(a, 'l'):
            b.l = [7, 8]

    def test_sync_delete(self):
        """ Test that deleting a synchronized trait works.
        """

        a = A()
        b = B()

        a.sync_trait('t', b)

        a.t = 5
        del a

        try:
            # Updating `b.t` should not raise an exception due to remaining
            # listeners.
            b.t = 7
        except Exception:
            self.fail("Unexpected exception while setting sync trait.")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_target
#------------------------------------------------------------------------------
#
#  Copyright (c) 2010, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------
""" Test whether HasTraits objects with cycles can be garbage collected.
"""

# Standard library imports
from traits.testing.unittest_tools import unittest

# Enthought library imports
from traits.api import HasTraits, Instance, Int


class TestCase(unittest.TestCase):
    """ Tests the 'target' argument for on_traits_change. """

    def test_simple(self):
        """ Tests a simple dynamic trait change handler. """
        class Test(HasTraits):
            i = Int

        # Create objects
        obj = Test()
        target = HasTraits()

        # Set up to count changes in i
        self.count = 0

        def count_notifies():
            self.count += 1
        obj.on_trait_change(count_notifies, "i", target=target)

        # Change the trait
        obj.i = 10
        # Delete the target and change it again
        del target
        obj.i = 0
        # The count should be 1
        self.assertEqual(self.count, 1)

    def test_extended(self):
        """ Tests a dynamic trait change handler using extended names. """

        class Child(HasTraits):
            i = Int

        class Parent(HasTraits):
            child = Instance(Child)

        # Create objects
        parent = Parent(child=Child())
        target = HasTraits()

        # Set up to count changes in i
        self.count = 0

        def count_notifies():
            self.count += 1
        parent.on_trait_change(count_notifies, "child:i", target=target)

        # Change the trait
        parent.child.i = 10
        # Delete the target and change it again
        del target
        parent.child.i = 0
        # The count should be 1
        self.assertEqual(self.count, 1)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_traits
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill Date: 03/20/2003 Description: Unit Test Case for the
# Traits Package
#------------------------------------------------------------------------------

#  Imports
from __future__ import absolute_import

import sys

from traits.testing.unittest_tools import unittest

from ..api import (Any, CFloat, CInt, CLong, Delegate, Float, HasTraits,
                   Instance, Int, List, Long, Str, Trait, TraitError,
                   TraitList, TraitPrefixList, TraitPrefixMap, TraitRange,
                   Tuple, pop_exception_handler, push_exception_handler)

#  Base unit test classes:


class BaseTest(object):

    def assign(self, value):
        self.obj.value = value

    def coerce(self, value):
        return value

    def test_assignment(self):
        obj = self.obj

        # Validate default value
        value = self._default_value
        self.assertEqual(obj.value, value)

        # Validate all legal values
        for i, value in enumerate(self._good_values):
            obj.value = value
            self.assertEqual(obj.value, self.coerce(value))

            # If there's a defined
            if i < len(self._mapped_values):
                self.assertEqual(obj.value_, self._mapped_values[i])

        # Validate correct behavior for illegal values
        for value in self._bad_values:
            self.assertRaises(TraitError, self.assign, value)


class test_base2(unittest.TestCase):

    def indexed_assign(self, list, index, value):
        list[index] = value

    def indexed_range_assign(self, list, index1, index2, value):
        list[index1: index2] = value

    def extended_slice_assign(self, list, index1, index2, step, value):
        list[index1:index2:step] = value

    # This avoids using a method name that contains 'test' so that this is not
    # called by the tester directly, as nose looks for all tests, regardless of
    # the handler at the bottom of this file.
    def check_values(self, name, default_value, good_values, bad_values,
                     actual_values=None, mapped_values=None):
        obj = self.obj
        try:
            # Make sure the default value is correct:
            msg = 'default value'
            value = default_value
            self.assertEqual(getattr(obj, name), value)

            # Iterate over all legal values being tested:
            if actual_values is None:
                actual_values = good_values
            msg = 'legal values'
            i = 0
            for value in good_values:
                setattr(obj, name, value)
                self.assertEqual(getattr(obj, name), actual_values[i])
                if mapped_values is not None:
                    self.assertEqual(getattr(obj, name + '_'),
                                     mapped_values[i])
                i += 1

            # Iterate over all illegal values being tested:
            msg = 'illegal values'
            for value in bad_values:
                self.assertRaises(TraitError, setattr, obj, name, value)
        except:
            print 'Failed while testing %s for value: %s(%s) in %s' % (
                msg, value, value.__class__.__name__, self.__class__.__name__)
            raise


class AnyTrait(HasTraits):
    value = Any


class AnyTraitTest(BaseTest, unittest.TestCase):

    obj = AnyTrait()

    _default_value = None
    _good_values = [10.0, 'ten', u'ten', [10], {'ten': 10}, (10,), None, 1j]
    _mapped_values = []
    _bad_values = []


class CoercibleIntTrait(HasTraits):
    value = CInt(99)


class IntTrait(HasTraits):
    value = Int(99)


class CoercibleIntTest(AnyTraitTest):

    obj = CoercibleIntTrait()

    _default_value = 99
    _good_values = [10, -10, 10L, -10L, 10.1, -10.1, '10', '-10', u'10',
                    u'-10']
    _bad_values = ['10L', '-10L', '10.1', '-10.1', u'10L', u'-10L', u'10.1',
                   u'-10.1', 'ten', u'ten', [10], {'ten': 10}, (10, ), None,
                   1j]

    def coerce(self, value):
        try:
            return int(value)
        except:
            try:
                return int(float(value))
            except:
                return int(long(value))


class IntTest(AnyTraitTest):

    obj = IntTrait()

    _default_value = 99
    _good_values = [10, -10, 10L, -10L]
    _bad_values = ['ten', u'ten', [10], {'ten': 10}, (10,), None, 1j,
                   10.1, -10.1, '10L', '-10L', '10.1', '-10.1', u'10L',
                   u'-10L', u'10.1', u'-10.1',  '10', '-10', u'10', u'-10']

    try:
        import numpy as np
    except ImportError:
        pass
    else:
        _good_values.extend([
            np.int64(10), np.int64(-10),
            np.int32(10), np.int32(-10),
            np.int_(10), np.int_(-10)
        ])

    def coerce(self, value):
        try:
            return int(value)
        except:
            try:
                return int(float(value))
            except:
                return int(long(value))


class CoercibleLongTrait(HasTraits):
    value = CLong(99L)


class LongTrait(HasTraits):
    value = Long(99L)


class CoercibleLongTest(AnyTraitTest):

    obj = CoercibleLongTrait()

    _default_value = 99L
    _good_values = [
        10, -10, 10L, -10L, 10.1, -10.1, '10', '-10', u'10', u'-10']
    if sys.version_info[0] < 3:
        _good_values.extend(['10L', '-10L', u'10L', u'-10L'])
    _bad_values = ['10.1', '-10.1', u'10.1', u'-10.1', 'ten', u'ten', [10],
                   [10l], {'ten': 10}, (10,), (10L,), None, 1j]

    def coerce(self, value):
        try:
            return long(value)
        except:
            return long(float(value))


class LongTest(AnyTraitTest):

    obj = LongTrait()

    _default_value = 99L
    _good_values = [10, -10, 10L, -10L]
    _bad_values = ['ten', u'ten', [10], [10l], {'ten': 10}, (10, ), (10L,),
                   None, 1j, 10.1, -10.1, '10', '-10', '10L', '-10L', '10.1',
                   '-10.1', u'10', u'-10', u'10L', u'-10L', u'10.1',
                   u'-10.1']

    def coerce(self, value):
        try:
            return long(value)
        except:
            return long(float(value))


class CoercibleFloatTrait(HasTraits):
    value = CFloat(99.0)


class FloatTrait(HasTraits):
    value = Float(99.0)


class CoercibleFloatTest(AnyTraitTest):
    obj = CoercibleFloatTrait()

    _default_value = 99.0
    _good_values = [10, -10, 10L, -10L, 10.1, -10.1, '10', '-10', '10.1',
                    '-10.1', u'10', u'-10', u'10.1', u'-10.1']
    _bad_values = ['10L', '-10L', u'10L', u'-10L', 'ten', u'ten', [10],
                   {'ten': 10}, (10, ), None, 1j]

    def coerce(self, value):
        try:
            return float(value)
        except:
            return float(long(value))


class FloatTest(AnyTraitTest):
    obj = FloatTrait()

    _default_value = 99.0
    _good_values = [10, -10, 10.1, -10.1]
    _bad_values = ['ten', u'ten', [10], {'ten': 10}, (10,), None,
                   1j, '10', '-10', '10L', '-10L', '10.1', '-10.1', u'10',
                   u'-10', u'10L', u'-10L', u'10.1', u'-10.1']

    if sys.version_info[0] < 3:
        # 2to3 will remove the L suffix and therfore make them actually good
        # ones!
        _bad_values.extend([-10L, 10L])

    def coerce(self, value):
        try:
            return float(value)
        except:
            return float(long(value))

#  Trait that can only have 'complex'(i.e. imaginary) values:


class ImaginaryValueTrait(HasTraits):
    value = Trait(99.0 - 99.0j)


class ImaginaryValueTest(AnyTraitTest):

    obj = ImaginaryValueTrait()

    _default_value = 99.0 - 99.0j
    _good_values = [10, -10, 10L, -10L, 10.1, -10.1, '10', '-10', '10.1',
                    '-10.1', 10j, 10 + 10j, 10 - 10j, 10.1j, 10.1 + 10.1j,
                    10.1 - 10.1j, '10j', '10+10j', '10-10j']
    _bad_values = [u'10L', u'-10L', 'ten', [10], {'ten': 10}, (10,), None]

    def coerce(self, value):
        try:
            return complex(value)
        except:
            return complex(long(value))


class StringTrait(HasTraits):
    value = Trait('string')


class StringTest(AnyTraitTest):

    obj = StringTrait()

    _default_value = 'string'
    _good_values = [10, -10, 10L, -10L, 10.1, -10.1, '10', '-10', '10L',
                    '-10L', '10.1', '-10.1', 'string', u'string', 1j, [10],
                    ['ten'], {'ten': 10}, (10,), None]
    _bad_values = []

    def coerce(self, value):
        return str(value)


class UnicodeTrait(HasTraits):
    value = Trait(u'unicode')


class UnicodeTest(StringTest):

    obj = UnicodeTrait()

    _default_value = u'unicode'
    _good_values = [10, -10, 10L, -10L, 10.1, -10.1, '10', '-10', '10L',
                    '-10L', '10.1', '-10.1', '', u'', 'string', u'string', 1j,
                    [10], ['ten'], [u'ten'], {'ten': 10}, (10,), None]
    _bad_values = []

    def coerce(self, value):
        return str(value)


class EnumTrait(HasTraits):
    value = Trait([1, 'one', 2, 'two', 3, 'three', 4.4, u'four.four'])


class EnumTest(AnyTraitTest):

    obj = EnumTrait()

    _default_value = 1
    _good_values = [1, 'one', 2, 'two', 3, 'three', 4.4, u'four.four']
    _bad_values = [0, 'zero', 4, None]


class MappedTrait(HasTraits):
    value = Trait('one', {'one': 1, 'two': 2, 'three': 3})


class MappedTest(AnyTraitTest):
    obj = MappedTrait()

    _default_value = 'one'
    _good_values = ['one', 'two', 'three']
    _mapped_values = [1, 2, 3]
    _bad_values = ['four', 1, 2, 3, [1], (1,), {1: 1}, None]


class PrefixListTrait(HasTraits):
    value = Trait('one', TraitPrefixList('one', 'two', 'three'))


class PrefixListTest(AnyTraitTest):
    obj = PrefixListTrait()

    _default_value = 'one'
    _good_values = ['o', 'on', 'one', 'tw', 'two', 'th', 'thr', 'thre',
                    'three']
    _bad_values = ['t', 'one ', ' two', 1, None]

    def coerce(self, value):
        return {'o': 'one', 'on': 'one', 'tw': 'two', 'th': 'three'}[value[:2]]


class PrefixMapTrait(HasTraits):
    value = Trait('one', TraitPrefixMap({'one': 1, 'two': 2, 'three': 3}))


class PrefixMapTest(AnyTraitTest):
    obj = PrefixMapTrait()

    _default_value = 'one'
    _good_values = ['o', 'on', 'one', 'tw', 'two', 'th', 'thr', 'thre',
                    'three']
    _mapped_values = [1, 1, 1, 2, 2, 3, 3, 3]
    _bad_values = ['t', 'one ', ' two', 1, None]

    def coerce(self, value):
        return {'o': 'one', 'on': 'one', 'tw': 'two', 'th': 'three'}[value[:2]]


class IntRangeTrait(HasTraits):
    value = Trait(3, TraitRange(2, 5))


class IntRangeTest(AnyTraitTest):

    obj = IntRangeTrait()

    _default_value = 3
    _good_values = [2, 3, 4, 5]
    _bad_values = [0, 1, 6, 0.999, 6.01, 'two', '0.999', '6.01', None]

    def coerce(self, value):
        try:
            return int(value)
        except:
            try:
                return int(float(value))
            except:
                return int(long(value))


class FloatRangeTrait(HasTraits):
    value = Trait(3.0, TraitRange(2.0, 5.0))


class FloatRangeTest(AnyTraitTest):

    obj = FloatRangeTrait()

    _default_value = 3.0
    _good_values = [2.0, 3.0, 4.0, 5.0, 2.001, 4.999]
    _bad_values = [0, 1, 6, 0L, 1L, 6L, 1.999, 6.01, 'two', '0.999', '6.01',
                   None]

    def coerce(self, value):
        try:
            return float(value)
        except:
            return float(long(value))


# Old style class version:


class OTraitTest1:
    pass


class OTraitTest2(OTraitTest1):
    pass


class OTraitTest3(OTraitTest2):
    pass


class OBadTraitTest:
    pass

otrait_test1 = OTraitTest1()


class OldInstanceTrait(HasTraits):
    value = Trait(otrait_test1)


class OldInstanceTest(AnyTraitTest):
    obj = OldInstanceTrait()

    _default_value = otrait_test1
    _good_values = [otrait_test1, OTraitTest1(), OTraitTest2(),
                    OTraitTest3(), None]
    _bad_values = [0, 0L, 0.0, 0j, OTraitTest1, OTraitTest2, OBadTraitTest(),
                   'string', u'string', [otrait_test1], (otrait_test1,),
                   {'data': otrait_test1}]


# New style class version:
class NTraitTest1(object):
    pass


class NTraitTest2(NTraitTest1):
    pass


class NTraitTest3(NTraitTest2):
    pass


class NBadTraitTest:
    pass


ntrait_test1 = NTraitTest1()


class NewInstanceTrait(HasTraits):
    value = Trait(ntrait_test1)


class NewInstanceTest(AnyTraitTest):
    obj = NewInstanceTrait()

    _default_value = ntrait_test1
    _good_values = [ntrait_test1, NTraitTest1(), NTraitTest2(), NTraitTest3(),
                    None]
    _bad_values = [0, 0L, 0.0, 0j, NTraitTest1, NTraitTest2, NBadTraitTest(),
                   'string', u'string', [ntrait_test1], (ntrait_test1,),
                   {'data': ntrait_test1}]


class FactoryClass(HasTraits):
    pass


class ConsumerClass(HasTraits):
    x = Instance(FactoryClass, ())


class ConsumerSubclass(ConsumerClass):
    x = FactoryClass()

embedded_instance_trait = Trait('', Str,
                                Instance('traits.has_traits.HasTraits'))


class Dummy(HasTraits):
    x = embedded_instance_trait
    xl = List(embedded_instance_trait)


class RegressionTest(unittest.TestCase):
    """ Check that fixed bugs stay fixed.
    """

    def test_factory_subclass_no_segfault(self):
        """ Test that we can provide an instance as a default in the definition
        of a subclass.
        """
        # There used to be a bug where this would segfault.
        obj = ConsumerSubclass()
        obj.x

    def test_trait_compound_instance(self):
        """ Test that a deferred Instance() embedded in a TraitCompound handler
        and then a list will not replace the validate method for the outermost
        trait.
        """
        # Pass through an instance in order to make the instance trait resolve
        # the class.
        d = Dummy()
        d.xl = [HasTraits()]
        d.x = 'OK'

#  Trait(using a function) that must be an odd integer:


def odd_integer(object, name, value):
    try:
        float(value)
        if(value % 2) == 1:
            return int(value)
    except:
        pass
    raise TraitError


class OddIntegerTrait(HasTraits):
    value = Trait(99, odd_integer)


class OddIntegerTest(AnyTraitTest):
    obj = OddIntegerTrait()

    _default_value = 99
    _good_values = [1, 3, 5, 7, 9, 999999999,
                    1L, 3L, 5L, 7L, 9L, 999999999L,
                    1.0, 3.0, 5.0, 7.0, 9.0, 999999999.0,
                    -1, -3, -5, -7, -9, -999999999,
                    -1L, -3L, -5L, -7L, -9L, -999999999L,
                    -1.0, -3.0, -5.0, -7.0, -9.0, -999999999.0]
    _bad_values = [0, 2, -2, 1j, None, '1', [1], (1,), {1: 1}]


class NotifierTraits(HasTraits):
    value1 = Int
    value2 = Int
    value1_count = Int
    value2_count = Int

    def _anytrait_changed(self, trait_name, old, new):
        if trait_name == 'value1':
            self.value1_count += 1
        elif trait_name == 'value2':
            self.value2_count += 1

    def _value1_changed(self, old, new):
        self.value1_count += 1

    def _value2_changed(self, old, new):
        self.value2_count += 1


class NotifierTests(unittest.TestCase):
    obj = NotifierTraits()

    def __init__(self, value):
        unittest.TestCase.__init__(self, value)

    def setUp(self):
        obj = self.obj
        obj.value1 = 0
        obj.value2 = 0
        obj.value1_count = 0
        obj.value2_count = 0

    def tearDown(self):
        obj = self.obj
        obj.on_trait_change(self.on_value1_changed, 'value1', remove=True)
        obj.on_trait_change(self.on_value2_changed, 'value2', remove=True)
        obj.on_trait_change(self.on_anytrait_changed, remove=True)

    def on_anytrait_changed(self, object, trait_name, old, new):
        if trait_name == 'value1':
            self.obj.value1_count += 1
        elif trait_name == 'value2':
            self.obj.value2_count += 1

    def on_value1_changed(self):
        self.obj.value1_count += 1

    def on_value2_changed(self):
        self.obj.value2_count += 1

    def test_simple(self):
        obj = self.obj

        obj.value1 = 1
        self.assertEqual(obj.value1_count, 2)
        self.assertEqual(obj.value2_count, 0)

        obj.value2 = 1
        self.assertEqual(obj.value1_count, 2)
        self.assertEqual(obj.value2_count, 2)

    def test_complex(self):
        obj = self.obj

        obj.on_trait_change(self.on_value1_changed, 'value1')
        obj.value1 = 1
        self.assertEqual(obj.value1_count, 3)
        self.assertEqual(obj.value2_count, 0)

        obj.on_trait_change(self.on_value2_changed, 'value2')
        obj.value2 = 1
        self.assertEqual(obj.value1_count, 3)
        self.assertEqual(obj.value2_count, 3)

        obj.on_trait_change(self.on_anytrait_changed)

        obj.value1 = 2
        self.assertEqual(obj.value1_count, 7)
        self.assertEqual(obj.value2_count, 3)

        obj.value1 = 2
        self.assertEqual(obj.value1_count, 7)
        self.assertEqual(obj.value2_count, 3)

        obj.value2 = 2
        self.assertEqual(obj.value1_count, 7)
        self.assertEqual(obj.value2_count, 7)

        obj.on_trait_change(self.on_value1_changed, 'value1', remove=True)
        obj.value1 = 3
        self.assertEqual(obj.value1_count, 10)
        self.assertEqual(obj.value2_count, 7)

        obj.on_trait_change(self.on_value2_changed, 'value2', remove=True)
        obj.value2 = 3
        self.assertEqual(obj.value1_count, 10)
        self.assertEqual(obj.value2_count, 10)

        obj.on_trait_change(self.on_anytrait_changed, remove=True)

        obj.value1 = 4
        self.assertEqual(obj.value1_count, 12)
        self.assertEqual(obj.value2_count, 10)

        obj.value2 = 4
        self.assertEqual(obj.value1_count, 12)
        self.assertEqual(obj.value2_count, 12)


class RaisesArgumentlessRuntimeError(HasTraits):
    x = Int(0)

    def _x_changed(self):
        raise RuntimeError


class TestRuntimeError(unittest.TestCase):

    def setUp(self):
        push_exception_handler(lambda *args: None, reraise_exceptions=True)

    def tearDown(self):
        pop_exception_handler()

    def test_runtime_error(self):
        f = RaisesArgumentlessRuntimeError()
        self.assertRaises(RuntimeError, setattr, f, 'x', 5)


class DelegatedFloatTrait(HasTraits):
    value = Trait(99.0)


class DelegateTrait(HasTraits):
    value = Delegate('delegate')
    delegate = Trait(DelegatedFloatTrait())


class DelegateTrait2(DelegateTrait):
    delegate = Trait(DelegateTrait())


class DelegateTrait3(DelegateTrait):
    delegate = Trait(DelegateTrait2())


class DelegateTests(unittest.TestCase):

    def test_delegation(self):
        obj = DelegateTrait3()

        self.assertEqual(obj.value, 99.0)
        parent1 = obj.delegate
        parent2 = parent1.delegate
        parent3 = parent2.delegate
        parent3.value = 3.0
        self.assertEqual(obj.value, 3.0)
        parent2.value = 2.0
        self.assertEqual(obj.value, 2.0)
        self.assertEqual(parent3.value, 3.0)
        parent1.value = 1.0
        self.assertEqual(obj.value, 1.0)
        self.assertEqual(parent2.value, 2.0)
        self.assertEqual(parent3.value, 3.0)
        obj.value = 0.0
        self.assertEqual(obj.value, 0.0)
        self.assertEqual(parent1.value, 1.0)
        self.assertEqual(parent2.value, 2.0)
        self.assertEqual(parent3.value, 3.0)
        del obj.value
        self.assertEqual(obj.value, 1.0)
        del parent1.value
        self.assertEqual(obj.value, 2.0)
        self.assertEqual(parent1.value, 2.0)
        del parent2.value
        self.assertEqual(obj.value, 3.0)
        self.assertEqual(parent1.value, 3.0)
        self.assertEqual(parent2.value, 3.0)
        del parent3.value
        # Uncommenting the following line allows
        # the last assertions to pass. However, this
        # may not be intended behavior, so keeping
        # the line commented.
        #del parent2.value
        self.assertEqual(obj.value, 99.0)
        self.assertEqual(parent1.value, 99.0)
        self.assertEqual(parent2.value, 99.0)
        self.assertEqual(parent3.value, 99.0)

#  Complex(i.e. 'composite') Traits tests:

# Make a TraitCompound handler that does not have a fast_validate so we can
# check for a particular regression.
slow = Trait(1, TraitRange(1, 3), TraitRange(-3, -1))
try:
    del slow.handler.fast_validate
except AttributeError:
    pass


class complex_value(HasTraits):
    num1 = Trait(1, TraitRange(1, 5), TraitRange(-5, -1))
    num2 = Trait(1, TraitRange(1, 5),
                 TraitPrefixList('one', 'two', 'three', 'four', 'five'))
    num3 = Trait(1, TraitRange(1, 5),
                 TraitPrefixMap({'one': 1, 'two': 2, 'three': 3,
                                 'four': 4, 'five': 5}))
    num4 = Trait(1, Trait(1, Tuple, slow), 10)
    num5 = Trait(1, 10, Trait(1, Tuple, slow))


class test_complex_value(test_base2):
    obj = complex_value()

    def test_num1(self):
        self.check_values('num1', 1, [1, 2, 3, 4, 5, -1, -2, -3, -4, -5],
                          [0, 6, -6, '0', '6', '-6', 0.0, 6.0, -6.0, [1], (1,),
                           {1: 1}, None],
                          [1, 2, 3, 4, 5, -1, -2, -3, -4, -5])

    def test_enum_exceptions(self):
        """ Check that enumerated values can be combined with nested
        TraitCompound handlers.
        """
        self.check_values('num4', 1, [1, 2, 3, -3, -2, -1, 10, ()],
                          [0, 4, 5, -5, -4, 11],
                          )
        self.check_values('num5', 1, [1, 2, 3, -3, -2, -1, 10, ()],
                          [0, 4, 5, -5, -4, 11],
                          )


class list_value(HasTraits):
    # Trait definitions:
    list1 = Trait([2], TraitList(Trait([1, 2, 3, 4]),
                                 maxlen=4))
    list2 = Trait([2], TraitList(Trait([1, 2, 3, 4]),
                                 minlen=1, maxlen=4))
    alist = List()


class test_list_value(test_base2):

    obj = list_value()

    def setUp(self):
        test_base2.setUp(self)
        self.last_event = None

    def tearDown(self):
        del self.last_event

    def del_range(self, list, index1, index2):
        del list[index1: index2]

    def del_extended_slice(self, list, index1, index2, step):
        del list[index1:index2:step]

    def check_list(self, list):
        self.assertEqual(list, [2])
        self.assertEqual(len(list), 1)
        list.append(3)
        self.assertEqual(len(list), 2)
        list[1] = 2
        self.assertEqual(list[1], 2)
        self.assertEqual(len(list), 2)
        list[0] = 1
        self.assertEqual(list[0], 1)
        self.assertEqual(len(list), 2)
        self.assertRaises(TraitError, self.indexed_assign, list, 0, 5)
        self.assertRaises(TraitError, list.append, 5)
        self.assertRaises(TraitError, list.extend, [1, 2, 3])
        list.extend([3, 4])
        self.assertEqual(list, [1, 2, 3, 4])
        self.assertRaises(TraitError, list.append, 1)
        self.assertRaises(ValueError,
                          self.extended_slice_assign,
                          list, 0, 4, 2, [4, 5, 6])
        del list[1]
        self.assertEqual(list, [1, 3, 4])
        del list[0]
        self.assertEqual(list, [3, 4])
        list[:0] = [1, 2]
        self.assertEqual(list, [1, 2, 3, 4])
        self.assertRaises(TraitError,
                          self.indexed_range_assign, list, 0, 0, [1])
        del list[0:3]
        self.assertEqual(list, [4])
        self.assertRaises(TraitError,
                          self.indexed_range_assign, list, 0, 0, [4, 5])

    def test_list1(self):
        self.check_list(self.obj.list1)

    def test_list2(self):
        self.check_list(self.obj.list2)
        self.assertRaises(TraitError, self.del_range, self.obj.list2, 0, 1)
        self.assertRaises(TraitError,
                          self.del_extended_slice,
                          self.obj.list2, 4, -5, -1)

    def assertLastTraitListEventEqual(self, index, removed, added):
        self.assertEqual(self.last_event.index, index)
        self.assertEqual(self.last_event.removed, removed)
        self.assertEqual(self.last_event.added, added)

    def test_trait_list_event(self):
        """ Record TraitListEvent behavior.
        """
        # FIXME: The behavior of TraitListEvent is suboptimal with
        # respect to extended slice changes. Previously, TraitListObject
        # used to have a __setitem__() and a separate __setslice__() to
        # handle non-extended slices. Extended slices were added to the
        # underlying list object later. The __setitem__() code handled
        # the new extended slices, but created the TraitListEvent in the
        # same way it did for an integer index; namely it wrapped the
        # value with a list. For simple slices, the `index` attribute of
        # the TraitListEvent is an integer, and the `added` list is just
        # the list of values added. For an extended slice, the `index`
        # attribute is the slice object and the `added` list is the list
        # of values wrapped in another list.
        self.obj.alist = [1, 2, 3, 4]
        self.obj.on_trait_change(self._record_trait_list_event, 'alist_items')
        del self.obj.alist[0]
        self.assertLastTraitListEventEqual(0, [1], [])
        self.obj.alist.append(5)
        self.assertLastTraitListEventEqual(3, [], [5])
        self.obj.alist[0:2] = [6, 7]
        self.assertLastTraitListEventEqual(0, [2, 3], [6, 7])
        self.obj.alist[0:2:1] = [8, 9]
        self.assertLastTraitListEventEqual(0, [6, 7], [8, 9])
        old_event = self.last_event
        self.obj.alist[0:2:1] = [8, 9]
        # If no values changed, no new TraitListEvent will be generated.
        self.assertIs(self.last_event, old_event)
        self.obj.alist[0:4:2] = [10, 11]
        self.assertLastTraitListEventEqual(
            slice(0, 4, 2), [[8, 4]], [[10, 11]])
        del self.obj.alist[1:4:2]
        self.assertLastTraitListEventEqual(slice(1, 4, 2), [[9, 5]], [])
        self.obj.alist = [1, 2, 3, 4]
        del self.obj.alist[2:4]
        self.assertLastTraitListEventEqual(2, [3, 4], [])

    def _record_trait_list_event(self, object, name, old, new):
        self.last_event = new

########NEW FILE########
__FILENAME__ = test_trait_change_event_tracer
""" Tests for the trait change event tracer. """
from traits.api import Float, HasTraits, on_trait_change
from traits.testing.unittest_tools import unittest

from traits import trait_notifiers


class FuzException(Exception):
    pass


class Foo(HasTraits):
    """ Test traits class with static and dynamic listeners.

    Changing `baz` triggers a dynamic listeners that modifies `bar`, which
    triggers one dynamic and one static listeners.
    """

    bar = Float
    baz = Float
    fuz = Float

    def _bar_changed(self):
        pass

    @on_trait_change('bar')
    def _on_bar_change_notification(self):
        pass

    @on_trait_change('baz')
    def _on_baz_change_notification(self):
        self.bar += 1

    @on_trait_change('fuz')
    def _on_fuz_change_notification(self):
        self.bar += 1
        raise FuzException('method')


class TestChangeEventTracers(unittest.TestCase):

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        self.pre_change_events = []
        self.post_change_events = []
        self.exceptions = []
        trait_notifiers.push_exception_handler(
            lambda obj, name, old, new: None
        )

    def tearDown(self):
        trait_notifiers.pop_exception_handler()

    #### Private protocol #####################################################

    def _collect_pre_notification_events(self, *args):
        self.pre_change_events.append(args)

    def _collect_post_notification_events(self, *args, **kwargs):
        self.post_change_events.append(args)
        self.exceptions.extend(kwargs.values())

    #### Tests ################################################################

    def test_change_event_hooks(self):

        # Create the test object and a function listener.
        foo = Foo()

        def _on_foo_baz_changed(obj, name, old, new):
            pass
        foo.on_trait_change(_on_foo_baz_changed, 'baz')

        # Set the event tracer and trigger a cascade of change events.
        trait_notifiers.set_change_event_tracers(
            pre_tracer=self._collect_pre_notification_events,
            post_tracer=self._collect_post_notification_events)

        foo.baz = 3

        self.assertEqual(len(self.pre_change_events), 4)
        self.assertEqual(len(self.post_change_events), 4)

        expected_pre_events = [
            (foo, 'baz', 0.0, 3.0, foo._on_baz_change_notification),
            (foo, 'bar', 0.0, 1.0, foo._bar_changed.im_func),
            (foo, 'bar', 0.0, 1.0, foo._on_bar_change_notification),
            (foo, 'baz', 0.0, 3.0, _on_foo_baz_changed),
        ]
        self.assertEqual(self.pre_change_events, expected_pre_events)

        expected_post_events = [
            (foo, 'bar', 0.0, 1.0, foo._bar_changed.im_func),
            (foo, 'bar', 0.0, 1.0, foo._on_bar_change_notification),
            (foo, 'baz', 0.0, 3.0, foo._on_baz_change_notification),
            (foo, 'baz', 0.0, 3.0, _on_foo_baz_changed),
        ]
        self.assertEqual(self.post_change_events, expected_post_events)

        self.assertEqual(self.exceptions, [None] * 4)

        # Deactivate the tracer; it should not be called anymore.
        trait_notifiers.clear_change_event_tracers()
        foo.baz = 23
        self.assertEqual(len(self.pre_change_events), 4)
        self.assertEqual(len(self.post_change_events), 4)

    def test_change_event_hooks_after_exception(self):

        # Create the test object and a function listener.
        foo = Foo()

        def _on_foo_fuz_changed(obj, name, old, new):
            raise FuzException('function')
        foo.on_trait_change(_on_foo_fuz_changed, 'fuz')

        # Set the event tracer and trigger a cascade of change events.
        trait_notifiers.set_change_event_tracers(
            pre_tracer=self._collect_pre_notification_events,
            post_tracer=self._collect_post_notification_events)

        foo.fuz = 3

        self.assertEqual(len(self.pre_change_events), 4)
        self.assertEqual(len(self.post_change_events), 4)

        expected_pre_events = [
            (foo, 'fuz', 0.0, 3.0, foo._on_fuz_change_notification),
            (foo, 'bar', 0.0, 1.0, foo._bar_changed.im_func),
            (foo, 'bar', 0.0, 1.0, foo._on_bar_change_notification),
            (foo, 'fuz', 0.0, 3.0, _on_foo_fuz_changed),
        ]
        self.assertEqual(self.pre_change_events, expected_pre_events)

        expected_post_events = [
            (foo, 'bar', 0.0, 1.0, foo._bar_changed.im_func),
            (foo, 'bar', 0.0, 1.0, foo._on_bar_change_notification),
            (foo, 'fuz', 0.0, 3.0, foo._on_fuz_change_notification),
            (foo, 'fuz', 0.0, 3.0, _on_foo_fuz_changed),
        ]
        self.assertEqual(self.post_change_events, expected_post_events)

        self.assertEqual(self.exceptions[:2], [None, None])
        self.assertIsInstance(self.exceptions[2], FuzException)
        self.assertEqual(self.exceptions[2].args, ('method',))
        self.assertIsInstance(self.exceptions[3], FuzException)
        self.assertEqual(self.exceptions[3].args, ('function',))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_trait_cycle
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------
""" Test whether HasTraits objects with cycles can be garbage collected.
"""

from __future__ import absolute_import

import gc
import time
from traits.testing.unittest_tools import unittest

# Enthought library imports
from ..api import HasTraits, Any, DelegatesTo, Instance, Int


class TestCase(unittest.TestCase):
    def _simple_cycle_helper(self, foo_class):
        """ Can the garbage collector clean up a cycle with traits objects?
        """

        # Create two Foo objects that refer to each other.
        first = foo_class()
        second = foo_class(child=first)
        first.child = second

        # get their ids
        foo_ids = [id(first), id(second)]

        # delete the items so that they can be garbage collected
        del first, second

        # tell the garbage collector to pick up the litter.
        gc.collect()

        # Now grab all objects in the process and ask for their ids
        all_ids = [id(obj) for obj in gc.get_objects()]

        # Ensure that neither of the Foo object ids are in this list
        for foo_id in foo_ids:
            self.assertTrue(foo_id not in all_ids)

    def test_simple_cycle_oldstyle_class(self):
        """ Can the garbage collector clean up a cycle with old style class?
        """
        class Foo:
            def __init__(self, child=None):
                self.child = child

        self._simple_cycle_helper(Foo)

    def test_simple_cycle_newstyle_class(self):
        """ Can the garbage collector clean up a cycle with new style class?
        """
        class Foo(object):
            def __init__(self, child=None):
                self.child = child

        self._simple_cycle_helper(Foo)

    def test_simple_cycle_hastraits(self):
        """ Can the garbage collector clean up a cycle with traits objects?
        """
        class Foo(HasTraits):
            child = Any

        self._simple_cycle_helper(Foo)

    def test_reference_to_trait_dict(self):
        """ Does a HasTraits object refer to its __dict__ object?

            This test may point to why the previous one fails.  Even if it
            doesn't, the functionality is needed for detecting problems
            with memory in debug.memory_tracker
        """

        class Foo(HasTraits):
            child = Any

        foo = Foo()

        # It seems like foo sometimes has not finished construction yet, so
        # the frame found by referrers is not _exactly_ the same as Foo(). For
        # more information, see the gc doc: http://docs.python.org/lib/module-
        # gc.html
        #
        # The documentation says that this (get_referrers) should be used for
        # no purpose other than debugging, so this is really not a good way to
        # test the code.

        time.sleep(0.1)
        referrers = gc.get_referrers(foo.__dict__)

        self.assertTrue(len(referrers) > 0)
        self.assertTrue(foo in referrers)

    def test_delegates_to(self):
        """ Tests if an object that delegates to another is freed.
        """
        class Base(HasTraits):
            """ Object we are delegating to. """

            i = Int

        class Delegates(HasTraits):
            """ Object that delegates. """

            b = Instance(Base)

            i = DelegatesTo('b')

        # Make a pair of object
        b = Base()
        d = Delegates(b=b)

        # Delete d and thoroughly collect garbage
        del d
        for i in range(3):
            gc.collect(2)

        # See if we still have a Delegates
        ds = [obj for obj in gc.get_objects() if isinstance(obj, Delegates)]
        self.assertEqual(ds, [])

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_trait_default_initializer
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

from __future__ import absolute_import

import unittest

from ..trait_types import Int
from ..has_traits import HasTraits


class Foo(HasTraits):

    bar = Int

    def _bar_default(self):
        return 4


class TestTraitDefaultInitializer(unittest.TestCase):
    """ Test basic usage of the default method.

    """

    def test_default_value(self):
        foo = Foo()
        self.assertEqual(foo.bar, 4)

    def test_default_value_override(self):
        foo = Foo(bar=3)
        self.assertEqual(foo.bar, 3)

    def test_reset_to_default(self):
        foo = Foo(bar=3)
        foo.reset_traits(traits=['bar'])
        self.assertEqual(foo.bar, 4)

    def test_error_propagation_in_default_methods(self):

        class FooException(Foo):

            def _bar_default(self):
                1 / 0

        foo = FooException()
        self.assertRaises(ZeroDivisionError, lambda: foo.bar)

        class FooKeyError(Foo):

            def _bar_default(self):
                raise KeyError()

        # Check that KeyError is propagated (issue #70).
        foo = FooKeyError()
        self.assertRaises(KeyError, lambda: foo.bar)

########NEW FILE########
__FILENAME__ = test_trait_list_dict
##############################################################################
# Copyright 2014 Enthought, Inc.
##############################################################################

""" Test the persistence behavior of TraitListObjects, TraitDictObjects and
TraitSetObjects.
"""

from __future__ import absolute_import

import copy
from cPickle import dumps, loads

from ..has_traits import HasTraits, on_trait_change
from ..trait_types import Dict, List, Set, Str, Int, Instance


class A(HasTraits):
    alist = List(Int, range(5))
    adict = Dict(Str, Int, dict(a=1, b=2))
    aset = Set(Int, range(5))

    events = List()

    @on_trait_change('alist_items,adict_items,aset_items')
    def _receive_events(self, object, name, old, new):
        self.events.append((name, new))


class B(HasTraits):
    dict = Dict(Str, Instance(A))


def test_trait_list_object_persists():
    a = A()
    list = loads(dumps(a.alist))
    assert list.object() is None
    list.append(10)
    assert len(a.events) == 0
    a.alist.append(20)
    assert len(a.events) == 1
    list2 = loads(dumps(list))
    assert list2.object() is None


def test_trait_dict_object_persists():
    a = A()
    dict = loads(dumps(a.adict))
    assert dict.object() is None
    dict['key'] = 10
    assert len(a.events) == 0
    a.adict['key'] = 10
    assert len(a.events) == 1
    dict2 = loads(dumps(dict))
    assert dict2.object() is None


def test_trait_set_object_persists():
    a = A()
    set = loads(dumps(a.aset))
    assert set.object() is None
    set.add(10)
    assert len(a.events) == 0
    a.aset.add(20)
    assert len(a.events) == 1
    set2 = loads(dumps(set))
    assert set2.object() is None


def test_trait_list_object_copies():
    a = A()
    list = copy.deepcopy(a.alist)
    assert list.object() is None
    list.append(10)
    assert len(a.events) == 0
    a.alist.append(20)
    assert len(a.events) == 1
    list2 = copy.deepcopy(list)
    list2.append(30)
    assert list2.object() is None


def test_trait_dict_object_copies():
    a = A()
    dict = copy.deepcopy(a.adict)
    assert dict.object() is None
    dict['key'] = 10
    assert len(a.events) == 0
    a.adict['key'] = 10
    assert len(a.events) == 1
    dict2 = copy.deepcopy(dict)
    dict2['key2'] = 20
    assert dict2.object() is None


def test_trait_set_object_copies():
    a = A()
    set1 = copy.deepcopy(a.aset)
    assert set1.object() is None
    set1.add(10)
    assert len(a.events) == 0
    a.aset.add(20)
    assert len(a.events) == 1
    set2 = copy.deepcopy(set1)
    set2.add(30)
    assert set2.object() is None
    set3 = a.aset.copy()
    assert type(set3) is set
    # Should not raise an AttributeError:
    set3.remove(20)


def test_pickle_whole():
    a = A()
    loads(dumps(a))
    b = B(dict=dict(a=a))
    loads(dumps(b))

########NEW FILE########
__FILENAME__ = test_trait_types
#  Unit test case for testing trait types created by subclassing TraitType.
#
#  Written by: David C. Morrill
#
#  Date: 4/10/2007
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#

""" Unit test case for testing trait types created by subclassing TraitType.
"""

from traits.testing.unittest_tools import unittest

from traits.api import Float, TraitType


class TraitTypesTest(unittest.TestCase):

    def test_traits_shared_transient(self):
        # Regression test for a bug in traits where the same _metadata
        # dictionary was shared between different trait types.
        class LazyProperty(TraitType):
            def get(self, obj, name):
                return 1729

        self.assertFalse(Float().transient)
        LazyProperty().as_ctrait()
        self.assertFalse(Float().transient)

    def test_numpy_validators_loaded_if_numpy_present(self):
        # If 'numpy' is available, the numpy validators should be loaded.

        # Make sure that numpy is present on this machine.
        try:
            import numpy
        except ImportError:
            self.skipTest("numpy library not found.")

        # Remove numpy from the list of imported modules.
        import sys
        del sys.modules['numpy']
        for k in list(sys.modules):
            if k.startswith('numpy.'):
                del sys.modules[k]

        # Check that the validators contain the numpy types.
        from traits.trait_types import float_fast_validate
        import numpy
        self.assertIn(numpy.floating, float_fast_validate)


# Run the unit tests (if invoked from the command line):
if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tuple
""" Unit tests for the Tuple trait type.
"""

from traits.testing.unittest_tools import unittest, UnittestTools

from traits.api import HasTraits, Tuple, TraitError

VALUES = ('value1', 33, None)


class E(HasTraits):

    t1 = Tuple(VALUES)

    t2 = Tuple(*VALUES)


class TupleTestCase(unittest.TestCase, UnittestTools):

    def test_default_values(self):
        # Check that the default values for t1 and t2 are correctly
        # derived from the VALUES tuple.

        e = E()
        self.assertEqual(e.t1, VALUES)
        self.assertEqual(e.t2, VALUES)

    def test_simple_assignment(self):
        # Check that we can assign different values of the correct type.

        e = E()
        with self.assertTraitChanges(e, 't1'):
            e.t1 = ('other value 1', 77, None)
        with self.assertTraitChanges(e, 't2'):
            e.t2 = ('other value 2', 99, None)

    def test_invalid_assignment_length(self):
        # Check that assigning a tuple of incorrect length
        # raises a TraitError.
        self._assign_invalid_values_length(('str', 44))
        self._assign_invalid_values_length(('str', 33, None, []))

    def test_type_checking(self):
        # Test that type checking is done for the 't1' attribute.
        e = E()
        other_tuple = ('other value', 75, True)
        with self.assertRaises(TraitError):
            e.t1 = other_tuple
        self.assertEqual(e.t1, VALUES)

        # Test that no type checking is done for the 't2' attribute.
        try:
            e.t2 = other_tuple
        except TraitError:
            self.fail('Unexpected TraitError when assigning to tuple.')
        self.assertEqual(e.t2, other_tuple)

    def _assign_invalid_values_length(self, values):

        e = E()
        with self.assertRaises(TraitError):
            e.t1 = values
        self.assertEqual(e.t1, VALUES)
        with self.assertRaises(TraitError):
            e.t2 = values
        self.assertEqual(e.t2, VALUES)

########NEW FILE########
__FILENAME__ = test_ui_notifiers
""" Tests for dynamic notifiers with `dispatch='ui'`.

Dynamic notifiers created with the `dispatch='ui'` option dispatch event
notifications on the UI thread. The class handling the dispatch,
`FastUITraitChangeNotifyWrapper`, is a subclass of `TraitChangeNotifyWrapper`.
Most of the functionality of the class is thus already covered by the
`TestDynamicNotifiers` test case, and we only need to test that the
notification really occurs on the UI thread.

At present, `dispatch='ui'` and `dispatch='fast_ui'` have the same effect.

"""

# Preamble: Try importing Qt, and set QT_FOUND to True on success.
try:
    from pyface.util.guisupport import get_app_qt4, start_event_loop_qt4

    # This import is necessary to set the `ui_handler` global variable in
    # `traits.trait_notifiers`, which is responsible for dispatching the events
    # to the UI thread.
    from traitsui.qt4 import toolkit

    qt4_app = get_app_qt4()

except Exception:
    QT_FOUND = False

else:
    QT_FOUND = True


import thread
from threading import Thread
import time

from traits.api import Float, HasTraits
from traits.testing.unittest_tools import unittest

from traits import trait_notifiers


class Foo(HasTraits):
    foo = Float


class TestUINotifiers(unittest.TestCase):
    """ Tests for dynamic notifiers with `dispatch='ui'`. """

    #### 'TestCase' protocol ##################################################

    def setUp(self):
        self.notifications = []

    #### 'TestUINotifiers' protocol ###########################################

    def flush_event_loop(self):
        """ Post and process the Qt events. """
        qt4_app.sendPostedEvents()
        qt4_app.processEvents()

    def on_foo_notifications(self, obj, name, old, new):
        thread_id = thread.get_ident()
        event = (thread_id, (obj, name, old, new))
        self.notifications.append(event)

    #### Tests ################################################################

    @unittest.skipIf(
        not QT_FOUND, "Qt event loop not found, UI dispatch not possible.")
    def test_notification_from_main_thread(self):

        obj = Foo()
        obj.on_trait_change(self.on_foo_notifications, 'foo', dispatch='ui')

        obj.foo = 3
        self.flush_event_loop()

        notifications = self.notifications
        self.assertEqual(len(notifications), 1)

        thread_id, event = notifications[0]
        self.assertEqual(event, (obj, 'foo', 0, 3))

        ui_thread = trait_notifiers.ui_thread
        self.assertEqual(thread_id, ui_thread)

    @unittest.skipIf(
        not QT_FOUND, "Qt event loop not found, UI dispatch not possible.")
    def test_notification_from_separate_thread(self):

        obj = Foo()
        obj.on_trait_change(self.on_foo_notifications, 'foo', dispatch='ui')

        # Set obj.foo to 3 on a separate thread.
        def set_foo_to_3(obj):
            obj.foo = 3

        Thread(target=set_foo_to_3, args=(obj,)).start()

        # Wait for a while to make sure the function has finished.
        time.sleep(0.1)

        self.flush_event_loop()

        notifications = self.notifications
        self.assertEqual(len(notifications), 1)

        thread_id, event = notifications[0]
        self.assertEqual(event, (obj, 'foo', 0, 3))

        ui_thread = trait_notifiers.ui_thread
        self.assertEqual(thread_id, ui_thread)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_undefined
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.testing.unittest_tools import unittest

from ..api import HasTraits, Str, Undefined, ReadOnly, Float


class Foo(HasTraits):
    name = Str()
    original_name = ReadOnly

    bar = Str
    baz = Float

    def _name_changed(self):
        if self.original_name is Undefined:
            self.original_name = self.name


class Bar(HasTraits):
    name = Str(Undefined)


class UndefinedTestCase(unittest.TestCase):
    def test_initial_value(self):
        b = Bar()
        self.assertEqual(b.name, Undefined)
        return

    def test_name_change(self):
        b = Bar()
        b.name = 'first'
        self.assertEqual(b.name, 'first')
        return

    def test_read_only_write_once(self):
        f = Foo()

        self.assertEqual(f.name, '')
        self.assertIs(f.original_name, Undefined)

        f.name = 'first'
        self.assertEqual(f.name, 'first')
        self.assertEqual(f.original_name, 'first')

        f.name = 'second'
        self.assertEqual(f.name, 'second')
        self.assertEqual(f.original_name, 'first')

        return

    def test_read_only_write_once_from_constructor(self):
        f = Foo(name='first')

        f.name = 'first'
        self.assertEqual(f.name, 'first')
        self.assertEqual(f.original_name, 'first')

        f.name = 'second'
        self.assertEqual(f.name, 'second')
        self.assertEqual(f.original_name, 'first')

        return

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = test_weak_ref
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------
""" Test cases for weakref (WeakRef) traits. """

import contextlib
import gc

from traits.testing.unittest_tools import unittest, UnittestTools

from ..trait_types import Str, WeakRef
from ..has_traits import HasTraits


class Eggs(HasTraits):
    name = Str


class Spam(HasTraits):
    eggs = WeakRef(Eggs)


@contextlib.contextmanager
def restore_gc_state():
    """Ensure that gc state is restored on exit of the with statement."""
    originally_enabled = gc.isenabled()
    try:
        yield
    finally:
        if originally_enabled:
            gc.enable()
        else:
            gc.disable()


class TestWeakRef(UnittestTools, unittest.TestCase):
    """ Test cases for weakref (WeakRef) traits. """

    def test_set_and_get(self):
        eggs = Eggs(name='platypus')
        spam = Spam()
        self.assertIsNone(spam.eggs)
        spam.eggs = eggs
        self.assertIs(spam.eggs, eggs)
        del eggs
        self.assertIsNone(spam.eggs)

    def test_target_freed_notification(self):
        eggs = Eggs(name='duck')
        spam = Spam(eggs=eggs)

        # Removal of the last reference to 'eggs' should trigger notification.
        with self.assertTraitChanges(spam, 'eggs'):
            del eggs

    def test_weakref_trait_doesnt_leak_cycles(self):
        eggs = Eggs(name='ostrich')
        with restore_gc_state():
            gc.disable()
            gc.collect()
            spam = Spam(eggs=eggs)
            del spam
            self.assertEqual(gc.collect(), 0)

########NEW FILE########
__FILENAME__ = traits
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author:        David C. Morrill
#  Original Date: 06/21/2002
#
#  Rewritten as a C-based type extension: 06/21/2004
#
#------------------------------------------------------------------------------

"""
Defines the 'core' traits for the Traits package. A trait is a type definition
that can be used for normal Python object attributes, giving the attributes
some additional characteristics:

Initialization:
    Traits have predefined values that do not need to be explicitly
    initialized in the class constructor or elsewhere.
Validation:
    Trait attributes have flexible, type-checked values.
Delegation:
    Trait attributes' values can be delegated to other objects.
Notification:
    Trait attributes can automatically notify interested parties when
    their values change.
Visualization:
    Trait attributes can automatically construct (automatic or
    programmer-defined) user interfaces that allow their values to be
    edited or displayed)

.. note:: 'trait' is a synonym for 'property', but is used instead of the
    word 'property' to differentiate it from the Python language 'property'
    feature.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import sys
from types import FunctionType, MethodType
NoneType = type(None)   # Python 3's types does not include NoneType

from . import trait_handlers
from .ctraits import cTrait
from .trait_errors import TraitError
from .trait_base import (SequenceTypes, Self, Undefined, Missing, TypeTypes,
    add_article)

from .trait_handlers import (TraitHandler, TraitInstance, TraitFunction,
    TraitCoerceType, TraitCastType, TraitEnum, TraitCompound, TraitMap,
    TraitString, ThisClass, TraitType, _arg_count, _read_only, _write_only,
    _undefined_get, _undefined_set)


#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping from 'ctrait' default value types to a string representation:
KindMap = {
   0: 'value',
   1: 'value',
   2: 'self',
   3: 'list',
   4: 'dict',
   5: 'list',
   6: 'dict',
   7: 'factory',
   8: 'method'
}

#-------------------------------------------------------------------------------
#  Editor factory functions:
#-------------------------------------------------------------------------------

PasswordEditor      = None
MultilineTextEditor = None
SourceCodeEditor    = None
HTMLTextEditor      = None
PythonShellEditor   = None
DateEditor          = None
TimeEditor          = None

def password_editor ( auto_set=True, enter_set=False ):
    """ Factory function that returns an editor for passwords.
    """
    global PasswordEditor

    if PasswordEditor is None:
        from traitsui.api import TextEditor
        PasswordEditor = TextEditor( password = True ,
                                     auto_set   = auto_set,
                                     enter_set  = enter_set )

    return PasswordEditor

def multi_line_text_editor ( auto_set=True, enter_set=False ):
    """ Factory function that returns a text editor for multi-line strings.
    """
    global MultilineTextEditor

    if MultilineTextEditor is None:
        from traitsui.api import TextEditor
        MultilineTextEditor = TextEditor( multi_line = True,
                                          auto_set   = auto_set,
                                          enter_set  = enter_set )

    return MultilineTextEditor

def code_editor ( ):
    """ Factory function that returns an editor that treats a multi-line string
    as source code.
    """
    global SourceCodeEditor

    if SourceCodeEditor is None:
        from traitsui.api import CodeEditor
        SourceCodeEditor = CodeEditor()

    return SourceCodeEditor

def html_editor ( ):
    """ Factory function for an "editor" that displays a multi-line string as
    interpreted HTML.
    """
    global HTMLTextEditor

    if HTMLTextEditor is None:
        from traitsui.api import HTMLEditor
        HTMLTextEditor = HTMLEditor()

    return HTMLTextEditor

def shell_editor ( ):
    """ Factory function that returns a Python shell for editing Python values.
    """
    global PythonShellEditor

    if PythonShellEditor is None:
        from traitsui.api import ShellEditor
        PythonShellEditor = ShellEditor()

    return PythonShellEditor

def time_editor ( ):
    """ Factory function that returns a Time editor for editing Time values.
    """
    global TimeEditor

    if TimeEditor is None:
        from traitsui.api import TimeEditor
        TimeEditor = TimeEditor()

    return TimeEditor

def date_editor ( ):
    """ Factory function that returns a Date editor for editing Date values.
    """
    global DateEditor

    if DateEditor is None:
        from traitsui.api import DateEditor
        DateEditor = DateEditor()

    return DateEditor

#-------------------------------------------------------------------------------
#  'CTrait' class (extends the underlying cTrait c-based type):
#-------------------------------------------------------------------------------

class CTrait ( cTrait ):
    """ Extends the underlying C-based cTrait type.
    """

    #---------------------------------------------------------------------------
    #  Allows a derivative trait to be defined from this one:
    #---------------------------------------------------------------------------

    def __call__ ( self, *args, **metadata ):
        handler = self.handler
        if isinstance( handler, TraitType ):
            dict = (self.__dict__ or {}).copy()
            dict.update( metadata )

            return handler( *args, **dict )

        metadata.setdefault( 'parent', self )
        return Trait( *(args + ( self, )), **metadata )

    #---------------------------------------------------------------------------
    #  (Python) property definitions:
    #---------------------------------------------------------------------------

    def __get_default ( self ):
        kind, value = self.default_value()
        if kind in ( 2, 7, 8 ):
            return Undefined

        if kind in ( 4, 6 ):
            return value.copy()

        if kind in ( 3, 5 ):
            return value[:]

        return value

    default = property( __get_default )

    def __get_default_kind ( self ):
        return KindMap[ self.default_value()[0] ]

    default_kind = property( __get_default_kind )

    def __get_trait_type ( self ):
        handler = self.handler
        if handler is not None:
            return handler
        else:
            from .trait_types import Any
            return Any

    trait_type = property( __get_trait_type )

    def __get_inner_traits ( self ):
        handler = self.handler
        if handler is not None:
            return handler.inner_traits()

        return ()

    inner_traits = property( __get_inner_traits )

    #---------------------------------------------------------------------------
    #  Returns whether or not this trait is of a specified trait type:
    #---------------------------------------------------------------------------

    def is_trait_type ( self, trait_type ):
        """ Returns whether or not this trait is of a specified trait type.
        """
        return isinstance( self.trait_type, trait_type )

    #---------------------------------------------------------------------------
    #  Returns the user interface editor associated with the trait:
    #---------------------------------------------------------------------------

    def get_editor ( self ):
        """ Returns the user interface editor associated with the trait.
        """
        from traitsui.api import EditorFactory

        # See if we have an editor:
        editor = self.editor
        if editor is None:

            # Else see if the trait handler has an editor:
            handler = self.handler
            if handler is not None:
                editor = handler.get_editor( self )

            # If not, give up and use a default text editor:
            if editor is None:
                from traitsui.api import TextEditor
                editor = TextEditor

        # If the result is not an EditorFactory:
        if not isinstance( editor, EditorFactory ):
            # Then it should be a factory for creating them:
            args   = ()
            traits = {}
            if type( editor ) in SequenceTypes:
                for item in editor[:]:
                    if type( item ) in SequenceTypes:
                        args = tuple( item )
                    elif isinstance( item, dict ):
                        traits = item
                        if traits.get( 'trait', 0 ) is None:
                            traits = traits.copy()
                            traits[ 'trait' ] = self
                    else:
                        editor = item
            editor = editor( *args, **traits )

        # Cache the result:
        self.editor = editor

        # Return the resulting EditorFactory object:
        return editor

    #---------------------------------------------------------------------------
    #  Returns the help text for a trait:
    #---------------------------------------------------------------------------

    def get_help ( self, full = True ):
        """ Returns the help text for a trait.

        Parameters
        ----------
        full : bool
            Indicates whether to return the value of the *help* attribute of
            the trait itself.

        Description
        -----------
        If *full* is False or the trait does not have a **help** string,
        the returned string is constructed from the **desc** attribute on the
        trait and the **info** string on the trait's handler.
        """
        if full:
            help = self.help
            if help is not None:
                return help

        handler = self.handler
        if handler is not None:
            info = 'must be %s.' % handler.info()
        else:
            info = 'may be any value.'

        desc = self.desc
        if self.desc is None:
            return info.capitalize()

        return 'Specifies %s and %s' % ( desc, info )

    #---------------------------------------------------------------------------
    #  Returns a description of the trait:
    #---------------------------------------------------------------------------

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        handler = self.handler
        if handler is not None:
            return handler.full_info( object, name, value )

        return 'any value'

    #---------------------------------------------------------------------------
    #  Returns a description of the trait:
    #---------------------------------------------------------------------------

    def info ( self ):
        """ Returns a description of the trait.
        """
        handler = self.handler
        if handler is not None:
            return handler.info()

        return 'any value'

    #---------------------------------------------------------------------------
    #  Returns the pickleable form of a CTrait object:
    #---------------------------------------------------------------------------

    def __reduce_ex__ ( self, protocol ):
        return ( __newobj__, ( self.__class__, 0 ), self.__getstate__() )

    #---------------------------------------------------------------------------
    #  Registers listeners on an assigned 'TraitValue' object's 'value'
    #  property:
    #---------------------------------------------------------------------------

    def _register ( self, object, name ):
        """ Registers listeners on an assigned 'TraitValue' object's 'value'
            property.
        """
        def handler ( ):
            object.trait_property_changed( name, None )

        tv       = self._trait_value
        handlers = tv._handlers
        if handlers is None:
            tv._handlers = handlers = {}
        handlers[ ( id( object ), name ) ] = handler

        tv.on_trait_change( handler, 'value' )

    #---------------------------------------------------------------------------
    #  Unregisters listeners on an assigned 'TraitValue' object's 'value'
    #  property:
    #---------------------------------------------------------------------------

    def _unregister ( self, object, name ):
        """ Unregisters listeners on an assigned 'TraitValue' object's 'value'
            property.
        """
        tv       = self._trait_value
        handlers = tv._handlers
        key      = ( id( object ), name )
        handler  = handlers.get( key )
        if handler is not None:
            del handlers[ key ]
            tv.on_trait_change( handler, 'value', remove = True )

# Make sure the Python-level version of the trait class is known to all
# interested parties:
from . import ctraits
ctraits._ctrait( CTrait )

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

ConstantTypes    = ( NoneType, int, long, float, complex, str, unicode )

PythonTypes      = ( str, unicode, int, long, float, complex, list, tuple,
                     dict, FunctionType, MethodType, type, NoneType )

if sys.version_info[0] < 3:
    from types import InstanceType,ClassType
    PythonTypes = PythonTypes[:-2] + (InstanceType,ClassType) + PythonTypes[2:]


CallableTypes    = ( FunctionType, MethodType )

TraitTypes       = ( TraitHandler, CTrait )

DefaultValues = {
    str:  '',
    unicode: u'',
    int:     0,
    long:    0L,
    float:   0.0,
    complex: 0j,
    list:    [],
    tuple:   (),
    dict:    {},
    bool: False
}

DefaultValueSpecial = [ Missing, Self ]
DefaultValueTypes   = [ list, dict ]

#-------------------------------------------------------------------------------
#  Function used to unpickle new-style objects:
#-------------------------------------------------------------------------------

def __newobj__ ( cls, *args ):
    """ Unpickles new-style objects.
    """
    return cls.__new__( cls, *args )

#-------------------------------------------------------------------------------
#  Returns the type of default value specified:
#-------------------------------------------------------------------------------

def _default_value_type ( default_value ):
    try:
        return DefaultValueSpecial.index( default_value ) + 1
    except:
        try:
            return DefaultValueTypes.index( type( default_value ) ) + 3
        except:
            return 0

#-------------------------------------------------------------------------------
#  'TraitFactory' class:
#-------------------------------------------------------------------------------

class TraitFactory ( object ):
    ### Need a docstring here.

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, maker_function = None ):
        if maker_function is not None:
            self.maker_function = maker_function
            self.__doc__ = maker_function.__doc__

    #---------------------------------------------------------------------------
    #  Creates a CTrait instance:
    #---------------------------------------------------------------------------

    def __call__ ( self, *args, **metadata ):
        return self.maker_function( *args, **metadata )

class TraitImportError ( TraitFactory ):
    """ Defines a factory class for deferring import problems until encountering
        code that actually tries to use the unimportable trait.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, message ):
        self.message = message

    #---------------------------------------------------------------------------
    #  Creates a CTrait instance:
    #---------------------------------------------------------------------------

    def __call__ ( self, *args, **metadata ):
        raise TraitError( self.message )

#-------------------------------------------------------------------------------
#  Returns a trait created from a TraitFactory instance:
#-------------------------------------------------------------------------------

_trait_factory_instances = {}

def trait_factory ( trait ):
    global _trait_factory_instances

    tid = id( trait )
    if tid not in _trait_factory_instances:
        _trait_factory_instances[ tid ] = trait()

    return _trait_factory_instances[ tid ]

#-------------------------------------------------------------------------------
#  Casts a CTrait or TraitFactory to a CTrait but returns None if it is neither:
#-------------------------------------------------------------------------------

def trait_cast ( something ):
    """ Casts a CTrait, TraitFactory or TraitType to a CTrait but returns None
        if it is none of those.
    """
    if isinstance( something, CTrait ):
        return something

    if isinstance( something, TraitFactory ):
        return trait_factory( something )

    if isinstance( something, type ) and issubclass( something, TraitType ):
        return something().as_ctrait()

    if isinstance( something, TraitType ):
        return something.as_ctrait()

    return None

#-------------------------------------------------------------------------------
#  Attempts to cast a value to a trait. Returns either a trait or the original
#  value:
#-------------------------------------------------------------------------------

def try_trait_cast ( something ):
    """ Attempts to cast a value to a trait. Returns either a trait or the
        original value.
    """
    return trait_cast( something ) or something

#-------------------------------------------------------------------------------
#  Returns a trait derived from its input:
#-------------------------------------------------------------------------------

def trait_from ( something ):
    """ Returns a trait derived from its input.
    """
    from .trait_types import Any

    if isinstance( something, CTrait ):
        return something

    if something is None:
        something = Any

    if isinstance( something, TraitFactory ):
        return trait_factory( something )

    if isinstance( something, type ) and issubclass( something, TraitType ):
        return something().as_ctrait()

    if isinstance( something, TraitType ):
        return something.as_ctrait()

    return Trait( something )

# Patch the reference to 'trait_from' in 'trait_handlers.py':
trait_handlers.trait_from = trait_from

#--- 'instance' traits ---------------------------------------------------------

class _InstanceArgs ( object ):

    def __init__ ( self, factory, args, kw ):
        self.args = ( factory, ) + args
        self.kw   = kw

#--- 'creates a run-time default value' ----------------------------------------

class Default ( object ):
    """ Generates a value the first time it is accessed.

    A Default object can be used anywhere a default trait value would normally
    be specified, to generate a default value dynamically.
    """
    def __init__ ( self, func = None, args = (), kw = None ):
        self.default_value = ( func, args, kw )

#-------------------------------------------------------------------------------
#  Factory function for creating C-based traits:
#-------------------------------------------------------------------------------

def Trait ( *value_type, **metadata ):
    """ Creates a trait definition.

    Parameters
    ----------
    This function accepts a variety of forms of parameter lists:

    +-------------------+---------------+-------------------------------------+
    | Format            | Example       | Description                         |
    +===================+===============+=====================================+
    | Trait(*default*)  | Trait(150.0)  | The type of the trait is inferred   |
    |                   |               | from the type of the default value, |
    |                   |               | which must be in *ConstantTypes*.   |
    +-------------------+---------------+-------------------------------------+
    | Trait(*default*,  | Trait(None,   | The trait accepts any of the        |
    | *other1*,         | 0, 1, 2,      | enumerated values, with the first   |
    | *other2*, ...)    | 'many')       | value being the default value. The  |
    |                   |               | values must be of types in          |
    |                   |               | *ConstantTypes*, but they need not  |
    |                   |               | be of the same type. The *default*  |
    |                   |               | value is not valid for assignment   |
    |                   |               | unless it is repeated later in the  |
    |                   |               | list.                               |
    +-------------------+---------------+-------------------------------------+
    | Trait([*default*, | Trait([None,  | Similar to the previous format, but |
    | *other1*,         | 0, 1, 2,      | takes an explicit list or a list    |
    | *other2*, ...])   | 'many'])      | variable.                           |
    +-------------------+---------------+-------------------------------------+
    | Trait(*type*)     | Trait(Int)    | The *type* parameter must be a name |
    |                   |               | of a Python type (see               |
    |                   |               | *PythonTypes*). Assigned values     |
    |                   |               | must be of exactly the specified    |
    |                   |               | type; no casting or coercion is     |
    |                   |               | performed. The default value is the |
    |                   |               | appropriate form of zero, False,    |
    |                   |               | or emtpy string, set or sequence.   |
    +-------------------+---------------+-------------------------------------+
    | Trait(*class*)    |::             | Values must be instances of *class* |
    |                   |               | or of a subclass of *class*. The    |
    |                   | class MyClass:| default value is None, but None     |
    |                   |    pass       | cannot be assigned as a value.      |
    |                   | foo = Trait(  |                                     |
    |                   | MyClass)      |                                     |
    +-------------------+---------------+-------------------------------------+
    | Trait(None,       |::             | Similar to the previous format, but |
    | *class*)          |               | None *can* be assigned as a value.  |
    |                   | class MyClass:|                                     |
    |                   |   pass        |                                     |
    |                   | foo = Trait(  |                                     |
    |                   | None, MyClass)|                                     |
    +-------------------+---------------+-------------------------------------+
    | Trait(*instance*) |::             | Values must be instances of the     |
    |                   |               | same class as *instance*, or of a   |
    |                   | class MyClass:| subclass of that class. The         |
    |                   |    pass       | specified instance is the default   |
    |                   | i = MyClass() | value.                              |
    |                   | foo =         |                                     |
    |                   |   Trait(i)    |                                     |
    +-------------------+---------------+-------------------------------------+
    | Trait(*handler*)  | Trait(        | Assignment to this trait is         |
    |                   | TraitEnum )   | validated by an object derived from |
    |                   |               | **traits.TraitHandler**.            |
    +-------------------+---------------+-------------------------------------+
    | Trait(*default*,  | Trait(0.0, 0.0| This is the most general form of    |
    | { *type* |        | 'stuff',      | the function. The notation:         |
    | *constant* |      | TupleType)    | ``{...|...|...}+`` means a list of  |
    | *dict* | *class* ||               | one or more of any of the items     |
    | *function* |      |               | listed between the braces. Thus, the|
    | *handler* |       |               | most general form of the function   |
    | *trait* }+ )      |               | consists of a default value,        |
    |                   |               | followed by one or more of several  |
    |                   |               | possible items. A trait defined by  |
    |                   |               | multiple items is called a          |
    |                   |               | "compound" trait.                   |
    +-------------------+---------------+-------------------------------------+

    All forms of the Trait function accept both predefined and arbitrary
    keyword arguments. The value of each keyword argument becomes bound to the
    resulting trait object as the value of an attribute having the same name
    as the keyword. This feature lets you associate metadata with a trait.

    The following predefined keywords are accepted:

    Keywords
    --------
    desc : str
        Describes the intended meaning of the trait. It is used in
        exception messages and fly-over help in user interfaces.
    label : str
        Provides a human-readable name for the trait. It is used to label user
        interface editors for traits.
    editor : traits.api.Editor
        Instance of a subclass Editor object to use when creating a user
        interface editor for the trait. See the "Traits UI User Guide" for
        more information on trait editors.
    comparison_mode : int
        Indicates when trait change notifications should be generated based upon
        the result of comparing the old and new values of a trait assignment:

        * 0 (NO_COMPARE): The values are not compared and a trait change
          notification is generated on each assignment.
        * 1 (OBJECT_IDENTITY_COMPARE): A trait change notification is
          generated if the old and new values are not the same object.
        * 2 (RICH_COMPARE): A trait change notification is generated if the
          old and new values are not equal using Python's
          'rich comparison' operator. This is the default.

    rich_compare : bool
        Indicates whether the basis for considering a trait attribute value to
        have changed is a "rich" comparison (True, the default), or simple
        object identity (False). This attribute can be useful in cases
        where a detailed comparison of two objects is very expensive, or where
        you do not care whether the details of an object change, as long as the
        same object is used.

            .. deprecated:: 3.0.3
                Use ``comparison_mode`` instead


    """
    return _TraitMaker( *value_type, **metadata ).as_ctrait()

#  Handle circular module dependencies:
trait_handlers.Trait = Trait

#-------------------------------------------------------------------------------
#  '_TraitMaker' class:
#-------------------------------------------------------------------------------

class _TraitMaker ( object ):

    # Ctrait type map for special trait types:
    type_map = {
       'event':    2,
       'constant': 7
    }

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, *value_type, **metadata ):
        metadata.setdefault( 'type', 'trait' )
        self.define( *value_type, **metadata )

    #---------------------------------------------------------------------------
    #  Define the trait:
    #---------------------------------------------------------------------------

    def define ( self, *value_type, **metadata ):
        default_value_type = -1
        default_value      = handler = clone = None

        if len( value_type ) > 0:
            default_value = value_type[0]
            value_type    = value_type[1:]

            if ((len( value_type ) == 0) and
                (type( default_value ) in SequenceTypes)):
                default_value, value_type = default_value[0], default_value

            if len( value_type ) == 0:
                default_value = try_trait_cast( default_value )

                if default_value in PythonTypes:
                    handler       = TraitCoerceType( default_value )
                    default_value = DefaultValues.get( default_value )

                elif isinstance( default_value, CTrait ):
                    clone = default_value
                    default_value_type, default_value = clone.default_value()
                    metadata[ 'type' ] = clone.type

                elif isinstance( default_value, TraitHandler ):
                    handler       = default_value
                    default_value = None

                elif default_value is ThisClass:
                    handler       = ThisClass()
                    default_value = None

                else:
                    typeValue = type( default_value )

                    if isinstance(default_value, basestring):
                        string_options = self.extract( metadata, 'min_len',
                                                       'max_len', 'regex' )
                        if len( string_options ) == 0:
                            handler = TraitCastType( typeValue )
                        else:
                            handler = TraitString( **string_options )

                    elif typeValue in TypeTypes:
                        handler = TraitCastType( typeValue )

                    else:
                        metadata.setdefault( 'instance_handler',
                                             '_instance_changed_handler' )
                        handler = TraitInstance( default_value )
                        if default_value is handler.aClass:
                            default_value = DefaultValues.get( default_value )
            else:
                enum  = []
                other = []
                map   = {}
                self.do_list( value_type, enum, map, other )

                if (((len( enum )  == 1) and (enum[0] is None)) and
                    ((len( other ) == 1) and
                     isinstance( other[0], TraitInstance ))):
                    enum = []
                    other[0].allow_none()
                    metadata.setdefault( 'instance_handler',
                                         '_instance_changed_handler' )
                if len( enum ) > 0:
                    if (((len( map ) + len( other )) == 0) and
                        (default_value not in enum)):
                        enum.insert( 0, default_value )

                    other.append( TraitEnum( enum ) )

                if len( map ) > 0:
                    other.append( TraitMap( map ) )

                if len( other ) == 0:
                    handler = TraitHandler()

                elif len( other ) == 1:
                    handler = other[0]
                    if isinstance( handler, CTrait ):
                        clone, handler = handler, None
                        metadata[ 'type' ] = clone.type

                    elif isinstance( handler, TraitInstance ):
                        metadata.setdefault( 'instance_handler',
                                             '_instance_changed_handler' )

                        if default_value is None:
                            handler.allow_none()

                        elif isinstance( default_value, _InstanceArgs ):
                            default_value_type = 7
                            default_value = ( handler.create_default_value,
                                default_value.args, default_value.kw )

                        elif (len( enum ) == 0) and (len( map ) == 0):
                            aClass    = handler.aClass
                            typeValue = type( default_value )

                            if typeValue is dict:
                                default_value_type = 7
                                default_value = ( aClass, (), default_value )
                            elif not isinstance( default_value, aClass ):
                                if typeValue is not tuple:
                                    default_value = ( default_value, )
                                default_value_type = 7
                                default_value = ( aClass, default_value, None )
                else:
                    for i, item in enumerate( other ):
                        if isinstance( item, CTrait ):
                            if item.type != 'trait':
                                raise TraitError, ("Cannot create a complex "
                                    "trait containing %s trait." %
                                    add_article( item.type ) )
                            handler = item.handler
                            if handler is None:
                                break
                            other[i] = handler
                    else:
                        handler = TraitCompound( other )

        # Save the results:
        self.handler = handler
        self.clone   = clone

        if default_value_type < 0:
            if isinstance( default_value, Default ):
                default_value_type = 7
                default_value      = default_value.default_value
            else:
                if (handler is None) and (clone is not None):
                    handler = clone.handler

                if handler is not None:
                    default_value_type = handler.default_value_type
                    if default_value_type < 0:
                        try:
                            default_value = handler.validate( None, '',
                                                              default_value )
                        except:
                            pass

                if default_value_type < 0:
                    default_value_type = _default_value_type( default_value )

        self.default_value_type = default_value_type
        self.default_value      = default_value
        self.metadata           = metadata.copy()

    #---------------------------------------------------------------------------
    #  Determine the correct TraitHandler for each item in a list:
    #---------------------------------------------------------------------------

    def do_list ( self, list, enum, map, other ):
        for item in list:
            if item in PythonTypes:
                other.append( TraitCoerceType( item ) )
            else:
                item     = try_trait_cast( item )
                typeItem = type( item )

                if typeItem in ConstantTypes:
                    enum.append( item )

                elif typeItem in SequenceTypes:
                    self.do_list( item, enum, map, other )

                elif typeItem is dict:
                    map.update( item )

                elif typeItem in CallableTypes:
                    other.append( TraitFunction( item ) )

                elif item is ThisClass:
                    other.append( ThisClass() )

                elif isinstance( item, TraitTypes ):
                    other.append( item )

                else:
                    other.append( TraitInstance( item ) )

    #---------------------------------------------------------------------------
    #  Returns a properly initialized 'CTrait' instance:
    #---------------------------------------------------------------------------

    def as_ctrait ( self ):
        metadata = self.metadata
        trait    = CTrait( self.type_map.get( metadata.get( 'type' ), 0 ) )
        clone    = self.clone
        if clone is not None:
            trait.clone( clone )
            if clone.__dict__ is not None:
                trait.__dict__ = clone.__dict__.copy()

        trait.default_value( self.default_value_type, self.default_value )

        handler = self.handler
        if handler is not None:
            trait.handler = handler
            validate      = getattr( handler, 'fast_validate', None )
            if validate is None:
                validate = handler.validate

            trait.set_validate( validate )

            post_setattr = getattr( handler, 'post_setattr', None )
            if post_setattr is not None:
                trait.post_setattr = post_setattr
                trait.is_mapped( handler.is_mapped )

        # Note: The use of 'rich_compare' metadata is deprecated; use
        # 'comparison_mode' metadata instead:
        rich_compare = metadata.get( 'rich_compare' )
        if rich_compare is not None:
            trait.rich_comparison( rich_compare is True )

        comparison_mode = metadata.get( 'comparison_mode' )
        if comparison_mode is not None:
            trait.comparison_mode( comparison_mode )

        trait.value_allowed( metadata.get( 'trait_value', False ) is True )

        if len( metadata ) > 0:
            if trait.__dict__ is None:
                trait.__dict__ = metadata
            else:
                trait.__dict__.update( metadata )

        return trait

    #---------------------------------------------------------------------------
    #  Extract a set of keywords from a dictionary:
    #---------------------------------------------------------------------------

    def extract ( self, from_dict, *keys ):
        to_dict = {}
        for key in keys:
            if key in from_dict:
                to_dict[ key ] = from_dict[ key ]
                del from_dict[ key ]
        return to_dict

#-------------------------------------------------------------------------------
#  Factory function for creating C-based trait properties:
#-------------------------------------------------------------------------------

def Property ( fget = None, fset = None, fvalidate = None, force = False,
               handler = None, trait = None, **metadata ):
    """ Returns a trait whose value is a Python property.

    Parameters
    ----------
    fget : function
        The "getter" function for the property.
    fset : function
        The "setter" function for the property.
    fvalidate : function
        The validation function for the property. The method should return the
        value to set or raise TraitError if the new value is not valid.
    force : bool
        Indicates whether to use only the function definitions specified by
        **fget** and **fset**, and not look elsewhere on the class.
    handler : function
        A trait handler function for the trait.
    trait : Trait or value
        A trait definition or a value that can be converted to a trait that
        constrains the values of the property trait.

    Description
    -----------
    If no getter, setter or validate functions are specified (and **force** is
    not True), it is assumed that they are defined elsewhere on the class whose
    attribute this trait is assigned to. For example::

        class Bar(HasTraits):
            
            # A float traits Property that should be always positive.
            foo = Property(Float)
            
            # Shadow trait attribute
            _foo = Float

            def _set_foo(self,x):
                self._foo = x

            def _validate_foo(self, x):
                if x <= 0:
                    raise TraitError(
                        'foo property should be a positive number')
                return x

            def _get_foo(self):
                return self._foo

    You can use the **depends_on** metadata attribute to indicate that the
    property depends on the value of another trait. The value of **depends_on**
    is an extended name specifier for traits that the property depends on. The
    property will a trait change notification if any of the traits specified
    by **depends_on** change. For example::

        class Wheel ( Part ):
            axle     = Instanced( Axle )
            position = Property( depends_on = 'axle.chassis.position' )

    For details of the extended trait name syntax, refer to the on_trait_change()
    method of the HasTraits class.
    """
    metadata[ 'type' ] = 'property'

    # If no parameters specified, must be a forward reference (if not forced):
    if (not force) and (fset is None):
        sum = ((fget      is not None) +
               (fvalidate is not None) +
               (trait     is not None))
        if sum <= 1:
            if sum == 0:
                return ForwardProperty( metadata )

            handler = None
            if fget is not None:
                trait = fget

            if trait is not None:
                trait = trait_cast( trait )
                if trait is not None:
                    fvalidate = handler = trait.handler
                    if fvalidate is not None:
                        fvalidate = handler.validate

            if (fvalidate is not None) or (trait is not None):
                if 'editor' not in metadata:
                    if (trait is not None) and (trait.editor is not None):
                        metadata[ 'editor' ] = trait.editor

                return ForwardProperty( metadata, fvalidate, handler )

    if fget is None:
        metadata[ 'transient' ] = True
        if fset is None:
            fget = _undefined_get
            fset = _undefined_set
        else:
            fget = _write_only

    elif fset is None:
        fset = _read_only
        metadata[ 'transient' ] = True

    if trait is not None:
        trait   = trait_cast( trait )
        handler = trait.handler
        if (fvalidate is None) and (handler is not None):
            fvalidate = handler.validate

        if ('editor' not in metadata) and (trait.editor is not None):
            metadata[ 'editor' ] = trait.editor

    metadata.setdefault( 'depends_on', getattr( fget, 'depends_on', None ) )
    if ((metadata.get( 'depends_on' ) is not None) and
         getattr( fget, 'cached_property', False )):
        metadata.setdefault( 'cached', True )

    n     = 0
    trait = CTrait( 4 )
    trait.__dict__ = metadata.copy()
    if fvalidate is not None:
        n = _arg_count( fvalidate )

    trait.property( fget,      _arg_count( fget ),
                    fset,      _arg_count( fset ),
                    fvalidate, n )
    trait.handler = handler

    return trait

Property = TraitFactory( Property )

class ForwardProperty ( object ):
    """ Used to implement Property traits where accessor functions are defined
    implicitly on the class.
    """
    def __init__ ( self, metadata, validate = None, handler = None ):
        self.metadata = metadata.copy()
        self.validate = validate
        self.handler  = handler

#-------------------------------------------------------------------------------
#  Dictionary used to handle return type mapping special cases:
#-------------------------------------------------------------------------------

SpecialNames = {
###   'int':     trait_factory( Int ),
###   'long':    trait_factory( Long ),
###   'float':   trait_factory( Float ),
###   'complex': trait_factory( Complex ),
###   'str':     trait_factory( Str ),
###   'unicode': trait_factory( Unicode ),
###   'bool':    trait_factory( Bool ),
###   'list':    trait_factory( List ),
###   'tuple':   trait_factory( Tuple ),
###   'dict':    trait_factory( Dict )
}


#-- Date Trait definition ----------------------------------------------------
#Date = Instance(datetime.date, metadata = { 'editor': date_editor })


#-- Time Trait definition ----------------------------------------------------
#Time = Instance(datetime.time, metadata = { 'editor': time_editor })



#-------------------------------------------------------------------------------
#  Create predefined, reusable trait instances:
#-------------------------------------------------------------------------------

# Generic trait with 'object' behavior:
generic_trait = CTrait( 8 )

#-------------------------------------------------------------------------------
#  User interface related color and font traits:
#-------------------------------------------------------------------------------

def Color ( *args, **metadata ):
    """ Returns a trait whose value must be a GUI toolkit-specific color.

    Description
    -----------
    For wxPython, the returned trait accepts any of the following values:

    * A wx.Colour instance
    * A wx.ColourPtr instance
    * an integer whose hexadecimal form is 0x*RRGGBB*, where *RR* is the red
      value, *GG* is the green value, and *BB* is the blue value

    Default Value
    -------------
    For wxPython, 0x000000 (that is, white)
    """
    from traitsui.toolkit_traits import ColorTrait

    return ColorTrait( *args, **metadata )

Color = TraitFactory( Color )

def RGBColor ( *args, **metadata ):
    """ Returns a trait whose value must be a GUI toolkit-specific RGB-based
        color.

    Description
    -----------
    For wxPython, the returned trait accepts any of the following values:

    * A tuple of the form (*r*, *g*, *b*), in which *r*, *g*, and *b* represent
      red, green, and blue values, respectively, and are floats in the range
      from 0.0 to 1.0
    * An integer whose hexadecimal form is 0x*RRGGBB*, where *RR* is the red
      value, *GG* is the green value, and *BB* is the blue value

    Default Value
    -------------
    For wxPython, (0.0, 0.0, 0.0) (that is, white)
    """
    from traitsui.toolkit_traits import RGBColorTrait

    return RGBColorTrait( *args, **metadata )

RGBColor = TraitFactory( RGBColor )

def Font ( *args, **metadata ):
    """ Returns a trait whose value must be a GUI toolkit-specific font.

    Description
    -----------
    For wxPython, the returned trait accepts any of the following:

    * a wx.Font instance
    * a wx.FontPtr instance
    * a string describing the font, including one or more of the font family,
      size, weight, style, and typeface name.

    Default Value
    -------------
    For wxPython, 'Arial 10'
    """
    from traitsui.toolkit_traits import FontTrait

    return FontTrait( *args, **metadata )

Font = TraitFactory( Font )


########NEW FILE########
__FILENAME__ = traits_listener
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/05/2007
#
#-------------------------------------------------------------------------------

""" Defines classes used to implement and manage various trait listener
    patterns.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import re
import string
import weakref
from weakref import WeakKeyDictionary
from string import whitespace
from types import MethodType

from .has_traits import HasPrivateTraits
from .trait_base import Undefined, Uninitialized
from .traits import Property
from .trait_types import Str, Int, Bool, Instance, List, Enum, Any
from .trait_errors import TraitError
from .trait_notifiers import TraitChangeNotifyWrapper

#---------------------------------------------------------------------------
#  Constants:
#---------------------------------------------------------------------------

# The name of the dictionary used to store active listeners
TraitsListener = '__traits_listener__'

# End of String marker
EOS = '\0'

# Types of traits that can be listened to

ANYTRAIT_LISTENER = '_register_anytrait'
SIMPLE_LISTENER   = '_register_simple'
LIST_LISTENER     = '_register_list'
DICT_LISTENER     = '_register_dict'
SET_LISTENER      = '_register_set'

# Mapping from trait default value types to listener types
type_map = {
    5: LIST_LISTENER,
    6: DICT_LISTENER,
    9: SET_LISTENER
}

# Listener types:
ANY_LISTENER = 0
SRC_LISTENER = 1
DST_LISTENER = 2

ListenerType = {
    0: ANY_LISTENER,
    1: DST_LISTENER,
    2: DST_LISTENER,
    3: SRC_LISTENER,
    4: SRC_LISTENER
}

# Invalid destination ( object, name ) reference marker (i.e. ambiguous):
INVALID_DESTINATION = ( None, None )

# Regular expressions used by the parser:
simple_pat = re.compile( r'^([a-zA-Z_]\w*)(\.|:)([a-zA-Z_]\w*)$' )
name_pat   = re.compile( r'([a-zA-Z_]\w*)\s*(.*)' )

# Characters valid in a traits name:
name_chars = string.ascii_letters + string.digits + '_'

#-------------------------------------------------------------------------------
# Utility functions:
#-------------------------------------------------------------------------------

def indent ( text, first_line = True, n = 1, width = 4 ):
    """ Indent lines of text.

    Parameters
    ----------
    text : str
        The text to indent.
    first_line : bool, optional
        If False, then the first line will not be indented (default: True).
    n : int, optional
        The level of indentation (default: 1).
    width : int, optional
        The number of spaces in each level of indentation (default: 4).

    Returns
    -------
    indented : str
    """
    lines = text.split( '\n' )
    if not first_line:
        first = lines[0]
        lines = lines[1:]

    spaces = ' ' * (width * n)
    lines2 = [ spaces + x for x in lines ]

    if not first_line:
        lines2.insert( 0, first )

    indented = '\n'.join( lines2 )

    return indented

#-------------------------------------------------------------------------------
#  Metadata filters:
#-------------------------------------------------------------------------------

def is_not_none ( value ): return (value is not None)
def is_none ( value ):     return (value is None)
def not_event ( value ):   return (value != 'event')

#-------------------------------------------------------------------------------
#  'ListenerBase' class:
#-------------------------------------------------------------------------------

class ListenerBase ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The handler to be called when any listened to trait is changed:
    #handler = Any

    # The dispatch mechanism to use when invoking the handler:
    #dispatch = Str

    # Does the handler go at the beginning (True) or end (False) of the
    # notification handlers list?
    #priority = Bool( False )

    # The next level (if any) of ListenerBase object to be called when any of
    # our listened to traits is changed:
    #next = Instance( ListenerBase )

    # The type of handler being used:
    #type = Enum( ANY_LISTENER, SRC_LISTENER, DST_LISTENER )

    # Should changes to this item generate a notification to the handler?
    # notify = Bool

    # Should registering listeners for items reachable from this listener item
    # be deferred until the associated trait is first read or set?
    # deferred = Bool

    #---------------------------------------------------------------------------
    #  Registers new listeners:
    #---------------------------------------------------------------------------

    def register ( self, new ):
        """ Registers new listeners.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Unregisters any existing listeners:
    #---------------------------------------------------------------------------

    def unregister ( self, old ):
        """ Unregisters any existing listeners.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Handles a trait change for a simple trait:
    #---------------------------------------------------------------------------

    def handle ( self, object, name, old, new ):
        """ Handles a trait change for a simple trait.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Handles a trait change for a list trait:
    #---------------------------------------------------------------------------

    def handle_list ( self, object, name, old, new ):
        """ Handles a trait change for a list trait.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Handles a trait change for a list traits items:
    #---------------------------------------------------------------------------

    def handle_list_items ( self, object, name, old, new ):
        """ Handles a trait change for a list traits items.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Handles a trait change for a dictionary trait:
    #---------------------------------------------------------------------------

    def handle_dict ( self, object, name, old, new ):
        """ Handles a trait change for a dictionary trait.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Handles a trait change for a dictionary traits items:
    #---------------------------------------------------------------------------

    def handle_dict_items ( self, object, name, old, new ):
        """ Handles a trait change for a dictionary traits items.
        """
        raise NotImplementedError

#-------------------------------------------------------------------------------
#  'ListenerItem' class:
#-------------------------------------------------------------------------------

class ListenerItem ( ListenerBase ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #: The name of the trait to listen to:
    name = Str

    #: The name of any metadata that must be present (or not present):
    metadata_name = Str

    #: Does the specified metadata need to be defined (True) or not defined
    #: (False)?
    metadata_defined = Bool( True )

    #: The handler to be called when any listened-to trait is changed:
    handler = Any

    #: A weakref 'wrapped' version of 'handler':
    wrapped_handler_ref = Any

    #: The dispatch mechanism to use when invoking the handler:
    dispatch = Str

    #: Does the handler go at the beginning (True) or end (False) of the
    #: notification handlers list?
    priority = Bool( False )

    #: The next level (if any) of ListenerBase object to be called when any of
    #: this object's listened-to traits is changed:
    next = Instance( ListenerBase )

    #: The type of handler being used:
    type = Enum( ANY_LISTENER, SRC_LISTENER, DST_LISTENER )

    #: Should changes to this item generate a notification to the handler?
    notify = Bool( True )

    #: Should registering listeners for items reachable from this listener item
    #: be deferred until the associated trait is first read or set?
    deferred = Bool( False )

    #: Is this an 'any_trait' change listener, or does it create explicit
    #: listeners for each individual trait?
    is_any_trait = Bool( False )

    #: Is the associated handler a special list handler that handles both
    #: 'foo' and 'foo_items' events by receiving a list of 'deleted' and 'added'
    #: items as the 'old' and 'new' arguments?
    is_list_handler = Bool( False )

    #: A dictionary mapping objects to a list of all current active
    #: (*name*, *type*) listener pairs, where *type* defines the type of
    #: listener, one of: (SIMPLE_LISTENER, LIST_LISTENER, DICT_LISTENER).
    active = Instance( WeakKeyDictionary, () )

    #-- 'ListenerBase' Class Method Implementations ----------------------------

    #---------------------------------------------------------------------------
    #  String representation:
    #---------------------------------------------------------------------------

    def __repr__ ( self, seen = None ):
        """Returns a string representation of the object.

        Since the object graph may have cycles, we extend the basic __repr__ API
        to include a set of objects we've already seen while constructing
        a string representation. When this method tries to get the repr of
        a ListenerItem or ListenerGroup, we will use the extended API and build
        up the set of seen objects. The repr of a seen object will just be
        '<cycle>'.
        """
        if seen is None:
            seen = set()

        seen.add( self )
        next_repr = 'None'
        next      = self.next
        if next is not None:
            if next in seen:
                next_repr = '<cycle>'
            else:
                next_repr = next.__repr__( seen )

        return """%s(
    name = %r,
    metadata_name = %r,
    metadata_defined = %r,
    is_any_trait = %r,
    dispatch = %r,
    notify = %r,
    is_list_handler = %r,
    type = %r,
    next = %s,
)""" % ( self.__class__.__name__, self.name, self.metadata_name,
          self.metadata_defined, self.is_any_trait, self.dispatch, self.notify,
          self.is_list_handler, self.type, indent( next_repr, False ) )

    #---------------------------------------------------------------------------
    #  Registers new listeners:
    #---------------------------------------------------------------------------

    def register ( self, new ):
        """ Registers new listeners.
        """
        # Make sure we actually have an object to set listeners on and that it
        # has not already been registered (cycle breaking):
        if (new is None) or (new is Undefined) or (new in self.active):
            return INVALID_DESTINATION

        # Create a dictionary of {name: trait_values} that match the object's
        # definition for the 'new' object:
        name = self.name
        last = name[-1:]
        if last == '*':
            # Handle the special case of an 'anytrait' change listener:
            if self.is_any_trait:
                try:
                    self.active[ new ] = [ ( '', ANYTRAIT_LISTENER ) ]
                    return self._register_anytrait( new, '', False )
                except TypeError:
                    # This error can occur if 'new' is a list or other object
                    # for which a weakref cannot be created as the dictionary
                    # key for 'self.active':
                    return INVALID_DESTINATION

            # Handle trait matching based on a common name prefix and/or
            # matching trait metadata:
            metadata = self._metadata
            if metadata is None:
                self._metadata = metadata = { 'type': not_event }
                if self.metadata_name != '':
                    if self.metadata_defined:
                        metadata[ self.metadata_name ] = is_not_none
                    else:
                        metadata[ self.metadata_name ] = is_none

            # Get all object traits with matching metadata:
            names = new.trait_names( **metadata )

            # If a name prefix was specified, filter out only the names that
            # start with the specified prefix:
            name = name[:-1]
            if name != '':
                n     = len( name )
                names = [ aname for aname in names if name == aname[ : n ] ]

            # Create the dictionary of selected traits:
            bt     = new.base_trait
            traits = dict( [ ( name, bt( name ) ) for name in names ] )

            # Handle any new traits added dynamically to the object:
            new.on_trait_change( self._new_trait_added, 'trait_added' )
        else:
            # Determine if the trait is optional or not:
            optional = (last == '?')
            if optional:
                name = name[:-1]

            # Else, no wildcard matching, just get the specified trait:
            trait = new.base_trait( name )

            # Try to get the object trait:
            if trait is None:
                # Raise an error if trait is not defined and not optional:

                # fixme: Properties which are lists don't implement the
                # '..._items' sub-trait, which can cause a failure here when
                # used with an editor that sets up listeners on the items...
                if not optional:
                    raise TraitError( "'%s' object has no '%s' trait" % (
                                      new.__class__.__name__, name ) )

                # Otherwise, just skip it:
                traits = {}
            else:
                # Create a result dictionary containing just the single trait:
                traits = { name: trait }

        # For each item, determine its type (simple, list, dict):
        self.active[ new ] = active = []
        for name, trait in traits.items():

            # Determine whether the trait type is simple, list, set or
            # dictionary:
            type    = SIMPLE_LISTENER
            handler = trait.handler
            if handler is not None:
                type = type_map.get( handler.default_value_type,
                                     SIMPLE_LISTENER )

            # Add the name and type to the list of traits being registered:
            active.append( ( name, type ) )

            # Set up the appropriate trait listeners on the object for the
            # current trait:
            value = getattr( self, type )( new, name, False )

        if len( traits ) == 1:
            return value

        return INVALID_DESTINATION

    #---------------------------------------------------------------------------
    #  Unregisters any existing listeners:
    #---------------------------------------------------------------------------

    def unregister ( self, old ):
        """ Unregisters any existing listeners.
        """
        if old is not None and old is not Uninitialized:
            try:
                active = self.active.pop( old, None )
                if active is not None:
                    for name, type in active:
                        getattr( self, type )( old, name, True )
            except TypeError:
                # An error can occur if 'old' is a list or other object for
                # which a weakref cannot be created and used an a key for
                # 'self.active':
                pass

    #---------------------------------------------------------------------------
    #  Handles a trait change for an intermediate link trait:
    #---------------------------------------------------------------------------

    def handle_simple ( self, object, name, old, new ):
        """ Handles a trait change for an intermediate link trait.
        """
        self.next.unregister( old )
        self.next.register( new )

    def handle_dst ( self, object, name, old, new ):
        """ Handles a trait change for an intermediate link trait when the
            notification is for the final destination trait.
        """
        self.next.unregister( old )
        object, name = self.next.register( new )
        if old is not Uninitialized:
            if object is None:
                raise TraitError( "on_trait_change handler signature is "
                         "incompatible with a change to an intermediate trait" )

            wh = self.wrapped_handler_ref()
            if wh is not None:
                wh( object, name, old,
                    getattr( object, name, Undefined ) )

    #---------------------------------------------------------------------------
    #  Handles a trait change for a list (or set) trait:
    #---------------------------------------------------------------------------

    def handle_list ( self, object, name, old, new ):
        """ Handles a trait change for a list (or set) trait.
        """
        if old is not None and old is not Uninitialized:
            unregister = self.next.unregister
            for obj in old:
                unregister( obj )

        register = self.next.register
        for obj in new:
            register( obj )

    #---------------------------------------------------------------------------
    #  Handles a trait change for a list (or set) traits items:
    #---------------------------------------------------------------------------

    def handle_list_items ( self, object, name, old, new ):
        """ Handles a trait change for items of a list (or set) trait.
        """
        self.handle_list( object, name, new.removed, new.added )

    def handle_list_items_special ( self, object, name, old, new ):
        """ Handles a trait change for items of a list (or set) trait with
            notification.
        """
        wh = self.wrapped_handler_ref()
        if wh is not None:
            wh( object, name, new.removed, new.added )

    #---------------------------------------------------------------------------
    #  Handles a trait change for a dictionary trait:
    #---------------------------------------------------------------------------

    def handle_dict ( self, object, name, old, new ):
        """ Handles a trait change for a dictionary trait.
        """
        if old is not Uninitialized:
            unregister = self.next.unregister
            for obj in old.values():
                unregister( obj )

        register = self.next.register
        for obj in new.values():
            register( obj )

    #---------------------------------------------------------------------------
    #  Handles a trait change for a dictionary traits items:
    #---------------------------------------------------------------------------

    def handle_dict_items ( self, object, name, old, new ):
        """ Handles a trait change for items of a dictionary trait.
        """
        self.handle_dict( object, name, new.removed, new.added )

        if len( new.changed ) > 0:
            # If 'name' refers to the '_items' trait, then remove the '_items'
            # suffix to get the actual dictionary trait.
            #
            # fixme: Is there ever a case where 'name' *won't* refer to the
            # '_items' trait?
            if name.endswith('_items'):
                name = name[:-len('_items')]

            dict = getattr( object, name )
            unregister = self.next.unregister
            register = self.next.register
            for key, obj in new.changed.items():
                unregister( obj )
                register( dict[ key ] )

    #---------------------------------------------------------------------------
    #  Handles an invalid intermediate trait change to a handler that must be
    #  applied to the final destination object.trait:
    #---------------------------------------------------------------------------

    def handle_error ( self, obj, name, old, new ):
        """ Handles an invalid intermediate trait change to a handler that must
            be applied to the final destination object.trait.
        """
        if old is not None and old is not Uninitialized:
            raise TraitError( "on_trait_change handler signature is "
                              "incompatible with a change to an intermediate trait" )

    #-- Event Handlers ---------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles the 'handler' trait being changed:
    #---------------------------------------------------------------------------

    def _handler_changed ( self, handler ):
        """ Handles the **handler** trait being changed.
        """
        if self.next is not None:
            self.next.handler = handler

    #---------------------------------------------------------------------------
    #  Handles the 'wrapped_handler_ref' trait being changed:
    #---------------------------------------------------------------------------

    def _wrapped_handler_ref_changed ( self, wrapped_handler_ref ):
        """ Handles the 'wrapped_handler_ref' trait being changed.
        """
        if self.next is not None:
            self.next.wrapped_handler_ref = wrapped_handler_ref

    #---------------------------------------------------------------------------
    #  Handles the 'dispatch' trait being changed:
    #---------------------------------------------------------------------------

    def _dispatch_changed ( self, dispatch ):
        """ Handles the **dispatch** trait being changed.
        """
        if self.next is not None:
            self.next.dispatch = dispatch

    #---------------------------------------------------------------------------
    #  Handles the 'priority' trait being changed:
    #---------------------------------------------------------------------------

    def _priority_changed ( self, priority ):
        """ Handles the **priority** trait being changed.
        """
        if self.next is not None:
            self.next.priority = priority

    #-- Private Methods --------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Registers any 'anytrait' listener:
    #---------------------------------------------------------------------------

    def _register_anytrait ( self, object, name, remove ):
        """ Registers any 'anytrait' listener.
        """
        handler = self.handler()
        if handler is not Undefined:
            object._on_trait_change(
                handler,
                remove=remove,
                dispatch=self.dispatch,
                priority=self.priority,
                target=self._get_target(),
            )

        return ( object, name )

    #---------------------------------------------------------------------------
    #  Registers a handler for a simple trait:
    #---------------------------------------------------------------------------

    def _register_simple ( self, object, name, remove ):
        """ Registers a handler for a simple trait.
        """
        next = self.next
        if next is None:
            handler = self.handler()
            if handler is not Undefined:
                object._on_trait_change(
                    handler,
                    name,
                    remove=remove,
                    dispatch=self.dispatch,
                    priority=self.priority,
                    target=self._get_target(),
                )

            return ( object, name )

        tl_handler = self.handle_simple
        if self.notify:
            if self.type == DST_LISTENER:
                if self.dispatch != 'same':
                    raise TraitError( "Trait notification dispatch type '%s' "
                      "is not compatible with handler signature and "
                      "extended trait name notification style" % self.dispatch )
                tl_handler = self.handle_dst
            else:
                handler = self.handler()
                if handler is not Undefined:
                    object._on_trait_change(
                        handler,
                        name,
                        remove=remove,
                        dispatch=self.dispatch,
                        priority=self.priority,
                        target=self._get_target(),
                    )

        object._on_trait_change(
            tl_handler,
            name,
            remove=remove,
            dispatch='extended',
            priority=self.priority,
            target=self._get_target(),
        )

        if remove:
            return next.unregister( getattr( object, name ) )

        if not self.deferred or name in object.__dict__:
            # Sometimes, the trait may already be assigned. This can happen when
            # there are chains of dynamic initializers and 'delegate'
            # notifications. If 'trait_a' and 'trait_b' have dynamic
            # initializers and 'trait_a's initializer creates 'trait_b', *and*
            # we have a DelegatesTo trait that delegates to 'trait_a', then the
            # listener that implements the delegate will create 'trait_a' and
            # thus 'trait_b'. If we are creating an extended trait change
            # listener on 'trait_b.something', and the 'trait_a' delegate
            # listeners just happen to get hooked up before this one, then
            # 'trait_b' will have been initialized already, and the registration
            # that we are deferring will never happen.
            return next.register( getattr( object, name ) )

        return ( object, name )

    #---------------------------------------------------------------------------
    #  Registers a handler for a list trait:
    #---------------------------------------------------------------------------

    def _register_list ( self, object, name, remove ):
        """ Registers a handler for a list trait.
        """
        next = self.next
        if next is None:
            handler = self.handler()
            if handler is not Undefined:
                object._on_trait_change(
                    handler,
                    name,
                    remove=remove,
                    dispatch=self.dispatch,
                    priority=self.priority,
                    target=self._get_target(),
                )

                if self.is_list_handler:
                    object._on_trait_change(
                        self.handle_list_items_special,
                        name + '_items',
                        remove=remove,
                        dispatch=self.dispatch,
                        priority=self.priority,
                        target=self._get_target(),
                    )

                elif self.type == ANY_LISTENER:
                    object._on_trait_change(
                        handler,
                        name + '_items',
                        remove=remove,
                        dispatch=self.dispatch,
                        priority=self.priority,
                        target=self._get_target(),
                    )

            return ( object, name )

        tl_handler       = self.handle_list
        tl_handler_items = self.handle_list_items
        if self.notify:
            if self.type == DST_LISTENER:
                tl_handler = tl_handler_items = self.handle_error
            else:
                handler = self.handler()
                if handler is not Undefined:
                    object._on_trait_change(
                        handler,
                        name,
                        remove=remove,
                        dispatch=self.dispatch,
                        priority=self.priority,
                        target=self._get_target(),
                    )

                    if self.is_list_handler:
                        object._on_trait_change(
                            self.handle_list_items_special,
                            name + '_items',
                            remove=remove,
                            dispatch=self.dispatch,
                            priority=self.priority,
                            target=self._get_target(),
                        )
                    elif self.type == ANY_LISTENER:
                        object._on_trait_change(
                            handler,
                            name + '_items',
                            remove=remove,
                            dispatch=self.dispatch,
                            priority=self.priority,
                            target=self._get_target(),
                        )

        object._on_trait_change(
            tl_handler,
            name,
            remove=remove,
            dispatch='extended',
            priority=self.priority,
            target=self._get_target(),
        )

        object._on_trait_change(
            tl_handler_items,
            name + '_items',
            remove=remove,
            dispatch='extended',
            priority=self.priority,
            target=self._get_target(),
        )

        if remove:
            handler = next.unregister
        elif self.deferred:
            return INVALID_DESTINATION
        else:
            handler = next.register

        for obj in getattr( object, name ):
            handler( obj )

        return INVALID_DESTINATION

    # Handle 'sets' the same as 'lists':
    # Note: Currently the behavior of sets is almost identical to that of lists,
    # so we are able to share the same code for both. This includes some 'duck
    # typing' that occurs with the TraitListEvent and TraitSetEvent, that define
    # 'removed' and 'added' attributes that behave similarly enough (from the
    # point of view of this module) that they can be treated as equivalent. If
    # the behavior of sets ever diverges from that of lists, then this code may
    # need to be changed.
    _register_set = _register_list

    #---------------------------------------------------------------------------
    #  Registers a handler for a dictionary trait:
    #---------------------------------------------------------------------------

    def _register_dict ( self, object, name, remove ):
        """ Registers a handler for a dictionary trait.
        """
        next = self.next
        if next is None:
            handler = self.handler()
            if handler is not Undefined:
                object._on_trait_change(
                    handler,
                    name,
                    remove=remove,
                    dispatch=self.dispatch,
                    priority=self.priority,
                    target=self._get_target(),
                )

                if self.type == ANY_LISTENER:
                    object._on_trait_change(
                        handler,
                        name + '_items',
                        remove=remove,
                        dispatch=self.dispatch,
                        priority=self.priority,
                        target=self._get_target(),
                    )

            return ( object, name )

        tl_handler       = self.handle_dict
        tl_handler_items = self.handle_dict_items
        if self.notify:
            if self.type == DST_LISTENER:
                tl_handler = tl_handler_items = self.handle_error
            else:
                handler = self.handler()
                if handler is not Undefined:
                    object._on_trait_change(
                        handler,
                        name,
                        remove=remove,
                        dispatch=self.dispatch,
                        priority=self.priority,
                        target=self._get_target(),
                    )

                    if self.type == ANY_LISTENER:
                        object._on_trait_change(
                            handler,
                            name + '_items',
                            remove=remove,
                            dispatch=self.dispatch,
                            priority=self.priority,
                            target=self._get_target(),
                        )

        object._on_trait_change(
            tl_handler,
            name,
            remove=remove,
            dispatch=self.dispatch,
            priority=self.priority,
            target=self._get_target(),
        )

        object._on_trait_change(
            tl_handler_items,
            name + '_items',
            remove=remove,
            dispatch=self.dispatch,
            priority=self.priority,
            target=self._get_target(),
        )

        if remove:
            handler = next.unregister
        elif self.deferred:
            return INVALID_DESTINATION
        else:
            handler = next.register

        for obj in getattr( object, name ).values():
            handler( obj )

        return INVALID_DESTINATION

    #---------------------------------------------------------------------------
    #  Handles new traits being added to an object being monitored:
    #---------------------------------------------------------------------------

    def _new_trait_added ( self, object, name, new_trait ):
        """ Handles new traits being added to an object being monitored.
        """
        # Set if the new trait matches our prefix and metadata:
        if new_trait.startswith( self.name[:-1] ):
            trait = object.base_trait( new_trait )
            for meta_name, meta_eval in self._metadata.items():
                if not meta_eval( getattr( trait, meta_name ) ):
                    return

            # Determine whether the trait type is simple, list, set or
            # dictionary:
            type    = SIMPLE_LISTENER
            handler = trait.handler
            if handler is not None:
                type = type_map.get( handler.default_value_,
                                 SIMPLE_LISTENER )

            # Add the name and type to the list of traits being registered:
            self.active[ object ].append( ( new_trait, type ) )

            # Set up the appropriate trait listeners on the object for the
            # new trait:
            getattr( self, type )( object, new_trait, False )

    def _get_target(self):
        """ Get the target object from the ListenerNotifyWrapper.
        """
        target = None
        lnw = self.wrapped_handler_ref()
        if lnw is not None:
            target_ref = getattr(lnw, 'object', None)
            if target_ref is not None:
                target = target_ref()
        return target


#-------------------------------------------------------------------------------
#  'ListenerGroup' class:
#-------------------------------------------------------------------------------

def _set_value ( self, name, value ):
    for item in self.items:
        setattr( item, name, value )

def _get_value ( self, name ):
    # Use the attribute on the first item. If there are no items, return None.
    if self.items:
        return getattr( self.items[0], name )
    else:
        return None

ListProperty = Property( fget = _get_value, fset = _set_value )

class ListenerGroup ( ListenerBase ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #: The handler to be called when any listened-to trait is changed
    handler = Property

    #: A weakref 'wrapped' version of 'handler':
    wrapped_handler_ref = Property

    #: The dispatch mechanism to use when invoking the handler:
    dispatch = Property

    #: Does the handler go at the beginning (True) or end (False) of the
    #: notification handlers list?
    priority = ListProperty

    #: The next level (if any) of ListenerBase object to be called when any of
    #: this object's listened-to traits is changed
    next = ListProperty

    #: The type of handler being used:
    type = ListProperty

    #: Should changes to this item generate a notification to the handler?
    notify = ListProperty

    #: Should registering listeners for items reachable from this listener item
    #: be deferred until the associated trait is first read or set?
    deferred = ListProperty

    # The list of ListenerBase objects in the group
    items = List( ListenerBase )

    #-- Property Implementations -----------------------------------------------

    def _set_handler ( self, handler ):
        if self._handler is None:
            self._handler = handler
            for item in self.items:
                item.handler = handler

    def _set_wrapped_handler_ref ( self, wrapped_handler_ref ):
        if self._wrapped_handler_ref is None:
            self._wrapped_handler_ref = wrapped_handler_ref
            for item in self.items:
                item.wrapped_handler_ref = wrapped_handler_ref

    def _set_dispatch ( self, dispatch ):
        if self._dispatch is None:
            self._dispatch = dispatch
            for item in self.items:
                item.dispatch = dispatch

    #-- 'ListenerBase' Class Method Implementations ----------------------------

    #---------------------------------------------------------------------------
    #  String representation:
    #---------------------------------------------------------------------------

    def __repr__ ( self, seen = None ):
        """Returns a string representation of the object.

        Since the object graph may have cycles, we extend the basic __repr__ API
        to include a set of objects we've already seen while constructing
        a string representation. When this method tries to get the repr of
        a ListenerItem or ListenerGroup, we will use the extended API and build
        up the set of seen objects. The repr of a seen object will just be
        '<cycle>'.
        """
        if seen is None:
            seen = set()

        seen.add( self )

        lines = [ '%s(items = [' % self.__class__.__name__ ]

        for item in self.items:
            lines.extend( indent( item.__repr__( seen ), True ).split( '\n' ) )
            lines[-1] += ','

        lines.append( '])' )

        return '\n'.join( lines )

    #---------------------------------------------------------------------------
    #  Registers new listeners:
    #---------------------------------------------------------------------------

    def register ( self, new ):
        """ Registers new listeners.
        """
        for item in self.items:
            item.register( new )

        return INVALID_DESTINATION

    #---------------------------------------------------------------------------
    #  Unregisters any existing listeners:
    #---------------------------------------------------------------------------

    def unregister ( self, old ):
        """ Unregisters any existing listeners.
        """
        for item in self.items:
            item.unregister( old )

#-------------------------------------------------------------------------------
#  'ListenerParser' class:
#-------------------------------------------------------------------------------

class ListenerParser ( HasPrivateTraits ):

    #-------------------------------------------------------------------------------
    #  Trait definitions:
    #-------------------------------------------------------------------------------

    #: The string being parsed
    text = Str

    #: The length of the string being parsed.
    len_text = Int

    #: The current parse index within the string
    index = Int

    #: The next character from the string being parsed
    next = Property

    #: The next Python attribute name within the string:
    name = Property

    #: The next non-whitespace character
    skip_ws = Property

    #: Backspaces to the last character processed
    backspace = Property

    #: The ListenerBase object resulting from parsing **text**
    listener = Instance( ListenerBase )

    #-- Property Implementations -----------------------------------------------

    def _get_next ( self ):
        index       = self.index
        self.index += 1
        if index >= self.len_text:
            return EOS

        return self.text[ index ]

    def _get_backspace ( self ):
        self.index = max( 0, self.index - 1 )

    def _get_skip_ws ( self ):
        while True:
            c = self.next
            if c not in whitespace:
                return c

    def _get_name ( self ):
        match = name_pat.match( self.text, self.index - 1 )
        if match is None:
            return ''

        self.index = match.start( 2 )

        return match.group( 1 )

    #-- object Method Overrides ------------------------------------------------

    def __init__ ( self, text = '', **traits ):
        self.text = text
        super( ListenerParser, self ).__init__( **traits )

    #-- Private Methods --------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Parses the text and returns the appropriate collection of ListenerBase
    #  objects described by the text:
    #---------------------------------------------------------------------------

    def parse ( self ):
        """ Parses the text and returns the appropriate collection of
            ListenerBase objects described by the text.
        """
        # Try a simple case of 'name1.name2'. The simplest case of a single
        # Python name never triggers this parser, so we don't try to make that
        # a shortcut too. Whitespace should already have been stripped from the
        # start and end.

        # TODO: The use of regexes should be used throughout all of the parsing
        # functions to speed up all aspects of parsing.
        match = simple_pat.match( self.text )
        if match is not None:
            return ListenerItem(
                       name   = match.group( 1 ),
                       notify = match.group(2) == '.',
                       next   = ListenerItem( name = match.group( 3 ) ) )

        return self.parse_group( EOS )

    #---------------------------------------------------------------------------
    #  Parses the contents of a group:
    #---------------------------------------------------------------------------

    def parse_group ( self, terminator = ']' ):
        """ Parses the contents of a group.
        """
        items = []
        while True:
            items.append( self.parse_item( terminator ) )

            c = self.skip_ws
            if c == terminator:
                break

            if c != ',':
                if terminator == EOS:
                    self.error( "Expected ',' or end of string" )
                else:
                    self.error( "Expected ',' or '%s'" % terminator )

        if len( items ) == 1:
            return items[0]

        return ListenerGroup( items = items )

    #---------------------------------------------------------------------------
    #  Parses a single, complete listener item/group string:
    #---------------------------------------------------------------------------

    def parse_item ( self, terminator ):
        """ Parses a single, complete listener item or group string.
        """
        c = self.skip_ws
        if c == '[':
            result = self.parse_group()
            c      = self.skip_ws
        else:
            name = self.name
            if name != '':
                c = self.next

            result = ListenerItem( name = name )

            if c in '+-':
                result.name += '*'
                result.metadata_defined = (c == '+')
                cn = self.skip_ws
                result.metadata_name = metadata = self.name
                if metadata != '':
                    cn = self.skip_ws

                result.is_any_trait = ((c == '-') and (name == '') and
                                       (metadata == ''))
                c = cn

                if result.is_any_trait and (not ((c == terminator) or
                    ((c == ',') and (terminator == ']')))):
                    self.error( "Expected end of name" )
            elif c == '?':
                if len( name ) == 0:
                    self.error( "Expected non-empty name preceding '?'" )
                result.name += '?'
                c = self.skip_ws

        cycle = (c == '*')
        if cycle:
            c = self.skip_ws

        if c in '.:':
            result.notify = (c == '.')
            next = self.parse_item( terminator )
            if cycle:
                last = result
                while last.next is not None:
                    last = last.next
                last.next = lg = ListenerGroup( items = [ next, result ] )
                result    = lg
            else:
                result.next = next

            return result

        if c == '[':
            if (self.skip_ws == ']') and (self.skip_ws == terminator):
                self.backspace
                result.is_list_handler = True
            else:
                self.error( "Expected '[]' at the end of an item" )
        else:
            self.backspace

        if cycle:
            result.next = result

        return result

    #---------------------------------------------------------------------------
    #  Parses the metadata portion of a listener item:
    #---------------------------------------------------------------------------

    def parse_metadata ( self, item ):
        """ Parses the metadata portion of a listener item.
        """
        self.skip_ws
        item.metadata_name = name = self.name
        if name == '':
            self.backspace

    #---------------------------------------------------------------------------
    #  Raises a syntax error:
    #---------------------------------------------------------------------------

    def error ( self, msg ):
        """ Raises a syntax error.
        """
        raise TraitError( "%s at column %d of '%s'" %
                          ( msg, self.index, self.text ) )

    #-- Event Handlers ---------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles the 'text' trait being changed:
    #---------------------------------------------------------------------------

    def _text_changed ( self ):
        self.index    = 0
        self.len_text = len( self.text )
        self.listener = self.parse()

#-------------------------------------------------------------------------------
#  'ListenerNotifyWrapper' class:
#-------------------------------------------------------------------------------

class ListenerNotifyWrapper ( TraitChangeNotifyWrapper ):

    #-- TraitChangeNotifyWrapper Method Overrides ------------------------------

    def __init__ ( self, handler, owner, id, listener, target=None):
        self.type     = ListenerType.get( self.init( handler,
                                    weakref.ref( owner, self.owner_deleted ), target ) )
        self.id       = id
        self.listener = listener

    def listener_deleted ( self, ref ):
        owner = self.owner()
        if owner is not None:
            dict      = owner.__dict__.get( TraitsListener )
            listeners = dict.get( self.id )
            listeners.remove( self )
            if len( listeners ) == 0:
                del dict[ self.id ]
                if len( dict ) == 0:
                    del owner.__dict__[ TraitsListener ]
                # fixme: Is the following line necessary, since all registered
                # notifiers should be getting the same 'listener_deleted' call:
                self.listener.unregister( owner )

        self.object = self.owner = self.listener = None

    def owner_deleted ( self, ref ):
        self.object = self.owner = None

#-------------------------------------------------------------------------------
#  'ListenerHandler' class:
#-------------------------------------------------------------------------------

class ListenerHandler ( object ):

    def __init__ ( self, handler ):
        if type( handler ) is MethodType:
            object = handler.im_self
            if object is not None:
                self.object = weakref.ref( object, self.listener_deleted )
                self.name   = handler.__name__

                return

        self.handler = handler

    def __call__ ( self ):
        result = getattr( self, 'handler', None )
        if result is not None:
            return result

        return getattr( self.object(), self.name )

    def listener_deleted ( self, ref ):
        self.handler = Undefined


########NEW FILE########
__FILENAME__ = trait_base
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/21/2002
#
#  Refactored into a separate module: 07/04/2003
#
#------------------------------------------------------------------------------

""" Defines common, low-level capabilities needed by the Traits package.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import os
import sys
from os import getcwd
from os.path import dirname, exists, join

from . import _py2to3

# backwards compatibility: trait_base used to provide a patched enumerate
enumerate = enumerate

# Set the Python version being used:
vi = sys.version_info
python_version = vi[0] + (float( vi[1] ) / 10.0)

try:
    from traits.etsconfig.api import ETSConfig
except:
    # If the ETSConfig package is not available, fake it:
    class ETSConfig ( object ):

        #-----------------------------------------------------------------------
        #  'object' interface:
        #-----------------------------------------------------------------------

        def __init__ ( self ):
            """ Constructor.

                Note that this constructor can only ever be called from within
                this module, since we don't expose the class.
            """
            # Shadow attributes for properties:
            self._application_data = None
            self._toolkit          = None

            return

        #-----------------------------------------------------------------------
        #  'ETSConfig' interface:
        #-----------------------------------------------------------------------

        #-- Property Implementations -------------------------------------------

        def _get_application_data ( self ):
            """ Property getter.

                This is a directory that applications and packages can safely
                write non-user accessible data to i.e. configuration
                information, preferences etc.

                Do not put anything in here that the user might want to navigate
                to (e.g. projects, user data files, etc).

                The actual location differs between operating systems.
            """
            if self._application_data is None:
                self._application_data = self._initialize_application_data()

            return self._application_data

        def _set_application_data ( self, application_data ):
            """ Property setter.
            """
            self._application_data = application_data

        application_data = property( _get_application_data,
                                     _set_application_data )

        def _get_toolkit ( self ):
            """
            Property getter for the GUI toolkit.  The value returned is, in
            order of preference: the value set by the application; the value
            passed on the command line using the '-toolkit' option; the value
            specified by the 'ETS_TOOLKIT' environment variable; otherwise the
            empty string.
            """
            if self._toolkit is None:
                self._toolkit = self._initialize_toolkit()

            return self._toolkit

        def _set_toolkit ( self, toolkit ):
            """
            Property setter for the GUI toolkit.  The toolkit can be set more
            than once, but only if it is the same one each time.  An application
            that is written for a particular toolkit can explicitly set it
            before any other module that gets the value is imported.

            """
            if self._toolkit and (self._toolkit != toolkit):
                raise ValueError( 'Cannot set toolkit to %s because it has '
                         'already been set to %s' % ( toolkit, self._toolkit ) )

            self._toolkit = toolkit

            return

        toolkit = property( _get_toolkit, _set_toolkit )

        #-- Private Methods ----------------------------------------------------

        def _initialize_application_data ( self ):
            """ Initializes the (default) application data directory.
            """
            if sys.platform == 'win32':
                environment_variable = 'APPDATA'
                directory_name       = 'Enthought'

            else:
                environment_variable = 'HOME'
                directory_name       = '.enthought'

            # Lookup the environment variable:
            parent_directory = os.environ.get( environment_variable, None )
            if parent_directory is None:
                raise ValueError( 'Environment variable "%s" not set' %
                                  environment_variable )

            application_data = os.path.join( parent_directory, directory_name )

            # If a file already exists with this name then make sure that it is
            # a directory!
            if os.path.exists( application_data ):
                if not os.path.isdir( application_data ):
                    raise ValueError( 'File "%s" already exists' %
                                      application_data )

            # Otherwise, create the directory:
            else:
                os.makedirs( application_data )

            return application_data

        def _initialize_toolkit ( self ):
            """ Initializes the toolkit.
            """
            # We handle the command line option even though it doesn't have the
            # highest precedence because we always want to remove it from the
            # command line:
            if '-toolkit' in sys.argv:
                opt_idx = sys.argv.index( '-toolkit' )

                try:
                    opt_toolkit = sys.argv[ opt_idx + 1 ]
                except IndexError:
                    raise ValueError( 'The -toolkit command line argument must '
                                      'be followed by a toolkit name' )

                # Remove the option:
                del sys.argv[ opt_idx: opt_idx + 1 ]
            else:
                opt_toolkit = None

            if self._toolkit is not None:
                toolkit = self._toolkit
            elif opt_toolkit is not None:
                toolkit = opt_toolkit
            else:
                toolkit = os.environ.get( 'ETS_TOOLKIT', '' )

            return toolkit

    ETSConfig = ETSConfig()

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

ClassTypes    = _py2to3.ClassTypes

SequenceTypes = ( list, tuple )

ComplexTypes  = ( float, int )

TypeTypes     = ( str,  unicode, int, long, float, complex, list, tuple, dict, bool )

TraitNotifier = '__trait_notifier__'

# The standard Traits property cache prefix:
TraitsCache = '_traits_cache_'

#-------------------------------------------------------------------------------
#  Singleton 'Uninitialized' object:
#-------------------------------------------------------------------------------
Uninitialized = None

class _Uninitialized(object):
    """ The singleton value of this class represents the uninitialized state
        of a trait and is specified as the 'old' value in the trait change
        notification that occurs when the value of a trait is read before being
        set.
    """

    def __new__(cls):
        if Uninitialized is not None:
            return Uninitialized
        else:
            self = object.__new__(cls)
            return self

    def __repr__(self):
        return '<uninitialized>'

    def __reduce_ex__(self, protocol):
        return (_Uninitialized, ())

#: When the first reference to a trait is a 'get' reference, the default value of
#: the trait is implicitly assigned and returned as the value of the trait.
#: Because of this implicit assignment, a trait change notification is
#: generated with the Uninitialized object as the 'old' value of the trait, and
#: the default trait value as the 'new' value. This allows other parts of the
#: traits package to recognize the assignment as the implicit default value
#: assignment, and treat it specially.
Uninitialized = _Uninitialized()

#-------------------------------------------------------------------------------
#  Singleton 'Undefined' object (used as undefined trait name and/or value):
#-------------------------------------------------------------------------------

Undefined = None

class _Undefined(object):
    """ Singleton 'Undefined' object (used as undefined trait name and/or value)
    """
    def __new__(cls):
        if Undefined is not None:
            return Undefined
        else:
            self = object.__new__(cls)
            return self

    def __repr__(self):
        return '<undefined>'

    def __reduce_ex__(self, protocol):
        return (_Undefined, ())

    def __eq__(self, other):
        return type(self) is type(other)

    def __hash__(self):
        return hash(type(self))

    def __ne__(self, other):
        return type(self) is not type(other)

#: Singleton object that indicates that a trait attribute has not yet had a
#: value set (i.e., its value is undefined). This object is used instead of
#: None, because None often has other meanings, such as that a value is not
#: used. When a trait attribute is first assigned a value, and its associated
#: trait notification handlers are called, Undefined is passed as the *old*
#: parameter, to indicate that the attribute previously had no value.
Undefined = _Undefined()

# Tell the C-base code about singleton 'Undefined' and 'Uninitialized' objects:
from . import ctraits
ctraits._undefined( Undefined, Uninitialized )

#-------------------------------------------------------------------------------
#  Singleton 'Missing' object (used as missing method argument marker):
#-------------------------------------------------------------------------------

class Missing ( object ):
    """ Singleton 'Missing' object (used as missing method argument marker).
    """
    def __repr__ ( self ):
        return '<missing>'

#: Singleton object that indicates that a method argument is missing from a
#: type-checked method signature.
Missing = Missing()

#-------------------------------------------------------------------------------
#  Singleton 'Self' object (used as object reference to current 'object'):
#-------------------------------------------------------------------------------

class Self ( object ):
    """ Singleton 'Self' object (used as object reference to current 'object').
    """
    def __repr__ ( self ):
        return '<self>'

#: Singleton object that references the current 'object'.
Self = Self()

#-------------------------------------------------------------------------------
#  Define a special 'string' coercion function:
#-------------------------------------------------------------------------------

def strx ( arg ):
    """ Wraps the built-in str() function to raise a TypeError if the
    argument is not of a type in StringTypes.
    """
    if type( arg ) in StringTypes:
       return str( arg )
    raise TypeError

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

StringTypes = ( str, unicode, int, long, float, complex )

#-------------------------------------------------------------------------------
#  Define a mapping of coercable types:
#-------------------------------------------------------------------------------

# Mapping of coercable types.
CoercableTypes = {
    long:    ( 11, long, int ),
    float:   ( 11, float, int ),
    complex: ( 11, complex, float, int ),
    unicode: ( 11, unicode, str )
}

#-------------------------------------------------------------------------------
#  Return a string containing the class name of an object with the correct
#  article (a or an) preceding it (e.g. 'an Image', 'a PlotValue'):
#-------------------------------------------------------------------------------

def class_of ( object ):
    """ Returns a string containing the class name of an object with the
    correct indefinite article ('a' or 'an') preceding it (e.g., 'an Image',
    'a PlotValue').
    """
    if isinstance( object, basestring ):
        return add_article( object )

    return add_article( object.__class__.__name__ )

#-------------------------------------------------------------------------------
#  Return a string containing the right article (i.e. 'a' or 'an') prefixed to
#  a specified string:
#-------------------------------------------------------------------------------

def add_article ( name ):
    """ Returns a string containing the correct indefinite article ('a' or 'an')
    prefixed to the specified string.
    """
    if name[:1].lower() in 'aeiou':
       return 'an ' + name

    return 'a ' + name

#----------------------------------------------------------------------------
#  Return a 'user-friendly' name for a specified trait:
#----------------------------------------------------------------------------

def user_name_for ( name ):
    """ Returns a "user-friendly" version of a string, with the first letter
    capitalized and with underscore characters replaced by spaces. For example,
    ``user_name_for('user_name_for')`` returns ``'User name for'``.
    """
    name       = name.replace( '_', ' ' )
    result     = ''
    last_lower = False

    for c in name:
        if c.isupper() and last_lower:
           result += ' '
        last_lower = c.islower()
        result    += c

    return result.capitalize()

#-------------------------------------------------------------------------------
#  Gets the path to the traits home directory:
#-------------------------------------------------------------------------------

_traits_home = None

def traits_home ( ):
    """ Gets the path to the Traits home directory.
    """
    global _traits_home

    if _traits_home is None:
        _traits_home = verify_path( join( ETSConfig.application_data,
                                          'traits' ) )

    return _traits_home

#-------------------------------------------------------------------------------
#  Verify that a specified path exists, and try to create it if it doesn't:
#-------------------------------------------------------------------------------

def verify_path ( path ):
    """ Verify that a specified path exists, and try to create it if it
        does not exist.
    """
    if not exists( path ):
        try:
            os.mkdir( path )
        except:
            pass

    return path

#-------------------------------------------------------------------------------
#  Returns the name of the module the caller's caller is located in:
#-------------------------------------------------------------------------------

def get_module_name ( level = 2 ):
    """ Returns the name of the module that the caller's caller is located in.
    """
    return sys._getframe( level ).f_globals.get( '__name__', '__main__' )

#-------------------------------------------------------------------------------
#  Returns a resource path calculated from the caller's stack:
#-------------------------------------------------------------------------------

def get_resource_path ( level = 2 ):
    """Returns a resource path calculated from the caller's stack.
    """
    module = sys._getframe( level ).f_globals.get( '__name__', '__main__' )

    if module != '__main__':
        # Return the path to the module:
        try:
            return dirname( getattr( sys.modules.get( module ), '__file__' ) )
        except:
            # Apparently 'module' is not a registered module...treat it like
            # '__main__':
            pass

    # '__main__' is not a real module, so we need a work around:
    for path in [ dirname( sys.argv[0] ), getcwd() ]:
        if exists( path ):
            break

    return path

#-------------------------------------------------------------------------------
#  Returns the value of an extended object attribute name of the form:
#  name[.name2[.name3...]]:
#-------------------------------------------------------------------------------

def xgetattr( object, xname, default = Undefined ):
    """ Returns the value of an extended object attribute name of the form:
        name[.name2[.name3...]].
    """
    names = xname.split( '.' )
    for name in names[:-1]:
        if default is Undefined:
            object = getattr( object, name )
        else:
            object = getattr( object, name, None )
            if object is None:
                return default

    if default is Undefined:
        return getattr( object, names[-1] )

    return getattr( object, names[-1], default )

#-------------------------------------------------------------------------------
#  Sets the value of an extended object attribute name of the form:
#  name[.name2[.name3...]]:
#-------------------------------------------------------------------------------

def xsetattr( object, xname, value ):
    """ Sets the value of an extended object attribute name of the form:
        name[.name2[.name3...]].
    """
    names = xname.split( '.' )
    for name in names[:-1]:
        object = getattr( object, name )

    setattr( object, names[-1], value )

#-------------------------------------------------------------------------------
#  Traits metadata selection functions:
#-------------------------------------------------------------------------------

def is_none ( value ):
    return (value is None)

def not_none ( value ):
    return (value is not None)

def not_false ( value ):
    return (value is not False)

def not_event ( value ):
    return (value != 'event')

def is_str ( value ):
    return isinstance( value, basestring )

########NEW FILE########
__FILENAME__ = trait_errors
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/21/2002
#
#------------------------------------------------------------------------------

""" Defines the standard exceptions raised by the Traits package.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import sys

from .trait_base import class_of

from . import _py2to3

#-------------------------------------------------------------------------------
#  Utilities
#-------------------------------------------------------------------------------


def repr_type(obj):
    """ Return a string representation of a value and its type for readable
    error messages.
    """
    the_type = _py2to3.type_w_old_style(obj)
    msg = '%r %r' % (obj, the_type)
    return msg

#-------------------------------------------------------------------------------
#  'TraitError' class:
#-------------------------------------------------------------------------------

class TraitError ( Exception ):

    def __init__ ( self, args = None, name = None, info = None, value = None ):
        if name is None:
           # If the given args is not a tuple then assume that the user intended
           # it to be the single item in a one-element tuple.
           if not isinstance(args, tuple):
               args = args,
           self.args = args
        else:
           # Save the information, in case the 'args' object is not the correct
           # one, and we need to regenerate the message later:
           self.name   = name
           self.info   = info
           self.value  = value
           self.desc   = None
           self.prefix = 'The'
           self.set_desc( None, args )

    def set_desc ( self, desc, object = None ):
        if hasattr( self, 'desc' ):
           if desc is not None:
              self.desc = desc
           if object is not None:
              self.object = object
           self.set_args()

    def set_prefix ( self, prefix ):
        if hasattr( self, 'prefix' ):
           self.prefix = prefix
           self.set_args()

    def set_args ( self ):
        if self.desc is None:
           extra = ''
        else:
           extra = ' specifies %s and' % self.desc
        obj = getattr( self, 'object', None )

        # Note: self.args must be a tuple so be sure to leave the trailing
        # commas.
        the_type = _py2to3.type_w_old_style(self.value)
        if obj is not None:
            self.args = ("%s '%s' trait of %s instance%s must be %s, "
                         "but a value of %s was specified." % (
                         self.prefix, self.name, class_of(obj), extra,
                         self.info, repr_type(self.value))),
        else:
            self.args = ("%s '%s' trait%s must be %s, but a value of %s was "
                         "specified." % (self.prefix, self.name, extra,
                                         self.info, repr_type(self.value))),

#-------------------------------------------------------------------------------
#  'TraitNotificationError' class:
#-------------------------------------------------------------------------------

class TraitNotificationError ( Exception ):

    pass

#-------------------------------------------------------------------------------
#  'DelegationError' class:
#-------------------------------------------------------------------------------

class DelegationError ( TraitError ):

    def __init__ ( self, args ):
        # .args must be a tuple.
        self.args = args,

#-------------------------------------------------------------------------------
#  Export the defined exceptions to the C-base traits module:
#-------------------------------------------------------------------------------

from . import ctraits
ctraits._exceptions( TraitError, DelegationError )

########NEW FILE########
__FILENAME__ = trait_handlers
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/21/2002
#
#  Refactored into a separate module: 07/04/2003
#
#------------------------------------------------------------------------------

"""
Defines the BaseTraitHandler class and a standard set of BaseTraitHandler
subclasses for use with the Traits package.

A trait handler mediates the assignment of values to object traits. It
verifies (via its validate() method) that a specified value is consistent
with the object trait, and generates a TraitError exception if it is not
consistent.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import sys
import re
import copy
import copy_reg
from types import FunctionType, MethodType
TypeType = type

from weakref import ref

from .trait_base import (strx, SequenceTypes, Undefined, TypeTypes, ClassTypes,
    CoercableTypes, TraitsCache, class_of, Missing)
from .trait_errors import TraitError, repr_type

from . import _py2to3

# Patched by 'traits.py' once class is defined!
Trait = Event = None

# Set up a logger:
import logging
logger = logging.getLogger( __name__ )

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Trait 'comparison_mode' enum values:
NO_COMPARE              = 0
OBJECT_IDENTITY_COMPARE = 1
RICH_COMPARE            = 2

RangeTypes    = ( int, long, float )

CallableTypes = ( FunctionType, MethodType )

# Mapping from trait metadata 'type' to CTrait 'type':
trait_types = {
    'python': 1,
    'event':  2
}

#-------------------------------------------------------------------------------
#  Forward references:
#-------------------------------------------------------------------------------

trait_from = None  # Patched by 'traits.py' when real 'trait_from' is defined

#-------------------------------------------------------------------------------
#  Returns the correct argument count for a specified function or method:
#-------------------------------------------------------------------------------

def _arg_count ( func ):
    """ Returns the correct argument count for a specified function or method.
    """
    if (type( func ) is MethodType) and (func.im_self is not None):
        return func.func_code.co_argcount - 1
    return func.func_code.co_argcount

#-------------------------------------------------------------------------------
#  Property error handling functions:
#-------------------------------------------------------------------------------

def _write_only ( object, name ):
    raise TraitError, "The '%s' trait of %s instance is 'write only'." % (
                      name, class_of( object ) )

def _read_only ( object, name, value ):
    raise TraitError, "The '%s' trait of %s instance is 'read only'." % (
                      name, class_of( object ) )

def _undefined_get ( object, name ):
    raise TraitError, ("The '%s' trait of %s instance is a property that has "
                       "no 'get' or 'set' method") % (
                       name, class_of( object ) )

def _undefined_set ( object, name, value ):
    _undefined_get( object, name )

#-------------------------------------------------------------------------------
#  'BaseTraitHandler' class (base class for all user defined traits and trait
#  handlers):
#-------------------------------------------------------------------------------

class BaseTraitHandler ( object ):
    """ The task of this class and its subclasses is to verify the correctness
    of values assigned to object trait attributes.

    This class is an alternative to trait validator functions. A trait handler
    has several advantages over a trait validator function, due to being an
    object:

        * Trait handlers have constructors and state. Therefore, you can use
          them to create *parametrized types*.
        * Trait handlers can have multiple methods, whereas validator functions
          can have only one callable interface. This feature allows more
          flexibility in their implementation, and allows them to handle a
          wider range of cases, such as interactions with other components.
    """

    default_value_type = -1
    has_items          = False
    is_mapped          = False
    editor             = None
    info_text          = 'a legal value'

    def is_valid ( self, object, name, value ):
        try:
            validate = self.validate
            try:
                validate( object, name, value )
                return True
            except:
                return False
        except:
            return True

    def error ( self, object, name, value ):
        """Raises a TraitError exception.

        Parameters
        ----------
        object : object
            The object whose attribute is being assigned.
        name : str
            The name of the attribute being assigned.
        value : object
            The proposed new value for the attribute.

        Description
        -----------
        This method is called by the validate() method when an assigned value
        is not valid. Raising a TraitError exception either notifies the user of
        the problem, or, in the case of compound traits, provides a chance for
        another trait handler to handle to validate the value.
        """
        raise TraitError( object, name, self.full_info( object, name, value ),
                          value )

    def full_info ( self, object, name, value ):
        """Returns a string describing the type of value accepted by the
        trait handler.

        Parameters
        ----------
        object : object
            The object whose attribute is being assigned.
        name : str
            The name of the attribute being assigned.
        value :
            The proposed new value for the attribute.

        Description
        -----------
        The string should be a phrase describing the type defined by the
        TraitHandler subclass, rather than a complete sentence. For example, use
        the phrase, "a square sprocket" instead of the sentence, "The value must
        be a square sprocket." The value returned by full_info() is combined
        with other information whenever an error occurs and therefore makes more
        sense to the user if the result is a phrase. The full_info() method is
        similar in purpose and use to the **info** attribute of a validator
        function.

        Note that the result can include information specific to the particular
        trait handler instance. For example, TraitRange instances return a
        string indicating the range of values acceptable to the handler (e.g.,
        "an integer in the range from 1 to 9"). If the full_info() method is not
        overridden, the default method returns the value of calling the info()
        method.
        """
        return self.info()

    def info ( self ):
        """Must return a string describing the type of value accepted by the
        trait handler.

        The string should be a phrase describing the type defined by the
        TraitHandler subclass, rather than a complete sentence. For example, use
        the phrase, "a square sprocket" instead of the sentence, "The value must
        be a square sprocket." The value returned by info() is combined with
        other information whenever an error occurs and therefore makes more
        sense to the user if the result is a phrase. The info() method is
        similar in purpose and use to the **info** attribute of a validator
        function.

        Note that the result can include information specific to the particular
        trait handler instance. For example, TraitRange instances return a
        string indicating the range of values acceptable to the handler (e.g.,
        "an integer in the range from 1 to 9"). If the info() method is not
        overridden, the default method returns the value of the 'info_text'
        attribute.
        """
        return self.info_text

    def repr ( self, value ):
        """ Returns a printable representation of a value along with its type.

        .. deprecated :: 3.0.3
            This functionality was only used to provide readable error
            messages. This functionality has been incorporated into
            TraitError itself.

        Parameters
        ----------
        value : object
            The value to be printed.
        """
        import warnings
        warnings.warn("this functionality has been merged into TraitError; "
            "just pass the raw value", DeprecationWarning)
        return repr_type(value)

    def get_editor ( self, trait = None ):
        """ Returns a trait editor that allows the user to modify the *trait*
        trait.

        Parameters
        ----------
        trait : Trait
            The trait to be edited.

        Description
        -----------
        This method only needs to be specified if traits defined using this
        trait handler require a non-default trait editor in trait user
        interfaces. The default implementation of this method returns a trait
        editor that allows the user to type an arbitrary string as the value.

        For more information on trait user interfaces, refer to the *Traits UI
        User Guide*.
        """
        if self.editor is None:
            self.editor = self.create_editor()

        return self.editor

    def create_editor ( self ):
        """ Returns the default traits UI editor to use for a trait.
        """
        from traitsui.api import TextEditor

        return TextEditor()

    def inner_traits ( self ):
        """ Returns a tuple containing the *inner traits* for this trait. Most
            trait handlers do not have any inner traits, and so will return an
            empty tuple. The exceptions are **List** and **Dict** trait types,
            which have inner traits used to validate the values assigned to the
            trait. For example, in *List( Int )*, the *inner traits* for
            **List** are ( **Int**, ).
        """
        return ()

#-------------------------------------------------------------------------------
#  'TraitType' (base class for class-based trait definitions:
#-------------------------------------------------------------------------------

# Create a singleton object for use in the TraitType constructor:
class NoDefaultSpecified ( object ): pass
NoDefaultSpecified = NoDefaultSpecified()

class TraitType ( BaseTraitHandler ):
    """ Base class for new trait types.

        This class enables you to define new traits using a class-based
        approach, instead of by calling the Trait() factory function with an
        instance of a TraitHandler derived object.

        When subclassing this class, you can implement one or more of the
        method signatures below. Note that these methods are defined only as
        comments, because the absence of method definitions in the subclass
        definition implicitly provides information about how the trait should
        operate.

        The optional methods are as follows:

        * **get ( self, object, name ):**

          This is the getter method of a trait that behaves like a property.

          :Parameters:
            **object** (*object*) -- The object that the property applies to.

            **name** (str) -- The name of the property on *object* property.

          *Description*

          If neither this method nor the set() method is defined, the value
          of the trait is handled like a normal object attribute. If this
          method is not defined, but the set() method is defined, the trait
          behaves like a write-only property. This method should return the
          value of the *name* property for the *object* object.

        * **set ( self, object, name, value )**

          This is the setter method of a trait that behaves like a property.

          :Parameters:
            **object** (*object*) -- The object that the property applies to.

            **name** (str) -- The name of the property on *object*.

            **value** -- The value being assigned as the value of the property.

          *Description*

          If neither this method nor the get() method is implemented, the
          trait behaves like a normal trait attribute. If this method is not
          defined, but the get() method is defined, the trait behaves like a
          read-only property. This method does not need to return a value,
          but it should raise a TraitError exception if the specified *value*
          is not valid and cannot be coerced or adapted to a valid value.

        * **validate ( self, object, name, value )**

          This method validates, coerces, or adapts the specified *value* as
          the value of the *name* trait of the *object* object. This method
          is called when a value is assigned to an object trait that is
          based on this subclass of *TraitType* and the class does not
          contain a definition for either the get() or set() methods. This
          method must return the original *value* or any suitably coerced or
          adapted value that is a legal value for the trait. If *value* is
          not a legal value for the trait, and cannot be coerced or adapted
          to a legal value, the method should either raise a **TraitError** or
          call the **error** method to raise the **TraitError** on its behalf.

        * **is_valid_for ( self, value )**

          As an alternative to implementing the **validate** method, you can
          instead implement the **is_valid_for** method, which receives only
          the *value* being assigned. It should return **True** if the value is
          valid, and **False** otherwise.

        * **value_for ( self, value )**

          As another alternative to implementing the **validate** method, you
          can instead implement the **value_for** method, which receives only
          the *value* being assigned. It should return the validated form of
          *value* if it is valid, or raise a **TraitError** if the value is not
          valid.

        * **post_setattr ( self, object, name, value )**

          This method allows the trait to do additional processing after
          *value* has been successfully assigned to the *name* trait of the
          *object* object. For most traits there is no additional processing
          that needs to be done, and this method need not be defined. It is
          normally used for creating "shadow" (i.e., "mapped" traits), but
          other uses may arise as well. This method does not need to return
          a value, and should normally not raise any exceptions.
    """

    default_value = Undefined
    metadata      = {}

    def __init__ ( self, default_value = NoDefaultSpecified, **metadata ):
        """ This constructor method is the only method normally called
            directly by client code. It defines the trait. The
            default implementation accepts an optional, untype-checked default
            value, and caller-supplied trait metadata. Override this method
            whenever a different method signature or a type-checked
            default value is needed.
        """
        if default_value is not NoDefaultSpecified:
            self.default_value = default_value

        if len( metadata ) > 0:
            if len( self.metadata ) > 0:
                self._metadata = self.metadata.copy()
                self._metadata.update( metadata )
            else:
                self._metadata = metadata
        else:
            self._metadata = self.metadata.copy()

        self.init()

    def init ( self ):
        """ Allows the trait to perform any additional initialization needed.
        """
        pass

    def get_default_value ( self ):
        """ Returns a tuple of the form: (*default_value_type*, *default_value*)
            which describes the default value for this trait. The default
            implementation analyzes the value of the trait's **default_value**
            attribute and determines an appropriate *default_value_type* for
            *default_value*. If you need to override this method to provide a
            different result tuple, the following values are valid values for
            *default_value_type*:

                - 0, 1: The *default_value* item of the tuple is the default
                  value.
                - 2: The object containing the trait is the default value.
                - 3: A new copy of the list specified by *default_value* is
                  the default value.
                - 4: A new copy of the dictionary specified by *default_value*
                  is the default value.
                - 5: A new instance of TraitListObject constructed using the
                  *default_value* list is the default value.
                - 6: A new instance of TraitDictObject constructed using the
                  *default_value* dictionary is the default value.
                - 7: *default_value* is a tuple of the form: (*callable*, *args*,
                  *kw*), where *callable* is a callable, *args* is a tuple, and
                  *kw* is either a dictionary or None. The default value is the
                  result obtained by invoking callable(\*args, \*\*kw).
                - 8: *default_value* is a callable. The default value is the
                  result obtained by invoking *default_value*(*object*), where
                  *object* is the object containing the trait. If the trait has
                  a validate() method, the validate() method is also called to
                  validate the result.
                - 9: A new instance of TraitSetObject constructed using the
                  *default_value* set is the default value.
        """
        dv  = self.default_value
        dvt = self.default_value_type
        if dvt < 0:
            dvt = 0
            if isinstance( dv, TraitListObject ):
                dvt = 5
            elif isinstance( dv, list ):
                dvt = 3
            elif isinstance( dv, TraitDictObject ):
                dvt = 6
            elif isinstance( dv, dict ):
                dvt = 4
            elif isinstance( dv, TraitSetObject ):
                dvt = 9

            self.default_value_type = dvt

        return ( dvt, dv )

    def clone ( self, default_value = Missing, **metadata ):
        """ Clones the contents of this object into a new instance of the same
            class, and then modifies the cloned copy using the specified
            *default_value* and *metadata*. Returns the cloned object as the
            result.

            Note that subclasses can change the signature of this method if
            needed, but should always call the 'super' method if possible.
        """
        if 'parent' not in metadata:
            metadata[ 'parent' ] = self

        new      = self.__class__.__new__( self.__class__ )
        new_dict = new.__dict__
        new_dict.update( self.__dict__ )

        if 'editor' in new_dict:
            del new_dict[ 'editor' ]

        if '_metadata' in new_dict:
            new._metadata = new._metadata.copy()
        else:
            new._metadata = {}

        new._metadata.update( metadata )

        if default_value is not Missing:
            new.default_value = default_value
            if self.validate is not None:
                try:
                    new.default_value = self.validate( None, None,
                                                       default_value )
                except:
                    pass

        return new

    def get_value ( self, object, name, trait = None ):
        """ Returns the current value of a property-based trait.
        """
        cname = TraitsCache + name
        value = object.__dict__.get( cname, Undefined )
        if value is Undefined:
            if trait is None:
                trait = object.trait( name )

            object.__dict__[ cname ] = value = \
                trait.default_value_for( object, name )

        return value

    def set_value ( self, object, name, value ):
        """ Sets the cached value of a property-based trait and fires the
            appropriate trait change event.
        """
        cname = TraitsCache + name
        old   = object.__dict__.get( cname, Undefined )
        if value != old:
            object.__dict__[ cname ] = value
            object.trait_property_changed( name, old, value )

    #-- Private Methods --------------------------------------------------------

    def __call__ ( self, *args, **kw ):
        """ Allows a derivative trait to be defined from this one.
        """
        return self.clone( *args, **kw ).as_ctrait()

    def _is_valid_for ( self, object, name, value ):
        """ Handles a simplified validator that only returns whether or not the
            original value is valid.
        """
        if self.is_valid_for( value ):
            return value

        self.error( object, name, value )

    def _value_for ( self, object, name, value ):
        """ Handles a simplified validator that only receives the value
            argument.
        """
        try:
            return self.value_for( value )
        except TraitError:
            self.error( object, name, value )

    def as_ctrait ( self ):
        """ Returns a CTrait corresponding to the trait defined by this class.
        """
        from .traits import CTrait

        metadata = getattr( self, '_metadata', {} )
        getter   = getattr( self, 'get', None )
        setter   = getattr( self, 'set', None )
        if (getter is not None) or (setter is not None):
            if getter is None:
                getter = _write_only
                metadata.setdefault( 'transient', True )
            elif setter is None:
                setter = _read_only
                metadata.setdefault( 'transient', True )
            trait    = CTrait( 4 )
            n        = 0
            validate = getattr( self, 'validate', None )
            if validate is not None:
                n = _arg_count( validate )
            trait.property( getter,   _arg_count( getter ),
                            setter,   _arg_count( setter ),
                            validate, n )
            metadata.setdefault( 'type', 'property' )
        else:
            type = getattr( self, 'ctrait_type', None )
            if type is None:
                type = trait_types.get( metadata.get( 'type' ), 0 )
            trait = CTrait( type )

            validate = getattr( self, 'fast_validate', None )
            if validate is None:
                validate = getattr( self, 'validate', None )
                if validate is None:
                    validate = getattr( self, 'is_valid_for', None )
                    if validate is not None:
                        validate = self._is_valid_for
                    else:
                        validate = getattr( self, 'value_for', None )
                        if validate is not None:
                            validate = self._value_for

            if validate is not None:
                trait.set_validate( validate )

            post_setattr = getattr( self, 'post_setattr', None )
            if post_setattr is not None:
                trait.post_setattr = post_setattr
                trait.is_mapped( self.is_mapped )

            # Note: The use of 'rich_compare' metadata is deprecated; use
            # 'comparison_mode' metadata instead:
            rich_compare = metadata.get( 'rich_compare' )
            if rich_compare is not None:
                trait.rich_comparison( rich_compare is True )

            comparison_mode = metadata.get( 'comparison_mode' )
            if comparison_mode is not None:
                trait.comparison_mode( comparison_mode )

            metadata.setdefault( 'type', 'trait' )

        trait.default_value( *self.get_default_value() )

        trait.value_allowed( metadata.get( 'trait_value', False ) is True )

        trait.handler = self

        trait.__dict__ = metadata.copy()

        return trait

    def __getattr__ ( self, name ):
        if (name[:2] == '__') and (name[-2:] == '__'):
            raise AttributeError( "'%s' object has no attribute '%s'" % (
                                  self.__class__.__name__, name ) )

        return getattr( self, '_metadata', {} ).get( name, None )

#-------------------------------------------------------------------------------
#  'TraitHandler' class (base class for all trait handlers):
#-------------------------------------------------------------------------------

class TraitHandler ( BaseTraitHandler ):
    """ The task of this class and its subclasses is to verify the correctness
    of values assigned to object trait attributes.

    This class is an alternative to trait validator functions. A trait handler
    has several advantages over a trait validator function, due to being an
    object:

        * Trait handlers have constructors and state. Therefore, you can use
          them to create *parametrized types*.
        * Trait handlers can have multiple methods, whereas validator functions
          can have only one callable interface. This feature allows more
          flexibility in their implementation, and allows them to handle a
          wider range of cases, such as interactions with other components.

    The only method of TraitHandler that *must* be implemented by subclasses
    is validate().
    """

    def validate ( self, object, name, value ):
        """ Verifies whether a new value assigned to a trait attribute is valid.

        Parameters
        ----------
        object : object
            The object whose attribute is being assigned.
        name : str
            The name of the attribute being assigned.
        value :
            The proposed new value for the attribute.

        Returns
        -------
        If the new value is valid, this method must return either the original
        value passed to it, or an alternate value to be assigned in place of the
        original value. Whatever value this method returns is the actual value
        assigned to *object.name*.

        Description
        -----------
        This method *must* be implemented by subclasses of TraitHandler. It is
        called whenever a new value is assigned to a trait attribute defined
        using this trait handler.

        If the value received by validate() is not valid for the trait
        attribute, the method must called the predefined error() method to
        raise a TraitError exception

        """
        raise TraitError, (
              "The '%s' trait of %s instance has an unknown type. "
              "Contact the developer to correct the problem." % (
              name, class_of( object ) ) )

#-------------------------------------------------------------------------------
#  'TraitRange' class:
#-------------------------------------------------------------------------------

class TraitRange ( TraitHandler ):
    """Ensures that a trait attribute lies within a specified numeric range.

    TraitRange is the underlying handler for the predefined Range() trait
    factory.

    Any value assigned to a trait containing a TraitRange handler must be of the
    correct type and in the numeric range defined by the TraitRange instance.
    No automatic coercion takes place. For example::

        class Person(HasTraits):
            age = Trait(0, TraitRange(0, 150))
            weight = Trait(0.0, TraitRange(0.0, None))

    This example defines a Person class, which has an **age** trait
    attribute, which must be an integer/long in the range from 0 to 150, and a
    **weight** trait attribute, which must be a non-negative float value.
    """
    def __init__ ( self, low = None, high = None,
                         exclude_low = False, exclude_high = False ):
        """ Creates a TraitRange handler.

        Parameters
        ----------
        low : number
            The minimum value that the trait can accept.
        high : number
            The maximum value that the trait can accept.
        exclude_low : bool
            Should the *low* value be exclusive (or inclusive).
        exclude_high : bool
            Should the *high* value be exclusive (or inclusive).

        Description
        -----------
        The *low* and *high* values must be of the same Python numeric type,
        either ``int``, ``long`` or ``float``. Alternatively, one of the values
        may be None, to indicate that that portion of the range is
        unbounded. The *exclude_low* and *exclude_high* values can be used to
        specify whether the *low* and *high* values should be exclusive (or
        inclusive).
        """

        vtype = type( high )
        if (low is not None) and (vtype is not float):
            vtype = type( low )
        if vtype not in RangeTypes:
            raise TraitError, ("TraitRange can only be use for int, long or "
                               "float values, but a value of type %s was "
                               "specified." % vtype)
        if vtype is float:
            self.validate = self.float_validate
            kind            = 4
            self._type_desc = 'a floating point number'
            if low is not None:
                low = float( low )
            if high is not None:
                high = float( high )
        elif vtype is long:
            self.validate   = self.long_validate
            self._type_desc = 'a long integer'
            if low is not None:
                low = long( low )
            if high is not None:
                high = long( high )
        else:
            self.validate = self.int_validate
            kind = 3
            self._type_desc = 'an integer'
            if low is not None:
                low = int( low )
            if high is not None:
                high = int( high )
        exclude_mask = 0
        if exclude_low:
            exclude_mask |= 1
        if exclude_high:
            exclude_mask |= 2
        if vtype is not long:
            self.fast_validate = ( kind, low, high, exclude_mask )

        # Assign type-corrected arguments to handler attributes
        self._low          = low
        self._high         = high
        self._exclude_low  = exclude_low
        self._exclude_high = exclude_high


    def float_validate ( self, object, name, value ):
        try:
            if (isinstance( value, RangeTypes ) and
                ((self._low  is None) or
                 (self._exclude_low and (self._low < value)) or
                 ((not self._exclude_low) and (self._low <= value))) and
                ((self._high is None) or
                 (self._exclude_high and (self._high > value)) or
                 ((not self._exclude_high) and (self._high >= value)))):
               return float( value )
        except:
            pass
        self.error( object, name, value )

    def int_validate ( self, object, name, value ):
        try:
            if (isinstance( value, int ) and
                ((self._low  is None) or
                 (self._exclude_low and (self._low < value)) or
                 ((not self._exclude_low) and (self._low <= value))) and
                ((self._high is None) or
                 (self._exclude_high and (self._high > value)) or
                 ((not self._exclude_high) and (self._high >= value)))):
               return value
        except:
            pass
        self.error( object, name, value )

    def long_validate ( self, object, name, value ):
        try:
            if (isinstance( value, long ) and
                ((self._low  is None) or
                 (self._exclude_low and (self._low < value)) or
                 ((not self._exclude_low) and (self._low <= value))) and
                ((self._high is None) or
                 (self._exclude_high and (self._high > value)) or
                 ((not self._exclude_high) and (self._high >= value)))):
               return value
        except:
            pass
        self.error( object, name, value )

    def info ( self ):
        if self._low is None:
            if self._high is None:
                return self._type_desc
            return '%s <%s %s' % (
                   self._type_desc, '='[ self._exclude_high: ], self._high )
        elif self._high is None:
            return  '%s >%s %s' % (
                    self._type_desc, '='[ self._exclude_low: ], self._low )
        return '%s <%s %s <%s %s' % (
               self._low, '='[ self._exclude_low: ], self._type_desc,
               '='[ self._exclude_high: ], self._high )

    def get_editor ( self, trait ):
        from traitsui.api import RangeEditor

        auto_set = trait.auto_set
        if auto_set is None:
            auto_set = True

        return RangeEditor( self,
                            mode       = trait.mode or 'auto',
                            cols       = trait.cols or 3,
                            auto_set   = auto_set,
                            enter_set  = trait.enter_set or False,
                            low_label  = trait.low  or '',
                            high_label = trait.high or '' )

#-------------------------------------------------------------------------------
#  'TraitString' class:
#-------------------------------------------------------------------------------

class TraitString ( TraitHandler ):
    """ Ensures that a trait attribute value is a string that satisfied some
    additional, optional constraints.

    The optional constraints include minimum and maximum lengths, and a regular
    expression that the string must match.

    If the value assigned to the trait attribute is a Python numeric type, the
    TraitString handler first coerces the value to a string. Values of other
    non-string types result in a TraitError being raised. The handler then
    makes sure that the resulting string is within the specified length range
    and that it matches the regular expression.

    Example
    -------

    class Person(HasTraits):
        name = Trait('', TraitString(maxlen=50, regex=r'^[A-Za-z]*$'))


    This example defines a **Person** class with a **name** attribute, which
    must be a string of between 0 and 50 characters that consist of only
    upper and lower case letters.
    """
    def __init__ ( self, minlen = 0, maxlen = sys.maxint, regex = '' ):
        """ Creates a TraitString handler.

        Parameters
        ----------
        minlen : int
            The minimum length allowed for the string.
        maxlen : int
            The maximum length allowed for the string.
        regex : str
            A Python regular expression that the string must match.

        """
        self.minlen = max( 0, minlen )
        self.maxlen = max( self.minlen, maxlen )
        self.regex  = regex
        self._init()

    def _init ( self ):
        if self.regex != '':
            self.match = re.compile( self.regex ).match
            if (self.minlen == 0) and (self.maxlen == sys.maxint):
                self.validate = self.validate_regex
        elif (self.minlen == 0) and (self.maxlen == sys.maxint):
            self.validate = self.validate_str
        else:
            self.validate = self.validate_len

    def validate ( self, object, name, value ):
        try:
            value = strx( value )
            if ((self.minlen <= len( value ) <= self.maxlen) and
                (self.match( value ) is not None)):
                return value
        except:
            pass
        self.error( object, name, value )

    def validate_str ( self, object, name, value ):
        try:
            return strx( value )
        except:
            pass
        self.error( object, name, value )

    def validate_len ( self, object, name, value ):
        try:
            value = strx( value )
            if self.minlen <= len( value ) <= self.maxlen:
                return value
        except:
            pass
        self.error( object, name, value )

    def validate_regex ( self, object, name, value ):
        try:
            value = strx( value )
            if self.match( value ) is not None:
                return value
        except:
            pass
        self.error( object, name, value )

    def info ( self ):
        msg = ''
        if (self.minlen != 0) and (self.maxlen != sys.maxint):
            msg = ' between %d and %d characters long' % (
                  self.minlen, self.maxlen )
        elif self.maxlen != sys.maxint:
            msg = ' <= %d characters long' % self.maxlen
        elif self.minlen != 0:
            msg = ' >= %d characters long' % self.minlen
        if self.regex != '':
            if msg != '':
                msg += ' and'
            msg += (" matching the pattern '%s'" % self.regex)
        return 'a string' + msg

    def __getstate__ ( self ):
        result = self.__dict__.copy()
        for name in [ 'validate', 'match' ]:
            if name in result:
                del result[ name ]
        return result

    def __setstate__ ( self, state ):
        self.__dict__.update( state )
        self._init()

#-------------------------------------------------------------------------------
#  'TraitCoerceType' class:
#-------------------------------------------------------------------------------

class TraitCoerceType ( TraitHandler ):
    """Ensures that a value assigned to a trait attribute is of a specified
    Python type, or can be coerced to the specified type.

    TraitCoerceType is the underlying handler for the predefined traits and
    factories for Python simple types. The TraitCoerceType class is also an
    example of a parametrized type, because the single TraitCoerceType class
    allows creating instances that check for totally different sets of values.
    For example::

        class Person(HasTraits):
            name = Trait('', TraitCoerceType(''))
            weight = Trait(0.0, TraitCoerceType(float))

    In this example, the **name** attribute must be of type ``str`` (string),
    while the **weight** attribute must be of type ``float``, although both are
    based on instances of the TraitCoerceType class. Note that this example is
    essentially the same as writing::

        class Person(HasTraits):
            name = Trait('')
            weight = Trait(0.0)

    This simpler form is automatically changed by the Trait() function into
    the first form, based on TraitCoerceType instances, when the trait
    attributes are defined.

    For attributes based on TraitCoerceType instances, if a value that is
    assigned is not of the type defined for the trait, a TraitError exception
    is raised. However, in certain cases, if the value can be coerced to the
    required type, then the coerced value is assigned to the attribute. Only
    *widening* coercions are allowed, to avoid any possible loss of precision.
    The following table lists the allowed coercions.

    ============ =================
     Trait Type   Coercible Types
    ============ =================
    complex      float, int
    float        int
    long         int
    unicode      str
    ============ =================
    """
    def __init__ ( self, aType ):
        """ Creates a TraitCoerceType handler.

        Parameters
        ----------
        aType : type
            Either a Python type (e.g., ``str`` or types.StringType) or a
            Python value (e.g., 'cat').

        Description
        -----------
        If *aType* is a value, it is mapped to its corresponding type. For
        example, the string 'cat' is automatically mapped to ``str`` (i.e.,
        types.StringType).
        """
        if not isinstance( aType, TypeType ):
            aType = type( aType )
        self.aType = aType
        try:
            self.fast_validate = CoercableTypes[ aType ]
        except:
            self.fast_validate = ( 11, aType )

    def validate ( self, object, name, value ):
        fv = self.fast_validate
        tv = type( value )

        # If the value is already the desired type, then return it:
        if tv is fv[1]:
            return value

        # Else see if it is one of the coercable types:
        for typei in fv[2:]:
            if tv is typei:
                # Return the coerced value:
                return fv[1]( value )

        # Otherwise, raise an exception:
        self.error( object, name, value )

    def info ( self ):
        return 'a value of %s' % str( self.aType )[1:-1]

    def get_editor ( self, trait ):

        # Make the special case of a 'bool' type use the boolean editor:
        if self.aType is bool:
            if self.editor is None:
                from traitsui.api import BooleanEditor

                self.editor = BooleanEditor()

            return self.editor

        # Otherwise, map all other types to a text editor:
        auto_set = trait.auto_set
        if auto_set is None:
            auto_set = True

        from traitsui.api import TextEditor

        return TextEditor( auto_set  = auto_set,
                           enter_set = trait.enter_set or False,
                           evaluate  = self.fast_validate[1] )

#-------------------------------------------------------------------------------
#  'TraitCastType' class:
#-------------------------------------------------------------------------------

class TraitCastType ( TraitCoerceType ):
    """Ensures that a value assigned to a trait attribute is of a specified
    Python type, or can be cast to the specified type.

    This class is similar to TraitCoerceType, but uses casting rather than
    coercion. Values are cast by calling the type with the value to be assigned
    as an argument. When casting is performed, the result of the cast is the
    value assigned to the trait attribute.

    Any trait that uses a TraitCastType instance in its definition ensures that
    its value is of the type associated with the TraitCastType instance. For
    example::

        class Person(HasTraits):
            name = Trait('', TraitCastType(''))
            weight = Trait(0.0, TraitCastType(float))

    In this example, the **name** trait must be of type ``str`` (string), while
    the **weight** trait must be of type ``float``. Note that this example is
    essentially the same as writing::

        class Person(HasTraits):
            name = CStr
            weight = CFloat

    To understand the difference between TraitCoerceType and TraitCastType (and
    also between Float and CFloat), consider the following example::

        >>>class Person(HasTraits):
        ...    weight = Float
        ...    cweight = CFloat
        >>>
        >>>bill = Person()
        >>>bill.weight = 180    # OK, coerced to 180.0
        >>>bill.cweight = 180   # OK, cast to 180.0
        >>>bill.weight = '180'  # Error, invalid coercion
        >>>bill.cweight = '180' # OK, cast to float('180')
    """
    def __init__ ( self, aType ):
        """ Creates a TraitCastType handler.

        Parameters
        ----------
        aType : type
            Either a Python type (e.g., ``str`` or types.StringType) or a
            Python value (e.g., ``'cat``).

        Description
        -----------
        If *aType* is a Python value, it is automatically mapped to its
        corresponding Python type. For example, the string 'cat' is
        automatically mapped to ``str`` (i.e., types.StringType).

        """
        if not isinstance( aType, TypeType ):
            aType = type( aType )
        self.aType = aType
        self.fast_validate = ( 12, aType )

    def validate ( self, object, name, value ):

        # If the value is already the desired type, then return it:
        if type( value ) is self.aType:
            return value

        # Else try to cast it to the specified type:
        try:
            return self.aType( value )
        except:
            self.error( object, name, value )

#-------------------------------------------------------------------------------
#  'ThisClass' class:
#-------------------------------------------------------------------------------

class ThisClass ( TraitHandler ):
    """Ensures that the trait attribute values belong to the same class (or
       a subclass) as the object containing the trait attribute.

       ThisClass is the underlying handler for the predefined traits **This**
       and **self**, and the elements of ListThis.
    """
    def __init__ ( self, allow_none = False ):
        """Creates a ThisClass handler.

        Parameters
        ----------
        allow_none : bool
            Flag indicating whether None is accepted as a valid value
            (True or non-zero) or not (False or 0).
        """
        if allow_none:
            self.validate      = self.validate_none
            self.info          = self.info_none
            self.fast_validate = ( 2, None )
        else:
            self.fast_validate = ( 2, )

    def validate ( self, object, name, value ):
        if isinstance( value, object.__class__ ):
            return value

        self.validate_failed( object, name, value )

    def validate_none ( self, object, name, value ):
        if isinstance( value, object.__class__ ) or (value is None):
            return value

        self.validate_failed( object, name, value )

    def info ( self ):
        return 'an instance of the same type as the receiver'

    def info_none ( self ):
        return 'an instance of the same type as the receiver or None'

    def validate_failed ( self, object, name, value ):
        self.error( object, name, value )

    def get_editor ( self, trait ):
        if self.editor is None:
            from traitsui.api import InstanceEditor

            self.editor = InstanceEditor( label = trait.label or '',
                                          view  = trait.view  or '',
                                          kind  = trait.kind  or 'live' )
        return self.editor

#-------------------------------------------------------------------------------
#  'TraitInstance' class:
#-------------------------------------------------------------------------------

# Mapping from 'adapt' parameter values to 'fast validate' values
AdaptMap = {
   'no':     -1,
   'yes':     0,
   'default': 1
}

class TraitInstance ( ThisClass ):
    """Ensures that trait attribute values belong to a specified Python class
    or type.

    TraitInstance is the underlying handler for the predefined trait
    **Instance** and the elements of List( Instance ).

    Any trait that uses a TraitInstance handler ensures that its values belong
    to the specified type or class (or one of its subclasses). For example::

        class Employee(HasTraits):
            manager = Trait(None, TraitInstance(Employee, True))

    This example defines a class Employee, which has a **manager** trait
    attribute, which accepts either None or an instance of Employee
    as its value.

    TraitInstance ensures that assigned values are exactly of the type specified
    (i.e., no coercion is performed).
    """
    def __init__ ( self, aClass, allow_none = True, adapt = 'no',
                   module = '' ):
        """Creates a TraitInstance handler.

        Parameters
        ----------
        aClass : class or type
            A Python class, an instance of a Python class, or a Python type.
        allow_none : bool
            Flag indicating whether None is accepted as a valid value.
            (True or non-zero) or not (False or 0)
        adapt : str
            Value indicating how adaptation should be handled:

            - 'no' (-1): Adaptation is not allowed.
            - 'yes' (0): Adaptation is allowed and should raise an exception if
              adaptation fails.
            - 'default' (1): Adaption is allowed and should return the default
              value if adaptation fails.
        module : module
            The module that the class belongs to.

        Description
        -----------
        If *aClass* is an instance, it is mapped to the class it is an instance
        of.
        """
        self._allow_none = allow_none
        self.adapt       = AdaptMap[ adapt ]
        self.module      = module
        if isinstance( aClass, basestring ):
            self.aClass = aClass
        else:
            if not isinstance( aClass, ClassTypes ):
                aClass = aClass.__class__
            self.aClass = aClass
            self.set_fast_validate()

    def allow_none ( self ):
        self._allow_none = True
        if hasattr( self, 'fast_validate' ):
            self.set_fast_validate()

    def set_fast_validate ( self ):
        if self.adapt < 0:
            fast_validate = [ 1, self.aClass ]
            if self._allow_none:
                fast_validate = [ 1, None, self.aClass ]
            if self.aClass in TypeTypes:
                fast_validate[0] = 0
            self.fast_validate = tuple( fast_validate )
        else:
            self.fast_validate = ( 19, self.aClass, self.adapt,
                                   self._allow_none )

    def validate ( self, object, name, value ):

        from traits.adaptation.api import adapt

        if value is None:
            if self._allow_none:
                return value
            else:
                self.validate_failed( object, name, value )

        if isinstance( self.aClass, basestring ):
            self.resolve_class( object, name, value )

        if self.adapt < 0:
            if isinstance( value, self.aClass ):
                return value
        elif self.adapt == 0:
            try:
                return adapt( value, self.aClass )
            except:
                pass
        else:
            # fixme: The 'None' value is not really correct. It should return
            # the default value for the trait, but the handler does not have
            # any way to know this currently. Since the 'fast validate' code
            # does the correct thing, this should not normally be a problem.
            return adapt( value, self.aClass, None )

        self.validate_failed( object, name, value )

    def info ( self ):
        aClass = self.aClass
        if type( aClass ) is not str:
            aClass = aClass.__name__

        if self.adapt < 0:
            result = class_of( aClass )
        else:
            result = ('an implementor of, or can be adapted to implement, %s' %
                      aClass)

        if self._allow_none:
            return result + ' or None'

        return result

    def resolve_class ( self, object, name, value ):
        aClass = self.validate_class( self.find_class( self.aClass ) )
        if aClass is None:
            self.validate_failed( object, name, value )
        self.aClass = aClass

        # fixme: The following is quite ugly, because it wants to try and fix
        # the trait referencing this handler to use the 'fast path' now that the
        # actual class has been resolved. The problem is finding the trait,
        # especially in the case of List(Instance('foo')), where the
        # object.base_trait(...) value is the List trait, not the Instance
        # trait, so we need to check for this and pull out the List
        # 'item_trait'. Obviously this does not extend well to other traits
        # containing nested trait references (Dict?)...
        self.set_fast_validate()
        trait   = object.base_trait( name )
        handler = trait.handler
        if (handler is not self) and hasattr( handler, 'item_trait' ):
            trait = handler.item_trait
        trait.set_validate( self.fast_validate )

    def find_class ( self, aClass ):
        module = self.module
        col    = aClass.rfind( '.' )
        if col >= 0:
            module = aClass[ : col ]
            aClass = aClass[ col + 1: ]

        theClass = getattr( sys.modules.get( module ), aClass, None )
        if (theClass is None) and (col >= 0):
            try:
                mod = __import__( module , globals=globals(), level=1)
                for component in module.split( '.' )[1:]:
                    mod = getattr( mod, component )
                theClass = getattr( mod, aClass, None )
            except:
                pass

        return theClass

    def validate_class ( self, aClass ):
        return aClass

    def create_default_value ( self, *args, **kw ):
        aClass = args[0]
        if isinstance( aClass, basestring ):
            aClass = self.validate_class( self.find_class( aClass ) )
            if aClass is None:
                raise TraitError, 'Unable to locate class: ' + args[0]

        return aClass( *args[1:], **kw )

#-------------------------------------------------------------------------------
#  'TraitWeakRef' class:
#-------------------------------------------------------------------------------

class TraitWeakRef ( TraitInstance ):

    def _get ( self, object, name ):
        value = getattr( object, name + '_', None )
        if value is not None:
            return value.value()
        return None

    def _set ( self, object, name, value ):
        if value is not None:
            value = HandleWeakRef( object, name, value )
        object.__dict__[ name + '_' ] = value

    def resolve_class ( self, object, name, value ):
        # fixme: We have to override this method to prevent the 'fast validate'
        # from being set up, since the trait using this is a 'property' style
        # trait which is not currently compatible with the 'fast_validate'
        # style (causes internal Python SystemError messages).
        aClass = self.find_class( self.aClass )
        if aClass is None:
            self.validate_failed( object, name, value )
        self.aClass = aClass



#-- Private Class --------------------------------------------------------------

def _make_value_freed_callback ( object_ref, name ):
    def _value_freed ( value_ref ):
        object = object_ref()
        if object is not None:
            object.trait_property_changed( name, Undefined, None )
    return _value_freed


class HandleWeakRef ( object ):

    def __init__ ( self, object, name, value ):
        object_ref = ref( object )
        _value_freed = _make_value_freed_callback( object_ref, name )
        self.object = object_ref
        self.name = name
        self.value = ref( value, _value_freed )


#-------------------------------------------------------------------------------
#  'TraitClass' class:
#-------------------------------------------------------------------------------

class TraitClass ( TraitHandler ):
    """Ensures that trait attribute values are subclasses of a specified class
    (or the class itself).

    A value is valid if it is a subclass of the specified class (including the
    class itself), or it is a string that is equivalent to the name of a valid
    class.
    """
    def __init__ ( self, aClass ):
        """Creates a TraitClass handler.

        Parameters
        ----------
        aClass : class
            A Python class.

        Description
        -----------
        If *aClass* is an instance, it is mapped to the class it is an instance
        of.
        """
        if _py2to3.is_old_style_instance(aClass):
            aClass = aClass.__class__
        self.aClass = aClass

    def validate ( self, object, name, value ):
        try:
            if isinstance( value, basestring ):
                value = value.strip()
                col   = value.rfind( '.' )
                if col >= 0:
                    module_name = value[:col]
                    class_name  = value[col + 1:]
                    module      = sys.modules.get( module_name )
                    if module is None:
                        exec( 'import ' + module_name )
                        module = sys.modules[ module_name ]
                    value = getattr( module, class_name )
                else:
                    value = globals().get( value )

            if issubclass( value, self.aClass ):
                return value
        except:
            pass

        self.error( object, name, value )

    def info ( self ):
        return 'a subclass of ' + self.aClass.__name__

#-------------------------------------------------------------------------------
#  'TraitFunction' class:
#-------------------------------------------------------------------------------

class TraitFunction ( TraitHandler ):
    """Ensures that assigned trait attribute values are acceptable to a
    specified validator function.

    TraitFunction is the underlying handler for the predefined trait
    **Function**, and for the use of function references as arguments to the
    Trait() function.
    """
    def __init__ ( self, aFunc ):
        """ Creates a TraitFunction handler.

        Parameters
        ----------
        aFunc : function
            A function to validate trait attribute values.

        Description
        -----------
        The signature of the function passed as an argument must be of the
        form *function* ( *object*, *name*, *value* ). The function must
        verify that *value* is a legal value for the *name* trait attribute
        of *object*. If it is, the value returned by the function is the
        actual value assigned to the trait attribute. If it is not, the
        function must raise a TraitError exception.
        """
        if not isinstance( aFunc, CallableTypes ):
            raise TraitError, "Argument must be callable."
        self.aFunc = aFunc
        self.fast_validate = ( 13, aFunc )

    def validate ( self, object, name, value ):
        try:
            return self.aFunc( object, name, value )
        except TraitError:
            self.error( object, name, value )

    def info ( self ):
        try:
            return self.aFunc.info
        except:
            if self.aFunc.__doc__:
                return self.aFunc.__doc__
            return 'a legal value'

#-------------------------------------------------------------------------------
#  'TraitEnum' class:
#-------------------------------------------------------------------------------

class TraitEnum ( TraitHandler ):
    """ Ensures that a value assigned to a trait attribute is a member of a
    specified list of values.

    TraitEnum is the underlying handler for the forms of the Trait() function
    that take a list of possible values
    """
    def __init__ ( self, *values ):
        """ Creates a TraitEnum handler.

        Parameters
        ----------
        values : list or tuple
            Enumeration of all legal values for a trait.

        Description
        -----------
        The list of legal values can be provided as a list of values. That is,
        ``TraitEnum([1, 2, 3])`` and ``TraitEnum(1, 2, 3)`` are equivalent. For
        example::

            class Flower(HasTraits):
                color = Trait('white', TraitEnum(['white', 'yellow', 'red']))
                kind  = Trait('annual', TraitEnum('annual', 'perennial'))

        This example defines a Flower class, which has a **color** trait
        attribute, which can have as its value, one of the three strings,
        'white', 'yellow', or 'red', and a **kind** trait attribute, which can
        have as its value, either of the strings 'annual' or 'perennial'. This
        is equivalent to the following class definition::

            class Flower(HasTraits):
                color = Trait(['white', 'yellow', 'red'])
                kind  = Trait('annual', 'perennial')

        The Trait() function automatically maps traits of the form shown in
        this example to the form shown in the preceding example whenever it
        encounters them in a trait definition.
        """
        if (len( values ) == 1) and (type( values[0] ) in SequenceTypes):
            values = values[0]
        self.values        = tuple( values )
        self.fast_validate = ( 5, self.values )

    def validate ( self, object, name, value ):
        if value in self.values:
            return value
        self.error( object, name, value )

    def info ( self ):
        return ' or '.join( [ repr( x ) for x in self.values ] )

    def get_editor ( self, trait ):
        from traitsui.api import EnumEditor

        return EnumEditor( values   = self,
                           cols     = trait.cols or 3,
                           evaluate = trait.evaluate,
                           mode     = trait.mode or 'radio' )

#-------------------------------------------------------------------------------
#  'TraitPrefixList' class:
#-------------------------------------------------------------------------------

class TraitPrefixList ( TraitHandler ):
    """Ensures that a value assigned to a trait attribute is a member of a list
    of specified string values, or is a unique prefix of one of those values.

    TraitPrefixList is a variation on TraitEnum. The values that can be
    assigned to a trait attribute defined using a TraitPrefixList handler is the
    set of all strings supplied to the TraitPrefixList constructor, as well as
    any unique prefix of those strings. That is, if the set of strings supplied
    to the constructor is described by [*s*\ :sub:`1`\ , *s*\ :sub:`2`\ , ...,
    *s*\ :sub:`n`\ ], then the string *v* is a valid value for the trait if
    *v* == *s*\ :sub:`i[:j]` for one and only one pair of values (i, j). If *v*
    is a valid value, then the actual value assigned to the trait attribute is
    the corresponding *s*\ :sub:`i` value that *v* matched.

    Example
    -------

    class Person(HasTraits):
        married = Trait('no', TraitPrefixList('yes', 'no')

    The Person class has a **married** trait that accepts any of the
    strings 'y', 'ye', 'yes', 'n', or 'no' as valid values. However, the actual
    values assigned as the value of the trait attribute are limited to either
    'yes' or 'no'. That is, if the value 'y' is assigned to the **married**
    attribute, the actual value assigned will be 'yes'.

    Note that the algorithm used by TraitPrefixList in determining whether a
    string is a valid value is fairly efficient in terms of both time and space,
    and is not based on a brute force set of comparisons.

    """
    def __init__ ( self, *values ):
        """ Creates a TraitPrefixList handler.

        Parameters
        ----------
        values : list or tuple of strings
            Enumeration of all legal values for a trait.

        Description
        -----------
        As with TraitEnum, the list of legal values can be provided as a list
        of values.  That is, ``TraitPrefixList(['one', 'two', 'three'])`` and
        ``TraitPrefixList('one', 'two', 'three')`` are equivalent.
        """
        if (len( values ) == 1) and (type( values[0] ) in SequenceTypes):
            values = values[0]
        self.values  = values[:]
        self.values_ = values_ = {}
        for key in values:
            values_[ key ] = key
        self.fast_validate = ( 10, values_, self.validate )

    def validate ( self, object, name, value ):
        try:
            if value not in self.values_:
                match = None
                n     = len( value )
                for key in self.values:
                    if value == key[:n]:
                        if match is not None:
                           match = None
                           break
                        match = key
                if match is None:
                    self.error( object, name, value )
                self.values_[ value ] = match
            return self.values_[ value ]
        except:
            self.error( object, name, value )

    def info ( self ):
        return (' or '.join( [ repr( x ) for x in self.values ] ) +
                ' (or any unique prefix)')

    def get_editor ( self, trait ):
        from traitsui.api import EnumEditor

        return EnumEditor( values = self,
                           cols   = trait.cols or 3  )

    def __getstate__ ( self ):
        result = self.__dict__.copy()
        if 'fast_validate' in result:
            del result[ 'fast_validate' ]

        return result

#-------------------------------------------------------------------------------
#  'TraitMap' class:
#-------------------------------------------------------------------------------

class TraitMap ( TraitHandler ):
    """Checks that the value assigned to a trait attribute is a key of a
    specified dictionary, and also assigns the dictionary value corresponding
    to that key to a *shadow* attribute.

    A trait attribute that uses a TraitMap handler is called *mapped* trait
    attribute. In practice, this means that the resulting object actually
    contains two attributes: one whose value is a key of the TraitMap
    dictionary, and the other whose value is the corresponding value of the
    TraitMap dictionary. The name of the shadow attribute is simply the base
    attribute name with an underscore ('_') appended. Mapped trait attributes
    can be used to allow a variety of user-friendly input values to be mapped to
    a set of internal, program-friendly values.

    Example
    -------

        >>>class Person(HasTraits):
        ...    married = Trait('yes', TraitMap({'yes': 1, 'no': 0 })
        >>>
        >>>bob = Person()
        >>>print bob.married
        yes
        >>>print bob.married_
        1

    In this example, the default value of the **married** attribute of the
    Person class is 'yes'. Because this attribute is defined using
    TraitPrefixList, instances of Person have another attribute,
    **married_**, whose default value is 1, the dictionary value corresponding
    to the key 'yes'.
    """
    is_mapped = True

    def __init__ ( self, map ):
        """ Creates a TraitMap handler.

        Parameters
        ----------
        map : dict
            A dictionary whose keys are valid values for the trait attribute,
            and whose corresponding values are the values for the shadow
            trait attribute.
        """
        self.map = map
        self.fast_validate = ( 6, map )

    def validate ( self, object, name, value ):
        try:
            if value in self.map:
                return value
        except:
            pass

        self.error( object, name, value )

    def mapped_value ( self, value ):
        return self.map[ value ]

    def post_setattr ( self, object, name, value ):
        try:
            setattr( object, name + '_', self.mapped_value( value ) )
        except:
            # We don't need a fancy error message, because this exception
            # should always be caught by a TraitCompound handler:
            raise TraitError, 'Unmappable'

    def info ( self ):
        keys = [ repr( x ) for x in self.map.keys() ]
        keys.sort()

        return ' or '.join( keys )

    def get_editor ( self, trait ):
        from traitsui.api import EnumEditor

        return EnumEditor( values = self,
                           cols   = trait.cols or 3  )

#-------------------------------------------------------------------------------
#  'TraitPrefixMap' class:
#-------------------------------------------------------------------------------

class TraitPrefixMap ( TraitMap ):
    """A cross between the TraitPrefixList and TraitMap classes.

    Like TraitMap, TraitPrefixMap is created using a dictionary, but in this
    case, the keys of the dictionary must be strings. Like TraitPrefixList,
    a string *v* is a valid value for the trait attribute if it is a prefix of
    one and only one key *k* in the dictionary. The actual values assigned to
    the trait attribute is *k*, and its corresponding mapped attribute is
    *map*[*k*].

    Example
    -------

        mapping = {'true': 1, 'yes': 1, 'false': 0, 'no': 0 }
        boolean_map = Trait('true', TraitPrefixMap(mapping))

    This example defines a Boolean trait that accepts any prefix of 'true',
    'yes', 'false', or 'no', and maps them to 1 or 0.
    """
    def __init__ ( self, map ):
        """Creates a TraitPrefixMap handler.

        Parameters
        ----------
        map : dict
            A dictionary whose keys are strings that are valid values for the
            trait attribute, and whose corresponding values are the values for
            the shadow trait attribute.
        """
        self.map  = map
        self._map = _map = {}
        for key in map.keys():
            _map[ key ] = key
        self.fast_validate = ( 10, _map, self.validate )

    def validate ( self, object, name, value ):
        try:
            if value not in self._map:
                match = None
                n     = len( value )
                for key in self.map.keys():
                    if value == key[:n]:
                        if match is not None:
                           match = None
                           break
                        match = key
                if match is None:
                    self.error( object, name, value )
                self._map[ value ] = match
            return self._map[ value ]
        except:
            self.error( object, name, value )

    def info ( self ):
        return super( TraitPrefixMap, self ).info() + ' (or any unique prefix)'

#-------------------------------------------------------------------------------
#  'TraitExpression' class:
#-------------------------------------------------------------------------------

class TraitExpression ( TraitHandler ):
    """ Ensures that a value assigned to a trait attribute is a valid Python
        expression. The compiled form of a valid expression is stored as the
        mapped value of the trait.
    """

    is_mapped = True

    def validate ( self, object, name, value ):
        try:
            compile( value, '<string>', 'eval' )
            return value
        except:
            self.error( object, name, value )

    def post_setattr ( self, object, name, value ):
        object.__dict__[ name + '_' ] = self.mapped_value( value )

    def info ( self ):
        return 'a valid Python expression'

    def mapped_value ( self, value ):
        return compile( value, '<string>', 'eval' )

#-------------------------------------------------------------------------------
#  'TraitCompound' class:
#-------------------------------------------------------------------------------

class TraitCompound ( TraitHandler ):
    """ Provides a logical-OR combination of other trait handlers.

    This class provides a means of creating complex trait definitions by
    combining several simpler trait definitions. TraitCompound is the underlying
    handler for the general forms of the Trait() function.

    A value is a valid value for a trait attribute based on a TraitCompound
    instance if the value is valid for at least one of the TraitHandler or
    trait objects supplied to the constructor. In addition, if at least one of
    the TraitHandler or trait objects is mapped (e.g., based on a TraitMap or
    TraitPrefixMap instance), then the TraitCompound is also mapped. In this
    case, any non-mapped traits or trait handlers use identity mapping.

    """
    def __init__ ( self, *handlers ):
        """ Creates a TraitCompound handler.

        Parameters
        ----------
        *handlers :
            list or tuple of TraitHandler or trait objects to be combined.

        """
        if (len( handlers ) == 1) and (type( handlers[0] ) in SequenceTypes):
            handlers = handlers[0]
        self.handlers = handlers
        self.set_validate()

    def set_validate ( self ):
        self.is_mapped  = False
        self.has_items  = False
        self.reversable = True
        post_setattrs   = []
        mapped_handlers = []
        validates       = []
        fast_validates  = []
        slow_validates  = []

        for handler in self.handlers:
            fv = getattr( handler, 'fast_validate', None )
            if fv is not None:
                validates.append( handler.validate )
                if fv[0] == 7:
                    # If this is a nested complex fast validator, expand its
                    # contents and adds its list to our list:
                    fast_validates.extend( fv[1] )
                else:
                    # Else just add the entire validator to the list:
                    fast_validates.append( fv )
            else:
                slow_validates.append( handler.validate )

            post_setattr = getattr( handler, 'post_setattr', None )
            if post_setattr is not None:
                post_setattrs.append( post_setattr )

            if handler.is_mapped:
                self.is_mapped = True
                mapped_handlers.append( handler )
            else:
                self.reversable = False

            if handler.has_items:
                self.has_items = True

        self.validates      = validates
        self.slow_validates = slow_validates

        if self.is_mapped:
            self.mapped_handlers = mapped_handlers
        elif hasattr( self, 'mapped_handlers' ):
            del self.mapped_handlers

        # If there are any fast validators, then we create a 'complex' fast
        # validator that composites them:
        if len( fast_validates ) > 0:
            # If there are any 'slow' validators, add a special handler at
            # the end of the fast validator list to handle them:
            if len( slow_validates ) > 0:
                fast_validates.append( ( 8, self ) )
            # Create the 'complex' fast validator:
            self.fast_validate = ( 7, tuple( fast_validates ) )
        elif hasattr( self, 'fast_validate' ):
            del self.fast_validate

        if len( post_setattrs ) > 0:
            self.post_setattrs = post_setattrs
            self.post_setattr  = self._post_setattr
        elif hasattr( self, 'post_setattr' ):
            del self.post_setattr

    def validate ( self, object, name, value ):
        for validate in self.validates:
            try:
               return validate( object, name, value )
            except TraitError:
               pass
        return self.slow_validate( object, name, value )

    def slow_validate ( self, object, name, value ):
        for validate in self.slow_validates:
            try:
               return validate( object, name, value )
            except TraitError:
               pass
        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        return ' or '.join( [ x.full_info( object, name, value )
                              for x in self.handlers ] )

    def info ( self ):
        return ' or '.join( [ x.info() for x in self.handlers ] )

    def mapped_value ( self, value ):
        for handler in self.mapped_handlers:
            try:
                return handler.mapped_value( value )
            except:
                pass
        return value

    def _post_setattr ( self, object, name, value ):
        for post_setattr in self.post_setattrs:
            try:
                post_setattr( object, name, value )
                return
            except TraitError:
               pass
        setattr( object, name + '_', value )

    def get_editor ( self, trait ):
        from traitsui.api import TextEditor, CompoundEditor

        the_editors = [ x.get_editor( trait ) for x in self.handlers ]
        text_editor = TextEditor()
        count       = 0
        editors     = []
        for editor in the_editors:
            if isinstance( text_editor, editor.__class__ ):
                count += 1
                if count > 1:
                    continue
            editors.append( editor )

        return CompoundEditor( editors = editors )

    def items_event ( self ):
        return items_event()

#-------------------------------------------------------------------------------
#  'TraitTuple' class:
#-------------------------------------------------------------------------------

class TraitTuple ( TraitHandler ):
    """ Ensures that values assigned to a trait attribute are tuples of a
    specified length, with elements that are of specified types.

    TraitTuple is the underlying handler for the predefined trait **Tuple**,
    and the trait factory Tuple().

    Example
    -------

        rank = Range(1, 13)
        suit = Trait('Hearts', 'Diamonds', 'Spades', 'Clubs')
        class Card(HasTraits):
            value = Trait(TraitTuple(rank, suit))

    This example defines a Card class, which has a **value** trait attribute,
    which must be a tuple of two elments. The first element must be an integer
    in the range from 1 to 13, and the second element must be one of the four
    strings, 'Hearts', 'Diamonds', 'Spades', or 'Clubs'.
    """
    def __init__ ( self, *args ):
        """ Creates a TraitTuple handler.

        Parameters
        ----------
        *args :
            A list of traits, each *trait*\ :sub:`i` specifies the type that
            the *i*\ th element of a tuple must be.

        Description
        -----------
        Each *trait*\ :sub:`i` must be either a trait, or a value that can be
        converted to a trait using the Trait() function. The resulting
        trait handler accepts values that are tuples of the same length as
        *args*, and whose *i*\ th element is of the type specified by
        *trait*\ :sub:`i`.
        """
        self.types = tuple( [ trait_from( arg ) for arg in args ] )
        self.fast_validate = ( 9, self.types )

    def validate ( self, object, name, value ):
        try:
            if isinstance( value, tuple ):
                types = self.types
                if len( value ) == len( types ):
                    values = []
                    for i, type in enumerate( types ):
                        values.append( type.handler.validate( object, name,
                                                              value[i] ) )
                    return tuple( values )
        except:
            pass

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        return 'a tuple of the form: (%s)' % (', '.join(
               [ self._trait_info( type, object, name, value )
                 for type in self.types ] ))

    def _trait_info ( self, type, object, name, value ):
        handler = type.handler
        if handler is None:
            return 'any value'

        return handler.full_info( object, name, value )

    def get_editor ( self, trait ):
        from traitsui.api import TupleEditor

        return TupleEditor( types  = self.types,
                            labels = trait.labels or [],
                            cols   = trait.cols   or 1  )

#-------------------------------------------------------------------------------
#  'TraitCallable' class:
#-------------------------------------------------------------------------------

class TraitCallable ( TraitHandler ):
    """Ensures that the value of a trait attribute is a callable Python object
    (usually a function or method).
    """
    def validate ( self, object, name, value ):
        if (value is None) or callable( value ):
            return value
        self.error( object, name, value )

    def info ( self ):
        return 'a callable value'

#-------------------------------------------------------------------------------
#  'TraitListEvent' class:
#-------------------------------------------------------------------------------

class TraitListEvent ( object ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, index = 0, removed = None, added = None ):
        self.index = index

        if removed is None:
            removed = []
        self.removed = removed

        if added is None:
            added = []
        self.added = added


#-------------------------------------------------------------------------------
#  'TraitList' class:
#-------------------------------------------------------------------------------

class TraitList ( TraitHandler ):
    """ Ensures that a value assigned to a trait attribute is a list containing
    elements of a specified type, and that the length of the list is also
    within a specified range.

    TraitList also makes sure that any changes made to the list after it is
    assigned to the trait attribute do not violate the list's type and length
    constraints. TraitList is the underlying handler for the predefined
    list-based traits.

    Example
    -------

    class Card(HasTraits):
        pass
    class Hand(HasTraits):
        cards = Trait([], TraitList(Trait(Card), maxlen=52))


    This example defines a Hand class, which has a **cards** trait attribute,
    which is a list of Card objects and can have from 0 to 52 items in the
    list.
    """
    info_trait         = None
    default_value_type = 5
    _items_event       = None

    def __init__ ( self, trait = None, minlen = 0, maxlen = sys.maxint,
                         has_items = True ):
        """ Creates a TraitList handler.

        Parameters
        ----------
        trait : Trait
            The type of items the list can contain.
        minlen : int
            The minimum length of the list.
        maxlen : int
            The maximum length of the list.
        has_items : bool
            Flag indicating whether the list contains elements.

        Description
        -----------
        If *trait* is None or omitted, then no type checking is performed
        on any items in the list; otherwise, *trait* must be either a trait, or
        a value that can be converted to a trait using the Trait() function.

        """
        self.item_trait = trait_from( trait )
        self.minlen     = max( 0, minlen )
        self.maxlen     = max( minlen, maxlen )
        self.has_items  = has_items

    def clone ( self ):
        return TraitList( self.item_trait, self.minlen, self.maxlen,
                          self.has_items )

    def validate ( self, object, name, value ):
        if (isinstance( value, list ) and
           (self.minlen <= len( value ) <= self.maxlen)):
            return TraitListObject( self, object, name, value )

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        if self.minlen == 0:
            if self.maxlen == sys.maxint:
                size = 'items'
            else:
                size = 'at most %d items' % self.maxlen
        else:
            if self.maxlen == sys.maxint:
                size = 'at least %d items' % self.minlen
            else:
                size = 'from %s to %s items' % (
                       self.minlen, self.maxlen )
        handler = self.item_trait.handler
        if handler is None:
            info = ''
        else:
            info = ' which are %s' % handler.full_info( object, name, value )

        return 'a list of %s%s' % ( size, info )

    def get_editor ( self, trait ):
        handler = self.item_trait.handler
        if isinstance( handler, TraitInstance ) and (trait.mode != 'list'):
            from .api import HasTraits

            if issubclass( handler.aClass, HasTraits ):
                try:
                    object = handler.aClass()
                    from traitsui.table_column import ObjectColumn
                    from traitsui.table_filter import (EvalFilterTemplate,
                        RuleFilterTemplate, MenuFilterTemplate, EvalTableFilter)
                    from traitsui.api import TableEditor

                    return TableEditor(
                            columns = [ ObjectColumn( name = name )
                                        for name in object.editable_traits() ],
                            filters     = [ RuleFilterTemplate,
                                            MenuFilterTemplate,
                                            EvalFilterTemplate ],
                            edit_view   = '',
                            orientation = 'vertical',
                            search      = EvalTableFilter(),
                            deletable   = True,
                            row_factory = handler.aClass )
                except:
                    pass

        from traitsui.api import ListEditor

        return ListEditor( trait_handler = self,
                           rows          = trait.rows or 5,
                           use_notebook  = trait.use_notebook is True,
                           page_name     = trait.page_name or '' )

    def items_event ( self ):
        return items_event()

def items_event ( ):
    if TraitList._items_event is None:
        TraitList._items_event = \
            Event( TraitListEvent, is_base = False ).as_ctrait()

    return TraitList._items_event

#-------------------------------------------------------------------------------
#  'TraitListObject' class:
#-------------------------------------------------------------------------------

class TraitListObject ( list ):

    def __init__ ( self, trait, object, name, value ):
        self.trait      = trait
        self.object     = ref( object )
        self.name       = name
        self.name_items = None
        if trait.has_items:
            self.name_items = name + '_items'

        # Do the validated 'setslice' assignment without raising an
        # 'items_changed' event:
        if trait.minlen <= len( value ) <= trait.maxlen:
            try:
                validate = trait.item_trait.handler.validate
                if validate is not None:
                    value = [ validate( object, name, val ) for val in value ]

                list.__setitem__(self, slice(0, 0), value )

                return

            except TraitError, excp:
                excp.set_prefix( 'Each element of the' )
                raise excp

        self.len_error( len( value ) )

    def _send_trait_items_event(self, name, event, items_event=None):
        """ Send a TraitListEvent to the owning object if there is one.
        """
        object = self.object()
        if object is not None:
            if items_event is None and hasattr(self, 'trait'):
                items_event = self.trait.items_event()
            object.trait_items_event(name, event, items_event)

    def __deepcopy__ ( self, memo ):
        id_self = id( self )
        if id_self in memo:
            return memo[ id_self ]

        memo[ id_self ] = result = TraitListObject( self.trait, lambda: None,
                         self.name, [ copy.deepcopy( x, memo ) for x in self ] )

        return result

    def __setitem__ ( self, key, value ):
        self_trait = getattr(self, 'trait', None)
        if self_trait is None:
            return list.__setitem__(self, key, value)
        try:
            removed = self[ key ]
        except:
            removed = []
        try:
            object   = self.object()
            validate = self.trait.item_trait.handler.validate
            name     = self.name

            if isinstance(key, slice):
                values = value
                try:
                    key = slice(*key.indices(len( self )))
                except (ValueError, TypeError):
                    raise TypeError('must assign sequence (not "%s") to slice' % (
                                    values.__class__.__name__ ))
                slice_len = max(0, (key.stop - key.start) // key.step)
                delta = len( values ) - slice_len
                if key.step != 1 and delta != 0:
                    raise ValueError(
                        'attempt to assign sequence of size %d to extended slice of size %d' % (
                        len( values ), slice_len
                    ))
                newlen = (len(self) + delta)
                if not (self_trait.minlen <= newlen <= self_trait.maxlen):
                    self.len_error( newlen )
                    return

                if validate is not None:
                    values = [ validate( object, name, value )
                               for value in values ]
                value = values
                if key.step == 1:
                    # FIXME: Bug-for-bug compatibility with old __setslice__ code.
                    # In this case, we return a TraitListEvent with an
                    # index=key.start and the removed and added lists as they
                    # are.
                    index = key.start
                else:
                    # Otherwise, we have an extended slice which was handled,
                    # badly, by __setitem__ before. In this case, we return the
                    # removed and added lists wrapped in another list.
                    index = key
                    values = [values]
                    removed = [removed]
            else:
                if validate is not None:
                    value = validate( object, name, value )

                values = [ value ]
                removed = [ removed ]
                delta = 0

                index = len( self ) + key if key < 0 else key

            list.__setitem__( self, key, value )
            if self.name_items is not None:
                if delta == 0:
                    try:
                        if removed == values:
                            return
                    except:
                        # Treat incomparable values as equal:
                        pass
                self._send_trait_items_event( self.name_items,
                    TraitListEvent( index, removed, values ) )

        except TraitError, excp:
            excp.set_prefix( 'Each element of the' )
            raise excp

    if sys.version_info[0] < 3:
        def __setslice__ ( self, i, j, values ):
            self.__setitem__(slice(i,j), values)

    def __delitem__ ( self, key ):
        trait = getattr(self, 'trait', None)
        if trait is None:
            return list.__delitem__(self, key)

        try:
            removed = self[ key ]
        except:
            removed = []

        if isinstance(key,slice):
            key = slice(*key.indices(len( self )))
            slice_len = max(0, (key.stop - key.start) // key.step)
            delta = slice_len
            if key.step == 1:
                # FIXME: See corresponding comment in __setitem__() for
                # explanation.
                index = key.start
            else:
                index = key
                removed = [removed]
        else:
            delta = 1
            index = len( self ) + key + 1 if key < 0 else key
            removed = [ removed ]

        if not (trait.minlen <= (len( self ) - delta)):
            self.len_error( len( self ) - delta)
            return

        list.__delitem__( self, key )

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitListEvent( index, removed ) )

    if sys.version_info[0] < 3:
        def __delslice__ ( self, i, j ):
            self.__delitem__(slice(i,j))

    def __iadd__(self, other):
        self.extend(other)
        return self

    def __imul__(self, count):
        trait = getattr( self, 'trait', None )
        if trait is None:
            return list.__imul__( self, count )

        original_len = len( self )

        if trait.minlen <= original_len * count <= trait.maxlen:
            if self.name_items is not None:
                removed = None if count else self[:]

            result = list.__imul__(self, count)

            if self.name_items is not None:
                added = self[original_len:] if count else None
                index = original_len if count else 0
                self._send_trait_items_event( self.name_items,
                    TraitListEvent( index, removed, added ) )

            return result
        else:
            self.len_error( original_len * count )


    def append ( self, value ):
        trait = getattr( self, 'trait', None )
        if trait is None:
            list.append( self, value )
            return

        if trait.minlen <= (len( self ) + 1) <= trait.maxlen:
            try:
                validate = trait.item_trait.handler.validate
                object   = self.object()
                if validate is not None:
                    value = validate( object, self.name, value )
                list.append( self, value )
                if self.name_items is not None:
                    self._send_trait_items_event( self.name_items,
                        TraitListEvent( len( self ) - 1, None, [ value ] ),
                        trait.items_event() )
                return

            except TraitError, excp:
                excp.set_prefix( 'Each element of the' )
                raise excp

        self.len_error( len( self ) + 1 )

    def insert ( self, index, value ):
        trait = getattr( self, 'trait', None )
        if trait is None:
            return list.insert(self, index, value)
        if trait.minlen <= (len( self ) + 1) <= trait.maxlen:
            try:
                validate = trait.item_trait.handler.validate
                object   = self.object()
                if validate is not None:
                    value = validate( object, self.name, value )

                list.insert( self, index, value )

                if self.name_items is not None:
                    # Length before the insertion.
                    original_len = len( self ) - 1

                    # Indices outside [-original_len, original_len] are clipped.
                    # This matches the behaviour of insert on the
                    # underlying list.
                    if index < 0:
                        index += original_len
                        if index < 0:
                            index = 0
                    elif index > original_len:
                        index = original_len

                    self._send_trait_items_event( self.name_items,
                        TraitListEvent( index, None, [ value ] ),
                        trait.items_event() )

                return

            except TraitError, excp:
                excp.set_prefix( 'Each element of the' )
                raise excp

        self.len_error( len( self ) + 1 )

    def extend ( self, xlist ):
        trait = getattr( self, 'trait', None )
        if trait is None:
            list.extend( self, xlist )

            return

        try:
            len_xlist = len( xlist )
        except:
            raise TypeError, "list.extend() argument must be iterable"

        if (trait.minlen <= (len( self ) + len_xlist) <= trait.maxlen):
            object   = self.object()
            name     = self.name
            validate = trait.item_trait.handler.validate
            try:
                if validate is not None:
                    xlist = [ validate( object, name, value )
                              for value in xlist ]

                list.extend( self, xlist )

                if (self.name_items is not None) and (len( xlist ) != 0):
                    self._send_trait_items_event( self.name_items,
                        TraitListEvent( len( self ) - len( xlist ), None,
                                        xlist ), trait.items_event() )

                return

            except TraitError, excp:
                excp.set_prefix( 'The elements of the' )
                raise excp

        self.len_error( len( self ) + len( xlist ) )

    def remove ( self, value ):
        trait = getattr(self, 'trait', None)
        if trait is None:
            list.remove(self, value)
            return
        if trait.minlen < len( self ):
            try:
                index   = self.index( value )
                removed = [ self[ index ] ]
            except:
                pass

            list.remove( self, value )

            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitListEvent( index, removed ) )
        elif len(self) == 0:
            # Let whatever system error (ValueError) should be raised be raised.
            list.remove(self, value)
        else:
            self.len_error( len( self ) - 1 )

    if sys.version_info[0] < 3:
        def sort ( self, cmp = None, key = None, reverse = False ):
            removed = self[:]
            list.sort( self, cmp = cmp, key = key, reverse = reverse )
            self._sort_common(removed)
    else:
        def sort ( self, key = None, reverse = False ):
            removed = self[:]
            list.sort( self, key = key, reverse = reverse )
            self._sort_common(removed)

    def _sort_common ( self, removed ):
        if (getattr(self, 'name_items', None) is not None and
            getattr(self, 'trait', None) is not None):
            self._send_trait_items_event( self.name_items,
                TraitListEvent( 0, removed, self[:] ) )

    def reverse ( self ):
        removed = self[:]
        if len( self ) > 1:
            list.reverse( self )
            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitListEvent( 0, removed, self[:] ) )

    def pop ( self, *args ):
        if not hasattr(self, 'trait'):
            return list.pop(self, *args)
        if self.trait.minlen < len( self ):
            if len( args ) > 0:
                index = args[0]
            else:
                index = -1

            try:
                removed = [ self[ index ] ]
            except:
                pass

            result = list.pop( self, *args )

            if self.name_items is not None:
                if index < 0:
                    index = len( self ) + index + 1

                self._send_trait_items_event( self.name_items,
                    TraitListEvent( index, removed ) )

            return result

        else:
            self.len_error( len( self ) - 1 )

    def rename ( self, name ):
        trait = self.object()._trait( name, 0 )
        if trait is not None:
            self.name  = name
            self.trait = trait.handler

    def len_error ( self, len ):
        raise TraitError( "The '%s' trait of %s instance must be %s, "
                  "but you attempted to change its length to %d element%s." % (
                  self.name, class_of( self.object() ),
                  self.trait.full_info( self.object(), self.name, Undefined ),
                  len, 's'[ len == 1: ] ) )

    def __getstate__ ( self ):
        result = self.__dict__.copy()
        result.pop('object', None)
        result.pop('trait', None)

        return result

    def __setstate__ ( self, state ):
        name   = state.setdefault('name', '')
        object = state.pop( 'object', None )
        if object is not None:
            self.object = ref( object )
            self.rename( name )
        else:
            self.object = lambda: None

        self.__dict__.update( state )

#-------------------------------------------------------------------------------
#  'TraitSetEvent' class:
#-------------------------------------------------------------------------------

class TraitSetEvent ( object ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, removed = None, added = None ):
        if removed is None:
            removed = set()
        self.removed = removed

        if added is None:
            added = set()
        self.added = added

#-------------------------------------------------------------------------------
#  'TraitSetObject' class:
#-------------------------------------------------------------------------------

class TraitSetObject ( set ):

    def __init__ ( self, trait, object, name, value ):
        self.trait      = trait
        self.object     = ref( object )
        self.name       = name
        self.name_items = None
        if trait.has_items:
            self.name_items = name + '_items'

        # Validate and assign the initial set value:
        try:
            validate = trait.item_trait.handler.validate
            if validate is not None:
                value = [ validate( object, name, val ) for val in value ]

            super( TraitSetObject, self ).__init__( value )

            return

        except TraitError, excp:
            excp.set_prefix( 'Each element of the' )
            raise excp

    def _send_trait_items_event(self, name, event, items_event=None):
        """ Send a TraitDictEvent to the owning object if there is one.
        """
        object = self.object()
        if object is not None:
            if items_event is None and hasattr(self, 'trait'):
                items_event = self.trait.items_event()
            object.trait_items_event(name, event, items_event)

    def __deepcopy__ ( self, memo ):
        id_self = id( self )
        if id_self in memo:
            return memo[ id_self ]

        memo[ id_self ] = result = TraitSetObject( self.trait, lambda: None,
                         self.name, [ copy.deepcopy( x, memo ) for x in self ] )

        return result

    def update ( self, value ):
        if not hasattr(self, 'trait'):
            return set.update(self, value)
        try:
            added = value.difference( self )
            if len( added ) > 0:
                object   = self.object()
                validate = self.trait.item_trait.handler.validate
                if validate is not None:
                    name  = self.name
                    added = set( [ validate( object, name, item )
                                   for item in added ] )

                set.update( self, added )

                if self.name_items is not None:
                    self._send_trait_items_event( self.name_items,
                        TraitSetEvent( None, added ) )
        except TraitError, excp:
            excp.set_prefix( 'Each element of the' )
            raise excp

    def intersection_update ( self, value ):
        removed = self.difference( value )
        if len( removed ) > 0:
            set.difference_update( self, removed )

            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitSetEvent( removed ) )

    def difference_update ( self, value ):
        removed = self.intersection( value )
        if len( removed ) > 0:
            set.difference_update( self, removed )

            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitSetEvent( removed ) )

    def symmetric_difference_update ( self, value ):
        if not hasattr(self, 'trait'):
            return set.symmetric_difference_update(self, value)
        removed = self.intersection( value )
        added   = value.difference( self )
        if (len( removed ) > 0) or (len( added ) > 0):
            object = self.object()
            set.difference_update( self, removed )

            if len( added ) > 0:
                validate = self.trait.item_trait.handler.validate
                if validate is not None:
                    name  = self.name
                    added = set( [ validate( object, name, item )
                                   for item in added ] )

                set.update( self, added )

            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitSetEvent( removed, added ) )

    def add ( self, value ):
        if not hasattr(self, 'trait'):
            return set.add(self, value)
        if value not in self:
            try:
                object   = self.object()
                validate = self.trait.item_trait.handler.validate
                if validate is not None:
                    value = validate( object, self.name, value )

                set.add( self, value )

                if self.name_items is not None:
                    self._send_trait_items_event( self.name_items,
                        TraitSetEvent( None, set( [ value ] ) ) )
            except TraitError, excp:
                excp.set_prefix( 'Each element of the' )
                raise excp

    def remove ( self, value ):
        set.remove( self, value )

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitSetEvent( set( [ value ] ) ) )

    def discard ( self, value ):
        if value in self:
            self.remove( value )

    def pop ( self ):
        value = set.pop( self )

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitSetEvent( set( [ value ] ) ) )

        return value

    def clear ( self ):
        removed = set( self )
        set.clear( self )

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitSetEvent( removed ) )

    def copy ( self ):
        """ Return a true ``set`` object with a copy of the data.
        """
        return set(self)

    def __reduce_ex__(self, protocol=None):
        """ Overridden to make sure we call our custom __getstate__.
        """
        return (copy_reg._reconstructor,
                (type(self), set, list(self)),
                self.__getstate__())

    def __getstate__ ( self ):
        result = self.__dict__.copy()
        result.pop('object', None)
        result.pop('trait', None)
        return result

    def __setstate__ ( self, state ):
        name   = state.setdefault('name', '')
        object = state.pop( 'object', None )
        if object is not None:
            self.object = ref( object )
            self.rename( name )
        else:
            self.object = lambda: None

        self.__dict__.update( state )


#-------------------------------------------------------------------------------
#  'TraitDictEvent' class:
#-------------------------------------------------------------------------------

class TraitDictEvent ( object ):

    def __init__ ( self, added = None, changed = None, removed = None ):
        """
        Parameters
        ----------
        added : dict
            New keys and values.
        changed : dict
            Updated keys and their previous values.
        removed : dict
            Old keys and values that were just removed.
        """
        # Construct new empty dicts every time instead of using a default value
        # in the method argument, just in case someone gets the bright idea of
        # modifying the dict they get in-place.
        if added is None:
            added = {}
        self.added = added

        if changed is None:
            changed = {}
        self.changed = changed

        if removed is None:
            removed = {}
        self.removed = removed

#-------------------------------------------------------------------------------
#  'TraitDict' class:
#-------------------------------------------------------------------------------

class TraitDict ( TraitHandler ):
    """ Ensures that values assigned to a trait attribute are dictionaries whose
    keys and values are of specified types.

    TraitDict also makes sure that any changes to keys or values made that are
    made after the dictionary is assigned to the trait attribute satisfy the
    type constraints. TraitDict is the underlying handler for the
    dictionary-based predefined traits, and the Dict() trait factory.

    Example
    -------

    class WorkoutClass(HasTraits):
        member_weights = Trait({}, TraitDict(str, float))


    This example defines a WorkoutClass class containing a *member_weights*
    trait attribute whose value must be a dictionary containing keys that
    are strings (i.e., the members' names) and whose associated values must
    be floats (i.e., their most recently recorded weight).
    """
    info_trait         = None
    default_value_type = 6
    _items_event       = None

    def __init__ ( self, key_trait = None, value_trait = None,
                         has_items = True ):
        """ Creates a TraitDict handler.

        Parameters
        ----------
        key_trait : trait
            The type for the dictionary keys.
        value_trait : trait
            The type for the dictionary values.
        has_items : bool
            Flag indicating whether the dictionary contains entries.

        Description
        -----------
        If *key_trait* is None or omitted, the keys in the dictionary can
        be of any type. Otherwise, *key_trait* must be either a trait, or a
        value that can be converted to a trait using the Trait() function. In
        this case, all dictionary keys are checked to ensure that they are of
        the type specified by *key_trait*.

        If *value_trait* is None or omitted, the values in the dictionary
        can be of any type. Otherwise, *value_trait* must be either a trait, or
        a value that can be converted to a trait using the Trait() function.
        In this case, all dictionary values are checked to ensure that they are
        of the type specified by *value_trait*.

        """
        self.key_trait   = trait_from( key_trait )
        self.value_trait = trait_from( value_trait )
        self.has_items   = has_items
        handler          = self.value_trait.handler
        if handler.has_items:
            handler = handler.clone()
            handler.has_items = False
        self.value_handler = handler

    def clone ( self ):
        return TraitDict( self.key_trait, self.value_trait, self.has_items )

    def validate ( self, object, name, value ):
        if isinstance( value, dict ):
            return TraitDictObject( self, object, name, value )
        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        extra   = ''
        handler = self.key_trait.handler
        if handler is not None:
            extra = (' with keys which are %s' %
                     handler.full_info( object, name, value))
        handler = self.value_handler
        if handler is not None:
            if extra == '':
                extra = ' with'
            else:
                extra += ' and'
            extra += (' values which are %s' %
                      handler.full_info( object, name, value ))
        return 'a dictionary%s' % extra

    def get_editor ( self, trait ):
        if self.editor is None:
            from traitsui.api import TextEditor

            self.editor = TextEditor( evaluate = eval )

        return self.editor

    def items_event ( self ):
        if TraitDict._items_event is None:
            TraitDict._items_event = \
                Event( TraitDictEvent, is_base = False ).as_ctrait()

        return TraitDict._items_event

#-------------------------------------------------------------------------------
#  'TraitDictObject' class:
#-------------------------------------------------------------------------------

class TraitDictObject ( dict ):

    def __init__ ( self, trait, object, name, value ):
        self.trait      = trait
        self.object     = ref( object )
        self.name       = name
        self.name_items = None
        if trait.has_items:
            self.name_items = name + '_items'

        if len( value ) > 0:
            dict.update( self, self._validate_dic( value ) )

    def _send_trait_items_event(self, name, event, items_event=None):
        """ Send a TraitDictEvent to the owning object if there is one.
        """
        object = self.object()
        if object is not None:
            if items_event is None and hasattr(self, 'trait'):
                items_event = self.trait.items_event()
            object.trait_items_event(name, event, items_event)

    def __deepcopy__ ( self, memo ):
        id_self = id( self )
        if id_self in memo:
            return memo[ id_self ]

        memo[ id_self ] = result = TraitDictObject( self.trait, lambda: None,
                         self.name, dict([ copy.deepcopy( x, memo ) for x in self.iteritems() ]) )

        return result

    def __setitem__ ( self, key, value ):
        trait = getattr( self, 'trait', None )
        if trait is None:
            dict.__setitem__( self, key, value )
            return

        object = self.object()
        try:
            validate = trait.key_trait.handler.validate
            if validate is not None:
                key = validate( object, self.name, key )

        except TraitError, excp:
            excp.set_prefix( 'Each key of the' )
            raise excp

        try:
            validate = trait.value_handler.validate
            if validate is not None:
                value = validate( object, self.name, value )

            if self.name_items is not None:
                if key in self:
                    added   = None
                    old     = self[ key ]
                    changed = { key: old }
                else:
                    added   = { key: value }
                    changed = None

            dict.__setitem__( self, key, value )

            if self.name_items is not None:
                if added is None:
                    try:
                        if old == value:
                            return
                    except:
                        # Treat incomparable objects as unequal:
                        pass
                self._send_trait_items_event( self.name_items,
                    TraitDictEvent( added, changed ), trait.items_event() )

        except TraitError, excp:
            excp.set_prefix( 'Each value of the' )
            raise excp

    def __delitem__ ( self, key ):
        if self.name_items is not None:
            removed = { key: self[ key ] }

        dict.__delitem__( self, key )

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitDictEvent( removed = removed ) )

    def clear ( self ):
        if len( self ) > 0:
            if self.name_items is not None:
                removed = self.copy()

            dict.clear( self )

            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitDictEvent( removed = removed ) )

    def update ( self, dic ):
        trait = getattr( self, 'trait', None )
        if trait is None:
            dict.update( self, dic )
            return

        if len( dic ) > 0:
            new_dic = self._validate_dic( dic )

            if self.name_items is not None:
                added   = {}
                changed = {}
                for key, value in new_dic.iteritems():
                    if key in self:
                        changed[ key ] = self[ key ]
                    else:
                        added[ key ] = value

                dict.update( self, new_dic )

                self._send_trait_items_event( self.name_items,
                    TraitDictEvent( added = added, changed = changed ) )
            else:
                dict.update( self, new_dic )

    def setdefault ( self, key, value = None ):
        if key in self:
            return self[ key ]

        self[ key ] = value
        result      = self[ key ]

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitDictEvent( added = { key: result } ) )

        return result

    def pop ( self, key, value = Undefined ):
        if (value is Undefined) or key in self:
            result = dict.pop( self, key )

            if self.name_items is not None:
                self._send_trait_items_event( self.name_items,
                    TraitDictEvent( removed = { key: result } ) )

            return result

        return value

    def popitem ( self ):
        result = dict.popitem( self )

        if self.name_items is not None:
            self._send_trait_items_event( self.name_items,
                TraitDictEvent( removed = { result[0]: result[1] } ) )

        return result

    def rename ( self, name ):
        trait = self.object()._trait( name, 0 )
        if trait is not None:
            self.name  = name
            self.trait = trait.handler
        else:
            logger.debug( "rename: No 'trait' in %s for '%s'" %
                          ( self.object(), name ) )

    def __getstate__ ( self ):
        result = self.__dict__.copy()
        result.pop('object', None)
        result.pop('trait', None)
        return result

    def __setstate__ ( self, state ):
        name   = state.setdefault('name', '')
        object = state.pop( 'object', None )
        if object is not None:
            self.object = ref( object )
            self.rename( name )
        else:
            self.object = lambda: None

        self.__dict__.update( state )

#-- Private Methods ------------------------------------------------------------

    def _validate_dic ( self, dic ):
        name    = self.name
        new_dic = {}

        key_validate = self.trait.key_trait.handler.validate
        if key_validate is None:
            key_validate = lambda object, name, key: key

        value_validate = self.trait.value_trait.handler.validate
        if value_validate is None:
            value_validate = lambda object, name, value: value

        object = self.object()
        for key, value in dic.iteritems():
            try:
                key = key_validate( object, name, key )
            except TraitError, excp:
                excp.set_prefix( 'Each key of the' )
                raise excp

            try:
                value = value_validate( object, name, value )
            except TraitError, excp:
                excp.set_prefix( 'Each value of the' )
                raise excp

            new_dic[ key ] = value

        return new_dic

#-------------------------------------------------------------------------------
#  Tell the C-based traits module about 'TraitListObject', 'TraitSetObject and
#  'TraitDictObject', and the PyProtocols 'adapt' function:
#-------------------------------------------------------------------------------

from . import ctraits
ctraits._list_classes( TraitListObject, TraitSetObject, TraitDictObject )

def _adapt_wrapper(*args, **kw):
    # We need this wrapper to defer the import of 'adapt' and avoid a circular
    # import. The ctraits 'adapt' callback needs to be set as soon as possible,
    # but the adaptation mechanism relies on traits.

    # This wrapper is called once, after which we set the ctraits callback
    # to point directly to 'adapt'.

    from traits.adaptation.api import adapt

    ctraits._adapt(adapt)
    return adapt(*args, **kw)

ctraits._adapt( _adapt_wrapper )

########NEW FILE########
__FILENAME__ = trait_notifiers
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005-2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author:        David C. Morrill
#  Original Date: 06/21/2002
#
#------------------------------------------------------------------------------

""" Classes that implement and support the Traits change notification mechanism
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from threading import local as thread_local
from threading import Thread
from thread import get_ident
import traceback
from types import MethodType
import weakref
import sys

from .trait_base import Uninitialized
from .trait_errors import TraitNotificationError

#-------------------------------------------------------------------------------
#  Global Data:
#-------------------------------------------------------------------------------

# The thread ID for the user interface thread
ui_thread = -1

# The handler for notifications that must be run on the UI thread
ui_handler = None

#-------------------------------------------------------------------------------
#  Sets up the user interface thread handler:
#-------------------------------------------------------------------------------

def set_ui_handler ( handler ):
    """ Sets up the user interface thread handler.
    """
    global ui_handler, ui_thread

    ui_handler = handler
    ui_thread  = get_ident()

def ui_dispatch( handler, *args, **kw ):
    if get_ident() == ui_thread:
        handler( *args, **kw )
    else:
        ui_handler( handler, *args, **kw )

#-------------------------------------------------------------------------------
#  'NotificationExceptionHandlerState' class:
#-------------------------------------------------------------------------------

class NotificationExceptionHandlerState ( object ):

    def __init__ ( self, handler, reraise_exceptions, locked ):
        self.handler            = handler
        self.reraise_exceptions = reraise_exceptions
        self.locked             = locked

#-------------------------------------------------------------------------------
#  'NotificationExceptionHandler' class:
#-------------------------------------------------------------------------------

class NotificationExceptionHandler ( object ):

    def __init__ ( self ):
        self.traits_logger = None
        self.main_thread   = None
        self.thread_local  = thread_local()

#-- Private Methods ------------------------------------------------------------

    def _push_handler ( self, handler = None, reraise_exceptions = False,
                              main = False, locked = False ):
        """ Pushes a new traits notification exception handler onto the stack,
            making it the new exception handler. Returns a
            NotificationExceptionHandlerState object describing the previous
            exception handler.

            Parameters
            ----------
            handler : handler
                The new exception handler, which should be a callable or
                None. If None (the default), then the default traits
                notification exception handler is used. If *handler* is not
                None, then it must be a callable which can accept four
                arguments: object, trait_name, old_value, new_value.
            reraise_exceptions : bool
                Indicates whether exceptions should be reraised after the
                exception handler has executed. If True, exceptions will be
                re-raised after the specified handler has been executed.
                The default value is False.
            main : bool
                Indicates whether the caller represents the main application
                thread. If True, then the caller's exception handler is
                made the default handler for any other threads that are
                created. Note that a thread can explicitly set its own
                exception handler if desired. The *main* flag is provided to
                make it easier to set a global application policy without
                having to explicitly set it for each thread. The default
                value is False.
            locked : bool
                Indicates whether further changes to the Traits notification
                exception handler state should be allowed. If True, then
                any subsequent calls to _push_handler() or _pop_handler() for
                that thread will raise a TraitNotificationError. The default
                value is False.
        """
        handlers = self._get_handlers()
        self._check_lock( handlers )
        if handler is None:
            handler = self._log_exception
        handlers.append( NotificationExceptionHandlerState( handler,
                                                  reraise_exceptions, locked ) )
        if main:
            self.main_thread = handlers

        return handlers[-2]

    def _pop_handler ( self ):
        """ Pops the traits notification exception handler stack, restoring
            the exception handler in effect prior to the most recent
            _push_handler() call. If the stack is empty or locked, a
            TraitNotificationError exception is raised.

            Note that each thread has its own independent stack. See the
            description of the _push_handler() method for more information on
            this.
        """
        handlers = self._get_handlers()
        self._check_lock( handlers )
        if len( handlers ) > 1:
            handlers.pop()
        else:
            raise TraitNotificationError(
                      'Attempted to pop an empty traits notification exception '
                      'handler stack.' )

    def _handle_exception ( self, object, trait_name, old, new  ):
        """ Handles a traits notification exception using the handler defined
            by the topmost stack entry for the corresponding thread.
        """
        excp_class, excp = sys.exc_info()[:2]
        handler_info     = self._get_handlers()[-1]
        handler_info.handler( object, trait_name, old, new )
        if (handler_info.reraise_exceptions or
            isinstance( excp, TraitNotificationError )):
            raise

    def _get_handlers ( self ):
        """ Returns the handler stack associated with the currently executing
            thread.
        """
        thread_local = self.thread_local
        if isinstance( thread_local, dict ):
            id       = get_ident()
            handlers = thread_local.get( id )
        else:
            handlers = getattr( thread_local, 'handlers', None )

        if handlers is None:
            if self.main_thread is not None:
                handler = self.main_thread[-1]
            else:
                handler = NotificationExceptionHandlerState(
                              self._log_exception, False, False )
            handlers = [ handler ]
            if isinstance( thread_local, dict ):
                thread_local[ id ] = handlers
            else:
                thread_local.handlers = handlers

        return handlers

    def _check_lock ( self, handlers ):
        """ Raises an exception if the specified handler stack is locked.
        """
        if handlers[-1].locked:
            raise TraitNotificationError(
                      'The traits notification exception handler is locked. '
                      'No changes are allowed.' )

    #---------------------------------------------------------------------------
    #  This method defines the default notification exception handling
    #  behavior of traits. However, it can be completely overridden by pushing
    #  a new handler using the '_push_handler' method.
    #
    #  It logs any exceptions generated in a trait notification handler.
    #---------------------------------------------------------------------------

    def _log_exception ( self, object, trait_name, old, new ):
        """ Logs any exceptions generated in a trait notification handler.
        """
        # When the stack depth is too great, the logger can't always log the
        # message. Make sure that it goes to the console at a minimum:
        excp_class, excp = sys.exc_info()[:2]
        if ((excp_class is RuntimeError) and
            (len(excp.args) > 0) and
            (excp.args[0] == 'maximum recursion depth exceeded')):
            sys.__stderr__.write( 'Exception occurred in traits notification '
                'handler for object: %s, trait: %s, old value: %s, '
                'new value: %s.\n%s\n' % ( object, trait_name, old, new,
                ''.join( traceback.format_exception( *sys.exc_info() ) ) ) )

        logger = self.traits_logger
        if logger is None:
            import logging

            self.traits_logger = logger = logging.getLogger(
                                                  'traits' )
            handler = logging.StreamHandler()
            handler.setFormatter( logging.Formatter( '%(message)s' ) )
            logger.addHandler( handler )
            print ('Exception occurred in traits notification handler.\n'
                   'Please check the log file for details.')

        try:
            logger.exception(
                'Exception occurred in traits notification handler for '
                'object: %s, trait: %s, old value: %s, new value: %s' %
                ( object, trait_name, old, new ) )
        except Exception:
            # Ignore anything we can't log the above way:
            pass

#-------------------------------------------------------------------------------
#  Traits global notification exception handler:
#-------------------------------------------------------------------------------

notification_exception_handler = NotificationExceptionHandler()

push_exception_handler = notification_exception_handler._push_handler
pop_exception_handler  = notification_exception_handler._pop_handler
handle_exception       = notification_exception_handler._handle_exception

#-------------------------------------------------------------------------------
#  Traits global notification event tracer:
#-------------------------------------------------------------------------------

_pre_change_event_tracer = None
_post_change_event_tracer = None

def set_change_event_tracers( pre_tracer=None, post_tracer=None ):
    """ Set the global trait change event tracers.

    The global tracers are called whenever a trait change event is dispatched.
    There are two tracers: `pre_tracer` is called before the notification is
    sent; `post_tracer` is called after the notification is sent, even if the
    notification failed with an exception (in which case the `post_tracer` is
    called with a reference to the exception, then the exception is sent to
    the `notification_exception_handler`).

    The tracers should be a callable taking 5 arguments:
    ::
      tracer(obj, trait_name, old, new, handler)

    `obj` is the source object, on which trait `trait_name` was changed from
    value `old` to value `new`. `handler` is the function or method that will
    be notified of the change.

    The post-notification tracer also has a keyword argument, `exception`,
    that is `None` if no exception has been raised, and the a reference to the
    raise exception otherwise.
    ::
      post_tracer(obj, trait_name, old, new, handler, exception=None)

    Note that for static trait change listeners, `handler` is not a method, but
    rather the function before class creation, since this is the way Traits
    works at the moment.
    """
    global _pre_change_event_tracer
    global _post_change_event_tracer
    _pre_change_event_tracer = pre_tracer
    _post_change_event_tracer = post_tracer

def clear_change_event_tracers():
    """ Clear the global trait change event tracer. """
    global _pre_change_event_tracer
    global _post_change_event_tracer
    _pre_change_event_tracer = None
    _post_change_event_tracer = None

#-------------------------------------------------------------------------------
#  'AbstractStaticChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class AbstractStaticChangeNotifyWrapper(object):
    """
    Concrete implementation must define the 'argument_transforms' class
    argument, a dictionary mapping the number of arguments in the event
    handler to a function that takes the arguments (obj, trait_name, old, new)
    and returns the arguments tuple for the actual handler.
    """

    arguments_transforms = {}

    def __init__ ( self, handler ):
        arg_count = handler.func_code.co_argcount
        if arg_count > 4:
            raise TraitNotificationError(
                ('Invalid number of arguments for the static anytrait change '
                 'notification handler: %s. A maximum of 4 arguments is '
                 'allowed, but %s were specified.')
                % ( handler.__name__, arg_count ) )
        self.argument_transform = self.argument_transforms[arg_count]

        self.handler  = handler

    def __call__ ( self, object, trait_name, old, new ):
        """ Dispatch to the appropriate handler method. """

        if old is not Uninitialized:
            # Extract the arguments needed from the handler.
            args = self.argument_transform( object, trait_name, old, new )

            # Send a description of the change event to the event tracer.
            if _pre_change_event_tracer is not None:
                _pre_change_event_tracer( object, trait_name, old, new,
                                          self.handler )

            try:
                # Call the handler.
                self.handler( *args )
            except Exception as e:
                exception = e
            else:
                exception = None
            finally:
                if _post_change_event_tracer is not None:
                    _post_change_event_tracer( object, trait_name, old, new,
                                               self.handler,
                                               exception=exception )

            if exception is not None:
                handle_exception( object, trait_name, old, new )

    def equals ( self, handler ):
        return False

#-------------------------------------------------------------------------------
#  'StaticAnyTraitChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class StaticAnyTraitChangeNotifyWrapper(AbstractStaticChangeNotifyWrapper):

    # The wrapper is called with the full set of argument, and we need to
    # create a tuple with the arguments that need to be sent to the event
    # handler, depending on the number of those.
    argument_transforms = {
        0: lambda obj, name, old, new: (),
        1: lambda obj, name, old, new: (obj,),
        2: lambda obj, name, old, new: (obj, name),
        3: lambda obj, name, old, new: (obj, name, new),
        4: lambda obj, name, old, new: (obj, name, old, new),
    }

#-------------------------------------------------------------------------------
#  'StaticTraitChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class StaticTraitChangeNotifyWrapper(AbstractStaticChangeNotifyWrapper):

    # The wrapper is called with the full set of argument, and we need to
    # create a tuple with the arguments that need to be sent to the event
    # handler, depending on the number of those.
    argument_transforms = {
        0: lambda obj, name, old, new: (),
        1: lambda obj, name, old, new: (obj,),
        2: lambda obj, name, old, new: (obj, new),
        3: lambda obj, name, old, new: (obj, old, new),
        4: lambda obj, name, old, new: (obj, name, old, new),
    }

#-------------------------------------------------------------------------------
#  'TraitChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class TraitChangeNotifyWrapper(object):
    """ Dynamic change notify wrapper.

    This class is in charge to dispatch trait change events to dynamic
    listener, typically created using the `on_trait_change` method, or
    the decorator with the same name.
    """

    # The wrapper is called with the full set of argument, and we need to
    # create a tuple with the arguments that need to be sent to the event
    # handler, depending on the number of those.
    argument_transforms = {
        0: lambda obj, name, old, new: (),
        1: lambda obj, name, old, new: (new,),
        2: lambda obj, name, old, new: (name, new),
        3: lambda obj, name, old, new: (obj, name, new),
        4: lambda obj, name, old, new: (obj, name, old, new),
    }

    def __init__ ( self, handler, owner, target=None ):
        self.init( handler, owner, target )

    def init ( self, handler, owner, target=None ):
        # If target is not None and handler is a function then the handler
        # will be removed when target is deleted.
        if type( handler ) is MethodType:
            func   = handler.im_func
            object = handler.im_self
            if object is not None:
                self.object = weakref.ref( object, self.listener_deleted )
                self.name   = handler.__name__
                self.owner  = owner
                arg_count   = func.func_code.co_argcount - 1
                if arg_count > 4:
                    raise TraitNotificationError(
                        ('Invalid number of arguments for the dynamic trait '
                         'change notification handler: %s. A maximum of 4 '
                         'arguments is allowed, but %s were specified.') %
                        ( func.__name__, arg_count ) )

                # We use the unbound method here to prevent cyclic garbage
                # (issue #100).
                self.notify_listener = type(self)._notify_method_listener
                self.argument_transform = self.argument_transforms[arg_count]

                return arg_count

        elif target is not None:
            # Set up so the handler will be removed when the target is deleted.
            self.object = weakref.ref( target, self.listener_deleted )
            self.owner = owner

        arg_count = handler.func_code.co_argcount
        if arg_count > 4:
            raise TraitNotificationError(
                ('Invalid number of arguments for the dynamic trait change '
                 'notification handler: %s. A maximum of 4 arguments is '
                 'allowed, but %s were specified.') %
                ( handler.__name__, arg_count ) )

        self.name     = None
        self.handler  = handler

        # We use the unbound method here to prevent cyclic garbage
        # (issue #100).
        self.notify_listener = type(self)._notify_function_listener
        self.argument_transform = self.argument_transforms[arg_count]

        return arg_count

    def __call__(self, object, trait_name, old, new):
        """ Dispatch to the appropriate method.

        We do explicit dispatch instead of assigning to the .__call__ instance
        attribute to avoid reference cycles.
        """

        # `notify_listener` is either the *unbound*
        # `_notify_method_listener` or `_notify_function_listener` to
        # prevent cyclic garbage (issue #100).
        self.notify_listener( self, object, trait_name, old, new )

    def dispatch ( self, handler, *args ):
        """ Dispatch the event to the listener.

        This method is normally the only one that needs to be overridden in
        a subclass to implement the subclass's dispatch mechanism.
        """
        handler( *args )

    def equals ( self, handler ):
        if handler is self:
            return True

        if (type( handler ) is MethodType) and (handler.im_self is not None):
            return ((handler.__name__ == self.name) and
                    (handler.im_self is self.object()))

        return ((self.name is None) and (handler == self.handler))

    def listener_deleted ( self, ref ):
        # In multithreaded situations, it's possible for this method to
        # be called after, or concurrently with, the dispose method.
        # Don't raise in that case.
        try:
            self.owner.remove( self )
        except ValueError:
            pass
        self.object = self.owner = None

    def dispose ( self ):
        self.object = None

    def _dispatch_change_event(self, object, trait_name, old, new, handler):
        """ Prepare and dispatch a trait change event to a listener. """

        # Extract the arguments needed from the handler.
        args = self.argument_transform( object, trait_name, old, new )

        # Send a description of the event to the change event tracer.
        if _pre_change_event_tracer is not None:
            _pre_change_event_tracer( object, trait_name, old, new, handler )

        # Dispatch the event to the listener.
        try:
            self.dispatch( handler, *args )
        except Exception as e:
            if _post_change_event_tracer is not None:
                _post_change_event_tracer( object, trait_name, old, new,
                                           handler, exception=e )
            # This call needs to be made inside the `except` block in case
            # the handler wants to re-raise the exception.
            handle_exception( object, trait_name, old, new )
        else:
            if _post_change_event_tracer is not None:
                _post_change_event_tracer( object, trait_name, old, new,
                                           handler, exception=None )

    def _notify_method_listener(self, object, trait_name, old, new):
        """ Dispatch a trait change event to a method listener. """

        obj_weak_ref = self.object
        if (obj_weak_ref is not None) and (old is not Uninitialized):
            # We make sure to hold a reference to the object before invoking
            # `getattr` so that the listener does not disappear in a
            # multi-threaded case.
            obj = obj_weak_ref()
            if obj is not None:
                # Dynamically resolve the listener by name.
                listener = getattr( obj, self.name )
                self._dispatch_change_event( object, trait_name, old, new,
                                             listener )

    def _notify_function_listener(self, object, trait_name, old, new):
        """ Dispatch a trait change event to a function listener. """

        if old is not Uninitialized:
            self._dispatch_change_event( object, trait_name, old, new,
                                         self.handler )

#-------------------------------------------------------------------------------
#  'ExtendedTraitChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class ExtendedTraitChangeNotifyWrapper ( TraitChangeNotifyWrapper ):
    """ Change notify wrapper for "extended" trait change events..

    The "extended notifiers" are set up internally when using extended traits,
    to add/remove traits listeners when one of the intermediate traits changes.

    For example, in a listener for the extended trait `a.b`, we need to
    add/remove listeners to `a:b` when `a` changes.
    """

    def _dispatch_change_event(self, object, trait_name, old, new, handler):
        """ Prepare and dispatch a trait change event to a listener. """

        # Extract the arguments needed from the handler.
        args = self.argument_transform( object, trait_name, old, new )

        # Dispatch the event to the listener.
        try:
            self.dispatch( handler, *args )
        except Exception:
            handle_exception( object, trait_name, old, new )

    def _notify_method_listener(self, object, trait_name, old, new):
        """ Dispatch a trait change event to a method listener. """

        obj_weak_ref = self.object
        if obj_weak_ref is not None:
            # We make sure to hold a reference to the object before invoking
            # `getattr` so that the listener does not disappear in a
            # multi-threaded case.
            obj = obj_weak_ref()
            if obj is not None:
                # Dynamically resolve the listener by name.
                listener = getattr( obj, self.name )
                self._dispatch_change_event( object, trait_name, old, new,
                                             listener )

    def _notify_function_listener(self, object, trait_name, old, new):
        """ Dispatch a trait change event to a function listener. """

        self._dispatch_change_event(object, trait_name, old, new, self.handler)

#-------------------------------------------------------------------------------
#  'FastUITraitChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class FastUITraitChangeNotifyWrapper ( TraitChangeNotifyWrapper ):
    """ Dynamic change notify wrapper, dispatching on the UI thread.

    This class is in charge to dispatch trait change events to dynamic
    listener, typically created using the `on_trait_change` method and the
    `dispatch` parameter set to 'ui' or 'fast_ui'.
    """

    def dispatch ( self, handler, *args ):
        if get_ident() == ui_thread:
            handler( *args )
        else:
            ui_handler( handler, *args )

#-------------------------------------------------------------------------------
#  'NewTraitChangeNotifyWrapper' class:
#-------------------------------------------------------------------------------

class NewTraitChangeNotifyWrapper ( TraitChangeNotifyWrapper ):
    """ Dynamic change notify wrapper, dispatching on a new thread.

    This class is in charge to dispatch trait change events to dynamic
    listener, typically created using the `on_trait_change` method and the
    `dispatch` parameter set to 'new'.
    """

    def dispatch ( self, handler, *args ):
        Thread( target = handler, args = args ).start()

########NEW FILE########
__FILENAME__ = trait_numeric
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/13/2004
#
#------------------------------------------------------------------------------

""" Trait definitions related to the numpy library.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import warnings

from .trait_base import SequenceTypes
from .trait_errors import TraitError
from .trait_handlers import TraitType, OBJECT_IDENTITY_COMPARE
from .trait_types import Str, Any, Int as TInt, Float as TFloat

#-------------------------------------------------------------------------------
#  Deferred imports from numpy:
#-------------------------------------------------------------------------------

ndarray = None
asarray = None

#-------------------------------------------------------------------------------
#  numpy dtype mapping:
#-------------------------------------------------------------------------------

def dtype2trait ( dtype ):
    """ Get the corresponding trait for a numpy dtype.
    """

    import numpy

    if dtype.char in numpy.typecodes['Float']:
        return TFloat

    elif dtype.char in numpy.typecodes['AllInteger']:
        return TInt

    elif dtype.char[0] == 'S':
        return Str

    else:
        return Any

#-------------------------------------------------------------------------------
#  'AbstractArray' trait base class:
#-------------------------------------------------------------------------------

class AbstractArray ( TraitType ):
    """ Abstract base class for defining numpy-based arrays.
    """

    def __init__ ( self, dtype = None, shape = None, value = None,
                         coerce = False, typecode = None, **metadata ):
        """ Returns an AbstractArray trait.
        """
        global ndarray, asarray

        try:
            import numpy
        except ImportError:
            raise TraitError( "Using Array or CArray trait types requires the "
                              "numpy package to be installed." )

        from numpy import array, asarray, ndarray, zeros

        # Mark this as being an 'array' trait:
        metadata[ 'array' ] = True

        # Normally use object identity to detect array values changing:
        metadata.setdefault( 'comparison_mode', OBJECT_IDENTITY_COMPARE )

        if typecode is not None:
            warnings.warn( 'typecode is a deprecated argument; use dtype '
                           'instead', DeprecationWarning )

            if (dtype is not None) and (dtype != typecode):
                raise TraitError( 'Inconsistent usage of the dtype and '
                                  'typecode arguments; use dtype alone.' )
            else:
                dtype = typecode

        if dtype is not None:
            try:
                # Convert the argument into an actual numpy dtype object:
                dtype = numpy.dtype( dtype )
            except TypeError:
                raise TraitError( 'could not convert %r to a numpy dtype' %
                                  dtype )

        if shape is not None:
            if isinstance( shape, SequenceTypes ):
                for item in shape:
                    if ((item is None) or (type( item ) is int) or
                        (isinstance( item, SequenceTypes ) and
                         (len( item ) == 2) and
                         (type( item[0] ) is int) and (item[0] >= 0) and
                         ((item[1] is None) or ((type( item[1] ) is int) and
                           (item[0] <= item[1]))))):
                        continue

                    raise TraitError, "shape should be a list or tuple"
            else:
                raise TraitError, "shape should be a list or tuple"

        if value is None:
            if dtype is None:
                # Compatibility with the default of Traits 2.0
                dt = int
            else:
                dt = dtype
            if shape is None:
                value = zeros( ( 0, ), dt )
            else:
                size = []
                for item in shape:
                    if item is None:
                        item = 1
                    elif type( item ) in SequenceTypes:
                        # XXX: what is this supposed to do?
                        item = item[0]
                    size.append( item )
                value = zeros( size, dt )

        self.dtype  = dtype
        self.shape  = shape
        self.coerce = coerce

        super( AbstractArray, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid array.
        """
        try:
            # Make sure the value is an array:
            type_value = type( value )
            if not isinstance( value, ndarray ):
                if not isinstance( value, SequenceTypes ):
                    self.error( object, name, value )
                if self.dtype is not None:
                    value = asarray( value, self.dtype )
                else:
                    value = asarray( value )

            # Make sure the array is of the right type:
            if ((self.dtype is not None) and
                (value.dtype != self.dtype)):
                if self.coerce:
                    value = value.astype( self.dtype )
                else:
                    # XXX: this also coerces.
                    value = asarray( value, self.dtype )

            # If no shape requirements, then return the value:
            trait_shape = self.shape
            if trait_shape is None:
                return value

            # Else make sure that the value's shape is compatible:
            value_shape = value.shape
            if len( trait_shape ) == len( value_shape ):
                for i, dim in enumerate( value_shape ):
                    item = trait_shape[i]
                    if item is not None:
                        if type( item ) is int:
                            if dim != item:
                                break
                        elif ((dim < item[0]) or
                              ((item[1] is not None) and (dim > item[1]))):
                            break
                else:
                    return value
        except:
            pass

        self.error( object, name, value )

    def info ( self ):
        """ Returns descriptive information about the trait.
        """
        dtype = shape = ''

        if self.shape is not None:
            shape = []
            for item in self.shape:
                if item is None:
                    item = '*'
                elif type( item ) is not int:
                    if item[1] is None:
                        item = '%d..' % item[0]
                    else:
                        item = '%d..%d' % item
                shape.append( item )
            shape = ' with shape %s' % ( tuple( shape ), )

        if self.dtype is not None:
            # FIXME: restore nicer descriptions of dtypes.
            dtype = ' of %s values' % self.dtype

        return 'an array%s%s' % ( dtype, shape )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        editor = None

        auto_set = False
        if self.auto_set is None:
            auto_set = True
        enter_set = self.enter_set or False

        if self.shape is not None and len( self.shape ) == 2:
            from traitsui.api import ArrayEditor
            editor = ArrayEditor( auto_set=auto_set, enter_set=enter_set )
        else:
            from traitsui.api import TupleEditor

            if self.dtype is None:
                types = Any
            else:
                types = dtype2trait( self.dtype )
            editor = TupleEditor( types     = types,
                                  labels    = self.labels or [],
                                  cols      = self.cols or 1,
                                  auto_set  = auto_set,
                                  enter_set = enter_set  )
        return editor

    #-- Private Methods --------------------------------------------------------

    def get_default_value ( self ):
        """ Returns the default value constructor for the type (called from the
            trait factory.
        """
        return ( 7, ( self.copy_default_value,
                 ( self.validate( None, None, self.default_value ), ), None ) )

    def copy_default_value ( self, value ):
        """ Returns a copy of the default value (called from the C code on
            first reference to a trait with no current value).
        """
        return value.copy()

#-------------------------------------------------------------------------------
#  'Array' trait:
#-------------------------------------------------------------------------------

class Array ( AbstractArray ):
    """ Defines a trait whose value must be a numpy array.
    """

    def __init__ ( self, dtype = None, shape = None, value = None,
                   typecode = None, **metadata ):
        """ Returns an Array trait.

        Parameters
        ----------
        dtype : a numpy dtype (e.g., int32)
            The type of elements in the array; if omitted, no type-checking is
            performed on assigned values.
        shape : a tuple
            Describes the required shape of any assigned value. Wildcards and
            ranges are allowed. The value None within the *shape* tuple means
            that the corresponding dimension is not checked. (For example,
            ``shape=(None,3)`` means that the first dimension can be any size,
            but the second must be 3.) A two-element tuple within the *shape*
            tuple means that the dimension must be in the specified range. The
            second element can be None to indicate that there is no upper
            bound. (For example, ``shape=((3,5),(2,None))`` means that the
            first dimension must be in the range 3 to 5 (inclusive), and the
            second dimension must be at least 2.)
        value : numpy array
            A default value for the array.

        Default Value
        -------------
        *value* or ``zeros(min(shape))``, where ``min(shape)`` refers to the
        minimum shape allowed by the array. If *shape* is not specified, the
        minimum shape is (0,).

        Description
        -----------
        An Array trait allows only upcasting of assigned values that are
        already numpy arrays. It automatically casts tuples and lists of the
        right shape to the specified *dtype* (just like numpy's **array**
        does).
        """
        super( Array, self ).__init__( dtype, shape, value, False,
                                       typecode = typecode, **metadata )

#-------------------------------------------------------------------------------
#  'CArray' trait:
#-------------------------------------------------------------------------------

class CArray ( AbstractArray ):
    """ Defines a trait whose value must be a numpy array, with casting
        allowed.
    """

    def __init__ ( self, dtype = None, shape = None, value = None,
                   typecode = None, **metadata ):
        """ Returns a CArray trait.

        Parameters
        ----------
        dtype : a numpy dtype (e.g., int32)
            The type of elements in the array.
        shape : a tuple
            Describes the required shape of any assigned value. Wildcards and
            ranges are allowed. The value None within the *shape* tuple means
            that the corresponding dimension is not checked. (For example,
            ``shape=(None,3)`` means that the first dimension can be any size,
            but the second must be 3.) A two-element tuple within the *shape*
            tuple means that the dimension must be in the specified range. The
            second element can be None to indicate that there is no upper
            bound. (For example, ``shape=((3,5),(2,None))`` means that the
            first dimension must be in the range 3 to 5 (inclusive), and the
            second dimension must be at least 2.)
        value : numpy array
            A default value for the array.

        Default Value
        -------------
        *value* or ``zeros(min(shape))``, where ``min(shape)`` refers to the
        minimum shape allowed by the array. If *shape* is not specified, the
        minimum shape is (0,).

        Description
        -----------
        The trait returned by CArray() is similar to that returned by Array(),
        except that it allows both upcasting and downcasting of assigned values
        that are already numpy arrays. It automatically casts tuples and
        lists of the right shape to the specified *dtype* (just like
        numpy's **array** does).
        """
        super( CArray, self ).__init__( dtype, shape, value, True,
                                        typecode = typecode, **metadata )


########NEW FILE########
__FILENAME__ = trait_types
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/22/2007
#
#------------------------------------------------------------------------------

""" Core Trait definitions.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import datetime
import operator
import re
import sys
from os.path import isfile, isdir
from types import FunctionType, MethodType, ModuleType

from . import trait_handlers

from .trait_base import (strx, get_module_name, class_of, SequenceTypes, TypeTypes,
        ClassTypes, Undefined, TraitsCache, python_version)

from .trait_handlers import (TraitType, TraitInstance, TraitListObject,
        TraitSetObject, TraitSetEvent, TraitDictObject, TraitDictEvent,
        ThisClass, items_event, RangeTypes, HandleWeakRef)

from .traits import (Trait, trait_from, _TraitMaker, _InstanceArgs, code_editor,
        html_editor, password_editor, shell_editor, date_editor, time_editor)

from .trait_errors import TraitError

from . import _py2to3

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

MutableTypes = ( list, dict )
SetTypes     = SequenceTypes + ( set, )

#-------------------------------------------------------------------------------
#  Numeric type fast validator definitions:
#-------------------------------------------------------------------------------

# A few words about the next block of code:

# Validator #11 is a generic validator for possibly coercible types
# (see validate_trait_coerce_type in ctraits.c).
#
# The tuples below are of the form
# (11, type1, [type2, type3, ...], [None, ctype1, [ctype2, ...]])
#
# 'type1' corresponds to the main type for the trait
# 'None' acts as the separator between 'types' and 'ctypes' (coercible types)
#
# The validation passes if:
# 1) The trait value type is (a subtype of) one of 'type1', 'type2',  ...
#    in which case the value is returned as-is
# or
# 2) The trait value type is (a subtype of) one of 'ctype1', 'ctype2', ...
#    in which case the value is returned coerced to trait type using
#    'return type1(value')

try:
    # The numpy enhanced definitions:
    from numpy import integer, floating, complexfloating, bool_

    int_fast_validate     = ( 11, int, integer )
    long_fast_validate    = ( 11, long, None, int, integer )
    float_fast_validate   = ( 11, float, floating, None, int, integer )
    complex_fast_validate = ( 11, complex, complexfloating, None,
                                  float, floating, int, integer )
    bool_fast_validate    = ( 11, bool, bool_ )
except ImportError:
    # The standard python definitions (without numpy):
    int_fast_validate     = ( 11, int )
    long_fast_validate    = ( 11, long,    None, int )
    float_fast_validate   = ( 11, float,   None, int )
    complex_fast_validate = ( 11, complex, None, float, int )
    bool_fast_validate    = ( 11, bool )

#-------------------------------------------------------------------------------
#  Returns a default text editor:
#-------------------------------------------------------------------------------

def default_text_editor ( trait, type = None ):
    auto_set = trait.auto_set
    if auto_set is None:
        auto_set = True

    enter_set = trait.enter_set or False

    from traitsui.api import TextEditor

    if type is None:
        return TextEditor( auto_set = auto_set, enter_set = enter_set )

    return TextEditor( auto_set  = auto_set,
                       enter_set = enter_set,
                       evaluate  = type )

#-------------------------------------------------------------------------------
#  'Any' trait:
#-------------------------------------------------------------------------------

class Any ( TraitType ):
    """ Defines a trait whose value can be anything.
    """

    #: The default value for the trait:
    default_value = None

    #: A description of the type of value this trait accepts:
    info_text = 'any value'

#-------------------------------------------------------------------------------
#  'Generic' trait:
#-------------------------------------------------------------------------------

class Generic ( Any ):
    """ Defines a trait whose value can be anything and whose definition can
        be redefined via assignment using a TraitValue object.
    """

    #: The standard metadata for the trait:
    metadata = { 'trait_value': True }

#-------------------------------------------------------------------------------
#  'BaseInt' and 'Int' traits:
#-------------------------------------------------------------------------------

class BaseInt ( TraitType ):
    """ Defines a trait whose type must be an int or long.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = int

    #: The default value for the trait:
    default_value = 0

    #: A description of the type of value this trait accepts:
    info_text = 'an integer (int or long)'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.
        """
        if type(value) is int:
            return value
        elif type(value) is long:
            return int(value)

        try:
            int_value = operator.index( value )
        except TypeError:
            pass
        else:
            return int(int_value)

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        return default_text_editor( self, int )


class Int ( BaseInt ):
    """ Defines a trait whose type must be an int or long using a C-level fast
        validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 20, )

#-------------------------------------------------------------------------------
#  'BaseLong' and 'Long' traits:
#-------------------------------------------------------------------------------

class BaseLong ( TraitType ):
    """ Defines a trait whose value must be a Python long.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = long

    #: The default value for the trait:
    default_value = 0L

    #: A description of the type of value this trait accepts:
    info_text = 'a long'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if isinstance( value, long ):
            return value

        if isinstance( value, int ):
            return long( value )

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        return default_text_editor( self, long )


class Long ( BaseLong ):
    """ Defines a trait whose value must be a Python long using a C-level fast
        validator.
    """

    #: The C-level fast validator to use:
    fast_validate = long_fast_validate

#-------------------------------------------------------------------------------
#  'BaseFloat' and 'Float' traits:
#-------------------------------------------------------------------------------

class BaseFloat ( TraitType ):
    """ Defines a trait whose value must be a Python float.
    """
    #: The function to use for evaluating strings to this type:
    evaluate = float

    #: The default value for the trait:
    default_value = 0.0

    #: A description of the type of value this trait accepts:
    info_text = 'a float'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if isinstance( value, float ):
            return value

        if isinstance( value, int ):
            return float( value )

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        return default_text_editor( self, float )


class Float ( BaseFloat ):
    """ Defines a trait whose value must be a Python float using a C-level fast
        validator.
    """

    #: The C-level fast validator to use:
    fast_validate = float_fast_validate

#-------------------------------------------------------------------------------
#  'BaseComplex' and 'Complex' traits:
#-------------------------------------------------------------------------------

class BaseComplex ( TraitType ):
    """ Defines a trait whose value must be a Python complex.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = complex

    #: The default value for the trait:
    default_value = 0.0 + 0.0j

    #: A description of the type of value this trait accepts:
    info_text = 'a complex number'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if isinstance( value, complex ):
            return value

        if isinstance( value, ( float, int ) ):
            return complex( value )

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        return default_text_editor( self, complex )


class Complex ( BaseComplex ):
    """ Defines a trait whose value must be a Python complex using a C-level
        fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = complex_fast_validate

#-------------------------------------------------------------------------------
#  'BaseStr' and 'Str' traits:
#-------------------------------------------------------------------------------

class BaseStr ( TraitType ):
    """ Defines a trait whose value must be a Python string.
    """

    #: The default value for the trait:
    default_value = ''

    #: A description of the type of value this trait accepts:
    info_text = 'a string'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if isinstance( value, basestring ):
            return value

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        from .traits import multi_line_text_editor
        auto_set = self.auto_set
        if auto_set is None:
            auto_set = True
        enter_set = self.enter_set or False

        return multi_line_text_editor(auto_set, enter_set)


class Str ( BaseStr ):
    """ Defines a trait whose value must be a Python string using a C-level
        fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 11, basestring )


class Title ( Str ):
    """ Defines a string type which by default uses the traits ui TitleEditor
        when used in a View.
    """

    def create_editor ( self ):
        """ Returns the default traits UI editor to use for a trait.
        """
        from traitsui.api import TitleEditor
        if hasattr(self, 'allow_selection'):
            return TitleEditor(allow_selection=self.allow_selection)
        else:
            return TitleEditor()

#-------------------------------------------------------------------------------
#  'BaseUnicode' and 'Unicode' traits:
#-------------------------------------------------------------------------------

class BaseUnicode ( TraitType ):
    """ Defines a trait whose value must be a Python unicode string.
    """

    #: The default value for the trait:
    default_value = u''

    #: A description of the type of value this trait accepts:
    info_text = 'a unicode string'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if isinstance( value, unicode ):
            return value

        if isinstance( value, str ):
            return unicode( value )

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        from .traits import multi_line_text_editor
        auto_set = self.auto_set
        if auto_set is None:
            auto_set = True
        enter_set = self.enter_set or False

        return multi_line_text_editor(auto_set, enter_set)


class Unicode ( BaseUnicode ):
    """ Defines a trait whose value must be a Python unicode string using a
        C-level fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 11, unicode, None, str )

#-------------------------------------------------------------------------------
#  'BaseBool' and 'Bool' traits:
#-------------------------------------------------------------------------------

class BaseBool ( TraitType ):
    """ Defines a trait whose value must be a Python boolean.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = bool

    #: The default value for the trait:
    default_value = False

    #: A description of the type of value this trait accepts:
    info_text = 'a boolean'

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if isinstance( value, bool ):
            return value

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        from traitsui.api import BooleanEditor

        return BooleanEditor()


class Bool ( BaseBool ):
    """ Defines a trait whose value must be a Python boolean using a C-level
        fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = bool_fast_validate

#-------------------------------------------------------------------------------
#  'BaseCInt' and 'CInt' traits:
#-------------------------------------------------------------------------------

class BaseCInt ( BaseInt ):
    """ Defines a trait whose value must be a Python int and which supports
        coercions of non-int values to int.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = int

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return int( value )
        except:
            self.error( object, name, value )


class CInt ( BaseCInt ):
    """ Defines a trait whose value must be a Python int and which supports
        coercions of non-int values to int using a C-level fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 12, int )

#-------------------------------------------------------------------------------
#  'BaseCLong' and 'CLong' traits:
#-------------------------------------------------------------------------------

class BaseCLong ( BaseLong ):
    """ Defines a trait whose value must be a Python long and which supports
        coercions of non-long values to long.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = long

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return long( value )
        except:
            self.error( object, name, value )


class CLong ( BaseCLong ):
    """ Defines a trait whose value must be a Python long and which supports
        coercions of non-long values to long using a C-level fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 12, long )

#-------------------------------------------------------------------------------
#  'BaseCFloat' and 'CFloat' traits:
#-------------------------------------------------------------------------------

class BaseCFloat ( BaseFloat ):
    """ Defines a trait whose value must be a Python float and which supports
        coercions of non-float values to float.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = float

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return float( value )
        except:
            self.error( object, name, value )


class CFloat ( BaseCFloat ):
    """ Defines a trait whose value must be a Python float and which supports
        coercions of non-float values to float using a C-level fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 12, float )

#-------------------------------------------------------------------------------
#  'BaseCComplex' and 'CComplex' traits:
#-------------------------------------------------------------------------------

class BaseCComplex ( BaseComplex ):
    """ Defines a trait whose value must be a Python complex and which supports
        coercions of non-complex values to complex.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = complex

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return complex( value )
        except:
            self.error( object, name, value )


class CComplex ( BaseCComplex ):
    """ Defines a trait whose value must be a Python complex and which supports
        coercions of non-complex values to complex using a C-level fast
        validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 12, complex )

#-------------------------------------------------------------------------------
#  'BaseCStr' and 'CStr' traits:
#-------------------------------------------------------------------------------

class BaseCStr ( BaseStr ):
    """ Defines a trait whose value must be a Python string and which supports
        coercions of non-string values to string.
    """

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return str( value )
        except:
            try:
                return unicode( value )
            except:
                self.error( object, name, value )


class CStr ( BaseCStr ):
    """ Defines a trait whose value must be a Python string and which supports
        coercions of non-string values to string using a C-level fast
        validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 7, ( ( 12, str ), ( 12, unicode ) ) )

#-------------------------------------------------------------------------------
#  'BaseCUnicode' and 'CUnicode' traits:
#-------------------------------------------------------------------------------

class BaseCUnicode ( BaseUnicode ):
    """ Defines a trait whose value must be a Python unicode string and which
        supports coercions of non-unicode values to unicode.
    """

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return unicode( value )
        except:
            self.error( object, name, value )


class CUnicode ( BaseCUnicode ):
    """ Defines a trait whose value must be a Python unicode string and which
        supports coercions of non-unicode values to unicode using a C-level
        fast validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 12, unicode )

#-------------------------------------------------------------------------------
#  'BaseCBool' and 'CBool' traits:
#-------------------------------------------------------------------------------

class BaseCBool ( BaseBool ):
    """ Defines a trait whose value must be a Python boolean and which supports
        coercions of non-boolean values to boolean.
    """

    #: The function to use for evaluating strings to this type:
    evaluate = bool

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        try:
            return bool( value )
        except:
            self.error( object, name, value )


class CBool ( BaseCBool ):
    """ Defines a trait whose value must be a Python boolean and which supports
        coercions of non-boolean values to boolean using a C-level fast
        validator.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 12, bool )

#-------------------------------------------------------------------------------
#  'String' trait:
#-------------------------------------------------------------------------------

class String ( TraitType ):
    """ Defines a trait whose value must be a Python string whose length is
        optionally in a specified range, and which optionally matches a
        specified regular expression.
    """

    def __init__ ( self, value = '', minlen = 0, maxlen = sys.maxint,
                   regex = '', **metadata ):
        """ Creates a String trait.

        Parameters
        ----------
        value : str
            The default value for the string.
        minlen : integer
            The minimum length allowed for the string.
        maxlen : integer
            The maximum length allowed for the string.
        regex : str
            A Python regular expression that the string must match.

        """
        super( String, self ).__init__( value, **metadata )
        self.minlen = max( 0, minlen )
        self.maxlen = max( self.minlen, maxlen )
        self.regex  = regex
        self._init()

    def _init ( self ):
        """ Completes initialization of the trait at construction or unpickling
            time.
        """
        self._validate = 'validate_all'
        if self.regex != '':
            self.match = re.compile( self.regex ).match
            if (self.minlen == 0) and (self.maxlen == sys.maxint):
                self._validate = 'validate_regex'
        elif (self.minlen == 0) and (self.maxlen == sys.maxint):
            self._validate = 'validate_str'
        else:
            self._validate = 'validate_len'

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid string.
        """
        return getattr( self, self._validate )( object, name, value )

    def validate_all ( self, object, name, value ):
        """ Validates that the value is a valid string in the specified length
            range which matches the specified regular expression.
        """
        try:
            value = strx( value )
            if ((self.minlen <= len( value ) <= self.maxlen) and
                (self.match( value ) is not None)):
                return value
        except:
            pass

        self.error( object, name, value )

    def validate_str ( self, object, name, value ):
        """ Validates that the value is a valid string.
        """
        try:
            return strx( value )
        except:
            pass

        self.error( object, name, value )

    def validate_len ( self, object, name, value ):
        """ Validates that the value is a valid string in the specified length
            range.
        """
        try:
            value = strx( value )
            if self.minlen <= len( value ) <= self.maxlen:
                return value
        except:
            pass

        self.error( object, name, value )

    def validate_regex ( self, object, name, value ):
        """ Validates that the value is a valid string which matches the
            specified regular expression.
        """
        try:
            value = strx( value )
            if self.match( value ) is not None:
                return value
        except:
            pass

        self.error( object, name, value )

    def info ( self ):
        """ Returns a description of the trait.
        """
        msg = ''
        if (self.minlen != 0) and (self.maxlen != sys.maxint):
            msg = ' between %d and %d characters long' % (
                  self.minlen, self.maxlen )
        elif self.maxlen != sys.maxint:
            msg = ' <= %d characters long' % self.maxlen
        elif self.minlen != 0:
            msg = ' >= %d characters long' % self.minlen
        if self.regex != '':
            if msg != '':
                msg += ' and'
            msg += (" matching the pattern '%s'" % self.regex)
        return 'a string' + msg

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        return default_text_editor( self )

    def __getstate__ ( self ):
        """ Returns the current state of the trait.
        """
        result = self.__dict__.copy()
        for name in [ 'validate', 'match' ]:
            if name in result:
                del result[ name ]

        return result

    def __setstate__ ( self, state ):
        """ Sets the current state of the trait.
        """
        self.__dict__.update( state )
        self._init()

#-------------------------------------------------------------------------------
#  'Regex' trait:
#-------------------------------------------------------------------------------

class Regex ( String ):
    """ Defines a trait whose value is a Python string that matches a specified
        regular expression.
    """

    def __init__ ( self, value = '', regex = '.*', **metadata ):
        """ Creates a Regex trait.

        Parameters
        ----------
        value : str
            The default value of the trait.
        regex : str
            The regular expression that the trait value must match.

        Default Value
        -------------
        *value* or ''
        """
        super( Regex, self ).__init__( value = value, regex = regex,
                                       **metadata )

#-------------------------------------------------------------------------------
#  'Code' trait:
#-------------------------------------------------------------------------------

class Code ( String ):
    """ Defines a trait whose value is a Python string that represents source
        code in some language.
    """

    #: The standard metadata for the trait:
    metadata = { 'editor': code_editor }

#-------------------------------------------------------------------------------
#  'HTML' trait:
#-------------------------------------------------------------------------------

class HTML ( String ):
    """ Defines a trait whose value must be a string that is interpreted as
    being HTML. By default the value is parsed and displayed as HTML in
    TraitsUI views. The validation of the value does not enforce HTML syntax.
    """

    #: The standard metadata for the trait:
    metadata = { 'editor': html_editor }

#-------------------------------------------------------------------------------
#  'Password' trait:
#-------------------------------------------------------------------------------

class Password ( String ):
    """ Defines a trait whose value must be a string, optionally of constrained
    length or matching a regular expression.

    The trait is identical to a String trait except that by default it uses a
    PasswordEditor in TraitsUI views, which obscures text entered by the user.
    """

    #: The standard metadata for the trait:
    metadata = { 'editor': password_editor }

#-------------------------------------------------------------------------------
#  'Callable' trait:
#-------------------------------------------------------------------------------

class Callable ( TraitType ):
    """ Defines a trait whose value must be a Python callable.
    """

    #: The standard metadata for the trait:
    metadata = { 'copy': 'ref' }

    #: The default value for the trait:
    default_value = None

    #: A description of the type of value this trait accepts:
    info_text = 'a callable value'

    def validate ( self, object, name, value ):
        """ Validates that the value is a Python callable.
        """
        if (value is None) or callable( value ):
            return value

        self.error( object, name, value )

#-------------------------------------------------------------------------------
#  'BaseType' base class:
#-------------------------------------------------------------------------------

class BaseType ( TraitType ):
    """ Defines a trait whose value must be an instance of a simple Python type.
    """

    def validate ( self, object, name, value ):
        """ Validates that the value is a Python callable.
        """
        if isinstance( value, self.fast_validate[1:] ):
            return value

        self.error( object, name, value )


class This ( BaseType ):
    """ Defines a trait whose value must be an instance of the defining class.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 2, )

    #: A description of the type of value this trait accepts:
    info_text = 'an instance of the same type as the receiver'

    def __init__ ( self, value = None, allow_none = True, **metadata ):
        super( This, self ).__init__( value, **metadata )

        if allow_none:
            self.fast_validate = ( 2, None )
            self.validate      = self.validate_none
            self.info          = self.info_none

    def validate ( self, object, name, value ):
        if isinstance( value, object.__class__ ):
            return value

        self.validate_failed( object, name, value )

    def validate_none ( self, object, name, value ):
        if isinstance( value, object.__class__ ) or (value is None):
            return value

        self.validate_failed( object, name, value )

    def info ( self ):
        return 'an instance of the same type as the receiver'

    def info_none ( self ):
        return 'an instance of the same type as the receiver or None'

    def validate_failed ( self, object, name, value ):
        kind = type( value )
        if _py2to3.is_InstanceType(kind):
            msg = 'class %s' % value.__class__.__name__
        else:
            msg = '%s (i.e. %s)' % ( str( kind )[1:-1], repr( value ) )

        self.error( object, name, msg )


class self ( This ):
    """ Defines a trait whose value must be an instance of the defining class
        and whose default value is the object containing the trait.
    """

    #: The default value type to use (i.e. 'self'):
    default_value_type = 2


class Function ( TraitType ):
    """ Defines a trait whose value must be a Python function.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 11, FunctionType )

    #: A description of the type of value this trait accepts:
    info_text = 'a function'


class Method ( TraitType ):
    """ Defines a trait whose value must be a Python method.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 11, MethodType )

    #: A description of the type of value this trait accepts:
    info_text = 'a method'

if sys.version_info[0] < 3:
    from types import ClassType
    
    class Class ( TraitType ):
        """ Defines a trait whose value must be an old-style Python class.
        """

        #: The C-level fast validator to use:
        fast_validate = ( 11, ClassType )

        #: A description of the type of value this trait accepts:
        info_text = 'an old-style class'


class Module ( TraitType ):
    """ Defines a trait whose value must be a Python module.
    """

    #: The C-level fast validator to use:
    fast_validate = ( 11, ModuleType )

    #: A description of the type of value this trait accepts:
    info_text = 'a module'

#-------------------------------------------------------------------------------
#  'Python' trait:
#-------------------------------------------------------------------------------

class Python ( TraitType ):
    """ Defines a trait that provides behavior identical to a standard Python
        attribute. That is, it allows any value to be assigned, and raises an
        ValueError if an attempt is made to get the value before one has been
        assigned. It has no default value. This trait is most often used in
        conjunction with wildcard naming. See the *Traits User Manual* for
        details on wildcards.
    """

    #: The standard metadata for the trait:
    metadata = { 'type': 'python' }

    #: The default value for the trait:
    default_value = Undefined

#-------------------------------------------------------------------------------
#  'ReadOnly' trait:
#-------------------------------------------------------------------------------

class ReadOnly ( TraitType ):
    """ Defines a trait that is write-once, and then read-only.
        The initial value of the attribute is the special, singleton object
        Undefined. The trait allows any value to be assigned to the attribute
        if the current value is the Undefined object. Once any other value is
        assigned, no further assignment is allowed. Normally, the initial
        assignment to the attribute is performed in the class constructor,
        based on information passed to the constructor. If the read-only value
        is known in advance of run time, use the Constant() function instead of
        ReadOnly to define the trait.
    """

    # Defines the CTrait type to use for this trait:
    ctrait_type = 6

    #: The default value for the trait:
    default_value = Undefined

# Create a singleton instance as the trait:
ReadOnly = ReadOnly()

#-------------------------------------------------------------------------------
#  'Disallow' trait:
#-------------------------------------------------------------------------------

class Disallow ( TraitType ):
    """ Defines a trait that prevents any value from being assigned or read.
        That is, any attempt to get or set the value of the trait attribute
        raises an exception. This trait is most often used in conjunction with
        wildcard naming, for example, to catch spelling mistakes in attribute
        names. See the *Traits User Manual* for details on wildcards.
    """

    #: Defines the CTrait type to use for this trait:
    ctrait_type = 5

# Create a singleton instance as the trait:
Disallow = Disallow()

#-------------------------------------------------------------------------------
#  'Constant' trait:
#-------------------------------------------------------------------------------

class Constant ( TraitType ):
    """  Defines a trait whose value is a constant.
    """

    #: Defines the CTrait type to use for this trait:
    ctrait_type = 7

    #: The standard metadata for the trait:
    metadata = { 'type': 'constant', 'transient': True }

    def __init__ ( self, value, **metadata ):
        """ Returns a constant, read-only trait whose value is *value*.

            Parameters
            ----------
            value : any type except a list or dictionary
                The default value for the trait.

            Default Value
            -------------
            *value*

            Description
            -----------
            Traits of this type are very space efficient (and fast) because
            *value* is not stored in each instance using the trait, but only in
            the trait object itself. The *value* cannot be a list or dictionary,
            because those types have mutable values.
        """
        if type( value ) in MutableTypes:
            raise TraitError, \
                  "Cannot define a constant using a mutable list or dictionary"

        super( Constant, self ).__init__( value, **metadata )

#-------------------------------------------------------------------------------
#  'Delegate' trait:
#-------------------------------------------------------------------------------

class Delegate ( TraitType ):
    """ Defines a trait whose value is delegated to a trait on another object.
    """

    #: Defines the CTrait type to use for this trait:
    ctrait_type = 3

    #: The standard metadata for the trait:
    metadata = { 'type': 'delegate', 'transient': False }

    def __init__ ( self, delegate, prefix = '', modify = False,
                         listenable = True, **metadata ):
        """ Creates a Delegate trait.
        """
        if prefix == '':
            prefix_type = 0
        elif prefix[-1:] != '*':
            prefix_type = 1
        else:
            prefix = prefix[:-1]
            if prefix != '':
                prefix_type = 2
            else:
                prefix_type = 3

        metadata[ '_delegate' ]   = delegate
        metadata[ '_prefix' ]     = prefix
        metadata[ '_listenable' ] = listenable

        super( Delegate, self ).__init__( **metadata )

        self.delegate    = delegate
        self.prefix      = prefix
        self.prefix_type = prefix_type
        self.modify      = modify

    def as_ctrait ( self ):
        """ Returns a CTrait corresponding to the trait defined by this class.
        """
        trait = super( Delegate, self ).as_ctrait()
        trait.delegate( self.delegate, self.prefix, self.prefix_type,
                        self.modify )

        return trait

#-------------------------------------------------------------------------------
#  'DelegatesTo' trait:
#-------------------------------------------------------------------------------

class DelegatesTo ( Delegate ):
    """ Defines a trait delegate that matches the standard 'delegate' design
        pattern.
    """

    def __init__ ( self, delegate, prefix = '', listenable = True, **metadata ):
        """ Creates a "delegator" trait, whose definition and default value are
            delegated to a *delegate* trait attribute on another object.

            Parameters
            ----------
            delegate : str
                Name of the attribute on the current object which references
                the object that is the trait's delegate.
            prefix : str
                A prefix or substitution applied to the original attribute when
                looking up the delegated attribute.
            listenable : bool
                Indicates whether a listener can be attached to this attribute
                such that changes to the delagate attribute will trigger it.

            Description
            -----------
            An object containing a delegator trait attribute must contain a
            second attribute that references the object containing the delegate
            trait attribute. The name of this second attribute is passed as the
            *delegate* argument to the DelegatesTo() function.

            The following rules govern the application of the prefix parameter:

            * If *prefix* is empty or omitted, the delegation is to an attribute
              of the delegate object with the same name as the delegator
              attribute.
            * If *prefix* is a valid Python attribute name, then the delegation
              is to an attribute whose name is the value of *prefix*.
            * If *prefix* ends with an asterisk ('*') and is longer than one
              character, then the delegation is to an attribute whose name is
              the value of *prefix*, minus the trailing asterisk, prepended to
              the delegator attribute name.
            * If *prefix* is equal to a single asterisk, the delegation is to an
              attribute whose name is the value of the delegator object's
              __prefix__ attribute prepended to delegator attribute name.

            Note that any changes to the delegator attribute are actually
            applied to the corresponding attribute on the delegate object. The
            original object containing the delegator trait is not modified.
        """
        super( DelegatesTo, self ).__init__( delegate,
                                             prefix     = prefix,
                                             modify     = True,
                                             listenable = listenable,
                                             **metadata )

#-------------------------------------------------------------------------------
#  'PrototypedFrom' trait:
#-------------------------------------------------------------------------------

class PrototypedFrom ( Delegate ):
    """ Defines a trait delegate that matches the standard 'prototype' design
        pattern.
    """

    def __init__ ( self, prototype, prefix = '', listenable = True,
                         **metadata ):
        """ Creates a "prototyped" trait, whose definition and default value are
            obtained from a trait attribute on another object.

            Parameters
            ----------
            prototype : str
                Name of the attribute on the current object which references the
                object that is the trait's prototype.
            prefix : str
                A prefix or substitution applied to the original attribute when
                looking up the prototyped attribute.
            listenable : bool
                Indicates whether a listener can be attached to this attribute
                such that changes to the corresponding attribute on the
                prototype object will trigger it.

            Description
            -----------
            An object containing a prototyped trait attribute must contain a
            second attribute that references the object containing the prototype
            trait attribute. The name of this second attribute is passed as the
            *prototype* argument to the PrototypedFrom() function.

            The following rules govern the application of the prefix parameter:

            * If *prefix* is empty or omitted, the prototype delegation is to an
              attribute of the prototype object with the same name as the
              prototyped attribute.
            * If *prefix* is a valid Python attribute name, then the prototype
              delegation is to an attribute whose name is the value of *prefix*.
            * If *prefix* ends with an asterisk ('*') and is longer than one
              character, then the prototype delegation is to an attribute whose
              name is the value of *prefix*, minus the trailing asterisk,
              prepended to the prototyped attribute name.
            * If *prefix* is equal to a single asterisk, the prototype
              delegation is to an attribute whose name is the value of the
              prototype object's __prefix__ attribute prepended to the
              prototyped attribute name.

            Note that any changes to the prototyped attribute are made to the
            original object, not the prototype object. The prototype object is
            only used to define to trait type and default value.

        """
        super( PrototypedFrom, self ).__init__( prototype,
                                                prefix     = prefix,
                                                modify     = False,
                                                listenable = listenable,
                                                **metadata )

#-------------------------------------------------------------------------------
#  'Expression' class:
#-------------------------------------------------------------------------------

class Expression ( TraitType ):
    """ Defines a trait whose value must be a valid Python expression. The
        compiled form of a valid expression is stored as the mapped value of
        the trait.
    """

    #: The default value for the trait:
    default_value = '0'

    #: A description of the type of value this trait accepts:
    info_text = 'a valid Python expression'

    #: Indicate that this is a mapped trait:
    is_mapped = True

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.
        """
        try:
            return compile( value, '<string>', 'eval' )
        except:
            self.error( object, name, value )

    def post_setattr ( self, object, name, value ):
        """ Performs additional post-assignment processing.
        """
        object.__dict__[ name + '_' ] = value

    def mapped_value ( self, value ):
        """ Returns the 'mapped' value for the specified **value**.
        """
        return compile( value, '<string>', 'eval' )

    def as_ctrait ( self ):
        """ Returns a CTrait corresponding to the trait defined by this class.
        """
        # Tell the C code that 'setattr' should store the original, unadapted
        # value passed to it:
        return super( Expression, self
                    ).as_ctrait().setattr_original_value( True )

#-------------------------------------------------------------------------------
#  'PythonValue' trait:
#-------------------------------------------------------------------------------

class PythonValue ( Any ):
    """ Defines a trait whose value can be of any type, and whose default
    editor is a Python shell.
    """

    #: The standard metadata for the trait:
    metadata = { 'editor': shell_editor }

#-------------------------------------------------------------------------------
#  'BaseFile' and 'File' traits:
#-------------------------------------------------------------------------------

class BaseFile ( BaseStr ):
    """ Defines a trait whose value must be the name of a file.
    """

    #: A description of the type of value this trait accepts:
    info_text = 'a file name'

    def __init__ ( self, value = '', filter = None, auto_set = False,
                         entries = 0, exists = False, **metadata ):
        """ Creates a File trait.

        Parameters
        ----------
        value : str
            The default value for the trait.
        filter : str
            A wildcard string to filter filenames in the file dialog box used by
            the attribute trait editor.
        auto_set : bool
            Indicates whether the file editor updates the trait value after
            every key stroke.
        exists : bool
            Indicates whether the trait value must be an existing file or
            not.

        Default Value
        -------------
        *value* or ''
        """
        self.filter = filter
        self.auto_set = auto_set
        self.entries = entries
        self.exists = exists

        super( BaseFile, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        validated_value = super( BaseFile, self ).validate( object, name, value )
        if not self.exists:
            return validated_value
        elif isfile( value ):
            return validated_value

        self.error( object, name, value )

    def create_editor(self):
        from traitsui.editors.file_editor import FileEditor
        editor = FileEditor(
            filter = self.filter or [],
            auto_set = self.auto_set,
            entries = self.entries,
        )
        return editor


class File ( BaseFile ):
    """ Defines a trait whose value must be the name of a file using a C-level
        fast validator.
    """

    def __init__ ( self, value = '', filter = None, auto_set = False,
                         entries = 0, exists = False, **metadata ):
        """ Creates a File trait.

        Parameters
        ----------
        value : str
            The default value for the trait.
        filter : str
            A wildcard string to filter filenames in the file dialog box used
            by the attribute trait editor.
        auto_set : bool
            Indicates whether the file editor updates the trait value after
            every key stroke.
        exists : bool
            Indicates whether the trait value must be an existing file or
            not.

        Default Value
        -------------
        *value* or ''
        """
        if not exists:
            # Define the C-level fast validator to use:
            fast_validate = ( 11, basestring )

        super( File, self ).__init__( value, filter, auto_set, entries, exists,
                                      **metadata )

#-------------------------------------------------------------------------------
#  'BaseDirectory' and 'Directory' traits:
#-------------------------------------------------------------------------------

class BaseDirectory ( BaseStr ):
    """ Defines a trait whose value must be the name of a directory.
    """

    #: A description of the type of value this trait accepts:
    info_text = 'a directory name'

    def __init__ ( self, value = '', auto_set = False, entries = 0,
                         exists = False, **metadata ):
        """ Creates a BaseDirectory trait.

        Parameters
        ----------
        value : str
            The default value for the trait.
        auto_set : bool
            Indicates whether the directory editor updates the trait value
            after every key stroke.
        exists : bool
            Indicates whether the trait value must be an existing directory or
            not.

        Default Value
        -------------
        *value* or ''
        """
        self.entries = entries
        self.auto_set = auto_set
        self.exists = exists

        super( BaseDirectory, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.

            Note: The 'fast validator' version performs this check in C.
        """
        if not self.exists:
            return super( BaseDirectory, self ).validate( object, name, value )

        if isdir( value ):
            return value

        self.error( object, name, value )

    def create_editor(self):
        from traitsui.editors.directory_editor import DirectoryEditor
        editor = DirectoryEditor(
            auto_set = self.auto_set,
            entries = self.entries,
        )
        return editor


class Directory ( BaseDirectory ):
    """ Defines a trait whose value must be the name of a directory using a
        C-level fast validator.
    """

    def __init__ ( self, value = '', auto_set = False, entries = 0,
                         exists = False, **metadata ):
        """ Creates a Directory trait.

        Parameters
        ----------
        value : str
            The default value for the trait.
        auto_set : bool
            Indicates whether the directory editor updates the trait value
            after every key stroke.
        exists : bool
            Indicates whether the trait value must be an existing directory or
            not.

        Default Value
        -------------
        *value* or ''
        """
        # Define the C-level fast validator to use if the directory existence
        #: test is not required:
        if not exists:
            self.fast_validate = ( 11, basestring )

        super( Directory, self ).__init__( value, auto_set, entries, exists,
                                           **metadata )

#-------------------------------------------------------------------------------
#  'BaseRange' and 'Range' traits:
#-------------------------------------------------------------------------------

class BaseRange ( TraitType ):
    """ Defines a trait whose numeric value must be in a specified range.
    """

    def __init__ ( self, low = None, high = None, value = None,
                         exclude_low = False, exclude_high = False,
                         **metadata ):
        """ Creates a Range trait.

        Parameters
        ----------
        low : integer, float or string (i.e. extended trait name)
            The low end of the range.
        high : integer, float or string (i.e. extended trait name)
            The high end of the range.
        value : integer, float or string (i.e. extended trait name)
            The default value of the trait.
        exclude_low : bool
            Indicates whether the low end of the range is exclusive.
        exclude_high : bool
            Indicates whether the high end of the range is exclusive.

        The *low*, *high*, and *value* arguments must be of the same type
        (integer or float), except in the case where either *low* or *high* is
        a string (i.e. extended trait name).

        Default Value
        -------------
        *value*; if *value* is None or omitted, the default value is *low*,
        unless *low* is None or omitted, in which case the default value is
        *high*.
        """
        if value is None:
            if low is not None:
                value = low
            else:
                value = high

        super( BaseRange, self ).__init__( value, **metadata )

        vtype = type( high )
        if ((low is not None) and
            (not issubclass( vtype, ( float, basestring ) ))):
            vtype = type( low )

        is_static = (not issubclass( vtype, basestring ))
        if is_static and (vtype not in RangeTypes):
            raise TraitError, ("Range can only be use for int, long or float "
                               "values, but a value of type %s was specified." %
                               vtype)

        self._low_name = self._high_name = ''
        self._vtype    = Undefined

        if vtype is float:
            self._validate  = 'float_validate'
            kind            = 4
            self._type_desc = 'a floating point number'
            if low is not None:
                low = float( low )

            if high is not None:
                high = float( high )

        elif vtype is long:
            self._validate  = 'long_validate'
            self._type_desc = 'a long integer'
            if low is not None:
                low = long( low )

            if high is not None:
                high = long( high )

        elif vtype is int:
            self._validate  = 'int_validate'
            kind            = 3
            self._type_desc = 'an integer'
            if low is not None:
                low = int( low )

            if high is not None:
                high = int( high )
        else:
            self.get, self.set, self.validate = self._get, self._set, None
            self._vtype     = None
            self._type_desc = 'a number'

            if isinstance( high, basestring ):
                self._high_name = high = 'object.' + high
            else:
                self._vtype = type( high )
            high = compile( str( high ), '<string>', 'eval' )

            if isinstance( low, basestring ):
                self._low_name = low = 'object.' + low
            else:
                self._vtype = type( low )
            low = compile( str( low ), '<string>', 'eval' )

            if isinstance( value, basestring ):
                value = 'object.' + value
            self._value = compile( str( value ), '<string>', 'eval' )

            self.default_value_type = 8
            self.default_value      = self._get_default_value

        exclude_mask = 0
        if exclude_low:
            exclude_mask |= 1

        if exclude_high:
            exclude_mask |= 2

        if is_static and (vtype is not long):
            self.init_fast_validator( kind, low, high, exclude_mask )

        #: Assign type-corrected arguments to handler attributes:
        self._low          = low
        self._high         = high
        self._exclude_low  = exclude_low
        self._exclude_high = exclude_high

    def init_fast_validator ( self, *args ):
        """ Does nothing for the BaseRange class. Used in the Range class to
            set up the fast validator.
        """
        pass

    def validate ( self, object, name, value ):
        """ Validate that the value is in the specified range.
        """
        return getattr( self, self._validate )( object, name, value )

    def float_validate ( self, object, name, value ):
        """ Validate that the value is a float value in the specified range.
        """
        try:
            if (isinstance( value, RangeTypes ) and
                ((self._low is None) or
                 (self._exclude_low and (self._low < value)) or
                 ((not self._exclude_low) and (self._low <= value))) and
                ((self._high is None) or
                 (self._exclude_high and (self._high > value)) or
                 ((not self._exclude_high) and (self._high >= value)))):
               return float( value )
        except:
            pass

        self.error( object, name, value )

    def int_validate ( self, object, name, value ):
        """ Validate that the value is an int value in the specified range.
        """
        try:
            if (isinstance( value, int_fast_validate[1:]) and
                ((self._low is None) or
                 (self._exclude_low and (self._low < value)) or
                 ((not self._exclude_low) and (self._low <= value))) and
                ((self._high is None) or
                 (self._exclude_high and (self._high > value)) or
                 ((not self._exclude_high) and (self._high >= value)))):
               return value
        except:
            pass

        self.error( object, name, value )

    def long_validate ( self, object, name, value ):
        """ Validate that the value is a long value in the specified range.
        """
        try:
            valid_types = list(long_fast_validate[1:])
            valid_types.remove(None)
            if (isinstance( value, tuple(valid_types) ) and
                ((self._low is None) or
                 (self._exclude_low and (self._low < value)) or
                 ((not self._exclude_low) and (self._low <= value))) and
                ((self._high is None) or
                 (self._exclude_high and (self._high > value)) or
                 ((not self._exclude_high) and (self._high >= value)))):
               return value
        except:
            pass

        self.error( object, name, value )

    def _get_default_value ( self, object ):
        """ Returns the default value of the range.
        """
        return eval( self._value )

    def _get ( self, object, name, trait ):
        """ Returns the current value of a dynamic range trait.
        """
        cname = '_traits_cache_' + name
        value = object.__dict__.get( cname, Undefined )
        if value is Undefined:
            object.__dict__[ cname ] = value = eval( self._value )

        low  = eval( self._low )
        high = eval( self._high )
        if (low is not None) and (value < low):
            value = low
        elif (high is not None) and (value > high):
            value = high

        return self._typed_value( value, low, high )

    def _set ( self, object, name, value ):
        """ Sets the current value of a dynamic range trait.
        """
        if not isinstance( value, basestring ):
            try:
                low  = eval( self._low )
                high = eval( self._high )
                if (low is None) and (high is None):
                    if isinstance( value, RangeTypes ):
                        self._set_value( object, name, value )
                        return
                else:
                    new_value = self._typed_value( value, low, high )
                    if (((low is None) or
                        (self._exclude_low and (low < new_value)) or
                        ((not self._exclude_low) and (low <= new_value))) and
                        ((high is None) or
                        (self._exclude_high and (high > new_value)) or
                        ((not self._exclude_high) and (high >= new_value)))):
                        self._set_value( object, name, new_value )
                        return
            except:
                pass

        self.error( object, name, value )

    def _typed_value ( self, value, low, high ):
        """ Returns the specified value with the correct type for the current
            dynamic range.
        """
        vtype = self._vtype
        if vtype is None:
            if low is not None:
                vtype = type( low )
            elif high is not None:
                vtype = type( high )
            else:
                vtype = lambda x: x

        return vtype( value )

    def _set_value ( self, object, name, value ):
        """ Sets the specified value as the value of the dynamic range.
        """
        cname = '_traits_cache_' + name
        old   = object.__dict__.get( cname, Undefined )
        if old is Undefined:
            old = eval( self._value )
        object.__dict__[ cname ] = value
        if value != old:
            object.trait_property_changed( name, old, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        if self._vtype is not Undefined:
            low       = eval( self._low )
            high      = eval( self._high )
            low, high = ( self._typed_value( low,  low, high ),
                          self._typed_value( high, low, high ) )
        else:
            low  = self._low
            high = self._high

        if low is None:
            if high is None:
                return self._type_desc

            return '%s <%s %s' % (
                   self._type_desc, '='[ self._exclude_high: ], high )

        elif high is None:
            return  '%s >%s %s' % (
                    self._type_desc, '='[ self._exclude_low: ], low )

        return '%s <%s %s <%s %s' % (
               low, '='[ self._exclude_low: ], self._type_desc,
               '='[ self._exclude_high: ], high )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        # fixme: Needs to support a dynamic range editor.

        auto_set = self.auto_set
        if auto_set is None:
            auto_set = True

        from traitsui.api import RangeEditor

        return RangeEditor( self,
                            mode       = self.mode or 'auto',
                            cols       = self.cols or 3,
                            auto_set   = auto_set,
                            enter_set  = self.enter_set or False,
                            low_label  = self.low  or '',
                            high_label = self.high or '',
                            low_name   = self._low_name,
                            high_name  = self._high_name )


class Range ( BaseRange ):
    """ Defines a trait whose numeric value must be in a specified range using
        a C-level fast validator.
    """

    def init_fast_validator ( self, *args ):
        """ Set up the C-level fast validator.
        """
        self.fast_validate = args

#-------------------------------------------------------------------------------
#  'BaseEnum' and 'Enum' traits:
#-------------------------------------------------------------------------------

class BaseEnum ( TraitType ):
    """ Defines a trait whose value must be one of a specified set of values.
    """

    def __init__ ( self, *args, **metadata ):
        """ Returns an Enum trait.

        Parameters
        ----------
        values : list or tuple
            The enumeration of all legal values for the trait

        Default Value
        -------------
        values[0]
        """
        values = metadata.pop( 'values', None )
        if isinstance( values, basestring ):
            n = len( args )
            if n == 0:
                default_value = None
            elif n == 1:
                default_value = args[0]
            else:
                raise TraitError( "Incorrect number of arguments specified "
                                  "when using the 'values' keyword" )
            self.name   = values
            self.values = compile( 'object.' + values, '<string>', 'eval' )
            self.get, self.set, self.validate = self._get, self._set, None
        else:
            default_value = args[0]
            if (len( args ) == 1) and isinstance( default_value, SequenceTypes):
                args          = default_value
                default_value = args[0]
            elif (len( args ) == 2) and isinstance( args[1], SequenceTypes ):
                args = args[1]

            self.name   = ''
            self.values = tuple( args )
            self.init_fast_validator( 5, self.values )

        super( BaseEnum, self ).__init__( default_value, **metadata )

    def init_fast_validator ( self, *args ):
        """ Does nothing for the BaseEnum class. Used in the Enum class to set
            up the fast validator.
        """
        pass

    def validate ( self, object, name, value ):
        """ Validates that the value is one of the enumerated set of valid
            values.
        """
        if value in self.values:
            return value

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        if self.name == '':
            values = self.values
        else:
            values = eval( self.values )

        return ' or '.join( [ repr( x ) for x in values ] )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        from traitsui.api import EnumEditor

        values = self
        if self.name != '':
            values = None

        return EnumEditor( values   = values,
                           name     = self.name,
                           cols     = self.cols or 3,
                           evaluate = self.evaluate,
                           mode     = self.mode or 'radio' )

    def _get ( self, object, name, trait ):
        """ Returns the current value of a dynamic enum trait.
        """
        value  = self.get_value( object, name, trait )
        values = eval( self.values )
        if value not in values:
            value = None
            if len( values ) > 0:
                value = values[0]

        return value

    def _set ( self, object, name, value ):
        """ Sets the current value of a dynamic range trait.
        """
        if value in eval( self.values ):
            self.set_value( object, name, value )
        else:
            self.error( object, name, value )

class Enum ( BaseEnum ):
    """ Defines a trait whose value must be one of a specified set of values
        using a C-level fast validator.
    """

    def init_fast_validator ( self, *args ):
        """ Set up the C-level fast validator.
        """
        self.fast_validate = args

#-------------------------------------------------------------------------------
#  'BaseTuple' and 'Tuple' traits:
#-------------------------------------------------------------------------------

class BaseTuple ( TraitType ):
    """ Defines a trait whose value must be a tuple of specified trait types.
    """

    def __init__ ( self, *types, **metadata ):
        """ Returns a Tuple trait.

        Parameters
        ----------
        types : zero or more arguments
            Definition of the default and allowed tuples. If the first item of
            *types* is a tuple, it is used as the default value.
            The remaining argument list is used to form a tuple that constrains
            the  values assigned to the returned trait. The trait's value must
            be a tuple of the same length as the remaining argument list, whose
            elements must match the types specified by the corresponding items
            of the remaining argument list.

        Default Value
        -------------
         1. If no arguments are specified, the default value is ().
         2. If a tuple is specified as the first argument, it is the default
            value.
         3. If a tuple is not specified as the first argument, the default
            value is a tuple whose length is the length of the argument list,
            and whose values are the default values for the corresponding trait
            types.

        Example for case #2::

            mytuple = Tuple(('Fred', 'Betty', 5))

        The trait's value must be a 3-element tuple whose first and second
        elements are strings, and whose third element is an integer. The
        default value is ('Fred', 'Betty', 5).

        Example for case #3::

            mytuple = Tuple('Fred', 'Betty', 5)

        The trait's value must be a 3-element tuple whose first and second
        elements are strings, and whose third element is an integer. The
        default value is ('','',0).
        """
        if len( types ) == 0:
            self.init_fast_validator( 11, tuple, None, list )

            super( BaseTuple, self ).__init__( (), **metadata )

            return

        default_value = None

        if isinstance( types[0], tuple ):
            default_value, types = types[0], types[1:]
            if len( types ) == 0:
                types = [ Trait( element ) for element in default_value ]

        self.types = tuple( [ trait_from( type ) for type in types ] )
        self.init_fast_validator( 9, self.types )

        if default_value is None:
            default_value = tuple( [ type.default_value()[1]
                                     for type in self.types ] )

        super( BaseTuple, self ).__init__( default_value, **metadata )

    def init_fast_validator ( self, *args ):
        """ Saves the validation parameters.
        """
        self.no_type_check = (args[0] == 11)

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid tuple.
        """
        if self.no_type_check:
            if isinstance( value, tuple ):
                return value

            if isinstance( value, list ):
                return tuple( value )

            self.error( object, name, value )

        try:
            if isinstance( value, list ):
                value = tuple( value )

            if isinstance( value, tuple ):
                types = self.types
                if len( value ) == len( types ):
                    values = []
                    for i, type in enumerate( types ):
                        values.append( type.validate( object, name, value[i] ) )

                    return tuple( values )
        except:
            pass

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        if self.no_type_check:
            return 'a tuple'

        return 'a tuple of the form: (%s)' % (', '.join(
            [ type.full_info( object, name, value )
              for type in self.types ] ))

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        from traitsui.api import TupleEditor

        auto_set = self.auto_set
        if auto_set is None:
            auto_set = True
        enter_set = self.enter_set or False

        return TupleEditor( types     = self.types,
                            labels    = self.labels or [],
                            cols      = self.cols or 1,
                            auto_set  = auto_set,
                            enter_set = enter_set )

class Tuple ( BaseTuple ):
    """ Defines a trait whose value must be a tuple of specified trait types
        using a C-level fast validator.
    """

    def init_fast_validator ( self, *args ):
        """ Set up the C-level fast validator.
        """
        super( Tuple, self ).init_fast_validator( *args )

        self.fast_validate = args

#-------------------------------------------------------------------------------
#  'List' trait:
#-------------------------------------------------------------------------------

class List ( TraitType ):
    """ Defines a trait whose value must be a list whose items are of the
        specified trait type.
    """

    info_trait         = None
    default_value_type = 5
    _items_event       = None

    def __init__ ( self, trait = None, value = None, minlen = 0,
                   maxlen = sys.maxint, items = True, **metadata ):
        """ Returns a List trait.

        Parameters
        ----------
        trait : a trait or value that can be converted to a trait using Trait()
            The type of item that the list contains. If not specified, the list
            can contain items of any type.
        value : list
            Default value for the list.
        minlen : integer
            The minimum length of a list that can be assigned to the trait.
        maxlen : integer
            The maximum length of a list that can be assigned to the trait.

        The length of the list assigned to the trait must be such that::

            minlen <= len(list) <= maxlen

        Default Value
        -------------
        *value* or None
        """
        metadata.setdefault( 'copy', 'deep' )

        if isinstance( trait, SequenceTypes ):
            trait, value = value, list( trait )

        if value is None:
            value = []

        self.item_trait = trait_from( trait )
        self.minlen     = max( 0, minlen )
        self.maxlen     = max( minlen, maxlen )
        self.has_items  = items

        if self.item_trait.instance_handler == '_instance_changed_handler':
            metadata.setdefault( 'instance_handler', '_list_changed_handler' )

        super( List, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that the values is a valid list.

        .. note::

            `object` can be None when validating a default value (see e.g.
            :meth:`~traits.trait_handlers.TraitType.clone`)

        """
        if (isinstance( value, list ) and
           (self.minlen <= len( value ) <= self.maxlen)):
            if object is None:
                return value

            return TraitListObject( self, object, name, value )

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        if self.minlen == 0:
            if self.maxlen == sys.maxint:
                size = 'items'
            else:
                size = 'at most %d items' % self.maxlen
        else:
            if self.maxlen == sys.maxint:
                size = 'at least %d items' % self.minlen
            else:
                size = 'from %s to %s items' % (
                       self.minlen, self.maxlen )

        return 'a list of %s which are %s' % (
                   size, self.item_trait.full_info( object, name, value ) )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        handler = self.item_trait.handler
        if isinstance( handler, TraitInstance ) and (self.mode != 'list'):
            from .api import HasTraits

            if issubclass( handler.aClass, HasTraits ):
                from traitsui.api import TableEditor

                return TableEditor()

        from traitsui.api import ListEditor

        return ListEditor( trait_handler = self,
                           rows          = self.rows or 5,
                           use_notebook  = self.use_notebook is True,
                           page_name     = self.page_name or '' )

    def inner_traits ( self ):
        """ Returns the *inner trait* (or traits) for this trait.
        """
        return ( self.item_trait, )

    #-- Private Methods --------------------------------------------------------

    def items_event ( self ):
        return items_event()

#-------------------------------------------------------------------------------
#  'CList' trait:
#-------------------------------------------------------------------------------

class CList ( List ):
    """ Defines a trait whose values must be a list whose items are of the
        specified trait type or which can be coerced to a list whose values are
        of the specified trait type.
    """

    def validate ( self, object, name, value ):
        """ Validates that the values is a valid list.
        """
        if not isinstance( value, list ):
            try:
                # Should work for all iterables as well as strings (which do
                # not define an __iter__ method)
                value = list( value )
            except (ValueError, TypeError):
                value = [ value ]

        return super( CList, self ).validate( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        return '%s or %s' % (
                   self.item_trait.full_info( object, name, value),
                   super( CList, self ).full_info( object, name, value ) )

#-------------------------------------------------------------------------------
#  'Set' trait:
#-------------------------------------------------------------------------------

class Set ( TraitType ):
    """ Defines a trait whose value must be a set whose items are of the
        specified trait type.
    """

    info_trait         = None
    default_value_type = 9
    _items_event       = None

    def __init__ ( self, trait = None, value = None, items = True, **metadata ):
        """ Returns a Set trait.

        Parameters
        ----------
        trait : a trait or value that can be converted to a trait using Trait()
            The type of item that the list contains. If not specified, the list
            can contain items of any type.
        value : set
            Default value for the set.

        Default Value
        -------------
        *value* or None
        """
        metadata.setdefault( 'copy', 'deep' )

        if isinstance( trait, SetTypes ):
            trait, value = value, set( trait )

        if value is None:
            value = set()

        self.item_trait = trait_from( trait )
        self.has_items  = items

        super( Set, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that the values is a valid set.

        .. note::

            `object` can be None when validating a default value (see e.g.
            :meth:`~traits.trait_handlers.TraitType.clone`)

        """
        if isinstance( value, set ):
            if object is None:
                return value

            return TraitSetObject( self, object, name, value )

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        return 'a set of %s' % self.item_trait.full_info( object, name, value )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        # fixme: Needs to be customized for sets.
        handler = self.item_trait.handler
        if isinstance( handler, TraitInstance ) and (self.mode != 'list'):
            from .api import HasTraits

            if issubclass( handler.aClass, HasTraits ):
                try:
                    object = handler.aClass()
                    from traitsui.table_column import ObjectColumn
                    from traitsui.table_filter import (EvalFilterTemplate,
                        RuleFilterTemplate, MenuFilterTemplate, EvalTableFilter)
                    from traitsui.api import TableEditor

                    return TableEditor(
                            columns = [ ObjectColumn( name = name )
                                        for name in object.editable_traits() ],
                            filters     = [ RuleFilterTemplate,
                                            MenuFilterTemplate,
                                            EvalFilterTemplate ],
                            edit_view   = '',
                            orientation = 'vertical',
                            search      = EvalTableFilter(),
                            deletable   = True,
                            row_factory = handler.aClass )
                except:
                    pass

        from traitsui.api import ListEditor

        return ListEditor( trait_handler = self,
                           rows          = self.rows or 5,
                           use_notebook  = self.use_notebook is True,
                           page_name     = self.page_name or '' )

    def inner_traits ( self ):
        """ Returns the *inner trait* (or traits) for this trait.
        """
        return ( self.item_trait, )

    #-- Private Methods --------------------------------------------------------

    def items_event ( self ):
        if self.__class__._items_event is None:
            self.__class__._items_event = \
                Event( TraitSetEvent, is_base = False ).as_ctrait()

        return self.__class__._items_event

#-------------------------------------------------------------------------------
#  'CSet' trait:
#-------------------------------------------------------------------------------

class CSet ( Set ):
    """ Defines a trait whose values must be a set whose items are of the
        specified trait type or which can be coerced to a set whose values are
        of the specified trait type.
    """

    def validate ( self, object, name, value ):
        """ Validates that the values is a valid list.
        """
        if not isinstance( value, set ):
            try:
                # Should work for all iterables as well as strings (which do
                # not define an __iter__ method)
                value = set( value )
            except ( ValueError, TypeError ):
                value = set( [ value ] )

        return super( CList, self ).validate( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        return '%s or %s' % (
                   self.item_trait.full_info( object, name, value),
                   super( CSet, self ).full_info( object, name, value ) )

#-------------------------------------------------------------------------------
#  'Dict' trait:
#-------------------------------------------------------------------------------

class Dict ( TraitType ):
    """ Defines a trait whose value must be a dictionary, optionally with
        specified types for keys and values.
    """

    info_trait         = None
    default_value_type = 6
    _items_event       = None

    def __init__ ( self, key_trait = None, value_trait = None, value = None,
                   items = True, **metadata ):
        """ Returns a Dict trait.

        Parameters
        ----------
        key_trait : a trait or value that can convert to a trait using Trait()
            The trait type for keys in the dictionary; if not specified, any
            values can be used as keys.
        value_trait : a trait or value that can convert to a trait using Trait()
            The trait type for values in the dictionary; if not specified, any
            values can be used as dictionary values.
        value : dict
            The default value for the returned trait.
        items : bool
            Indicates whether the value contains items.

        Default Value
        -------------
        *value* or {}
        """
        if isinstance( key_trait, dict ):
            key_trait, value_trait, value = value_trait, value, key_trait

        if value is None:
            value = {}

        self.key_trait   = trait_from( key_trait )
        self.value_trait = trait_from( value_trait )
        self.has_items   = items

        handler = self.value_trait.handler
        if (handler is not None) and handler.has_items:
            handler = handler.clone()
            handler.has_items = False
        self.value_handler = handler

        super( Dict, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid dictionary.

        .. note::

            `object` can be None when validating a default value (see e.g.
            :meth:`~traits.trait_handlers.TraitType.clone`)

        """
        if isinstance( value, dict ):
            if object is None:
                return value
            return TraitDictObject( self, object, name, value )

        self.error( object, name, value )

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        return ('a dictionary with keys which are %s and with values which '
                'are %s') % (
                self.key_trait.full_info(   object, name, value ),
                self.value_trait.full_info( object, name, value ) )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        from traitsui.api import TextEditor

        return TextEditor( evaluate = eval )

    def inner_traits ( self ):
        """ Returns the *inner trait* (or traits) for this trait.
        """
        return ( self.key_trait, self.value_trait )

    #-- Private Methods --------------------------------------------------------

    def items_event ( self ):
        cls = self.__class__
        if cls._items_event is None:
            cls._items_event = \
                Event( TraitDictEvent, is_base = False ).as_ctrait()

        return cls._items_event

#-------------------------------------------------------------------------------
#  'BaseInstance' and 'Instance' traits:
#-------------------------------------------------------------------------------

# Allowed values and mappings for the 'adapt' keyword:
AdaptMap = {
   'no':      0,
   'yes':     1,
   'default': 2
}

class BaseClass ( TraitType ):
    """ Base class for types which have an associated class which can be
        determined dynamically by specifying a string name for the class (e.g.
        'package1.package2.module.class'.

        Any subclass must define instances with 'klass' and 'module' attributes
        that contain the string name of the class (or actual class object) and
        the module name that contained the original trait definition (used for
        resolving local class names (e.g. 'LocalClass')).

        This is an abstract class that only provides helper methods used to
        resolve the class name into an actual class object.
    """

    def resolve_class ( self, object, name, value ):
        klass = self.validate_class( self.find_class( self.klass ) )
        if klass is None:
            self.validate_failed( object, name, value )

        self.klass = klass

    def validate_class ( self, klass ):
        return klass

    def find_class ( self, klass ):
        module = self.module
        col    = klass.rfind( '.' )
        if col >= 0:
            module = klass[ : col ]
            klass = klass[ col + 1: ]

        theClass = getattr( sys.modules.get( module ), klass, None )
        if (theClass is None) and (col >= 0):
            try:
                mod = __import__( module )
                for component in module.split( '.' )[1:]:
                    mod = getattr( mod, component )

                theClass = getattr( mod, klass, None )
            except:
                pass

        return theClass

    def validate_failed ( self, object, name, value ):

        self.error( object, name, value )

def validate_implements ( value, klass, unused = None ):
    """ Checks to see if a specified value implements the instance class
        interface (if it is an interface).
    """

    from .has_traits import isinterface
    from .interface_checker import check_implements

    return isinterface(klass) and check_implements( value.__class__, klass )

#: Tell the C-base code about the 'validate_implements' function (used by the
#: 'fast_validate' code for Instance types):
from . import ctraits
ctraits._validate_implements( validate_implements )

class BaseInstance ( BaseClass ):
    """ Defines a trait whose value must be an instance of a specified class,
        or one of its subclasses.
    """

    adapt_default = 'no'

    def __init__ ( self, klass = None, factory = None, args = None, kw = None,
                   allow_none = True, adapt = None, module = None,
                   **metadata ):
        """ Returns an Instance trait.

        Parameters
        ----------
        klass : class or instance
            The object that forms the basis for the trait; if it is an
            instance, then trait values must be instances of the same class or
            a subclass. This object is not the default value, even if it is an
            instance.
        factory : callable
            A callable, typically a class, that when called with *args* and
            *kw*, returns the default value for the trait. If not specified,
            or *None*, *klass* is used as the factory.
        args : tuple
            Positional arguments for generating the default value.
        kw : dictionary
            Keyword arguments for generating the default value.
        allow_none : bool
            Indicates whether None is allowed as a value.
        adapt : str
            A string specifying how adaptation should be applied. The possible
            values are:

                - 'no': Adaptation is not allowed.
                - 'yes': Adaptation is allowed. If adaptation fails, an
                    exception should be raised.
                - 'default': Adaptation is allowed. If adaptation fails, the
                    default value for the trait should be used.

        Default Value
        -------------
        **None** if *klass* is an instance or if it is a class and *args* and
        *kw* are not specified. Otherwise, the default value is the instance
        obtained by calling ``klass(*args, **kw)``. Note that the constructor
        call is performed each time a default value is assigned, so each
        default value assigned is a unique instance.
        """
        if klass is None:
            raise TraitError( 'A %s trait must have a class specified.' %
                              self.__class__.__name__ )

        metadata.setdefault( 'copy', 'deep' )
        metadata.setdefault( 'instance_handler', '_instance_changed_handler' )

        adapt = adapt or self.adapt_default
        if adapt not in AdaptMap:
            raise TraitError( "'adapt' must be 'yes', 'no' or 'default'." )

        if isinstance( factory, tuple ):
            if args is None:
                args, factory = factory, klass
            elif isinstance( args, dict ):
                factory, args, kw = klass, factory, args

        elif (kw is None) and isinstance( factory, dict ):
            kw, factory = factory, klass

        elif ((args is not None) or (kw is not None)) and (factory is None):
            factory = klass

        self._allow_none = allow_none
        self.adapt       = AdaptMap[ adapt ]
        self.module      = module or get_module_name()

        if isinstance( klass, basestring ):
            self.klass = klass
        else:
            if not isinstance( klass, ClassTypes ):
                klass = klass.__class__

            self.klass = klass
            self.init_fast_validate()

        value = factory
        if factory is not None:
            if args is None:
                args = ()

            if kw is None:
                if isinstance( args, dict ):
                    kw   = args
                    args = ()
                else:
                    kw = {}
            elif not isinstance( kw, dict ):
                raise TraitError( "The 'kw' argument must be a dictionary." )

            if ((not callable( factory )) and
                (not isinstance( factory, basestring ))):
                if (len( args ) > 0) or (len( kw ) > 0):
                    raise TraitError( "'factory' must be callable" )
            else:
                value = _InstanceArgs( factory, args, kw )

        self.default_value = value

        super( BaseInstance, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid object instance.
        """
        from traits.adaptation.api import adapt

        if value is None:
            if self._allow_none:
                return value

            self.validate_failed( object, name, value )

        if isinstance( self.klass, basestring ):
            self.resolve_class( object, name, value )

        if self.adapt == 0:
            try:
                if value is adapt( value, self.klass ):
                    return value
            except:
                if validate_implements( value, self.klass ):
                    return value

        elif self.adapt == 1:
            try:
                return adapt( value, self.klass )
            except:
                if validate_implements( value, self.klass ):
                    return value

        else:
            result = adapt( value, self.klass, None )
            if result is None:
                if validate_implements( value, self.klass ):
                    return value

                result = self.default_value
                if isinstance( result, _InstanceArgs ):
                    result = result[0]( *result[1], **result[2] )

            return result

        self.validate_failed( object, name, value )

    def info ( self ):
        """ Returns a description of the trait.
        """
        klass = self.klass
        if not isinstance( klass, basestring ):
            klass = klass.__name__

        if self.adapt == 0:
            result = class_of( klass )
        else:
            result = ('an implementor of, or can be adapted to implement, %s' %
                      klass)

        if self._allow_none:
            return result + ' or None'

        return result

    def get_default_value ( self ):
        """ Returns a tuple of the form: ( default_value_type, default_value )
            which describes the default value for this trait.
        """
        dv  = self.default_value
        dvt = self.default_value_type
        if dvt < 0:
            if not isinstance( dv, _InstanceArgs ):
                return super( BaseInstance, self ).get_default_value()

            self.default_value_type = dvt = 7
            self.default_value      = dv  = ( self.create_default_value,
                                              dv.args, dv.kw )

        return ( dvt, dv )

    def create_editor ( self ):
        """ Returns the default traits UI editor for this type of trait.
        """
        from traitsui.api import InstanceEditor

        return InstanceEditor( label = self.label or '',
                               view  = self.view  or '',
                               kind  = self.kind  or 'live' )

    #-- Private Methods --------------------------------------------------------

    def create_default_value ( self, *args, **kw ):
        klass = args[0]
        if isinstance( klass, basestring ):
            klass = self.validate_class( self.find_class( klass ) )
            if klass is None:
                raise TraitError, 'Unable to locate class: ' + args[0]

        return klass( *args[1:], **kw )

    #: fixme: Do we still need this method using the new style?...
    def allow_none ( self ):
        self._allow_none = True
        self.init_fast_validate()

    def init_fast_validate ( self ):
        """ Does nothing for the BaseInstance' class. Used by the 'Instance',
            'AdaptedTo' and 'AdaptsTo' classes to set up the C-level fast
            validator.
        """
        pass

    def resolve_class ( self, object, name, value ):
        super( BaseInstance, self ).resolve_class( object, name, value )

        #: fixme: The following is quite ugly, because it wants to try and fix
        #: the trait referencing this handler to use the 'fast path' now that the
        #: actual class has been resolved. The problem is finding the trait,
        # especially in the case of List(Instance('foo')), where the
        # object.base_trait(...) value is the List trait, not the Instance
        # trait, so we need to check for this and pull out the List
        # 'item_trait'. Obviously this does not extend well to other traits
        # containing nested trait references (Dict?)...
        self.init_fast_validate()
        trait   = object.base_trait( name )
        handler = trait.handler
        if handler is not self:
            set_validate = getattr( handler, 'set_validate', None )
            if set_validate is not None:
                # The outer trait is a TraitCompound. Recompute its
                # fast_validate table now that we have updated ours.
                # FIXME: there are probably still issues if the TraitCompound is
                # further nested.
                set_validate()
            else:
                item_trait = getattr( handler, 'item_trait', None )
                if item_trait is not None and item_trait.handler is self:
                    # The outer trait is a List trait.
                    trait   = item_trait
                    handler = self
                else:
                    return
        if handler.fast_validate is not None:
            trait.set_validate( handler.fast_validate )

class Instance ( BaseInstance ):
    """ Defines a trait whose value must be an instance of a specified class,
        or one of its subclasses using a C-level fast validator.
    """

    def init_fast_validate ( self ):
        """ Sets up the C-level fast validator. """

        from .has_traits import isinterface

        if (self.adapt == 0) and (not isinterface(self.klass)):
            fast_validate = [ 1, self.klass ]
            if self._allow_none:
                fast_validate = [ 1, None, self.klass ]

            if self.klass in TypeTypes:
                fast_validate[0] = 0

            self.fast_validate = tuple( fast_validate )
        else:
            self.fast_validate = ( 19, self.klass, self.adapt,
                                   self._allow_none )

class Supports( Instance ):
    """ A traits whose value must support a specified protocol.

    In other words, the value of the trait directly provide, or can be adapted
    to, the given protocol (Interface or type).

    The value of the trait after assignment is the possibly adapted value
    (i.e., it is the original assigned value if that provides the protocol,
    or is an adapter otherwise).

    The original, unadapted value is stored in a "shadow" attribute with
    the same name followed by an underscore (e.g., 'foo' and 'foo_').
    """

    adapt_default = 'yes'

    def post_setattr ( self, object, name, value ):
        """ Performs additional post-assignment processing.
        """
        # Save the original, unadapted value in the mapped trait:
        object.__dict__[ name + '_' ] = value

    def as_ctrait ( self ):
        """ Returns a CTrait corresponding to the trait defined by this class.
        """
        return self.modify_ctrait( super( AdaptedTo, self ).as_ctrait() )

    def modify_ctrait ( self, ctrait ):

        # Tell the C code that the 'post_setattr' method wants the original,
        # unadapted value passed to 'setattr':
        return ctrait.post_setattr_original_value( True )

# Alias defined for backward compatibility with Traits 4.3.0
AdaptedTo = Supports

class AdaptsTo ( Supports ):
    """ A traits whose value must support a specified protocol.

    In other words, the value of the trait directly provide, or can be adapted
    to, the given protocol (Interface or type).

    The value of the trait after assignment is the original, unadapted value.

    A possibly adapted value is stored in a "shadow" attribute with
    the same name followed by an underscore (e.g., 'foo' and 'foo_').
    """

    def modify_ctrait ( self, ctrait ):
        # Tell the C code that 'setattr' should store the original, unadapted
        # value passed to it:
        return ctrait.setattr_original_value( True )

#-------------------------------------------------------------------------------
#  'Type' trait:
#-------------------------------------------------------------------------------

class Type ( BaseClass ):
    """ Defines a trait whose value must be a subclass of a specified class.
    """

    def __init__ ( self, value = None, klass = None, allow_none = True,
                         **metadata ):
        """ Returns an Type trait.

        Parameters
        ----------
        value : class or None

        klass : class or None

        allow_none : bool
            Indicates whether None is allowed as an assignable value. Even if
            **False**, the default *value* may be **None**.

        Default Value
        -------------
        **None** if *klass* is an instance or if it is a class and *args* and
        *kw* are not specified. Otherwise, the default value is the instance
        obtained by calling ``klass(*args, **kw)``. Note that the constructor
        call is performed each time a default value is assigned, so each
        default value assigned is a unique instance.
        """
        if value is None:
            if klass is None:
                klass = object

        elif klass is None:
            klass = value

        if isinstance( klass, basestring ):
            self.validate = self.resolve

        elif not isinstance( klass, ClassTypes ):
            raise TraitError( "A Type trait must specify a class." )

        self.klass       = klass
        self._allow_none = allow_none
        self.module      = get_module_name()

        super( Type, self ).__init__( value, **metadata )

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid object instance.
        """
        try:
            if issubclass( value, self.klass ):
                return value
        except:
            if (value is None) and (self._allow_none):
                return value

        self.error( object, name, value )

    def resolve ( self, object, name, value ):
        """ Resolves a class originally specified as a string into an actual
            class, then resets the trait so that future calls will be handled by
            the normal validate method.
        """
        if isinstance( self.klass, basestring ):
            self.resolve_class( object, name, value )
            del self.validate

        return self.validate( object, name, value )

    def info ( self ):
        """ Returns a description of the trait.
        """
        klass = self.klass
        if not isinstance( klass, basestring ):
            klass = klass.__name__

        result = 'a subclass of ' + klass

        if self._allow_none:
            return result + ' or None'

        return result

    def get_default_value ( self ):
        """ Returns a tuple of the form: ( default_value_type, default_value )
            which describes the default value for this trait.
        """
        if not isinstance( self.default_value, basestring ):
            return super( Type, self ).get_default_value()

        return ( 7, ( self.resolve_default_value, (), None ) )

    def resolve_default_value ( self ):
        """ Resolves a class name into a class so that it can be used to
            return the class as the default value of the trait.
        """
        if isinstance( self.klass, basestring ):
            try:
                self.resolve_class( None, None, None )
                del self.validate
            except:
                raise TraitError( 'Could not resolve %s into a valid class' %
                                  self.klass )

        return self.klass

#-------------------------------------------------------------------------------
#  'Event' trait:
#-------------------------------------------------------------------------------

class Event ( TraitType ):

    def __init__ ( self, trait = None, **metadata ):
        metadata[ 'type' ]      = 'event'
        metadata[ 'transient' ] = True

        super( Event, self ).__init__( **metadata )

        self.trait = None
        if trait is not None:
            self.trait = trait_from( trait )
            validate   = self.trait.get_validate()
            if validate is not None:
                self.fast_validate = validate

    def full_info ( self, object, name, value ):
        """ Returns a description of the trait.
        """
        trait = self.trait
        if trait is None:
            return 'any value'

        return trait.full_info( object, name, value )

#  Handle circular module dependencies:
trait_handlers.Event = Event

#-------------------------------------------------------------------------------
#  'Button' trait:
#-------------------------------------------------------------------------------

class Button ( Event ):
    """ Defines a trait whose UI editor is a button.
    """

    def __init__ ( self, label = '', image = None, values_trait = None, style = 'button',
                         orientation = 'vertical', width_padding = 7,
                         height_padding = 5, view = None, **metadata ):
        """ Returns a trait event whose editor is a button.

            Parameters
            ----------
            label : str
                The label for the button.
            image : pyface.ImageResource
                An image to display on the button.
            style : one of: 'button', 'radio', 'toolbar', 'checkbox'
                The style of button to display.
            values_trait : str
                For a "button" or "toolbar" style, the name of an enum
                trait whose values will populate a drop-down menu on the button.
                The selected value will replace the label on the button.
            orientation : one of: 'horizontal', 'vertical'
                The orientation of the label relative to the image.
            width_padding : integer between 0 and 31
                Extra padding (in pixels) added to the left and right sides of
                the button.
            height_padding : integer between 0 and 31
                Extra padding (in pixels) added to the top and bottom of the
                button.

            Default Value
            -------------
            No default value because events do not store values.
        """
        self.label = label
        self.values_trait = values_trait
        self.image = image
        self.style = style
        self.orientation = orientation
        self.width_padding = width_padding
        self.height_padding = height_padding
        self.view = view
        super( Button, self ).__init__( **metadata )

    def create_editor(self):
        from traitsui.api import ButtonEditor

        editor = ButtonEditor(
            label = self.label,
            values_trait = self.values_trait,
            image = self.image,
            style = self.style,
            orientation = self.orientation,
            width_padding = self.width_padding,
            height_padding = self.height_padding,
            view = self.view,
        )
        return editor


#-------------------------------------------------------------------------------
#  'ToolbarButton' trait:
#-------------------------------------------------------------------------------

class ToolbarButton ( Button ):
    """ Defines a trait whose UI editor is a button that can be used on a
        toolbar.
    """

    def __init__ ( self, label = '', image = None, style = 'toolbar',
                         orientation = 'vertical', width_padding = 2,
                         height_padding = 2, **metadata ):
        """ Returns a trait event whose editor is a toolbar button.

            Parameters
            ----------
            label : str
                The label for the button
            image : pyface.ImageResource
                An image to display on the button
            style : one of: 'button', 'radio', 'toolbar', 'checkbox'
                The style of button to display
            orientation : one of ['horizontal', 'vertical']
                The orientation of the label relative to the image
            width_padding : integer between 0 and 31
                Extra padding (in pixels) added to the left and right sides of
                the button
            height_padding : integer between 0 and 31
                Extra padding (in pixels) added to the top and bottom of the
                button

            Default Value
            -------------
            No default value because events do not store values.

        """
        super( ToolbarButton, self ).__init__( label,
                                               image=image,
                                               style=style,
                                               orientation=orientation,
                                               width_padding=width_padding,
                                               height_padding=height_padding,
                                               **metadata )

#-------------------------------------------------------------------------------
#  'Either' trait:
#-------------------------------------------------------------------------------

class Either ( TraitType ):
    """ Defines a trait whose value can be any of of a specified list of traits.
    """

    def __init__ ( self, *traits, **metadata ):
        """ Creates a trait whose value can be any of of a specified list of
            traits.
        """
        self.trait_maker = _TraitMaker( metadata.pop( 'default', None ),
                                        *traits, **metadata )

    def as_ctrait ( self ):
        """ Returns a CTrait corresponding to the trait defined by this class.
        """
        return self.trait_maker.as_ctrait()

#-------------------------------------------------------------------------------
#  'Symbol' trait:
#-------------------------------------------------------------------------------

class Symbol ( TraitType ):

    #: A description of the type of value this trait accepts:
    info_text = ("an object or a string of the form "
        "'[package.package...package.]module[:symbol[([arg1,...,argn])]]' "
        "specifying where to locate the object")

    def get ( self, object, name ):
        value = object.__dict__.get( name, Undefined )
        if value is Undefined:
            cache = TraitsCache + name
            ref   = object.__dict__.get( cache )
            if ref is None:
                object.__dict__[ cache ] = ref = \
                    object.trait( name ).default_value_for( object, name )

            if isinstance( ref, basestring ):
                object.__dict__[ name ] = value = self._resolve( ref )

        return value

    def set ( self, object, name, value ):
        dict = object.__dict__
        old  = dict.get( name, Undefined )
        if isinstance( value, basestring ):
            dict.pop( name, None )
            dict[ TraitsCache + name ] = value
            object.trait_property_changed( name, old )
        else:
            dict[ name ] = value
            object.trait_property_changed( name, old, value )

    def _resolve ( self, ref ):
        try:
            path   = ref.split( ':', 1 )
            module = __import__( path[0] )
            for component in path[0].split( '.' )[1:]:
                module = getattr( module, component )

            if len( path ) == 1:
                return module

            elements = path[1].split( '(', 1 )
            symbol   = getattr( module, elements[0] )
            if len( elements ) == 1:
                return symbol

            args = eval( '(' + elements[1] )
            if not isinstance( args, tuple ):
                args = ( args, )

            return symbol( *args )
        except:
            raise TraitError( "Could not resolve '%s' into a valid symbol." %
                              ref )


if python_version >= 2.5:

    import uuid

    #---------------------------------------------------------------------------
    #  'UUID' trait:
    #---------------------------------------------------------------------------

    class UUID ( TraitType ):
        """ Defines a trait whose value is a globally unique UUID (type 4).
        """

        #: A description of the type of value this trait accepts:
        info_text = 'a read-only UUID'

        def __init__ ( self, **metadata ):
            """ Returns a UUID trait.
            """
            super( UUID, self ).__init__( None, **metadata )

        def validate ( self, object, name, value ):
            """ Raises an error, since no values can be assigned to the trait.
            """
            raise TraitError( "The '%s' trait of %s instance is a read-only "
                              "UUID." % ( name, class_of( object ) ) )

        def get_default_value ( self ):
            return ( 7, ( self._create_uuid, (), None ) )

        #-- Private Methods ---------------------------------------------------

        def _create_uuid ( self ):
            return uuid.uuid4()

#-------------------------------------------------------------------------------
#  'WeakRef' trait:
#-------------------------------------------------------------------------------

class WeakRef ( Instance ):
    """ Returns a trait whose value must be an instance of the same type
    (or a subclass) of the specified *klass*, which can be a class or an
    instance. Note that the trait only maintains a weak reference to the
    assigned value.
    """

    def __init__ ( self, klass = 'traits.has_traits.HasTraits',
                         allow_none = False, adapt = 'yes', **metadata ):
        """ Returns a WeakRef trait.

        Only a weak reference is maintained to any object assigned to a WeakRef
        trait. If no other references exist to the assigned value, the value
        may be garbage collected, in which case the value of the trait becomes
        None. In all other cases, the value returned by the trait is the
        original object.

        Parameters
        ----------
        klass : class or instance
            The object that forms the basis for the trait. If *klass* is
            omitted, then values must be an instance of HasTraits.
        allow_none : boolean
            Indicates whether None can be assigned.

        Default Value
        -------------
        **None** (even if allow_none==False)
        """

        metadata.setdefault( 'copy', 'ref' )

        super( WeakRef, self ).__init__( klass, allow_none = allow_none,
                         adapt = adapt, module = get_module_name(), **metadata )

    def get ( self, object, name ):
        value = getattr( object, name + '_', None )
        if value is not None:
            return value.value()

        return None

    def set ( self, object, name, value ):
        old = self.get( object, name )

        if value is None:
            object.__dict__[ name + '_' ] = None
        else:
            object.__dict__[ name + '_' ] = HandleWeakRef( object, name, value )

        if value is not old:
            object.trait_property_changed( name, old, value )

    def resolve_class ( self, object, name, value ):
        # fixme: We have to override this method to prevent the 'fast validate'
        # from being set up, since the trait using this is a 'property' style
        # trait which is not currently compatible with the 'fast_validate'
        # style (causes internal Python SystemError messages).
        klass = self.find_class( self.klass )
        if klass is None:
            self.validate_failed( object, name, value )

        self.klass = klass


#-- Date Trait definition ----------------------------------------------------
Date = BaseInstance(datetime.date, editor=date_editor)


#-- Time Trait definition ----------------------------------------------------
Time = BaseInstance(datetime.time, editor=time_editor)


#-------------------------------------------------------------------------------
#  Create predefined, reusable trait instances:
#-------------------------------------------------------------------------------

# Synonym for Bool; default value is False.
false = Bool

# Boolean values only; default value is True.
true = Bool( True )

# Allows any value to be assigned; no type-checking is performed.
# Default value is Undefined.
undefined = Any( Undefined )

#-- List Traits ----------------------------------------------------------------

#: List of integer values; default value is [].
ListInt = List( int )

#: List of float values; default value is [].
ListFloat = List( float )

#: List of string values; default value is [].
ListStr = List( str )

#: List of Unicode string values; default value is [].
ListUnicode = List( unicode )

#: List of complex values; default value is [].
ListComplex = List( complex )

#: List of Boolean values; default value is [].
ListBool = List( bool )

#: List of function values; default value is [].
ListFunction = List( FunctionType )

#: List of method values; default value is [].
ListMethod = List( MethodType )

if sys.version_info[0] < 3:
    from types import ClassType, InstanceType
    
    #: List of class values; default value is [].
    ListClass = List( ClassType )

    #: List of instance values; default value is [].
    ListInstance = List( InstanceType )

#: List of container type values; default value is [].
ListThis = List( ThisClass )

#-- Dictionary Traits ----------------------------------------------------------

#: Only a dictionary of string:Any values can be assigned; only string keys can
#: be inserted. The default value is {}.
DictStrAny = Dict( str, Any )

#: Only a dictionary of string:string values can be assigned; only string keys
#: with string values can be inserted. The default value is {}.
DictStrStr = Dict( str, str )

#: Only a dictionary of string:integer values can be assigned; only string keys
#: with integer values can be inserted. The default value is {}.
DictStrInt = Dict( str, int )

#: Only a dictionary of string:long-integer values can be assigned; only string
#: keys with long-integer values can be inserted. The default value is {}.
DictStrLong = Dict( str, long )

#: Only a dictionary of string:float values can be assigned; only string keys
#: with float values can be inserted. The default value is {}.
DictStrFloat = Dict( str, float )

#: Only a dictionary of string:bool values can be assigned; only string keys
#: with boolean values can be inserted. The default value is {}.
DictStrBool = Dict( str, bool )

#: Only a dictionary of string:list values can be assigned; only string keys
#: with list values can be assigned. The default value is {}.
DictStrList = Dict( str, list )


########NEW FILE########
__FILENAME__ = trait_value
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author:        David C. Morrill
#  Original Date: 04/01/2008
#
#------------------------------------------------------------------------------

""" Defines the TraitValue class, used for creating special, dynamic trait
    values.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .trait_base import Undefined
from .traits import CTrait
from .has_traits import HasTraits, HasPrivateTraits
from .trait_errors import TraitError
from .trait_types import Tuple, Dict, Any, Str, Instance, Event, Callable
from .trait_handlers import TraitType, _read_only, _write_only, _arg_count

#-------------------------------------------------------------------------------
#  'BaseTraitValue' class:
#-------------------------------------------------------------------------------

class BaseTraitValue ( HasPrivateTraits ):

    # Subclasses can define this trait as a property:
    # value = Property

    #-- Public Methods ---------------------------------------------------------

    def as_ctrait ( self, original_trait ):
        """ Returns the low-level C-based trait for this TraitValue.
        """
        notifiers = original_trait._notifiers( 0 )

        if self._ctrait is not None:
            if (notifiers is None) or (len( notifiers ) == 0):
                return self._ctrait

            trait = CTrait( 0 )
            trait.clone( self._ctrait )
        else:
            trait = self._as_ctrait( original_trait )

        if ((trait     is not None) and
            (notifiers is not None) and
            (len( notifiers ) > 0)):
            trait._notifiers( 1 ).extend( notifiers )

        return trait

    #-- Private Methods --------------------------------------------------------

    def _as_ctrait ( self, original_trait ):
        """ Returns the low-level C-based trait for this TraitValue.
        """
        value_trait = self.trait( 'value' )
        if value_trait is None:
            return None

        if value_trait.type != 'property':
            raise TraitError( "Invalid TraitValue specified." )

        metadata = { 'type':         'property',
                     '_trait_value': self }

        getter, setter, validate = value_trait.property()
        read_only = (getter is _read_only)
        if not read_only:
            getter = self._getter
            metadata[ 'transient' ] =  True

        if setter is not _write_only:
            if read_only:
                setter = self._read_only_setter
            else:
                setter = self._setter
            metadata[ 'transient' ] =  True

        return self._property_trait( getter, setter, validate, metadata )

    def _property_trait ( self, getter, setter, validate, metadata ):
        """ Returns a properly constructed 'property' trait.
        """
        n = 0
        if validate is not None:
            n = _arg_count( validate )

        trait = CTrait( 4 )
        trait.property( getter,   _arg_count( getter ),
                        setter,   _arg_count( setter ),
                        validate, n )

        trait.value_allowed(  True )
        trait.value_property( True )
        trait.__dict__ = metadata

        return trait

    def _getter ( self, object, name ):
        return self.value

    def _setter ( self, object, name, value ):
        old_value  = self.value
        self.value = value
        new_value  = self.value
        if new_value != old_value:
            object.trait_property_changed( name, old_value, new_value )

    def _read_only_setter ( self, object, name, value ):
        self.value = value
        object.trait_property_changed( name, Undefined, value )

#-------------------------------------------------------------------------------
#  'TraitValue' class:
#-------------------------------------------------------------------------------

class TraitValue ( BaseTraitValue ):

    #: The callable used to define a default value:
    default = Callable

    #: The positional arguments to pass to the callable default value:
    args = Tuple

    #: The keyword arguments to pass to the callable default value:
    kw = Dict

    #: The trait to use as the new trait type:
    type = Any

    #: The object to delegate the new value to:
    delegate = Instance( HasTraits )

    #: The name of the trait on the delegate object to get the new value from:
    name = Str

    #-- Private Methods --------------------------------------------------------

    def _as_ctrait ( self, original_trait ):
        """ Returns the low-level C-based trait for this TraitValue.
        """
        if self.default is not None:
            trait = CTrait( 0 )
            trait.clone( original_trait )
            if original_trait.__dict__ is not None:
                trait.__dict__ = original_trait.__dict__.copy()

            trait.default_value( 7, ( self.default, self.args, self.kw ) )

        elif self.type is not None:
            type = self.type
            try:
                rc = issubclass( type, TraitType )
            except:
                rc = False

            if rc:
                type = type( *self.args, **self.kw )

            if not isinstance( type, TraitType ):
                raise TraitError( ("The 'type' attribute of a TraitValue "
                    "instance must be a TraitType instance or subclass, but a "
                    "value of %s was specified.") % self.trait )

            self._ctrait = trait = type.as_ctrait()
            trait.value_allowed( True )

        elif self.delegate is None:
            return None

        else:
            if self.name == '':
                raise TraitError( "You must specify a non-empty string "
                    "value for the 'name' attribute when using the "
                    "'delegate' trait of a TraitValue instance." )

            metadata = { 'type':         'property',
                         '_trait_value': self,
                         'transient':    True }

            getter   = self._delegate_getter
            setter   = self._delegate_setter
            validate = None

            self.add_trait( 'value', Event() )
            self.delegate.on_trait_change( self._delegate_modified, self.name )

            trait = self._property_trait( getter, setter, validate, metadata )

        return trait

    def _delegate_getter ( self, object, name ):
        return getattr( self.delegate, self.name )

    def _delegate_setter ( self, object, name, value ):
        setattr( self.delegate, self.name, value )

    #-- Traits Event Handlers --------------------------------------------------

    def _delegate_modified ( self ):
        self.value = True

#-- Helper Function Definitions ------------------------------------------------

def SyncValue ( delegate, name ):
    return TraitValue( delegate = delegate, name = name )

def TypeValue ( type ):
    return TraitValue( type = type )

def DefaultValue ( default, args = (), kw = {} ):
    return TraitValue( default = default, args = args, kw = kw )

#-------------------------------------------------------------------------------
#  Tell the C-based traits module about the 'BaseTraitValue' class:
#-------------------------------------------------------------------------------

from . import ctraits
ctraits._value_class( BaseTraitValue )


########NEW FILE########
__FILENAME__ = ustr_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/21/2008
#
#------------------------------------------------------------------------------

""" Defines the UStr type and HasUniqueStrings mixin class for efficiently
    creating lists of objects containing traits whose string values must be
    unique within the list.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .trait_base import is_str
from .has_traits import HasTraits
from .trait_value import TraitValue, TypeValue
from .trait_types import List
from .trait_handlers import TraitType, NoDefaultSpecified

#-------------------------------------------------------------------------------
#  'UStr' class:
#-------------------------------------------------------------------------------

class UStr ( TraitType ):
    """ Trait type that ensures that a value assigned to a trait is unique
        within the list it belongs to.
    """
    #: The type value to assign to restore the original list item type when a
    #: list item is removed from the monitored list:
    str_type = TraitValue()

    #: The informational text describing the trait:
    info_text = 'a unique string'

    def __init__ ( self, owner, list_name, str_name,
                         default_value = NoDefaultSpecified, **metadata ):
        """ Initializes the type.
        """
        super( UStr, self ).__init__( default_value, **metadata )

        self.owner     = owner
        self.list_name = list_name
        self.str_name  = str_name
        self.ustr_type = TypeValue( self )
        self.names     = dict( [ ( getattr( item, str_name ), item )
                                 for item in getattr( owner, list_name ) ] )
        self.roots     = {}
        self.available = {}
        owner.on_trait_change( self._items_modified, list_name + '[]' )

    def validate ( self, object, name, value ):
        """ Ensures that a value being assigned to a trait is a unique string.
        """
        if isinstance( value, basestring ):
            names    = self.names
            old_name = getattr( object, name )
            if names.get( old_name ) is object:
                self._remove( old_name )

            if value not in names:
                names[ value ] = object
                return value

            available = self.available.get( value )
            while True:
                if available is None:
                    new_value = None
                    break

                index = available.pop()
                if len( available ) == 0:
                    del self.available[ value ]
                    available = None

                new_value = '%s_%d' % ( value, index )
                if new_value not in names:
                    break

            if new_value is None:
                self.roots[ value ] = index = \
                    self.roots.setdefault( value, 1 ) + 1
                new_value = '%s_%d' % ( value, index )

            names[ new_value ] = object
            return new_value

        self.error( object, name, value )

    def _remove ( self, name ):
        """ Removes a specified name.
        """
        self.names.pop( name, None )
        col = name.rfind( '_' )
        if col >= 0:
            try:
                index  = int( name[ col + 1: ] )
                prefix = name[ : col ]
                if prefix in self.roots:
                    if prefix not in self.available:
                        self.available[ prefix ] = set()
                    self.available[ prefix ].add( index )
            except:
                pass

    def _items_modified ( self, object, name, removed, added ):
        """ Handles items being added to or removed from the monitored list.
        """
        str_name  = self.str_name
        str_type  = self.str_type
        ustr_type = self.ustr_type

        for item in removed:
            setattr( item, str_name, str_type )
            self._remove( getattr( item, str_name ) )

        for item in added:
            setattr( item, str_name, ustr_type )
            setattr( item, str_name, getattr( item, str_name ) )

#-------------------------------------------------------------------------------
#  'HasUniqueStrings' class:
#-------------------------------------------------------------------------------

class HasUniqueStrings ( HasTraits ):
    """ Mixin or base class for objects containing lists with items containing
        string valued traits that must be unique.

        List traits within the class that contain items which have string traits
        which must be unique should indicate this by attaching metadata of the
        form::

            unique_string = 'trait1, trait2, ..., traitn'

        where each 'traiti' value is the name of a trait within each list item
        that must contain unique string data.

        For example::

            usa = List( State, unique_string = 'name, abbreviation' )
    """

    #-- Private Traits ---------------------------------------------------------

    # List of UStr traits that have been attached to object list traits:
    _ustr_traits = List

    #-- HasTraits Object Initializer -------------------------------------------

    def traits_init ( self ):
        """ Adds any UStrMonitor objects to list traits with 'unique_string'
            metadata.
        """
        super( HasUniqueStrings, self ).traits_init()

        for name, trait in self.traits( unique_string = is_str ).items():
            for str_name in trait.unique_string.split( ',' ):
                self._ustr_traits.append( UStr( self, name, str_name.strip() ) )

            items = getattr( self, name )
            if len( items ) > 0:
                setattr( self, name, [] )
                setattr( self, name, items )


########NEW FILE########
__FILENAME__ = api
__all__ = [
    'deprecated',
    'import_symbol',
    'record_events',
]

from .deprecated import deprecated
from .event_tracer import record_events
from .import_symbol import import_symbol

########NEW FILE########
__FILENAME__ = async_trait_wait
import threading


def wait_for_condition(condition, obj, trait, timeout=None):
    """
    Wait until the given condition is true, re-evaluating on trait change.

    This is intended for use in multithreading situations where traits can be
    modified from a different thread than the calling thread.

    Wait until `condition` is satisfied.  Raise a RuntimeError if
    `condition` is not satisfied within the given timeout.

    `condition` is a callback function that will be called with `obj`
    as its single argument.  It should return a boolean indicating
    whether the condition is satisfied or not.

    `timeout` gives the maximum time in seconds to wait for the
    condition to become true.  The default value of `None` indicates
    no timeout.

    (obj, trait) give an object and trait to listen to for indication
    of a possible change: whenever the trait changes, the condition is
    re-evaluated.  The condition will also be evaluated on entering
    this function.

    Note that in cases of unusual timing it's possible for the condition to be
    evaluated one more time *after* the ``wait_for_condition`` call has
    returned.

    """
    condition_satisfied = threading.Event()

    def handler():
        if condition(obj):
            condition_satisfied.set()

    obj.on_trait_change(handler, trait)
    try:
        if condition(obj):
            # Catch case where the condition was satisfied before
            # the on_trait_change handler was active.
            pass
        elif timeout is None:
            # Allow a Ctrl-C to interrupt.  The 0.05 value matches
            # what's used by the standard library's Condition.wait.
            while not condition_satisfied.is_set():
                condition_satisfied.wait(timeout=0.05)
        else:
            condition_satisfied.wait(timeout=timeout)
            if not condition_satisfied.is_set():
                raise RuntimeError("Timed out waiting for condition.")
    finally:
        obj.on_trait_change(handler, trait, remove=True)

########NEW FILE########
__FILENAME__ = camel_case
""" Defines utility functions for operating on camel case names.
"""

# Standard library imports.
import re

###############################################################################
# Classes
###############################################################################

class CamelCaseToPython:
    """ Simple functor class to convert names from camel case to idiomatic
    Python variable names.

    For example::
        >>> camel2python = CamelCaseToPython
        >>> camel2python('XMLActor2DToSGML')
        'xml_actor2d_to_sgml'
    """

    def __init__(self):
        self.patn = re.compile(r'([A-Z0-9]+)([a-z0-9]*)')
        self.nd_patn = re.compile(r'(\D[123])_D')

    def __call__(self, name):
        ret = self.patn.sub(self._repl, name)
        ret = self.nd_patn.sub(r'\1d', ret)
        if ret[0] == '_':
            ret = ret[1:]
        return ret.lower()

    def _repl(self, m):
        g1 = m.group(1)
        g2 = m.group(2)
        if len(g1) > 1:
            if g2:
                return '_' + g1[:-1] + '_' + g1[-1] + g2
            else:
                return '_' + g1
        else:
            return '_' + g1 + g2

###############################################################################
# Functions
###############################################################################

# Instantiate a converter.
camel_case_to_python = CamelCaseToPython()

def camel_case_to_words(s):
    """ Convert a camel case string into words separated by spaces.

    For example::
        >>> camel_case_to_words('CamelCase')
        'Camel Case'
    """

    def add_space_between_words(s, c):
        # We detect a word boundary if the character we are looking at is
        # upper case, but the character preceding it is lower case.
        if len(s) > 0 and s[-1].islower() and c.isupper():
            return s + ' ' + c

        return s + c

    return reduce(add_space_between_words, s, '')

########NEW FILE########
__FILENAME__ = clean_strings
#-----------------------------------------------------------------------------
#
#  Copyright (c) 2006 by Enthought, Inc.
#  All rights reserved.
#
#-----------------------------------------------------------------------------

""" Provides functions that mange strings to avoid characters that would be
    problematic in certain situations.
"""

# Standard library imports.
import copy
import datetime
import keyword
import re


def clean_filename(name):
    """ Munge a string to avoid characters that might be problematic as
        a filename in some filesystems.
    """
    # The only acceptable characters are alphanumeric (in the current locale)
    # plus a period and dash.
    wordparts = re.split('[^\w\.\-]+', name)

    # Filter out empty strings at the beginning or end of the list.
    wordparts = filter(None, wordparts)

    # Make sure this is an ASCII-encoded string, not a Unicode string.
    filename = '_'.join(wordparts).encode('ascii')

    return filename


def clean_timestamp(dt=None, microseconds=False):
    """ Return a timestamp that has been cleansed of characters that might
        cause problems in filenames, namely colons.  If no datetime object
        is provided, then uses the current time.

        Description
        -----------
        The timestamp is in ISO-8601 format with the following exceptions:

        * Colons ':' are replaced by underscores '_'.
        * Microseconds are not displayed if the 'microseconds' parameter is
          False.

        Parameters
        ----------
        dt : None or datetime.datetime
            If None, then the current time is used.
        microseconds : bool
            Display microseconds or not.

        Returns
        -------
        A string timestamp.
    """
    if dt is None:
        dt = datetime.datetime.now()
    else:
        # Operate on a copy.
        dt = copy.copy(dt)

    if not microseconds:
        # The microseconds are largely uninformative but annoying.
        dt = dt.replace(microsecond=0)

    stamp = dt.isoformat().replace(':', '_')

    return stamp


def python_name(name):
    """ Attempt to make a valid Python identifier out of a name.
    """

    if len(name) > 0:
        # Replace spaces with underscores.
        name = name.replace(' ', '_').lower()

        # If the name is a Python keyword then prefix it with an
        # underscore.
        if keyword.iskeyword(name):
            name = '_' + name

        # If the name starts with a digit then prefix it with an
        # underscore.
        if name[0].isdigit():
            name = '_' + name

    return name


### EOF ######################################################################


########NEW FILE########
__FILENAME__ = deprecated
""" A decorator for marking methods/functions as deprecated. """


# Standard library imports.
import logging

# We only warn about each function or method once!
_cache = {}


def deprecated(message):
    """ A factory for decorators for marking methods/functions as deprecated.

    """

    def decorator(fn):
        """ A decorator for marking methods/functions as deprecated. """

        def wrapper(*args, **kw):
            """ The method/function wrapper. """

            global _cache

            module_name = fn.__module__
            function_name = fn.__name__

            if (module_name, function_name) not in _cache:
                logging.getLogger(module_name).warn(
                    'DEPRECATED: %s.%s, %s' % (
                        module_name, function_name, message
                    )
                )

                _cache[(module_name, function_name)] = True

            return fn(*args, **kw)

        wrapper.__doc__  = fn.__doc__
        wrapper.__name__ = fn.__name__

        return wrapper

    return decorator

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = event_tracer
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------
""" Record trait change events in single and multi-threaded environments.

"""
import inspect
import os
import threading
from contextlib import contextmanager
from datetime import datetime

from traits import trait_notifiers


CHANGEMSG = (
    u"{time} {direction:-{direction}{length}} {name!r} changed from "
    u"{old!r} to {new!r} in {class_name!r}\n")
CALLINGMSG = u"{time} {action:>{gap}}: {handler!r} in {source}\n"
EXITMSG = (
    u"{time} {direction:-{direction}{length}} "
    u"EXIT: {handler!r}{exception}\n")
SPACES_TO_ALIGN_WITH_CHANGE_MESSAGE = 9


class SentinelRecord(object):
    """ Sentinel record to separate groups of chained change event dispatches.

    """
    __slots__ = ()

    def __unicode__(self):
        return u'\n'


class ChangeMessageRecord(object):
    """ Message record for a change event dispatch.

    """

    __slots__ = ('time', 'indent', 'name', 'old', 'new', 'class_name')

    def __init__(self, time, indent, name, old, new, class_name):
        #: Time stamp in UTC.
        self.time = time
        #: Depth level in a chain of trait change dispatches.
        self.indent = indent
        #: The name of the trait that changed
        self.name = name
        #: The old value.
        self.old = old
        #: The new value.
        self.new = new
        #: The name of the class that the trait change took place.
        self.class_name = class_name

    def __unicode__(self):
        length = self.indent * 2
        return CHANGEMSG.format(
            time=self.time,
            direction='>',
            name=self.name,
            old=self.old,
            new=self.new,
            class_name=self.class_name,
            length=length,
        )


class CallingMessageRecord(object):
    """ Message record for a change handler call.

    """

    __slots__ = ('time', 'indent', 'handler', 'source')

    def __init__(self, time, indent, handler, source):
        #: Time stamp in UTC.
        self.time = time
        #: Depth level of the call in a chain of trait change dispatches.
        self.indent = indent
        #: The traits change handler that is called.
        self.handler = handler
        #: The source file where the handler was defined.
        self.source = source

    def __unicode__(self):
        gap = self.indent * 2 + SPACES_TO_ALIGN_WITH_CHANGE_MESSAGE
        return CALLINGMSG.format(
            time=self.time,
            action='CALLING',
            handler=self.handler,
            source=self.source,
            gap=gap)


class ExitMessageRecord(object):
    """ Message record for returning from a change event dispatch.

    """

    __slots__ = ('time', 'indent', 'handler', 'exception')

    def __init__(self, time, indent, handler, exception):
        #: Time stamp in UTC.
        self.time = time
        #: Depth level of the exit in a chain of trait change dispatch.
        self.indent = indent
        #: The traits change handler that is called.
        self.handler = handler
        #: The exception type (if one took place)
        self.exception = exception

    def __unicode__(self):
        length = self.indent * 2
        return EXITMSG.format(
            time=self.time,
            direction='<',
            handler=self.handler,
            exception=self.exception,
            length=length,
        )


class RecordContainer(object):
    """ A simple record container.

     This class is commonly used to hold records from a single thread.

    """

    def __init__(self):
        self._records = []

    def record(self, record):
        """ Add the record into the container.

        """

        self._records.append(record)

    def save_to_file(self, filename):
        """ Save the records into a file.

        """
        with open(filename, 'w') as fh:
            for record in self._records:
                fh.write(unicode(record))


class MultiThreadRecordContainer(object):
    """ A container of record containers that are used by separate threads.

    Each record container is mapped to a thread name id. When a RecordContainer
    does not exist for a specific thread a new empty RecordContainer will be
    created on request.


    """

    def __init__(self):
        self._creation_lock = threading.Lock()
        self._record_containers = {}

    def get_change_event_collector(self, thread_name):
        """ Return the dedicated RecordContainer for the thread.

        If no RecordContainer is found for `thread_name` then a new
        RecordContainer is created.

        """
        with self._creation_lock:
            container = self._record_containers.get(thread_name)
            if container is None:
                container = RecordContainer()
                self._record_containers[thread_name] = container
            return container

    def save_to_directory(self, directory_name):
        """ Save records files into the directory.

        Each RecordContainer will dump its records on a separate file named
        <thread_name>.trace.

        """
        with self._creation_lock:
            containers = self._record_containers
            for thread_name, container in containers.iteritems():
                filename = os.path.join(
                    directory_name, '{0}.trace'.format(thread_name))
                container.save_to_file(filename)


class ChangeEventRecorder(object):
    """ A single thread trait change event recorder.

    """

    def __init__(self, container):
        """ Class constructor

        Parameters
        ----------
        container : MultiThreadRecordContainer
           An container to store the records for each trait change.

        """
        self.indent = 1
        self.container = container

    def pre_tracer(self, obj, name, old, new, handler):
        """ Record a string representation of the trait change dispatch

        """
        indent = self.indent
        time = datetime.utcnow().isoformat(' ')
        container = self.container
        container.record(
            ChangeMessageRecord(
                time=time,
                indent=indent,
                name=name,
                old=old,
                new=new,
                class_name=obj.__class__.__name__,
            ),
        )

        container.record(
            CallingMessageRecord(
                time=time,
                indent=indent,
                handler=handler.__name__,
                source=inspect.getsourcefile(handler),
            ),
        )
        self.indent += 1

    def post_tracer(self, obj, name, old, new, handler, exception=None):
        """ Record a string representation of the trait change return

        """
        time = datetime.utcnow().isoformat(' ')
        self.indent -= 1
        indent = self.indent
        if exception:
            exception_msg = ' [EXCEPTION: {}]'.format(exception)
        else:
            exception_msg = ''

        container = self.container

        container.record(
            ExitMessageRecord(
                time=time,
                indent=indent,
                handler=handler.__name__,
                exception=exception_msg,
            ),
        )

        if indent == 1:
            container.record(SentinelRecord())


class MultiThreadChangeEventRecorder(object):
    """ A thread aware trait change recorder.

    The class manages multiple ChangeEventRecorders which record trait change
    events for each thread in a separate file.

    """

    def __init__(self, container):
        """ Object constructor

        Parameters
        ----------
        container : MultiThreadChangeEventRecorder
            The container of RecordContainers to keep the trait change records
            for each thread.

        """
        self.tracers = {}
        self._tracer_lock = threading.Lock()
        self.container = container

    def close(self):
        """ Close and stop all logging.

        """
        with self._tracer_lock:
            self.tracers = {}

    def pre_tracer(self, obj, name, old, new, handler):
        """ The traits pre event tracer.

        This method should be set as the global pre event tracer for traits.

        """
        tracer = self._get_tracer()
        tracer.pre_tracer(obj, name, old, new, handler)

    def post_tracer(self, obj, name, old, new, handler, exception=None):
        """ The traits post event tracer.

        This method should be set as the global post event tracer for traits.

        """
        tracer = self._get_tracer()
        tracer.post_tracer(obj, name, old, new, handler, exception=exception)

    def _get_tracer(self):
        with self._tracer_lock:
            thread = threading.current_thread().name
            if thread not in self.tracers:
                container = self.container
                thread_container = container.get_change_event_collector(
                    thread)
                tracer = ChangeEventRecorder(thread_container)
                self.tracers[thread] = tracer
                return tracer
            else:
                return self.tracers[thread]


@contextmanager
def record_events():
    """ Multi-threaded trait change event tracer.

    Usage
    -----
    ::

        >>> from trace_recorder import record_events
        >>> with record_events() as change_event_container:
        ...     my_model.some_trait = True
        >>> change_event_container.save_to_directory('C:\\dev\\trace')

    This will install a tracer that will record all events that occur from
    setting of some_trait on the my_model instance.

    The results will be stored in one file per running thread in the
    directory 'C:\\dev\\trace'.  The files are named after the thread being
    traced.

    """
    container = MultiThreadRecordContainer()
    recorder = MultiThreadChangeEventRecorder(container=container)
    trait_notifiers.set_change_event_tracers(
        pre_tracer=recorder.pre_tracer, post_tracer=recorder.post_tracer)

    try:
        yield container
    finally:
        trait_notifiers.clear_change_event_tracers()
        recorder.close()

########NEW FILE########
__FILENAME__ = home_directory
#------------------------------------------------------------------------------
# Copyright (c) 2005, 2006 by Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought util package component>
#------------------------------------------------------------------------------
import os

def get_home_directory():
    """ Determine the user's home directory."""

    # 'HOME' should work on most Unixes, and 'USERPROFILE' works on at
    # least Windows XP ;^)
    #
    # FIXME: Is this really better than the following??
    #       path = os.path.expanduser('~')
    # The above seems to work on both Windows and Unixes though the docs
    # indicate it might not work as well on Macs.
    for name in ['HOME', 'USERPROFILE']:
        if name in os.environ:
            # Make sure that the path ends with a path separator.
            path = os.environ[name]
            if path[-1] != os.path.sep:
                path += os.path.sep

            break

    # If all else fails, the current directory will do.
    else:
        path = ''

    return path

########NEW FILE########
__FILENAME__ = import_symbol
""" A function to import symbols. """


def import_symbol(symbol_path):
    """ Import the symbol defined by the specified symbol path.

    Examples
    --------

    import_symbol('tarfile:TarFile') -> TarFile
    import_symbol('tarfile:TarFile.open') -> TarFile.open

    To allow compatibility with old-school traits symbol names we also allow
    all-dotted paths, but in this case you can only import top-level names
    from the module.

    import_symbol('tarfile.TarFile') -> TarFile

    """

    if ':' in symbol_path:
        module_name, symbol_name = symbol_path.split(':')

        module = __import__(module_name, {}, {}, [symbol_name], 0)
        symbol = eval(symbol_name, module.__dict__)

    else:
        components  = symbol_path.split('.')
        module_name = '.'.join(components[:-1])
        symbol_name = components[-1]

        module = __import__(module_name, {}, {}, [symbol_name], 0)
        symbol = getattr(module, symbol_name)

    return symbol

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = resource
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought util package component>
#------------------------------------------------------------------------------
""" Utility functions for managing and finding resources (ie. images/files etc).

    get_path :           Returns the absolute path of a class or instance

    create_unique_name : Creates a name with a given prefix that is not in a
                         given list of existing names. The separator between the
                         prefix and the rest of the name can also be specified
                         (default is a '_')

    find_resource:       Given a setuptools project specification string
                         ('MyProject>=2.1') and a partial path leading from the
                         projects base directory to the desired resource, will
                         return either an opened file object or, if specified, a
                         full path to the resource.
"""


# Standard library imports.
import inspect, os, sys
from distutils.sysconfig import get_python_lib


def get_path(path):
    """ Returns an absolute path for the specified path.

    'path' can be a string, class or instance.

    """

    if type(path) is not str:
        # Is this a class or an instance?
        if inspect.isclass(path):
            klass = path

        else:
            klass = path.__class__

        # Get the name of the module that the class was loaded from.
        module_name = klass.__module__

        # Look the module up.
        module = sys.modules[module_name]

        if module_name == '__main__':
            dirs = [os.path.dirname(sys.argv[0]), os.getcwd()]
            for d in dirs:
                if os.path.exists(d):
                    path = d
                    break
        else:
            # Get the path to the module.
            path = os.path.dirname(module.__file__)

    return path

def create_unique_name(prefix, names, separator='_'):
    """ Creates a name starting with 'prefix' that is not in 'names'. """

    i = 1

    name = prefix
    while name in names:
        name = prefix + separator + str(i)
        i += 1

    return name

def find_resource(project, resource_path, alt_path=None, return_path=False):
    """ Returns a file object or file path pointing to the desired resource.

    Parameters
    ----------
    project : str
        The name of the project to look for the resource in. Can be the name or
        a requirement string. Ex: 'MyProject', 'MyProject>1.0', 'MyProject==1.1'
    resource_path : str
        The path to the file from inside the package. If the file desired is
        MyProject/data/image.jpg, resource_path would be 'data/image.jpg'.
    alt_path : str
        The path to the resource relative to the location of the application's
        top-level script (the one with __main__). If this function is called in
        code/scripts/myscript.py and the resource is code/data/image.jpg, the
        alt_path would be '../data/image.jpg'. This path is only used if the
        resource cannot be found using setuptools.
    return_path : bool
        Determines whether the function should return a file object or a full
        path to the resource.

    Returns
    -------
    file : file object or file path
        A file object containing the resource. If return_path is True, 'file'
        will be the full path to the resource. If the file is not found or
        cannot be opened, None is returned.

    Description
    -----------
    This function will find a desired resource file and return an opened file
    object. The main method of finding the resource uses the pkg_resources
    resource_stream method, which searches your working set for the installed
    project specified and appends the resource_path given to the project
    path, leading it to the file. If setuptools is not installed or it cannot
    find/open the resource, find_resource will use the sys.path[0] to find the
    resource if alt_path is defined.
    """

    try:
        # Get the image using the pkg_resources resource_stream module, which
        # will find the file by getting the Chaco install path and appending the
        # image path. This method works in all cases as long as setuptools is
        # installed. If setuptools isn't installed, the backup sys.path[0]
        # method is used.
        from pkg_resources import resource_stream, working_set, Requirement

        # Get a requirement for the project
        requirement = Requirement.parse(project)

        if return_path:
            dist = working_set.find(requirement)
            full_path = os.path.join(dist.location, resource_path)

            # If the path exists, return it
            if os.path.exists(full_path):
                return full_path
            else:
                raise
        else:
            return resource_stream(requirement, resource_path)

    except:
        # Setuptools was either not installed, or it failed to find the file.
        # First check to see if the package was installed using egginst by
        # looking for the file at: site-packages\\resouce_path
        full_path = os.path.join(get_python_lib(), resource_path)
        if os.path.exists(full_path):
            if return_path:
                return full_path
            else:
                return open(full_path, 'rb')

        # Get the image using sys.path[0], which is the directory that the
        # running script lives in. The path to the file is then constructed by
        # navigating from the script's location. This method only works if this
        # script is called directly from the command line using
        # 'python %SOMEPATH%/<script>'
        if alt_path is None:
            return
        if return_path:
            return os.path.join(sys.path[0], alt_path)

        # Try to open the file, return None on exception
        try:
            return open(os.path.join(sys.path[0], alt_path), 'rb')
        except:
            return


def store_resource(project, resource_path, filename):
    """ Store the content of a resource, given by the name of the project
        and the path (relative to the root of the project), into a newly
        created file.

        The first two arguments (project and resource_path) are the same
        as for the function find_resource in this module.  The third
        argument (filename) is the name of the file which will be created,
        or overwritten if it already exists.
        The return value in always None.
    """
    fi = find_resource(project, resource_path)
    if fi is None:
        raise RuntimeError('Resource not found for project "%s": %s' %
                           (project, resource_path))

    fo = open(filename, 'wb')
    fo.write(fi.read())
    fo.close()

    fi.close()


#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_async_trait_wait
import random
import threading
import time
import unittest

from traits.api import Enum, HasStrictTraits

from traits.util.async_trait_wait import wait_for_condition


class TrafficLights(HasStrictTraits):
    colour = Enum('Green', 'Amber', 'Red', 'RedAndAmber')

    _next_colour = {
        'Green': 'Amber',
        'Amber': 'Red',
        'Red': 'RedAndAmber',
        'RedAndAmber': 'Green',
    }

    def make_random_changes(self, change_count):
        for _ in xrange(change_count):
            time.sleep(random.uniform(0.1, 0.3))
            self.colour = self._next_colour[self.colour]


class TestAsyncTraitWait(unittest.TestCase):
    def test_wait_for_condition_success(self):
        lights = TrafficLights(colour='Green')
        t = threading.Thread(target=lights.make_random_changes, args=(2,))
        t.start()

        wait_for_condition(
            condition=lambda l: l.colour == 'Red',
            obj=lights,
            trait='colour',
        )

        self.assertEqual(lights.colour, 'Red')
        t.join()

    def test_wait_for_condition_failure(self):
        lights = TrafficLights(colour='Green')
        t = threading.Thread(target=lights.make_random_changes, args=(2,))
        t.start()

        self.assertRaises(
            RuntimeError,
            wait_for_condition,
            condition=lambda l: l.colour == 'RedAndAmber',
            obj=lights,
            trait='colour',
            timeout=5.0,
            )
        t.join()

    def test_traits_handler_cleaned_up(self):
        # An older version of wait_for_condition failed to clean up
        # the trait handler, leading to possibly evaluation of the
        # condition after the 'wait_for_condition' call had returned.

        self.lights = TrafficLights(colour='Green')
        t = threading.Thread(target=self.lights.make_random_changes, args=(3,))
        t.start()
        wait_for_condition(
            condition=lambda l: self.lights.colour == 'Red',
            obj=self.lights,
            trait='colour',
        )
        del self.lights

        # If the condition gets evaluated again past this point, we'll
        # see an AttributeError from the failed self.lights lookup.

        # assertSucceeds!
        t.join()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_camel_case
# Standard library imports.
from traits.testing.unittest_tools import unittest

# Local imports.
from traits.util.camel_case import camel_case_to_python, camel_case_to_words


class CamelCaseTestCase(unittest.TestCase):

    def test_python_conversion(self):
        """ Does CamelCase -> Python name work?
        """
        c_names = [ 'GetFooBar', 'GetOBBTree', 'XMLDataReader',
                    'GetFooXML', 'HTMLIsSGML', '_SetMe', '_XYZTest',
                    'Actor2D', 'Actor3D', 'Actor6D', 'PLOT3DReader',
                    'Actor61Dimension', 'GL2PSExporter', 'Volume16Reader' ]
        t_names = [ 'get_foo_bar', 'get_obb_tree', 'xml_data_reader',
                    'get_foo_xml', 'html_is_sgml', '_set_me',
                    '_xyz_test', 'actor2d', 'actor3d', 'actor6_d',
                    'plot3d_reader', 'actor61_dimension',
                    'gl2ps_exporter', 'volume16_reader' ]
        for i, c_name in enumerate(c_names):
            t_name = camel_case_to_python(c_name)
            self.assertEqual(t_name, t_names[i])

    def test_word_conversion(self):
        """ Does CamelCase -> words work?
        """
        self.assertEqual(camel_case_to_words('FooBarBaz'), 'Foo Bar Baz')


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_import_symbol
""" Tests for the import manager. """


from traits.util.api import import_symbol
from traits.testing.unittest_tools import unittest


class TestImportSymbol(unittest.TestCase):
    """ Tests for the import manager. """

    def test_import_dotted_symbol(self):
        """ import dotted symbol """

        import tarfile

        symbol = import_symbol('tarfile.TarFile')
        self.assertEqual(symbol, tarfile.TarFile)

        return

    def test_import_nested_symbol(self):
        """ import nested symbol """

        import tarfile

        symbol = import_symbol('tarfile:TarFile.open')
        self.assertEqual(symbol, tarfile.TarFile.open)

        return

    def test_import_dotted_module(self):
        """ import dotted module """

        symbol = import_symbol(
            'traits.util.import_symbol:import_symbol'
        )

        self.assertEqual(symbol, import_symbol)

        return


if __name__ == '__main__':
    unittest.main()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = test_message_records
#----------------------------------------------------------------------------
# Copyright (c) 2014, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
#
# Thanks for using Enthought open source!
#
#----------------------------------------------------------------------------
import unittest
from traits.util.event_tracer import (
    SentinelRecord, ChangeMessageRecord, CallingMessageRecord,
    ExitMessageRecord)


class TestMessageRecords(unittest.TestCase):

    def test_base_message_record(self):
        record = SentinelRecord()

        # Check unicode output
        self.assertEqual(unicode(record), u'\n')

        # Check initialization
        self.assertRaises(TypeError, SentinelRecord, sdd=0)

    def test_change_message_record(self):
        record = ChangeMessageRecord(
            time=1,  indent=3, name='john', old=1, new=1,
            class_name='MyClass')

        # Check unicode output
        self.assertEqual(
            unicode(record),
            u"1 -----> 'john' changed from 1 to 1 in 'MyClass'\n")

        # Check initialization
        self.assertRaises(TypeError, ChangeMessageRecord, sdd=0)

    def test_exit_message_record(self):
        record = ExitMessageRecord(
            time=7,  indent=5, handler='john', exception='sssss')

        # Check unicode output
        self.assertEqual(
            unicode(record), u"7 <--------- EXIT: 'john'sssss\n")

        # Check initialization
        self.assertRaises(TypeError, ExitMessageRecord, sdd=0)

    def test_calling_message_record(self):
        record = CallingMessageRecord(
            time=7,  indent=5, handler='john', source='sssss')

        # Check unicode output
        self.assertEqual(
            unicode(record), u"7             CALLING: 'john' in sssss\n")

        # Check initialization
        self.assertRaises(TypeError, CallingMessageRecord, sdd=0)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_record_containers
#----------------------------------------------------------------------------
# Copyright (c) 2014, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
#
# Thanks for using Enthought open source!
#
#----------------------------------------------------------------------------
import os
import shutil
import tempfile
import threading
import unittest
from traits.util.event_tracer import (
    SentinelRecord, RecordContainer, MultiThreadRecordContainer)


class TestRecordContainers(unittest.TestCase):

    def setUp(self):
        self.directory = tempfile.mkdtemp()
        self.filename = os.path.join(self.directory, 'myfile')

    def tearDown(self):
        shutil.rmtree(self.directory)

    def test_record_container(self):
        container = RecordContainer()

        # add records
        for i in range(7):
            container.record(SentinelRecord())
        self.assertEqual(len(container._records), 7)

        # save records
        container.save_to_file(self.filename)

        with open(self.filename, 'Ur') as handle:
            lines = handle.readlines()
        self.assertEqual(lines, ['\n'] * 7)

    def test_multi_thread_record_container(self):
        container = MultiThreadRecordContainer()

        def record(container):
            thread = threading.current_thread().name
            collector = container.get_change_event_collector(thread)
            collector.record(SentinelRecord())

        thread_1 = threading.Thread(target=record, args=(container,))
        thread_2 = threading.Thread(target=record, args=(container,))
        thread_1.start()
        thread_2.start()
        record(container)
        thread_2.join()
        thread_1.join()

        self.assertEqual(len(container._record_containers), 3)
        for collector in container._record_containers.itervalues():
            self.assertTrue(
                isinstance(collector._records[0], SentinelRecord))
            self.assertEqual(len(collector._records), 1)

        # save records
        container.save_to_directory(self.directory)
        for name in container._record_containers:
            filename = os.path.join(self.directory, '{0}.trace'.format(name))
            with open(filename, 'Ur') as handle:
                lines = handle.readlines()
            self.assertEqual(lines, ['\n'])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_record_events
#----------------------------------------------------------------------------
# Copyright (c) 2005-2013, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
#
# Thanks for using Enthought open source!
#
#----------------------------------------------------------------------------
import os
import shutil
import tempfile
import threading
import unittest

from traits.api import HasTraits, on_trait_change, Bool, Float, List
from traits import trait_notifiers
from traits.util.event_tracer import (
    ChangeEventRecorder, MultiThreadChangeEventRecorder,
    MultiThreadRecordContainer, RecordContainer, record_events)


class TestObject(HasTraits):

    number = Float(2.0)
    list_of_numbers = List(Float())
    flag = Bool

    @on_trait_change('number')
    def _add_number_to_list(self, value):
        self.list_of_numbers.append(value)

    def add_to_number(self, value):
        self.number += value


class TestRecordEvents(unittest.TestCase):

    def setUp(self):
        self.directory = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.directory)

    def test_change_event_recorder(self):
        test_object = TestObject()
        container = RecordContainer()
        recorder = ChangeEventRecorder(container=container)
        trait_notifiers.set_change_event_tracers(
            pre_tracer=recorder.pre_tracer,
            post_tracer=recorder.post_tracer)
        try:
            test_object.number = 5.0
        finally:
            trait_notifiers.clear_change_event_tracers()

        filename = os.path.join(self.directory, 'MainThread.trace')
        container.save_to_file(filename)
        with open(filename, 'Ur') as handle:
            lines = handle.readlines()
            self.assertEqual(len(lines), 4)
            # very basic checking
            self.assertTrue(
                "-> 'number' changed from 2.0 to 5.0 in 'TestObject'\n"
                in lines[0])
            self.assertTrue('CALLING' in lines[1])
            self.assertTrue('EXIT' in lines[2])

    def test_multi_thread_change_event_recorder(self):
        test_object = TestObject()
        container = MultiThreadRecordContainer()
        recorder = MultiThreadChangeEventRecorder(container=container)
        trait_notifiers.set_change_event_tracers(
            pre_tracer=recorder.pre_tracer,
            post_tracer=recorder.post_tracer)
        try:
            test_object.number = 5.0
            thread = threading.Thread(
                target=test_object.add_to_number, args=(5,))
            thread.start()
            thread.join()
        finally:
            trait_notifiers.clear_change_event_tracers()
        self.assertEqual(len(container._record_containers), 2)

        # save records
        container.save_to_directory(self.directory)
        for name in container._record_containers:
            filename = os.path.join(self.directory, '{0}.trace'.format(name))
            with open(filename, 'Ur') as handle:
                lines = handle.readlines()
            self.assertEqual(len(lines), 4)
            # very basic checking
            if 'MainThread.trace' in filename:
                self.assertTrue(
                    "-> 'number' changed from 2.0 to 5.0 in 'TestObject'\n"
                    in lines[0])
            else:
                self.assertTrue(
                    "-> 'number' changed from 5.0 to 10.0 in 'TestObject'\n"
                    in lines[0])
            self.assertTrue('CALLING' in lines[1])
            self.assertTrue('EXIT' in lines[2])

    def test_record_events(self):
        test_object = TestObject()
        with record_events() as container:
            test_object.number = 5.0
            thread = threading.Thread(
                target=test_object.add_to_number, args=(3,))
            thread.start()
            thread.join()

        # save records
        container.save_to_directory(self.directory)
        for name in container._record_containers:
            filename = os.path.join(self.directory, '{0}.trace'.format(name))
            with open(filename, 'Ur') as handle:
                lines = handle.readlines()
            self.assertEqual(len(lines), 4)
            # very basic checking
            if 'MainThread.trace' in filename:
                self.assertTrue(
                    "-> 'number' changed from 2.0 to 5.0 in 'TestObject'\n"
                    in lines[0])
            else:
                self.assertTrue(
                    "-> 'number' changed from 5.0 to 8.0 in 'TestObject'\n"
                    in lines[0])
            self.assertTrue('CALLING' in lines[1])
            self.assertTrue('EXIT' in lines[2])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = toposort
#-----------------------------------------------------------------------------
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought util package component>
#
#-----------------------------------------------------------------------------

""" A simple topological sort on a dictionary graph.
"""

class CyclicGraph(Exception):
    """
    Exception for cyclic graphs.
    """
    def __init__(self):
        Exception.__init__(self, "Graph is cyclic")


def topological_sort(graph):
    """
    Returns the nodes in the graph in topological order.
    """
    discovered = {}
    explored = {}
    order = []
    def explore(node):
        children = graph.get(node, [])
        for child in children:
            if child in explored:
                pass
            elif child in discovered:
                raise CyclicGraph()
            else:
                discovered[child] = 1
                explore(child)
        explored[node] = 1
        order.append(node)

    for node in graph.keys():
        if node not in explored:
            explore(node)
    order.reverse()
    return order



########NEW FILE########
__FILENAME__ = trait_documenter
# -*- coding: utf-8 -*-
"""
    A Trait Documenter
    (Subclassed from the autodoc ClassLevelDocumenter)

    :copyright: Copyright 2012 by Enthought, Inc

"""
import traceback
import sys
import inspect
import tokenize
import token
import StringIO

from sphinx.ext.autodoc import ClassLevelDocumenter

from ..trait_handlers import TraitType
from ..has_traits import MetaHasTraits


def _is_class_trait(name, cls):
    """ Check if the name is in the list of class defined traits of ``cls``.
    """
    return isinstance(cls, MetaHasTraits) and name in cls.__class_traits__


class TraitDocumenter(ClassLevelDocumenter):
    """ Specialized Documenter subclass for trait attributes.

    The class defines a new documenter that recovers the trait definition
    signature of module level and class level traits.

    To use the documenter, append the module path in the extension
    attribute of the `conf.py`.

    .. warning::

        Using the TraitDocumenter in conjunction with TraitsDoc is not
        advised.

    """

    ### ClassLevelDocumenter interface #####################################

    objtype = 'traitattribute'
    directivetype = 'attribute'
    member_order = 60

    # must be higher than other attribute documenters
    priority = 12

    @classmethod
    def can_document_member(cls, member, membername, isattr, parent):
        """ Check that the documented member is a trait instance.
        """
        check = (isattr and issubclass(type(member), TraitType) or
                 _is_class_trait(membername, parent.object))
        return check

    def document_members(self, all_members=False):
        """ Trait attributes have no members """
        pass

    def add_content(self, more_content, no_docstring=False):
        """ Never try to get a docstring from the trait."""
        ClassLevelDocumenter.add_content(self, more_content,
                                         no_docstring=True)

    def import_object(self):
        """ Get the Trait object.

        Notes
        -----
        Code adapted from autodoc.Documenter.import_object.

        """
        try:
            __import__(self.modname)
            current = self.module = sys.modules[self.modname]
            for part in self.objpath[:-1]:
                current = self.get_attr(current, part)
            name = self.objpath[-1]
            self.object_name = name
            self.object = None
            self.parent = current
            return True
        # this used to only catch SyntaxError, ImportError and
        # AttributeError, but importing modules with side effects can raise
        # all kinds of errors.
        except Exception, err:
            if self.env.app and not self.env.app.quiet:
                self.env.app.info(traceback.format_exc().rstrip())
            msg = ('autodoc can\'t import/find {0} {r1}, it reported error: '
                   '"{2}", please check your spelling and sys.path')
            self.directive.warn(msg.format(self.objtype, str(self.fullname),
                                                                        err))
            self.env.note_reread()
            return False

    def add_directive_header(self, sig):
        """ Add the directive header 'attribute' with the annotation
        option set to the trait definition.

        """
        ClassLevelDocumenter.add_directive_header(self, sig)
        definition = self._get_trait_definition()
        self.add_line(u'   :annotation: = {0}'.format(definition),
                      '<autodoc>')

    ### Private Interface #####################################################

    def _get_trait_definition(self):
        """ Retrieve the Trait attribute definition
        """

        # Get the class source and tokenize it.
        source = inspect.getsource(self.parent)
        string_io = StringIO.StringIO(source)
        tokens = tokenize.generate_tokens(string_io.readline)

        # find the trait definition start
        trait_found = False
        name_found = False
        while not trait_found:
            item = tokens.next()
            if name_found and item[:2] == (token.OP, '='):
                trait_found = True
                continue
            if item[:2] == (token.NAME, self.object_name):
                name_found = True

        # Retrieve the trait definition.
        definition_tokens = []
        for type, name, start, stop, line in tokens:
            if type == token.NEWLINE:
                break
            item = (type, name, (0, start[1]), (0, stop[1]), line)
            definition_tokens.append(item)

        return tokenize.untokenize(definition_tokens).strip()


def setup(app):
    """ Add the TraitDocumenter in the current sphinx autodoc instance. """
    app.add_autodocumenter(TraitDocumenter)

########NEW FILE########
__FILENAME__ = _py2to3
""" Helper module, providing a common API for tasks that require a different implementation in python 2 and 3.
"""

from __future__ import division, absolute_import

import sys


if sys.version_info[0] < 3:
    import string
    str_find = string.find
    str_rfind = string.rfind
else:
    str_find = str.find
    str_rfind = str.rfind

if sys.version_info[0] < 3:
    from types import InstanceType,ClassType
    def is_old_style_instance(obj):
        return type(obj) is InstanceType
    def is_old_style_class(obj):
        return type(obj) is ClassType
    def is_InstanceType(obj):
        return obj is InstanceType
    def is_ClassType(obj):
        return obj is ClassType
else:
    def is_old_style_instance(obj):
        return False
    def is_old_style_instance(obj):
        return False
    def is_InstanceType(obj):
        return False
    def is_ClassType(obj):
        return False


if sys.version_info[0] < 3:
    from types import InstanceType
    def type_w_old_style(obj):
        the_type = type(obj)
        if the_type is InstanceType:
            # Old-style class.
            the_type = obj.__class__
        return the_type
else:
    type_w_old_style = type

if sys.version_info[0] < 3:
    from types import ClassType
    ClassTypes    = ( ClassType, type )
else:
    ClassTypes    = ( type, )


import contextlib
if sys.version_info[0] < 3:
    def nested_context_mgrs(*args):
        return contextlib.nested(*args)
else:
    if sys.version_info[:2] < (3,3):
        # ExitStack was introduced in python 3.3. We copy the 3.3 version here
        # to support python 3.2
        class ExitStack(object):
            """Context manager for dynamic management of a stack of exit callbacks
        
            For example:
        
                with ExitStack() as stack:
                    files = [stack.enter_context(open(fname)) for fname in filenames]
                    # All opened files will automatically be closed at the end of
                    # the with statement, even if attempts to open files later
                    # in the list raise an exception
        
            """
            def __init__(self):
                from collections import deque
                self._exit_callbacks = deque()
        
            def pop_all(self):
                """Preserve the context stack by transferring it to a new instance"""
                from collections import deque
                new_stack = type(self)()
                new_stack._exit_callbacks = self._exit_callbacks
                self._exit_callbacks = deque()
                return new_stack
        
            def _push_cm_exit(self, cm, cm_exit):
                """Helper to correctly register callbacks to __exit__ methods"""
                def _exit_wrapper(*exc_details):
                    return cm_exit(cm, *exc_details)
                _exit_wrapper.__self__ = cm
                self.push(_exit_wrapper)
        
            def push(self, exit):
                """Registers a callback with the standard __exit__ method signature
        
                Can suppress exceptions the same way __exit__ methods can.
        
                Also accepts any object with an __exit__ method (registering a call
                to the method instead of the object itself)
                """
                # We use an unbound method rather than a bound method to follow
                # the standard lookup behaviour for special methods
                _cb_type = type(exit)
                try:
                    exit_method = _cb_type.__exit__
                except AttributeError:
                    # Not a context manager, so assume its a callable
                    self._exit_callbacks.append(exit)
                else:
                    self._push_cm_exit(exit, exit_method)
                return exit # Allow use as a decorator
        
            def callback(self, callback, *args, **kwds):
                """Registers an arbitrary callback and arguments.
        
                Cannot suppress exceptions.
                """
                def _exit_wrapper(exc_type, exc, tb):
                    callback(*args, **kwds)
                # We changed the signature, so using @wraps is not appropriate, but
                # setting __wrapped__ may still help with introspection
                _exit_wrapper.__wrapped__ = callback
                self.push(_exit_wrapper)
                return callback # Allow use as a decorator
        
            def enter_context(self, cm):
                """Enters the supplied context manager
        
                If successful, also pushes its __exit__ method as a callback and
                returns the result of the __enter__ method.
                """
                # We look up the special methods on the type to match the with statement
                _cm_type = type(cm)
                _exit = _cm_type.__exit__
                result = _cm_type.__enter__(cm)
                self._push_cm_exit(cm, _exit)
                return result
        
            def close(self):
                """Immediately unwind the context stack"""
                self.__exit__(None, None, None)
        
            def __enter__(self):
                return self
        
            def __exit__(self, *exc_details):
                # We manipulate the exception state so it behaves as though
                # we were actually nesting multiple with statements
                frame_exc = sys.exc_info()[1]
                def _fix_exception_context(new_exc, old_exc):
                    while 1:
                        exc_context = new_exc.__context__
                        if exc_context in (None, frame_exc):
                            break
                        new_exc = exc_context
                    new_exc.__context__ = old_exc
        
                # Callbacks are invoked in LIFO order to match the behaviour of
                # nested context managers
                suppressed_exc = False
                while self._exit_callbacks:
                    cb = self._exit_callbacks.pop()
                    try:
                        if cb(*exc_details):
                            suppressed_exc = True
                            exc_details = (None, None, None)
                    except:
                        new_exc_details = sys.exc_info()
                        # simulate the stack of exceptions by setting the context
                        _fix_exception_context(new_exc_details[1], exc_details[1])
                        if not self._exit_callbacks:
                            raise
                        exc_details = new_exc_details
                return suppressed_exc
    else:
        ExitStack = contextlib.ExitStack

    class nested_context_mgrs(ExitStack):
        """ Emulation of python 2's :py:class:`contextlib.nested`.
        
        It has gone from python 3 due to it's deprecation status
        in python 2.
        
        Note that :py:class:`contextlib.nested` was deprecated for
        a reason: It has issues with context managers that fail
        during init. The same caveats also apply here.
        So do not use this unless really necessary!
        """
        def __init__(self,*args):
            super(nested_context_mgrs,self).__init__()
            self._ctxt_mgrs = args
        
        def __enter__(self):
            ret = []
            try:
                for mgr in self._ctxt_mgrs:
                    ret.append(self.enter_context(mgr))
            except:
                self.close()
                raise
            return tuple(ret)

if sys.version_info[0] < 3:
    def assertCountEqual(self,itemsA,itemsB):
        self.assertItemsEqual(itemsA,itemsB)
else:
    def assertCountEqual(self,itemsA,itemsB):
        self.assertCountEqual(itemsA,itemsB)
    
########NEW FILE########
