__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Traits documentation build configuration file, created by
# sphinx-quickstart on Tue Jul 22 10:52:03 2008.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

import sys, os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
#sys.path.append(os.path.abspath('some/directory'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'traitsui'
copyright = '2008-2013, Enthought'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# Pull from the actual release number without imports
d = {}
execfile(os.path.join('..', '..', 'traitsui', '__init__.py'), d)
version = release = d['__version__']

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directories, that shouldn't be searched
# for source files.
#exclude_dirs = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "TraitsUI 4 User Manual"

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (within the static path) to place at the top of
# the sidebar.
html_logo = "e-logo-rev.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = "et.ico"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static',
                    os.path.join('tutorials','code_snippets')]

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = False

# If false, no index is generated.
#html_use_index = False

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Traitsuidoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [
  ('index', 'TraitsUI.tex', 'TraitsUI 4 User Manual', 'Enthought, Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = "enthought_logo.jpg"
latex_logo = "e-logo-rev.png"

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = code_block0
from numpy import cos, sin

class Point(object):
    """ 3D Points objects """
    x = 0.
    y = 0.
    z = 0.

    def rotate_z(self, theta):
        """ rotate the point around the Z axis """
        xtemp =  cos(theta) * self.x + sin(theta) * self.y
        ytemp = -sin(theta) * self.x + cos(theta) * self.y
        self.x = xtemp
        self.y = ytemp


########NEW FILE########
__FILENAME__ = code_block1
from traits.api import *
from traitsui.api import *

class Camera( HasTraits ):
   """ Camera object """
   gain = Enum(1, 2, 3,
      desc="the gain index of the camera",
      label="gain", )
   exposure = CInt(10,
      desc="the exposure time, in ms",
      label="Exposure", )

   def capture(self):
      """ Captures an image on the camera and returns it """
      print "capturing an image at %i ms exposure, gain: %i" % (
                    self.exposure, self.gain )

if  __name__ == "__main__":
   camera = Camera()
   camera.configure_traits()
   camera.capture()


########NEW FILE########
__FILENAME__ = container
from traits.api import *
from traitsui.api import *

class Camera(HasTraits):
    """ Camera object """

    gain = Enum(1, 2, 3,
        desc="the gain index of the camera",
        label="gain", )

    exposure = CInt(10,
        desc="the exposure time, in ms",
        label="Exposure", )

class Display(HasTraits):
    string = String()

    view= View( Item('string', show_label=False, springy=True, style='custom' ))

class Container(HasTraits):
    camera = Instance(Camera, ())
    display = Instance(Display, ())

    view = View(
                Item('camera', style='custom', show_label=False, ),
                Item('display', style='custom', show_label=False, ),
               )

Container().configure_traits()


########NEW FILE########
__FILENAME__ = echo_box
from traits.api import *

class EchoBox(HasTraits):
    input =  Str()
    output = Str()

    def _input_changed(self):
        self.output = self.input

EchoBox().configure_traits()


########NEW FILE########
__FILENAME__ = event_loop
from traits.api import *
import wx

class Counter(HasTraits):
    value =  Int()

Counter().edit_traits()
wx.PySimpleApp().MainLoop()


########NEW FILE########
__FILENAME__ = interactive
from traits import *
from pyface.api import GUI
from traitsui import View, Item, ButtonEditor

class Counter(HasTraits):
    value =  Int()
    add_one = Button()

    def _add_one_fired(self):
        self.value +=1

    view = View('value', Item('add_one', show_label=False ))

Counter().edit_traits()
GUI().start_event_loop()


########NEW FILE########
__FILENAME__ = mpl_figure_editor

import wx

import matplotlib
# We want matplotlib to use a wxPython backend
matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.backends.backend_wx import NavigationToolbar2Wx

from traits.api import Any, Instance
from traitsui.wx.editor import Editor
from traitsui.wx.basic_editor_factory import BasicEditorFactory

class _MPLFigureEditor(Editor):

    scrollable  = True

    def init(self, parent):
        self.control = self._create_canvas(parent)
        self.set_tooltip()

    def update_editor(self):
        pass

    def _create_canvas(self, parent):
        """ Create the MPL canvas. """
        # The panel lets us add additional controls.
        panel = wx.Panel(parent, -1, style=wx.CLIP_CHILDREN)
        sizer = wx.BoxSizer(wx.VERTICAL)
        panel.SetSizer(sizer)
        # matplotlib commands to create a canvas
        mpl_control = FigureCanvas(panel, -1, self.value)
        sizer.Add(mpl_control, 1, wx.LEFT | wx.TOP | wx.GROW)
        toolbar = NavigationToolbar2Wx(mpl_control)
        sizer.Add(toolbar, 0, wx.EXPAND)
        self.value.canvas.SetMinSize((10,10))
        return panel

class MPLFigureEditor(BasicEditorFactory):

    klass = _MPLFigureEditor


if __name__ == "__main__":
    # Create a window to demo the editor
    from traits.api import HasTraits
    from traitsui.api import View, Item
    from numpy import sin, cos, linspace, pi

    class Test(HasTraits):

        figure = Instance(Figure, ())

        view = View(Item('figure', editor=MPLFigureEditor(),
                                show_label=False),
                        width=400,
                        height=300,
                        resizable=True)

        def __init__(self):
            super(Test, self).__init__()
            axes = self.figure.add_subplot(111)
            t = linspace(0, 2*pi, 200)
            axes.plot(sin(t)*(1+0.5*cos(11*t)), cos(t)*(1+0.5*cos(11*t)))

    Test().configure_traits()


########NEW FILE########
__FILENAME__ = thread_example
from threading import Thread
from time import sleep

class MyThread(Thread):
    def run(self):
        sleep(2)
        print "MyThread done"

my_thread = MyThread()

my_thread.start()
print "Main thread done"


########NEW FILE########
__FILENAME__ = traits_thread
from threading import Thread
from time import sleep
from traits.api import *
from traitsui.api import View, Item, ButtonEditor

class TextDisplay(HasTraits):
    string = String()

    view= View( Item('string',show_label=False, springy=True, style='custom' ))

class CaptureThread(Thread):
    def run(self):
        self.display.string = 'Camera started\n' + self.display.string  n_img = 0
        while not self.wants_abort:
            sleep(.5)
            n_img += 1
            self.display.string = '%d image captured\n' % n_img \ + self.display.string
        self.display.string = 'Camera stopped\n' + self.display.string

class Camera(HasTraits):
    start_stop_capture = Button()
    display = Instance(TextDisplay)
    capture_thread = Instance(CaptureThread)

    view = View( Item('start_stop_capture', show_label=False ))

    def _start_stop_capture_fired(self):
    if self.capture_thread and self.capture_thread.isAlive():
        self.capture_thread.wants_abort = True
    else:
        self.capture_thread = CaptureThread()
        self.capture_thread.wants_abort = False
        self.capture_thread.display = self.display
        self.capture_thread.start()

class MainWindow(HasTraits):
    display = Instance(TextDisplay, ())

    camera = Instance(Camera)

    def _camera_default(self):
        return Camera(display=self.display)

    view = View('display', 'camera', style="custom", resizable=True)

    if __name__ == '__main__':
        MainWindow().configure_traits()

########NEW FILE########
__FILENAME__ = Adapted_tree_editor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Demonstrates an alternative method of defining a <b>TreeEditor</b> by creating
<b>ITreeNodeAdapter</b> subclasses.

To run this demonstration successfully, you must have the <b>AppTools</b> egg
installed.

Using <b>ITreeNodeAdapters</b> can be useful in cases where the kind of content
of the tree is not always known ahead of time. For example, you might be
creating a reusable tool or component which can display its data in a tree
view, but you do not know what kind of data it will be asked to display when
you write the code. Therefore, it may be impossible for you to specify a
<b>TreeEditor</b> with a correct set of <b>TreeNode</b> objects that will work
in all possible future cases.

Using <b>ITreeNodeAdapter</b> subclasses, you can allow the clients of your code
to solve this problem by providing one of more <b>ITreeNodeAdapters</b> that
can be used to provide the correct tree node information for each type of data
that will appear in the <b>TreeEditor</b> view.

In this demo, we define an <b>ITreeNodeAdapter</b> subclass that adapts the
<i>apptools.io.file.File</i> class to be displayed in a file explorer style
tree view.
"""

#-- Imports --------------------------------------------------------------------

from os \
    import getcwd

from traits.api \
    import HasTraits, Property, Directory, adapts, property_depends_on

from traitsui.api \
    import View, VGroup, Item, TreeEditor, ITreeNode, ITreeNodeAdapter

from apptools.io.api \
    import File

#-- FileAdapter Class ----------------------------------------------------------

class FileAdapter ( ITreeNodeAdapter ):

    adapts( File, ITreeNode )

    #-- ITreeNodeAdapter Method Overrides --------------------------------------

    def allows_children ( self ):
        """ Returns whether this object can have children.
        """
        return self.adaptee.is_folder

    def has_children ( self ):
        """ Returns whether the object has children.
        """
        children = self.adaptee.children
        return ((children is not None) and (len( children ) > 0))

    def get_children ( self ):
        """ Gets the object's children.
        """
        return self.adaptee.children

    def get_label ( self ):
        """ Gets the label to display for a specified object.
        """
        return self.adaptee.name + self.adaptee.ext

    def get_tooltip ( self ):
        """ Gets the tooltip to display for a specified object.
        """
        return self.adaptee.absolute_path

    def get_icon ( self, is_expanded ):
        """ Returns the icon for a specified object.
        """
        if self.adaptee.is_file:
            return '<item>'

        if is_expanded:
            return '<open>'

        return '<open>'

    def can_auto_close ( self ):
        """ Returns whether the object's children should be automatically
            closed.
        """
        return True

#-- FileTreeDemo Class ---------------------------------------------------------

class FileTreeDemo ( HasTraits ):

    # The path to the file tree root:
    root_path = Directory( entries = 10 )

    # The root of the file tree:
    root = Property

    # The traits view to display:
    view = View(
        VGroup(
            Item( 'root_path' ),
            Item( 'root',
                  editor = TreeEditor( editable = False, auto_open = 1 )
            ),
            show_labels = False
        ),
        width     = 0.33,
        height    = 0.50,
        resizable = True
    )

    #-- Traits Default Value Methods -------------------------------------------

    def _root_path_default ( self ):
        return getcwd()

    #-- Property Implementations -----------------------------------------------

    @property_depends_on( 'root_path' )
    def _get_root ( self ):
        return File( path = self.root_path )

#-- Create and run the demo ----------------------------------------------------

demo = FileTreeDemo()

# Run the demo (if invoked form the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Apply_Revert_handler_demo
"""
Apply / Revert

Provides support in a dialog box for an "Apply" button which modifies the
object being viewed, and a "Revert" button, which returns the object to its
starting state (before any "Apply").

Note that this does not automatically provide a full (multi-step incremental)
Undo capability.
"""

from traits.api import HasTraits, Str, List
from traitsui.api import Item, View, Handler, HGroup, VGroup

# 'ApplyRevert_Handler' class:
class ApplyRevert_Handler(Handler):

    def apply(self, info):
        object = info.object
        object.stack.insert(0, object.input)
        object.queue.append(object.input)

    def revert(self, info):
        # Do something exciting here...
        print 'revert called...'

# 'ApplyRevertDemo' class:
class ApplyRevertDemo(HasTraits):

    # Trait definitions:
    input = Str
    stack = List
    queue = List

    # Traits view definitions:
    traits_view = View(
        VGroup(
            VGroup(
                Item('input',
                      show_label = False
                ),
                label       = 'Input',
                show_border = True
            ),
            HGroup(
                VGroup(
                    Item('stack',
                          show_label = False,
                          height     = 50,
                          width      = 100,
                          style      = 'readonly'
                    ),
                    label       = 'Stack',
                    show_border = True
                ),
                VGroup(
                    Item('queue',
                          show_label = False,
                          height     = 50,
                          width      = 100,
                          style      = 'readonly'
                    ),
                    label       = 'Queue',
                    show_border = True
                )
            )
        ),
        resizable = True,
        height = 300,
        title   = 'Apply/Revert example',
        buttons = [ 'Apply', 'Revert' ],
        handler = ApplyRevert_Handler
    )

# Create the demo:
modal_popup = ApplyRevertDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    modal_popup.configure_traits()

########NEW FILE########
__FILENAME__ = Auto_editable_readonly_table_cells
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This example shows how to define a read-only, auto-edit table column using a
custom pop-up view.

The example displays a list of integer values from 1 to n, where 'n' can be set
using the slider at the top of the view. Each entry in the list shows the value
of the integer and the number of unique factors it has.

Mousing over the number of factors for a particular integer displays a pop-up
list containing the unique factors for the integer. Mousing out of the cell
causes the pop-up list to be removed (and perhaps causes a new pop-up list to
be displayed, depending upon whether the mouse entered a new cell or not).

Creating the auto pop-up effect is achieved by setting the 'auto_editable' trait
of the associated ObjectColumn to True and also specifying a view to display
on mouse over as the value of the ObjectColumn's 'view' trait.

Note that this style of auto pop-up view can only be used with non-editable
table editor fields. If the field is editable, then setting 'auto_editable' to
True will cause the editor associated with the ObjectColumn to be automatically
activated on mouse over, rather than the pop-up view specified by the 'view'
trait.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, Int, List, Range, Property, property_depends_on

from traitsui.api \
    import View, VGroup, Item, TableEditor

from traitsui.table_column \
    import ObjectColumn

#-- Integer Class --------------------------------------------------------------

class Integer ( HasTraits ):

    # The value:
    n = Int

#-- Factor Class ---------------------------------------------------------------

class Factor ( HasTraits ):

    # The number being factored:
    n = Int

    # The list of factors of 'n':
    factors = Property( List )

    @property_depends_on( 'n' )
    def _get_factors ( self ):
        n      = self.n
        i      = 1
        result = []

        while (i * i) <= n:
            j = n / i
            if (i * j) == n:
                result.append( Integer( n = i ) )
                if i != j:
                    result.append( Integer( n = j ) )
            i += 1

        result.sort( lambda l, r: cmp( l.n, r.n ) )

        return result

#-- The table editor used for the pop-up view ----------------------------------

factor_table_editor = TableEditor(
    columns = [
        ObjectColumn( name                 = 'n',
                      width                = 1.0,
                      editable             = False,
                      horizontal_alignment = 'center' )
    ],
    sortable           = False,
    auto_size          = False,
    show_toolbar       = False,
    show_column_labels = False
)

#-- The table editor used for the main view ------------------------------------

factors_view = View(
    Item( 'factors',
          id         = 'factors',
          show_label = False,
          editor     = factor_table_editor
    ),
    id     = 'traits.examples.demo.Advanced.factors_view',
    kind   = 'info',
    height = 0.30,
)

factors_table_editor = TableEditor(
    columns = [
        ObjectColumn( name                 = 'n',
                      width                = 0.5,
                      editable             = False,
                      horizontal_alignment = 'center' ),
        ObjectColumn( name                 = 'factors',
                      width                = 0.5,
                      editable             = False,
                      horizontal_alignment = 'center',
                      auto_editable        = True,
                      format_func          = lambda f: '%s factors' % len( f ),
                      view                 = factors_view ),
    ],
    sortable     = False,
    auto_size    = False,
    show_toolbar = False
)

#-- Factors Class --------------------------------------------------------------

class Factors ( HasTraits ):

    # The maximum number to include in the table:
    max_n = Range( 1, 1000, 20, mode = 'slider' )

    # The list of Factor objects:
    factors = Property( List )

    # The view of the list of Factor objects:
    view = View(
        VGroup(
            VGroup(
                Item( 'max_n' ),
                show_labels = False,
                show_border = True,
                label       = 'Maximum Number'
            ),
            VGroup(
                Item( 'factors',
                      show_label = False,
                      editor     = factors_table_editor
                ),
            )
        ),
        title     = 'List of numbers and their factors',
        width     = 0.2,
        height    = 0.4,
        resizable = True
    )

    @property_depends_on( 'max_n' )
    def _get_factors ( self ):
        return [ Factor( n = i + 1 ) for i in xrange( self.max_n ) ]

#-- Create and run the demo ----------------------------------------------------

# Create the demo:
demo = Factors()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Auto_update_TabularEditor_demo
"""
Auto-update from a list to a TabularEditor

Demonstrates using a TabularEditor with the 'auto_update' feature enabled, which
allows the tabular editor to automatically update itself when the content of
any object in the list associated with the editor is modified.

To interact with the demo:
  - Select an employee from the list.
  - Adjust their salary increase.
  - Click the <b>Give raise</b> button.
  - Observe that the table automatically updates to reflect the employees new
    salary.

In order for auto-update to work correctly, the editor trait should be a list of
objects derived from HasTraits. Also, performance can be affected when very long
lists are used, since enabling this feature adds and removed Traits listeners to
each item in the list.

"""

from traits.api import HasTraits, Str, Float, List, Instance, Button
from traitsui.api import View, HGroup, Item, TabularEditor, spring
from traitsui.tabular_adapter import TabularAdapter

#-- EmployeeAdapter Class ------------------------------------------------------

class EmployeeAdapter(TabularAdapter):

    columns = [('Name', 'name'), ('Salary', 'salary') ]

    def get_default_value(self, object, trait):
        return Employee(salary = 30000)

#-- Employee Class -------------------------------------------------------------

class Employee(HasTraits):

    name   = Str
    salary = Float

#-- Company Class --------------------------------------------------------------

class Company(HasTraits):

    employees  = List(Employee)
    employee   = Instance(Employee)
    increase   = Float
    give_raise = Button('Give raise')

    view = View(
        Item('employees',
              show_label = False,
              editor     = TabularEditor(adapter = EmployeeAdapter(),
                                        selected = 'employee',
                                        auto_update = True)
        ),
        HGroup(
            spring,
            Item('increase'),
            Item('give_raise',
                  show_label   = False,
                  enabled_when = 'employee is not None')
        ),
        title     = 'Auto Update Tabular Editor demo',
        height    = 0.25,
        width     = 0.30,
        resizable = True
    )

    def _give_raise_changed(self):
        self.employee.salary += self.increase
        self.employee = None

#-- Set up the demo ------------------------------------------------------------

demo = Company(increase = 1000, employees = [
    Employee(name = 'Fred',   salary = 45000),
    Employee(name = 'Sally',  salary = 52000),
    Employee(name = 'Jim',    salary = 39000),
    Employee(name = 'Helen',  salary = 41000),
    Employee(name = 'George', salary = 49000),
    Employee(name = 'Betty',  salary = 46000) ])

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Date_editor_demo
#  Copyright (c) 2007-2009, Enthought, Inc.
#  License: BSD Style.

"""
A Traits UI editor that wraps a WX calendar panel.
"""

from traits.api import HasTraits, Date, List, Str
from traitsui.api import View, Item, DateEditor, Group


class DateEditorDemo(HasTraits):
    """ Demo class to show Date editors. """
    single_date = Date
    multi_date = List(Date)
    info_string = Str('The editors for Traits Date objects.  Showing both '\
                      'the defaults, and one with alternate options.')

    multi_select_editor = DateEditor(multi_select=True,
                                     months=2,
                                     allow_future=False,
                                     padding=30,
                                     on_mixed_select='max_change',
                                     shift_to_select=False)

    view = View(Item('info_string',
                     show_label=False,
                     style='readonly'),

                Group(Item('single_date',
                           label='Simple date editor'),
                      Item('single_date',
                           style='custom',
                           label='Default custom editor'),
                      Item('single_date',
                           style='readonly',
                           editor=DateEditor(strftime='You picked %B %d %Y',
                                             message='Click a date above.'),
                           label='ReadOnly editor'),
                      label='Default settings for editors'),

                Group(Item('multi_date',
                           editor=multi_select_editor,
                           style='custom',
                           label='Multi-select custom editor'),
                      label='More customized editor: multi-select; disallow '\
                            'future; two months; padding; selection '\
                            'style; etc.'),

                resizable=True)


    def _multi_date_changed(self):
        """ Print each time the date value is changed in the editor. """
        print self.multi_date

    def _simple_date_changed(self):
        """ Print each time the date value is changed in the editor. """
        print self.simple_date, self.single_date

    def _single_date_changed(self):
        """ Print each time the date value is changed in the editor. """
        print self.single_date


#-- Set Up The Demo ------------------------------------------------------------

demo = DateEditorDemo()

if __name__ == "__main__":
    demo.configure_traits()

#-- eof -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = Dynamic_EnumEditor_demo
"""
Dynamic changing an Enum selection list, depending on checked items

Another way to dynamically change the values shown by an EnumEditor.

The scenario is a restaurant that at the beginning of the day has a menu list
of entrees based upon a fully stocked kitchen. However, as the day progresses,
the kitchen's larder gets depleted, and the kitchen may no longer be able to
prepare certain entrees, which must then be deleted from the menu. Similarly,
deliveries may allow certain entrees to be added back onto the menu.

The demo is divided into two tabs: Order and Kitchen.

The Order tab represents a customer's order and consists of a single Entree
field, which represents the customer's selection from the drop-down list of
entrees that the kitchen can currently prepare.

The Kitchen tab represents the current set of entrees that the kitchen can
prepare, based upon the current contents of its larder.

As entrees are checked on or off from the Kitchen tab, the customer's Entree
drop-down is dynamically updated with the current list of available entrees.

Notes:

 - The key point of the demo is the use of the 'name' trait in the EnumEditor
   definition, which links the list of available entrees from the
   KitchenCapabilities object to the OrderMenu object's entree EnumEditor.

 - The design will work with any number of active OrderMenu objects, since they
   all share a common KitchenCapabilities object. As the KitchenCapabilities
   object is updated, all OrderMenu UI's will automatically update their
   associated Entree's drop-down list.

 - A careful reader will also observe that this example contains only
   declarative code. No imperative code is required to handle the automatic
   updating of the Entree list.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasPrivateTraits, Str, List, Constant

from traitsui.api \
    import View, Item, VGroup, HSplit, EnumEditor, CheckListEditor

#-- The list of possible entrees -----------------------------------------------

possible_entrees = [
    'Chicken Fried Steak',
    'Chicken Fingers',
    'Chicken Enchiladas',
    'Cheeseburger',
    'Pepper Steak',
    'Beef Tacos',
    'Club Sandwich',
    'Ceasar Salad',
    'Cobb Salad'
]

#-- The KitchenCapabilities class ----------------------------------------------

class KitchenCapabilities ( HasPrivateTraits ):

    # The current set of entrees the kitchen can make (based on its larder):
    available = List( possible_entrees )

# The KitchenCapabilities are shared by all waitstaff taking orders:
kitchen_capabilities = KitchenCapabilities()

#-- The OrderMenu class --------------------------------------------------------

class OrderMenu ( HasPrivateTraits ):

    # The person's entree order:
    entree = Str

    # Reference to the restaurant's current entree capabilities:
    capabilities = Constant( kitchen_capabilities )

    # The user interface view:
    view = View(
        HSplit(
            VGroup(
                Item( 'entree',
                      editor = EnumEditor(
                                   name = 'object.capabilities.available' )
                ),
                label       = 'Order',
                show_border = True,
                dock        = 'tab'
            ),
            VGroup(
                Item( 'object.capabilities.available',
                      show_label = False,
                      style      = 'custom',
                      editor     = CheckListEditor( values = possible_entrees )
                ),
                label       = 'Kitchen',
                show_border = True,
                dock        = 'tab'
            )
        ),
        title = 'Dynamic EnumEditor Demo',
    )

#-------------------------------------------------------------------------------

# Create the demo:
demo = OrderMenu()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Dynamic_range_trait_and_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This program demonstrates defining and visualizing dynamic ranges.

A dynamic range is a range whose low or high limit can be modified dynamically
at run time.

You can define a dynamic range using the standard Range trait and specifying
the name of other traits as either the low or high limit value (or both). In
fact, it is even possible to specify the default value of the range trait as
another trait if desired. The traits used as low, high or default values need
not be defined on the same object, but can be defined on any object reachable
from the object (i.e. it allows use of extended trait names).

In this completely artificial example, we present an example of the first
hotel at the North Pole. The hotel guarantees that each room will be heated
to a certain minimum temperature. However, that minimum value is determined
both by the time of year and the current cost of heating fuel, so it can vary;
but each room is guaranteed the same minimum temperature.

Each guest of the hotel can choose among several different plans that allow
them to control the maximum room temperature. Higher maximum room temperatures
correspond to higher plan costs. Thus each guest must decide which plan (and
highest maximum room temperature) to pay for.

And finally, each guest is free to set the current room temperature anywhere
between the hotel minimum value and the guest's maximum plan value.

The demo is organized as a series of tabs corresponding to each guest of the
hotel, with access to the plan they have chosen and the current room
temperature setting. In addition, there is a master set of hotel information
displayed at the top of the view which allows you to change the season of the
year and the current fuel cost. There is also a button to allow more guests to
be added to the hotel.

Notes:
    - The dynamic range trait is the 'temperature' trait in the Guest class. It
      depends upon traits defined both in the Guest instance as well as in the
      containing Hotel object.

    - As with most traits code and examples, observe how much of the code is
      'declarative' versus 'imperative'. Note also the use of properties and
      'depends_on' metadata, as well as 'cached_property' and 'on_trait_change'
      method decorators.

    - Try dragging the guest tabs around so that you can see multiple guests
      simultaneously, and then watch the behavior of the guest's 'temperature'
      slider as you adjust the hotel 'season', 'fuel cost' and each guest's
      'plan'.
"""

#-- Imports --------------------------------------------------------------------

import logging, sys
logging.basicConfig(stream=sys.stderr)

from random \
    import choice

from traits.api \
    import HasPrivateTraits, Str, Enum, Range, List, Button, Instance, \
           Property, cached_property, on_trait_change

from traitsui.api \
    import View, VGroup, HGroup, Item, ListEditor, spring

#-- The Hotel class ------------------------------------------------------------

class Hotel ( HasPrivateTraits ):

    # The season of the year:
    season = Enum( 'Winter', 'Spring', 'Summer', 'Fall' )

    # The current cost of heating fuel (in dollars/gallon):
    fuel_cost = Range( 2.00, 10.00, 4.00 )

    # The current minimum temparature allowed by the hotel:
    min_temperature = Property( depends_on = 'season, fuel_cost' )

    # The guests currently staying at the hotel:
    guests = List # ( Instance( 'Guest' ) )

    # Add a new guest to the hotel:
    add_guest = Button( 'Add Guest' )

    # The view of the hotel:
    view = View(
        VGroup(
            HGroup(
                Item( 'season' ), '20',
                Item( 'fuel_cost', width = 300 ),
                spring,
                Item( 'add_guest', show_label = False ),
                show_border = True,
                label       = 'Hotel Information'
            ),
            VGroup(
                Item( 'guests',
                      style  = 'custom',
                      editor = ListEditor( use_notebook = True,
                                           deletable    = True,
                                           dock_style   = 'tab',
                                           page_name    = '.name' )
                ),
                show_labels = False,
                show_border = True,
                label       = 'Guests'
            )
        ),
        title     = 'The Belmont Hotel Dashboard',
        width     = 0.6,
        height    = 0.2,
        resizable = True
    )

    # Property implementations:
    @cached_property
    def _get_min_temperature ( self ):
        return ({ 'Winter': 32,
                  'Spring': 40,
                  'Summer': 45,
                  'Fall':   40 }[ self.season ] +
                  min( int( 60.00 / self.fuel_cost ), 15 ))

    # Event handlers:
    @on_trait_change( 'guests[]' )
    def _guests_modified ( self, removed, added ):
        for guest in added:
            guest.hotel = self

    def _add_guest_changed ( self ):
        self.guests.append( Guest() )

#-- The Guest class ------------------------------------------------------------

class Guest ( HasPrivateTraits ):

    # The name of the guest:
    name = Str

    # The hotel the guest is staying at:
    hotel = Instance( Hotel )

    # The room plan the guest has chosen:
    plan = Enum( 'Flop house', 'Cheap', 'Cozy', 'Deluxe' )

    # The maximum temperature allowed by the guest's plan:
    max_temperature = Property( depends_on = 'plan' )

    # The current room temperature as set by the guest:
    temperature = Range( 'hotel.min_temperature', 'max_temperature' )

    # The view of the guest:
    view = View(
        Item( 'plan' ),
        Item( 'temperature' )
    )

    # Property implementations:
    @cached_property
    def _get_max_temperature ( self ):
        return { 'Flop house': 62,
                 'Cheap':      66,
                 'Cozy':       75,
                 'Deluxe':     85 }[ self.plan ]

    # Default values:
    def _name_default ( self ):
        return choice(
            [ 'Leah', 'Vibha', 'Janet', 'Jody', 'Dave', 'Evan', 'Ilan', 'Gael',
              'Peter', 'Robert', 'Judah', 'Eric', 'Travis', 'Mike', 'Bryce',
              'Chris' ] )

#-- Create the demo ------------------------------------------------------------

# Create the demo object:
demo = Hotel( guests = [ Guest() for i in range( 5 ) ] )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    logging.info('Start!')
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Dynamic_views_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

""" Demonstrates how to use the Dynamic Views facility.
"""

from traits.api \
    import Bool, HasTraits, Str, Instance, Button

from traitsui.api \
    import View, HGroup, Group, Item, Handler, Label, spring

from traits.has_dynamic_views \
    import DynamicView, HasDynamicViews

class HasFooView ( HasDynamicViews ):
    """ A base class declaring the existence of the 'foo' dynamic view.
    """

    def __init__ ( self, *args, **traits ):
        """ Constructor.

            Extended to declare our dynamic foo view.
        """
        super( HasFooView, self ).__init__( *args, **traits )

        # Declare and add our dynamic view:
        declaration = DynamicView(
            name     = 'foo',
            id       = 'traitsui.demos.dynamic_views',
            keywords = {
                'buttons':    [ 'OK' ],
                'dock':       'tab',
                'height':     0.4,
                'width':      0.4,
                'resizable':  True,
                'scrollable': True,
            },
            use_as_default = True,
        )
        self.declare_dynamic_view( declaration )

class MyInfoHandler ( Handler ):

    def object_first_changed ( self, info ):
        info.object.derived = info.object.first

class BaseFoo ( HasFooView ):
    """ A base class that puts some content in the 'foo' dynamic view.
    """

    first = Str( 'My first name' )
    last  = Str( 'My last name' )

    # A derived trait set by the handler associated with out dynamic view
    # contribution:
    derived = Str

    ui_person = Group(
        Item(label='On this tab, notice how the sub-handler keeps\n'
            'the derived value equal to the first name.\n\n'
            'On the next tab, change the selection in order to\n'
            'control which tabs are visible when the ui is \n'
            'displayed for the 2nd time.'
            ),
        spring,
        'first', 'last',
        spring,
        'derived',
        label = 'My Info',
        _foo_order    = 5,
        _foo_priority = 1,
        _foo_handler  = MyInfoHandler(),
    )

class FatherInfoHandler ( Handler ):

    def object_father_first_name_changed ( self, info ):
        info.object.father_derived = info.object.father_first_name

class DerivedFoo ( BaseFoo ):
    """ A derived class that puts additional content in the 'foo' dynamic view.
        Note that the additional content could also have been added via a traits
        category contribution, or even dynamic manipulation of metadata on a UI
        subelement.  The key is what the metadata represents when the view is
        *created*
    """

    knows_mother      = Bool( False )
    mother_first_name = Str( "My mother's first name" )
    mother_last_name  = Str( "My mother's last name" )

    knows_father      = Bool( True )
    father_first_name = Str( "My father's first name" )
    father_last_name  = Str( "My father's last name" )
    father_derived    = Str

    ui_parents = Group(
        'knows_mother',
        'knows_father',
        label         = 'Parents?',
        _foo_order    = 7,
        _foo_priority = 1,
    )

    ui_mother = Group(
        'mother_first_name',
        'mother_last_name',
        label         = "Mother's Info",
        _foo_priority = 1,
    )

    ui_father = Group(
        'father_first_name',
        'father_last_name',
        spring,
        'father_derived',
        label         = "Father's Info",
        _foo_order    = 15,
        _foo_priority = 1,
        _foo_handler  = FatherInfoHandler(),
    )

    def _knows_mother_changed ( self, old, new ):
        ui_mother = self.trait_view( 'ui_mother' )
        if new:
            ui_mother._foo_order = 10
        elif hasattr( ui_mother, '_foo_order' ):
            del ui_mother._foo_order

    def _knows_father_changed ( self, old, new ):
        ui_father = self.trait_view( 'ui_father' )
        if new:
            ui_father._foo_order = 15
        elif hasattr( ui_father, '_foo_order' ):
            del ui_father._foo_order


class FooDemo ( HasTraits ):
    """ Defines a class to run the demo.
    """

    foo       = Instance( DerivedFoo, () )
    configure = Button( 'Configure' )

    view = View(
        Label( "Try configuring several times, each time changing the items "
               "on the 'Parents?' tab." ),
        '_',
        HGroup( spring, Item( 'configure', show_label = False ) )
    )

    def _configure_changed ( self ):
        self.foo.configure_traits()

# Create the demo:
popup = FooDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = HDF5_tree_demo
"""This demo shows how to use Traits TreeEditors with PyTables to walk the
heirarchy of an HDF5 file.  This only picks out arrays and groups, but could
easily be extended to other structures, like tables.

In the demo, the path to the selected item is printed whenever the selection
changes.  In order to run, a path to an existing HDF5 database must be given
at the bottom of this file.
"""

from traits.api import HasTraits, Str, List, Instance
from traitsui.api import TreeEditor, TreeNode, View, Item, Group

import tables as tb


# View for objects that aren't edited
no_view = View()


# HDF5 Nodes in the tree
class Hdf5ArrayNode(HasTraits):
    name   = Str( '<unknown>' )
    path = Str( '<unknown>' )
    parent_path = Str( '<unknown>' )

class Hdf5GroupNode(HasTraits):
    name     = Str( '<unknown>' )
    path = Str( '<unknown>' )
    parent_path = Str( '<unknown>' )
    # Can't have recursive traits?  Really?
    #groups = List( Hdf5GroupNode )
    groups = List
    arrays = List( Hdf5ArrayNode )
    groups_and_arrays = List

class Hdf5FileNode(HasTraits):
    name   = Str( '<unknown>' )
    path   = Str( '/' )
    groups = List( Hdf5GroupNode )
    arrays = List( Hdf5ArrayNode )
    groups_and_arrays = List

# Recurssively build tree, there is probably a better way of doing this.
def _get_sub_arrays(group, h5file):
    """Return a list of all arrays immediately below a group in an HDF5 file."""
    l = []

    for array in h5file.iterNodes(group, classname='Array'):
        a = Hdf5ArrayNode(
            name = array._v_name,
            path = array._v_pathname,
            parent_path = array._v_parent._v_pathname,
            )
        l.append(a)

    return l

def _get_sub_groups(group, h5file):
    """Return a list of all groups and arrays immediately below a group in an HDF5 file."""
    l = []

    for subgroup in h5file.iterNodes(group, classname='Group'):
        g = Hdf5GroupNode(
                name = subgroup._v_name,
                path = subgroup._v_pathname,
                parent_path = subgroup._v_parent._v_pathname,
                )

        subarrays = _get_sub_arrays(subgroup, h5file)
        if subarrays != []:
            g.arrays = subarrays

        subgroups = _get_sub_groups(subgroup, h5file)
        if subgroups != []:
            g.groups = subgroups

        g.groups_and_arrays = []
        g.groups_and_arrays.extend(subgroups)
        g.groups_and_arrays.extend(subarrays)

        l.append(g)

    return l

def _hdf5_tree(filename):
    """Return a list of all groups and arrays below the root group of an HDF5 file."""

    h5file = tb.openFile(filename, 'r')

    file_tree = Hdf5FileNode(
            name = filename,
            groups = _get_sub_groups(h5file.root, h5file),
            arrays = _get_sub_arrays(h5file.root, h5file),
            )

    file_tree.groups_and_arrays = []
    file_tree.groups_and_arrays.extend(file_tree.groups)
    file_tree.groups_and_arrays.extend(file_tree.arrays)

    h5file.close()

    return file_tree

# Get a tree editor
def _hdf5_tree_editor(selected=''):
    """Return a TreeEditor specifically for HDF5 file trees."""
    return TreeEditor(
        nodes = [
            TreeNode(
                node_for  = [ Hdf5FileNode ],
                auto_open = True,
                children  = 'groups_and_arrays',
                label     = 'name',
                view      = no_view,
                ),
            TreeNode(
                node_for  = [ Hdf5GroupNode ],
                auto_open = False,
                children  = 'groups_and_arrays',
                label     = 'name',
                view      = no_view,
                ),
            TreeNode(
                node_for  = [ Hdf5ArrayNode ],
                auto_open = False,
                children  = '',
                label     = 'name',
                view      = no_view,
                ),
            ],
        editable = False,
        selected = selected,
        )


if __name__ == '__main__':
    from traits.api import Any

    class ATree(HasTraits):
        h5_tree = Instance(Hdf5FileNode)
        node = Any

        traits_view =View(
            Group(
                Item('h5_tree',
                    editor = _hdf5_tree_editor(selected='node'),
                    resizable =True
                    ),
                orientation = 'vertical',
                ),
            title = 'HDF5 Tree Example',
            buttons = [ 'Undo', 'OK', 'Cancel' ],
            resizable = True,
            width = .3,
            height = .3
            )

        def _node_changed(self):
            print self.node.path


    a_tree = ATree( h5_tree = _hdf5_tree('/path/to/file.h5')  )
    a_tree.configure_traits()
#    a_tree.edit_traits()

########NEW FILE########
__FILENAME__ = History_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This program demonstrates the use of editors that support <i>history</i>. A
history is a persistent record of the last 'n' values the user has entered or
selected for a particular trait.

In order for the history to be recorded correctly, you must specify an <i>id</i>
for both the Item containing the history editor and the View containing the
Item.

The maximum number of history entries recorded is specified by the value of
the history editor's <i>entries</i> trait. If <i>entries</i> is less than or
equal to 0, then a normal, non-history, version of the editor will be used.

A history editor also attempts to restore the last value set as the current
value for the trait if the current value of the trait is the empty string. You
can see this for yourself by setting some values in the fields, selecting a
different demo, then reselecting this demo. Each field should have the same
value it had when the demo was run the previous time.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, Str, File, Directory

from traitsui.api \
    import View, Item, FileEditor, DirectoryEditor, HistoryEditor

#-- HistoryDemo Class ----------------------------------------------------------

class HistoryDemo ( HasTraits ):

    name      = Str
    file      = File
    directory = Directory

    view = View(
        Item( 'name',
              id     = 'name',
              editor = HistoryEditor( entries = 5 )
        ),
        Item( 'file',
              id     = 'file1',
              editor = FileEditor( entries = 10 )
        ),
        Item( 'file',
              id     = 'file2',
              editor = FileEditor( entries = 10,
                                   filter  = [ 'All files (*.*)|*.*',
                                               'Python files (*.py)|*.py' ] )
        ),
        Item( 'directory',
              id     = 'directory',
              editor = DirectoryEditor( entries = 10 )
        ),
        title     = 'History Editor Demo',
        id        = 'enthought.test.history_demo.HistoryDemo',
        width     = 0.33,
        resizable = True
    )

# Create the demo:
demo = HistoryDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Invalid_state_handling
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Sometimes the inputs to a model are not correlated. That is, any valid model
input produces a corresponding valid model state. However, in other cases, some
or all of the model inputs are correlated. That is, there may exist one or more
combinations of individually valid model inputs which produce invalid model
states.

In cases where this can happen, it is very often desirable to warn the user if
a particular combination of input values will not produce a usable result. This
problem cannot be solved solely though the use of carefully chosen trait types
and editors, because each individual input may be valid, but it is the
combination of inputs which is invalid.

Solving this problem therefore typically requires providing a way of determining
whether or not the model is in a valid state, and then communicating that
information to the user via the user interface.

This demonstration provides an example of doing this using the TraitEditor's
'invalid' trait. Each trait editor has an 'invalid' trait which can be set
equal to the name of a trait in the user interface context which contains a
boolean value reflecting whether or not the user interface (and underlying
model) are in a invalid state or not. A True value for the trait indicates that
the editor's current value produces an invalid model state. By associating the
same 'invalid' trait with one or more editors in the user interface, the
resulting user interface can indicate to the user which combination of input
values is producing the invalid state.

In this example, we have a very simple model which allows the user to control
the mass and velocity of a system. The model also defines the kinetic energy
of the resulting system. For safety reasons, the kinetic energy of the system
should not exceed a certain threshold. If it does, the user should be warned
so that they can reduce either or both of the system mass and velocity back down
to a safe level.

In the model, an 'error' property is defined which is True whenever the
kinetic energy level of the system exceeds the safety threshold. This trait is
then synchronized with the user interface's 'mass', velocity' and 'status'
editors, turning them red whenever the model enters an invalid state.

The 'status' trait is another property, based on the 'error' trait, which
provides a human readable description of the current system state.

Note that in this example, we synchronize the 'error' trait with the user
interface using 'sync_to_view' metadata, whose value is a list of user
interface editor traits the trait should be synchronized 'to' (i.e. changes to
the 'error' trait will be copied to the corresponding trait in the editor, but
not vice versa). We could also have explicitly set the 'invalid' trait of each
corresponding editor in the view definition to 'error' as well.

To use the demo, simply use the 'mass' and 'velocity' sliders and observe the
changes to the 'kinetic_energy' of the system. When the kinetic energy exceeds
50,000, notice how the 'mass', 'velocity' and 'status' fields turn red, and
that when the kinetic energy drops below 50,000, the fields return to their
normal color.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, Range, Float, Bool, Str, Property, property_depends_on

from traitsui.api \
    import View, VGroup, Item

#-- System Class ---------------------------------------------------------------

class System ( HasTraits ):

    # The mass of the system:
    mass = Range( 0.0, 100.0 )

    # The velocity of the system:
    velocity = Range( 0.0, 100.0 )

    # The kinetic energy of the system:
    kinetic_energy = Property( Float )

    # The current error status of the system:
    error = Property( Bool,
               sync_to_view = 'mass.invalid, velocity.invalid, status.invalid' )

    # The current status of the system:
    status = Property( Str )

    view = View(
        VGroup(
            VGroup(
                Item( 'mass' ),
                Item( 'velocity' ),
                Item( 'kinetic_energy',
                      style      = 'readonly',
                      format_str = '%.0f'
                ),
                label       = 'System',
                show_border = True ),
            VGroup(
                Item( 'status',
                      style      = 'readonly',
                      show_label = False
                ),
                label       = 'Status',
                show_border = True
            ),
        )
    )

    @property_depends_on( 'mass, velocity' )
    def _get_kinetic_energy ( self ):
        return (self.mass * self.velocity * self.velocity) / 2.0

    @property_depends_on( 'kinetic_energy' )
    def _get_error ( self ):
        return (self.kinetic_energy > 50000.0)

    @property_depends_on( 'error' )
    def _get_status ( self ):
        if self.error:
            return 'The kinetic energy of the system is too high.'

        return ''

#-- Create and run the demo ----------------------------------------------------

# Create the demo:
demo = System()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = ListStrEditor_demo
"""
Edit a List of Strings

Simple demonstration of the ListStrEditor, which can be used for editing and
displaying lists of strings, or other data that can be logically mapped to a
list of strings.
"""

from traits.api import HasTraits, List, Str
from traitsui.api import View, Item, ListStrEditor

#-- ShoppingListDemo Class -----------------------------------------------------

class ShoppingListDemo (HasTraits):

    # The list of things to buy at the store:
    shopping_list = List(Str)

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item('shopping_list',
              show_label = False,
              editor = ListStrEditor(title = 'Shopping List', auto_add = True)
        ),
        title     = 'Shopping List',
        width     = 0.2,
        height    = 0.5,
        resizable = True
    )

#-- Set up the Demo ------------------------------------------------------------

demo = ShoppingListDemo(shopping_list = [
    'Carrots',
    'Potatoes (5 lb. bag)',
    'Cocoa Puffs',
    'Ice Cream (French Vanilla)',
    'Peanut Butter',
    'Whole wheat bread',
    'Ground beef (2 lbs.)',
    'Paper towels',
    'Soup (3 cans)',
    'Laundry detergent'
])

# Run the demo (in invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = List_editors_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This shows the three different types of editor that can be applied to a list
of objects:

 - Table
 - List
 - Dockable notebook (a list variant)

Each editor style is editing the exact same list of objects. Note that any
changes made in one editor are automatically reflected in the others.
"""

# Imports:
from traits.api \
    import HasStrictTraits, Str, Int, Regex, List, Instance

from traitsui.api \
    import View, Item, Tabbed, TableEditor, ListEditor

from traitsui.table_column \
    import ObjectColumn

from traitsui.table_filter \
    import RuleTableFilter, RuleFilterTemplate, \
           MenuFilterTemplate, EvalFilterTemplate

# 'Person' class:
class Person ( HasStrictTraits ):

    # Trait definitions:
    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    # Traits view definition:
    traits_view = View( 'name', 'age', 'phone',
                        width   = 0.18,
                        buttons = [ 'OK', 'Cancel' ] )

# Sample data:
people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

# Table editor definition:
filters      = [ EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate ]

table_editor = TableEditor(
    columns     = [ ObjectColumn( name = 'name',  width = 0.4 ),
                    ObjectColumn( name = 'age',   width = 0.2 ),
                    ObjectColumn( name = 'phone', width = 0.4 ) ],
    editable    = True,
    deletable   = True,
    sortable    = True,
    sort_model  = True,
    auto_size   = False,
    filters     = filters,
    search      = RuleTableFilter(),
    row_factory = Person
)

# 'ListTraitTest' class:
class ListTraitTest ( HasStrictTraits ):

    # Trait definitions:
    people = List( Instance( Person, () ) )

    # Traits view definitions:
    traits_view = View(
        Tabbed(
            Item( 'people',
                  label  = 'Table',
                  id     = 'table',
                  editor = table_editor ),
            Item( 'people',
                  label  = 'List',
                  id     = 'list',
                  style  = 'custom',
                  editor = ListEditor( style = 'custom',
                                       rows  = 5 ) ),
            Item( 'people',
                  label  = 'Notebook',
                  id     = 'notebook',
                  style  = 'custom',
                  editor = ListEditor( use_notebook = True,
                                       deletable    = True,
                                       export       = 'DockShellWindow',
                                       page_name    = '.name' ) ),
            id          = 'splitter',
            show_labels = False ),
        id   = 'traitsui.demo.Traits UI Demo.Advanced.List_editors_demo',
        dock = 'horizontal' )

# Create the demo:
demo = ListTraitTest( people = people )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = List_editor_notebook_selection_demo
"""
Displaying a list of objects in notebook tabs

A list of objects can be displayed in a tabbed notebook, one object per tab.

This example also shows how the currently active notebook tab of a ListEditor
can be controlled using the ListEditor's 'selected' trait.

Note the interaction between the spinner control (for the 'index' trait) and
the currently selected notebook tab. Try changing the spinner value, then try
clicking on various notebook tabs.

Finally, note that the ListEditor will automatically scroll the tabs to make
the selected tab completely visible.
"""

# The following text was removed from the module docstring (only works in wx):
#  Also note that rearranging the notebook tabs (using drag and drop) does not
#  affect the correspondence between the index value and its associated notebook
#  tab. The correspondence is determined by the contents of the 'people' trait,
#  and not by the physical layout of the notebook tabs.


from traits.api import HasStrictTraits, Str, Int, Regex, List, Instance, Range
from traitsui.api import View, VGroup, Item, ListEditor

#-- Person Class ---------------------------------------------------------------

class Person(HasStrictTraits):

    # Trait definitions:
    name  = Str
    age   = Int
    phone = Regex(value = '000-0000', regex = '\d\d\d[-]\d\d\d\d')

    # Traits view definition:
    traits_view = View('name', 'age', 'phone',
                        width   = 0.18,
                        buttons = [ 'OK', 'Cancel' ])

#-- Sample Data ----------------------------------------------------------------

people = [
   Person(name = 'Dave Chomsky',        age = 39, phone = '555-1212'),
   Person(name = 'Mike Wakowski',       age = 28, phone = '555-3526'),
   Person(name = 'Joe Higginbotham',    age = 34, phone = '555-6943'),
   Person(name = 'Tom Derringer',       age = 22, phone = '555-7586'),
   Person(name = 'Dick Van Der Hooten', age = 63, phone = '555-3895'),
   Person(name = 'Harry McCallum',      age = 46, phone = '555-3285'),
   Person(name = 'Sally Johnson',       age = 43, phone = '555-8797'),
   Person(name = 'Fields Timberlawn',   age = 31, phone = '555-3547')
]

#-- ListEditorNotebookSelectionDemo Class --------------------------------------

class ListEditorNotebookSelectionDemo(HasStrictTraits):

    #-- Trait Definitions ------------------------------------------------------

    # List of people:
    people = List(Person)

    # The currently selected person:
    selected = Instance(Person)

    # The index of the currently selected person:
    index = Range(0, 7, mode = 'spinner')

    #-- Traits View Definitions ------------------------------------------------

    traits_view = View(
        Item('index'),
        '_',
        VGroup(
            Item('people',
                  id         = 'notebook',
                  show_label = False,
                  style      = 'custom',
                  editor     = ListEditor(use_notebook = True,
                                           deletable    = False,
                                           selected     = 'selected',
                                           export       = 'DockWindowShell',
                                           page_name    = '.name')
            )
        ),
        id   = 'traitsui.demo.Traits UI Demo.Advanced.'
               'List_editor_notebook_selection_demo',
        dock = 'horizontal')

    #-- Trait Event Handlers ---------------------------------------------------

    def _selected_changed(self, selected):
        self.index = self.people.index(selected)

    def _index_changed(self, index):
        self.selected = self.people[ index ]

#-- Set Up The Demo ------------------------------------------------------------

demo = ListEditorNotebookSelectionDemo(people = people)

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Multi_select_string_list
"""
Creating a multi-select list box

How to use a TabularEditor to create a multi-select list box.

This demo uses two TabularEditors, side-by-side. Selections from the left table
are shown in the right table. Each table has only one column.

"""

from traits.api import HasPrivateTraits, List, Str, Property
from traitsui.api import View, HGroup, UItem, TabularEditor
from traitsui.tabular_adapter import TabularAdapter

class MultiSelectAdapter(TabularAdapter):
    """ This adapter is used by both the left and right tables
    """

    # Titles and column names for each column of a table.
    # In this example, each table has only one column.
    columns = [ ('', 'myvalue') ]

    # Magically named trait which gives the display text of the column named 
    # 'myvalue'. This is done using a Traits Property and its getter:
    myvalue_text = Property
    
    # The getter for Property 'myvalue_text' simply takes the value of the 
    # corresponding item in the list being displayed in this table.
    # A more complicated example could format the item before displaying it.
    def _get_myvalue_text(self):
        return self.item

class MultiSelect(HasPrivateTraits):
    """ This is the class used to view two tables
    """
    # FIXME (TraitsUI defect #14): When multi-select is done by keyboard 
    # (shift+arrow), the 'selected' trait list does not update.
    
    # FIXME (TraitsUI defect #15): In Windows wx, when show_titles is False, 
    # left table does not draw until selection passes through all rows.
    # (Workaround here: set show_titles True and make column titles empty.)
    
    choices  = List(Str)
    selected = List(Str)
    
    view = View(
        HGroup(
            UItem('choices',
                  editor     = TabularEditor(
                                   show_titles  = True,
                                   selected     = 'selected',
                                   editable     = False,
                                   multi_select = True,
                                   adapter      = MultiSelectAdapter())
            ),
            UItem('selected',
                  editor     = TabularEditor(
                                   show_titles  = True,
                                   editable     = False,
                                   adapter      = MultiSelectAdapter())
            )
        ),
        resizable=True,
        width=200,
        height=300
    )

# Create the demo:
demo = MultiSelect(choices = [ 'one', 'two', 'three', 'four', 'five', 'six',
                                'seven', 'eight', 'nine', 'ten' ])

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Multi_thread_demo
"""
Monitoring threads in the user interface

Shows a simple user interface being updated by multiple threads.

When the *Start Threads* button is pressed, the program starts three independent
threads running. Each thread counts from 0 to 199, updating its own
thread-specific trait, and performs a sleep of a thread-specific duration
between each update.

The *Start Threads* button is disabled while the threads are running, and
becomes active again once all threads have finished running.
"""

from threading import Thread
from time import sleep
from traits.api import HasTraits, Int, Button
from traitsui.api import View, Item, VGroup

class ThreadDemo(HasTraits):

    # The thread specific counters:
    thread_0 = Int
    thread_1 = Int
    thread_2 = Int

    # The button used to start the threads running:
    start = Button('Start Threads')

    # The count of how many threads ae currently running:
    running = Int

    view = View(
        VGroup(
            Item('thread_0', style = 'readonly'),
            Item('thread_1', style = 'readonly'),
            Item('thread_2', style = 'readonly'),
        ),
        '_',
        Item('start', show_label = False,
             width = -90,
             enabled_when = 'running == 0' ),
        resizable = True,
        width = 250,
        title = 'Monitoring threads'
    )

    def _start_changed(self):
        for i in range(3):
            Thread(target = self.counter,
                   args = ('thread_%d' % i, (i*10 + 10)/1000.0)).start()

    def counter(self, name, interval):
        self.running += 1
        count = 0
        for i in range( 200 ):
            setattr(self, name, count)
            count += 1
            sleep(interval)
        self.running -= 1

# Create the demo:
demo = ThreadDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = Multi_thread_demo_2
"""
Monitoring a dynamic number of threads

Shows a simple user interface being updated by a dynamic number of threads.

When the *Create Threads* button is pressed, the *count* method is
dispatched on a new thread. It then creates a new *Counter* object and
adds it to the *counters* list (which causes the *Counter* to appear
in the user interface. It then counts by incrementing the *Counter*
object's *count* trait (which again causes a user interface update each
time the counter is incremented). After it reaches its maximum count, it
removes the *Counter* from the *counter* list (causing the counter
to be removed from the user interface) and exits (terminating the thread).

Note that repeated clicking of the *Create Thread* button will create
additional threads.
"""

from time import sleep
from traits.api import HasTraits, Int, Button, List
from traitsui.api import View, Item, ListEditor

#-- The Counter objects used to keep track of the current count ----------------

class Counter(HasTraits):

    # The current count:
    count = Int

    view = View(Item('count', style = 'readonly'))

#-- The main 'ThreadDemo' class ------------------------------------------------

class ThreadDemo(HasTraits):

    # The button used to start a new thread running:
    create = Button('Create Thread')

    # The set of counter objects currently running:
    counters = List(Counter)

    view = View(
        Item('create', show_label = False, width = -100),
        '_',
        Item('counters', style      = 'custom',
                          show_label = False,
                          editor     = ListEditor(use_notebook = True,
                                                   dock_style   = 'tab')),
        resizable = True,
        width = 300,
        height = 150,
        title = 'Dynamic threads'
    )

    def __init__(self, **traits):
        super(HasTraits, self).__init__(**traits)

        # Set up the notification handler for the 'Create Thread' button so
        # that it is run on a new thread:
        self.on_trait_change(self.count, 'create', dispatch = 'new')

    def count(self):
        """ This method is dispatched on a new thread each time the
            'Create Thread' button is pressed.
        """
        counter = Counter()
        self.counters.append(counter)
        for i in range(1000):
            counter.count += 1
            sleep(0.030)
        self.counters.remove(counter)

# Create the demo:
demo = ThreadDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = MVC_demo
"""
Supporting Model/View/Controller (MVC) pattern

Demonstrates one approach to writing Model/View/Controller (MVC)-based
applications using Traits UI.

This example contains a trivial model containing only one data object, the
string 'myname'.

In this example, the Controller contains the View. A more rigorous example
would separate these.

A few key points:

     - the Controller itself accesses the model as self.model

     - the Controller's View can access model traits directly ('myname')
"""

from traits.api import HasTraits, Str, Bool, TraitError
from traitsui.api import View, VGroup, HGroup, Item, Controller

class MyModel(HasTraits):
    """ Define a simple model containing a single string, 'myname'
    """

    # Simple model data:
    myname = Str

class MyViewController(Controller):
    """ Define a combined controller/view class that validates that
        MyModel.myname is consistent with the 'allow_empty_string' flag.
    """

    # When False, the model.myname trait is not allowed to be empty:
    allow_empty_string = Bool

    # Last attempted value of model.myname to be set by user:
    last_name = Str

    # Define the view associated with this controller:
    view = View(
        VGroup(
            HGroup(
                Item('myname', springy = True), '10',
                Item('controller.allow_empty_string', label = 'Allow Empty')
            ),

            # Add an empty vertical group so the above items don't end up
            # centered vertically:
            VGroup()
        ),
        resizable = True
    )

    #-- Handler Interface ------------------------------------------------------

    def myname_setattr(self, info, object, traitname, value):
        """ Validate the request to change the named trait on object to the
            specified value.  Validation errors raise TraitError, which by
            default causes the editor's entry field to be shown in red.
            (This is a specially named method <model trait name>_setattr,
            which is available inside a Controller.)
        """
        self.last_name = value
        if (not self.allow_empty_string) and (value.strip() == ''):
            raise TraitError('Empty string not allowed.')

        return super(MyViewController, self).setattr(info, object, traitname,
                                                         value)

    #-- Event handlers ---------------------------------------------------------

    def controller_allow_empty_string_changed(self, info):
        """ 'allow_empty_string' has changed, check the myname trait to ensure
            that it is consistent with the current setting.
        """
        if (not self.allow_empty_string) and (self.model.myname == ''):
            self.model.myname = '?'
        else:
            self.model.myname = self.last_name

# Create the model and (demo) view/controller:
demo = MyViewController(MyModel())

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = NumPy_array_tabular_editor_demo
"""
Displaying large NumPy arrays with TabularEditor

A demonstration of how the TabularEditor can be used to display (large) NumPy
arrays, in this case 100,000 random 3D points from a unit cube.

In addition to showing the coordinates of each point, it also displays the
index of each point in the array, as well as a red flag if the point lies within
0.25 of the center of the cube.
"""

#-- Imports --------------------------------------------------------------------

from numpy import sqrt
from numpy.random import random
from traits.api import HasTraits, Property, Array, Font
from traitsui.api import View, Item, TabularEditor
from traitsui.tabular_adapter import TabularAdapter

#-- Tabular Adapter Definition -------------------------------------------------

class ArrayAdapter(TabularAdapter):

    columns = [('i', 'index'), ('x', 0), ('y', 1),  ('z', 2)]

    # Font fails with wx in OSX; see traitsui issue #13:
    # font        = Font('Courier 10')
    alignment   = 'right'
    format      = '%.4f'
    index_text  = Property
    index_image = Property

    def _get_index_text(self):
        return str(self.row)

    def _get_index_image(self):
        x, y, z = self.item
        if sqrt((x - 0.5) ** 2 + (y - 0.5) ** 2 + (z - 0.5) ** 2) <= 0.25:
            return '@icons:red_ball'

        return None

#-- ShowArray Class Definition -------------------------------------------------

class ShowArray(HasTraits):

    data = Array

    view = View(
        Item('data',
              show_label = False,
              style      = 'readonly',
              editor     = TabularEditor(adapter = ArrayAdapter())
        ),
        title     = 'Array Viewer',
        width     = 0.3,
        height    = 0.8,
        resizable = True
    )

# Create the demo:
demo = ShowArray(data = random((100000, 3)))

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = NumPy_array_view_editor_demo
"""
Using ArrayViewEditor to display large NumPy arrays in a table.

This example displays 100,000 random 3D points from a unit cube.

Note that the ArrayViewEditor has the following traits::

    # Should an index column be displayed:
    show_index = Bool(True)

    # List of (optional) column titles:
    titles = List(Str)

    # Should the array be logically transposed:
    transpose = Bool(False)

    # The format used to display each array element:
    format = Str('%s')

By default, the array row index will be shown in column one. If 'show_index'
is  False, then the row index column is omitted.

If the list of 'titles' is empty, no column headers will be displayed.

If the number of column headers is less than the number of array columns, then
there are two cases:

    - If (number of array_columns) % (number of titles) == 0, then the titles
      are used to construct a series of repeating column headers with increasing
      subscripts (e.g. an (n x 6) array with titles of ['x','y','z'] would
      result in column headers of: 'x0', 'y0', 'z0', 'x1', 'y1', 'z1').

    - In all other cases the titles are used as the column headers for the
      first set of columns, and the remaining column headers are set to the
      empty string (e.g. an (n x 5) array with titles of ['x','y','z'] would
      result in column headers of: 'x', 'y', 'z', '', '').

Setting 'transpose' to True will logically transpose the input array (e.g. an
(3 x n) array will be displayed as an (n x 3) array).
"""

from numpy.random import random
from traits.api import HasTraits, Array
from traitsui.api import View, Item
from traitsui.ui_editors.array_view_editor import ArrayViewEditor

#-- ShowArray demo class -------------------------------------------------------

class ShowArray(HasTraits):

    data = Array

    view = View(
        Item('data',
              show_label = False,
              editor     = ArrayViewEditor(titles = [ 'x', 'y', 'z' ],
                                           format = '%.4f',
                                           # Font fails with wx in OSX;
                                           #   see traitsui issue #13:
                                           # font   = 'Arial 8'
                                          )
        ),
        title     = 'Array Viewer',
        width     = 0.3,
        height    = 0.8,
        resizable = True
    )

#-- Run the demo ---------------------------------------------------------------

# Create the demo:
demo = ShowArray(data = random((100000, 3)))

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Popup_Dialog_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Demonstrates using a popup view within another view.

Try changing the gender of the person from 'Male' to 'Female' using the
drop-down list. When the person's gender is changed, a pop-up dialog is
displayed immediately below the gender field providing you with the
opportunity to cancel the gender change.

If you click the Cancel button, the person's gender will return to its previous
value. If you click anywhere else outside of the pop-up dialog, the pop-up
dialog will simply disappear, leaving the person's new gender value as is.

The main items of interest in this demo are:
 - The: kind = 'popup' trait set in the PersonHandler View which marks the view
   as being a popup view.
 - The parent = info.gender.control value passed to the edit_traits method
   when the popup dialog is created in the object_gender_changed method. This
   value specifies the control that the popup dialog should be positioned near.

Notes:
 - Traits UI will automatically position the popup dialog near the specified
   control in such a way that the pop-up dialog will not overlay the control
   and will be entirely on the screen (as long as these two conditions do not
   conflict).
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasPrivateTraits, Str, Int, Enum, Instance, Button

from traitsui.api \
    import View, HGroup, Item, Handler, UIInfo, spring

#-- The PersonHandler class ----------------------------------------------------

class PersonHandler ( Handler ):

    # The UIInfo object associated with the view:
    info = Instance( UIInfo )

    # The cancel button used to revert an unintentional gender change:
    cancel = Button( 'Cancel' )

    # The pop-up customization view:
    view = View(
        HGroup(
            spring,
            Item( 'cancel', show_label = False ),
        ),
        kind = 'popup'
    )

    # Event handlers:
    def object_gender_changed ( self, info ):
        if info.initialized:
            self.info = info
            self._ui  = self.edit_traits( parent = info.gender.control )

    def _cancel_changed ( self ):
        object = self.info.object
        object.gender = [ 'Male', 'Female' ][ object.gender == 'Male' ]
        self._ui.dispose()

#-- The Person class -----------------------------------------------------------

class Person ( HasPrivateTraits ):

    # The person's name, age and gender:
    name   = Str
    age    = Int
    gender = Enum( 'Male', 'Female' )

    # The traits UI view:
    traits_view = View(
        Item( 'name' ),
        Item( 'age' ),
        Item( 'gender' ),
        title   = 'Button Popup Demo',
        handler = PersonHandler
    )

#-- Create and run the demo ----------------------------------------------------

# Create the demo:
demo = Person( name = 'Mike Thomas', age  = 32 )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Property_List_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This demo shows the proper way to create a <b>Property</b> whose value is a
list, especially when the value of the <b>Property</b> will be used in a user
interface, such as with the <b>TableEditor</b>.

Most of the demo is just the machinery to set up the example. The key thing to
note is the declaration of the <i>people</i> trait:

    people = Property( List, depends_on = 'ticker' )

In this case, by defining the <b>Property</b> as having a value of type
<b>List</b>, you are ensuring that the computed value of the property will be
validated using the <b>List</b> type, which in addition to verifying that the
value is indeed a list, also guarantees that it will be converted to a
<b>TraitListObject</b>, which is necessary for correct interaction with various
Traits UI editors in a user interface.

Note also the use of the <i>depends_on</i> metadata to trigger a trait property
change whenever the <i>ticker</i> trait changes (in this case, it is changed
every three seconds by a background thread).

Finally, the use of the <i>@cached_property</i> decorator simplifies the
implementation of the property by allowing the <b>_get_people</b> <i>getter</i>
method to perform the expensive generation of a new list of people only when
the <i>ticker</i> event fires, not every time it is accessed.
"""

#-- Imports --------------------------------------------------------------------

from random \
    import randint, choice

from threading \
   import Thread

from time \
    import sleep

from traits.api \
    import HasStrictTraits, HasPrivateTraits, Str, Int, Enum, List, Event, \
           Property, cached_property

from traitsui.api \
    import View, Item, TableEditor

from traitsui.table_column \
    import ObjectColumn

#-- Person Class ---------------------------------------------------------------

class Person ( HasStrictTraits ):
    """ Defines some sample data to display in the TableEditor.
    """

    name   = Str
    age    = Int
    gender = Enum( 'Male', 'Female' )

#-- PropertyListDemo Class -----------------------------------------------------

class PropertyListDemo ( HasPrivateTraits ):
    """ Displays a random list of Person objects in a TableEditor that is
        refreshed every 3 seconds by a background thread.
     """

    # An event used to trigger a Property value update:
    ticker = Event

    # The property being display in the TableEditor:
    people = Property( List, depends_on = 'ticker' )

    # Tiny hack to allow starting the background thread easily:
    begin = Int

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'people',
              show_label = False,
              editor = TableEditor(
                  columns = [
                      ObjectColumn( name = 'name',   editable = False,
                                    width = 0.50 ),
                      ObjectColumn( name = 'age',    editable = False,
                                    width = 0.15 ),
                      ObjectColumn( name = 'gender', editable = False,
                                    width = 0.35 )
                  ],
                  auto_size    = False,
                  show_toolbar = False
              )
        ),
        title     = 'Property List Demo',
        width     = 0.25,
        height    = 0.33,
        resizable = True
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_people ( self ):
        """ Returns the value for the 'people' property.
        """
        return [ Person(
            name = '%s %s' % (
                choice( [ 'Tom', 'Dick', 'Harry', 'Alice', 'Lia', 'Vibha' ] ),
                choice( [ 'Thomas', 'Jones', 'Smith', 'Adams', 'Johnson' ] ) ),
            age    = randint( 21, 75 ),
            gender = choice( [ 'Male', 'Female' ] ) )
            for i in xrange( randint( 10, 20 ) )
        ]

    #-- Default Value Implementations ------------------------------------------

    def _begin_default ( self ):
        """ Starts the background thread running.
        """
        thread = Thread( target = self._timer )
        thread.setDaemon( True )
        thread.start()

        return 0

    #-- Private Methods --------------------------------------------------------

    def _timer ( self ):
        """ Triggers a property update every 3 seconds for 30 seconds.
        """
        for i in range( 10 ):
            sleep( 3 )
            self.ticker = True

# Create the demo:
demo = PropertyListDemo()
demo.begin

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Scrubber_editor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This example demonstrates several different variations on using the
ScrubberEditor. A 'scrubber' is a type of widget often seen in certain types
of applications, such as video editing, image editing, 3D graphics and
animation.

These types of programs often have many parameters defined over various ranges
that the user can tweak to get varying effects or results. Because the number
of parameters is typically fairly large, and the amount of screen real estate is
fairly limited, these program often use 'scrubbers' to allow the user to adjust
the parameter values.

A scrubber often looks like a simple text field. The user can type in new
values, if they need a precise setting, or simply drag the mouse over the value
to set a new value, much like dragging a slider control. The visual feedback
often comes in the form of seeing both the text value of the parameter change
and the effect that the new parameter value has on the underlying model.

For example, in a 3D graphics program, there might be a scrubber for
controlling the rotation of the currently selected object around the Y-axis.
As the user scrubs the rotation parameter, they also see the model spin on
the screen as well. This visual feedback is what makes a scrubber more useful
than a simple text entry field. And the fact that the scrubber takes up no
more screen real estate that a text entry field is what makes it more useful
than a full-fledged slider in space limited applications.

The Traits UI ScrubberEditor works as follows:

  - When the mouse pointer moves over the scrubber, the cursor pointer changes
    shape to indicate that the field has some additional control behavior.

  - The control may optionally change color as well, to visually indicate that
    the control is 'live'.

  - If you simply click on the scrubber, an active text entry field is
    displayed, where you can type a new value for the trait, then press the
    Enter key.

  - If you click and drag while over the scrubber, the value of the trait is
    modified based on the direction you move the mouse. Right and/or up
    increases the value, left and/or down decreases the value. Holding the
    Shift key down while scrubbing causes the value to change by 10 times its
    normal amount. Holding the Control key down while scrubbing changes the
    value by 0.1 times its normal amount.

  - Scrubbing is not limited to the area of the scrubber control. You can drag
    as far as you want in any direction, subject to the maximum limits imposed
    by the trait or ScrubberEditor definition.

The ScrubberEditor also supports several different style and functional
variations:

  - The visual default is to display only the special scrubber pointer to
    indicate to the user that 'scrubber' functionality is available.

  - By specifying a 'hover_color' value, you can also have the editor change
    color when the mouse pointer is over it.

  - By specifying an 'active_color' value, you can have the editor change color
    while the user is scrubbing.

  - By specifying a 'border_color' value, you can display a solid border around
    the editor to mark it as something other than an ordinary text field.

  - By specifying an 'increment' value, you can tell the editor what the normal
    increment value for the scrubber should be. Otherwise, the editor will
    calculate the increment value itself. Explicitly specifying an increment
    can be very useful in cases where the underlying trait has an unbounded
    value, which makes it difficult for the editor to determine what a
    reasonable increment value might be.

  - The editor will also correctly handle traits with dynamic ranges (i.e.
    ranges whose high and low limits are defined by other traits). Besides
    correctly handling the range limits, the editor will also adjust the
    default tooltip to display the current range of the scrubber.

In this example, several of the variations described above are shown:

  - A simple integer range with default visual cues.

  - A float range with both 'hover_color' and 'active_color' values specified.

  - An unbounded range with a 'border_color' value specified.

  - A dynamic range using an Item theme. This consists of three scrubbers: one
    to control the low end of the range, one to control the high end, and one
    that uses the high and low values to determine its range.

For comparison purposes, the example also shows the same traits displayed using
their default editors.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, Range, Float

from traitsui.api \
    import View, VGroup, HGroup, Item, ScrubberEditor, spring

from traitsui.ui_traits \
    import ATheme

#-- Shared Themed Item Definition ----------------------------------------------

class TItem ( Item ):
    editor     = ScrubberEditor()
    item_theme = ATheme( '@std:LG' )

#-- ScrubberDemo Class ---------------------------------------------------------

class ScrubberDemo ( HasTraits ):

    # Define some sample ranges and values:
    simple_integer       = Range( 0, 100 )
    rollover_float       = Range( -10.0, 10.0 )
    bordered_unbounded   = Float
    themed_dynamic_low   = Range( high = -0.01, value = -10.0 )
    themed_dynamic_high  = Range( low  =  0.01, value =  10.0 )
    themed_dynamic_value = Range( 'themed_dynamic_low', 'themed_dynamic_high',
                                  0.0 )

    # Define the demo view:
    view = View(
        HGroup(
            VGroup(
                Item( 'simple_integer',
                      editor = ScrubberEditor() ),
                Item( 'rollover_float',
                      editor = ScrubberEditor( hover_color  = 0xFFFFFF,
                                               active_color = 0xA0CD9E ) ),
                Item( 'bordered_unbounded',
                      editor = ScrubberEditor( hover_color  = 0xFFFFFF,
                                               active_color = 0xA0CD9E,
                                               border_color = 0x808080 ) ),
                TItem( 'themed_dynamic_low' ),
                TItem( 'themed_dynamic_high' ),
                TItem( 'themed_dynamic_value' ),
                show_border = True,
                label       = 'Scrubber Editors'
            ),
            VGroup(
                Item( 'simple_integer' ),
                Item( 'rollover_float' ),
                Item( 'bordered_unbounded' ),
                Item( 'themed_dynamic_low' ),
                Item( 'themed_dynamic_high' ),
                Item( 'themed_dynamic_value' ),
                show_border = True,
                label       = 'Default Editors'
            ),
            spring
        ),
        title = 'Scrubber Editor Demo'
    )

#-- Create and run the demo ----------------------------------------------------

# Create the demo:
demo = ScrubberDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = Settable_cached_property
"""
Creating settable cached Property in Traits

How to create a Traits Property which is cached but is not read-only.

The example demonstrates how to create a 'settable cached' property. The example
itself is nonsensical, and is provided mainly to show how to set up such a
property, and how it differs from a standard 'cached' property.

A normal 'cached' property does not have a 'setter' method, meaning that the
property is read-only. It usually represents a value which depends upon the
state of other traits for its value. The cached property provides both a
mechanism for remembering (i.e. caching) the current value of the property as
well as a means of automatically detecting when the value of the property
changes (which causes the cache to be flushed), and notifying any associated
trait listeners that the value of the property has changed.

Normally there is no 'setter' for such a property because the value is derived
from the value of other traits.

However, it is possible to define a 'settable cached' property which in addition
to the capabilities of a normal 'cached' property, also allows the property's
value to be explicitly set.

To accomplish this, simply set the 'settable' argument to the
'property_depends_on' decorator to True (see the '_get_c' method in the
example code). When set this way, an appropriate 'setter' method is
automatically generated for the associated property.

This allows code to set the value of the property directly if desired, subject
to any constraints specified in the property declaration. For example, in the
example, the 'c' trait is a 'settable cached' property whose value must be an
integer. Attempting to set a non-integer value of the property will raise an
exception, just like any other trait would.

If any of the traits which the property depends upon change value, the current
value of the property will be flushed from the cache and a change notification
for the property will be generated. Any code that then attempts to read the
value of the property will result in the cache being reloaded with the new value
returned by the property's 'getter' method.

In the example, trait 'c' is a 'settable cached' property which returns the
product of 'a' times 'b', and trait 'd' is a normal 'cached' property that
returns double the value of 'c'.

To see the effect of these traits in action, try moving the 'a' and 'b' sliders
and watching the 'c' and 'd' traits update. This demonstrates how 'c' and 'd'
are properties that depend upon the values of other traits.

Now try changing the value of the 'c' trait by moving the slider or typing a
new value into the text entry field. You will see that the 'd' trait updates
as well, illustrating that the 'c' trait can be set directly, as well as
indirectly by changes to 'a' and 'b'.

Also, try typing non-numeric values into the 'c' field and you will see that
any values set are being type checked as well (i.e. they must be integer
values).

Now try typing a value into the 'd' trait and you will see that an error
results (indicated by the text entry field turning red), because this is a
normal 'cached' trait that has no 'setter' method defined.
"""

from traits.api import HasTraits, Int, Range, Property, property_depends_on
from traitsui.api import View, Item, RangeEditor

#-- Demo Class -----------------------------------------------------------------

class SettableCachedProperty(HasTraits):

    a = Range(1, 10)
    b = Range(1, 10)
    c = Property(Int)
    d = Property

    view = View(
        Item('a'),
        Item('b'),
        '_',
        Item('c',
              editor = RangeEditor(low = 1, high = 100, mode = 'slider')),
        Item('c'),
        '_',
        Item('d',
              editor = RangeEditor(low = 1, high = 400, mode = 'slider')),
        Item('d'),
        width = 0.3
    )

    @property_depends_on('a,b', settable = True)
    def _get_c(self):
        return (self.a * self.b)

    @property_depends_on('c')
    def _get_d(self):
        return (self.c + self.c)

#-- Run the demo ---------------------------------------------------------------

# Create the demo:
demo = SettableCachedProperty()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = Statusbar_demo
"""
Displaying a statusbar in a Traits UI

A statusbar may contain one or more fields, of fixed or variable size.

Fixed width fields are specified in pixels, while variable width fields are
specified as fractional values relative to other variable width fields.

The content of a statusbar field is specified via the extended trait name of
the object attribute that will contain the statusbar information.

In this example, there are two statusbar fields:

 - The current length of the text input data (variable width)
 - The current time (fixed width, updated once per second).

Note the use of a timer thread to update the status bar once per second.

"""

from time import sleep, strftime
from threading import Thread
from traits.api import HasPrivateTraits, Str, Property
from traitsui.api import View, Item, StatusItem, Label

#-- The demo class -------------------------------------------------------------

class TextEditor(HasPrivateTraits):

    # The text being edited:
    text = Str

    # The current length of the text being edited:
    length = Property(depends_on = 'text')

    # The current time:
    time = Str

    # The view definition:
    view = View(
        Label('Type into the text editor box:'),
        Item('text', style = 'custom', show_label = False),
        title     = 'Text Editor',
        id        = 'traitsui.demo.advanced.statusbar_demo',
        width     = 0.4,
        height    = 0.4,
        resizable = True,
        statusbar = [ StatusItem(name = 'length', width = 0.5),
                      StatusItem(name = 'time',   width = 85) ]
    )

    #-- Property Implementations -----------------------------------------------

    def _get_length(self):
        return ('Length: %d characters' % len(self.text))

    #-- Default Trait Values ---------------------------------------------------

    def _time_default(self):
        thread = Thread(target = self._clock)
        thread.setDaemon(True)
        thread.start()

        return ''

    #-- Private Methods --------------------------------------------------------

    def _clock(self):
        """ Update the statusbar time once every second.
        """
        while True:
            self.time = strftime('%I:%M:%S %p')
            sleep(1.0)

# Create the demo object:
popup = TextEditor()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = String_list_ui_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Another demo showing how to use a TabularEditor to create a multi-select list
box. This demo creates a reusable StringListEditor class and uses that instead
of defining the editor as part of the demo class.

This approach greatly simplifies the actual demo class and shows how to
construct a reusable Traits UI-based editor that can be used in other
applications.
"""

#-- Imports ------------------------------------------------------------------

from traits.api import HasPrivateTraits, List, Str, Property, on_trait_change

from traitsui.api import View, HGroup, Item, TabularEditor
from traitsui.tabular_adapter import TabularAdapter
from traitsui.basic_editor_factory import BasicEditorFactory

from traits.etsconfig.api import ETSConfig
if ETSConfig.toolkit == 'wx':
    from traitsui.wx.ui_editor import UIEditor
else:
    from traitsui.qt4.ui_editor import UIEditor

#-- Define the reusable StringListEditor class and its helper classes --------

# Define the tabular adapter used by the Traits UI string list editor:
class MultiSelectAdapter ( TabularAdapter ):

    # The columns in the table (just the string value):
    columns = [ ( 'Value', 'value' ) ]

    # The text property used for the 'value' column:
    value_text = Property

    def _get_value_text ( self ):
        return self.item

# Define the actual Traits UI string list editor:
class _StringListEditor ( UIEditor ):

    # Indicate that the editor is scrollable/resizable:
    scrollable = True

    # The list of available editor choices:
    choices = List( Str )

    # The list of currently selected items:
    selected = List( Str )

    # The traits UI view used by the editor:
    view = View(
        Item( 'choices',
              show_label = False,
              editor     = TabularEditor(
                               show_titles  = False,
                               selected     = 'selected',
                               editable     = False,
                               multi_select = True,
                               adapter      = MultiSelectAdapter() )
        ),
        id        = 'string_list_editor',
        resizable = True
    )

    def init_ui ( self, parent ):

        self.sync_value( self.factory.choices, 'choices', 'from',
                         is_list = True )
        self.selected = self.value

        return self.edit_traits( parent = parent, kind = 'subpanel' )

    @on_trait_change( ' selected' )
    def _selected_modified ( self ):
        self.value = self.selected

# Define the StringListEditor class used by client code:
class StringListEditor ( BasicEditorFactory ):

    # The editor implementation class:
    klass = _StringListEditor

    # The extended trait name containing the editor's set of choices:
    choices = Str

#-- Define the demo class ----------------------------------------------------

class MultiSelect ( HasPrivateTraits ):
    """ This class demonstrates using the StringListEditor to select a set
        of string values from a set of choices.
    """

    # The list of choices to select from:
    choices = List( Str )

    # The currently selected list of choices:
    selected = List( Str )

    # A dummy result so that we can display the selection using the same
    # StringListEditor:
    result = List( Str )

    # A traits view showing the list of choices on the left-hand side, and
    # the currently selected choices on the right-hand side:
    view = View(
        HGroup(
            Item( 'selected',
                  show_label = False,
                  editor     = StringListEditor( choices = 'choices' )
            ),
            Item( 'result',
                  show_label = False,
                  editor     = StringListEditor( choices = 'selected' )
            )
        ),
        width  = 0.20,
        height = 0.25
    )

# Create the demo:
demo = MultiSelect( choices  = [ 'one', 'two', 'three', 'four', 'five', 'six',
                                 'seven', 'eight', 'nine', 'ten' ],
                    selected = [ 'two', 'five', 'nine' ] )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Table_editor_with_checkbox_column
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This shows a table editor which has a checkbox column in addition to normal
data columns.
"""

# Imports:
from random \
    import randint

from traits.api \
    import HasStrictTraits, Str, Int, Float, List, Bool, Property

from traitsui.api \
    import View, Item, TableEditor

from traitsui.table_column \
    import ObjectColumn

from traitsui.extras.checkbox_column \
    import CheckboxColumn


# Create a specialized column to set the text color differently based upon
# whether or not the player is in the lineup:
class PlayerColumn ( ObjectColumn ):

    # Override some default settings for the column:
    width                = 0.08
    horizontal_alignment = 'center'

    def get_text_color ( self, object ):
        return [ 'light grey', 'black' ][ object.in_lineup ]


# The 'players' trait table editor:
player_editor = TableEditor(
    sortable     = False,
    configurable = False,
    auto_size    = False,
    columns  = [ CheckboxColumn( name  = 'in_lineup',  label = 'In Lineup',
                                 width = 0.12 ),
                 PlayerColumn( name = 'name', editable = False, width  = 0.24,
                               horizontal_alignment = 'left' ),
                 PlayerColumn( name   = 'at_bats',     label  = 'AB' ),
                 PlayerColumn( name   = 'strike_outs', label  = 'SO' ),
                 PlayerColumn( name   = 'singles',     label  = 'S' ),
                 PlayerColumn( name   = 'doubles',     label  = 'D' ),
                 PlayerColumn( name   = 'triples',     label  = 'T' ),
                 PlayerColumn( name   = 'home_runs',   label  = 'HR' ),
                 PlayerColumn( name   = 'walks',       label  = 'W' ),
                 PlayerColumn( name   =  'average',    label  = 'Ave',
                               editable = False,       format = '%0.3f' ) ] )

# 'Player' class:
class Player ( HasStrictTraits ):

    # Trait definitions:
    in_lineup   = Bool( True )
    name        = Str
    at_bats     = Int
    strike_outs = Int
    singles     = Int
    doubles     = Int
    triples     = Int
    home_runs   = Int
    walks       = Int
    average     = Property( Float )

    def _get_average ( self ):
        """ Computes the player's batting average from the current statistics.
        """
        if self.at_bats == 0:
            return 0.0

        return float( self.singles + self.doubles +
                      self.triples + self.home_runs ) / self.at_bats


class Team ( HasStrictTraits ):

    # Trait definitions:
    players = List( Player )

    # Trait view definitions:
    traits_view = View(
        Item( 'players',
              show_label = False,
              editor     = player_editor
        ),
        title     = 'Baseball Team Roster Demo',
        width     = 0.5,
        height    = 0.5,
        resizable = True
    )


def random_player ( name ):
    """ Generates and returns a random player.
    """
    p = Player( name        = name,
                strike_outs = randint( 0, 50 ),
                singles     = randint( 0, 50 ),
                doubles     = randint( 0, 20 ),
                triples     = randint( 0,  5 ),
                home_runs   = randint( 0, 30 ),
                walks       = randint( 0, 50 ) )
    return p.trait_set( at_bats = p.strike_outs + p.singles + p.doubles + p.triples +
                            p.home_runs + randint( 100, 200 ) )

# Create the demo:
demo = view = Team( players = [ random_player( name ) for name in [
    'Dave', 'Mike', 'Joe', 'Tom', 'Dick', 'Harry', 'Dirk', 'Fields', 'Stretch'
] ] )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Table_editor_with_context_menu_demo
"""
Defining column-specific context menu in a Table

Shows a TableEditor which has column-specific context menus.

The demo is a simple baseball scoring system, which lists each player and
their current batting statistics. After a given player has an at bat, you
right-click on the table cell corresponding to the player and the result of
the at-bat (e.g. 'S' = single) and select the 'Add' menu option to register
that the player hit a single and update the player's overall statistics.

This demo also illustrates the use of Property traits, and how using 'event'
meta-data can simplify event handling by collapsing an event that can
occur on a number of traits into a category of event, which can be handled by
a single event handler defined for the category (in this case, the category
is 'affects_average').
"""

from random import randint
from traits.api import HasStrictTraits, Str, Int, Float, List, Property
from traitsui.api import View, Item, TableEditor
from traitsui.menu import Menu, Action
from traitsui.table_column import ObjectColumn

# Define a custom table column for handling items which affect the player's
# batting average:
class AffectsAverageColumn(ObjectColumn):

    # Define the context menu for the column:
    menu = Menu(Action(name = 'Add', action = 'column.add(object)'),
                 Action(name = 'Sub', action = 'column.sub(object)'))

    # Right-align numeric values (override):
    horizontal_alignment = 'center'

    # Column width (override):
    width = 0.09

    # Don't allow the data to be edited directly:
    editable = False

    # Action methods for the context menu items:

    def add(self, object):
        """ Increment the affected player statistic.
        """
        setattr(object, self.name, getattr(object, self.name) + 1)

    def sub(self, object):
        """ Decrement the affected player statistic.
        """
        setattr(object, self.name, getattr(object, self.name) - 1)


# The 'players' trait table editor:
player_editor = TableEditor(
    editable  = True,
    sortable  = True,
    auto_size = False,
    columns   = [ ObjectColumn(name     = 'name',
                                editable = False, width = 0.28),
                  AffectsAverageColumn(name  = 'at_bats',
                                        label = 'AB'),
                  AffectsAverageColumn(name  = 'strike_outs',
                                        label = 'SO'),
                  AffectsAverageColumn(name  = 'singles',
                                        label = 'S'),
                  AffectsAverageColumn(name  = 'doubles',
                                        label = 'D'),
                  AffectsAverageColumn(name  = 'triples',
                                        label = 'T'),
                  AffectsAverageColumn(name  = 'home_runs',
                                        label = 'HR'),
                  AffectsAverageColumn(name  = 'walks',
                                        label = 'W'),
                  ObjectColumn(name     = 'average',
                                label    = 'Ave',
                                editable = False,
                                width    = 0.09,
                                horizontal_alignment = 'center',
                                format   = '%0.3f') ]
)


# 'Player' class:
class Player(HasStrictTraits):

    # Trait definitions:
    name        = Str
    at_bats     = Int
    strike_outs = Int(event = 'affects_average')
    singles     = Int(event = 'affects_average')
    doubles     = Int(event = 'affects_average')
    triples     = Int(event = 'affects_average')
    home_runs   = Int(event = 'affects_average')
    walks       = Int
    average     = Property(Float)

    def _get_average(self):
        """ Computes the player's batting average from the current statistics.
        """
        if self.at_bats == 0:
            return 0.0

        return float(self.singles + self.doubles +
                      self.triples + self.home_runs) / self.at_bats

    def _affects_average_changed(self):
        """ Handles an event that affects the player's batting average.
        """
        self.at_bats += 1


class Team(HasStrictTraits):

    # Trait definitions:
    players = List(Player)

    # Trait view definitions:
    traits_view = View(
        Item('players',
              show_label = False,
              editor     = player_editor
        ),
        title     = 'Baseball Scoring Demo',
        width     = 0.5,
        height    = 0.5,
        resizable = True
    )


def random_player(name):
    """ Generates and returns a random player.
    """
    p = Player(name        = name,
                strike_outs = randint(0, 50),
                singles     = randint(0, 50),
                doubles     = randint(0, 20),
                triples     = randint(0,  5),
                home_runs   = randint(0, 30),
                walks       = randint(0, 50))
    return p.trait_set(at_bats = p.strike_outs + p.singles + p.doubles + p.triples +
                            p.home_runs + randint(100, 200))

# Create the demo:
demo = view = Team(players = [ random_player(name) for name in [
    'Dave', 'Mike', 'Joe', 'Tom', 'Dick', 'Harry', 'Dirk', 'Fields', 'Stretch'
] ])

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Table_editor_with_live_search_and_cell_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This example demonstrates how to implement 'live search' using a TableEditor,
as well as how to embed more sophisticated editors, such as a CodeEditor, within
a table cell. This example also makes extensive use of cached properties.

The example is a fairly simple source code file search utility. You determine
which files to search and what to search for using the various controls spread
across the top line of the view.

You specify the root directory to search for files in using the 'Path' field.
You can either:

  - Type in a directory name.
  - Click the '...' button and select a directory from the drop-down tree view
    that is displayed.
  - Click on the directory name drop-down to display a history list of the 10
    most recently visited directories, and select a directory from the list.

You can specify whether sub-directories should be included or not by toggling
the 'Recursive' checkbox on or off.

You can specify the types of files to be searched by clicking on the 'Type'
drop-down and selecting a file type such as Python or C from the list.

You can specify what string to search for by typing into the 'Search' field.
The set of source files containing the search string is automatically updated
as you type (this is the 'live search' feature). The search field also maintains
a history of previous searches, so you can click on the drop-down arrow to
display and select a previous search. Note that entries are only added to the
search history when the enter key is pressed. This prevents each partial
substring typed from being added to the history as a separate entry.

You can specify whether the search is case sensitive or not by toggling the
'Case sensitive' checkbox on or off.

The results of the search are displayed in a table below the input fields.
The table contains four columns:

  - #: The number of lines matching the search string in the file.
  - Matches: A list of all lines containing search string matches in the file.
    Normally, only the first match is displayed, but you can click on this
    field to display the entire list of matches (the table row will expand and a
    CodeEditor will be displayed showing the complete list of matching source
    code file lines). You can click on or cursor to lines in the code editor to
    display the corresponding source code line in context in the code editor
    that appears at the bottom of the view.
  - Name: Displays the base name of the source file with no path information.
  - Path: Displays the portion of the source file path not included in the
    the root directory being used for the search.

Selecting a line in the table editor will display the contents of the
corresponding source file in the Code Editor displayed at the bottom of the
view.

After clicking on a 'Matches' column entry you can use the cursor up and down
keys to select the various matching source code lines displayed in the table
cell editor. You can move to the next or previous 'Matches' entry by pressing
the Ctrl-Up and Ctrl-Down cursor keys. You can also use the Ctrl-Left and
Ctrl-Right cursor keys to move to the previous or next column on the same line.

You can also exit the 'Matches' code editor by pressing the Escape key.

Finally:

  - You can click and drag the little circle to the right of the currently
    selected file to drag and drop the file. This can be useful, for example, to
    drag and drop the file into your favorite text editor.

  - Similarly, you can also drag the contents of the 'Name' column into your
    favorite text editor to edit the file corresponding to that line in the
    table.
"""

#-- Imports --------------------------------------------------------------------

from os \
    import walk, getcwd, listdir

from os.path \
    import basename, dirname, splitext, join

from traits.api \
    import HasTraits, File, Directory, Str, Bool, Int, Enum, Instance, \
           Property, Any, property_depends_on

from traitsui.api \
    import View, VGroup, VSplit, HGroup, Item, TableEditor, CodeEditor, \
           TitleEditor, HistoryEditor, DNDEditor

from traitsui.table_column \
    import ObjectColumn

#-- Constants ------------------------------------------------------------------

FileTypes = {
    'Python': [ '.py' ],
    'C':      [ '.c', '.h' ],
    'C++':    [ '.cpp', '.h' ],
    'Java':   [ '.java' ],
    'Ruby':   [ '.rb' ]
}

#-- The Live Search table editor definition ------------------------------------

class MatchesColumn1 ( ObjectColumn ):

    def get_value ( self, object ):
        n = len( self.get_raw_value( object ) )
        if n == 0:
            return ''

        return str( n )

class MatchesColumn2 ( ObjectColumn ):

    def is_editable ( self, object ):
        return (len( object.matches ) > 0)

class FileColumn ( ObjectColumn ):

    def get_drag_value ( self, object ):
        return object.full_name

table_editor = TableEditor(
    columns = [
        MatchesColumn1( name        = 'matches',
                        label       = '#',
                        editable    = False,
                        width       = 0.05,
                        horizontal_alignment = 'center' ),
        MatchesColumn2( name        = 'matches',
                        width       = 0.35,
                        format_func = lambda x: (x + [ '' ])[0].strip(),
                        editor      = CodeEditor( line =
                                          'object.live_search.selected_match',
                                        selected_line =
                                          'object.live_search.selected_match' ),
                        style       = 'readonly',
                        edit_width  = 0.95,
                        edit_height = 0.33 ),
        FileColumn(     name        = 'base_name',
                        label       = 'Name',
                        width       = 0.30,
                        editable    = False ),
        ObjectColumn(   name        = 'ext_path',
                        label       = 'Path',
                        width       = 0.30,
                        editable    = False ),
    ],
    filter_name        = 'filter',
    auto_size          = False,
    show_toolbar       = False,
    selected           = 'selected',
    selection_color    = 0x000000,
    selection_bg_color = 0xFBD391
)

#-- LiveSearch class -----------------------------------------------------------

class LiveSearch ( HasTraits ):

    # The currenty root directory being searched:
    root = Directory( getcwd(), entries = 10 )

    # Should sub directories be included in the search:
    recursive = Bool( True )

    # The file types to include in the search:
    file_type = Enum( 'Python', 'C', 'C++', 'Java', 'Ruby' )

    # The current search string:
    search = Str

    # Is the search case sensitive?
    case_sensitive = Bool( False )

    # The live search table filter:
    filter = Property # Instance( TableFilter )

    # The current list of source files being searched:
    source_files = Property # List( SourceFile )

    # The currently selected source file:
    selected = Any # Instance( SourceFile )

    # The contents of the currently selected source file:
    selected_contents = Property # List( Str )

    # The currently selected match:
    selected_match = Int

    # The text line corresponding to the selected match:
    selected_line = Property # Int

    # The full name of the currently selected source file:
    selected_full_name = Property # File

    # The list of marked lines for the currently selected file:
    mark_lines = Property # List( Int )

    # Summary of current number of files and matches:
    summary = Property # Str

    #-- Traits UI Views --------------------------------------------------------

    view = View(
        VGroup(
            HGroup(
                Item( 'root',
                      id    = 'root',
                      label = 'Path',
                      width = 0.5
                ),
                Item( 'recursive' ),
                Item( 'file_type', label = 'Type' ),
                Item( 'search',
                      id     = 'search',
                      width  = 0.5,
                      editor = HistoryEditor( auto_set = True )
                ),
                Item( 'case_sensitive' )
            ),
            VSplit(
                VGroup(
                    Item( 'summary',
                          editor = TitleEditor()
                    ),
                    Item( 'source_files',
                          id     = 'source_files',
                          editor = table_editor
                    ),
                    dock        = 'horizontal',
                    show_labels = False
                ),
                VGroup(
                    HGroup(
                        Item( 'selected_full_name',
                              editor  = TitleEditor(),
                              springy = True
                        ),
                        Item( 'selected_full_name',
                              editor  = DNDEditor(),
                              tooltip = 'Drag this file'
                        ),
                        show_labels = False
                    ),
                    Item( 'selected_contents',
                          style  = 'readonly',
                          editor = CodeEditor( mark_lines    = 'mark_lines',
                                               line          = 'selected_line',
                                               selected_line = 'selected_line' )
                    ),
                    dock        = 'horizontal',
                    show_labels = False
                ),
                id = 'splitter'
            )
        ),
        title     = 'Live File Search',
        id        = 'enthought.examples.demo.Advanced.'
                    'Table_editor_with_live_search_and_cell_editor.LiveSearch',
        width     = 0.75,
        height    = 0.67,
        resizable = True
    )

    #-- Property Implementations -----------------------------------------------

    @property_depends_on( 'search, case_sensitive' )
    def _get_filter ( self ):
        if len( self.search ) == 0:
            return lambda x: True

        return lambda x: len( x.matches ) > 0

    @property_depends_on( 'root, recursive, file_type' )
    def _get_source_files ( self ):
        root = self.root
        if root == '':
            root = getcwd()

        file_types = FileTypes[ self.file_type ]
        if self.recursive:
            result = []
            for dir_path, dir_names, file_names in walk( root ):
                for file_name in file_names:
                    if splitext( file_name )[1] in file_types:
                        result.append( SourceFile(
                            live_search = self,
                            full_name   = join( dir_path, file_name ) ) )
            return result

        return [ SourceFile( live_search = self,
                             full_name   = join( root, file_name ) )
                 for file_name in listdir( root )
                 if splitext( file_name )[1] in file_types ]

    @property_depends_on( 'selected' )
    def _get_selected_contents ( self ):
        if self.selected is None:
            return ''

        return ''.join( self.selected.contents )

    @property_depends_on( 'selected' )
    def _get_mark_lines ( self ):
        if self.selected is None:
            return []

        return [ int( match.split( ':', 1 )[0] )
                 for match in self.selected.matches ]

    @property_depends_on( 'selected, selected_match' )
    def _get_selected_line ( self ):
        selected = self.selected
        if (selected is None) or (len( selected.matches ) == 0):
            return 1

        return int( selected.matches[ self.selected_match - 1
                                    ].split( ':', 1 )[0] )

    @property_depends_on( 'selected' )
    def _get_selected_full_name ( self ):
        if self.selected is None:
            return ''

        return self.selected.full_name

    @property_depends_on( 'source_files, search, case_sensitive' )
    def _get_summary ( self ):
        source_files = self.source_files
        search       = self.search
        if search == '':
            return 'A total of %d files.' % len( source_files )

        files   = 0
        matches = 0
        for source_file in source_files:
            n = len( source_file.matches )
            if n > 0:
                files   += 1
                matches += n

        return 'A total of %d files with %d files containing %d matches.' % (
               len( source_files ), files, matches )

    #-- Traits Event Handlers --------------------------------------------------

    def _selected_changed ( self ):
        self.selected_match = 1

    def _source_files_changed ( self ):
        if len( self.source_files ) > 0:
            self.selected = self.source_files[0]
        else:
            self.selected = None

#-- SourceFile class -----------------------------------------------------------

class SourceFile ( HasTraits ):

    # The search object this source file is associated with:
    live_search = Instance( LiveSearch )

    # The full path and file name of the source file:
    full_name = File

    # The base file name of the source file:
    base_name = Property # Str

    # The portion of the file path beyond the root search path:
    ext_path = Property # Str

    # The contents of the source file:
    contents = Property # List( Str )

    # The list of matches for the current search criteria:
    matches = Property # List( Str )

    #-- Property Implementations -----------------------------------------------

    @property_depends_on( 'full_name' )
    def _get_base_name ( self ):
        return basename( self.full_name )

    @property_depends_on( 'full_name' )
    def _get_ext_path ( self ):
        return dirname( self.full_name )[ len( self.live_search.root ): ]

    @property_depends_on( 'full_name' )
    def _get_contents ( self ):
        try:
            fh = open( self.full_name, 'rb' )
            contents = fh.readlines()
            fh.close()
            return contents
        except:
            return ''

    @property_depends_on( 'full_name, live_search.[search, case_sensitive]' )
    def _get_matches ( self ):
        search = self.live_search.search
        if search == '':
            return []

        case_sensitive = self.live_search.case_sensitive
        if case_sensitive:
            return [ '%5d: %s' % ( (i + 1), line.strip() )
                     for i, line in enumerate( self.contents )
                     if line.find( search ) >= 0 ]

        search = search.lower()
        return [ '%5d: %s' % ( (i + 1), line.strip() )
                 for i, line in enumerate( self.contents )
                 if line.lower().find( search ) >= 0 ]

#-- Set up and run the demo ----------------------------------------------------

# Create the demo object:
demo = LiveSearch()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Tabular_editor_demo
"""
Tabular editor

The TabularEditor can be used for many of the same purposes as the TableEditor,
that is, for displaying a table of attributes of lists or arrays of objects.

While similar in function, the tabular editor has advantages and disadvantages
relative to the table editor. See the Traits UI User Manual for details.

This example defines three classes:

 - *Person*: A single person.
 - *MarriedPerson*: A married person (subclass of Person).
 - *Report*: Defines a report based on a list of single and married people.

It creates a tabular display of 10,000 single and married people showing the
following information:

 - Name of the person.
 - Age of the person.
 - The person's address.
 - The name of the person's spouse (if any).

In addition:

 - It uses a Courier 10 point font for each line in the table.
 - It displays age column right, instead of left, justified.
 - If the person is a minor (age < 18) and married, it displays a red flag
   image in the age column.
 - If the person is married, it makes the background color for that row a light
   blue.
   
 - If this demo is running under QT, it displays each person's surname
   in a row label.

This example demonstrates:

 - How to set up a *TabularEditor*.
 - The display speed of the *TabularEditor*.
 - How to create a *TabularAdapter* that meets each of the specified display
   requirements.

Additional notes:

 - You can change the current selection using the up and down arrow keys.
 - You can move a selected row up and down in the table using the left and
   right arrow keys.
"""

from random import randint, choice, shuffle
from traits.api import HasTraits, Str, Int, List, Instance, Property, \
     Constant, Color
from traits.etsconfig.api import ETSConfig
from traitsui.api import View, Group, Item, TabularEditor
from traitsui.tabular_adapter import TabularAdapter

#-- Person Class Definition ----------------------------------------------------

class Person(HasTraits):

    name    = Str
    address = Str
    age     = Int
    
    # surname is displayed in qt-only row label:
    surname = Property(fget=lambda self: self.name.split()[-1], 
                       depends_on='name')

#-- MarriedPerson Class Definition ---------------------------------------------

class MarriedPerson(Person):

    partner = Instance(Person)

#-- Tabular Adapter Definition -------------------------------------------------

class ReportAdapter(TabularAdapter):
    """ The tabular adapter interfaces between the tabular editor and the data 
    being displayed. For more details, please refer to the traitsUI user guide. 
    """
    # List of (Column labels, Column ID).
    columns = [ ('Name',    'name'),
                ('Age',     'age'),
                ('Address', 'address'),
                ('Spouse',  'spouse') ]

    row_label_name = 'surname'

    # Interfacing between the model and the view: make some of the cell 
    # attributes a property whose behavior is then controlled by the get 
    # (and optionally set methods). The cell is identified by its column 
    # ID (age, spouse).
    
    # Font fails with wx in OSX; see traitsui issue #13:
    # font                      = 'Courier 10'
    age_alignment             = Constant('right')
    MarriedPerson_age_image   = Property
    MarriedPerson_bg_color    = Color(0xE0E0FF)
    MarriedPerson_spouse_text = Property
    Person_spouse_text        = Constant('')

    def _get_MarriedPerson_age_image(self):
        if self.item.age < 18:
            return '@icons:red_ball'

        return None

    def _get_MarriedPerson_spouse_text(self):
        return self.item.partner.name

#-- Tabular Editor Definition --------------------------------------------------

# The tabular editor works in conjunction with an adapter class, derived from 
# TabularAdapter. 
tabular_editor = TabularEditor(
    adapter    = ReportAdapter(),
    operations = [ 'move', 'edit' ],
    # Row titles are not supported in WX:
    show_row_titles = ETSConfig.toolkit == 'qt4',
)

#-- Report Class Definition ----------------------------------------------------

class Report(HasTraits):

    people = List(Person)

    view = View(
        Group(
            Item('people', id = 'table', editor = tabular_editor),
            show_labels        = False
        ),
        title     = 'Tabular Editor Demo',
        id        = 'traitsui.demo.Applications.tabular_editor_demo',
        width     = 0.60,
        height    = 0.75,
        resizable = True
    )

#-- Generate 10,000 random single and married people ---------------------------

male_names = [ 'Michael', 'Edward', 'Timothy', 'James', 'George', 'Ralph',
    'David', 'Martin', 'Bryce', 'Richard', 'Eric', 'Travis', 'Robert', 'Bryan',
    'Alan', 'Harold', 'John', 'Stephen', 'Gael', 'Frederic', 'Eli', 'Scott',
    'Samuel', 'Alexander', 'Tobias', 'Sven', 'Peter', 'Albert', 'Thomas',
    'Horatio', 'Julius', 'Henry', 'Walter', 'Woodrow', 'Dylan', 'Elmer' ]

female_names = [ 'Leah', 'Jaya', 'Katrina', 'Vibha', 'Diane', 'Lisa', 'Jean',
    'Alice', 'Rebecca', 'Delia', 'Christine', 'Marie', 'Dorothy', 'Ellen',
    'Victoria', 'Elizabeth', 'Margaret', 'Joyce', 'Sally', 'Ethel', 'Esther',
    'Suzanne', 'Monica', 'Hortense', 'Samantha', 'Tabitha', 'Judith', 'Ariel',
    'Helen', 'Mary', 'Jane', 'Janet', 'Jennifer', 'Rita', 'Rena', 'Rianna' ]

all_names = male_names + female_names

male_name   = lambda: choice(male_names)
female_name = lambda: choice(female_names)
any_name    = lambda: choice(all_names)
age         = lambda: randint(15, 72)

family_name = lambda: choice([ 'Jones', 'Smith', 'Thompson', 'Hayes', 'Thomas', 'Boyle',
    "O'Reilly", 'Lebowski', 'Lennon', 'Starr', 'McCartney', 'Harrison',
    'Harrelson', 'Steinbeck', 'Rand', 'Hemingway', 'Zhivago', 'Clemens',
    'Heinlien', 'Farmer', 'Niven', 'Van Vogt', 'Sturbridge', 'Washington',
    'Adams', 'Bush', 'Kennedy', 'Ford', 'Lincoln', 'Jackson', 'Johnson',
    'Eisenhower', 'Truman', 'Roosevelt', 'Wilson', 'Coolidge', 'Mack', 'Moon',
    'Monroe', 'Springsteen', 'Rigby', "O'Neil", 'Philips', 'Clinton',
    'Clapton', 'Santana', 'Midler', 'Flack', 'Conner', 'Bond', 'Seinfeld',
    'Costanza', 'Kramer', 'Falk', 'Moore', 'Cramdon', 'Baird', 'Baer',
    'Spears', 'Simmons', 'Roberts', 'Michaels', 'Stuart', 'Montague',
    'Miller' ])

address = lambda: '%d %s %s' % (randint(11, 999), choice([ 'Spring',
    'Summer', 'Moonlight', 'Winding', 'Windy', 'Whispering', 'Falling',
    'Roaring', 'Hummingbird', 'Mockingbird', 'Bluebird', 'Robin', 'Babbling',
    'Cedar', 'Pine', 'Ash', 'Maple', 'Oak', 'Birch', 'Cherry', 'Blossom',
    'Rosewood', 'Apple', 'Peach', 'Blackberry', 'Strawberry', 'Starlight',
    'Wilderness', 'Dappled', 'Beaver', 'Acorn', 'Pecan', 'Pheasant', 'Owl' ]),
    choice([ 'Way', 'Lane', 'Boulevard', 'Street', 'Drive', 'Circle',
    'Avenue', 'Trail' ]))

people = [ Person(name    = '%s %s' % (any_name(), family_name()),
                   age     = age(),
                   address = address()) for i in range(5000) ]

marrieds = [ (MarriedPerson(name    = '%s %s' % (female_name(), last_name),
                              age     = age(),
                              address = address),
               MarriedPerson(name    = '%s %s' % (male_name(), last_name),
                              age     = age(),
                              address = address))
             for last_name, address in
                 [ (family_name(), address()) for i in range(2500) ] ]

for female, male in marrieds:
    female.partner = male
    male.partner   = female
    people.extend([ female, male ])

shuffle(people)

# Create the demo:
demo = Report(people = people)

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = Time_editor_demo
"""
A timer editor

Display or edit a time.

You can edit the time directly, or by using only the arrow keys (left & right
to navigate, up & down to change).

"""
import datetime

from traits.api import HasTraits, Time
from traitsui.api import View, Item, TimeEditor


class TimeEditorDemo(HasTraits):
    """ Demo class. """
    time = Time(datetime.time(12, 0, 0))
    view = View(Item('time', label='Simple Editor'),
                Item('time', label='Readonly Editor',
                     style='readonly',
                     # Show 24-hour mode instead of default 12 hour.
                     editor=TimeEditor(strftime='%H:%M:%S')
                     ),
                resizable=True)

    def _time_changed(self):
        """ Print each time the time value is changed in the editor. """
        print self.time


#-- Set Up The Demo ------------------------------------------------------------

demo = TimeEditorDemo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = converter
"""
Tiny application: convert length measurements from one unit system to another

Select the input and output units using the drop down combo-boxes in the
*Input:* and *Output:* sections respectively. Type the input quantity
to convert into the left most text box. The output value corresponding to the
current input value will automatically be updated in the *Output:*
section.

Use the *Undo* and *ReDo* buttons to undo and redo changes you
have made to any of the input fields.

Note that other than the 'output_amount' property implementation, the rest
of the code is simply declarative.
"""

# FIXME: Help is broken in QT

from traits.api import HasStrictTraits, Trait, CFloat, Property
from traitsui.api import View, VGroup, HGroup, Item

# Help text:
ViewHelp = """
This program converts length measurements from one unit system to another.

Select the input and output units using the drop down combo-boxes in the
*Input:* and *Output:* sections respectively. Type the input quantity
to convert into the left most text box. The output value corresponding to the
current input value will automatically be updated in the *Output:*
section.

Use the *Undo* and *ReDo* buttons to undo and redo changes you
have made to any of the input fields.
"""

# Units trait maps all units to centimeters:
Units = Trait( 'inches', { 'inches':      2.54,
                           'feet':        (12 * 2.54),
                           'yards':       (36 * 2.54),
                           'miles':       (5280 * 12 * 2.54),
                           'millimeters': 0.1,
                           'centimeters': 1.0,
                           'meters':      100.0,
                           'kilometers':  100000.0 } )

# Converter Class:
class Converter ( HasStrictTraits ):

    # Trait definitions:
    input_amount  = CFloat( 12.0,    desc = "the input quantity" )
    input_units   = Units( 'inches', desc = "the input quantity's units" )
    output_amount = Property( depends_on = [ 'input_amount', 'input_units',
                                             'output_units' ],
                              desc = "the output quantity" )
    output_units  = Units( 'feet',   desc = "the output quantity's units" )

    # User interface views:
    traits_view = View(
        VGroup(
            HGroup(
                Item( 'input_amount', springy = True ),
                Item( 'input_units', show_label = False ),
                label       = 'Input',
                show_border = True
            ),
            HGroup(
                Item( 'output_amount', style = 'readonly', springy = True ),
                Item( 'output_units',  show_label = False ),
                label       = 'Output',
                show_border = True
            ),
            help = ViewHelp
        ),
        title   = 'Units Converter',
        buttons = [ 'Undo', 'OK', 'Help' ]
    )

    # Property implementations
    def _get_output_amount ( self ):
        return ((self.input_amount * self.input_units_) / self.output_units_)

# Create the demo:
popup = Converter()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = Python_source_browser
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This demo shows a combination of the <b>DirectoryEditor</b>, the
<b>TabularEditor</b> and the <b>CodeEditor</b> used to create a simple Python
source browser:

 - Use the <b>DirectoryEditor</b> on the left to navigate to and select
   directories containing Python source files.
 - Use the <b>TabularEditor</b> on the top-right to view information about and
   to select Python source files in the currently selected directory.
 - View the currently selected Python source file's contents in the
   <b>CodeEditor</b> in the bottom-right.

As an extra <i>feature</i>, the <b>TabularEditor</b> also displays a:

 - Red ball if the file size > 64KB.
 - Blue ball if the file size > 16KB.
"""

import traits

from time \
    import localtime, strftime

from os \
    import listdir

from os.path \
    import getsize, getmtime, isfile, join, splitext, basename, dirname

from traits.api \
    import HasPrivateTraits, Str, Float, List, Directory, File, Code, \
           Instance, Property, Font, cached_property

from traitsui.api \
    import View, Item, HSplit, VSplit, TabularEditor

from traitsui.tabular_adapter \
    import TabularAdapter

from pyface.image_resource \
    import ImageResource

#-- Constants ------------------------------------------------------------------

# Necessary because of the dynamic way in which the demos are loaded:
search_path = [ join( dirname( traits.api.__file__ ),
                      '..', '..', 'examples', 'demo', 'Applications' ) ]

#-- FileInfo Class Definition --------------------------------------------------

class FileInfo ( HasPrivateTraits ):

    file_name = File
    name      = Property
    size      = Property
    time      = Property
    date      = Property

    @cached_property
    def _get_name ( self ):
        return basename( self.file_name )

    @cached_property
    def _get_size ( self ):
        return getsize( self.file_name )

    @cached_property
    def _get_time ( self ):
        return strftime( '%I:%M:%S %p',
                         localtime( getmtime( self.file_name ) ) )

    @cached_property
    def _get_date ( self ):
        return strftime( '%m/%d/%Y',
                         localtime( getmtime( self.file_name ) ) )

#-- Tabular Adapter Definition -------------------------------------------------

class FileInfoAdapter ( TabularAdapter ):

    columns = [ ( 'File Name', 'name' ),
                ( 'Size',      'size' ),
                ( '',          'big'  ),
                ( 'Time',      'time' ),
                ( 'Date',      'date' ) ]

    even_bg_color  = ( 201, 223, 241 )
    # FIXME: Font fails with wx in OSX; see traitsui issue #13:
    font           = Font('Courier 10')
    size_alignment = Str( 'right' )
    time_alignment = Str( 'right' )
    date_alignment = Str( 'right' )
    big_text       = Str
    big_width      = Float( 18 )
    big_image      = Property

    def _get_big_image ( self ):
        size = self.item.size
        if size > 65536:
            return 'red_ball'

        return ( None, 'blue_ball' )[ size > 16384 ]

#-- Tabular Editor Definition --------------------------------------------------

tabular_editor = TabularEditor(
    editable   = False,
    selected   = 'file_info',
    adapter    = FileInfoAdapter(),
    operations = [],
    images     = [ ImageResource( 'blue_ball', search_path = search_path ),
                   ImageResource( 'red_ball',  search_path = search_path ) ]
)

#-- PythonBrowser Class Definition ---------------------------------------------

class PythonBrowser ( HasPrivateTraits ):

    #-- Trait Definitions ------------------------------------------------------

    dir       = Directory
    files     = List( FileInfo )
    file_info = Instance( FileInfo )
    code      = Code

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HSplit(
            Item( 'dir', style = 'custom' ),
            VSplit(
                Item( 'files', editor = tabular_editor ),
                Item( 'code',  style = 'readonly' ),
                show_labels = False ),
            show_labels = False
        ),
        resizable = True,
        width     = 0.75,
        height    = 0.75
    )

    #-- Event Handlers ---------------------------------------------------------

    def _dir_changed ( self, dir ):
        self.files = [ FileInfo( file_name = join( dir, name ) )
                       for name in listdir( dir )
                       if ((splitext( name )[1] == '.py') and
                           isfile( join( dir, name ) )) ]

    def _file_info_changed ( self, file_info ):
        fh = None
        try:
            fh = open( file_info.file_name, 'rb' )
            self.code = fh.read()
        except:
            pass

        if fh is not None:
            fh.close()

# Create the demo:
demo = PythonBrowser( dir = dirname( traits.api.__file__ ) )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = demo
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   09/15/2005
#
#-------------------------------------------------------------------------------

""" Run the Traits UI demo.
"""

from traitsui.extras.demo import demo

demo()


########NEW FILE########
__FILENAME__ = dynamic_form_using_instances
"""
Dynamic restructuring a user interface using Instance editor and Handler

How to dynamically change the *structure* of a user interface (not merely which
components are visible), depending on the value of another trait.

This code sample shows a simple implementation of the dynamic
restructuring of a View on the basis of some trait attribute's
assigned value.

The demo class "Person" has attributes that apply to all instances
('first_name', 'last_name', 'age') and a single attribute 'misc'
referring to another object whose traits are specific to age
group (AdultSpec for adults 18 and over, ChildSpec for children
under 18).  The 'misc' attribute is re-assigned to a new instance
of the appropriate type when a change to 'age' crosses the range
boundary.

The multi-attribute instance assigned to 'misc' is edited by means
of a single InstanceEditor, which is displayed in the 'custom' style
so that the dynamic portion of the interface is displayed in a panel
rather than a separate window.

It is necessary to use a Handler because otherwise when the instance is
updated dynamically, Traits UI will not detect the change and the UI will not
be reconfigured. This is due to architectural limitations of the current
version of Traits UI.

Compare this to the simpler, but less powerful demo of *enabled_when*.
"""

from traits.api import HasTraits, Str, Range, Enum, Bool, Instance

from traitsui.api import Item, Group, View, Handler, Label


class Spec ( HasTraits ):
    """ An empty class from which all age-specific trait list classes are
        derived.
    """
    pass


class ChildSpec ( Spec ):
    """ Trait list for children (assigned to 'misc' for a Person when age < 18).
    """
    legal_guardian = Str
    school         = Str
    grade          = Range( 1, 12 )

    traits_view = View( 'legal_guardian',
                        'school',
                        'grade' )


class AdultSpec ( Spec ):
    """ Trait list for adults (assigned to 'misc' for a Person when age >= 18).
    """

    marital_status   = Enum( 'single', 'married', 'divorced', 'widowed' )
    registered_voter = Bool
    military_service = Bool

    traits_view = View( 'marital_status',
                        'registered_voter',
                        'military_service' )


class PersonHandler ( Handler ):
    """ Handler class to perform restructuring action when conditions are met.
    The restructuring consists of replacing a ChildSpec instance by an
    AdultSpec instance, or vice-versa. We would not need a handler to listen
    for a change in age, but we do need a Handler so that Traits UI will
    respond immediately to changes in the viewed Person, which require
    immediate restructuring of the UI.
    """

    def object_age_changed ( self, info ):
        if ((info.object.age >= 18) and
            (not isinstance( info.object.misc, AdultSpec ))):
            info.object.misc = AdultSpec()
        elif ((info.object.age < 18) and
              (not isinstance( info.object.misc, ChildSpec ))):
            info.object.misc = ChildSpec()


class Person ( HasTraits ):
    """ Demo class for demonstrating dynamic interface restructuring.
    """
    first_name = Str
    last_name  = Str
    age        = Range( 0, 120 )
    misc       = Instance( Spec )

    # Interface for attributes that are always visible in interface:
    gen_group = Group(
        Item( name = 'first_name' ),
        Item( name = 'last_name' ),
        Item( name = 'age'),
        label       = 'General Info',
        show_border = True
    )

    # Interface for attributes that depend on the value of 'age':
    spec_group = Group(
        Group(
            Item( name = 'misc', style = 'custom' ),
            show_labels = False
        ),
        label       = 'Additional Info',
        show_border = True
    )

    # A simple View is enough as long as the right handler is specified:
    view = View(
        Group( 
            gen_group, 
            '10',
            Label("Using Instances and a Handler:"),
            '10',
            spec_group 
            ),
        title     = 'Personal Information',
        buttons   = [ 'OK' ],
        resizable = True,
        width = 300,
        handler   = PersonHandler()
    )

# Create the demo:
demo = Person( first_name = "Samuel",
               last_name  = "Johnson",
               age        = 18,
               misc       = AdultSpec() )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = dynamic_range_editor
"""
Dynamic Range editor

Demonstrates how to dynamically modify the low and high limits of a Range Trait.

In the simple *Range Editor* example, we saw how to define a Range Trait, whose
values were restricted to a fixed range. Here, we show how the limits of the
range can be changed dynamically using the editor's *low_name* and *high_name*
attributes.

In this example, these range limits are set with sliders. In practice, the
limits would often be calculated from other user input or model data.

The demo is divided into three tabs:

 * A dynamic range using a simple slider.
 * A dynamic range using a large-range slider.
 * A dynamic range using a spinner.

In each section of the demo, the top-most 'value' trait can have its range
end points changed dynamically by modifying the 'low' and 'high' sliders
below it.

The large-range slider includes low-end and high-end arrows, which are used
to step the visible range through the full range, when the latter is too large
to be entirely visible.

This demo also illustrates how the value, label formatting and label
widths can also be specified if desired.
"""

# Imports:
from traits.api import HasPrivateTraits, Float, Range, Int

from traitsui.api import View, Group, Item, Label, RangeEditor

class DynamicRangeEditor ( HasPrivateTraits ):
    """ Defines an editor for dynamic ranges (i.e. ranges whose bounds can be
        changed at run time).
    """

    # The value with the dynamic range:
    value = Float

    # This determines the low end of the range:
    low = Range( 0.0, 10.0, 0.0 )

    # This determines the high end of the range:
    high = Range( 20.0, 100.0, 20.0 )

    # An integer value:
    int_value = Int

    # This determines the low end of the integer range:
    int_low = Range( 0, 10, 0 )

    # This determines the high end of the range:
    int_high = Range( 20, 100, 20 )

    # Traits view definitions:
    traits_view = View(

        # Dynamic simple slider demo:
        Group(
            Item( 'value',
                   editor = RangeEditor( low_name    = 'low',
                                         high_name   = 'high',
                                         format      = '%.1f',
                                         label_width = 28,
                                         mode        = 'auto' )
            ),
            '_',
            Item( 'low' ),
            Item( 'high' ),
            '_',
            Label( 'Move the Low and High sliders to change the range of '
                   'Value.' ),
            label = 'Simple Slider'
        ),

        # Dynamic large range slider demo:
        Group(
            Item( 'value',
                  editor = RangeEditor( low_name    = 'low',
                                        high_name   = 'high',
                                        format      = '%.1f',
                                        label_width = 28,
                                        mode        = 'xslider' )
            ),
            '_',
            Item( 'low' ),
            Item( 'high' ),
            '_',
            Label( 'Move the Low and High sliders to change the range of '
                   'Value.' ),
            label = 'Large Range Slider'
        ),

        # Dynamic spinner demo:
        Group(
            Item( 'int_value',
                  editor = RangeEditor( low         = 0,
                                        high        = 20,
                                        low_name    = 'int_low',
                                        high_name   = 'int_high',
                                        format      = '%d',
                                        is_float    = False,
                                        label_width = 28,
                                        mode        = 'spinner' )
            ),
            '_',
            Item( 'int_low' ),
            Item( 'int_high' ),
            '_',
            Label( 'Move the Low and High sliders to change the range of '
                   'Value.' ),
            label = 'Spinner'
        ),
        title     = 'Dynamic Range Editor Demonstration',
        buttons   = [ 'OK' ],
        resizable = True
    )


# Create the demo:
demo = DynamicRangeEditor()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = dynamic_selector
"""
Dynamic changing a selection list, using Handler

One way to dynamically change the list of values shown by an EnumEditor.

This example demonstrates several useful Traits UI concepts. It dynamically
changes the values which an EnumEditor presents to the user for selection. It
does this with a custom *Handler* which is assigned to the view, listens for
changes in a viewed trait, and changes the selection list accordingly.

Various implementations of dynamic data retrieval are possible. This example
shows how a Handler can interact with the traits in a view, separating model
logic from the view implementation.

Demo class *Address* has a simple set of attributes: *street_address*, *state*
and *city*. The values of *state* and *city* are to be chosen from enumerated
lists; however, the user does not want to see every city in the USA, but only
those for the chosen state.

Note that *city* is simply defined as a trait of type Str. By default, a Str
would be displayed using a simple TextEditor, but in this view we explicitly
specify that *city* should be displayed with an EnumEditor. The values that
appear in the GUI's enumerated list are determined by the *cities* attribute of
the view's handler, as specified in the EnumEditor's *name* parameter.
"""

from traits.api import HasTraits, Str, Enum, List
from traitsui.api import View, Item, Handler, EnumEditor

# Dictionary of defined states and cities.
cities = {
    'GA': ['Athens', 'Atlanta', 'Macon', 'Marietta', 'Savannah'],
    'TX': ['Austin', 'Amarillo', 'Dallas', 'Houston', 'San Antonio', 'Waco'],
    'OR': ['Albany', 'Eugene', 'Portland']
}


class AddressHandler(Handler):
    """
    Handler class to redefine the possible values of 'city' based on 'state'.
    This handler will be assigned to a view of an Address, and can listen and
    respond to changes in the viewed Address.
    """

    # Current list of available cities:
    cities = List(Str)

    def object_state_changed(self, info):
        """
        This method listens for a change in the *state* attribute of the
        object (Address) being viewed.

        When this listener method is called, *info.object* is a reference to
        the viewed object (Address).

        """
        # Change the list of available cities
        self.cities = cities[info.object.state]

        # As default value, use the first city in the list:
        info.object.city = self.cities[0]


class Address(HasTraits):
    """ Demo class for demonstrating dynamic redefinition of valid trait values.
    """

    street_address = Str
    state          = Enum(cities.keys()[0], cities.keys())
    city           = Str

    view = View(
        Item(name  = 'street_address'),
        Item(name  = 'state'),
        Item(name  = 'city',
             editor = EnumEditor(name = 'handler.cities'),
             ),
        title     = 'Address Information',
        buttons   = ['OK'],
        resizable = True,
        handler   = AddressHandler
    )


# Create the demo:
demo = Address(street_address="4743 Dudley Lane")

# Run the demo (if invoked from the command line):
if __name__== '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = enabled_when
"""
Dynamic enabling parts of a user interface using 'enabled_when'

How to dynamically enable or disable components of a Traits UI view, depending
on the value of another trait.

The demo class "Person" has a set of attributes that apply to all instances
('first_name', 'last_name', 'age'), a set of attributes that apply only to
children (Persons whose age is under 18), and a set of attributes that apply
only to adults. As a Person's age changes, only the age-appropriate attributes
will be enabled (available for editing).

**Detail:** The optional *enabled_when* attribute of an Item or Group is a
string containing a boolean expression (logical condition) indicating when this
Item or Group will be enabled. The boolean expression is evaluated for the
object being viewed, so that in this example, 'age' refers to the 'age'
attribute of the Person being viewed.

Compare this to very similar demo of *visible_when*.
"""

from traits.api import HasTraits, Str, Range, Bool, Enum
from traitsui.api import Item, Group, View, Label


class Person( HasTraits ):
    """ Example of enabling/disabling components of a user interface.
    """

    # General traits:
    first_name = Str
    last_name  = Str
    age        = Range(0, 120)

    # Traits for children only:
    legal_guardian = Str
    school         = Str
    grade          = Range(1, 12)

    # Traits for adults only:
    marital_status   = Enum('single', 'married', 'divorced', 'widowed')
    registered_voter = Bool(False)
    military_service = Bool(False)

    # Interface for attributes that are always visible in interface:
    gen_group = Group(
        Item(name = 'first_name'),
        Item(name = 'last_name'),
        Item(name = 'age'),
        label       = 'General Info',
        show_border = True
    )

    # Interface for attributes of Persons under 18:
    child_group = Group(
        Item(name = 'legal_guardian'),
        Item(name = 'school'),
        Item(name = 'grade'),
        label        = 'Additional Info for minors',
        show_border  = True,
        enabled_when = 'age < 18',
    )

    # Interface for attributes of Persons 18 and over:
    adult_group = Group(
        Item(name = 'marital_status'),
        Item(name = 'registered_voter'),
        Item(name = 'military_service'),
        '10',
        label        = 'Additional Info for adults',
        show_border  = True,
        enabled_when = 'age >= 18',
    )

    # A simple View is sufficient, since the Group definitions do all the work:
    view = View(
        Group(
            gen_group,
            '10',
            Label("Using 'enabled_when':"),
            '10',
            child_group,
            adult_group
        ),
        title     = 'Personal Information',
        resizable = True,
        buttons   = [ 'OK' ]
    )

# Create the demo:
demo = Person(
    first_name = "Samuel",
    last_name  = "Johnson",
    age        = 16
)

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = visible_when
"""
Dynamic restructuring a user interface using 'visible_when'

How to dynamically change which components of a Traits UI view are visible,
depending on the value of another trait.

The demo class "Person" has a set of attributes that apply to all instances
('first_name', 'last_name', 'age'), a set of attributes that apply only to
children (Persons whose age is under 18), and a set of attributes that apply
only to adults. As a Person's age changes, only the age-appropriate attributes
will be visible.

**Detail:** The optional *visible_when* attribute of an Item or Group is a
string containing a boolean expression (logical condition) indicating when this
Item or Group will be visible. The boolean expression is evaluated for the
object being viewed, so that in this example, 'age' refers to the 'age'
attribute of the Person being viewed.

Compare this to very similar demo of *enabled_when*, and the visually similar,
but structurally very different demo of *dynamic restructuring of a user 
interface using an Instance editor and a Handler*.
"""

from traits.api import HasTraits, Str, Range, Bool, Enum
from traitsui.api import Item, Group, View, Label

class Person(HasTraits):
    """ Example of restructuring a user interface by controlling visibility.
    """

    # General traits:
    first_name = Str
    last_name  = Str
    age        = Range(0, 120)

    # Traits for children only:
    legal_guardian = Str
    school         = Str
    grade          = Range(1, 12)

    # Traits for adults only:
    marital_status   = Enum('single', 'married', 'divorced', 'widowed')
    registered_voter = Bool(False)
    military_service = Bool(False)

    # Interface for attributes that are always visible in interface:
    gen_group = Group(
        Item(name = 'first_name'),
        Item(name = 'last_name'),
        Item(name = 'age'),
        label       = 'General Info',
        show_border = True
    )

    # Interface for attributes of Persons under 18:
    child_group = Group(
        Item(name = 'legal_guardian'),
        Item(name = 'school'),
        Item(name = 'grade'),
        label        = 'Additional Info for minors',
        show_border  = True,
        visible_when = 'age < 18',
    )

    # Interface for attributes of Persons 18 and over:
    adult_group = Group(
        Item(name = 'marital_status'),
        Item(name = 'registered_voter'),
        Item(name = 'military_service'),
        label        = 'Additional Info for adults',
        show_border  = True,
        visible_when = 'age >= 18',
    )

    # A simple View is sufficient, since the Group definitions do all the work:
    view = View(
        Group(
            gen_group,
            '10',
            Label("Using 'visible_when':"),
            '10',
            child_group,
            adult_group
        ),
        title     = 'Personal Information',
        resizable = True,
        buttons   = [ 'OK' ]
    )

# Create the demo:
demo = Person(
    first_name = "Samuel",
    last_name  = "Johnson",
    age        = 16
)

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = animated_GIF
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This demo shows you how to use animated GIF files in a traits user interface.
"""

from os.path import join, dirname, abspath

from traits.api import HasTraits, File, Bool

from traitsui.api import View, VGroup, HGroup, Item, EnumEditor

from traitsui.wx.animated_gif_editor import AnimatedGIFEditor


# Some sample animated GIF files:
base_path = join(dirname(__file__), 'images')

files = [
    abspath(join(base_path, 'logo_64x64.gif')),
    abspath(join(base_path, 'logo_48x48.gif')),
    abspath(join(base_path, 'logo_32x32.gif'))
]


class AnimatedGIFDemo(HasTraits):

    # The animated GIF file to display:
    gif_file = File(files[0])

    # Is the animation playing or not?
    playing = Bool(True)

    # The traits view:
    view = View(
        VGroup(
            HGroup(
                Item('gif_file',
                     editor=AnimatedGIFEditor(playing='playing'),
                     show_label=False),
                Item('playing'),
            ),
            '_',
            Item('gif_file',
                 label='GIF File',
                 editor=EnumEditor(values=files)
            )
        ),
        title='Animated GIF Demo',
        buttons=['OK']
    )

# Create the demo:
demo = AnimatedGIFDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = Image_editor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
A simple demonstration of how to use the ImageEditor to add a graphic element
to a Traits UI View.
"""

import traits

# Imports:
from os.path \
    import join, dirname

from traits.api \
    import HasTraits, Str

from traitsui.api \
    import View, VGroup, Item

from traitsui.api \
    import ImageEditor

from pyface.image_resource \
    import ImageResource

# Constants:

# Necessary because of the dynamic way in which the demos are loaded:
search_path = [ join( dirname( traits.api.__file__ ),
                      '..', '..', 'examples', 'demo', 'Extras' ) ]

# Define the demo class:
class Employee ( HasTraits ):

    # Define the traits:
    name  = Str
    dept  = Str
    email = Str

    # Define the view:
    view = View(
        VGroup(
            VGroup(
                Item( 'name',
                      show_label = False,
                      editor = ImageEditor(
                          image = ImageResource( 'info',
                                                 search_path = search_path) ) )
            ),
            VGroup(
                Item( 'name' ),
                Item( 'dept' ),
                Item( 'email' ),
                Item( 'picture',
                        editor = ImageEditor(
                            scale=True,
                            preserve_aspect_ratio=True,
                            allow_upscaling=True ),
                        springy = True ),
            )
        ),
        resizable=True
    )

# Create the demo:
popup = Employee( name  = 'William Murchison',
                  dept  = 'Receiving',
                  email = 'wmurchison@acme.com',
                  picture = ImageResource('e-logo-rev',
                                            search_path=search_path) )

# Run the demo (if invoked form the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = LED_display
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
This demo illustrates use of the LEDEditor for displaying numeric values
using a simulated LED display control.
"""

from threading \
    import Thread

from time \
    import sleep

from traits.api \
    import HasTraits, Instance, Int, Bool, Float

from traitsui.api \
    import View, Item, HGroup, Handler, UIInfo, spring

from traitsui.wx.extra.led_editor \
    import LEDEditor

# Handler class for the LEDDemo class view:
class LEDDemoHandler ( Handler ):

    # The UIInfo object associated with the UI:
    info = Instance( UIInfo )

    # Is the demo currently running:
    running = Bool( True )

    # Is the thread still alive?
    alive = Bool( True )

    def init ( self, info ):
        self.info = info
        Thread( target = self._update_counter ).start()

    def closed ( self, info, is_ok ):
        self.running = False
        while self.alive:
            sleep( .05 )

    def _update_counter ( self ):
        while self.running:
            self.info.object.counter1 += 1
            self.info.object.counter2 += .001
            sleep( .01 )
        self.alive = False

# The main demo class:
class LEDDemo ( HasTraits ):

    # A counter to display:
    counter1 = Int

    # A floating point value to display:
    counter2 = Float

    # The traits view:
    view = View(
        Item( 'counter1',
              label  = 'Left aligned',
              editor = LEDEditor( alignment = 'left' )
        ),
        Item( 'counter1',
              label  = 'Center aligned',
              editor = LEDEditor( alignment = 'center' )
        ),
        Item( 'counter1',
              label  = 'Right aligned',
              editor = LEDEditor()  # default = 'right' aligned
        ),
        Item( 'counter2',
              label  = 'Float value',
              editor = LEDEditor( format_str = '%.3f' )
        ),
        '_',
        HGroup(
            Item( 'counter1',
                  label  = 'Left',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor( alignment = 'left' )
            ),
            spring,
            Item( 'counter1',
                  label  = 'Center',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor( alignment = 'center' )
            ),
            spring,
            Item( 'counter1',
                  label  = 'Right',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor()  # default = 'right' aligned
            ),
            spring,
            Item( 'counter2',
                  label  = 'Float',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor( format_str = '%.3f' )
            )
        ),
        title   = 'LED Editor Demo',
        buttons = [ 'OK' ],
        handler = LEDDemoHandler
    )

# Create the demo:
demo = LEDDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = flash
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

""" Demo showing how to use the Windows specific Flash editor.
"""

# Imports:
from traitsui.wx.extra.windows.flash_editor \
    import FlashEditor

from traits.api \
    import Enum, HasTraits

from traitsui.api \
    import View, HGroup, Item

# The demo class:
class FlashDemo ( HasTraits ):

    # The Flash file to display:
    flash = Enum( 'http://www.ianag.com/arcade/swf/sudoku.swf',
                  'http://www.ianag.com/arcade/swf/f-336.swf',
                  'http://www.ianag.com/arcade/swf/f-3D-Reversi-1612.swf',
                  'http://www.ianag.com/arcade/swf/game_234.swf',
                  'http://www.ianag.com/arcade/swf/flashmanwm.swf',
                  'http://www.ianag.com/arcade/swf/2379_gyroball.swf',
                  'http://www.ianag.com/arcade/swf/f-1416.swf',
                  'http://www.ianag.com/arcade/swf/mah_jongg.swf',
                  'http://www.ianag.com/arcade/swf/game_e4fe4e55fedc2f502be627ee6df716c5.swf',
                  'http://www.ianag.com/arcade/swf/rhumb.swf' )

    # The view to display:
    view = View(
        HGroup(
            Item( 'flash', label = 'Pick a game to play' )
        ),
        '_',
        Item( 'flash',
              show_label = False,
              editor     = FlashEditor()
        )
    )

# Create the demo:
demo = FlashDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = internet_explorer
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

""" Demo showing how to use the Windows specific Internet Explorer editor.
"""

# Imports:
from traitsui.wx.extra.windows.ie_html_editor \
    import IEHTMLEditor

from traits.api \
    import Str, List, Button, HasTraits

from traitsui.api \
    import View, VGroup, HGroup, Item, TextEditor, ListEditor

# The web page class:
class WebPage ( HasTraits ):

    # The URL to display:
    url = Str( 'http://code.enthought.com' )

    # The page title:
    title = Str

    # The page status:
    status = Str

    # The browser navigation buttons:
    back    = Button( '<--' )
    forward = Button( '-->' )
    home    = Button( 'Home' )
    stop    = Button( 'Stop' )
    refresh = Button( 'Refresh' )
    search  = Button( 'Search' )

    # The view to display:
    view = View(
        HGroup( 'back', 'forward', 'home', 'stop', 'refresh', 'search', '_',
                Item( 'status', style = 'readonly' ),
                show_labels = False
        ),
        Item( 'url',
              show_label = False,
              editor     = IEHTMLEditor(
                               home    = 'home',    back   = 'back',
                               forward = 'forward', stop   = 'stop',
                               refresh = 'refresh', search = 'search',
                               title   = 'title',   status = 'status' )
        )
    )

# The demo class:
class InternetExplorerDemo ( HasTraits ):

    # A URL to display:
    url = Str( 'http://' )

    # The list of web pages being browsed:
    pages = List( WebPage )

    # The view to display:
    view = View(
        VGroup(
            Item( 'url',
                  label  = 'Location',
                  editor = TextEditor( auto_set = False, enter_set = True )
            )
        ),
        Item( 'pages',
              show_label = False,
              style      = 'custom',
              editor     = ListEditor( use_notebook = True,
                                       deletable    = True,
                                       dock_style   = 'tab',
                                       export       = 'DockWindowShell',
                                       page_name    = '.title' )
        )
    )

    # Event handlers:
    def _url_changed ( self, url ):
        self.pages.append( WebPage( url = url.strip() ) )

# Create the demo:
demo = InternetExplorerDemo(
           pages = [ WebPage(url='http://code.enthought.com/projects/traits/'),
                     WebPage(url='http://dmorrill.com') ] )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = BooleanEditor_demo
"""
Boolean editor (checkbox or text)

A Boolean (True/False) trait is displayed and edited as a checkbox, by default.

It can also be displayed as text 'True' / 'False', either editable or read-only.

This example also shows how to listen for a change in a trait, and take
action when its value changes.

It also demonstrates how to add vertical space and a Label (plain text which is
not editable.)
"""

from traits.api import HasTraits, Bool, Int
from traitsui.api import Item, Label, Group, View

class BooleanEditorDemo (HasTraits):
    """ Defines the main BooleanEditor demo class. """

    # a boolean trait to view:
    my_boolean_trait = Bool
    count_changes = Int(0)

    # When the trait's value changes, do something.
    # The listener method is named '_TraitName_changed', where
    # 'TraitName' is the name of the trait being monitored.
    def _my_boolean_trait_changed(self):
        self.count_changes += 1

    # Demo view
    traits_view = View(
        '10', # vertical space

        # The trait to be displayed / edited, in default format.
        # To edit a simple trait, this is the only line needed inside the View.
        # This is shorthand for Item('my_boolean_trait', style = 'simple')
        'my_boolean_trait',

        '10', # vertical space

        # We put this label in its own group so that it will be left justified.
        # Otherwise it will line up with other edit fields (indented):
        Group(
            Label('The same Boolean trait can also be displayed and edited as '
                  'text (True/False):')
            ),

        '10', # vertical space

        Item( 'my_boolean_trait', style = 'readonly', label = 'Read-only style' ),
        Item( 'my_boolean_trait', style = 'text',     label = 'Text style' ),

        '10',
        'count_changes',

        title     = 'Boolean trait',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo view (but do not yet display it):
demo = BooleanEditorDemo()

# Display and edit the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = ButtonEditor_demo
"""
Button editor

A Button trait is displayed as a button in a Traits UI view. When the button is
clicked, Traits UI will execute a method of your choice (a 'listener').

In this example, the listener just increments a click counter.
"""

from traits.api import HasTraits, Button, Int
from traitsui.api import View

class ButtonEditorDemo(HasTraits):
    """ Defines the main ButtonEditor demo class. """

    # Define a Button trait:
    my_button_trait = Button('Click Me')
    click_counter = Int

    # When the button is clicked, do something.
    # The listener method is named '_TraitName_fired', where
    # 'TraitName' is the name of the button trait.
    def _my_button_trait_fired(self):
        self.click_counter += 1

    # Demo view:
    traits_view = View(
        'my_button_trait',
        'click_counter',
        title     = 'ButtonEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )

# Create the demo:
demo = ButtonEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = CheckListEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a CheckListEditor demo plugin for the Traits UI demo program.

For each of three CheckListEditor column formations, this demo shows
each of the four styles of the CheckListEditor.
"""

# Imports:
from traits.api \
    import HasTraits, List

from traitsui.api \
    import Item, Group, View, CheckListEditor

# Define the demo class:
class CheckListEditorDemo ( HasTraits ):
    """ Define the main CheckListEditor demo class. """

    # Define a trait for each of three formations:
    checklist_4col = List( editor = CheckListEditor(
                           values = [ 'one', 'two', 'three', 'four' ],
                           cols   = 4 ) )

    checklist_2col = List( editor = CheckListEditor(
                           values = [ 'one', 'two', 'three', 'four' ],
                           cols   = 2 ) )

    checklist_1col = List( editor = CheckListEditor(
                           values = [ 'one', 'two', 'three', 'four' ],
                           cols   = 1 ) )

    # CheckListEditor display with four columns:
    cl_4_group = Group(
        Item( 'checklist_4col', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'checklist_4col', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'checklist_4col', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'checklist_4col', style = 'readonly', label = 'ReadOnly' ),
        label = '4-column'
    )

    # CheckListEditor display with two columns:
    cl_2_group = Group(
        Item( 'checklist_2col', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'checklist_2col', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'checklist_2col', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'checklist_2col', style = 'readonly', label = 'ReadOnly' ),
        label = '2-column'
    )

    # CheckListEditor display with one column:
    cl_1_group = Group(
        Item( 'checklist_1col', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'checklist_1col', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'checklist_1col', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'checklist_1col', style = 'readonly', label = 'ReadOnly' ),
        label = '1-column'
    )

    # The view includes one group per column formation.  These will be displayed
    # on separate tabbed panels.
    view1 = View(
        cl_4_group,
        cl_2_group,
        cl_1_group,
        title     = 'CheckListEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )

# Create the demo:
demo = CheckListEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = CheckListEditor_simple_demo
"""
Checklist editor for a List of strings

The checklist editor provides a simple way for the user to select multiple items
from a list of known strings.

This example demonstrates the checklist editor's two most useful styles:

  * 'custom' displays all the strings in columns next to checkboxes.
  * 'readonly' displays only the selected strings, as a Python list of strings.

We do *not* demonstrate two styles which are not as useful for this editor:

  * 'text' is like 'readonly' except editable. It will accept a list of strings
    or numbers or even expressions. This is useful for quick, non-production
    data entry, but it ignores the editor's list of valid 'values'.
  * 'simple' (the default) only lets you select one item at a time, from a
    drop-down widget.
"""

from traits.api import HasTraits, List
from traitsui.api import UItem, Group, View, CheckListEditor, Label

class CheckListEditorDemo ( HasTraits ):
    """ Define the main CheckListEditor simple demo class. """

    # Specify the strings to be displayed in the checklist:
    checklist = List( editor = CheckListEditor(
                           values = [ 'one', 'two', 'three', 'four',
                                      'five', 'six'],
                           cols   = 2 ) )

    # CheckListEditor display with two columns:
    checklist_group = Group(
        '10', # insert vertical space
        Label('The custom style lets you select items from a checklist:'),
        UItem( 'checklist', style = 'custom'),
        '10','_','10',  # a horizontal line with 10 empty pixels above and below
        Label('The readonly style shows you which items are selected, '
              'as a Python list:'),
        UItem( 'checklist', style = 'readonly'),
    )

    traits_view = View(
        checklist_group,
        title     = 'CheckListEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )

# Create the demo:
demo = CheckListEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = CodeEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a CodeEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the CodeEditor
"""

# Imports:
from traits.api \
    import HasTraits, Code

from traitsui.api \
    import Item, Group, View

# The main demo class:
class CodeEditorDemo ( HasTraits ):
    """ Defines the CodeEditor demo class.
    """

    # Define a trait to view:
    code_sample = Code( 'import sys\n\nsys.print("hello world!")' )

    # Display specification:
    code_group = Group(
        Item( 'code_sample', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'code_sample', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'code_sample', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'code_sample', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        code_group,
        title   = 'CodeEditor',
        buttons = [ 'OK' ] )


# Create the demo:
demo = CodeEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = ColorEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a ColorEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the ColorEditor
"""

# Imports:
from traits.api \
    import HasTraits, Color

from traitsui.api \
    import Item, Group, View

# Demo class definition:
class ColorEditorDemo ( HasTraits ):
    """ Defines the main ColorEditor demo. """

    # Define a Color trait to view:
    color_trait = Color

    # Items are used to define the demo display, one item per editor style:
    color_group = Group(
        Item( 'color_trait', style = 'simple',   label = 'Simple' ),
        Item(  '_' ),
        Item( 'color_trait', style = 'custom',   label = 'Custom' ),
        Item( '_'),
        Item( 'color_trait', style = 'text',     label = 'Text' ),
        Item( '_'),
        Item( 'color_trait', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view
    view1 = View(
        color_group,
        title     = 'ColorEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = ColorEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = CompoundEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a CompoundEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the CompoundEditor
"""

# Imports:
from traits.api \
    import HasTraits, Trait, Range

from traitsui.api \
    import Item, Group, View

# Define the demo class:
class CompoundEditorDemo ( HasTraits ):
    """ Defines the main CompoundEditor demo class.
    """

    # Define a compund trait to view:
    compound_trait = Trait( 1, Range( 1, 6 ), 'a', 'b', 'c', 'd', 'e', 'f' )


    # Display specification (one Item per editor style):
    comp_group = Group(
        Item( 'compound_trait', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'compound_trait', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'compound_trait', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'compound_trait', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        comp_group,
        title     = 'CompoundEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = CompoundEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = CSVListEditor_demo
"""
Demonstrate the CSVListEditor class.<br>
<br>
This editor allows the user to enter a *single* line of input text, containing
comma-separated values (or another separator may be specified). Your program
specifies an element Trait type of Int, Float, Str, Enum, or Range.
"""

from traits.api import HasTraits, List, Int, Float, Enum, Range, Str, Button, \
                            Property
from traitsui.api import View, Item, Label, Heading, VGroup, HGroup, UItem, \
                            spring, TextEditor, CSVListEditor


class Demo(HasTraits):

    list1 = List(Int)

    list2 = List(Float)

    list3 = List(Str, maxlen=3)

    list4 = List(Enum('red', 'green', 'blue', 2, 3))

    list5 = List(Range(low=0.0, high=10.0))

    # 'low' and 'high' are used to demonstrate lists containing dynamic ranges.
    low = Float(0.0)
    high = Float(1.0)

    list6 = List(Range(low=-1.0, high='high'))

    list7 = List(Range(low='low', high='high'))

    pop1 = Button("Pop from first list")

    sort1 = Button("Sort first list")

    # This will be str(self.list1).
    list1str = Property(Str, depends_on='list1')

    traits_view = \
        View(
            HGroup(
                # This VGroup forms the column of CSVListEditor examples.
                VGroup(
                    Item('list1', label="List(Int)",
                        editor=CSVListEditor(ignore_trailing_sep=False),
                        tooltip='options: ignore_trailing_sep=False'),
                    Item('list1', label="List(Int)", style='readonly',
                        editor=CSVListEditor()),
                    Item('list2', label="List(Float)",
                        editor=CSVListEditor(enter_set=True, auto_set=False),
                        tooltip='options: enter_set=True, auto_set=False'),
                    Item('list3', label="List(Str, maxlen=3)",
                        editor=CSVListEditor()),
                    Item('list4',
                         label="List(Enum('red', 'green', 'blue', 2, 3))",
                        editor=CSVListEditor(sep=None),
                        tooltip='options: sep=None'),
                    Item('list5', label="List(Range(low=0.0, high=10.0))",
                        editor=CSVListEditor()),
                    Item('list6', label="List(Range(low=-1.0, high='high'))",
                        editor=CSVListEditor()),
                    Item('list7', label="List(Range(low='low', high='high'))",
                        editor=CSVListEditor()),
                    springy=True,
                ),
                # This VGroup forms the right column; it will display the
                # Python str representation of the lists.
                VGroup(
                    UItem('list1str', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list1str', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list2', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list3', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list4', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list5', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list6', editor=TextEditor(),
                                        enabled_when='False', width=240),
                    UItem('list7', editor=TextEditor(),
                                        enabled_when='False', width=240),
                ),
            ),
            '_',
            HGroup('low', 'high', spring, UItem('pop1'), UItem('sort1')),
            Heading("Notes"),
            Label("Hover over a list to see which editor options are set, "
                  "if any."),
            Label("The editor of the first list, List(Int), uses "
                  "ignore_trailing_sep=False, so a trailing comma is "
                  "an error."),
            Label("The second list is a read-only view of the first list."),
            Label("The editor of the List(Float) example has enter_set=True "
                  "and auto_set=False; press Enter to validate."),
            Label("The List(Str) example will accept at most 3 elements."),
            Label("The editor of the List(Enum(...)) example uses sep=None, "
                  "i.e. whitespace acts as a separator."),
            Label("The last two List(Range(...)) examples take one or both "
                  "of their limits from the Low and High fields below."),
            width=720,
            title="CSVListEditor Demonstration",
        )

    def _list1_default(self):
        return [1, 4, 0, 10]

    def _get_list1str(self):
        return str(self.list1)

    def _pop1_fired(self):
        if len(self.list1) > 0:
            x = self.list1.pop()
            print x

    def _sort1_fired(self):
        self.list1.sort()


if __name__ == "__main__":
    demo = Demo()
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = DirectoryEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a DirectoryEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the DirectoryEditor
"""

# Imports:
from traits.api \
    import HasTraits, Directory

from traitsui.api \
    import Item, Group, View

# Define the demo class:
class DirectoryEditorDemo ( HasTraits ):
    """ Define the main DirectoryEditor demo class. """

    # Define a Directory trait to view:
    dir_name = Directory


    # Display specification (one Item per editor style):
    dir_group = Group(
        Item( 'dir_name', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'dir_name', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'dir_name', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'dir_name', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        dir_group,
        title     = 'DirectoryEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = DirectoryEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = EnumEditor_demo
"""
Enum editor

The Enum editor provides a simple way for the user to choose one item from
a list of known values (normally strings or numbers).

An Enum trait can take any value from a specified list of values. These values
are typically strings, integers, or floats, but can also be None or hashable
tuples.

An Enum can be displayed / edited in one of five styles:

  * 'simple' displays a drop-down list of allowed values
  * 'custom' by default, displays one or more columns of radio buttons (only
    one of which is selected at a time).
  * 'custom' in 'list' mode (see source code below), displays a list of all the
    allowed values at once.
  * 'readonly' displays the current value as non-editable text.
  * 'text' displays the current value as text. You can also edit this text,
    but your text must be in the list of allowed values.

"""

# Imports:
from traits.api import HasTraits, Enum

from traitsui.api import Item, Group, View, EnumEditor

class EnumEditorDemo ( HasTraits ):
    """ Defines the main EnumEditor demo class. """

    # Define an Enum trait to view.
    name_list = Enum( 'A-495', 'A-498', 'R-1226', 'TS-17', 'TS-18',
                      'Foo', 12345, (11,7), None )

    # Items are used to define the display, one Item per editor style:
    enum_group = Group(
        Item( 'name_list', style = 'simple',   label = 'Simple' ),
        Item( '_' ),

        # The custom style defaults to radio button mode:
        Item( 'name_list', style = 'custom',   label = 'Custom radio' ),
        Item( '_' ),

        # The custom style can also display in list mode, with extra work:
        Item( 'name_list', style = 'custom',   label = 'Custom list',
              editor= EnumEditor(values=name_list.values, mode='list') ),
        Item( '_' ),

        Item( 'name_list', style = 'readonly', label = 'ReadOnly' ),
        Item( '_' ),

        Item( 'name_list', style = 'text',     label = 'Text' )
    )

    # Demo view:
    traits_view = View(
        enum_group,
        title     = 'EnumEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = EnumEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = FileEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a FileEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the FileEditor
"""

# Imports:
from traits.api \
    import HasTraits, File

from traitsui.api \
    import Item, Group, View

# Define the demo class:
class FileEditorDemo ( HasTraits ):
    """ Defines the main FileEditor demo class. """

    # Define a File trait to view:
    file_name = File

    # Display specification (one Item per editor style):
    file_group = Group(
        Item( 'file_name', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'file_name', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'file_name', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'file_name', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        file_group,
        title     = 'FileEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = FileEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = File_Open
"""
This demonstrates one of the simplest cases of using the Traits file dialog to
select a file for opening (i.e. reading or editing).

The first question of course is why use the Traits file dialog at all, when the
standard OS file dialog is also available?

And the answer is that you can use either, but the advantages of using the
Traits file dialog are:

 - It supports history. That is, each time the user selects a file for opening,
   the file is added to a persistent history list, similar to many applications
   <i>Open recent...</i> function, but built directly into the file dialog.
   The amount of history remembered can be specified by the developer, with the
   default being the last 10 files opened.

 - It is resizable. Some standard OS file dialogs are not resizable, which can
   be very annoying to the user trying to select a file through a tiny
   peephole view of the file system. In addition, if the user resizes the
   dialog, the new size and position will be persisted, so that the file dialog
   will appear in the same location the next time the user wants to open a
   file.

 - There is a very nice synergy between the file system view and the history
   list. Quite often users shuttle between several <i>favorite</i> locations
   in the file system when opening files. The Traits file dialog automatically
   discovers these favorite locations just by the user opening files. When a
   user opens the file dialog, they can select a previously opened file from
   the history list, which then automatically causes the file system view to
   expand the selected file's containing folder, thus allowing them to select a
   different file in the same location. Since the history list is updated each
   time a user selects a file, It tends to automatically discover a <i>working
   set</i> of favorite directories just through simple use, without the user
   having to explicitly designate them as such.

 - It's customizable. The Traits file dialog accepts extension objects which
   can be used to display additional file information or even modify the
   selection behavior of the dialog. Several extensions are provided with
   Traits (and are demonstrated in some of the other examples), and you are
   free to write your own by implementing a very simple interface.

 - The history and user settings are customizable per application. Just by
   setting a unique id in the file dialog request, you can specify that the
   history and window size and position information are specific to your
   application. If you have file dialog extensions added, the user can
   reorder, resize and reconfigure the overall file dialog layout, including
   your extensions, and have their custom settings restored each time they use
   the file dialog. If you do not specify a unique id, then the history and
   user settings default to the system-wide settings for the file dialog. It's
   your choice.

 - It's easy to use. That's what this particular example is all about. So take
   a look at the source code for this example to see how easy it is...
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, File, Button

from traitsui.api \
    import View, HGroup, Item

from traitsui.file_dialog  \
    import open_file

#-- FileDialogDemo Class -------------------------------------------------------

class FileDialogDemo ( HasTraits ):

    # The name of the selected file:
    file_name = File

    # The button used to display the file dialog:
    open = Button( 'Open...' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HGroup(
            Item( 'open', show_label = False ),
            '_',
            Item( 'file_name', style = 'readonly', springy = True )
        ),
        width = 0.5
    )

    #-- Traits Event Handlers --------------------------------------------------

    def _open_changed ( self ):
        """ Handles the user clicking the 'Open...' button.
        """
        file_name = open_file()
        if file_name != '':
            self.file_name = file_name

# Create the demo:
demo = FileDialogDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = File_Open_with_Custom_Extension
"""
This demonstrates using the Traits file dialog with a custom written file
dialog extension, in this case an extension called <b>LineCountInfo</b>, which
displays the number of text lines in the currently selected file.

For more information about why you would want to use the Traits file dialog
over the standard OS file dialog, select the <b>File Open</b> demo.
"""

#-- Imports --------------------------------------------------------------------

from os.path \
    import getsize

from traits.api \
    import HasTraits, File, Button, Property, cached_property

from traitsui.api \
    import View, VGroup, HGroup, Item

from traitsui.file_dialog  \
    import open_file, MFileDialogModel

from traitsui.helper \
    import commatize

#-- LineCountInfo Class --------------------------------------------------------

class LineCountInfo ( MFileDialogModel ):
    """ Defines a file dialog extension that displays the number of text lines
        in the currently selected file.
    """

    # The number of text lines in the currently selected file:
    lines = Property( depends_on = 'file_name' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            Item( 'lines', style = 'readonly' ),
            label       = 'Line Count Info',
            show_border = True
        )
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_lines ( self ):
        try:
            if getsize( self.file_name ) > 10000000:
                return 'File too big...'

            fh   = file( self.file_name, 'rb' )
            data = fh.read()
            fh.close()
        except:
            return ''

        if (data.find( '\x00' ) >= 0) or (data.find( '\xFF' ) >= 0):
            return 'File contains binary data...'

        return ('%s lines' % commatize( len( data.splitlines() ) ))

#-- FileDialogDemo Class -------------------------------------------------------

# Demo specific file dialig id:
demo_id = ('traitsui.demo.standard_editors.file_dialog.'
           'line_count_info')

class FileDialogDemo ( HasTraits ):

    # The name of the selected file:
    file_name = File

    # The button used to display the file dialog:
    open = Button( 'Open...' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HGroup(
            Item( 'open', show_label = False ),
            '_',
            Item( 'file_name', style = 'readonly', springy = True )
        ),
        width = 0.5
    )

    #-- Traits Event Handlers --------------------------------------------------

    def _open_changed ( self ):
        """ Handles the user clicking the 'Open...' button.
        """
        file_name = open_file( extensions = LineCountInfo(), id = demo_id )
        if file_name != '':
            self.file_name = file_name

# Create the demo:
demo = FileDialogDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = File_Open_with_FileInfo_Extension
"""
This demonstrates using the Traits file dialog with a file dialog extension,
in this case, the <b>FileInfo</b> extension, which displays information about
the currently selected file, such as:

 - File size.
 - Date and time last accessed.
 - Date and time last modified.
 - Date and time last created.

For more information about why you would want to use the Traits file dialog
over the standard OS file dialog, select the <b>File Open</b> demo. For a
demonstration of writing a custom file dialog extension, select the
<b>File Open with Custom Extension</b> demo.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, File, Button

from traitsui.api \
    import View, HGroup, Item

from traitsui.file_dialog  \
    import open_file, FileInfo

#-- FileDialogDemo Class -------------------------------------------------------

# Demo specific file dialig id:
demo_id = 'traitsui.demo.standard_editors.file_dialog.file_info'

class FileDialogDemo ( HasTraits ):

    # The name of the selected file:
    file_name = File

    # The button used to display the file dialog:
    open = Button( 'Open...' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HGroup(
            Item( 'open', show_label = False ),
            '_',
            Item( 'file_name', style = 'readonly', springy = True )
        ),
        width = 0.5
    )

    #-- Traits Event Handlers --------------------------------------------------

    def _open_changed ( self ):
        """ Handles the user clicking the 'Open...' button.
        """
        file_name = open_file( extensions = FileInfo(), id = demo_id )
        if file_name != '':
            self.file_name = file_name

# Create the demo:
demo = FileDialogDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = File_Open_with_ImageInfo_Extension
"""
This demonstrates using the Traits file dialog with a file dialog extension,
in this case, the <b>ImageInfo</b> extension, which displays (if possible) the
contents, width and height information for the currently selected image file
so that the user can quickly verify they are opening the correct file before
leaving the file dialog.

For more information about why you would want to use the Traits file dialog
over the standard OS file dialog, select the <b>File Open</b> demo. For a
demonstration of writing a custom file dialog extension, select the
<b>File Open with Custom Extension</b> demo.

This example also shows setting a file name filter which only allows common
image file formats (i.e. *.png, *.gif, *.jpg, *.jpeg) files to be viewed and
selected.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, File, Button

from traitsui.api \
    import View, HGroup, Item

from traitsui.file_dialog  \
    import open_file, ImageInfo

#-- FileDialogDemo Class -------------------------------------------------------

# Demo specific file dialig id:
demo_id = 'traitsui.demo.standard_editors.file_dialog.image_info'

# The image filters description:
filters = [
    'PNG file (*.png)|*.png',
    'GIF file (*.gif)|*.gif',
    'JPG file (*.jpg)|*.jpg',
    'JPEG file (*.jpeg)|*.jpeg'
]

class FileDialogDemo ( HasTraits ):

    # The name of the selected file:
    file_name = File

    # The button used to display the file dialog:
    open = Button( 'Open...' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HGroup(
            Item( 'open', show_label = False ),
            '_',
            Item( 'file_name', style = 'readonly', springy = True )
        ),
        width = 0.5
    )

    #-- Traits Event Handlers --------------------------------------------------

    def _open_changed ( self ):
        """ Handles the user clicking the 'Open...' button.
        """
        file_name = open_file( extensions = ImageInfo(),
                               filter     = filters,
                               id         = demo_id )
        if file_name != '':
            self.file_name = file_name

# Create the demo:
demo = FileDialogDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = File_Open_with_Multiple_Extensions
"""
This demonstrates using the Traits file dialog with multiple file dialog
extensions, in this case, the <b>FileInfo</b>, <b>TextInfo</b> and
<b>ImageInfo</b> extensions.

For more information about why you would want to use the Traits file dialog
over the standard OS file dialog, select the <b>File Open</b> demo. For a
demonstration of writing a custom file dialog extension, select the
<b>File Open with Custom Extension</b> demo.

Suggestion: Try resizing the dialog and dragging the various file dialog
extensions around to create a better arrangement than the rather cramped
default vertical arrangement. Close the dialog, then re-open it to see that
your new arrangement has been correctly restored. Try a different file dialog
demo to verify that the customizations are not affected by any of the other
demos because this demo specifies a custom id when invoking the file dialog.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, File, Button

from traitsui.api \
    import View, HGroup, Item

from traitsui.file_dialog  \
    import open_file, FileInfo, TextInfo, ImageInfo

#-- FileDialogDemo Class -------------------------------------------------------

# Demo specific file dialig id:
demo_id = 'traitsui.demo.standard_editors.file_dialog.multiple_info'

# The list of file dialog extensions to use:
extensions = [ FileInfo(), TextInfo(), ImageInfo() ]

class FileDialogDemo ( HasTraits ):

    # The name of the selected file:
    file_name = File

    # The button used to display the file dialog:
    open = Button( 'Open...' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HGroup(
            Item( 'open', show_label = False ),
            '_',
            Item( 'file_name', style = 'readonly', springy = True )
        ),
        width = 0.5
    )

    #-- Traits Event Handlers --------------------------------------------------

    def _open_changed ( self ):
        """ Handles the user clicking the 'Open...' button.
        """
        file_name = open_file( extensions = extensions, id = demo_id )
        if file_name != '':
            self.file_name = file_name

# Create the demo:
demo = FileDialogDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = File_Open_with_TextInfo_Extension
"""
This demonstrates using the Traits file dialog with a file dialog extension,
in this case, the <b>TextInfo</b> extension, which displays (if possible) the
contents of the currently selected file in a read-only text editor so the user
can quickly verify they are opening the correct file before leaving the file
dialog.

For more information about why you would want to use the Traits file dialog
over the standard OS file dialog, select the <b>File Open</b> demo. For a
demonstration of writing a custom file dialog extension, select the
<b>File Open with Custom Extension</b> demo.

This example also shows setting a file name filter which only allows Python
source (i.e. *.py) files to be viewed and selected.
"""

#-- Imports --------------------------------------------------------------------

from traits.api \
    import HasTraits, File, Button

from traitsui.api \
    import View, HGroup, Item

from traitsui.file_dialog  \
    import open_file, TextInfo

#-- FileDialogDemo Class -------------------------------------------------------

# Demo specific file dialig id:
demo_id = 'traitsui.demo.standard_editors.file_dialog.text_info'

class FileDialogDemo ( HasTraits ):

    # The name of the selected file:
    file_name = File

    # The button used to display the file dialog:
    open = Button( 'Open...' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HGroup(
            Item( 'open', show_label = False ),
            '_',
            Item( 'file_name', style = 'readonly', springy = True )
        ),
        width = 0.5
    )

    #-- Traits Event Handlers --------------------------------------------------

    def _open_changed ( self ):
        """ Handles the user clicking the 'Open...' button.
        """
        file_name = open_file( extensions = TextInfo(),
                               filter     = 'Python file (*.py)|*.py',
                               id         = demo_id )
        if file_name != '':
            self.file_name = file_name

# Create the demo:
demo = FileDialogDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = FontEditor_demo
"""
Font editor

A Font editor in a Traits UI allows the user to select a font from the operating
system.

Typically, you then pass the Font trait to another UI editor, which uses it to
display text. You can also read the Font trait as a string, or access its
individual attributes (note that these attributes are specific to the UI toolkit
-- QT or WX.)

The default 'simple' Font editor style is usually the most useful and powerful
style - it pops up a font selection dialog which is specific to the OS and
toolkit.

This example also displays some other less common style choices.
"""

# Imports:
from traits.api import HasTraits, Font

from traitsui.api import Item, Group, View

class FontEditorDemo ( HasTraits ):
    """ Defines the main FontEditor demo class. """

    # Define a Font trait to view:
    my_font_trait = Font

    # Display specification (one Item per editor style):
    font_group = Group(
        Item( 'my_font_trait', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'my_font_trait', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'my_font_trait', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'my_font_trait', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        font_group,
        title     = 'FontEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = FontEditorDemo()


# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = HTMLEditor_demo
"""
HTML editor

The HTML editor displays simple formatted HTML text in a Traits UI view.

If the text is held in an HTML trait, then the HTMLEditor is the default. If
the text is held in a Str trait, then you may specify the HTMLEditor explicitly
if you wish to display it as HTML.

The supported subset of HTML tags and features depends on the UI toolkit (WX or
QT). This editor does not support style sheets. It does not support WYSIWYG
editing of the text, though the unformatted text can be edited in a plain text
editor.

The HTML editor can optionally be configured to do simple formatting of lists
and paragraphs without HTML tags, by setting the editor's 'format_text'
parameter True.

"""

from traits.api import HasTraits, HTML
from traitsui.api import UItem, View, HTMLEditor

# Sample text to display as HTML: header, plus module docstring, plus
# some lists. The docstring and lists will be auto-formatted (format_text=True).
sample_text = ("""
<html><body><h1>HTMLEditor example</h1>

""" +
__doc__ +
"""
<i>Here are some lists formatted in this way:</i>

Numbered list:
  * first
  * second
  * third

Bulleted list:
  - eat
  - drink
  - be merry
""")


class HTMLEditorDemo ( HasTraits ):
    """ Defines the main HTMLEditor demo class. """

    # Define a HTML trait to view
    my_html_trait = HTML(sample_text)

    # Demo view
    traits_view = View(
        UItem('my_html_trait',
              # we specify the editor explicitly in order to set format_text:
              editor=HTMLEditor(format_text=True)),
                title     = 'HTMLEditor',
                buttons   = ['OK'],
                width     = 800,
                height    = 600,
                resizable = True)

# Create the demo:
demo = HTMLEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = ImageEnumEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of an ImageEnumEditor demo plugin for the Traits UI demo program.

This demo shows each of the four styles of the ImageEnumEditor.
"""

# Imports:
from traits.api \
    import HasTraits, Str, Trait

from traitsui.api \
    import Item, Group, View, ImageEnumEditor

# This list of image names (with the standard suffix "_origin") is used to
# construct an image enumeration trait to demonstrate the ImageEnumEditor:
image_list = [ 'top left', 'top right', 'bottom left', 'bottom right' ]

class Dummy ( HasTraits ):
    """ Dummy class for ImageEnumEditor
    """
    x = Str

    view = View()

class ImageEnumEditorDemo ( HasTraits ):
    """ Defines the ImageEnumEditor demo class.
    """

    # Define a trait to view:
    image_from_list = Trait( editor = ImageEnumEditor( values = image_list,
                                                       prefix = '@icons:',
                                                       suffix = '_origin',
                                                       cols   = 4,
                                                       klass  = Dummy ),
                             *image_list )

    # Items are used to define the demo display, one Item per editor style:
    img_group = Group(
        Item( 'image_from_list', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'image_from_list', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'image_from_list', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'image_from_list', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        img_group,
        title     = 'ImageEnumEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )

# Create the demo:
demo = ImageEnumEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = InstanceEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of an InstanceEditor demo plugin for the Traits UI demo program.

This demo shows each of the four styles of the InstanceEditor

Fixme: This version of the demo only shows the old-style InstanceEditor
capabilities.
"""

# Imports:
from traits.api \
    import HasTraits, Str, Range, Bool, Instance

from traitsui.api \
    import Item, Group, View

#-------------------------------------------------------------------------------
#  Classes:
#-------------------------------------------------------------------------------

class SampleClass ( HasTraits ):
    """ This Sample class is used to demonstrate the InstanceEditor demo.
    """

    # The actual attributes don't matter here; we just need an assortment
    # to demonstrate the InstanceEditor's capabilities.:
    name             = Str
    occupation       = Str
    age              = Range( 21, 65 )
    registered_voter = Bool

    # The InstanceEditor uses whatever view is defined for the class.  The
    # default view lists the fields alphabetically, so it's best to define one
    # explicitly:
    view = View( 'name', 'occupation', 'age', 'registered_voter' )

class InstanceEditorDemo ( HasTraits ):
    """ This class specifies the details of the InstanceEditor demo.
    """

    # Create an Instance trait to view:
    sample_instance = Instance( SampleClass, () )


    # Items are used to define the demo display, one item per editor style:
    inst_group = Group(
        Item( 'sample_instance', style = 'simple',  label = 'Simple' ),
        Item( '_' ),
        Item( 'sample_instance', style = 'custom',  label = 'Custom' ),
        Item( '_' ),
        Item( 'sample_instance', style = 'text',    label = 'Text' ),
        Item( '_' ),
        Item( 'sample_instance', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo View:
    view = View(
        inst_group,
        title   = 'InstanceEditor',
        buttons = [ 'OK' ],
        resizable = True
    )

# Create the demo:
demo = InstanceEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = ListEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implemention of a ListEditor demo plugin for Traits UI demo program

This demo shows each of the four styles of ListEditor
"""

# Imports:
from traits.api \
    import HasTraits, List, Str

from traitsui.api \
    import Item, Group, View

# Define the demo class:
class ListEditorDemo ( HasTraits ):
    """ Defines the main ListEditor demo class. """

    # Define a List trait to display:
    play_list = List( Str, [ "The Merchant of Venice", "Hamlet", "MacBeth" ] )

    # Items are used to define display, one per editor style:
    list_group = Group(
        Item( 'play_list', style = 'simple',   label = 'Simple', height = 75 ),
        Item( '_' ),
        Item( 'play_list', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'play_list', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'play_list', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view:
    view = View(
        list_group,
        title     = 'ListEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )

# Create the demo:
demo = ListEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = BooleanEditor_demo
"""
Implementation of a BooleanEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the BooleanEditor
"""


#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

from traits.api import HasTraits, Bool
from traitsui.api import Item, Group, View


class BooleanEditorDemo ( HasTraits ):
    """ This class specifies the details of the BooleanEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    boolean_trait    = Bool

    # Items are used to define the demo display - one Item per
    # editor style
    bool_group = Group( Item('boolean_trait', style='simple', label='Simple'),
                        Item('_'),
                        Item('boolean_trait', style='custom', label='Custom'),
                        Item('_'),
                        Item('boolean_trait', style='text', label='Text'),
                        Item('_'),
                        Item('boolean_trait', style='readonly', label='ReadOnly'))

    # Demo view
    view1 = View( bool_group,
                  title = 'BooleanEditor',
                  buttons = ['OK'],
                  width = 300 )


# Hook for 'demo.py'
popup = BooleanEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = ButtonEditor_demo
"""
Implementation of a ButtonEditor demo plugin for Traits UI demo program.

This demo shows each of the two styles of the ButtonEditor.
(As of this writing, they are identical.)
"""

from traits.api import HasTraits, Button
from traitsui.api import Item, View, Group
from traitsui.message import message


#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class ButtonEditorDemo ( HasTraits ):
    """ This class specifies the details of the ButtonEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    fire_event = Button('Click Me')


    def _fire_event_fired():
        message("Button clicked!")



    # ButtonEditor display
    # (Note that Text and ReadOnly versions are not applicable)
    event_group = Group( Item('fire_event', style='simple', label='Simple'),
                         Item('_'),
                         Item('fire_event', style='custom', label='Custom'),
                         Item('_'),
                         Item(label='[text style unavailable]'),
                         Item('_'),
                         Item(label='[read only style unavailable]'))

    # Demo view
    view1 = View( event_group,
                  title = 'ButtonEditor',
                  buttons = ['OK'],
                  width = 250 )


# Create the demo:
popup = ButtonEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = CheckListEditor_demo
"""
Implementation of a CheckListEditor demo plugin for the Traits UI demo program.

For each of three CheckListEditor column formations, this demo shows
each of the four styles of the CheckListEditor.
"""

from traits.api import HasTraits, List
from traitsui.api import Item, Group, View, CheckListEditor

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class CheckListEditorDemo ( HasTraits ):
    """ This class specifies the details of the CheckListEditor demo.
    """

    # Define a trait for each of three formations
    checklist_4col = List( editor = CheckListEditor(
                           values = [ 'one', 'two', 'three', 'four' ],
                           cols   = 4 ) )

    checklist_2col = List( editor = CheckListEditor(
                           values=[ 'one', 'two', 'three', 'four' ],
                           cols = 2 ) )

    checklist_1col = List( editor = CheckListEditor(
                           values=[ 'one', 'two', 'three', 'four' ],
                           cols = 1 ) )

    # CheckListEditor display with four columns
    cl_4_group = Group( Item('checklist_4col', style='simple', label='Simple'),
                        Item('_'),
                        Item('checklist_4col', style='custom', label='Custom'),
                        Item('_'),
                        Item('checklist_4col', style='text', label='Text'),
                        Item('_'),
                        Item('checklist_4col', style='readonly', label='ReadOnly'),
                        label='4-column' )

    # CheckListEditor display with two columns
    cl_2_group = Group( Item('checklist_2col', style='simple', label='Simple'),
                        Item('_'),
                        Item('checklist_2col', style='custom', label='Custom'),
                        Item('_'),
                        Item('checklist_2col', style='text', label='Text'),
                        Item('_'),
                        Item('checklist_2col', style='readonly', label='ReadOnly'),
                        label='2-column' )

    # CheckListEditor display with one column
    cl_1_group = Group( Item('checklist_1col', style='simple', label='Simple'),
                        Item('_'),
                        Item('checklist_1col', style='custom', label='Custom'),
                        Item('_'),
                        Item('checklist_1col', style='text', label='Text'),
                        Item('_'),
                        Item('checklist_1col', style='readonly', label='ReadOnly'),
                        label='1-column' )


    # The view includes one group per column formation.  These will be displayed
    # on separate tabbed panels.
    view1 = View( cl_4_group,
                  cl_2_group,
                  cl_1_group,
                  title = 'CheckListEditor',
                  buttons = ['OK'])


# Create the demo:
popup = CheckListEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = CodeEditor_demo
"""
Implementation of a CodeEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the CodeEditor.
"""

from traits.api import HasTraits, Code
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class CodeEditorDemo ( HasTraits ):
    """ This class specifies the details of the CodeEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    code_sample = Code( 'import sys\n\nsys.print("hello world!")' )

    # Display specification
    code_group = Group( Item('code_sample', style='simple', label='Simple'),
                        Item('_'),
                        Item('code_sample', style='custom', label='Custom'),
                        Item('_'),
                        Item('code_sample', style='text', label='Text'),
                        Item('_'),
                        Item('code_sample', style='readonly', label='ReadOnly'))

    # Demo view
    view1 = View( code_group,
                  title = 'CodeEditor',
                  width = 350,
                  buttons = ['OK'] )


# Create the demo:
popup = CodeEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = ColorEditor_demo
"""
Implementation of a ColorEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the ColorEditor.
"""

from traits.api import HasTraits, Color
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class ColorEditorDemo ( HasTraits ):
    """ This class specifies the details of the ColorEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    color_trait = Color

    # Items are used to define the demo display - one item per
    # editor style
    color_group = Group( Item('color_trait', style='simple', label='Simple'),
                         Item('_'),
                         Item('color_trait', style='custom', label='Custom'),
                         Item('_'),
                         Item('color_trait', style='text', label='Text'),
                         Item('_'),
                         Item('color_trait', style='readonly', label='ReadOnly'))


    # Demo view
    view1 = View( color_group,
                  title = 'ColorEditor',
                  buttons = ['OK'] )


# Create the demo:
popup = ColorEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = CompoundEditor_demo
"""
Implementation of a CompoundEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the CompoundEditor.
"""

from traits.api import HasTraits, Trait, Range
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class CompoundEditorDemo ( HasTraits ):
    """ This class specifies the details of the CompoundEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    compound_trait = Trait( 1, Range( 1, 6 ), 'a', 'b', 'c', 'd', 'e', 'f' )


    # Display specification (one Item per editor style)
    comp_group = Group( Item('compound_trait', style = 'simple', label = 'Simple'),
                        Item('_'),
                        Item('compound_trait', style = 'custom', label = 'Custom'),
                        Item('_'),
                        Item('compound_trait', style = 'text', label = 'Text'),
                        Item('_'),
                        Item('compound_trait',
                             style = 'readonly',
                             label = 'ReadOnly'))

    # Demo view
    view1 = View( comp_group,
                  title = 'CompoundEditor',
                  buttons = ['OK'] )


# Create the demo:
popup = CompoundEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = DirectoryEditor_demo
"""
Implementation of a DirectoryEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the DirectoryEditor.
"""

from traits.api import HasTraits, Directory
from traitsui.api import Item, Group, View


#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class DirectoryEditorDemo ( HasTraits ):
    """ This class specifies the details of the DirectoryEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    dir_name = Directory


    # Display specification (one Item per editor style)
    dir_group = Group( Item('dir_name', style = 'simple', label = 'Simple'),
                       Item('_'),
                       Item('dir_name', style = 'custom', label = 'Custom'),
                       Item('_'),
                       Item('dir_name', style = 'text', label = 'Text'),
                       Item('_'),
                       Item('dir_name', style = 'readonly', label = 'ReadOnly'))

    # Demo view
    view1 = View( dir_group,
                  title = 'DirectoryEditor',
                  width = 400,
                  buttons = ['OK'] )


# Create the demo:
popup = DirectoryEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = EnumEditor_demo
"""
Implementation of an EnumEditor demo for Traits UI

This demo shows each of the four styles of the EnumEditor.

Fixme: This only shows the capabilities of the old-style EnumEditor
"""

from traits.api import HasTraits, Enum
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class EnumEditorDemo ( HasTraits ):
    """ This class specifies the details of the BooleanEditor demo.
    """

    # The Trait to be displayed in the editor
    name_list = Enum('A-495', 'A-498', 'R-1226', 'TS-17', 'TS-18')

    # Items are used to define the display; one Item per editor style.
    enum_group = Group( Item('name_list', style='simple', label='Simple'),
                        Item('_'),
                        Item('name_list', style='custom', label='Custom'),
                        Item('_'),
                        Item('name_list', style='text', label='Text'),
                        Item('_'),
                        Item('name_list', style='readonly', label='ReadOnly'))

    # Demo view
    view1 = View( enum_group,
                  title = 'EnumEditor',
                  buttons = ['OK'] )


# Create the demo:
popup = EnumEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = FileEditor_demo
"""
Implementation of a FileEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the FileEditor.
"""

from traits.api import HasTraits, File
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class FileEditorDemo ( HasTraits ):
    """ This class specifies the details of the FileEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    file_name = File


    # Display specification (one Item per editor style)
    file_group = Group( Item('file_name', style = 'simple', label = 'Simple'),
                        Item('_'),
                        Item('file_name', style = 'custom', label = 'Custom'),
                        Item('_'),
                        Item('file_name', style = 'text', label = 'Text'),
                        Item('_'),
                        Item('file_name', style = 'readonly', label = 'ReadOnly'))

    # Demo view
    view1 = View( file_group,
                  title = 'FileEditor',
                  width = 400,
                  buttons = ['OK'] )


# Create the demo:
popup = FileEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = FontEditor_demo
"""
Implementation of a FontEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the FontEditor.
"""

from traits.api import HasTraits, Font
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class FontEditorDemo ( HasTraits ):
    """ This class specifies the details of the FontEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    font_trait = Font

    # Display specification (one Item per editor style)
    font_group = Group( Item('font_trait', style = 'simple', label = 'Simple'),
                        Item('_'),
                        Item('font_trait', style = 'custom', label = 'Custom'),
                        Item('_'),
                        Item('font_trait', style = 'text', label = 'Text'),
                        Item('_'),
                        Item('font_trait',
                              style = 'readonly',
                              label = 'ReadOnly'))

    # Demo view
    view1 = View( font_group,
                  title = 'FontEditor',
                  buttons = ['OK'] )


# Create the demo:
popup = FontEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = ImageEnumEditor_demo
"""
Implementation of an ImageEnumEditor demo plugin for the Traits UI demo program.

This demo shows each of the four styles of the ImageEnumEditor.
"""

from traits.api import HasTraits, Str, Trait
from traitsui.api import Item, Group, View, ImageEnumEditor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# This list of image names (with the standard suffix "_origin") is used to
# construct an image enumeration trait to demonstrate the ImageEnumEditor.

image_list = [ 'top left', 'top right', 'bottom left', 'bottom right' ]


#-------------------------------------------------------------------------------
#  Classes:
#-------------------------------------------------------------------------------

class Dummy(HasTraits):
    """ Dummy class for ImageEnumEditor
    """
    x = Str
    view = View(" ")



class ImageEnumEditorDemo( HasTraits ):
    """ This class specifies the details of the ImageEnumEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    image_from_list  = Trait( editor = ImageEnumEditor( values = image_list,
                                                        prefix = '@icons:',
                                                        suffix = '_origin',
                                                        cols   = 4,
                                                        klass  = Dummy ),
                              *image_list )


    # Items are used to define the demo display - one Item per
    # editor style
    img_group = Group( Item('image_from_list', style='simple', label='Simple'),
                       Item('_'),
                       Item('image_from_list', style='custom', label='Custom'),
                       Item('_'),
                       Item('image_from_list', style='text', label='Text'),
                       Item('_'),
                       Item('image_from_list',
                             style='readonly',
                             label='ReadOnly'))

    #Demo view
    view1 = View( img_group,
                  title='ImageEnumEditor',
                  buttons=['OK'] )


# Create the demo:
popup = ImageEnumEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = InstanceEditor_demo
"""
Implementation of an InstanceEditor demo plugin for the Traits UI demo program.

This demo shows each of the four styles of the InstanceEditor.

Fixme: This version of the demo only shows the old-style InstanceEditor
capabilities.
"""

from traits.api import HasTraits, Str, Range, Bool, Trait
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Classes:
#-------------------------------------------------------------------------------

class SampleClass ( HasTraits ):
    """ This Sample class is used to demonstrate the InstanceEditor demo.
    """

    #--------------------------------------------------------------------------
    # The actual attributes don't matter here; we just need an assortment
    # to demonstrate the InstanceEditor's capabilities.
    #--------------------------------------------------------------------------

    name             = Str
    occupation       = Str
    age              = Range( 21,65 )
    registered_voter = Bool

    #--------------------------------------------------------------------------
    # The InstanceEditor uses whatever view is defined for the class.  The
    # default view lists the fields alphabetically, so it's best to define one
    # explicitly.
    #--------------------------------------------------------------------------

    view = View( 'name', 'occupation', 'age', 'registered_voter' )


class InstanceEditorDemo ( HasTraits ):
    """ This class specifies the details of the InstanceEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    sample_instance  = Trait( SampleClass() )


    # Items are used to define the demo display - one item per
    # editor style
    inst_group = Group( Item('sample_instance', style='simple', label='Simple'),
                        Item('_'),
                        Item('sample_instance', style='custom', label='Custom'),
                        Item('_'),
                        Item('sample_instance', style='text', label='Text'),
                        Item('_'),
                        Item('sample_instance',
                              style='readonly',
                              label='ReadOnly'))

    # Demo View
    view1 = View( inst_group,
                  title='InstanceEditor',
                  buttons=['OK'] )


# Create the demo:
popup = InstanceEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = ListEditor_demo
"""
Implemention of a ListEditor demo plugin for Traits UI demo program

This demo shows each of the four styles of ListEditor.
"""

from traits.api import HasTraits, List, Str
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class ListEditorDemo ( HasTraits ):
    """ This class specifies the details of the BooleanEditor demo.
    """

    # The Trait to be displayed in the editor
    play_list = List( Str, ["The Merchant of Venice", "Hamlet", "MacBeth"])


    # Items are used to define display; one per editor style.
    list_group = Group( Item('play_list', style='simple', label='Simple'),
                        Item('_'),
                        Item('play_list', style='custom', label='Custom'),
                        Item('_'),
                        Item('play_list', style='text', label='Text'),
                        Item('_'),
                        Item('play_list',
                              style='readonly',
                              label='ReadOnly'))

    # Demo view
    view1 = View( list_group,
                  title = 'ListEditor',
                  buttons = ['OK'],
                  height=400,
                  width=400 )


# Create the demo:
popup = ListEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = RangeEditor_demo
"""
Implementation of a RangeEditor demo plugin for the Traits UI demo program.

This demo shows each of the four styles of the RangeEditor Variations for a
small integer range, a medium-sized integer range, a large integer range
and a float range are demonstrated on separate tabs.
"""

from traits.api import HasTraits, Range
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class RangeEditorDemo ( HasTraits ):
    """ This class specifies the details of the RangeEditor demo.
    """

    # Define a trait for each of four variants
    small_int_range  = Range( 1, 16 )
    medium_int_range = Range( 1, 25 )
    large_int_range  = Range( 1, 150 )
    float_range      = Range( 0.0, 150.0 )


    # RangeEditor display for narrow integer Range traits (< 17 wide):
    int_range_group1 = Group( Item('small_int_range',
                                    style='simple',
                                    label='Simple'),
                              Item('_'),
                              Item('small_int_range',
                                    style='custom',
                                    label='Custom'),
                              Item('_'),
                              Item('small_int_range',
                                    style='text',
                                    label='Text'),
                              Item('_'),
                              Item('small_int_range',
                                    style='readonly',
                                    label='ReadOnly'),
                              label = "Small Int")

    # RangeEditor display for medium-width integer Range traits (17 to 100):
    int_range_group2 = Group( Item('medium_int_range',
                                    style='simple',
                                    label='Simple'),
                              Item('_'),
                              Item('medium_int_range',
                                    style='custom',
                                    label='Custom'),
                              Item('_'),
                              Item('medium_int_range',
                                    style='text',
                                    label='Text'),
                              Item('_'),
                              Item('medium_int_range',
                                    style='readonly',
                                    label='ReadOnly'),
                              label = "Medium Int")

    # RangeEditor display for wide integer Range traits (> 100):
    int_range_group3 = Group( Item('large_int_range',
                                    style='simple',
                                    label='Simple'),
                              Item('_'),
                              Item('large_int_range',
                                    style='custom',
                                    label='Custom'),
                              Item('_'),
                              Item('large_int_range',
                                    style='text',
                                    label='Text'),
                              Item('_'),
                              Item('large_int_range',
                                    style='readonly',
                                    label='ReadOnly'),
                              label = "Large Int")

    # RangeEditor display for float Range traits:
    float_range_group = Group( Item('float_range',
                                     style='simple',
                                     label='Simple'),
                               Item('_'),
                               Item('float_range',
                                     style='custom',
                                     label='Custom'),
                               Item('_'),
                               Item('float_range',
                                     style='text',
                                     label='Text'),
                               Item('_'),
                               Item('float_range',
                                     style='readonly',
                                     label='ReadOnly'),
                               label = "Float")

    # The view includes one group per data type.  These will be displayed
    # on separate tabbed panels.
    view1 = View(int_range_group1,
                 int_range_group2,
                 int_range_group3,
                 float_range_group,
                 title = 'RangeEditor',
                 buttons = ['OK'])


# Create the demo:
popup =  RangeEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = SetEditor_demo
"""
Implementation of a SetEditor demo plugin for the Traits UI demo program.

The four tabs of this demo show variations on the interface as follows:

   Unord I:  Creates an alphabetized subset, has no "move all" options
   Unord II: Creates an alphabetized subset, has "move all" options
   Ord I:    Creates a set whose order is specified by the user, no "move all"
   Ord II:   Creates a set whose order is specifed by the user, has "move all"
"""

from traits.api import HasTraits, List
from traitsui.api import Item, Group, View, SetEditor

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class SetEditorDemo ( HasTraits ):
    """ This class specifies the details of the SetEditor demo.
    """

    # Define a trait each for four variants
    unord_nma_set = List( editor = SetEditor(
                              values = [ 'kumquats', 'pomegranates', 'kiwi' ],
                              can_move_all = False,
                              left_column_title  = 'Available Fruit',
                              right_column_title = 'Exotic Fruit Bowl' ) )

    unord_ma_set = List( editor = SetEditor(
                              values = [ 'kumquats', 'pomegranates', 'kiwi' ],
                              left_column_title  = 'Available Fruit',
                              right_column_title = 'Exotic Fruit Bowl' ) )

    ord_nma_set = List( editor = SetEditor(
                            values  = ['apples', 'berries', 'cantaloupe' ],
                            ordered = True,
                            can_move_all = False,
                            left_column_title  = 'Available Fruit',
                            right_column_title = 'Fruit Bowl' ) )

    ord_ma_set = List( editor = SetEditor(
                       values  = ['apples', 'berries', 'cantaloupe' ],
                       ordered = True,
                       left_column_title  = 'Available Fruit',
                       right_column_title = 'Fruit Bowl' ) )


    # SetEditor display, unordered, no move-all buttons.
    no_nma_group = Group( Item('unord_nma_set', style='simple'),
                          label='Unord I',
                          show_labels=False)


    # SetEditor display, unordered, move-all buttons.
    no_ma_group = Group( Item('unord_ma_set', style='simple'),
                         label='Unord II',
                         show_labels=False)


    # SetEditor display, ordered, no move-all buttons.
    o_nma_group = Group( Item('ord_nma_set', style='simple'),
                         label='Ord I',
                         show_labels=False)


    # SetEditor display, ordered, move-all buttons.
    o_ma_group = Group( Item('ord_ma_set', style='simple'),
                        label='Ord II',
                        show_labels=False)



    # The view includes one group per data type.  These will be displayed
    # on separate tabbed panels.
    view1 = View( no_nma_group,
                  no_ma_group,
                  o_nma_group,
                  o_ma_group,
                  title = 'SetEditor',
                  buttons = ['OK'])


# Create the demo:
popup =  SetEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = TableEditor_demo
"""
Implementation of a TableEditor demo plugin for Traits UI demo program

This demo shows the full behavior of a straightforward TableEditor.  Only
one style of TableEditor is implemented, so that is the one shown.
"""

# Imports:
from traits.api \
    import HasTraits, HasStrictTraits, Str, Int, Regex, List, Enum

from traitsui.api \
    import View, Group, Item, TableEditor

from traitsui.table_column \
    import ObjectColumn

from traitsui.table_filter \
    import EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate, \
           RuleTableFilter

# A helper class for 'Department' below:
class Employee ( HasTraits ):
    name  = Str
    age     = Int
    gender  = Enum( 'Male', 'Female' )
    phone   = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d')

    traits_view = View(
        'name', 'age', 'phone',
        title = 'Create new employee',
        width = 0.18,
        buttons = [ 'OK', 'Cancel' ]
    )

# For readability, the parameters of the demo TableEditor are set here, rather
# than in the View:
table_editor = TableEditor(
    columns     = [ ObjectColumn( name = 'name',   width = 0.30 ),
                    ObjectColumn( name = 'age',    width = 0.20 ),
                    ObjectColumn( name = 'gender', width = 0.25 ),
                    ObjectColumn( name = 'phone',  width = 0.25 ) ],
    auto_size   = False,
    deletable   = True,
    sort_model  = True,
    orientation = 'vertical',
    edit_view   = View( Group( 'name', 'age', 'phone', show_border=True),
                          resizable = True ),
    filters     = [ EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate ],
    search      = RuleTableFilter(),
    row_factory = Employee )

# The class to be edited with the TableEditor:
class Department ( HasStrictTraits ):
    employees = List( Employee )
    traits_view = View( Group( Item( 'employees',
                                     editor = table_editor),
                               show_border=True,
                               show_labels=False),
                        title = 'Department Personnel',
                        width = .4,
                        height = .4,
                        resizable = True,
                        buttons  = [ 'OK', 'Cancel', 'Undo' ],
                        kind = 'live' )



# Create some employees:
jas  = Employee( name = 'Jason', age = 32, phone = '555-1111' )
mike = Employee( name = 'Mike',  age = 34, phone = '555-2222' )
dave = Employee( name = 'Dave',  age = 42, phone = '555-3333' )
lyn  = Employee( name = 'Lyn',   age = 40, phone = '555-4444' )
greg = Employee( name = 'Greg',  age = 45, phone = '555-5555' )

# Create the demo:
popup = Department( employees = [ jas, mike, dave, lyn, greg ] )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = TextEditor_demo
"""
Implementation of a TextEditor demo plugin for the Traits UI demo program.

For each of three data types for which TextEditor is used, this demo shows
each of the four styles of the TextEditor.
"""

from traits.api import HasTraits, Str, Int, Password
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class TextEditorDemo ( HasTraits ):
    """ This class specifies the details of the TextEditor demo.
    """

    # Define a trait for each of three variants
    string_trait     = Str( "sample string" )
    int_trait        = Int( 1 )
    password         = Password


    # TextEditor display without multi-line capability (for various traits):
    text_int_group = Group( Item('int_trait', style='simple', label='Simple'),
                            Item('_'),
                            Item('int_trait', style='custom', label='Custom'),
                            Item('_'),
                            Item('int_trait', style='text', label='Text'),
                            Item('_'),
                            Item('int_trait', style='readonly', label='ReadOnly'),
                            label='Integer' )

    # TextEditor display with multi-line capability (for various traits):
    text_str_group = Group( Item('string_trait',
                                  style='simple',
                                  label='Simple'),
                            Item('_'),
                            Item('string_trait',
                                  style='custom',
                                  label='Custom'),
                            Item('_'),
                            Item('string_trait',
                                  style='text',
                                  label='Text'),
                            Item('_'),
                            Item('string_trait',
                                  style='readonly',
                                  label='ReadOnly'),
                            label='String' )

    # TextEditor display with secret typing capability (for Password traits):
    text_pass_group = Group( Item('password', style='simple', label='Simple'),
                             Item('_'),
                             Item('password', style='custom', label='Custom'),
                             Item('_'),
                             Item('password', style='text', label='Text'),
                             Item('_'),
                             Item('password', style='readonly', label='ReadOnly'),
                             label='Password' )


    # The view includes one group per data type.  These will be displayed
    # on separate tabbed panels.
    view1 = View(text_int_group,
                 text_str_group,
                 text_pass_group,
                 title = 'TextEditor',
                 buttons = ['OK'])


# Create the demo:
popup = TextEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = TreeEditor_demo
"""
Demonstrates using the TreeEditor to display a hierarchically organized data
structure.

In this case, the tree has the following hierarchy:
  - Partner
    - Company
      - Department
        - Employee
"""

from traits.api \
    import HasTraits, Str, Regex, List, Instance

from traitsui.api \
    import Item, View, TreeEditor, TreeNode

class Employee ( HasTraits ):
    name  = Str( '<unknown>' )
    title = Str
    phone = Regex( regex = r'\d\d\d-\d\d\d\d' )

    def default_title ( self ):
        self.title = 'Senior Engineer'

class Department ( HasTraits ):
    name      = Str( '<unknown>' )
    employees = List( Employee )

class Company ( HasTraits ):
    name        = Str( '<unknown>' )
    departments = List( Department )
    employees   = List( Employee )

# Create an empty view for objects that have no data to display:
no_view = View()

# Define the TreeEditor used to display the hierarchy:
tree_editor = TreeEditor(
    nodes = [
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = '',
                  label     = 'name',
                  view      = View( [ 'name' ] )
        ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'departments',
                  label     = '=Departments',
                  view      = no_view,
                  add       = [ Department ]
        ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'employees',
                  label     = '=Employees',
                  view      = no_view,
                  add       = [ Employee ]
        ),
        TreeNode( node_for  = [ Department ],
                  auto_open = True,
                  children  = 'employees',
                  label     = 'name',
                  view      = View( [ 'name' ] ),
                  add       = [ Employee ]
        ),
        TreeNode( node_for  = [ Employee ],
                  auto_open = True,
                  label     = 'name',
                  view      = View( [ 'name', 'title', 'phone' ] )
        )
    ]
)

class Partner ( HasTraits ):
    name    = Str( '<unknown>' )
    company = Instance( Company )

    view = View(
        Item( name       = 'company',
              editor     = tree_editor,
              show_label = False
        ),
        title     = 'Company Structure',
        buttons   = [ 'OK' ],
        resizable = True,
        style     = 'custom',
        width     = .3,
        height    = .3
    )

# Create an example data structure:
jason  = Employee( name  = 'Jason',
                   title = 'Senior Engineer',
                   phone = '536-1057' )
mike   = Employee( name  = 'Mike',
                   title = 'Senior Engineer',
                   phone = '536-1057' )
dave   = Employee( name  = 'Dave',
                   title = 'Senior Software Developer',
                   phone = '536-1057' )
martin = Employee( name  = 'Martin',
                   title = 'Senior Engineer',
                   phone = '536-1057' )
duncan = Employee( name  = 'Duncan',
                   title = 'Consultant',
                   phone = '526-1057' )

# Create the demo:
popup = Partner(
    name    = 'Enthought, Inc.',
    company = Company(
        name        = 'Enthought',
        employees   = [ dave, martin, duncan, jason, mike ],
        departments = [
            Department(
                name      = 'Business',
                employees = [ jason, mike ]
            ),
            Department(
                name      = 'Scientific',
                employees = [ dave, martin, duncan ]
            )
        ]
    )
)

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = TupleEditor_demo
"""
Implementation of a TupleEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the TupleEditor.
"""

from traits.api import HasTraits, Tuple, Color, Range, Str
from traitsui.api import Item, Group, View

#-------------------------------------------------------------------------------
#  Demo Class
#-------------------------------------------------------------------------------

class TupleEditorDemo ( HasTraits ):
    """ This class specifies the details of the TupleEditor demo.
    """

    # To demonstrate any given Trait editor, an appropriate Trait is required.
    tuple = Tuple( Color, Range( 1, 4 ), Str )


    # Display specification (one Item per editor style)
    tuple_group = Group( Item('tuple', style = 'simple', label = 'Simple'),
                         Item('_'),
                         Item('tuple', style = 'custom', label = 'Custom'),
                         Item('_'),
                         Item('tuple', style = 'text', label = 'Text'),
                         Item('_'),
                         Item('tuple', style = 'readonly', label = 'ReadOnly'))

    # Demo view
    view1 = View( tuple_group,
                  title = 'TupleEditor',
                  buttons = ['OK'] )


# Create the demo:
popup = TupleEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    popup.configure_traits()


########NEW FILE########
__FILENAME__ = RangeEditor_demo
"""
Range editor

A Range Trait holds a numeric value which is restricted to a specified range.

This example shows how the RangeEditor's simple and custom styles vary
depending on the type (integer or float) and size (small, medium, or large
integer) of the specified range.

The example also shows how multiple Groups at the top level of a View are
automatically placed into separate tabs.

For an example of how to dynamically vary the bounds of a Range trait, see
the *Dynamic Range Editor* example.
"""

from traits.api import HasTraits, Range
from traitsui.api import Item, Group, View

class RangeEditorDemo ( HasTraits ):
    """ Defines the RangeEditor demo class.
    """

    # Define a trait for each of four range variants:
    small_int_range  = Range( 1, 16 )
    medium_int_range = Range( 1, 25 )
    large_int_range  = Range( 1, 150 )
    float_range      = Range( 0.0, 150.0 )

    # RangeEditor display for narrow integer Range traits (< 17 wide):
    int_range_group1 = Group(
        Item( 'small_int_range',  style = 'simple',  label = 'Simple' ),
        Item( '_' ),
        Item( 'small_int_range',  style = 'custom',  label = 'Custom' ),
        Item( '_' ),
        Item( 'small_int_range', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'small_int_range', style = 'readonly', label = 'ReadOnly' ),
        label = 'Small Int'
    )

    # RangeEditor display for medium-width integer Range traits (17 to 100):
    int_range_group2 = Group(
        Item( 'medium_int_range', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'medium_int_range', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'medium_int_range', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'medium_int_range', style = 'readonly', label = 'ReadOnly' ),
        label = 'Medium Int'
    )

    # RangeEditor display for wide integer Range traits (> 100):
    int_range_group3 = Group(
        Item( 'large_int_range', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'large_int_range', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'large_int_range', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'large_int_range', style = 'readonly', label = 'ReadOnly' ),
        label = 'Large Int'
    )

    # RangeEditor display for float Range traits:
    float_range_group = Group(
        Item( 'float_range', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'float_range', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'float_range', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'float_range', style = 'readonly', label = 'ReadOnly' ),
        label = 'Float'
    )

    # The view includes one group per data type. These will be displayed
    # on separate tabbed panels:
    traits_view = View(
        int_range_group1,
        int_range_group2,
        int_range_group3,
        float_range_group,
        title     = 'RangeEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )


# Create the demo:
demo =  RangeEditorDemo()

# Run the demo (if invoked from the comand line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = RGBColorEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a ColorEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the ColorEditor
"""

# Imports:
from traits.api \
    import HasTraits, RGBColor

from traitsui.api \
    import Item, Group, View

# Demo class definition:
class ColorEditorDemo ( HasTraits ):
    """ Defines the main ColorEditor demo. """

    # Define a Color trait to view:
    color_trait = RGBColor

    # Items are used to define the demo display, one item per editor style:
    color_group = Group(
        Item( 'color_trait', style = 'simple',   label = 'Simple' ),
        Item(  '_' ),
        Item( 'color_trait', style = 'custom',   label = 'Custom' ),
        Item( '_'),
        Item( 'color_trait', style = 'text',     label = 'Text' ),
        Item( '_'),
        Item( 'color_trait', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view
    view1 = View(
        color_group,
        title     = 'ColorEditor',
        buttons   = ['OK'],
        resizable = True
    )

# Create the demo:
demo = ColorEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = SetEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a SetEditor demo plugin for the Traits UI demo program.

The four tabs of this demo show variations on the interface as follows:

   Unord I:  Creates an alphabetized subset, has no "move all" options
   Unord II: Creates an alphabetized subset, has "move all" options
   Ord I:    Creates a set whose order is specified by the user, no "move all"
   Ord II:   Creates a set whose order is specifed by the user, has "move all"
"""

# Imports:
from traits.api \
    import HasTraits, List

from traitsui.api \
    import Item, Group, View, SetEditor

# Define the main demo class:
class SetEditorDemo ( HasTraits ):
    """ Defines the SetEditor demo class.
    """

    # Define a trait each for four SetEditor variants:
    unord_nma_set = List( editor = SetEditor(
                              values = [ 'kumquats', 'pomegranates', 'kiwi' ],
                              can_move_all       = False,
                              left_column_title  = 'Available Fruit',
                              right_column_title = 'Exotic Fruit Bowl' ) )

    unord_ma_set = List( editor = SetEditor(
                              values = [ 'kumquats', 'pomegranates', 'kiwi' ],
                              left_column_title  = 'Available Fruit',
                              right_column_title = 'Exotic Fruit Bowl' ) )

    ord_nma_set = List( editor = SetEditor(
                            values  = ['apples', 'berries', 'cantaloupe' ],
                            ordered            = True,
                            can_move_all       = False,
                            left_column_title  = 'Available Fruit',
                            right_column_title = 'Fruit Bowl' ) )

    ord_ma_set = List( editor = SetEditor(
                       values  = ['apples', 'berries', 'cantaloupe' ],
                       ordered            = True,
                       left_column_title  = 'Available Fruit',
                       right_column_title = 'Fruit Bowl' ) )

    # SetEditor display, unordered, no move-all buttons:
    no_nma_group = Group(
        Item( 'unord_nma_set', style = 'simple' ),
        label       = 'Unord I',
        show_labels = False
    )

    # SetEditor display, unordered, move-all buttons:
    no_ma_group = Group(
        Item( 'unord_ma_set', style = 'simple' ),
        label       = 'Unord II',
        show_labels = False
    )

    # SetEditor display, ordered, no move-all buttons:
    o_nma_group = Group(
        Item( 'ord_nma_set', style = 'simple' ),
        label       = 'Ord I',
        show_labels = False
    )

    # SetEditor display, ordered, move-all buttons:
    o_ma_group = Group(
        Item( 'ord_ma_set', style = 'simple' ),
        label       = 'Ord II',
        show_labels = False
    )

    # The view includes one group per data type. These will be displayed
    # on separate tabbed panels:
    view = View(
        no_nma_group,
        no_ma_group,
        o_nma_group,
        o_ma_group,
        title   = 'SetEditor',
        buttons = ['OK']
    )

# Create the demo:
demo = SetEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = TableEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a TableEditor demo plugin for Traits UI demo program

This demo shows the full behavior of a straightforward TableEditor.  Only
one style of TableEditor is implemented, so that is the one shown.
"""

# Import statements:
from traits.api \
    import HasTraits, HasStrictTraits, Str, Int, Regex, List

from traitsui.api \
    import View, Group, Item, TableEditor

from traitsui.table_column \
    import ObjectColumn, ExpressionColumn

from traitsui.table_filter \
    import EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate, \
           EvalTableFilter

# A helper class for the 'Department' class below:
class Employee ( HasTraits ):
    first_name = Str
    last_name  = Str
    age        = Int
    phone      = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    traits_view = View(
        'first_name', 'last_name', 'age', 'phone',
        title   = 'Create new employee',
        width   = 0.18,
        buttons = [ 'OK', 'Cancel' ]
    )

# The definition of the demo TableEditor:
table_editor = TableEditor(
    columns = [ ObjectColumn( name = 'first_name', width = 0.20 ),
                ObjectColumn( name = 'last_name',  width = 0.20 ),
                ExpressionColumn(
                    label = 'Full Name',
                    width = 0.30,
                    expression = "'%s %s' % (object.first_name, "
                                 "object.last_name )" ),
                ObjectColumn( name = 'age',   width = 0.10,
                              horizontal_alignment = 'center' ),
                ObjectColumn( name = 'phone', width = 0.20 ) ],
    deletable   = True,
    sort_model  = True,
    auto_size   = False,
    orientation = 'vertical',
    edit_view   = View(
                      Group( 'first_name', 'last_name', 'age', 'phone',
                             show_border = True
                      ),
                      resizable = True
                  ),
    filters     = [ EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate ],
    search      = EvalTableFilter(),
    show_toolbar = True,
    row_factory = Employee )

# The class to be edited with the TableEditor:
class Department ( HasStrictTraits ):

    employees = List( Employee )

    traits_view = View(
        Group(
            Item( 'employees',
                  show_label  = False,
                  editor      = table_editor
            ),
            show_border = True,
        ),
        title     = 'TableEditor',
        width     = .4,
        height    = .4,
        resizable = True,
        buttons   = [ 'OK' ],
        kind      = 'live'
    )

# Create some employees:
employees = [
    Employee( first_name = 'Jason', last_name = 'Smith',
              age = 32, phone = '555-1111' ),
    Employee( first_name = 'Mike',  last_name = 'Tollan',
              age = 34, phone = '555-2222' ),
    Employee( first_name = 'Dave',  last_name = 'Richards',
              age = 42, phone = '555-3333' ),
    Employee( first_name = 'Lyn',   last_name = 'Spitz',
              age = 40, phone = '555-4444' ),
    Employee( first_name = 'Greg',  last_name = 'Andrews',
              age = 45, phone = '555-5555' )
]

# Create the demo:
demo = Department( employees = employees )

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = TextEditor_demo
"""
Edit a string, password, or integer

The TextEditor displays a Str, Password, or Int trait for the user to edit.

When editing a Str, consider styles 'simple' (one-line), 'custom' (multi-line),
or read-only (multi-line).

When editing a Password, use style 'simple' (shows asterisks).

When editing an Int, consider styles 'simple' and 'readonly'.
"""
# FIXME:? as of 7/1/2011, Password style 'text' showed typed characters.
# It no longer does. Should it?

# Imports:
from traits.api import HasTraits, Str, Int, Password

from traitsui.api import Item, Group, View

# The main demo class:
class TextEditorDemo ( HasTraits ):
    """ Defines the TextEditor demo class.
    """

    # Define a trait for each of three TextEditor variants:
    string_trait = Str( "sample string" )
    int_trait    = Int( 1 )
    password     = Password

    # TextEditor display with multi-line capability (for a string):
    text_str_group = Group(
        Item( 'string_trait', style = 'simple',  label = 'Simple' ),
        Item( '_' ),
        Item( 'string_trait', style = 'custom',  label = 'Custom' ),
        Item( '_' ),
        # text style is the same as simple, not shown.
        Item( 'string_trait', style = 'readonly', label = 'ReadOnly' ),
        label = 'String'
    )

    # TextEditor display without multi-line capability (for an integer):
    text_int_group = Group(
        Item( 'int_trait', style = 'simple',   label = 'Simple' ),
        # custom and text styles are not useful for editing integers, not shown:
        Item( '_' ),
        Item( 'int_trait', style = 'readonly', label = 'ReadOnly' ),
        label = 'Integer'
    )

    # TextEditor display with secret typing capability (for Password traits):
    text_pass_group = Group(
        Item( 'password', style = 'simple',   label = 'Simple' ),
        # custom and text style are the same as simple, not shown.
        label = 'Password'
    )

    # The view includes one group per data type. These will be displayed
    # on separate tabbed panels:
    traits_view = View(
        text_str_group,
        text_pass_group,
        text_int_group,
        title   = 'TextEditor',
        buttons = [ 'OK' ]
    )

# Create the demo:
demo =  TextEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = TitleEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Demonstrates the use of the TitleEditor.

A TitleEditor can be used to dynamically label sections of a user interface.
The text displayed by the TitleEditor is specified by a trait associated with
the view.

This demonstration shows three variations of using a TitleEditor:

 * In the first example, the TitleEditor values are supplied by an Enum trait.
   Simply select a new value for the title from the drop-down list to cause the
   title to change.
 * In the second example, the TitleEditor values are supplied by a Str trait.
   Simply type a new value into the title field to cause the title to change.
 * In the third example, the TitleEditor values are supplied by a Property
   whose value is derived from a calculation on a Float trait. Type a number
   into the value field to cause the title to changed.
"""

# Imports:
from traits.api \
    import HasTraits, Enum, Str, Float, Property, cached_property

from traitsui.api \
    import View, VGroup, HGroup, Item, TitleEditor

class TitleEditorDemo ( HasTraits ):

    # Define the selection of titles that can be displayed:
    title = Enum(
        'Select a new title from the drop down list below',
        'This is the TitleEditor demonstration',
        'Acme Widgets Sales for Each Quarter',
        'This is Not Intended to be a Real Application'
    )

    # A user settable version of the title:
    title_2 = Str( 'Type into the text field below to change this title' )

    # A title driven by the result of a calculation:
    title_3 = Property( depends_on = 'value' )

    # The number used to drive the calculation:
    value = Float

    # Define the test view:
    view = View(
        VGroup(
            VGroup(
                HGroup(
                    Item( 'title',
                          show_label = False,
                          springy    = True,
                          editor     = TitleEditor()
                    )
                ),
                Item( 'title' ),
                show_border = True
            ),
            VGroup(
                HGroup(
                    Item( 'title_2',
                          show_label = False,
                          springy    = True,
                          editor     = TitleEditor()
                    )
                ),
                Item( 'title_2', label = 'Title' ),
                show_border = True
            ),
            VGroup(
                HGroup(
                    Item( 'title_3',
                          show_label = False,
                          springy    = True,
                          editor     = TitleEditor()
                    )
                ),
                Item( 'value' ),
                show_border = True
            )
        ),
        width = 0.4
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_title_3 ( self ):
        try:
            return ('The square root of %s is %s' %
                    ( self.value, self.value ** 0.5 ))
        except:
            return ('The square root of %s is %si' %
                    ( self.value, (-self.value) ** 0.5 ))

# Create the demo:
demo = TitleEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = TreeEditor_demo
"""
Tree editor for hierarchal data

Demonstrates using the TreeEditor to display a hierarchically organized data
structure.

In this case, the tree has the following hierarchy:

  - Partner

    - Company

      - Department

        - Employee

The TreeEditor generates a hierarchical tree control, consisting of nodes. It is
useful for cases where objects contain lists of other objects.

The tree control is displayed in one pane of the editor, and a user interface
for the selected object is displayed in the other pane. The layout orientation
of the tree and the object editor is determined by the *orientation* parameter
of TreeEditor(), which can be 'horizontal' or 'vertical'.

You must specify the types of nodes that can appear in the tree using the
*nodes* parameter, which must be a list of instances of TreeNode (or of
subclasses of TreeNode).

You must specify the classes whose instances the node type applies to. Use the
**node_for** attribute of TreeNode to specify a list of classes; often, this
list contains only one class. You can have more than one node type that applies
to a particular class; in this case, each object of that class is represented by
multiple nodes, one for each applicable node type.

See the Traits User Manual for more details.
"""

# FIXME: provide accessible copy or equivalent of factories_advanced_extra.rst

from traits.api import HasTraits, Str, Regex, List, Instance
from traitsui.api import Item, View, TreeEditor, TreeNode

class Employee(HasTraits):
    """ Defines a company employee. """

    name  = Str('<unknown>')
    title = Str
    phone = Regex(regex = r'\d\d\d-\d\d\d\d')

    def default_title(self):
        self.title = 'Senior Engineer'

class Department(HasTraits):
    """ Defines a department with employees. """

    name      = Str('<unknown>')
    employees = List(Employee)

class Company(HasTraits):
    """ Defines a company with departments and employees. """

    name        = Str('<unknown>')
    departments = List(Department)
    employees   = List(Employee)

# Create an empty view for objects that have no data to display:
no_view = View()

# Define the TreeEditor used to display the hierarchy:
tree_editor = TreeEditor(
    nodes = [
        # The first node specified is the top level one
        TreeNode(node_for  = [ Company ],
                  auto_open = True,
                  # child nodes are
                  children  = '',
                  label     = 'name',  # label with Company name
                  view      = View([ 'name' ])
        ),
        TreeNode(node_for  = [ Company ],
                  auto_open = True,
                  children  = 'departments',
                  label     = '=Departments',  # constant label
                  view      = no_view,
                  add       = [ Department ],
        ),
        TreeNode(node_for  = [ Company ],
                  auto_open = True,
                  children  = 'employees',
                  label     = '=Employees',   # constant label
                  view      = no_view,
                  add       = [ Employee ]
        ),
        TreeNode(node_for  = [ Department ],
                  auto_open = True,
                  children  = 'employees',
                  label     = 'name',   # label with Department name
                  view      = View([ 'name' ]),
                  add       = [ Employee ]
        ),
        TreeNode(node_for  = [ Employee ],
                  auto_open = True,
                  label     = 'name',   # label with Employee name
                  view      = View([ 'name', 'title', 'phone' ])
        )
    ]
)

class Partner(HasTraits):
    """ Defines a business partner."""

    name    = Str('<unknown>')
    company = Instance(Company)

    view = View(
        Item(name       = 'company',
              editor     = tree_editor,
              show_label = False
        ),
        title     = 'Company Structure',
        buttons   = [ 'OK' ],
        resizable = True,
        style     = 'custom',
        width     = .3,
        height    = 500
    )

# Create an example data structure:
jason  = Employee(name  = 'Jason',
                   title = 'Senior Engineer',
                   phone = '536-1057')
mike   = Employee(name  = 'Mike',
                   title = 'Senior Engineer',
                   phone = '536-1057')
dave   = Employee(name  = 'Dave',
                   title = 'Senior Software Developer',
                   phone = '536-1057')
martin = Employee(name  = 'Martin',
                   title = 'Senior Engineer',
                   phone = '536-1057')
duncan = Employee(name  = 'Duncan',
                   title = 'Consultant',
                   phone = '526-1057')

# Create the demo:
demo = Partner(
    name    = 'Enthought, Inc.',
    company = Company(
        name        = 'Enthought',
        employees   = [ dave, martin, duncan, jason, mike ],
        departments = [
            Department(
                name      = 'Business',
                employees = [ jason, mike ]
            ),
            Department(
                name      = 'Scientific',
                employees = [ dave, martin, duncan ]
            )
        ]
    )
)

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = TupleEditor_demo
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

"""
Implementation of a TupleEditor demo plugin for Traits UI demo program.

This demo shows each of the four styles of the TupleEditor
"""

# Imports:
from traits.api \
    import HasTraits, Tuple, Color, Range, Str

from traitsui.api \
    import Item, Group, View

# The main demo class:
class TupleEditorDemo ( HasTraits ):
    """ Defines the TupleEditor demo class.
    """

    # Define a trait to view:
    tuple = Tuple( Color, Range( 1, 4 ), Str )


    # Display specification (one Item per editor style):
    tuple_group = Group(
        Item( 'tuple', style = 'simple',   label = 'Simple' ),
        Item( '_' ),
        Item( 'tuple', style = 'custom',   label = 'Custom' ),
        Item( '_' ),
        Item( 'tuple', style = 'text',     label = 'Text' ),
        Item( '_' ),
        Item( 'tuple', style = 'readonly', label = 'ReadOnly' )
    )

    # Demo view
    view = View(
        tuple_group,
        title     = 'TupleEditor',
        buttons   = [ 'OK' ],
        resizable = True
    )


# Create the demo:
demo = TupleEditorDemo()

# Run the demo (if invoked from the command line):
if __name__ == '__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = demo_group_size
"""
Control the height and width of a Group

TraitsUI does not permit explicit specification of the height or width of a 
Group (or its descendants). The workaround is to put each Group whose size you 
wish to control into its own View class, which can be an Item (hence can be 
size-controlled) in the larger View. Sometimes it is necessary to repeat such 
surgery at several levels to get the desired layout.

We separate the left and right groups by a splitter (HSplit), and also 
make the window itself resizable.

This demo includes a simple Chaco plot for variety, but it is not a Chaco demo.

"""
from numpy import linspace, pi, sin
from traits.api import HasTraits, Instance, Str, Int
# UItem is Unlabeled Item
from traitsui.api import View, Item, UItem, HSplit, InstanceEditor, \
     VGroup, HGroup
from chaco.api import Plot, AbstractPlotData, ArrayPlotData
from enable.component_editor import ComponentEditor

class InstanceUItem(UItem):
    """Convenience class for including an Instance in a View"""
    style = Str('custom')
    editor = Instance(InstanceEditor,())

class PlotView(HasTraits):
    """Defines a sub-view whose size we wish to explicitly control."""
    n = Int(123)
    data = Instance(AbstractPlotData)
    plot1 = Instance(Plot)
    view = View(
            # This HGroup keeps 'n' from over-widening, by implicitly placing
            # a spring to the right of the item.
            HGroup(Item('n')),
            UItem('plot1', editor=ComponentEditor()),
            resizable=True,
            )

    def create_plot(self, data, name, color):
        p = Plot(self.data)
        p.plot(data, name=name, color=color)
        return p

    def _data_changed(self):
        self.plot1 = self.create_plot(("x", "y1"), "sin plot", "red")

class VerticalBar(HasTraits):
    """Defines a sub-view whose size we wish to explicitly control."""
    a = Str('abcdefg')
    b = Int(123)
    view = View(
                VGroup(
                    Item('a'),
                    Item('b'),
                    show_border=True,
                    ),
                )

class BigView(HasTraits):
    """Defines the top-level view. It contains two side-by-side panels (a
    vertical bar and a plot under an integer) whose relative sizes we wish
    to control explicitly. If these were simply defined as Groups, we could 
    not control their sizes. But by extracting them as separate classes with
    their own views, the resizing becomes possible, because they are loaded
    as Items now.
    """
    bar = Instance(VerticalBar, ())
    plot = Instance(PlotView)
    view = View(
                HSplit(
                    # Specify pixel width of each sub-view. (Or, to specify
                    # proportionate width, use a width < 1.0)
                    # We specify the height here for sake of demonstration;
                    # it could also be specified for the top-level view.
                    InstanceUItem('bar', width=150),
                    InstanceUItem('plot', width=500, height=500),
                    show_border=True,
                    ),
                resizable=True,
                )

x = linspace(-2*pi, 2*pi, 100)
pv = PlotView(data = ArrayPlotData(x=x, y1=sin(x)))
bv = BigView(plot=pv)
bv.configure_traits()
########NEW FILE########
__FILENAME__ = using_springs
"""
Spacing widgets using springs

*Springs* are a simple technique for adding space before, after, or between
Traits UI editors (a.k.a. widgets).

By default, Traits UI arranges widgets immediately adjacent to each other --
from left to right in a horizontal group, or from top to bottom in a vertical
group. Sometimes this works well, but sometimes it results in widgets that are
placed confusingly, or have been unattractively stretched to fill available
space.

When you place a *spring* in a horizontal group, Traits UI will not try to fill
that space with an adjacent widget, instead allowing empty space which varies 
depending on the overall size of the containing group.
"""

from traits.api import HasTraits, Button
from traitsui.api import View, VGroup, HGroup, Item, spring, Label

# dummy button which will be used repeatedly to demonstrate widget spacing:
button = Item( 'ignore', show_label = False )

class SpringDemo(HasTraits):

    ignore = Button('Ignore')

    view = View(
               VGroup(
                   '10',
                   Label(label='Spring in a horizontal group moves widget right:'),
                   '10',
                   HGroup(button, button,
                        show_border = True,
                        label = 'Left justified (no springs)' ),
                   HGroup(spring, button, button,
                        show_border = True,
                        label = 'Right justified with a spring '
                                'before any buttons'),
                   HGroup(button, spring, button,
                        show_border = True,
                        label = 'Left and right justified with a '
                                         'spring between buttons'),
                   HGroup(button, button, spring,
                        button, button, spring,
                        button, button,
                        show_border = True,
                        label = 'Left, center and right justified '
                                'with springs after the 2nd and 4th '
                                'buttons'),
                   spring,
                   Label('But spring in vertical group does not move '
                         'widget down at present.'),
                   button
               ),
               width=600,
               height=600,
               resizable=True,
               title   = 'Spring Demo',
               buttons = [ 'OK' ]
           )

demo = SpringDemo()

if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = array_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# array_editor.py -- Example of using array editors

#--[Imports]--------------------------------------------------------------------
from numpy.numarray import Int, Float

from traits.api import HasPrivateTraits, Array
from traitsui.api import View, ArrayEditor, Item
from traitsui.menu import NoButtons

#--[Code]-----------------------------------------------------------------------

class ArrayEditorTest ( HasPrivateTraits ):

    three = Array(Int, (3,3))
    four  = Array(Float,
                  (4,4),
                  editor = ArrayEditor(width = -50))

    view = View( Item('three', label='3x3 Integer'),
                 '_',
                 Item('three',
                      label='Integer Read-only',
                      style='readonly'),
                 '_',
                 Item('four', label='4x4 Float'),
                 '_',
                 Item('four',
                      label='Float Read-only',
                      style='readonly'),
                 buttons   = NoButtons,
                 resizable = True )


if __name__ == '__main__':
    ArrayEditorTest().configure_traits()

########NEW FILE########
__FILENAME__ = configure_traits_view
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# configure_traits_view.py -- Sample code to demonstrate configure_traits()


#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int
from traitsui.api import View, Item
import traitsui

#--[Code]-----------------------------------------------------------------------

class SimpleEmployee(HasTraits):
    first_name = Str
    last_name = Str
    department = Str
    employee_number = Str
    salary = Int

view1 = View(Item(name = 'first_name'),
             Item(name = 'last_name'),
             Item(name = 'department'))

sam = SimpleEmployee()
sam.configure_traits(view=view1)


########NEW FILE########
__FILENAME__ = configure_traits_view_buttons
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# configure_traits_view_buttons.py -- Sample code to demonstrate
#                                     configure_traits()

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int
from traitsui.api import View, Item
from traitsui.menu import OKButton, CancelButton

#--[Code]-----------------------------------------------------------------------

class SimpleEmployee(HasTraits):
    first_name = Str
    last_name = Str
    department = Str

    employee_number = Str
    salary = Int

view1 = View(Item(name = 'first_name'),
             Item(name = 'last_name'),
             Item(name = 'department'),
             buttons = [OKButton, CancelButton])

sam = SimpleEmployee()
sam.configure_traits(view=view1)


########NEW FILE########
__FILENAME__ = configure_traits_view_group
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


# configure_traits_view_group.py -- Sample code to demonstrate configure_traits()

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int
from traitsui.api import View, Item, Group
import traitsui

#--[Code]-----------------------------------------------------------------------

class SimpleEmployee(HasTraits):
    first_name = Str
    last_name = Str
    department = Str

    employee_number = Str
    salary = Int

view1 = View(Group(Item(name = 'first_name'),
                   Item(name = 'last_name'),
                   Item(name = 'department'),
                   label = 'Personnel profile',
                   show_border = True))


sam = SimpleEmployee()
sam.configure_traits(view=view1)


########NEW FILE########
__FILENAME__ = default_traits_view
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# default_traits_view.py -- Sample code to demonstrate the use of 'traits_view'

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int
from traitsui.api import View, Item, Group
import traitsui

#--[Code]-----------------------------------------------------------------------

class SimpleEmployee2(HasTraits):
    first_name = Str
    last_name = Str
    department = Str

    employee_number = Str
    salary = Int

    traits_view = View(Group(Item(name = 'first_name'),
                             Item(name = 'last_name'),
                             Item(name = 'department'),
                             label = 'Personnel profile',
                             show_border = True))

sam = SimpleEmployee2()
sam.configure_traits()


########NEW FILE########
__FILENAME__ = default_trait_editors
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# default_trait_editors.py -- Example of using default trait editors

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Range, Bool
from traitsui.api import View, Item

#--[Code]-----------------------------------------------------------------------

class Adult(HasTraits):
    first_name = Str
    last_name = Str
    age = Range(21,99)
    registered_voter = Bool

    traits_view = View(Item(name='first_name'),
                       Item(name='last_name'),
                       Item(name='age'),
                       Item(name='registered_voter'))

alice = Adult(first_name='Alice',
              last_name='Smith',
              age=42,
              registered_voter=True)

alice.configure_traits()


########NEW FILE########
__FILENAME__ = enum_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# enum_editor.py -- Example of using an enumeration editor

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Enum
from traitsui.api import EnumEditor, View, Item

#--[Code]-----------------------------------------------------------------------

class EnumExample(HasTraits):
    priority = Enum('Medium', 'Highest',
                              'High',
                              'Medium',
                              'Low',
                              'Lowest')

    view = View( Item(name='priority',
                      editor=EnumEditor(values={
                          'Highest' : '1:Highest',
                          'High'    : '2:High',
                          'Medium'  : '3:Medium',
                          'Low'     : '4:Low',
                          'Lowest'  : '5:Lowest', })))


EnumExample().configure_traits()

########NEW FILE########
__FILENAME__ = handler_override
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# handler_override.py -- Example of a Handler that overrides setattr(), and
#                        that has a user interface notification method

#--[Imports]--------------------------------------------------------------------

from traits.api import HasTraits, Bool
from traitsui.api import View, Handler

#--[Code]-----------------------------------------------------------------------

class TC_Handler(Handler):

    def setattr(self, info, object, name, value):
        Handler.setattr(self, info, object, name, value)
        info.object._updated = True

    def object__updated_changed(self, info):
        if info.initialized:
            info.ui.title += "*"

class TestClass(HasTraits):
    b1 = Bool
    b2 = Bool
    b3 = Bool
    _updated = Bool(False)

view1 = View('b1', 'b2', 'b3',
             title="Alter Title",
             handler=TC_Handler(),
             buttons = ['OK', 'Cancel'])

tc = TestClass()
tc.configure_traits(view=view1)


########NEW FILE########
__FILENAME__ = include_extra
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# include_extra.py --- Example of Include object
#                      provided for subclasses
from traits.api import HasTraits, Int, Str
from traitsui.api import Group, Include, View

class Person(HasTraits):
    name = Str
    age = Int

    person_view = View('name', Include('extra'), 'age')

class LocatedPerson(Person):
    street = Str
    city = Str
    state = Str
    zip = Str

    extra = Group('street', 'city', 'state', 'zip')


Person().configure_traits()
LocatedPerson().configure_traits()

########NEW FILE########
__FILENAME__ = instance_editor_selection
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# instance_editor_selection.py -- Example of an instance editor with
#                                 instance selection

#--[Imports]--------------------------------------------------------------------

from traits.api    \
    import HasStrictTraits, Int, Instance, List, Regex, Str
from traitsui.api \
    import View, Item, InstanceEditor

#--[Code]-----------------------------------------------------------------------

class Person ( HasStrictTraits ):
    name  = Str
    age   = Int
    phone = Regex( value = '000-0000',
                   regex = '\d\d\d[-]\d\d\d\d' )

    traits_view = View( 'name', 'age', 'phone' )

people = [
  Person( name = 'Dave',   age = 39, phone = '555-1212' ),
  Person( name = 'Mike',   age = 28, phone = '555-3526' ),
  Person( name = 'Joe',    age = 34, phone = '555-6943' ),
  Person( name = 'Tom',    age = 22, phone = '555-7586' ),
  Person( name = 'Dick',   age = 63, phone = '555-3895' ),
  Person( name = 'Harry',  age = 46, phone = '555-3285' ),
  Person( name = 'Sally',  age = 43, phone = '555-8797' ),
  Person( name = 'Fields', age = 31, phone = '555-3547' )
]

class Team ( HasStrictTraits ):

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    traits_view = View( Item('name'),
                        Item('_'),
                        Item( 'captain',
                              label='Team Captain',
                              editor =
                                  InstanceEditor( name = 'roster',
                                                  editable = True),
                              style = 'custom',
                             ),
                        buttons = ['OK'])

#--[Example*]-------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()


########NEW FILE########
__FILENAME__ = key_bindings
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# key_bindings.py -- Example of a code editor with a key bindings editor

#--[Imports]--------------------------------------------------------------------
from traits.api \
    import Button, Code, HasPrivateTraits, Str

from traitsui.api \
    import View, Item, Group, Handler, CodeEditor

from traitsui.key_bindings \
    import KeyBinding, KeyBindings

#--[Code]-----------------------------------------------------------------------

key_bindings = KeyBindings(
    KeyBinding( binding1    = 'Ctrl-s',
                description = 'Save to a file',
                method_name = 'save_file' ),
    KeyBinding( binding1    = 'Ctrl-r',
                description = 'Run script',
                method_name = 'run_script' ),
    KeyBinding( binding1    = 'Ctrl-k',
                description = 'Edit key bindings',
                method_name = 'edit_bindings' )
)

# Traits UI Handler class for bound methods
class CodeHandler ( Handler ):

    def save_file ( self, info ):
        info.object.status = "save file"

    def run_script ( self, info ):
        info.object.status = "run script"

    def edit_bindings ( self, info ):
        info.object.status = "edit bindings"
        key_bindings.edit_traits()

class KBCodeExample ( HasPrivateTraits ):

    code   = Code
    status = Str
    kb    = Button(label='Edit Key Bindings')

    view = View( Group (
                 Item( 'code',
                       style     = 'custom',
                       resizable = True ),
                 Item('status', style='readonly'),
                 'kb',
                 orientation = 'vertical',
                 show_labels = False,
                 ),
               id = 'KBCodeExample',
               key_bindings = key_bindings,
               title = 'Code Editor With Key Bindings',
               resizable = True,

               handler   = CodeHandler() )

    def _kb_fired( self, event ):
        key_bindings.edit_traits()


if __name__ == '__main__':
    KBCodeExample().configure_traits()


########NEW FILE########
__FILENAME__ = mixed_styles
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# mixed_styles.py -- Example of using editor styles at various levels

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Enum
from traitsui.api import View, Group, Item

#--[Code]-----------------------------------------------------------------------

class MixedStyles(HasTraits):
   first_name = Str
   last_name = Str

   department = Enum("Business", "Research", "Admin")
   position_type = Enum("Full-Time",
                        "Part-Time",
                        "Contract")

   traits_view = View(Group(Item(name='first_name'),
                            Item(name='last_name'),
                            Group(Item(name='department'),
                                  Item(name=
                                          'position_type',
                                       style='custom'),
                                  style='simple')),
                      title='Mixed Styles',
                      style='readonly')

ms = MixedStyles(first_name='Sam', last_name='Smith')
ms.configure_traits()


########NEW FILE########
__FILENAME__ = multiple_views
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# multiple_views.py -- Sample code to demonstrate the use of multiple views

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int
from traitsui.api import View, Item, Group
import traitsui

#--[Code]-----------------------------------------------------------------------

class SimpleEmployee3(HasTraits):
    first_name = Str
    last_name = Str
    department = Str

    employee_number = Str
    salary = Int

    traits_view = View(Group(Item(name = 'first_name'),
                             Item(name = 'last_name'),
                             Item(name = 'department'),
                             label = 'Personnel profile',
                             show_border = True))

    all_view = View(Group(Item(name = 'first_name'),
                          Item(name = 'last_name'),
                          Item(name = 'department'),
                          Item(name = 'employee_number'),
                          Item(name = 'salary'),
                          label = 'Personnel database ' +
                                  'entry',
                          show_border = True))

sam = SimpleEmployee3()
sam.configure_traits()
sam.configure_traits(view='all_view')


########NEW FILE########
__FILENAME__ = multi_object_view
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# multi_object_view.py -- Sample code to show multi-object view with context

#--[Imports]--------------------------------------------------------------------
from traits.api import HasTraits, Str, Int, Bool
from traitsui.api import View, Group, Item

#--[Code]-----------------------------------------------------------------------

# Sample class
class House(HasTraits):
   address  = Str
   bedrooms = Int
   pool     = Bool
   price    = Int

# View object designed to display two objects of class 'House'
comp_view = View(
    Group(
        Group(
            Item('h1.address', resizable=True),
            Item('h1.bedrooms'),
            Item('h1.pool'),
            Item('h1.price'),
            show_border=True
        ),
        Group(
            Item('h2.address', resizable=True),
            Item('h2.bedrooms'),
            Item('h2.pool'),
            Item('h2.price'),
            show_border=True
        ),
        orientation = 'horizontal'
    ),
    title = 'House Comparison'
)

# A pair of houses to demonstrate the View
house1 = House(address  = '4743 Dudley Lane',
               bedrooms = 3,
               pool     = False,
               price    = 150000)
house2 = House(address  ='11604 Autumn Ridge',
               bedrooms = 3,
               pool     = True,
               price    = 200000)

# ...And the actual display command
house1.configure_traits(view=comp_view, context={'h1':house1, 'h2':house2})


########NEW FILE########
__FILENAME__ = override_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# override_editor.py --- Example of overriding a trait
#                        editor
from traits.api import HasTraits, Trait, Color
from traitsui.api import ColorEditor

class Polygon(HasTraits):
    line_color = Trait(Color((0, 0, 0)),
                       editor=ColorEditor())

Polygon().configure_traits()

########NEW FILE########
__FILENAME__ = tree_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# tree_editor.py -- Example of a tree editor

#--[Imports]--------------------------------------------------------------------
from traits.api \
    import HasTraits, Str, Regex, List, Instance
from traitsui.api \
    import TreeEditor, TreeNode, View, Item, VSplit, \
           HGroup, Handler, Group
from traitsui.menu \
    import Menu, Action, Separator
try:
    from traitsui.wx.tree_editor \
        import NewAction, CopyAction, CutAction, \
            PasteAction, DeleteAction, RenameAction
except RuntimeError:
    from traitsui.qt4.tree_editor \
        import NewAction, CopyAction, CutAction, \
            PasteAction, DeleteAction, RenameAction
#--[Code]-----------------------------------------------------------------------

# DATA CLASSES

class Employee ( HasTraits ):
    name  = Str( '<unknown>' )
    title = Str
    phone = Regex( regex = r'\d\d\d-\d\d\d\d' )

    def default_title ( self ):
        self.title = 'Senior Engineer'

class Department ( HasTraits ):
    name      = Str( '<unknown>' )
    employees = List( Employee )

class Company ( HasTraits ):
    name        = Str( '<unknown>' )
    departments = List( Department )
    employees   = List( Employee )

class Owner ( HasTraits ):
    name    = Str( '<unknown>' )
    company = Instance( Company )

# INSTANCES

jason = Employee(
     name  = 'Jason',
     title = 'Engineer',
     phone = '536-1057' )

mike = Employee(
     name  = 'Mike',
     title = 'Sr. Marketing Analyst',
     phone = '536-1057' )

dave = Employee(
     name  = 'Dave',
     title = 'Sr. Engineer',
     phone = '536-1057' )

susan = Employee(
     name  = 'Susan',
     title = 'Engineer',
     phone = '536-1057' )

betty = Employee(
     name  = 'Betty',
     title = 'Marketing Analyst' )

owner = Owner(
    name    = 'wile',
    company = Company(
        name = 'Acme Labs, Inc.',
        departments = [
            Department(
                name = 'Marketing',
                employees = [ mike, betty ]
            ),
            Department(
                name = 'Engineering',
                employees = [ dave, susan, jason ]
            )
        ],
        employees = [ dave, susan, mike, betty, jason ]
    )
)

# View for objects that aren't edited
no_view = View()

# Actions used by tree editor context menu

def_title_action = Action(name='Default title',
                          action = 'object.default')

dept_action = Action(
    name='Department',
    action='handler.employee_department(editor,object)')

# View used by tree editor
employee_view = View(
    VSplit(
        HGroup( '3', 'name' ),
        HGroup( '9', 'title' ),
        HGroup( 'phone' ),
        id = 'vsplit' ),
    id = 'traits.doc.example.treeeditor',
    dock = 'vertical' )

class TreeHandler ( Handler ):

    def employee_department ( self, editor, object ):
        dept = editor.get_parent( object )
        print '%s works in the %s department.' %\
            ( object.name, dept.name )

# Tree editor
tree_editor = TreeEditor(
    nodes = [
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = '',
                  label     = 'name',
                  view      = View( Group('name',
                                   orientation='vertical',
                                   show_left=True )) ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'departments',
                  label     = '=Departments',
                  view      = no_view,
                  add       = [ Department ] ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'employees',
                  label     = '=Employees',
                  view      = no_view,
                  add       = [ Employee ] ),
        TreeNode( node_for  = [ Department ],
                  auto_open = True,
                  children  = 'employees',
                  label     = 'name',
                  menu      = Menu( NewAction,
                                    Separator(),
                                    DeleteAction,
                                    Separator(),
                                    RenameAction,
                                    Separator(),
                                    CopyAction,
                                    CutAction,
                                    PasteAction ),
                  view      = View( Group ('name',
                                   orientation='vertical',
                                   show_left=True )),
                  add       = [ Employee ] ),
        TreeNode( node_for  = [ Employee ],
                  auto_open = True,
                  label     = 'name',
                  menu=Menu( NewAction,
                             Separator(),
                             def_title_action,
                             dept_action,
                             Separator(),
                             CopyAction,
                             CutAction,
                             PasteAction,
                             Separator(),
                             DeleteAction,
                             Separator(),
                             RenameAction ),
                  view = employee_view )
    ]
)
# The main view
view = View(
           Group(
               Item(
                    name = 'company',
                    id = 'company',
                    editor = tree_editor,
                    resizable = True ),
                orientation = 'vertical',
                show_labels = True,
                show_left = True, ),
            title = 'Company Structure',
            id = \
             'traitsui.tests.tree_editor_test',
            dock = 'horizontal',
            drop_class = HasTraits,
            handler = TreeHandler(),
            buttons = [ 'Undo', 'OK', 'Cancel' ],
            resizable = True,
            width = .3,
            height = .3 )

if __name__ == '__main__':
    owner.configure_traits( view = view )


########NEW FILE########
__FILENAME__ = view_attributes
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# view_attributes.py --- Example of a view as an
#                        attribute of a class
from traits.api import HasTraits, Int, Str, Trait
from traitsui.api import View

class Person(HasTraits):
    first_name = Str
    last_name = Str
    age = Int
    gender = Trait(None, 'M', 'F')
    name_view = View('first_name', 'last_name')

bill = Person()
bill.configure_traits()

########NEW FILE########
__FILENAME__ = view_multi_object
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# view_multi_object.py --- Example of a view for
#                          editing multiple objects
import wx
from traits.api import HasTraits, Int, Str, Trait
from traitsui.api import View
import traitsui

class Person(HasTraits):
    first_name = Str
    last_name = Str

class Company(HasTraits):
    company_name = Str

# Standalone View object referencing objects in the UI context
employee_view = View('e.first_name', 'e.last_name',
                     'c.company_name')

bill = Person(first_name='Bill')
acme = Company(company_name='Acme Products')

class TraitApp ( wx.App ):

    def __init__ ( self, obj1, obj2, view ):
        self.obj1 = obj1
        self.obj2 = obj2
        self.view = view
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()

    def OnInit ( self ):
        # This is the call to the ui() method, which includes a
        # context dictionary
        ui = self.view.ui({'e':self.obj1, 'c':self.obj2})
        self.SetTopWindow( ui.control )
        return True


#  Main program:
TraitApp( bill, acme, employee_view )


########NEW FILE########
__FILENAME__ = view_standalone
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# view_standalone.py --- Example of a view as a
#                        standalone object
import wx
from traits.api import HasTraits, Int, Str, Trait
from traitsui.api import View

class Person(HasTraits):
    first_name = Str
    last_name = Str
    age = Int
    gender = Trait(None, 'M', 'F')
    name_view = View('first_name', 'last_name')

# Note that person_view is a standalone object.
person_view = View('first_name', 'last_name', 'age', 'gender')

bill = Person()

class TraitApp ( wx.App ):

    def __init__ ( self, object, view ):
        self.object = object
        self.view = view
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()

    def OnInit ( self ):
        # This is the call to the ui() method.
        ui = self.view.ui(self.object)
        self.SetTopWindow( ui.control )
        return True


#  Main program:
TraitApp( bill, person_view )

########NEW FILE########
__FILENAME__ = wizard
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

# wizard.py ---Example of a traits-based wizard UI
from traits.api import HasTraits, Int, Str

class Person(HasTraits):
    name = Str
    age = Int
    street = Str
    city = Str
    state = Str
    pcode = Str

bill = Person()
bill.configure_traits()

########NEW FILE########
__FILENAME__ = buttons
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(View Default Button Changes)------------------------------------------------
"""
View Default Button Changes
===========================

For the last year or so, use of the following **View** traits for managing the
default buttons displayed at the bottom of a view has been deprecated:

- apply
- revert
- undo
- ok
- cancel

Use of these traits has been supplanted by use of the *buttons* trait instead.

As part of the ongoing phasing out of these traits, the following changes have
been implemented in Traits 3.0:

- All use of the *apply*, *revert*, *undo*, *ok* and *cancel* traits have been
  removed from views contained within the traits package itself, and have been
  replaced with the *buttons* trait.

- The default value for each of the deprecated traits has been changed from
  **True** to **False**.

While use of the deprecated **View** traits is still allowed at the moment, the
affect of these changes could cause changes in behavior within existing code
that has not yet removed references to the deprecated traits.

In particular, the most likely side effect is for some or all of the default
**View** buttons to disappear from views which are implicitly relying on the
default values for each of the deprecated traits. Views which explicitly set
the deprecated **View** traits or use the newer *buttons* trait should not be
affected.

The correct fix for any **View** which has buttons disappear after installing
Traits 3.0 is to add a *buttons* trait with the correct value set to the
**View**.

Note that in a future release, the deprecated view traits will actually be
removed from the **View** class.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *
from traitsui.api import *

#--[Adder Class]----------------------------------------------------------------

# Click the run button to view the pop-up dialog...

class Adder ( HasTraits ):

    value_1 = Float
    value_2 = Float
    sum     = Property( depends_on = [ 'value_1', 'value_2' ] )

    view = View(
        Item( 'value_1' ),
        Item( 'value_2' ),
        '_',
        Item( 'sum', style = 'readonly' ),
        title   = 'Adding Machine',
        buttons = [ 'OK' ]
    )

    def _get_sum ( self ):
        return (self.value_1 + self.value_2)

#--<Example>--------------------------------------------------------------------

popup = Adder()


if __name__ == '__main__':
    popup.configure_traits()

########NEW FILE########
__FILENAME__ = deferred
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Deferred UI Notifications)--------------------------------------------------
"""
Deferred UI Notifications
=========================

In Traits 3.0, a change has been made to the way that events are handled in the
Traits UI that should improve the performance and responsive of Traits-based
user interfaces in certain important situations.

In particular, changes made to the underlying model being displayed by a Traits
UI are no longer reflected immediately in the user interface, but are instead
queued up to be processed by the UI thread at its first available opportunity.

More precisely, the first time that a user interface related model trait is
modified, an event requesting a user interface update is generated containing
the old and new values of the trait. Subsequent changes to the same model trait
result in no new events being generated, but instead simply update the original
event information with the latest value of the modified trait.

Eventually the UI thread will process the original event, at which point it will
update the user interface using the original old value of the trait along with
the latest new value.

Although this may sound like it should slow down user interface updates, in many
cases where a model is being rapidly updated by calculations running either on a
background or UI thread, it should actually appear to make the system more
responsive, and should in fact, help prevent or reduce situations where the user
interface would previously have appeared to be unresponsive due to an excessive
number of screen updates.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *
from traitsui.api import *

#--[Count Class]----------------------------------------------------------------

class Count ( HasTraits ):

    count = Int
    go    = Button( 'Count' )

    view = View(
        Item( 'count', style = 'readonly' ),
        Item( 'go', show_label = False )
    )

    def _go_changed ( self ):
        # Even though the 'count' trait (which is visible in the UI) is being
        # rapidly updated here, the UI should show only a single update each
        # time the 'Count' button is clicked. In previous Traits versions, the
        # user would actually see the counter update sequentially through all
        # 10,000 values, during which time the user interface would be
        # unresponsive:
        for i in range( 10000 ):
            self.count += 1

#--<Example*>-------------------------------------------------------------------

demo = Count()


if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = animated_gif
#--(Animated GIF Editor)--------------------------------------------------------
"""
Animated GIF Editor
===================

In Traits 3.0, a new **AnimatedGIFEditor** has been added to the Traits UI
package. The purpose of the editor is to allow inclusion of simple animated
graphics into a traits UI via the use of animated GIF files.

The traits supported by the **AnimatedGIFEditor** editor are as follows:

playing
    A string that specifies the extended name of a trait that specifies whether
    the animated GIF file is playing or not. If not specified, the default is to
    play the animated GIF file endlessly.

The value associated with **AnimatedGIFEditor** should be the name of the
animated GIF image file to be displayed. No user editing of the value is
provided by this editor, it is display only.
"""

#--[Imports]--------------------------------------------------------------------

from os.path \
    import join, dirname

from traits.api \
    import HasTraits, File, Bool, Int

from traitsui.api \
    import View, VGroup, HGroup, Item, EnumEditor

from traitsui.wx.animated_gif_editor \
    import AnimatedGIFEditor

#--[Setup]----------------------------------------------------------------------

# Some sample animated GIF files:
import traitsui as ui

base_path = join( dirname( ui.__file__ ), 'demo', 'Extras', 'images' )

# Get the names of the animated GIF files that can be displayed:
files = [
    join( base_path, 'logo_64x64.gif' ),
    join( base_path, 'logo_48x48.gif' ),
    join( base_path, 'logo_32x32.gif' )
]

#--[AnimatedGIFDemo Class]------------------------------------------------------

class AnimatedGIFDemo ( HasTraits ):

    # The animated GIF file to display:
    gif_file = File( files[0] )

    # Is the animation playing or not?
    playing = Bool( True )

    # The traits view:
    view = View(
        VGroup(
            HGroup(
                Item( 'gif_file',
                      editor     = AnimatedGIFEditor( playing = 'playing' ),
                      show_label = False ),
                Item( 'playing' ),
            ),
            '_',
            Item( 'gif_file',
                  label  = 'GIF File',
                  editor = EnumEditor( values = files )
            )
        ),
        title     = 'Animated GIF Demo',
        resizable = True,
        buttons   = [ 'OK' ]
    )

#--<Example*>-------------------------------------------------------------------

demo = AnimatedGIFDemo()


########NEW FILE########
__FILENAME__ = flash
#--(Flash Editor (Windows Only))------------------------------------------------
"""
Flash Editor (Windows Only)
===========================

In Traits 3.0, a new **FlashEditor** has been added to the Traits UI package.
The editor allows displaying and interacting with Adobe Flash compatible files.

This editor is currently only available for the Windows platform and is
located in the wxPython version of the Traits UI in the
*traitsui.wx.extras.windows* package. The purpose of the
*extras.windows* package is to provide a location for editors which may be
toolkit and Windows platform specific, and not necessarily available in all
Traits UI toolkit packages or platforms.

The **FlashEditor** has no developer settable traits.

The value edited by a **FlashEditor** should be a string containing either the
URL or file name of the Flash file to display. This is a *read only* value that
is not modified by the editor. Changing the value causes the editor to display
the Flash file defined by the new value of the trait.
"""

#--[Imports]--------------------------------------------------------------------

from traitsui.wx.extra.windows.flash_editor \
    import FlashEditor

from traits.api \
    import HasTraits, Enum

from traitsui.api \
    import View, HGroup, Item

#--[FlashDemo Class]------------------------------------------------------------

class FlashDemo ( HasTraits ):

    # The Flash file to display:
    flash = Enum(
        'http://www.ianag.com/arcade/swf/sudoku.swf',
        'http://www.ianag.com/arcade/swf/f-336.swf',
        'http://www.ianag.com/arcade/swf/f-3D-Reversi-1612.swf',
        'http://www.ianag.com/arcade/swf/game_234.swf',
        'http://www.ianag.com/arcade/swf/flashmanwm.swf',
        'http://www.ianag.com/arcade/swf/2379_gyroball.swf',
        'http://www.ianag.com/arcade/swf/f-1416.swf',
        'http://www.ianag.com/arcade/swf/mah_jongg.swf',
        'http://www.ianag.com/arcade/swf/game_e4fe4e55fedc2f502be627ee6df716c5.swf',
        'http://www.ianag.com/arcade/swf/rhumb.swf'
    )

    # The view to display:
    view = View(
        HGroup(
            Item( 'flash', label = 'Pick a game to play' )
        ),
        '_',
        Item( 'flash',
              show_label = False,
              editor     = FlashEditor()
        )
    )

#--<Example*>-------------------------------------------------------------------

demo = FlashDemo()


########NEW FILE########
__FILENAME__ = ie_html
#--(Internet Explorer HTML Editor (Windows Only))-------------------------------
"""
Internet Explorer HTML Editor (Windows Only)
============================================

In Traits 3.0, a new **IEHTMLEditor** has been added to the Traits UI package.
The editor allows displaying (but not editing) HTML pages using the Microsoft
Internet Explorer browser.

This editor is currently only available for the Windows platform and is
located in the wxPython version of the Traits UI in the
*traitsui.wx.extras.windows* package. The purpose of the
*extras.windows* package is to provide a location for editors which may be
toolkit and Windows platform specific, and not necessarily available in all
Traits UI toolkit packages or platforms.

The traits supported by the **IEHTMLEditor** editor are as follows:

home
    A string specifying the optional extended name of a trait event used to tell
    Internet Explorer to display the user's home page. Set the specified trait
    to **True** to cause the browser to display the user's home page.

back
    A string specifying the optional extended name of a trait event used to tell
    Internet Explorer to display the previous browser page. Set the specified
    trait to **True** to cause the browser to display the previous browser page.

forward
    A string specifying the optional extended name of a trait event used to tell
    Internet Explorer to display the next (i.e. forward) browser page. Set the
    specified trait to **True** to cause the browser to display the next browser
    page (if available).

stop
    A string specifying the optional extended name of a trait event used to tell
    Internet Explorer to stop loading the current page. Set the specified trait
    to **True** to cause the browser to stop loading the current page.

refresh
    A string specifying the optional extended name of a trait event used to tell
    Internet Explorer to refresh the current page. Set the specified trait to
    **True** to cause the browser to refresh the current page.

search
    A string specifying the optional extended name of a trait event used to tell
    Internet Explorer to initiate a search of the current page. Set the
    specified trait to **True** to cause the browser to start a search of the
    current page.

status
    A string specifying the optional extended name of a trait used contain the
    current Internet Explorer status. This trait is automatically updated by the
    browser as its internal status changes.

title
    A string specifying the optional extended name of a trait used contain the
    current Internet Explorer page title. This trait is automatically updated by
    the browser as the current page title is changed.

page_loaded
    A string specifying the optional extended name of a trait used contain the
    URL of the current Internet Explorer page. This trait is automatically
    updated by the browser as a page is loaded.

html
    A string specifying the optional extended name of a trait used to get or
    set the HTML page content of the current Internet Explorer page. This
    trait is automatically updated by the browser as a page is loaded, and can
    also be set by an application to cause the browser to display the content
    provided.

The value edited by an **IEHTMLEditor** should be a string containing either the
URL or file name of the file that Internet Explorer should display. This is a
*read only* value that is not modified by the editor. Changing the value causes
the browser to display the page defined by the new value of the trait.
"""

#--[Imports]--------------------------------------------------------------------

from traitsui.wx.extra.windows.ie_html_editor \
    import IEHTMLEditor

from traits.api \
    import HasTraits, Str, List, Button

from traitsui.api \
    import View, VGroup, HGroup, Item, TextEditor, ListEditor, spring

#--[WebPage Class]--------------------------------------------------------------

class WebPage ( HasTraits ):

    # The URL to display:
    url = Str( 'http://code.enthought.com' )

    # The page title:
    title = Str

    # The page status:
    status = Str

    # The browser navigation buttons:
    back    = Button( '<--' )
    forward = Button( '-->' )
    home    = Button( 'Home' )
    stop    = Button( 'Stop' )
    refresh = Button( 'Refresh' )
    search  = Button( 'Search' )

    # The view to display:
    view = View(
        HGroup( 'back', 'forward', 'home', 'stop', 'refresh', 'search', '_',
                Item( 'status', style = 'readonly' ),
                show_labels = False
        ),
        Item( 'url',
              show_label = False,
              editor     = IEHTMLEditor(
                               home    = 'home',    back   = 'back',
                               forward = 'forward', stop   = 'stop',
                               refresh = 'refresh', search = 'search',
                               title   = 'title',   status = 'status' )
        )
    )

#--[InternetExplorerDemo Class]-------------------------------------------------

class InternetExplorerDemo ( HasTraits ):

    # A URL to display:
    url = Str( 'http://' )

    # The list of web pages being browsed:
    pages = List( WebPage )

    # The view to display:
    view = View(
        VGroup(
            Item( 'url',
                  label  = 'Location',
                  editor = TextEditor( auto_set = False, enter_set = True )
            )
        ),
        Item( 'pages',
              show_label = False,
              style      = 'custom',
              editor     = ListEditor( use_notebook = True,
                                       deletable    = True,
                                       dock_style   = 'tab',
                                       export       = 'DockWindowShell',
                                       page_name    = '.title' )
        )
    )

    # Event handlers:
    def _url_changed ( self, url ):
        self.pages.append( WebPage( url = url.strip() ) )

#--(Demo Notes)-----------------------------------------------------------------

"""
Demo Notes
==========

- Try dragging one of the browser tabs completely out of the tutorial window
  and see what happens...

- Then, just for fun, try dragging it back...
"""

#--<Example*>-------------------------------------------------------------------

demo = InternetExplorerDemo(
           pages = [ WebPage( url = 'http://code.enthought.com/traits/' ),
                     WebPage( url = 'http://dmorrill.com' ) ] )


########NEW FILE########
__FILENAME__ = led
#--(LED Editor)-----------------------------------------------------------------
"""
LED Editor
==========

In Traits 3.0, a new **LEDEditor** has been added to the Traits UI package. The
editor allows displaying (but not editing) numeric values using a set of
simulated LEDs.

This editor is currently only available in the wxPython version of the Traits UI
in the *traitsui.wx.extras* package. The purpose of the *extras*
package is to provide a location for editors which may be toolkit specific, and
not necessarily available in all Traits UI toolkit packages.

The traits supported by the **LEDEditor** editor are as follows:

alignment
    Specifies the alignment of the numeric text within the control. The possible
    values are: *right* (the default), *left* and *center*.

The value edited by an **LEDEditor** should be an integer or float value,
or a string value containing only characters that would be found in an interger
or float value.
"""

#--[Imports]--------------------------------------------------------------------

from threading \
    import Thread

from time \
    import sleep

from traits.api \
    import HasTraits, Instance, Int, Float, Bool

from traitsui.api \
    import View, Item, HGroup, Handler, UIInfo, spring

from traitsui.wx.extra.led_editor \
    import LEDEditor

#--[LEDDemoHandler Class]-------------------------------------------------------

# Handler class for the LEDDemo class view:
class LEDDemoHandler ( Handler ):

    # The UIInfo object associated with the UI:
    info = Instance( UIInfo )

    # Is the demo currently running:
    running = Bool( True )

    # Is the thread still alive?
    alive = Bool( True )

    def init ( self, info ):
        self.info = info
        Thread( target = self._update_counter ).start()

    def closed ( self, info, is_ok ):
        self.running = False
        while self.alive:
            sleep( .05 )

    def _update_counter ( self ):
        while self.running:
            self.info.object.counter1 += 1
            self.info.object.counter2 += .001
            sleep( .01 )
        self.alive = False

#--[LEDDemo Class]--------------------------------------------------------------

# The main demo class:
class LEDDemo ( HasTraits ):

    # A counter to display:
    counter1 = Int

    # A floating point value to display:
    counter2 = Float

    # The traits view:
    view = View(
        Item( 'counter1',
              label  = 'Left aligned',
              editor = LEDEditor( alignment = 'left' )
        ),
        Item( 'counter1',
              label  = 'Center aligned',
              editor = LEDEditor( alignment = 'center' )
        ),
        Item( 'counter1',
              label  = 'Right aligned',
              editor = LEDEditor()  # default = 'right' aligned
        ),
        Item( 'counter2',
              label  = 'Float value',
              editor = LEDEditor( format_str = '%.3f' )
        ),
        '_',
        HGroup(
            Item( 'counter1',
                  label  = 'Left',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor( alignment = 'left' )
            ),
            spring,
            Item( 'counter1',
                  label  = 'Center',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor( alignment = 'center' )
            ),
            spring,
            Item( 'counter1',
                  label  = 'Right',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor()  # default = 'right' aligned
            ),
            spring,
            Item( 'counter2',
                  label  = 'Float',
                  height = -40,
                  width  = 120,
                  editor = LEDEditor( format_str = '%.3f' )
            )
        ),
        title   = 'LED Editor Demo',
        buttons = [ 'OK' ],
        handler = LEDDemoHandler
    )

#--<Example*>-------------------------------------------------------------------

demo = LEDDemo()


########NEW FILE########
__FILENAME__ = numpy_array
#--(NumPy Array Example)--------------------------------------------------------
"""
This lesson demonstrates how the **TabularEditor** can be used to display
(large) NumPy arrays. In this example, the array consists of 100,000 random 3D
points from a unit cube.

In addition to showing the coordinates of each point, the example code also
displays the index of each point in the array, as well as a red flag if the
point lies within 0.25 of the center of the cube.

As with the other tabular editor tutorials, this example shows how to set up a
**TabularEditor** and create an appropriate **TabularAdapter** subclass.

In this case, it also shows:

- An example of using array indices as *column_id* values.
- Using the *format* trait to format the numeric values for display.
- Creating a *synthetic* index column for displaying the point's array index
  (the *index_text* property), as well as a flag image for points close to the
  cube's center (the *index_image* property).
"""

#--<Imports>--------------------------------------------------------------------

from os.path \
    import join, dirname

from numpy \
    import sqrt

from numpy.random \
    import random

from traits.api \
    import HasTraits, Property, Array

from traitsui.api \
    import View, Item, TabularEditor

from traitsui.tabular_adapter \
    import TabularAdapter

from traitsui.menu \
    import NoButtons

from pyface.image_resource \
    import ImageResource

#--<Constants>------------------------------------------------------------------

# Necessary because of the dynamic way in which the demos are loaded:
import traitsui.api

search_path = [ join( dirname( traitsui.api.__file__ ),
                      'demo', 'Advanced' ) ]

#--[Tabular Adapter Definition]-------------------------------------------------

class ArrayAdapter ( TabularAdapter ):

    columns = [ ( 'i', 'index' ), ( 'x', 0 ), ( 'y', 1 ),  ( 'z', 2 ) ]

    font        = 'Courier 10'
    alignment   = 'right'
    format      = '%.4f'
    index_text  = Property
    index_image = Property

    def _get_index_text ( self ):
        return str( self.row )

    def _get_index_image ( self ):
        x, y, z = self.item
        if sqrt( (x - 0.5) ** 2 + (y - 0.5) ** 2 + (z - 0.5) ** 2 ) <= 0.25:
            return 'red_flag'
        return None

#--[Tabular Editor Definition]--------------------------------------------------

tabular_editor = TabularEditor(
    adapter = ArrayAdapter(),
    images  = [ ImageResource( 'red_flag', search_path = search_path ) ]
)

#--[ShowArray Class]------------------------------------------------------------

class ShowArray ( HasTraits ):

    data = Array

    view = View(
        Item( 'data', editor = tabular_editor, show_label = False ),
        title     = 'Array Viewer',
        width     = 0.3,
        height    = 0.8,
        resizable = True,
        buttons   = NoButtons
    )

#--[Example Code*]--------------------------------------------------------------

demo = ShowArray( data = random( ( 100000, 3 ) ) )


########NEW FILE########
__FILENAME__ = python_source_browser
#--(Python Source Browser Example)----------------------------------------------
"""
This lesson shows a combination of the **DirectoryEditor**, the
**TabularEditor** and the **CodeEditor** used together to create a very simple
Python source browser. In the **Demo** tab you can:

- Use the **DirectoryEditor** on the left to navigate to and select
  directories containing Python source files.
- Use the **TabularEditor** on the top-right to view information about and
  to select Python source files in the currently selected directory.
- View the currently selected Python source file's contents in the
  **CodeEditor** in the bottom-right.

As an extra *feature*, the **TabularEditor** also displays a:

- Red ball if the file size > 64KB.
- Blue ball if the file size > 16KB.

As with the *Single and Married Person Example* tutorial, this example shows you
how to:

- Set up a **TabularEditor**.
- Define a **TabularAdapter** subclass that meets the display requirements of
  the application.

In this example, please note the use of the *even_bg_color* trait in the
**FileInfoAdapter** adapter class to set up alternating line colors in the table
for improved readability.

Also note that the *name*, *size*, *time* and *date* columns define *column_id*
values which correspond directly with traits defined in the **FileInfo** class,
but the *big* column id is an artifical column defined to display the file size
related *blue ball* and *red ball* images when the file size exceeds various
thresholds. The column id is used simply to provide a name reference for the
related trait and property definitions in the adapter class itself.
"""

#--<Imports>--------------------------------------------------------------------

import traits
import traitsui

import wx

from time \
    import localtime, strftime

from os \
    import listdir

from os.path \
    import getsize, getmtime, isfile, join, splitext, basename, dirname

from traits.api \
    import HasPrivateTraits, Str, Float, List, Directory, File, Code, \
           Instance, Property, cached_property

from traitsui.api \
    import View, Item, HSplit, VSplit, TabularEditor

from traitsui.tabular_adapter \
    import TabularAdapter

from pyface.image_resource \
    import ImageResource

#--<Constants>------------------------------------------------------------------

# Necessary because of the dynamic way in which the demos are loaded:
search_path = [ join( dirname( traitsui.api.__file__ ),
                      'demo', 'Applications' ) ]

#--[FileInfo Class]-------------------------------------------------------------

class FileInfo ( HasPrivateTraits ):

    file_name = File
    name      = Property
    size      = Property
    time      = Property
    date      = Property

    @cached_property
    def _get_name ( self ):
        return basename( self.file_name )

    @cached_property
    def _get_size ( self ):
        return getsize( self.file_name )

    @cached_property
    def _get_time ( self ):
        return strftime( '%I:%M:%S %p',
                         localtime( getmtime( self.file_name ) ) )

    @cached_property
    def _get_date ( self ):
        return strftime( '%m/%d/%Y',
                         localtime( getmtime( self.file_name ) ) )

#--[FileInfoAdapter Class]------------------------------------------------------

class FileInfoAdapter ( TabularAdapter ):

    columns = [ ( 'File Name', 'name' ),
                ( 'Size',      'size' ),
                ( '',          'big'  ),
                ( 'Time',      'time' ),
                ( 'Date',      'date' ) ]

    even_bg_color  = wx.Colour( 201, 223, 241 )
    font           = 'Courier 10'
    size_alignment = Str( 'right' )
    time_alignment = Str( 'right' )
    date_alignment = Str( 'right' )
    big_text       = Str
    big_width      = Float( 18 )
    big_image      = Property

    def _get_big_image ( self ):
        size = self.item.size
        if size > 65536:
            return 'red_ball'

        return ( None, 'blue_ball' )[ size > 16384 ]

#--[Tabular Editor Definition]--------------------------------------------------

tabular_editor = TabularEditor(
    editable   = False,
    selected   = 'file_info',
    adapter    = FileInfoAdapter(),
    operations = [],
    images     = [ ImageResource( 'blue_ball', search_path = search_path ),
                   ImageResource( 'red_ball',  search_path = search_path ) ]
)

#--[PythonBrowser Class]--------------------------------------------------------

class PythonBrowser ( HasPrivateTraits ):

    dir       = Directory
    files     = List( FileInfo )
    file_info = Instance( FileInfo )
    code      = Code

    view = View(
        HSplit(
            Item( 'dir', style = 'custom' ),
            VSplit(
                Item( 'files', editor = tabular_editor ),
                Item( 'code',  style = 'readonly' ),
                show_labels = False ),
            show_labels = False
        ),
        resizable = True,
        width     = 0.75,
        height    = 0.75
    )

    #-- Event Handlers ---------------------------------------------------------

    def _dir_changed ( self, dir ):
        self.files = [ FileInfo( file_name = join( dir, name ) )
                       for name in listdir( dir )
                       if ((splitext( name )[1] == '.py') and
                           isfile( join( dir, name ) )) ]

    def _file_info_changed ( self, file_info ):
        fh = None
        try:
            fh = open( file_info.file_name, 'rb' )
            self.code = fh.read()
        except:
            pass

        if fh is not None:
            fh.close()

#--[Example*]-------------------------------------------------------------------

demo = PythonBrowser( dir = dirname( traits.api.__file__ ) )


########NEW FILE########
__FILENAME__ = sm_person_example
#--(Single/Married Person Example)----------------------------------------------
"""
This lesson contains a tabular editor example based upon the **Person** and
**MarriedPerson** example presented in the *Tabular Editor Introduction*
tutorial.

This example defines three main classes:

- **Person**: A single person.
- **MarriedPerson**: A married person (a subclass of **Person**).
- **Report**: A report based on a list of single and married people.

The example code creates a tabular display of 10,000 single and married people
showing the following information:

- Name of the person.
- Age of the person.
- The person's address.
- The name of the person's spouse (if any).

In addition:

- It uses a Courier 10 point font for each line in the table.
- It displays the age column right, instead of left, justified.
- If a person is a minor (age < 18) and married, it displays a red flag
  image in the age column.
- If the person is married, it makes the background color for that row a light
  blue.

This example demonstrates:

- How to set up a **TabularEditor**.
- The display speed of the **TabularEditor**.
- How to create a **TabularAdapter** that meets each of the specified display
  requirements.

Additional notes:

- You can change the current selection using the up and down arrow keys.
- You can move a selected row up and down in the table using the left and
  right arrow keys.
"""

#--<Imports>--------------------------------------------------------------------

from os.path \
    import join, dirname

from random \
    import randint, choice, shuffle

from traits.api \
    import HasTraits, Str, Int, List, Instance, Property, Constant, Color

from traitsui.api \
    import View, Group, Item, Margin, TabularEditor

from traitsui.tabular_adapter \
    import TabularAdapter

from traitsui.menu \
    import NoButtons

from pyface.image_resource \
    import ImageResource

#--<Constants>------------------------------------------------------------------

# Necessary because of the dynamic way in which the demos are loaded:
import traitsui.api

search_path = [ join( dirname( traitsui.api.__file__ ),
                      'demo', 'Advanced' ) ]

#--[Person Class]---------------------------------------------------------------

class Person ( HasTraits ):

    name    = Str
    address = Str
    age     = Int

#--[MarriedPerson Class]--------------------------------------------------------

class MarriedPerson ( Person ):

    partner = Instance( Person )

#--[Tabular Adapter Definition]-------------------------------------------------

class ReportAdapter ( TabularAdapter ):

    columns = [ ( 'Name',    'name' ),
                ( 'Age',     'age' ),
                ( 'Address', 'address' ),
                ( 'Spouse',  'spouse' ) ]

    font                      = 'Courier 10'
    age_alignment             = Constant( 'right' )
    MarriedPerson_age_image   = Property
    MarriedPerson_bg_color    = Color( 0xE0E0FF )
    MarriedPerson_spouse_text = Property
    Person_spouse_text        = Constant( '' )

    def _get_MarriedPerson_age_image ( self ):
        if self.item.age < 18:
            return 'red_flag'
        return None

    def _get_MarriedPerson_spouse_text ( self ):
        return self.item.partner.name

#--[Tabular Editor Definition]--------------------------------------------------

tabular_editor = TabularEditor(
    adapter    = ReportAdapter(),
    operations = [ 'move' ],
    images     = [ ImageResource( 'red_flag', search_path = search_path ) ],
)

#--[Report Class]---------------------------------------------------------------

class Report ( HasTraits ):

    people = List( Person )

    view = View(
        Group(
            Item( 'people', id = 'table', editor = tabular_editor ),
            show_labels        = False,
        ),
        title     = 'Tabular Editor Demo',
        id        = 'traitsui.demo.Applications.tabular_editor_demo',
        width     = 0.60,
        height    = 0.75,
        resizable = True,
        buttons   = NoButtons
    )


#--<Generate People>------------------------------------------------------------

male_names = [ 'Michael', 'Edward', 'Timothy', 'James', 'George', 'Ralph',
    'David', 'Martin', 'Bryce', 'Richard', 'Eric', 'Travis', 'Robert', 'Bryan',
    'Alan', 'Harold', 'John', 'Stephen', 'Gael', 'Frederic', 'Eli', 'Scott',
    'Samuel', 'Alexander', 'Tobias', 'Sven', 'Peter', 'Albert', 'Thomas',
    'Horatio', 'Julius', 'Henry', 'Walter', 'Woodrow', 'Dylan', 'Elmer' ]

female_names = [ 'Leah', 'Jaya', 'Katrina', 'Vibha', 'Diane', 'Lisa', 'Jean',
    'Alice', 'Rebecca', 'Delia', 'Christine', 'Marie', 'Dorothy', 'Ellen',
    'Victoria', 'Elizabeth', 'Margaret', 'Joyce', 'Sally', 'Ethel', 'Esther',
    'Suzanne', 'Monica', 'Hortense', 'Samantha', 'Tabitha', 'Judith', 'Ariel',
    'Helen', 'Mary', 'Jane', 'Janet', 'Jennifer', 'Rita', 'Rena', 'Rianna' ]

all_names = male_names + female_names

male_name   = lambda: choice( male_names )
female_name = lambda: choice( female_names )
any_name    = lambda: choice( all_names )
age         = lambda: randint( 15, 72 )

family_name = lambda: choice( [ 'Jones', 'Smith', 'Thompson', 'Hayes', 'Thomas', 'Boyle',
    "O'Reilly", 'Lebowski', 'Lennon', 'Starr', 'McCartney', 'Harrison',
    'Harrelson', 'Steinbeck', 'Rand', 'Hemingway', 'Zhivago', 'Clemens',
    'Heinlien', 'Farmer', 'Niven', 'Van Vogt', 'Sturbridge', 'Washington',
    'Adams', 'Bush', 'Kennedy', 'Ford', 'Lincoln', 'Jackson', 'Johnson',
    'Eisenhower', 'Truman', 'Roosevelt', 'Wilson', 'Coolidge', 'Mack', 'Moon',
    'Monroe', 'Springsteen', 'Rigby', "O'Neil", 'Philips', 'Clinton',
    'Clapton', 'Santana', 'Midler', 'Flack', 'Conner', 'Bond', 'Seinfeld',
    'Costanza', 'Kramer', 'Falk', 'Moore', 'Cramdon', 'Baird', 'Baer',
    'Spears', 'Simmons', 'Roberts', 'Michaels', 'Stuart', 'Montague',
    'Miller' ] )

address = lambda: '%d %s %s' % ( randint( 11, 999 ), choice( [ 'Spring',
    'Summer', 'Moonlight', 'Winding', 'Windy', 'Whispering', 'Falling',
    'Roaring', 'Hummingbird', 'Mockingbird', 'Bluebird', 'Robin', 'Babbling',
    'Cedar', 'Pine', 'Ash', 'Maple', 'Oak', 'Birch', 'Cherry', 'Blossom',
    'Rosewood', 'Apple', 'Peach', 'Blackberry', 'Strawberry', 'Starlight',
    'Wilderness', 'Dappled', 'Beaver', 'Acorn', 'Pecan', 'Pheasant', 'Owl' ] ),
    choice( [ 'Way', 'Lane', 'Boulevard', 'Street', 'Drive', 'Circle',
    'Avenue', 'Trail' ] ) )

people = [ Person( name    = '%s %s' % ( any_name(), family_name() ),
                   age     = age(),
                   address = address() ) for i in range( 5000 ) ]

marrieds = [ ( MarriedPerson( name    = '%s %s' % ( female_name(), last_name ),
                              age     = age(),
                              address = address ),
               MarriedPerson( name    = '%s %s' % ( male_name(), last_name ),
                              age     = age(),
                              address = address ) )
             for last_name, address in
                 [ ( family_name(), address() ) for i in range( 2500 ) ] ]

for female, male in marrieds:
    female.partner = male
    male.partner   = female
    people.extend( [ female, male ] )

shuffle( people )

#--[Example Code*]--------------------------------------------------------------

demo = Report( people = people )

########NEW FILE########
__FILENAME__ = items
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(Extended Traits UI Item and Editor References)------------------------------
"""
Extended Traits UI Item and Editor References
=============================================

In Traits 3.0, the Traits UI **Item** class and various *editor* classes
have been extended to use the new extended trait name support provided by the
*on_trait_change* method.

In previous Traits versions, for example, **Item** objects could only refer to
traits defined directly on a UI context object. For example::

    view = View(
        Item( 'name' ),
        Item( 'object.age' ),
        Item( 'handler.status' )
    )

In Traits 3.0 this restriction has been lifted, and now **Items** can reference
(i.e. edit) any trait reachable from a UI context object::

    view = View(
        Item( 'object.mother.name' ),
        Item( 'object.axel.chassis.serial_number', style = 'readonly' )
    )

Similarly, any Traits UI *editor* classes that previously accepted a trait name
now accept an extended trait name::

    view = View(
        Item( 'address' ),
        Item( 'state', editor = EnumEditor( name = 'handler.country.states' )
    )

Because **Items** and *editors* only refer to a single trait, you should not use
extended trait references that refer to multiple traits, such as
*'foo.[bar,baz]'* or *'foo.+editable'*, since the behavior of such references
is not defined.

Look at the code tabs for this lesson for a complete example of a Traits UI
using extended **Item** and editor references. In particular, the
**LeagueModelView Class** tab contains a **View** definition containing
extended references.

Code Incompatibilities
----------------------

Note that the editor enhancement may cause some incompatibities with editors
that previously supported both an *object* and *name* trait, with the *object*
trait containing the context object name, and the *name* trait containing the
name of  the trait on the specified context object. Using the new extended trait
references, these have been combined into a single *name* trait.

If you encounter such an occurrence in existing code, simply combine the
context object name and trait name into a single extended name of the form::

    context_object_name.trait_name

Warning
-------

Avoid extended **Item** references that contain intermediate links that could
be *None*. For example, in the following code::

    view = View(
        ...
        Item( 'object.team.players', ... )
        ...
    )

an exception will be raised if *object.team* is *None*, or is set to *None*,
while the view is active, since there is no obvious way to obtain a valid value
for *object.team.players* for the associated **Item** *editor* to display.

Note that the above example is borrowed from this lesson's demo code, which has
additional code written to ensure that *object.team* is not *None*. See the
*_model_changed* method in the **LeagueModelView Class** tab, which makes sure
that the *team* trait is intialized to a valid value when a new **League**
model is set up.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api \
    import *

from traitsui.api \
    import *

from traitsui.table_column \
    import *

#--[Player Class]---------------------------------------------------------------

# Define a baseball player:
class Player ( HasTraits ):

    # The name of the player:
    name = Str( '<new player>' )

    # The number of hits the player made this season:
    hits = Int

#--[Team Class]-----------------------------------------------------------------

# Define a baseball team:
class Team ( HasTraits ):

    # The name of the team:
    name = Str( '<new team>' )

    # The players on the team:
    players = List( Player )

    # The number of players on the team:
    num_players = Property( depends_on = 'players' )

    def _get_num_players ( self ):
        """ Implementation of the 'num_players' property.
        """
        return len( self.players )

#--[League Class]---------------------------------------------------------------

# Define a baseball league model:
class League ( HasTraits ):

    # The name of the league:
    name = Str( '<new league>' )

    # The teams in the league:
    teams = List( Team )

#--[LeagueModelView Class]-----------------------------------------------------

# Define a ModelView for a League model:
class LeagueModelView ( ModelView ):

    # The currently selected team:
    team = Instance( Team )

    # The currently selected player:
    player = Instance( Player )

    # Button to add a hit to the current player:
    got_hit = Button( 'Got a Hit' )

    # The total number of hits
    total_hits = Property( depends_on = 'model.teams.players.hits' )

    @cached_property
    def _get_total_hits ( self ):
        """ Returns the total number of hits across all teams and players.
        """
        return 0
        return reduce( add, [ reduce( add, [ p.hits for p in t.players ], 0 )
                              for t in self.model.teams ], 0 )

    view = View(
        VGroup(
            HGroup(
                Item( 'total_hits', style = 'readonly' ),
                      label       = 'League Statistics',
                      show_border = True
            ),
            VGroup(
                Item( 'model.teams',
                      show_label = False,
                      editor = TableEditor(
                                columns = [ ObjectColumn( name  = 'name',
                                                          width = 0.70 ),
                                            ObjectColumn( name  = 'num_players',
                                                          label = '# Players',
                                                          editable = False,
                                                          width = 0.29 ) ],
                                selected     = 'object.team',
                                auto_add     = True,
                                row_factory  = Team,
                                configurable = False,
                                sortable     = False )
                ),
                label       = 'League Teams',
                show_border = True
            ),
            VGroup(
                Item( 'object.team.players', # <-- Extended Item name
                      show_label = False,
                      editor = TableEditor(
                                   columns  = [ ObjectColumn( name  = 'name',
                                                              width = 0.70 ),
                                                ObjectColumn( name  = 'hits',
                                                              editable = False,
                                                              width = 0.29 ) ],
                                   selected     = 'object.player',
                                   auto_add     = True,
                                   row_factory  = Player,
                                   configurable = False,
                                   sortable     = False )
                ),
                '_',
                HGroup(
                    Item( 'got_hit',
                          show_label   = False,
                          enabled_when = 'player is not None'
                    )
                ),
                label       = 'Team Players',
                show_labels = False,
                show_border = True
            )
        ),
        resizable = True
    )

    def _model_changed ( self, model ):
        """ Handles the 'league' model being initialized.
        """
        if len( model.teams ) > 0:
            self.team = model.teams[0]

    def _got_hit_changed ( self ):
        """ Handles the currently selected player making a hit.
        """
        self.player.hits += 1

    def _team_changed ( self, team ):
        """ Handles a new team being selected.
        """
        if len( team.players ) > 0:
            self.player = team.players[0]
        else:
            self.player = None

# Function to add two numbers (used with 'reduce'):
add = lambda a, b: a + b

#--[Example*]-------------------------------------------------------------------

# Define some sample teams and players:
blue_birds = Team( name = 'Blue Birds', players = [
    Player( name = 'Mike Scott',     hits = 25 ),
    Player( name = 'Willy Shofield', hits = 37 ),
    Player( name = 'Tony Barucci',   hits = 19 ) ] )

chicken_hawks = Team( name = 'Chicken Hawks', players = [
    Player( name = 'Jimmy Domore',   hits = 34 ),
    Player( name = 'Bill Janks',     hits = 16 ),
    Player( name = 'Tim Saunders',   hits = 27 ) ] )

eagles = Team( name = 'Eagles', players = [
    Player( name = 'Joe Peppers',    hits = 33 ),
    Player( name = 'Sam Alone',      hits = 12 ),
    Player( name = 'Roger Clemson',  hits = 23 ) ] )

# Create a league and its corresponding model view:
demo = LeagueModelView(
    League( name  = 'National Baseball Conference',
            teams = [ blue_birds, chicken_hawks, eagles ] )
)


if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = model_view
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

#--(ModelView and Controller Classes)-------------------------------------------
"""
ModelView and Controller Classes
================================

Traits 3.0 introduces two new **Handler** subclasses, **ModelView** and
**Controller**, both of which are intended to help simplify the process of
creating MVC (i.e. Model/View/Controller) based applications.

Both **Controller** and **ModelView** classes add the following new traits to
the **Handler** subclass::

    # The model this handler defines a view and controller for:
    model = Instance( HasTraits )

    # The UIInfo object associated with the controller:
    info = Instance( UIInfo )

The *model* trait provides simple access to the model object associated with
either the **Controller** or **ModelView** class. Normally, the *model* trait
is set in the constructor when a **Controller** or **ModelView** subclass is
created. See the **Example** tab for an example of this.

The *info* trait provides access to the **UIInfo** object associated with the
active user interface view for the handler object. The *info* trait is set
automatically when the handler's object view is created.

So far, the **Controller** and **ModelView** classes are identical. The only
difference between them is in the *context* dictionary each class defines when
it creates it associated user interface.

For a **Controller** subclass, the *context* dictionary contains:

object
    The **Controller**'s *model* object.
controller
    The **Controller** object itself.

For a **ModelView** subclass, the *context* dictionary contains:

object
    The **ModelView** object itself.
model
    The **ModelView**'s *model* object.

The **Controller** class is normally used when implementing a standard MVC-based
design. In this case, the *model* object contains most, if not all, of the data
being viewed, and can be easily referenced in the controller's **View**
definition using unqualified trait names (e.g. *Item( 'name' )*).

The **ModelView** class is useful when creating a variant of the standard
MVC-based design the author likes to refer to as a *model-view*. In this
pattern, the **ModelView** subclass typically reformulates a number of the
traits on its associated *model* object as properties on the **ModelView**
class, usually for the purpose of converting the model's data into a more user
interface friendly format.

So in this design, the **ModelView** class not only supplies the view and
controller, but also, in effect, the model (as a set of properties wrapped
around the original model). Because of this, the **ModelView** context
dictionary specifies itself as the special *object* value, and assigns the
original  model as the *model* value. Again, the main purpose of this is to
allow easy reference to the **ModelView**'s property traits within its **View**
using unqualified trait names.

Other than these somewhat subtle, although useful, distinctions, the
**Controller** and **ModelView** classes are identical, and which class to use
is really a personal preference as much as it is a design decision.

Calling the Constructor
-----------------------

Both the **ModelView** and **Controller** classes have the same constructor
signature::

    ModelView( model = None, **metadata )

    Controller( model = None, **metadata )

So both of the following are valid examples of creating a controller for
a model::

    mv = MyModelView( my_model )

    c = MyController( model = my_model )

An Example
----------

The code portion of this lesson provides a complete example of using a
**ModelView** design. Refer to the lesson on *Delegation Fixes and Improvements*
for an example of a related **Controller** based design.
"""

#--<Imports>--------------------------------------------------------------------

from traits.api import *
from traitsui.api import *
from traitsui.table_column import *

#--[Parent Class]---------------------------------------------------------------

class Parent ( HasTraits ):

    first_name = Str
    last_name  = Str

#--[Child Class]----------------------------------------------------------------

class Child ( HasTraits ):

    mother = Instance( Parent )
    father = Instance( Parent )

    first_name = Str
    last_name  = Delegate( 'father' )

#--[ChildModelView Class]-------------------------------------------------------

class ChildModelView ( ModelView ):

    # Define the 'family' ModelView property that maps the child and its
    # parents into a list of objects that can be viewed as a table:
    family = Property( List )

    # Define a view showing the family as a table:
    view = View(
        Item( 'family',
              show_label = False,
              editor = TableEditor(
                  columns = [ ObjectColumn( name = 'first_name' ),
                              ObjectColumn( name = 'last_name' ) ] ) ),
        resizable = True
    )

    # Implementation of the 'family' property:
    def _get_family ( self ):
        return [ self.model.father, self.model.mother, self.model ]

#--[Example*]-------------------------------------------------------------------

# Create a sample family:
mom = Parent( first_name = 'Julia', last_name = 'Wilson' )
dad = Parent( first_name = 'William', last_name = 'Chase' )
son = Child( mother = mom, father = dad, first_name = 'John' )

# Create the controller for the model:
demo = ChildModelView( model = son )


if __name__ == '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/30/2007
#
#  fixme:
#  - Get custom tree view images.
#  - Write a program to create a directory structure from a lesson plan file.
#
#-------------------------------------------------------------------------------

""" A framework for creating interactive Python tutorials.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import sys
import os
import re

from string \
    import capwords

from traits.api \
    import HasPrivateTraits, HasTraits, File, Directory, Instance, Int, Str, \
           List, Bool, Dict, Any, Property, Delegate, Button, cached_property

from traitsui.api \
    import View, VGroup, HGroup, VSplit, HSplit, Tabbed, Item, Heading, \
           Handler, ListEditor, CodeEditor, EnumEditor, HTMLEditor, \
           TreeEditor, TitleEditor, ValueEditor, ShellEditor

from traitsui.menu \
    import NoButtons

from traitsui.tree_node \
    import TreeNode

from pyface.image_resource \
    import ImageResource

try:
    from traitsui.wx.extra.windows.ie_html_editor \
        import IEHTMLEditor

    from traitsui.wx.extra.windows.flash_editor \
        import FlashEditor
    wx_available = True
except:
    IEHTMLEditor = HTMLEditor
    FlashEditor = ValueEditor # Set this to a random editor to prevent error.
    wx_available = False

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Correct program usage information:
Usage = """
Correct usage is: tutor.py [root_dir]
where:
    root_dir = Path to root of the tutorial tree

If omitted, 'root_dir' defaults to the current directory."""

# The standard list editor used:
list_editor = ListEditor(
    use_notebook = True,
    deletable    = False,
    page_name    = '.title',
    export       = 'DockWindowShell',
    dock_style   = 'fixed'
)

# The standard code snippet editor used:
snippet_editor = ListEditor(
    use_notebook = True,
    deletable    = False,
    page_name    = '.title',
    export       = 'DockWindowShell',
    dock_style   = 'tab',
    selected     = 'snippet'
)

# Regular expressions used to match section directories:
dir_pat1 = re.compile( r'^(\d\d\d\d)_(.*)$' )
dir_pat2 = re.compile( r'^(.*)_(\d+\.\d+)$' )

# Regular expression used to match section header in a Python source file:
section_pat1 = re.compile( r'^#-*\[(.*)\]' )  # Normal
section_pat2 = re.compile( r'^#-*<(.*)>' )    # Hidden
section_pat3 = re.compile( r'^#-*\((.*)\)' )  # Description

# Regular expression used to extract item titles from URLs:
url_pat1 = re.compile( r'^(.*)\[(.*)\](.*)$' )  # Normal

# Is this running on the Windows platform?
is_windows = (sys.platform in ( 'win32', 'win64' ))

# Python file section types:
IsCode        = 0
IsHiddenCode  = 1
IsDescription = 2

# HTML template for a default lecture:
DefaultLecture = """<html>
  <head>
  </head>
  <body>
    <p>This section contains the following topics:</p>
    <ul>
    %s
    </ul>
  </body>
</html>
"""

# HTML template for displaying a .wmv/.avi movie file:
WMVMovieTemplate = """<html>
<head>
</head>
<body>
<p><object classid="clsid:22D6F312-B0F6-11D0-94AB-0080C74C7E95" codebase="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,5,715">
<param name="FileName" value="%s">
<param name="AutoStart" value="true">
<param name="ShowTracker" value="true">
<param name="ShowControls" value="true">
<param name="ShowGotoBar" value="false">
<param name="ShowDisplay" value="false">
<param name="ShowStatusBar" value="false">
<param name="AutoSize" value="true">
<embed src="%s" AutoStart="true" ShowTracker="true" ShowControls="true" ShowGotoBar="false" ShowDisplay="false" ShowStatusBar="false" AutoSize="true" pluginspage="http://www.microsoft.com/windows/windowsmedia/download/"></object></p>
</body>
</html>
"""

# HTML template for displaying a QuickTime.mov movie file:
QTMovieTemplate = """<html>
<head>
</head>
<body>
<p><object classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B" codebase="http://www.apple.com/qtactivex/qtplugin.cab" width="100%%" height="100%%">
<param name="src" value="file:///%s">
<param name="scale" value="aspect">
<param name="autoplay" value="true">
<param name="loop" value="false">
<param name="controller" value="true">
<embed src="file:///%s" width="100%%" height="100%%" scale="aspect" autoplay="true" loop="false" controller="true" pluginspage="http://www.apple.com/quicktime/download"></object></p>
</body>
</html>
"""

# HTML template for displaying an image file:
ImageTemplate = """<html>
<head>
</head>
<body>
<img src="%s">
</body>
</html>
"""

# HTML template for playing an MP3 audio file:
MP3Template = """<html>
<head>
<bgsound src="%s">
</head>
<body>
<p>&nbsp;</p>
</body>
</html>
"""

#-------------------------------------------------------------------------------
#  Returns the contents of a specified text file (or None):
#-------------------------------------------------------------------------------

def read_file ( path, mode = 'rb' ):
    """ Returns the contents of a specified text file (or None).
        """
    fh = result = None

    try:
        fh     = file( path, mode )
        result = fh.read()
    except:
        pass

    if fh is not None:
        try:
            fh.close()
        except:
            pass

    return result

#-------------------------------------------------------------------------------
#  Creates a title from a specified string:
#-------------------------------------------------------------------------------

def title_for ( title ):
    """ Creates a title from a specified string.
    """
    return capwords( title.replace( '_', ' ' ) )

#-------------------------------------------------------------------------------
#  Returns a relative CSS style sheet path for a specified path and parent
#  section:
#-------------------------------------------------------------------------------

def css_path_for ( path, parent ):
    """ Returns a relative CSS style sheet path for a specified path and parent
        section.
    """
    if os.path.isfile( os.path.join( path, 'default.css' ) ):
        return 'default.css'

    if parent is not None:
        result = parent.css_path
        if result != '':
            if path != parent.path:
                result = os.path.join( '..', result )

            return result

    return ''

#-------------------------------------------------------------------------------
#  'StdOut' class:
#-------------------------------------------------------------------------------

class StdOut ( object ):
    """ Simulate stdout, but redirect the output to the 'output' string
        supplied by some 'owner' object.
    """

    def __init__ ( self, owner ):
        self.owner = owner

    def write ( self, data ):
        """ Adds the specified data to the output log.
        """
        self.owner.output += data

    def flush ( self ):
        """ Flushes all current data to the output log.
        """
        pass

#-------------------------------------------------------------------------------
#  'NoDemo' class:
#-------------------------------------------------------------------------------

class NoDemo ( HasPrivateTraits ):

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Heading( 'No demo defined for this lab.' ),
        resizable = True
    )

#-------------------------------------------------------------------------------
#  'DemoPane' class:
#-------------------------------------------------------------------------------

class DemoPane ( HasPrivateTraits ):
    """ Displays the contents of a Python lab's *demo* value.
    """

    #-- Trait Definitions ------------------------------------------------------

    demo = Instance( HasTraits, factory = NoDemo )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'demo',
              id         = 'demo',
              show_label = False,
              style      = 'custom',
              resizable  = True
        ),
        id        = 'enthought.tutor.demo',
        resizable = True
    )

#-------------------------------------------------------------------------------
#  'ATutorialItem' class:
#-------------------------------------------------------------------------------

class ATutorialItem ( HasPrivateTraits ):
    """ Defines the abstract base class for each type of item (HTML, Flash,
        text, code) displayed within the tutor.
    """

    #-- Traits Definitions -----------------------------------------------------

    # The title for the item:
    title = Str

    # The path to the item:
    path = File

    # The displayable content for the item:
    content = Property

#-------------------------------------------------------------------------------
#  'ADescriptionItem' class:
#-------------------------------------------------------------------------------

class ADescriptionItem ( ATutorialItem ):
    """ Defines a common base class for all description items.
    """

    #-- Event Handlers ---------------------------------------------------------

    def _path_changed ( self, path ):
        """ Sets the title for the item based on the item's path name.
        """
        self.title = title_for( os.path.splitext( os.path.basename(
                                                  path ) )[0] )

#-------------------------------------------------------------------------------
#  'HTMLItem' class:
#-------------------------------------------------------------------------------

class HTMLItem ( ADescriptionItem ):
    """ Defines a class used for displaying a single HTML page within the tutor
        using the default Traits HTML editor.
    """

    #-- Traits Definitions -----------------------------------------------------

    url = Str

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = HTMLEditor()
        )
    )

    #-- Event Handlers ---------------------------------------------------------

    def _url_changed ( self, url ):
        """ Sets the item title when the 'url' is changed.
        """
        match = url_pat1.match( url )
        if match is not None:
            title = match.group(2).strip()
        else:
            title = url.strip()
            col   = title.rfind( '/' )
            if col >= 0:
                title = os.path.splitext( title[ col + 1: ] )[0]

        self.title = title

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_content ( self ):
        """ Returns the item content.
        """
        url = self.url
        if url != '':
            match = url_pat1.match( url )
            if match is not None:
                url = match.group(1) + match.group(3)

            return url

        return read_file( self.path )

    def _set_content ( self, content ):
        """ Sets the item content.
        """
        self._content = content

#-------------------------------------------------------------------------------
#  'HTMLStrItem' class:
#-------------------------------------------------------------------------------

class HTMLStrItem ( HTMLItem ):
    """ Defines a class used for displaying a single HTML text string within
        the tutor using the default Traits HTML editor.
    """

    # Make the content a real trait rather than a property:
    content = Str

#-------------------------------------------------------------------------------
#  'IEHTMLItem' class:
#-------------------------------------------------------------------------------

class IEHTMLItem ( HTMLItem ):
    """ Defines a class used for displaying a single HTML page within the tutor
        using the Traits Internet Explorer HTML editor.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = IEHTMLEditor()
        )
    )

#-------------------------------------------------------------------------------
#  'IEHTMLStrItem' class:
#-------------------------------------------------------------------------------

class IEHTMLStrItem ( IEHTMLItem ):
    """ Defines a class used for displaying a single HTML text string within
        the tutor using the Traits Internet Explorer HTML editor.
    """

    # Make the content a real trait rather than a property:
    content = Str

#-------------------------------------------------------------------------------
#  'FlashItem' class:
#-------------------------------------------------------------------------------

class FlashItem ( HTMLItem ):
    """ Defines a class used for displaying a Flash-based animation or video
        within the tutor.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = FlashEditor()
        )
    )

#-------------------------------------------------------------------------------
#  'TextItem' class:
#-------------------------------------------------------------------------------

class TextItem ( ADescriptionItem ):
    """ Defines a class used for displaying a text file within the tutor.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'readonly',
              show_label = False,
              editor     = CodeEditor( show_line_numbers = False,
                                       selected_color    = 0xFFFFFF )
        )
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_content ( self ):
        """ Returns the item content.
        """
        return read_file( self.path )

#-------------------------------------------------------------------------------
#  'TextStrItem' class:
#-------------------------------------------------------------------------------

class TextStrItem ( TextItem ):
    """ Defines a class used for displaying a text file within the tutor.
    """

    # Make the content a real trait, rather than a property:
    content = Str

#-------------------------------------------------------------------------------
#  'CodeItem' class:
#-------------------------------------------------------------------------------

class CodeItem ( ATutorialItem ):
    """ Defines a class used for displaying a Python source code fragment
        within the tutor.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The displayable content for the item (override):
    content = Str

    # The starting line of the code snippet within the original file:
    start_line = Int

    # The currently selected line:
    selected_line = Int

    # Should this section normally be hidden?
    hidden = Bool

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'content',
              style      = 'custom',
              show_label = False,
              editor     = CodeEditor( selected_line = 'selected_line' )
        )
    )

#-------------------------------------------------------------------------------
#  'ASection' abstract base class:
#-------------------------------------------------------------------------------

class ASection ( HasPrivateTraits ):
    """ Defines an abstract base class for a single section of a tutorial.
    """

    #-- Traits Definitions -----------------------------------------------------

    # The title of the section:
    title = Str

    # The path to this section:
    path = Directory

    # The parent section of this section (if any):
    parent = Instance( 'ASection' )

    # Optional table of contents (can be used to define/locate the subsections):
    toc = List( Str )

    # The path to the CSS style sheet to use for this section:
    css_path = Property

    # The list of subsections contained in this section:
    subsections = Property # List( ASection )

    # This section can be executed:
    is_runnable = Bool( True )

    # Should the Python code be automatically executed on start-up?
    auto_run = Bool( False )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_subsections ( self ):
        """ Returns the subsections for this section:
        """
        if len( self.toc ) > 0:
            self._load_toc()
        else:
            self._load_dirs()

        # Return the cached list of sections:
        return self._subsections

    @cached_property
    def _get_css_path ( self ):
        """ Returns the path to the CSS style sheet for this section.
        """
        return css_path_for( self.path, self.parent )

    #-- Private Methods --------------------------------------------------------

    def _load_dirs ( self ):
        """ Defines the section's subsections by analyzing all of the section's
            sub-directories.
        """
        # No value cached yet:
        dirs = []
        path = self.path

        # Find every sub-directory whose name begins with a number of the
        # form ddd, or ends with a number of the form _ddd.ddd (used for
        # sorting them into the correct presentation order):
        for name in os.listdir( path ):
            dir = os.path.join( path, name )
            if os.path.isdir( dir ):
               match = dir_pat1.match( name )
               if match is not None:
                   dirs.append( ( float( match.group(1) ),
                                  match.group(2), dir ) )
               else:
                   match = dir_pat2.match( name )
                   if match is not None:
                       dirs.append( ( float( match.group(2) ),
                                      match.group(1), dir ) )

        # Sort the directories by their index value:
        dirs.sort( lambda l, r: cmp( l[0], r[0] ) )

        # Create the appropriate type of section for each valid directory:
        self._subsections = [
            sf.section for sf in [
                SectionFactory( title  = title_for( title ),
                                parent = self ).set(
                                path   = dir )
                for index, title, dir in dirs
            ] if sf.section is not None
        ]

    def _load_toc ( self ):
        """ Defines the section's subsections by finding matches for the items
            defined in the section's table of contents.
        """
        toc         = self.toc
        base_names  = [ item.split( ':', 1 )[0] for item in toc ]
        subsections = [ None ] * len( base_names )
        path        = self.path

        # Classify all file names that match a base name in the table of
        # contents:
        for name in os.listdir( path ):
            try:
                base_name = os.path.splitext( os.path.basename( name ) )[0]
                index     = base_names.index( base_name )
                if subsections[ index ] is None:
                    subsections[ index ] = []
                subsections[ index ].append( name )
            except:
                pass

        # Try to convert each group of names into a section:
        for i, names in enumerate( subsections ):

            # Only process items for which we found at least one matching file
            # name:
            if names is not None:

                # Get the title for the section from its table of contents
                # entry:
                parts = toc[i].split( ':', 1 )
                if len( parts ) == 1:
                    title = title_for( parts[0].strip() )
                else:
                    title = parts[1].strip()

                # Handle an item with one file which is a directory as a normal
                # section:
                if len( names ) == 1:
                    dir = os.path.join( path, names[0] )
                    if os.path.isdir( dir ):
                        subsections[i] = SectionFactory( title  = title,
                                                         parent = self ).set(
                                                         path   = dir ).section
                        continue

                # Otherwise, create a section from the list of matching files:
                subsections[i] = SectionFactory( title  = title,
                                                 parent = self,
                                                 files  = names ).set(
                                                 path   = path ).section

        # Set the subsections to the non-None values that are left:
        self._subsections = [ subsection for subsection in subsections
                                         if subsection is not None ]

#-------------------------------------------------------------------------------
#  'Lecture' class:
#-------------------------------------------------------------------------------

class Lecture ( ASection ):
    """ Defines a lecture, which is a section of a tutorial with descriptive
        information, but no associated Python code. Can be used to provide
        course overviews, introductory sections, or lead-ins to follow-on
        lessons or labs.
    """

    #-- Trait Definitions-------------------------------------------------------

    # The list of descriptive items for the lecture:
    descriptions = List( ATutorialItem )

    # This section can be executed (override):
    is_runnable = False

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'descriptions',
              style      = 'custom',
              show_label = False,
              editor     = list_editor
        ),
        id = 'enthought.tutor.lecture'
    )

#-------------------------------------------------------------------------------
#  'LabHandler' class:
#-------------------------------------------------------------------------------

class LabHandler ( Handler ):
    """ Defines the controller functions for the Lab view.
    """

    def init ( self, info ):
        """ Handles initialization of the view.
        """
        # Run the associated Python code if the 'auto-run' feature is enabled:
        if info.object.auto_run:
            info.object.run_code()

#-------------------------------------------------------------------------------
#  'Lab' class:
#-------------------------------------------------------------------------------

class Lab ( ASection ):
    """ Defines a lab, which is a section of a tutorial with only Python code.
        This type of section might typically follow a lecture which introduced
        the code being worked on in the lab.
    """

    #-- Trait Definitions-------------------------------------------------------

    # The set-up code (if any) for the lab:
    setup = Instance( CodeItem )

    # The list of code items for the lab:
    snippets = List( CodeItem )

    # The list of visible code items for the lab:
    visible_snippets = Property( depends_on = 'visible', cached = True )

    # The currently selected snippet:
    snippet = Instance( CodeItem )

    # Should normally hidden code items be shown?
    visible = Bool( False )

    # The dictionary containing the items from the Python code execution:
    values = Dict #Any( {} )

    # The run Python code button:
    run = Button( image = ImageResource( 'run' ), height_padding = 1 )

    # User error message:
    message = Str

    # The output produced while the program is running:
    output = Str

    # The current demo pane (if any):
    demo = Instance( DemoPane, () )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VSplit(
            VGroup(
                Item( 'visible_snippets',
                      style      = 'custom',
                      show_label = False,
                      editor     = snippet_editor
                ),
                HGroup(
                    Item( 'run',
                          style      = 'custom',
                          show_label = False,
                          tooltip    = 'Run the Python code'
                    ),
                    '_',
                    Item( 'message',
                          springy    = True,
                          show_label = False,
                          editor     = TitleEditor()
                    ),
                    '_',
                    Item( 'visible',
                          label = 'View hidden sections'
                    )
                ),
            ),
            Tabbed(
                Item( 'values',
                      id     = 'values_1',
                      label  = 'Shell',
                      editor = ShellEditor( share = True ),
                      dock   = 'tab',
                      export = 'DockWindowShell'
                ),
                Item( 'values',
                      id     = 'values_2',
                      editor = ValueEditor(),
                      dock   = 'tab',
                      export = 'DockWindowShell'
                ),
                Item( 'output',
                      style  = 'readonly',
                      editor = CodeEditor( show_line_numbers = False,
                                           selected_color    = 0xFFFFFF ),
                      dock   = 'tab',
                      export = 'DockWindowShell'
                ),
                Item( 'demo',
                      id        = 'demo',
                      style     = 'custom',
                      resizable = True,
                      dock      = 'tab',
                      export    = 'DockWindowShell'
                ),
                show_labels = False,
            ),
            id = 'splitter',
        ),
        id      = 'enthought.tutor.lab',
        handler = LabHandler
    )

    #-- Event Handlers ---------------------------------------------------------

    def _run_changed ( self ):
        """ Runs the current set of snippet code.
        """
        self.run_code()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_visible_snippets ( self ):
        """ Returns the list of code items that are currently visible.
        """
        if self.visible:
            return self.snippets

        return [ snippet for snippet in self.snippets if (not snippet.hidden) ]

    #-- Public Methods ---------------------------------------------------------

    def run_code ( self ):
        """ Runs all of the code snippets associated with the section.
        """
        # Reconstruct the lab code from the current set of code snippets:
        start_line = 1
        module     = ''
        for snippet in self.snippets:
            snippet.start_line = start_line
            module      = '%s\n\n%s' % ( module, snippet.content )
            start_line += (snippet.content.count( '\n' ) + 2)

        # Reset any syntax error and message log values:
        self.message   = self.output = ''

        # Redirect standard out and error to the message log:
        stdout, stderr = sys.stdout, sys.stderr
        sys.stdout     = sys.stderr = StdOut( self )

        try:
            try:
                # Get the execution context dictionary:
                values = self.values

                # Clear out any special variables defined by the last run:
                for name in ( 'demo', 'popup' ):
                    if isinstance( values.get( name ), HasTraits ):
                        del values[ name ]

                # Execute the current lab code:
                exec module[2:] in values, values

                # fixme: Hack trying to update the Traits UI view of the dict.
                self.values = {}
                self.values = values

                # Handle a 'demo' value being defined:
                demo = values.get( 'demo' )
                if not isinstance( demo, HasTraits ):
                    demo = NoDemo()
                self.demo.demo = demo

                # Handle a 'popup' value being defined:
                popup = values.get( 'popup' )
                if isinstance( popup, HasTraits ):
                    popup.edit_traits( kind = 'livemodal' )

            except SyntaxError, excp:
                # Convert the line number of the syntax error from one in the
                # composite module to one in the appropriate code snippet:
                line = excp.lineno
                if line is not None:
                    snippet = self.snippets[0]
                    for s in self.snippets:
                        if s.start_line > line:
                            break
                        snippet = s
                    line -= (snippet.start_line - 1)

                    # Highlight the line in error:
                    snippet.selected_line = line

                    # Select the correct code snippet:
                    self.snippet = snippet

                    # Display the syntax error message:
                    self.message = '%s in column %s of line %s' % (
                                   excp.msg.capitalize(), excp.offset, line )
                else:
                    # Display the syntax error message without line # info:
                    self.message = excp.msg.capitalize()
            except:
                import traceback
                traceback.print_exc()
        finally:
            # Restore standard out and error to their original values:
            sys.stdout, sys.stderr = stdout, stderr

#-------------------------------------------------------------------------------
#  'Lesson' class:
#-------------------------------------------------------------------------------

class Lesson ( Lab ):
    """ Defines a lesson, which is a section of a tutorial with both descriptive
        information and associated Python code.
    """

    #-- Trait Definitions-------------------------------------------------------

    # The list of descriptive items for the lesson:
    descriptions = List( ATutorialItem )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HSplit(
            Item( 'descriptions',
                  label      = 'Lesson',
                  style      = 'custom',
                  show_label = False,
                  dock       = 'horizontal',
                  editor     = list_editor
            ),
            VSplit(
                VGroup(
                    Item( 'visible_snippets',
                          style      = 'custom',
                          show_label = False,
                          editor     = snippet_editor
                    ),
                    HGroup(
                        Item( 'run',
                              style      = 'custom',
                              show_label = False,
                              tooltip    = 'Run the Python code'
                        ),
                        '_',
                        Item( 'message',
                              springy    = True,
                              show_label = False,
                              editor     = TitleEditor()
                        ),
                        '_',
                        Item( 'visible',
                              label = 'View hidden sections'
                        )
                    ),
                    label = 'Lab',
                    dock  = 'horizontal'
                ),
                Tabbed(
                    Item( 'values',
                          id     = 'values_1',
                          label  = 'Shell',
                          editor = ShellEditor( share = True ),
                          dock   = 'tab',
                          export = 'DockWindowShell'

                    ),
                    Item( 'values',
                          id     = 'values_2',
                          editor = ValueEditor(),
                          dock   = 'tab',
                          export = 'DockWindowShell'
                    ),
                    Item( 'output',
                          style  = 'readonly',
                          editor = CodeEditor( show_line_numbers = False,
                                               selected_color    = 0xFFFFFF ),
                          dock   = 'tab',
                          export = 'DockWindowShell'
                    ),
                    Item( 'demo',
                          id        = 'demo',
                          style     = 'custom',
                          resizable = True,
                          dock      = 'tab',
                          export    = 'DockWindowShell'
                    ),
                    show_labels = False,
                ),
                label = 'Lab',
                dock  = 'horizontal'
            ),
            id = 'splitter',
        ),
        id      = 'enthought.tutor.lesson',
        handler = LabHandler
    )

#-------------------------------------------------------------------------------
#  'Demo' class:
#-------------------------------------------------------------------------------

class Demo ( Lesson ):
    """ Defines a demo, which is a section of a tutorial with both descriptive
        information and associated Python code which is executed but not
        shown.
    """

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        HSplit(
            Item( 'descriptions',
                  label      = 'Lesson',
                  style      = 'custom',
                  show_label = False,
                  dock       = 'horizontal',
                  editor     = list_editor
            ),
            Item( 'demo',
                  id         = 'demo',
                  style      = 'custom',
                  show_label = False,
                  resizable  = True,
                  dock       = 'horizontal',
                  export     = 'DockWindowShell'
            ),
            id = 'splitter',
        ),
        id      = 'enthought.tutor.demo',
        handler = LabHandler
    )

#-------------------------------------------------------------------------------
#  'SectionFactory' class:
#-------------------------------------------------------------------------------

class SectionFactory ( HasPrivateTraits ):
    """ Defines a class that creates Lecture, Lesson or Lab sections (or None),
        based on the content of a specified directory. None is returned if the
        directory does not contain any recognized files.
    """

    #-- Traits Definitions -----------------------------------------------------

    # The path the section is to be created for:
    path = Directory

    # The list of files contained in the section:
    files = List( Str )

    # The parent of the section being created:
    parent = Instance( ASection )

    # The section created from the path:
    section = Instance( ASection )

    # The title for the section:
    title = Str

    # The optional table of contents for the section:
    toc = List( Str )

    # The list of descriptive items for the section:
    descriptions = List( ADescriptionItem )

    # The list of code snippet items for the section:
    snippets = List( CodeItem )

    # The path to the CSS style sheet for the section:
    css_path = Property

    # Should the Python code be automatically executed on start-up?
    auto_run = Bool( False )

    #-- Event Handlers ---------------------------------------------------------

    def _path_changed ( self, path ):
        """ Creates the appropriate section based on the value of the path.
        """
        # Get the list of files to process:
        files = self.files
        if len( files ) == 0:
            # If none were specified, then use all files in the directory:
            files = os.listdir( path )

            # Process the description file (if any) first:
            for name in files:
                if os.path.splitext( name )[1] == '.desc':
                    self._add_desc_item( os.path.join( path, name ) )
                    break

        # Try to convert each file into one or more 'xxxItem' objects:
        toc = [ item.split( ':', 1 )[0].strip() for item in self.toc ]
        for name in files:
            file_name = os.path.join( path, name )

            # Only process the ones that are actual files:
            if os.path.isfile( file_name ):

                # Use the file extension to determine the file's type:
                root, ext = os.path.splitext( name )
                if (root not in toc) and (len( ext ) > 1):

                    # If we have a handler for the file type, invoke it:
                    method = getattr( self, '_add_%s_item' % ext[1:].lower(),
                                      None )
                    if method is not None:
                        method( file_name )

        # Based on the type of items created (if any), create the corresponding
        # type of section:
        if len( self.descriptions ) > 0:
            if len( self.snippets ) > 0:
                if len( [ snippet for snippet in self.snippets
                                  if (not snippet.hidden) ] ) > 0:
                    self.section = Lesson(
                        title        = self.title,
                        path         = path,
                        toc          = self.toc,
                        parent       = self.parent,
                        descriptions = self.descriptions,
                        snippets     = self.snippets,
                        auto_run     = self.auto_run
                    )
                else:
                    self.section = Demo(
                        title        = self.title,
                        path         = path,
                        toc          = self.toc,
                        parent       = self.parent,
                        descriptions = self.descriptions,
                        snippets     = self.snippets,
                        auto_run     = True
                    )
            else:
                self.section = Lecture(
                    title        = self.title,
                    path         = path,
                    toc          = self.toc,
                    parent       = self.parent,
                    descriptions = self.descriptions
                )
        elif len( self.snippets ) > 0:
            self.section = Lab(
                title    = self.title,
                path     = path,
                toc      = self.toc,
                parent   = self.parent,
                snippets = self.snippets,
                auto_run = self.auto_run
            )
        else:
            # No descriptions or code snippets were found. Create a lecture
            # anyway:
            section = Lecture(
                title  = self.title,
                path   = path,
                toc    = self.toc,
                parent = self.parent
            )

            # If the lecture has subsections, then return the lecture and add
            # a default item containing a description of the subsections of the
            # lecture:
            if len( section.subsections ) > 0:
                self._create_html_item( path = path, content =
                         DefaultLecture % ( '\n'.join(
                             [ '<li>%s</li>' % subsection.title
                               for subsection in section.subsections ] ) ) )
                section.descriptions = self.descriptions
                self.section = section

    #-- Property Implementations -----------------------------------------------

    def _get_css_path ( self ):
        """ Returns the path to the CSS style sheet for the section.
        """
        return css_path_for( self.path, self.parent )

    #-- Factory Methods for Creating Section Items Based on File Type ----------

    def _add_py_item ( self, path ):
        """ Creates the code snippets for a Python source file.
        """
        source = read_file( path )
        if source is not None:
            lines      = source.replace( '\r', '' ).split( '\n' )
            start_line = 0
            title      = 'Prologue'
            type       = IsCode

            for i, line in enumerate( lines ):
                match = section_pat1.match( line )
                if match is not None:
                    next_type = IsCode
                else:
                    match = section_pat2.match( line )
                    if match is not None:
                        next_type = IsHiddenCode
                    else:
                        next_type = IsDescription
                        match     = section_pat3.match( line )

                if match is not None:
                    self._add_snippet( title, path, lines, start_line, i - 1,
                                       type )
                    start_line = i + 1
                    title      = match.group(1).strip()
                    type       = next_type

            self._add_snippet( title, path, lines, start_line, i, type )

    def _add_txt_item ( self, path ):
        """ Creates a description item for a normal text file.
        """
        self.descriptions.append( TextItem( path = path ) )

    def _add_htm_item ( self, path ):
        """ Creates a description item for an HTML file.
        """
        # Check if there is a corresponding .rst (restructured text) file:
        dir, base_name = os.path.split( path )
        rst = os.path.join( dir, os.path.splitext( base_name )[0] + '.rst' )

        # If no .rst file exists, just add the file as a normal HTML file:
        if not os.path.isfile( rst ):
            self._create_html_item( path = path )

    def _add_html_item ( self, path ):
        """ Creates a description item for an HTML file.
        """
        self._add_htm_item( path )

    def _add_url_item ( self, path ):
        """ Creates a description item for a file containing URLs.
        """
        data = read_file( path )
        if data is not None:
            for url in [ line for line in data.split( '\n' )
                              if line.strip()[:1] not in ( '', '#' ) ]:
                self._create_html_item( url = url.strip() )

    def _add_rst_item ( self, path ):
        """ Creates a description item for a ReSTructured text file.
        """
        # If docutils is not installed, just process the file as an ordinary
        # text file:
        try:
            from docutils.core import publish_cmdline
        except:
            self._add_txt_item( path )
            return

        # Get the name of the HTML file we will write to:
        dir, base_name = os.path.split( path )
        html = os.path.join( dir, os.path.splitext( base_name )[0] + '.htm' )

        # Try to find a CSS style sheet, and set up the docutil overrides if
        # found:
        settings = {}
        css_path = self.css_path
        if css_path != '':
            css_path = os.path.join( self.path, css_path )
            settings[ 'stylesheet_path' ]  = css_path
            settings[ 'embed_stylesheet' ] = True
            settings[ 'stylesheet' ]       = None
        else:
            css_path = path

        # If the HTML file does not exist, or is older than the restructured
        # text file, then let docutils convert it to HTML:
        is_file = os.path.isfile( html )
        if ((not is_file) or
            (os.path.getmtime( path )     > os.path.getmtime( html )) or
            (os.path.getmtime( css_path ) > os.path.getmtime( html ))):

            # Delete the current HTML file (if any):
            if is_file:
                os.remove( html )

            # Let docutils create a new HTML file from the restructured text
            # file:
            publish_cmdline( writer_name        = 'html',
                             argv               = [ path, html ],
                             settings_overrides = settings )

        if os.path.isfile( html ):
            # If there is now a valid HTML file, use it:
            self._create_html_item( path = html )

        else:
            # Otherwise, just use the original restructured text file:
            self._add_txt_item( path )

    def _add_swf_item ( self, path ):
        """ Creates a description item for a Flash file.
        """
        if is_windows and wx_available:
            self.descriptions.append( FlashItem( path = path ) )

    def _add_mov_item ( self, path ):
        """ Creates a description item for a QuickTime movie file.
        """
        path2 = path.replace( ':', '|' )
        self._create_html_item( path    = path,
                                content = QTMovieTemplate % ( path2, path2 ) )

    def _add_wmv_item ( self, path ):
        """ Creates a description item for a Windows movie file.
        """
        self._create_html_item( path    = path,
                                content = WMVMovieTemplate % ( path, path ) )

    def _add_avi_item ( self, path ):
        """ Creates a description item for an AVI movie file.
        """
        self._add_wmv_item( path )

    def _add_jpg_item ( self, path ):
        """ Creates a description item for a JPEG image file.
        """
        self._create_html_item( path    = path,
                                content = ImageTemplate % path )

    def _add_jpeg_item ( self, path ):
        """ Creates a description item for a JPEG image file.
        """
        self._add_jpg_item( path )

    def _add_png_item ( self, path ):
        """ Creates a description item for a PNG image file.
        """
        self._add_jpg_item( path )

    def _add_mp3_item ( self, path ):
        """ Creates a description item for an mp3 audio file.
        """
        self._create_html_item( path    = path,
                                content = MP3Template % path )

    def _add_desc_item ( self, path ):
        """ Creates a section title from a description file.
        """
        # If we've already processed a description file, then we're done:
        if len( self.toc ) > 0:
            return

        lines = []
        desc  = read_file( path )
        if desc is not None:
            # Split the file into lines and save the non-empty, non-comment
            # lines:
            for line in desc.split( '\n' ):
                line = line.strip()
                if (len( line ) > 0) and (line[0] != '#'):
                    lines.append( line )

        if len( lines ) == 0:
            # If the file didn't have anything useful in it, set a title based
            # on the description file name:
            self.title = title_for(
                             os.path.splitext( os.path.basename( path ) )[0] )
        else:
            # Otherwise, set the title and table of contents from the lines in
            # the file:
            self.title = lines[0]
            self.toc   = lines[1:]

    #-- Private Methods --------------------------------------------------------

    def _add_snippet ( self, title, path, lines, start_line, end_line, type ):
        """ Adds a new code snippet or restructured text item to the list of
            code snippet or description items.
        """
        # Trim leading and trailing blank lines from the snippet:
        while start_line <= end_line:
            if lines[ start_line ].strip() != '':
                break
            start_line += 1

        while end_line >= start_line:
            if lines[ end_line ].strip() != '':
                break
            end_line -= 1

        # Only add if the snippet is not empty:
        if start_line <= end_line:

            # Check for the title containing the 'auto-run' flag ('*'):
            if title[:1] == '*':
                self.auto_run = True
                title = title[1:].strip()

            if title[-1:] == '*':
                self.auto_run = True
                title = title[:-1].strip()

            # Extract out just the lines we will use:
            content_lines = lines[ start_line: end_line + 1 ]

            if type == IsDescription:
                # Add the new restructured text description:
                self._add_description( content_lines, title )
            else:
                # Add the new code snippet:
                self.snippets.append( CodeItem(
                    title   = title or 'Code',
                    path    = path,
                    hidden  = (type == IsHiddenCode),
                    content = '\n'.join( content_lines )
                ) )

    def _add_description ( self, lines, title ):
        """ Converts a restructured text string to HTML and adds it as
            description item.
        """
        # Scan the lines for any imbedded Python code that should be shown as
        # a separate snippet:
        i = 0
        while i < len( lines ):
            if lines[i].strip()[-2:] == '::':
                i = self._check_embedded_code( lines, i + 1 )
            else:
                i += 1

        # Strip off any docstring style triple quotes (if necessary):
        content = '\n'.join( lines ).strip()
        if content[:3] in ( '"""', "'''" ):
            content = content[3:]

        if content[-3:] in ( '"""', "'''" ):
            content = content[:-3]

        content = content.strip()

        # If docutils is not installed, just add it as a text string item:
        try:
            from docutils.core import publish_string
        except:
            self.descriptions.append( TextStrItem( content = content,
                                                   title   = title ) )
            return

        # Try to find a CSS style sheet, and set up the docutil overrides if
        # found:
        settings = {}
        css_path = self.css_path
        if css_path != '':
            css_path = os.path.join( self.path, css_path )
            settings[ 'stylesheet_path' ]  = css_path
            settings[ 'embed_stylesheet' ] = True
            settings[ 'stylesheet' ]       = None

        # Convert it from restructured text to HTML:
        html = publish_string( content, writer_name        = 'html',
                                        settings_overrides = settings )

        # Choose the right HTML renderer:
        if is_windows and wx_available:
            item = IEHTMLStrItem( content = html, title = title )
        else:
            item = HTMLStrItem( content = html, title = title )

        # Add the resulting item to the descriptions list:
        self.descriptions.append( item )

    def _create_html_item ( self, **traits ):
        """ Creates a platform specific html item and adds it to the list of
            descriptions.
        """
        if is_windows and wx_available:
            item = IEHTMLItem( **traits )
        else:
            item = HTMLItem( **traits )

        self.descriptions.append( item )

    def _check_embedded_code ( self, lines, start ):
        """ Checks for an embedded Python code snippet within a description.
        """
        n = len( lines )
        while start < n:
            line = lines[ start ].strip()

            if line == '':
                start += 1
                continue

            if (line[:1] != '[') or (line[-1:] != ']'):
                break

            del lines[ start ]

            n     -= 1
            title  = line[1:-1].strip()
            line   = lines[ start ] + '.'
            pad    = len( line ) - len( line.strip() )
            clines = []

            while start < n:
                line     = lines[ start ] + '.'
                len_line = len( line.strip() )
                if (len_line > 1) and ((len( line ) - len_line) < pad):
                    break

                if (len( clines ) > 0) or (len_line > 1):
                    clines.append( line[ pad: -1 ] )

                start += 1

            # Add the new code snippet:
            self.snippets.append( CodeItem(
                title   = title or 'Code',
                content = '\n'.join( clines )
            ) )

            break

        return start

#-------------------------------------------------------------------------------
#  Tutor tree editor:
#-------------------------------------------------------------------------------

tree_editor = TreeEditor(
    nodes = [
        TreeNode(
            children   = 'subsections',
            label      = 'title',
            rename     = False,
            copy       = False,
            delete     = False,
            delete_me  = False,
            insert     = False,
            auto_open  = True,
            auto_close = False,
            node_for   = [ ASection ],
            icon_group = '<group>'
        )
    ],
    editable  = False,
    auto_open = 1,
    selected = 'section'
)

#-------------------------------------------------------------------------------
#  'Tutor' class:
#-------------------------------------------------------------------------------

class Tutor ( HasPrivateTraits ):
    """ The main tutorial class which manages the presentation and navigation
        of the entire tutorial.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The path to the files distributed with the tutor:
    home = Directory

    # The path to the root of the tutorial tree:
    path = Directory

    # The root of the tutorial lesson tree:
    root = Instance( ASection )

    # The current section of the tutorial being displayed:
    section = Instance( ASection )

    # The next section:
    next_section = Property( depends_on = 'section', cached = True )

    # The previous section:
    previous_section = Property( depends_on = 'section', cached = True )

    # The previous section button:
    previous = Button( image = ImageResource( 'previous' ), height_padding = 1 )

    # The next section button:
    next = Button( image = ImageResource( 'next' ), height_padding = 1 )

    # The parent section button:
    parent = Button( image = ImageResource( 'parent' ), height_padding = 1 )

    # The reload tutor button:
    reload = Button( image = ImageResource( 'reload' ), height_padding = 1 )

    # The title of the current session:
    title = Property( depends_on = 'section' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            HGroup(
                Item( 'previous',
                      style        = 'custom',
                      enabled_when = 'previous_section is not None',
                      tooltip      = 'Go to previous section'
                ),
                Item( 'parent',
                      style        = 'custom',
                      enabled_when = '(section is not None) and '
                                     '(section.parent is not None)',
                      tooltip      = 'Go up one level'
                ),
                Item( 'next',
                      style        = 'custom',
                      enabled_when = 'next_section is not None',
                      tooltip      = 'Go to next section'
                ),
                '_',
                Item( 'title',
                      springy = True,
                      editor  = TitleEditor()
                ),
                '_',
                Item( 'reload',
                      style   = 'custom',
                      tooltip = 'Reload the tutorial'
                ),
                show_labels = False
            ),
            '_',
            HSplit(
                Item( 'root',
                      label  = 'Table of Contents',
                      editor = tree_editor,
                      dock   = 'horizontal',
                      export = 'DockWindowShell'
                ),
                Item( 'section',
                      id        = 'section',
                      label     = 'Current Lesson',
                      style     = 'custom',
                      resizable = True,
                      dock      = 'horizontal'
                ),
                id          = 'splitter',
                show_labels = False
            )
        ),
        title     = 'Python Tutor',
        id        = 'dmorrill.tutor.tutor:1.0',
        buttons   = NoButtons,
        resizable = True,
        width     = 0.8,
        height    = 0.8
    )

    #-- Event Handlers ---------------------------------------------------------

    def _path_changed ( self, path ):
        """ Handles the tutorial root path being changed.
        """
        self.init_tutor()

    def _next_changed ( self ):
        """ Displays the next tutorial section.
        """
        self.section = self.next_section

    def _previous_changed ( self ):
        """ Displays the previous tutorial section.
        """
        self.section = self.previous_section

    def _parent_changed ( self ):
        """ Displays the parent of the current tutorial section.
        """
        self.section = self.section.parent

    def _reload_changed ( self ):
        """ Reloads the tutor from the original path specified.
        """
        self.init_tutor()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_next_section ( self ):
        """ Returns the next section of the tutorial.
        """
        next    = None
        section = self.section
        if len( section.subsections ) > 0:
            next = section.subsections[0]
        else:
            parent = section.parent
            while parent is not None:
                index = parent.subsections.index( section )
                if index < (len( parent.subsections ) - 1):
                    next = parent.subsections[ index + 1 ]
                    break

                parent, section = parent.parent, parent

        return next

    @cached_property
    def _get_previous_section ( self ):
        """ Returns the previous section of the tutorial.
        """
        previous = None
        section  = self.section
        parent   = section.parent
        if parent is not None:
            index = parent.subsections.index( section )
            if index > 0:
                previous = parent.subsections[ index - 1 ]
                while len( previous.subsections ) > 0:
                    previous = previous.subsections[-1]
            else:
                previous = parent

        return previous

    def _get_title ( self ):
        """ Returns the title of the current section.
        """
        section = self.section
        if section is None:
            return ''

        return ('%s: %s' % ( section.__class__.__name__, section.title ))

    #-- Public Methods ---------------------------------------------------------

    def init_tutor ( self ):
        """ Initials the tutor by creating the root section from the specified
            path.
        """
        path    = self.path
        title   = title_for( os.path.splitext( os.path.basename( path ) )[0] )
        section = SectionFactory( title = title ).set( path = path ).section
        if section is not None:
            self.section = self.root = section

#-------------------------------------------------------------------------------
#  Run the program:
#-------------------------------------------------------------------------------

# Only run the program if we were invoked from the command line:
if __name__ == '__main__':

    # Validate the command line arguments:
    if len( sys.argv ) > 2:
        print Usage
        sys.exit( 1 )

    # Determine the root path to use for the tutorial files:
    if len( sys.argv ) == 2:
        path = sys.argv[1]
    else:
        path = os.getcwd()

    # Create a tutor and display the tutorial:
    tutor = Tutor( home = os.path.dirname( sys.argv[0] ) ).set(
                   path = path )
    if tutor.root is not None:
        tutor.configure_traits()
    else:
        print """No traits tutorial found in %s.

Correct usage is: python tutor.py [tutorial_path]
where: tutorial_path = Path to the root of the traits tutorial.

If tutorial_path is omitted, the current directory is assumed to be the root of
the tutorial.""" % path


########NEW FILE########
__FILENAME__ = styled_date_editor_test

from datetime import date

from traits.etsconfig.api import ETSConfig
ETSConfig.toolkit = 'qt4'

from traits.api import Date, Dict, HasTraits, List, on_trait_change
from traitsui.api import View, Item, StyledDateEditor
from traitsui.editors.styled_date_editor import CellFormat

class Foo(HasTraits):
    dates = Dict()
    styles = Dict()

    fast_dates = List
    slow_dates = List

    current_date = Date()

    traits_view = View(Item("current_date", style="custom", show_label=False,
                        editor=StyledDateEditor(dates_trait="dates", styles_trait="styles")))

    def __init__(self, *args, **kw):
        HasTraits.__init__(self, *args, **kw)
        self.styles = {
                "fast" : CellFormat(bold=True, fgcolor="darkGreen"),
                "slow" : CellFormat(italics=True, fgcolor="lightGray"),
                }

        self.fast_dates = [date(2010,7,4), date(2010,7,3), date(2010,7,2)]
        self.slow_dates = [date(2010,6,28), date(2010,6,27), date(2010,6,24)]

    @on_trait_change("fast_dates,slow_dates")
    def _update_dates_dict(self):
        self.dates["fast"] = self.fast_dates
        self.dates["slow"] = self.slow_dates

    def _current_date_changed(self, old, new):
        print "Old:", old, "New:", new


def main():
    foo = Foo()
    foo.configure_traits()


if __name__ == "__main__":
    main()



########NEW FILE########
__FILENAME__ = array_editor_test
#-------------------------------------------------------------------------------
#
#  ArrayEditor test case
#
#  Written by: David C. Morrill
#
#  Date: 01/10/2006
#
#  (c) Copyright 2006 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasPrivateTraits, Array

from traitsui.api \
    import View, ArrayEditor

#-------------------------------------------------------------------------------
#  'Test' class:
#-------------------------------------------------------------------------------

class Test ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    three = Array( int, (3,3) )
    four  = Array( float, (4,4), editor = ArrayEditor( width = -50 ) )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    view = View( 'three', '_', 'three', '_', 'three~', '_',
                 'four',  '_', 'four',  '_', 'four~',
                 title     = 'ArrayEditor Test Case',
                 resizable = True )

#-------------------------------------------------------------------------------
#  Run the test case:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Test().configure_traits()

########NEW FILE########
__FILENAME__ = buttons_test
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api \
    import *

from traitsui.api \
    import *

from traitsui.menu \
    import *

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( Handler ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )
    notes = Str

    #---------------------------------------------------------------------------
    #  Handles the 'Annoy' button being clicked:
    #---------------------------------------------------------------------------

    def _annoy_clicked ( self, info ):
        self.edit_traits( view = View( title   = 'Annoying',
                                       kind    = 'modal',
                                       buttons = [ 'OK' ] ) )

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    AnnoyButton = Action( name         = 'Annoy',
                          tooltip      = 'Click me to be annoyed',
                          enabled_when = 'age >= 40' )

    person = Person( name = 'Bill', age = 42, phone = '555-1212' )

    fields = Group( 'name', 'age', 'phone', 'notes~' )

    person.notes = ("Should have 6 standard 'live' buttons: Undo, Redo, "
                    "Revert, OK, Cancel, Help")
    person.configure_traits( view = View( fields,
                             kind    = 'livemodal',
                             buttons = LiveButtons ) )

    person.notes = ("Should have 5 standard 'modal' buttons: Apply, Revert, "
                    "OK, Cancel, Help")
    person.configure_traits( view = View( fields,
                                          buttons = ModalButtons ) )

    person.notes = "Should have 2 standard buttons: OK, Cancel"
    person.configure_traits(
               view = View( fields,
                            buttons = [ OKButton, CancelButton ] ) )

    person.notes = "Should have 1 standard button: OK (enabled when age >= 40)"
    person.configure_traits(
               view = View( fields,
                            buttons      = [ Action( name = 'OK',
                            enabled_when = 'age >= 40' ) ] ) )

    person.notes = "Should have 1 standard button: OK (visible when age >= 40)"
    person.configure_traits(
               view = View( fields,
                            buttons      = [ Action( name = 'OK',
                            visible_when = 'age >= 40' ) ] ) )

    person.notes = ("Should have 2 standard buttons: OK, Help (defined when "
                    "age >= 50)")
    person.configure_traits(
               view = View( fields,
                            buttons      = [ 'OK', Action( name = 'Help',
                            defined_when = 'age >= 50' ) ] ) )

    person.notes = ("Should have 1 user and 5 standard buttons: Annoy (enabled "
                    "when age >= 40), Apply, Revert, OK, Cancel, Help")
    person.configure_traits(
               view    = View( fields,
               buttons = [ AnnoyButton ] + ModalButtons ) )


########NEW FILE########
__FILENAME__ = check_list_editor_test
#-------------------------------------------------------------------------------
#
#  CheckListEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 06/29/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import Enum, List

from traitsui.api \
    import Handler, View, Item, CheckListEditor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

colors  = [ 'red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet' ]

numbers = [ 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',
            'nine', 'ten' ]

#-------------------------------------------------------------------------------
#  'CheckListTest' class:
#-------------------------------------------------------------------------------

class CheckListTest ( Handler ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    case  = Enum( 'Colors', 'Numbers' )
    value = List( editor = CheckListEditor( values = colors, cols = 5 ) )

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def object_case_changed ( self, info ):
        if self.case == 'Colors':
            info.value.factory.values = colors
        else:
            info.value.factory.values = numbers

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    clt = CheckListTest()
    clt.configure_traits(
        view = View( 'case', '_', Item( 'value',  id = 'value' ) ) )
    print 'value:', clt.value
    clt.configure_traits(
        view = View( 'case', '_', Item( 'value@',  id = 'value' ) ) )
    print 'value:', clt.value

########NEW FILE########
__FILENAME__ = check_list_editor_test2
#-------------------------------------------------------------------------------
#
#  CheckListEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 06/29/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import Enum, List, Str

from traitsui.api \
    import Handler, View, Item, CheckListEditor

#-------------------------------------------------------------------------------
#  'CheckListTest' class:
#-------------------------------------------------------------------------------

class CheckListTest ( Handler ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    value       = List( editor = CheckListEditor( name = 'values', cols = 5 ) )
    values      = List( Str )
    values_text = Str( 'red orange yellow green blue indigo violet' )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    simple_view = View( 'value',  'values_text@' )
    custom_view = View( 'value@', 'values_text@' )

    #---------------------------------------------------------------------------
    #  'Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        super( CheckListTest, self ).__init__( **traits )
        self._values_text_changed()

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def _values_text_changed ( self ):
        self.values = self.values_text.split()

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    clt = CheckListTest()
    clt.configure_traits( view = 'simple_view' )
    print 'value:', clt.value
    clt.configure_traits( view = 'custom_view' )
    print 'value:', clt.value

########NEW FILE########
__FILENAME__ = code_editor_test
#-------------------------------------------------------------------------------
#
#  Test using a KeyBindings object with the traits Codeditor
#
#  Written by: David C. Morrill
#
#  Date: 09/22/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasPrivateTraits, Code, Str

from traitsui.api \
    import View, Item, Handler, CodeEditor

from traitsui.key_bindings \
    import KeyBinding, KeyBindings

#-------------------------------------------------------------------------------
#  Define a KeyBindings object:
#-------------------------------------------------------------------------------

key_bindings = KeyBindings(

    KeyBinding( binding1    = 'Ctrl-s',
                description = 'Save to a file',
                method_name = 'save_file' ),

    KeyBinding( binding1    = 'Ctrl-r',
                description = 'Run script',
                method_name = 'run_script' ),

    KeyBinding( binding1    = 'Ctrl-q',
                description = 'Edit key bindings',
                method_name = 'edit_bindings' )
)

#-------------------------------------------------------------------------------
#  'CodeHandler' class:
#-------------------------------------------------------------------------------

class CodeHandler ( Handler ):

    def save_file ( self, info ):
        info.object.status = "save file"

    def run_script ( self, info ):
        info.object.status = "run script"

    def edit_bindings ( self, info ):
        info.object.status = "edit bindings"
        key_bindings.edit_traits()

#-------------------------------------------------------------------------------
#  'TestCode' class:
#-------------------------------------------------------------------------------

class TestCode ( HasPrivateTraits ):

    code   = Code
    status = Str

    view = View(
               [ Item( 'code',
                       style     = 'custom',
                       resizable = True,
                       editor    = CodeEditor( key_bindings = key_bindings ) ),
                 'status~',
                 '|<>' ],
               id = 'traitsui.tests.test_code_editor.TestCode',
               title     = 'Sample Code Editor',
               width     = 0.4,
               height    = 0.4,
               resizable = True,
               handler   = CodeHandler() )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    TestCode().configure_traits()


########NEW FILE########
__FILENAME__ = enum_dynamic_test
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *

def evaluate_value(v):
    print 'evaluate_value', v
    return str(v)

class Team ( HasTraits ):

    captain = Str( 'Dick' )
    players = List( [ 'Tom', 'Dick', 'Harry', 'Sally' ], Str )

    captain_editor = EnumEditor( name = 'players', evaluate=evaluate_value )

    view = View( Item( 'captain', editor = captain_editor),
                 '_',
                 'players@',
                 height=200 )

if __name__ == '__main__':
    team = Team()
    team.configure_traits()
    team.print_traits()


########NEW FILE########
__FILENAME__ = enum_editor_test
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Date: 04/06/2005
# Description: Test the EnumEditor trait editor.
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasTraits, Trait, Enum, Range

from traitsui.api \
    import EnumEditor

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

values = [ 'one', 'two', 'three', 'four' ]
enum   = Enum( *values )
range  = Range( 1, 4 )

#-------------------------------------------------------------------------------
#  'TestEnumEditor' class:
#-------------------------------------------------------------------------------

class TestEnumEditor ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    value = Trait( 1, enum, range,
                   editor = EnumEditor( values   = values,
                                        evaluate = int ) )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    test = TestEnumEditor()
    test.configure_traits()
    test.print_traits()


########NEW FILE########
__FILENAME__ = html_editor_test
#-------------------------------------------------------------------------------
#
#  Test case for the HTMLEditor.
#
#  Written by: David C. Morrill
#
#  Date: 09/22/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasPrivateTraits, Code

from traitsui.api \
    import View, Group, Item, HTMLEditor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

sample = """This is a code block:

    def foo ( bar ):
        print 'bar:', bar

This is an unordered list:
 - An
 - unordered
 - list

This is an ordered list:
 * One
 * Two
 * Three

Lists can be nested:
 * One
   * 1.1
   * 1.2
 * Two
   * 2.1
   * 2.2
"""

#-------------------------------------------------------------------------------
#  'TestHTML' class:
#-------------------------------------------------------------------------------

class TestHTML ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Text string to display as HTML:
    html = Code( sample )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    view = View( Group(
                     [ Item( 'html#@', editor = HTMLEditor() ), '|<>' ],
                     [ '{Enter formatted text and/or HTML below:}@',
                       'html#@', '|<>' ],
                     '|<>', layout = 'split' ),
                 title     = 'HTML Editor Test',
                 resizable = True,
                 width     = 0.4,
                 height    = 0.6 )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    TestHTML().configure_traits()

########NEW FILE########
__FILENAME__ = instance_drag_test
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Date: 12/04/2004
# Description: Test case for the traits tree editor.
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasTraits, Str, Regex, List, Instance

from traitsui.api \
    import TreeEditor, TreeNode, View, Group, Item, Handler, InstanceEditor

from traitsui.instance_choice \
    import InstanceDropChoice

from traitsui.menu \
    import Menu, Action, Separator

from traitsui.wx.tree_editor \
    import NewAction, CopyAction, CutAction, PasteAction, DeleteAction, \
           RenameAction

#-------------------------------------------------------------------------------
#  'Employee' class:
#-------------------------------------------------------------------------------

class Employee ( HasTraits ):
    name  = Str( '<unknown>' )
    title = Str
    phone = Regex( regex = r'\d\d\d-\d\d\d\d' )

    view = View( 'title', 'phone' )

    def default_title ( self ):
        self.title = 'Senior Engineer'

#-------------------------------------------------------------------------------
#  'Department' class:
#-------------------------------------------------------------------------------

class Department ( HasTraits ):
    name      = Str( '<unknown>' )
    employees = List( Employee )

    view = View( [ 'employees', '|<>' ] )

#-------------------------------------------------------------------------------
#  'Company' class:
#-------------------------------------------------------------------------------

class Company ( HasTraits ):
    name        = Str( '<unknown>' )
    departments = List( Department )
    employees   = List( Employee )

#-------------------------------------------------------------------------------
#  'Partner' class:
#-------------------------------------------------------------------------------

class Partner ( HasTraits ):
    name    = Str( '<unknown>' )
    company = Instance( Company )
    eom     = Instance( Employee )
    dom     = Instance( Department )

#-------------------------------------------------------------------------------
#  Create a hierarchy:
#-------------------------------------------------------------------------------

jason = Employee(
     name  = 'Jason',
     title = 'Sr. Engineer',
     phone = '536-1057' )

mike = Employee(
     name  = 'Mike',
     title = 'Sr. Engineer',
     phone = '536-1057' )

dave = Employee(
     name  = 'Dave',
     title = 'Sr. Engineer',
     phone = '536-1057' )

martin = Employee(
     name  = 'Martin',
     title = 'Sr. Engineer',
     phone = '536-1057' )

duncan = Employee(
     name  = 'Duncan',
     title = 'Sr. Engineer' )

partner = Partner(
    name    = 'eric',
    company = Company(
        name        = 'Enthought, Inc.',
        departments = [
            Department(
                name      = 'Business',
                employees = [ jason, mike ]
            ),
            Department(
                name      = 'Scientific',
                employees = [ dave, martin, duncan ]
            )
        ],
        employees = [ dave, martin, mike, duncan, jason ]
    )
)

#-------------------------------------------------------------------------------
#  Define the tree trait editor:
#-------------------------------------------------------------------------------

no_view = View()

tree_editor = TreeEditor(
    editable = False,
    nodes = [
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = '',
                  label     = 'name',
                  view      = View( [ 'name', '|<' ] ) ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'departments',
                  label     = '=Departments',
                  view      = no_view,
                  add       = [ Department ] ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'employees',
                  label     = '=Employees',
                  view      = no_view,
                  add       = [ Employee ] ),
        TreeNode( node_for  = [ Department ],
                  auto_open = True,
                  children  = 'employees',
                  label     = 'name',
                  menu      = Menu( NewAction,
                                    Separator(),
                                    DeleteAction,
                                    Separator(),
                                    RenameAction,
                                    Separator(),
                                    CopyAction,
                                    CutAction,
                                    PasteAction ),
                  view      = View( [ 'name', '|<' ] ),
                  add       = [ Employee ] ),
        TreeNode( node_for  = [ Employee ],
                  auto_open = True,
                  label     = 'name',
                  menu      = Menu( NewAction,
                                    Separator(),
                                    Action( name   = 'Default title',
                                            action = 'object.default_title' ),
                                    Action( name   = 'Department',
                                            action = 'handler.employee_department(editor,object)' ),
                                    Separator(),
                                    CopyAction,
                                    CutAction,
                                    PasteAction,
                                    Separator(),
                                    DeleteAction,
                                    Separator(),
                                    RenameAction ),
                  view      = View( [ 'name', 'title', 'phone', '|<' ] ) )
    ]
)

#-------------------------------------------------------------------------------
#  'TreeHandler' class:
#-------------------------------------------------------------------------------

class TreeHandler ( Handler ):

    def employee_department ( self, editor, object ):
        dept = editor.get_parent( object )
        print '%s works in the %s department.' % ( object.name, dept.name )

#-------------------------------------------------------------------------------
#  Define the View to use:
#-------------------------------------------------------------------------------

view = View(
    Group(
        [ Item( 'company',
                editor    = tree_editor,
                resizable = True ),
          '|<>' ],
        Group(
            [ '{Employee of the Month}@',
              Item( 'eom@',
                    editor = InstanceEditor( values = [
                                 InstanceDropChoice( klass      = Employee,
                                                     selectable = True ) ] ),
                    resizable = True ),
              '|<>' ],
            [ '{Department of the Month}@',
              Item( 'dom@',
                    editor = InstanceEditor( values = [
                                 InstanceDropChoice( klass = Department ) ] ),
                    resizable = True ),
              '|<>' ],
            show_labels = False,
            layout      = 'split' ),
        orientation = 'horizontal',
        show_labels = False,
        layout      = 'split' ),
    title     = 'Company Structure',
    handler   = TreeHandler(),
    buttons   = [ 'OK', 'Cancel' ],
    resizable = True,
    width     = .5,
    height    = .5
)

#-------------------------------------------------------------------------------
#  Edit it:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    partner.configure_traits( view = view )


########NEW FILE########
__FILENAME__ = instance_editor_test
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *
from traitsui.instance_choice import InstanceChoice

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone' )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'Team' class:
#-------------------------------------------------------------------------------

class Team ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', '_',
                        Item( 'captain@',
                              editor = InstanceEditor( name = 'roster' ) ),
                        buttons = [ 'Undo', 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()

########NEW FILE########
__FILENAME__ = instance_editor_test2
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *
from traitsui.instance_choice \
    import InstanceChoice, InstanceFactoryChoice

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone' )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'Team' class:
#-------------------------------------------------------------------------------

class Team ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', '_',
                        Item( 'captain@',
                              editor = InstanceEditor( name   = 'roster',
                                                       values = [
                                           InstanceFactoryChoice(
                                               klass = Person,
                                               name  = 'Non player' ) ] ) ) )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()

########NEW FILE########
__FILENAME__ = instance_editor_test3
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *
from traitsui.instance_choice import InstanceChoice

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone' )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'Team' class:
#-------------------------------------------------------------------------------

class Team ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', '_',
                        Item( 'captain@',
                              editor = InstanceEditor( name = 'roster' ) ), '_',
                        'roster' )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()

########NEW FILE########
__FILENAME__ = instance_editor_test4
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *
from traitsui.instance_choice import InstanceChoice

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone' )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'Team' class:
#-------------------------------------------------------------------------------

class Team ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', '_',
                        Item( 'captain@',
                              editor = InstanceEditor( name     = 'roster',
                                                       editable = False ) ),
                        '_', 'roster' )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()

########NEW FILE########
__FILENAME__ = instance_editor_test5
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *
from traitsui.instance_choice \
    import InstanceChoice, InstanceFactoryChoice

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name~', 'age~', 'phone~' )
    edit_view   = View( 'name',  'age',  'phone'  )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'Team' class:
#-------------------------------------------------------------------------------

class Team ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ 'name', '_',
                            Item( 'captain@',
                                  editor = InstanceEditor( name     = 'roster',
                                                           editable = False,
                                                           values   = [
                                               InstanceFactoryChoice(
                                                   klass = Person,
                                                   name  = 'Non player',
                                                   view  = 'edit_view' ) ] ) ),
                            '_' ],
                        [ 'captain@', '|<>' ] ] )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()

########NEW FILE########
__FILENAME__ = instance_editor_test6
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *
from traitsui.instance_choice \
    import InstanceChoice, InstanceFactoryChoice

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone',
                        buttons = [ 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'Team' class:
#-------------------------------------------------------------------------------

class Team ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    captain = Instance( Person )
    roster  = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ 'name', '_',
                          Item( 'captain',
                                editor = InstanceEditor( name   = 'roster',
                                                         label  = 'Edit...',
                                                         values = [
                                             InstanceFactoryChoice(
                                                 klass = Person,
                                                 name  = 'Non player',
                                                 view  = 'edit_view' ) ] ) ) ],
                        buttons = [ 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    Team( name    = 'Vultures',
          captain = people[0],
          roster  = people ).configure_traits()

########NEW FILE########
__FILENAME__ = large_range_editor
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api import HasTraits, Float, List
from traitsui.api import View, Item, RangeEditor

# Tests the Large Range Slider editor. It also tests the case where the
# editor is embedded in a list.
class TestRangeEditor(HasTraits):
    x = Float
    low = Float(123.123)
    high = Float(1123.123)
    list = List(Float(
                     editor = RangeEditor(low_name='low',
                                          high_name = 'high',
                                          # These force the large range
                                          # slider to be used.
                                          low=100.0,
                                          high=10000.123)
                     )
               )
    view = View(Item(name='x',
                     editor = RangeEditor(low_name='low',
                                          high_name = 'high',
                                          # These force the large range
                                          # slider to be used.
                                          low=100.0,
                                          high=10000.123)
                     ),
                 Item('list'),
                 resizable=True
                )

def test():
    a = TestRangeEditor()
    a.x = 500
    a.list.append(500)
    a.edit_traits() # Just close the resulting dialog.
    assert a.x == 500
    assert a.list[0] == 500

test()

########NEW FILE########
__FILENAME__ = list_traits_ui_test
#-------------------------------------------------------------------------------
#
#  TableEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 11/11/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasStrictTraits, Str, Int, Regex, List, Instance

from traitsui.api \
    import View, Item, VSplit, TableEditor, ListEditor

from traitsui.table_column \
    import ObjectColumn

from traitsui.table_filter \
    import TableFilter, RuleTableFilter, RuleFilterTemplate, \
           MenuFilterTemplate, EvalFilterTemplate

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone',
                        width   = 0.18,
                        buttons = [ 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  Table editor definition:
#-------------------------------------------------------------------------------

filters      = [ EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate ]

table_editor = TableEditor(
    columns     = [ ObjectColumn( name = 'name' ),
                    ObjectColumn( name = 'age' ),
                    ObjectColumn( name = 'phone' ) ],
    editable    = True,
    deletable   = True,
    sortable    = True,
    sort_model  = True,
    filters     = filters,
    search      = RuleTableFilter(),
    row_factory = Person
)

#-------------------------------------------------------------------------------
#  'ListTraitTest' class:
#-------------------------------------------------------------------------------

class ListTraitTest ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    people = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View(
        VSplit(
            Item( 'people',
                  id     = 'table',
                  editor = table_editor ),
            Item( 'people@',
                  id     = 'list',
                  editor = ListEditor( style = 'custom',
                                       rows  = 5 ) ),
            Item( 'people@',
                  id     = 'notebook',
                  editor = ListEditor( use_notebook = True,
                                       deletable    = True,
                                       export       = 'DockShellWindow',
                                       page_name    = '.name' ) ),
            id          = 'splitter',
            show_labels = False ),
        title     = 'List Trait Editor Test',
        id        = 'traitsui.tests.list_traits_ui_test',
        dock      = 'horizontal',
        width     = .4,
        height    = .6,
        resizable = True,
        kind      = 'live' )

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    ListTraitTest( people = people ).configure_traits()


########NEW FILE########
__FILENAME__ = numeric_editor_test
#-------------------------------------------------------------------------------
#
#  NumericEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 11/29/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasPrivateTraits, Array, Instance

from traitsui.api \
    import View, Item, HGroup

from traitsui.table_column \
    import NumericColumn

from traitsui.wx.numeric_editor \
    import ToolkitEditorFactory as NumericEditor

from blockcanvas.model.api \
    import ANumericModel, NumericArrayModel, ReductionModel, SelectionModel, \
           NumericItem, ExpressionFilter, IndexFilter

from numpy \
    import array, sin, arange

#-------------------------------------------------------------------------------
#  Defines the numeric editor:
#-------------------------------------------------------------------------------

number_editor = NumericEditor(
    extendable              = True,
    new_columns             = 'last',
    configurable            = True,
    columns                 = [ NumericColumn( name   = 'model_indices',
                                               label  = 'i' ),
                                NumericColumn( name   = 'x',
                                               label  = 'x',
                                               format = '%.2f' ),
                                NumericColumn( name   = 'sinx',
                                               label  = 'sin(x)',
                                               format = '%.3f' ),
                                NumericColumn( name   = 'xsinx',
                                               label  = 'x*sin(x)',
                                               format = '%.3f' ) ],
    other_columns           = [],
    choose_selection_filter = True,
    edit_selection_filter   = True,
    edit_selection_colors   = False,
    selection_filter        = None,
    selection_filter_name   = '',
    user_selection_filter   = IndexFilter(),
    choose_reduction_filter = True,
    edit_reduction_filter   = True,
    reduction_filter        = None,
    reduction_filter_name   = '',
    deletable               = True,
    sortable                = True,
    sort_model              = False,
    editable                = True,
    auto_size               = False,
    show_lines              = True,
    menu                    = None,
    show_column_labels      = True,
    #line_color              = 0xC4C0A9,
    #cell_font              = Font,
    #cell_color              = Color( 'black' )
    #cell_bg_color           = Color( 'white' )
    #cell_read_only_bg_color = Color( 0xF8F7F1 )
    #label_font              = Font
    #label_color             = Color( 'black' )
    #label_bg_color          = Color( 0xD7D2BF )
    #selection_bg_color      = Color( 0x0D22DF )
    #selection_color         = Color( 'white' )
    #column_label_height     = Int( 25 )
    #row_label_width         = Int( 82 )
    #on_select               = Callable
    #on_dclick               = Callable
)

#-------------------------------------------------------------------------------
#  'BunchANumbersApp' class:
#-------------------------------------------------------------------------------

class BunchANumbersApp ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    model = Instance( ANumericModel )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    view = View(
               HGroup( Item( 'model', editor = number_editor,
                                      id     = 'model' ),
#                       Item( 'model', editor = number_editor ),
                       show_labels = False ),
                 title     = 'Numeric Editor Test',
                 id        = 'traitsui.tests.numeric_editor_test',
                 width     = 0.28,
                 height    = 0.6,
                 resizable = True )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    x     = arange( 0.0, 20.005, 0.1 )
    model = NumericArrayModel( x = x, sinx = sin( x ), xsinx = x * sin( x ) )
    BunchANumbersApp( model = model ).configure_traits()


########NEW FILE########
__FILENAME__ = set_dynamic_test
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.

from traits.api    import *
from traitsui.api import *

class Team ( HasTraits ):

    batting_order = List( Str )
    roster        = List( [ 'Tom', 'Dick', 'Harry', 'Sally' ], Str )

    view = View( Item( 'batting_order', editor = SetEditor( name    = 'roster',
                                                            ordered = True ) ),
                 '_', 'roster@',
                 height=500,
                 resizable=True)

if __name__ == '__main__':
    Team().configure_traits()

########NEW FILE########
__FILENAME__ = shell_editor_test
#-------------------------------------------------------------------------------
#
#  Traits UI Python ShellEditor test.
#
#  Written by: David C. Morrill
#
#  Date: 10/13/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

from traits.api         import *
from traitsui.api      import *
from traitsui.menu import *

#-------------------------------------------------------------------------------
#  'ShellTest' class:
#-------------------------------------------------------------------------------

class ShellTest ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name    = Str
    age     = Int
    weight  = Float
    shell_1 = Str
    shell_2 = Dict

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    view = View( 'name', 'age', 'weight', '_',
                 Item( 'shell_1', editor = ShellEditor() ),
                 Item( 'shell_2', editor = ShellEditor() ),
                 id        = 'traitsui.tests.shell_editor_test',
                 resizable = True,
                 width     = 0.3,
                 height    = 0.3 )

#-------------------------------------------------------------------------------
#  Run the test:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    ShellTest().configure_traits()


########NEW FILE########
__FILENAME__ = table_editor_color_test
#-------------------------------------------------------------------------------
#
#  TableEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 07/05/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasTraits, List

from traitsui.api \
    import View, Item, TableEditor

from traitsui.color_column \
    import ColorColumn

from enable.api \
    import ColorTrait

class Thingy ( HasTraits ):
    color = ColorTrait( 'black' )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

colors = [
   Thingy( color = 'red'),
   Thingy( color = 'orange'),
   Thingy( color = 'yellow'),
   Thingy( color = 'green'),
   Thingy( color = 'blue'),
   Thingy( color = 'indigo'),
   Thingy( color = 'violet'),
   Thingy( color = 'black'),
   Thingy( color = 'white'),
]

class TableTest ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    colors = List( Thingy )

    table_editor = TableEditor(
        columns            = [ ColorColumn( name = 'color' ),
                             ],

        editable           = True,
        deletable          = True,
        sortable           = True,        #
        sort_model         = True,
        show_lines         = True,        #
        orientation        = 'vertical',
        show_column_labels = True,        #
        row_factory        = Thingy
    )


    traits_view = View(
        [ Item( 'colors',
                id     = 'colors',
                editor = table_editor ),
          '|[]<>' ],
        title     = 'Table Editor Test',
        id        = 'traitsui.tests.table_editor_color_test',
        dock      = 'horizontal',
        width     = .4,
        height    = .3,
        resizable = True,
        kind      = 'live' )

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    tt = TableTest( colors = colors )
    tt.configure_traits()

########NEW FILE########
__FILENAME__ = table_editor_focus_bug
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.


from traits.api import HasTraits, Str, List
from traitsui.api import Group, Item, TableEditor, View
from traitsui.table_column \
    import ObjectColumn

class Word(HasTraits):
    word = Str

class Foo(HasTraits):

    # arbitrary string containing spaces
    input = Str

    # input split on space
    parsed = List


    def _input_changed(self):
        words = self.input.split()

        for word in self.parsed[:]:
            if word.word in words:
                words.remove(word.word)
            else:
                self.parsed.remove(word)


        for word in words:
            self.parsed.append(Word(word=word))

        return


    table_editor = TableEditor(
       columns = [ ObjectColumn( name='word') ],
       editable=True )


    help = Str("""Type in the 'input' box before clicking the Parsed tab.
The first non-whitespace character will cause changes to the parsed trait
and therefore changes to the table rows.  That is expected.

BUG: the table grabs the focus from 'input' and thus subsequent typing goes
into one of the table cells.

If you click the 'Parsed' tab, to view the table, and then the 'Inputs' tab
the focus will stay with the 'input' box.
""")

    traits_view = View(
       Group( Item( 'help', style='readonly'),
              Item( 'input' ),
              label='Input'),
       Group( Item( 'parsed', editor=table_editor),
              label='Parsed' ),
       dock = 'tab',
       resizable=True,
       width=320,
       height=240
       )

if __name__ == '__main__':

    # simple test of the model
    foo = Foo()
    foo.input = 'these words in the list'
    assert( [word.word for word in foo.parsed] == ['these', 'words', 'in', 'the', 'list'] )
    foo.input = 'these dudes in the bar'
    assert( [word.word for word in foo.parsed] == ['these', 'in', 'the', 'dudes', 'bar'] )

    foo.configure_traits( kind='modal' )
    print foo.input, [word.word for word in foo.parsed]


########NEW FILE########
__FILENAME__ = table_editor_test
#-------------------------------------------------------------------------------
#
#  TableEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 07/05/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasStrictTraits, Str, Int, Regex, List, Instance

from traitsui.api \
    import View, Group, Item, TableEditor, EnumEditor

from traitsui.table_column \
    import ObjectColumn

from traitsui.table_filter \
    import TableFilter, RuleTableFilter, RuleFilterTemplate, \
           MenuFilterTemplate, EvalFilterTemplate

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------




class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )
    state = Str

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone', 'state',
                        title   = 'Create new person',
                        width   = 0.18,
                        buttons = [ 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   Person( name = 'Joe',    age = 34, phone = '555-6943' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   Person( name = 'Sally',  age = 43, phone = '555-8797' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'AgeFilter' class:
#-------------------------------------------------------------------------------

class AgeFilter ( TableFilter ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name = "Age filter"
    _name = "Age filter"

    age = Int( 0 )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    #filter_view = Group( 'age{Age >=}' )

    #---------------------------------------------------------------------------
    #  Returns whether an object passes the filter or not:
    #---------------------------------------------------------------------------

    def filter ( self, person ):
        """ Returns whether an object passes the filter or not.
        """
        return (person.age >= self.age)

    #---------------------------------------------------------------------------
    #  Returns a user readable description of what the filter does:
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a user readable description of what the filter does.
        """
        return 'Age >= %d' % self.age

    def _age_changed(self, old, new):
        self.name = self.description()
        print 'AgeFilter _age_changed', self.name

#-------------------------------------------------------------------------------
#  'NameFilter' class:
#-------------------------------------------------------------------------------

class NameFilter ( TableFilter ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    mname = Str

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    filter_view = Group( 'mname{Name contains}' )

    #---------------------------------------------------------------------------
    #  Returns whether an object passes the filter or not:
    #---------------------------------------------------------------------------

    def filter ( self, person ):
        """ Returns whether an object passes the filter or not.
        """
        return (person.name.lower().find( self.mname.lower() ) >= 0)

    #---------------------------------------------------------------------------
    #  Returns a user readable description of what the filter does:
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a user readable description of what the filter does.
        """
        return "Name contains '%s'" % self.mname

#-------------------------------------------------------------------------------
#  Table editor definition:
#-------------------------------------------------------------------------------

filters      = [ AgeFilter( age = 30 ), NameFilter( mname = 'd' ), EvalFilterTemplate, MenuFilterTemplate, RuleFilterTemplate,
                 ]

def evaluate_value(v):
    print 'evaluate_value', v
    return str(v)
#-------------------------------------------------------------------------------
#  'TableTest' class:
#-------------------------------------------------------------------------------

class TableTest ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #people = Instance( Person )
    people = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    _valid_states = List(["AL", "AR", "AZ", "AK"])

    _state_editor = EnumEditor(
        name     = "_valid_states",
        evaluate = evaluate_value,
        object   = 'table_editor_object'
    )


    table_editor = TableEditor(
        columns            = [ ObjectColumn( name = 'name' ),
                               ObjectColumn( name = 'age' ),
                               ObjectColumn( name = 'phone' ),
                               ObjectColumn( name = 'state',
                                             editor=_state_editor), ],
        editable           = True,
        deletable          = True,
        sortable           = True,
        sort_model         = True,
        show_lines         = True,
        orientation        = 'vertical',
        show_column_labels = True,
        edit_view          = View( [ 'name', 'age', 'phone', 'state', '|[]' ],
                                   resizable = True ),
        filter             = None,
        filters            = filters,
        row_factory        = Person
    )


    traits_view = View(
        [ Item( 'people',
                id     = 'people',
                editor = table_editor ),
          '|[]<>' ],
        title     = 'Table Editor Test',
        id        = 'traitsui.tests.table_editor_test',
        dock      = 'horizontal',
        width     = .4,
        height    = .3,
        resizable = True,
        kind      = 'live' )


#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    tt = TableTest( people = people )
    tt.configure_traits()
    for p in tt.people:
        p.print_traits()
        print '--------------'

########NEW FILE########
__FILENAME__ = table_editor_test2
#-------------------------------------------------------------------------------
#
#  TableEditor test case for Traits UI
#
#  Written by: David C. Morrill
#
#  Date: 07/05/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasStrictTraits, Str, Int, Regex, List

from traitsui.api \
    import View

#-------------------------------------------------------------------------------
#  'Person' class:
#-------------------------------------------------------------------------------

class Person ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name  = Str
    age   = Int
    phone = Regex( value = '000-0000', regex = '\d\d\d[-]\d\d\d\d' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone',
                        title   = 'Create new person',
                        width   = 0.18,
                        buttons = [ 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  'WorkingPerson' class
#-------------------------------------------------------------------------------

class WorkingPerson ( Person ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    job = Str

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'name', 'age', 'phone', 'job',
                        title   = 'Create new working person.........',
                        width   = 0.18,
                        buttons = [ 'OK', 'Cancel' ] )

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   Person( name = 'Dave',   age = 39, phone = '555-1212' ),
   Person( name = 'Mike',   age = 28, phone = '555-3526' ),
   WorkingPerson( name = 'Joe', age = 34, phone = '555-6943', job = 'Fireman' ),
   Person( name = 'Tom',    age = 22, phone = '555-7586' ),
   Person( name = 'Dick',   age = 63, phone = '555-3895' ),
   Person( name = 'Harry',  age = 46, phone = '555-3285' ),
   WorkingPerson( name = 'Sally', age = 43, phone = '555-8797', job = 'Soldier' ),
   Person( name = 'Fields', age = 31, phone = '555-3547' )
]

#-------------------------------------------------------------------------------
#  'TableTest' class:
#-------------------------------------------------------------------------------

class TableTest ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    people = List( Person )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ 'people#', '|<>' ], resizable = True )

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    tt = TableTest( people = people )
    tt.configure_traits()
    for p in tt.people:
        p.print_traits()
        print '--------------'

########NEW FILE########
__FILENAME__ = table_list_editor_test
#-------------------------------------------------------------------------------
#
#  TableEditor test case for Traits UI which tests editing of lists instead of
#  editing of objects.
#
#  Written by: David C. Morrill
#
#  Date: 07/06/2005
#
#  (c) Copyright 2005 by Enthought, Inc.
#  Copyright (c) 2007, Enthought, Inc.
#  License: BSD Style.
#
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import HasStrictTraits, List

from traitsui.api \
    import View, Item, TableEditor

from traitsui.table_column \
    import ListColumn

from traitsui.table_filter \
    import TableFilter

#-------------------------------------------------------------------------------
#  Sample data:
#-------------------------------------------------------------------------------

people = [
   [ 'Dave',   39, '555-1212' ],
   [ 'Mike',   28, '555-3526' ],
   [ 'Joe',    34, '555-6943' ],
   [ 'Tom',    22, '555-7586' ],
   [ 'Dick',   63, '555-3895' ],
   [ 'Harry',  46, '555-3285' ],
   [ 'Sally',  43, '555-8797' ],
   [ 'Fields', 31, '555-3547' ]
]

#-------------------------------------------------------------------------------
#  Table editor definition:
#-------------------------------------------------------------------------------

table_editor = TableEditor(
    columns            = [ ListColumn( index = 0, label = 'Name'  ),
                           ListColumn( index = 1, label = 'Age'   ),
                           ListColumn( index = 2, label = 'Phone' ) ],
    editable           = False,
    show_column_labels = True,       #
)

#-------------------------------------------------------------------------------
#  'TableTest' class:
#-------------------------------------------------------------------------------

class TableTest ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    people = List

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ Item( 'people',
                                editor    = table_editor,
                                resizable = True ),
                          '|[]<>' ],
                        title   = 'Table Editor Test',
                        width   = .17,
                        height  = .23,
                        buttons = [ 'OK', 'Cancel' ],
                        kind    = 'live' )

#-------------------------------------------------------------------------------
#  Run the tests:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    tt = TableTest( people = people )
    tt.configure_traits()
    for p in tt.people:
        print p
        print '--------------'

########NEW FILE########
__FILENAME__ = test_ui
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill Date: 11/02/2004 Description: Test case for Traits
# User Interface
# ------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Trait, HasTraits, Str, Int, Range, List, Event, File, Directory, \
           Bool, Color, Font, Enum

from traitsui.api \
    import View, Handler, Item, CheckListEditor, ButtonEditor, FileEditor, \
           DirectoryEditor, ImageEnumEditor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

origin_values = [ 'top left', 'top right', 'bottom left', 'bottom right' ]

#-------------------------------------------------------------------------------
#  'Instance' class:
#-------------------------------------------------------------------------------

class Instance ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    integer_text = Int( 1 )
    enumeration  = Enum( 'one', 'two', 'three', 'four', 'five', 'six',
                         cols = 3 )
    float_range  = Range( 0.0, 10.0, 10.0 )
    int_range    = Range( 1, 5 )
    boolean      = Bool( True )

    view         = View( 'integer_text', 'enumeration', 'float_range',
                         'int_range', 'boolean' )

#-------------------------------------------------------------------------------
#  'TraitsTest' class
#-------------------------------------------------------------------------------

class TraitsTest ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    integer_text = Int( 1 )
    enumeration  = Enum( 'one', 'two', 'three', 'four', 'five', 'six',
                         cols = 3 )
    float_range  = Range( 0.0, 10.0, 10.0 )
    int_range    = Range( 1, 6 )
    int_range2   = Range( 1, 50 )
    compound     = Trait( 1, Range( 1, 6 ),
                          'one', 'two', 'three', 'four', 'five', 'six' )
    boolean      = Bool( True )
    instance     = Trait( Instance() )
    color        = Color
    font         = Font
    check_list   = List( editor = CheckListEditor(
                                   values = [ 'one', 'two', 'three', 'four' ],
                                   cols   = 4 ) )
    list         = List( Str, [ 'East of Eden', 'The Grapes of Wrath',
                                'Of Mice and Men' ] )
    button       = Event( 0, editor = ButtonEditor( label = 'Click' ) )
    file         = File
    directory    = Directory
    image_enum   = Trait( editor = ImageEnumEditor( values = origin_values,
                                                   suffix = '_origin',
                                                   cols   = 4,
                                                   klass  = Instance ),
                         *origin_values )

    #---------------------------------------------------------------------------
    #  View definitions:
    #---------------------------------------------------------------------------

    view = View(
                 ( '|{Enum}',
                   ( '|<[Enumeration]',  'enumeration[Simple]',  '_',
                                         'enumeration[Custom]@', '_',
                                         'enumeration[Text]*',   '_',
                                         'enumeration[Readonly]~' ),
                   ( '|<[Check List]',   'check_list[Simple]',  '_',
                                         'check_list[Custom]@', '_',
                                         'check_list[Text]*',   '_',
                                         'check_list[Readonly]~' )
                 ),
                 ( '|{Range}',
                   ( '|<[Float Range]',  'float_range[Simple]',  '_',
                                         'float_range[Custom]@', '_',
                                         'float_range[Text]*',   '_',
                                         'float_range[Readonly]~' ),
                   ( '|<[Int Range]',    'int_range[Simple]',  '_',
                                         'int_range[Custom]@', '_',
                                         'int_range[Text]*',   '_',
                                         'int_range[Readonly]~' ),
                   ( '|<[Int Range 2]',  'int_range2[Simple]',  '_',
                                         'int_range2[Custom]@', '_',
                                         'int_range2[Text]*',   '_',
                                         'int_range2[Readonly]~' )
                 ),
                 ( '|{Misc}',
                   ( '|<[Integer Text]', 'integer_text[Simple]',  '_',
                                         'integer_text[Custom]@', '_',
                                         'integer_text[Text]*',   '_',
                                         'integer_text[Readonly]~' ),
                   ( '|<[Compound]',     'compound[Simple]',  '_',
                                         'compound[Custom]@', '_',
                                         'compound[Text]*',   '_',
                                         'compound[Readonly]~' ),
                   ( '|<[Boolean]',      'boolean[Simple]',  '_',
                                         'boolean[Custom]@', '_',
                                         'boolean[Text]*',   '_',
                                         'boolean[Readonly]~' )
                 ),
                 ( '|{Color/Font}',
                   ( '|<[Color]',        'color[Simple]',  '_',
                                         'color[Custom]@', '_',
                                         'color[Text]*',   '_',
                                         'color[Readonly]~' ),
                   ( '|<[Font]',          'font[Simple]', '_',
                                         'font[Custom]@', '_',
                                         'font[Text]*',   '_',
                                         'font[Readonly]~' )
                 ),
                 ( '|{List}',
                   ( '|<[List]',         'list[Simple]',  '_',
                                         'list[Custom]@', '_',
                                         'list[Text]*',   '_',
                                         'list[Readonly]~' )
                 ),
                 ( '|{Button}',
                   ( '|<[Button]',       'button[Simple]',  '_',
                                         'button[Custom]@' ),
#                                        'button[Text]*',
#                                        'button[Readonly]~' ),
                   ( '|<[Image Enum]',   'image_enum[Simple]',  '_',
                                         'image_enum[Custom]@', '_',
                                         'image_enum[Text]*',   '_',
                                         'image_enum[Readonly]~' ),
                   ( '|<[Instance]',     'instance[Simple]',  '_',
                                         'instance[Custom]@', '_',
                                         'instance[Text]*',   '_',
                                         'instance[Readonly]~' ),
                 ),
                 ( '|{File}',

                   ( '|<[File]',         'file[Simple]',  '_',
                                         'file[Custom]@', '_',
                                         'file[Text]*',   '_',
                                         'file[Readonly]~', ),
                   ( '|<[Directory]',    'directory[Simple]',  '_',
                                         'directory[Custom]@', '_',
                                         'directory[Text]*',   '_',
                                         'directory[Readonly]~' )
                 ),
                 buttons = [ 'Apply', 'Revert', 'Undo', 'OK' ]
               )

#-------------------------------------------------------------------------------
#  'TraitSheetApp' class:
#-------------------------------------------------------------------------------

class TraitSheetApp ( wx.App ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, object ):
        self.object = object
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()

    #---------------------------------------------------------------------------
    #  Handle application initialization:
    #---------------------------------------------------------------------------

    def OnInit ( self ):
        ui = self.object.edit_traits( kind = 'modal' )
        ui = self.object.edit_traits( kind = 'wizard' )
        ui = self.object.edit_traits( kind = 'nonmodal' )
        ui = self.object.edit_traits( kind = 'live' )
        self.SetTopWindow( ui.control )
        return True

#-------------------------------------------------------------------------------
#  Main program:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    TraitSheetApp( TraitsTest() )


########NEW FILE########
__FILENAME__ = test_ui2
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill Date: 11/02/2004 Description: Test case for Traits
# User Interface
# ------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from kiva.traits.kiva_font_trait \
    import KivaFont

from enable.traits.api \
    import RGBAColor

from traits.api \
    import Trait, HasTraits, Str, Int, Range, List, Event, Bool

from traitsui.api \
    import View, Handler, Item, CheckListEditor, ButtonEditor, FileEditor, \
           DirectoryEditor, ImageEnumEditor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

origin_values = [ 'top left', 'top right', 'bottom left', 'bottom right' ]

#-------------------------------------------------------------------------------
#  'PersonHandler' class:
#-------------------------------------------------------------------------------

class PersonHandler ( Handler ):

    def object_zip_changed ( self, info ):
        obj     = info.object
        enabled = (obj.zip >= 10000)
        info.street.enabled = enabled
        info.city.enabled   = enabled
        info.state.enabled  = enabled
        if obj.zip == 78664:
            obj.street = '901 Morning View Place'
            obj.city   = 'Round Rock'
            obj.state  = 'Texas'

    def object_call_changed ( self, info ):
        print 'You called?'

#-------------------------------------------------------------------------------
#  'WizardHandler' class:
#-------------------------------------------------------------------------------

class WizardHandler ( Handler ):

    def object_sex_changed ( self, info ):
        if info.object.sex == 'Female':
            info.p1.next = 'p3'
        else:
            info.p1.next = 'p2'
            info.p2.next = None

    def object_name_changed ( self, info ):
        info.p2.enabled = info.p3.enabled = (info.object.name != '')
        if not info.p2.enabled:
            info.p2.msg = info.p3.msg = 'You must enter a valid name.'

#-------------------------------------------------------------------------------
#  'Employer' class:
#-------------------------------------------------------------------------------

class Employer ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    company = Str
    boss    = Str

    view    = View( 'company', 'boss' )

#-------------------------------------------------------------------------------
#  'Person' class
#-------------------------------------------------------------------------------

class Person ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    name      = Str( 'David Morrill' )
    age       = Int( 39 )
    sex       = Trait( 'Male', 'Female' )
    coolness  = Range( 0.0, 10.0, 10.0 )
    number    = Trait( 1, Range( 1, 6 ),
                       'one', 'two', 'three', 'four', 'five', 'six' )
    human     = Bool( True )
    employer  = Trait( Employer( company = 'Enthought, Inc.', boss = 'eric' ) )
    eye_color = RGBAColor
    set       = List( editor = CheckListEditor(
                                  values = [ 'one', 'two', 'three', 'four' ],
                                  cols   = 4 ) )
    font      = KivaFont
    street    = Str
    city      = Str
    state     = Str
    zip       = Int( 78663 )
    password  = Str
    books     = List( Str, [ 'East of Eden', 'The Grapes of Wrath',
                             'Of Mice and Men' ] )
    call      = Event( 0, editor = ButtonEditor( label = 'Click to call' ) )
    info      = Str( editor = FileEditor() )
    location  = Str( editor = DirectoryEditor() )
    origin    = Trait( editor = ImageEnumEditor( values = origin_values,
                                                 suffix = '_origin',
                                                 cols   = 4,
                                                 klass  = Employer ),
                       *origin_values )

    nm   = Item( 'name',     enabled_when = 'object.age >= 21' )
    pw   = Item( 'password', defined_when = 'object.zip == 78664' )
    view = View( ( ( nm, 'age', 'coolness',
                     '_', 'eye_color', 'eye_color@', 'eye_color*', 'eye_color~',
                     '_', 'font', 'font@', 'font*', 'font~',
                     '_', 'set', 'set@', 'set*', 'set~',
                     '_', 'sex', 'sex@', 'sex*', 'sex~',
                     '_', 'human', 'human@', 'human*', 'human~',
                     '_', 'number', 'number@', 'number*', 'number~',
                     '_', 'books', '_', 'books@', '_', 'books*', '_', 'books~',
                     '_', 'info', 'location', 'origin', 'origin@', 'call',
                     'employer', 'employer[]@', 'employer*', 'employer~',
                     pw,
                     '|<[Person:]' ),
                   ( ' ', 'street', 'city', 'state', 'zip', '|<[Address:]' ),
                   ( nm, nm, nm, nm, nm, nm, nm, nm, nm, nm, nm, nm, nm, nm,
                     '|<[Names:]' ),
                   '|' ),
                 title   = 'Traits 2 User Interface Test',
                 handler = PersonHandler(),
                 buttons = [ 'Apply', 'Revert', 'Undo', 'OK' ],
                 height  = 0.5 )

    wizard = View( ( '|p1:', 'name', 'age', 'sex' ),
                   ( '|p2:', 'street', 'city', 'state', 'zip' ),
                   ( '|p3:', 'eye_color', 'origin', 'human' ),
                   handler = WizardHandler() )

#-------------------------------------------------------------------------------
#  'TraitSheetApp' class:
#-------------------------------------------------------------------------------

class TraitSheetApp ( wx.App ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, object ):
        self.object = object
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()
        object.print_traits()

    #---------------------------------------------------------------------------
    #  Handle application initialization:
    #---------------------------------------------------------------------------

    def OnInit ( self ):
        #ui = self.object.edit_traits( 'view', kind = 'live' )
        ui = self.object.edit_traits( 'wizard', kind = 'wizard' )
        self.SetTopWindow( ui.control )
        return True

#-------------------------------------------------------------------------------
#  Main program:
#-------------------------------------------------------------------------------

TraitSheetApp( Person() )


########NEW FILE########
__FILENAME__ = test_ui3
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Date: 11/02/2004
# Description: Test case for Traits User Interface
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api    import Trait, HasTraits, Str, Int
from traitsui.api import View, Group
from traits.api import Color

#-------------------------------------------------------------------------------
#  Model/View classes:
#-------------------------------------------------------------------------------

class Employer ( HasTraits ):
    company = Str
    boss    = Str

    view    = View( 'company', 'boss' )

class Person ( HasTraits ):
    name = Str( 'David Morrill' )
    age  = Int( 39 )

    view = View( 'name', '<extra>', 'age', kind = 'modal' )

class ExtraPerson ( Person ):
    sex       = Trait( 'Male', 'Female' )
    eye_color = Color

    extra     = Group( 'sex', 'eye_color' )

class LocatedPerson ( Person ):
    street = Str
    city   = Str
    state  = Str
    zip    = Int( 78663 )

    extra  = Group( 'street', 'city', 'state', 'zip' )

class EmployedPerson ( LocatedPerson ):
    employer = Trait( Employer( company = 'Enthought, Inc.', boss = 'eric' ) )

    extra    = Group( 'employer', '<extra>' )

#-------------------------------------------------------------------------------
#  'TraitSheetApp' class:
#-------------------------------------------------------------------------------

class TraitSheetApp ( wx.App ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self ):
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()

    #---------------------------------------------------------------------------
    #  Handle application initialization:
    #---------------------------------------------------------------------------

    def OnInit ( self ):
        Person().edit_traits()
        ExtraPerson().edit_traits()
        LocatedPerson().edit_traits()
        EmployedPerson().edit_traits()
        return True

#-------------------------------------------------------------------------------
#  Main program:
#-------------------------------------------------------------------------------

TraitSheetApp()


########NEW FILE########
__FILENAME__ = test_ui4
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Date: 11/02/2004
# Description: Test case for Traits User Interface
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api    import Trait, HasTraits, Str, Int
from traitsui.api import View, Group
from traits.api import Color

#-------------------------------------------------------------------------------
#  Model classes:
#-------------------------------------------------------------------------------

class Employer ( HasTraits ):
    company = Str( 'Enthought, Inc.' )
    boss    = Str( 'eric' )

    view    = View( 'company', 'boss' )

class Person ( HasTraits ):
    name = Str( 'David Morrill' )
    age  = Int( 39 )

class ExtraPerson ( Person ):
    sex       = Trait( 'Male', 'Female' )
    eye_color = Color

class LocatedPerson ( Person ):
    street = Str
    city   = Str
    state  = Str
    zip    = Int( 78663 )

class EmployedPerson ( LocatedPerson ):
    employer = Trait( Employer() )

#-------------------------------------------------------------------------------
#  View classes:
#-------------------------------------------------------------------------------

class PersonView ( HasTraits ):
    view = View( 'name', '<extra>', 'age', kind = 'modal' )

class ExtraPersonView ( PersonView ):
    extra = Group( 'sex', 'eye_color' )

class LocatedPersonView ( PersonView ):
    extra = Group( 'street', 'city', 'state', 'zip' )

class EmployedPersonView ( LocatedPersonView ):
    extra = Group( 'employer', '<extra>' )

#-------------------------------------------------------------------------------
#  'TraitSheetApp' class:
#-------------------------------------------------------------------------------

class TraitSheetApp ( wx.App ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self ):
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()

    #---------------------------------------------------------------------------
    #  Handle application initialization:
    #---------------------------------------------------------------------------

    def OnInit ( self ):
        PersonView().edit_traits( context = Person() )
        ExtraPersonView().edit_traits( context = ExtraPerson() )
        LocatedPersonView().edit_traits( context = LocatedPerson() )
        EmployedPersonView().edit_traits( context = EmployedPerson() )
        return True

#-------------------------------------------------------------------------------
#  Main program:
#-------------------------------------------------------------------------------

TraitSheetApp()


########NEW FILE########
__FILENAME__ = test_ui5
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/02/2004
#
# ------------------------------------------------------------------------------

""" Traits Test case
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Trait, HasTraits, Str, Int, Range, List, Event, File, Directory, Bool

from traitsui.api \
    import View, Handler, Item, CheckListEditor, ButtonEditor, FileEditor, \
           DirectoryEditor, ImageEnumEditor

from traits.api \
    import Color, Font

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

origin_values = [ 'top left', 'top right', 'bottom left', 'bottom right' ]

#-------------------------------------------------------------------------------
#  'Instance' class:
#-------------------------------------------------------------------------------

class Instance ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    integer_text = Int( 1 )
    enumeration  = Trait( 'one', 'two', 'three', 'four', 'five', 'six',
                          cols = 3 )
    float_range  = Range( 0.0, 10.0, 10.0 )
    int_range    = Range( 1, 5 )
    boolean      = Bool( True )

    view         = View( 'integer_text', 'enumeration', 'float_range',
                         'int_range', 'boolean' )

#-------------------------------------------------------------------------------
#  'TraitsTestHandler' class:
#-------------------------------------------------------------------------------

class TraitsTestHandler ( Handler ):

    def object_enabled_changed ( self, info ):
        enabled = info.object.enabled
        for i in range( 1, 63 ):
            getattr( info, 'f%d' % i ).enabled = enabled

#-------------------------------------------------------------------------------
#  'TraitsTest' class
#-------------------------------------------------------------------------------

class TraitsTest ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    enabled      = Bool( True )
    integer_text = Int( 1 )
    enumeration  = Trait( 'one', 'two', 'three', 'four', 'five', 'six',
                          cols = 3 )
    float_range  = Range( 0.0, 10.0, 10.0 )
    int_range    = Range( 1, 6 )
    int_range2   = Range( 1, 50 )
    compound     = Trait( 1, Range( 1, 6 ),
                          'one', 'two', 'three', 'four', 'five', 'six' )
    boolean      = Bool( True )
    instance     = Trait( Instance() )
    color        = Color( 'cyan' )
    font         = Font()
    check_list   = List( editor = CheckListEditor(
                                   values = [ 'one', 'two', 'three', 'four' ],
                                   cols   = 4 ) )
    list         = List( Str, [ 'East of Eden', 'The Grapes of Wrath',
                                'Of Mice and Men' ] )
    button       = Event( 0, editor = ButtonEditor( label = 'Click' ) )
    file         = File()
    directory    = Directory()
    image_enum   = Trait( editor = ImageEnumEditor( values = origin_values,
                                                   suffix = '_origin',
                                                   cols   = 4,
                                                   klass  = Instance ),
                         *origin_values )

    #---------------------------------------------------------------------------
    #  View definitions:
    #---------------------------------------------------------------------------

    view = View(
                 ( '|{Enum}',
                   ( 'enabled', ),
                   ( '|<[Enumeration]',  'f1:enumeration[Simple]',  '_',
                                         'f2:enumeration[Custom]@', '_',
                                         'f3:enumeration[Text]*',   '_',
                                         'f4:enumeration[Readonly]~' ),
                   ( '|<[Check List]',   'f5:check_list[Simple]',  '_',
                                         'f6:check_list[Custom]@', '_',
                                         'f7:check_list[Text]*',   '_',
                                         'f8:check_list[Readonly]~' )
                 ),
                 ( '|{Range}',
                   ( '|<[Float Range]',  'f9:float_range[Simple]',  '_',
                                         'f10:float_range[Custom]@', '_',
                                         'f11:float_range[Text]*',   '_',
                                         'f12:float_range[Readonly]~' ),
                   ( '|<[Int Range]',    'f13:int_range[Simple]',  '_',
                                         'f14:int_range[Custom]@', '_',
                                         'f15:int_range[Text]*',   '_',
                                         'f16:int_range[Readonly]~' ),
                   ( '|<[Int Range 2]',  'f17:int_range2[Simple]',  '_',
                                         'f18:int_range2[Custom]@', '_',
                                         'f19:int_range2[Text]*',   '_',
                                         'f20:int_range2[Readonly]~' )
                 ),
                 ( '|{Misc}',
                   ( '|<[Integer Text]', 'f21:integer_text[Simple]',  '_',
                                         'f22:integer_text[Custom]@', '_',
                                         'f23:integer_text[Text]*',   '_',
                                         'f24:integer_text[Readonly]~' ),
                   ( '|<[Compound]',     'f25:compound[Simple]',  '_',
                                         'f26:compound[Custom]@', '_',
                                         'f27:compound[Text]*',   '_',
                                         'f28:compound[Readonly]~' ),
                   ( '|<[Boolean]',      'f29:boolean[Simple]',  '_',
                                         'f30:boolean[Custom]@', '_',
                                         'f31:boolean[Text]*',   '_',
                                         'f32:boolean[Readonly]~' )
                 ),
                 ( '|{Color/Font}',
                   ( '|<[Color]',        'f33:color[Simple]',  '_',
                                         'f34:color[Custom]@', '_',
                                         'f35:color[Text]*',   '_',
                                         'f36:color[Readonly]~' ),
                   ( '|<[Font]',         'f37:font[Simple]', '_',
                                         'f38:font[Custom]@', '_',
                                         'f39:font[Text]*',   '_',
                                         'f40:font[Readonly]~' )
                 ),
                 ( '|{List}',
                   ( '|<[List]',         'f41:list[Simple]',  '_',
                                         'f42:list[Custom]@', '_',
                                         'f43:list[Text]*',   '_',
                                         'f44:list[Readonly]~' )
                 ),
                 ( '|{Button}',
                   ( '|<[Button]',       'f45:button[Simple]',  '_',
                                         'f46:button[Custom]@' ),
#                                        'button[Text]*',
#                                        'button[Readonly]~' ),
                   ( '|<[Image Enum]',   'f47:image_enum[Simple]',  '_',
                                         'f48:image_enum[Custom]@', '_',
                                         'f49:image_enum[Text]*',   '_',
                                         'f50:image_enum[Readonly]~' ),
                   ( '|<[Instance]',     'f51:instance[Simple]',  '_',
                                         'f52:instance[Custom]@', '_',
                                         'f53:instance[Text]*',   '_',
                                         'f54:instance[Readonly]~' ),
                 ),
                 ( '|{File}',

                   ( '|<[File]',         'f55:file[Simple]',  '_',
                                         'f56:file[Custom]@', '_',
                                         'f57:file[Text]*',   '_',
                                         'f58:file[Readonly]~', ),
                   ( '|<[Directory]',    'f59:directory[Simple]',  '_',
                                         'f60:directory[Custom]@', '_',
                                         'f61:directory[Text]*',   '_',
                                         'f62:directory[Readonly]~' )
                 ),
                 buttons = [ 'Apply', 'Revert', 'Undo', 'OK' ],
                 handler = TraitsTestHandler()
               )

#-------------------------------------------------------------------------------
#  'TraitSheetApp' class:
#-------------------------------------------------------------------------------

class TraitSheetApp ( wx.App ):

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, object ):
        self.object = object
        wx.InitAllImageHandlers()
        wx.App.__init__( self, 1, 'debug.log' )
        self.MainLoop()

    #---------------------------------------------------------------------------
    #  Handle application initialization:
    #---------------------------------------------------------------------------

    def OnInit ( self ):
        ui = self.object.edit_traits( kind = 'live' )
        ui = self.object.edit_traits( kind = 'modal' )
        ui = self.object.edit_traits( kind = 'nonmodal' )
        ui = self.object.edit_traits( kind = 'wizard' )
        self.SetTopWindow( ui.control )
        return True

#-------------------------------------------------------------------------------
#  Main program:
#-------------------------------------------------------------------------------

TraitSheetApp( TraitsTest() )


########NEW FILE########
__FILENAME__ = text_editor_invalid
# Test for TextEditor 'invalid' trait.
#
# Look for:
#
#   background color should be correctly to the error indicating color
#     whenever the name is invalid (all whitespace).  In particular:
#
#   background color should be set at initialization.

from traits.api import Bool, HasTraits, Property, Str
from traitsui.api import Item, View
from traitsui.api import TextEditor


class Person(HasTraits):
    name = Str

    invalid = Property(Bool, depends_on='name')

    def _get_invalid(self):
        # Name is valid iff it doesn't consist entirely of whitespace.
        stripped_name = self.name.strip()
        return stripped_name == ''

    traits_view = View(
        Item('name', editor=TextEditor(invalid='invalid')),
    )


if __name__ == '__main__':
    Person().configure_traits()

########NEW FILE########
__FILENAME__ = tree_editor_test
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in /LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: David C. Morrill
# Date: 12/04/2004
# Description: Test case for the traits tree editor.
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api         import HasTraits, Str, Regex, List, Instance
from traitsui.api      import TreeEditor, TreeNode, View, Item, VSplit, \
                                     HGroup, Handler
from traitsui.menu import Menu, Action, Separator
from traitsui.wx.tree_editor import NewAction, CopyAction, \
                              CutAction, PasteAction, DeleteAction, RenameAction

#-------------------------------------------------------------------------------
#  'Employee' class:
#-------------------------------------------------------------------------------

class Employee ( HasTraits ):
    name  = Str( '<unknown>' )
    title = Str
    phone = Regex( regex = r'\d\d\d-\d\d\d\d' )

    def default_title ( self ):
        self.title = 'Senior Engineer'

#-------------------------------------------------------------------------------
#  'Department' class:
#-------------------------------------------------------------------------------

class Department ( HasTraits ):
    name      = Str( '<unknown>' )
    employees = List( Employee )

#-------------------------------------------------------------------------------
#  'Company' class:
#-------------------------------------------------------------------------------

class Company ( HasTraits ):
    name        = Str( '<unknown>' )
    departments = List( Department )
    employees   = List( Employee )

#-------------------------------------------------------------------------------
#  'Partner' class:
#-------------------------------------------------------------------------------

class Partner ( HasTraits ):
    name    = Str( '<unknown>' )
    company = Instance( Company )

#-------------------------------------------------------------------------------
#  Create a hierarchy:
#-------------------------------------------------------------------------------

jason = Employee(
     name  = 'Jason',
     title = 'Sr. Engineer',
     phone = '536-1057' )

mike = Employee(
     name  = 'Mike',
     title = 'Sr. Engineer',
     phone = '536-1057' )

dave = Employee(
     name  = 'Dave',
     title = 'Sr. Engineer',
     phone = '536-1057' )

martin = Employee(
     name  = 'Martin',
     title = 'Sr. Engineer',
     phone = '536-1057' )

duncan = Employee(
     name  = 'Duncan',
     title = 'Sr. Engineer' )

partner = Partner(
    name    = 'eric',
    company = Company(
        name        = 'Enthought, Inc.',
        departments = [
            Department(
                name      = 'Business',
                employees = [ jason, mike ]
            ),
            Department(
                name      = 'Scientific',
                employees = [ dave, martin, duncan ]
            )
        ],
        employees = [ dave, martin, mike, duncan, jason ]
    )
)

#-------------------------------------------------------------------------------
#  Define the tree trait editor:
#-------------------------------------------------------------------------------

no_view = View()

tree_editor = TreeEditor(
    nodes = [
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = '',
                  label     = 'name',
                  view      = View( [ 'name', '|<' ] ) ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'departments',
                  label     = '=Departments',
                  view      = no_view,
                  add       = [ Department ] ),
        TreeNode( node_for  = [ Company ],
                  auto_open = True,
                  children  = 'employees',
                  label     = '=Employees',
                  view      = no_view,
                  add       = [ Employee ] ),
        TreeNode( node_for  = [ Department ],
                  auto_open = True,
                  children  = 'employees',
                  label     = 'name',
                  menu      = Menu( NewAction,
                                    Separator(),
                                    DeleteAction,
                                    Separator(),
                                    RenameAction,
                                    Separator(),
                                    CopyAction,
                                    CutAction,
                                    PasteAction ),
                  view      = View( [ 'name', '|<' ] ),
                  add       = [ Employee ] ),
        TreeNode( node_for  = [ Employee ],
                  auto_open = True,
                  label     = 'name',
                  menu      = Menu( NewAction,
                                    Separator(),
                                    Action( name   = 'Default title',
                                            action = 'object.default_title' ),
                                    Action( name   = 'Department',
                                            action = 'handler.employee_department(editor,object)' ),
                                    Separator(),
                                    CopyAction,
                                    CutAction,
                                    PasteAction,
                                    Separator(),
                                    DeleteAction,
                                    Separator(),
                                    RenameAction ),
                  view      = View( VSplit( HGroup( '3', 'name' ),
                                            HGroup( '9', 'title' ),
                                            HGroup( 'phone' ),
                                            id = 'vsplit' ),
                                    id   = 'traitsui.test.tree_editor_test.employee',
                                    dock = 'vertical' ) )
    ]
)

#-------------------------------------------------------------------------------
#  'TreeHandler' class:
#-------------------------------------------------------------------------------

class TreeHandler ( Handler ):

    def employee_department ( self, editor, object ):
        dept = editor.get_parent( object )
        print '%s works in the %s department.' % ( object.name, dept.name )

#-------------------------------------------------------------------------------
#  Define the View to use:
#-------------------------------------------------------------------------------

view = View( [ Item( name      = 'company',
                     id        = 'company',
                     editor    = tree_editor,
                     resizable = True ), '|<>' ],
             title      = 'Company Structure',
             id         = 'traitsui.tests.tree_editor_test',
             dock       = 'horizontal',
             drop_class = HasTraits,
             handler    = TreeHandler(),
             buttons    = [ 'Undo', 'OK', 'Cancel' ],
             resizable  = True,
             width      = .3,
             height     = .3 )

#-------------------------------------------------------------------------------
#  Edit it:
#-------------------------------------------------------------------------------

if __name__ == '__main__':
    partner.configure_traits( view = view )


########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Exports the symbols defined by the traits.ui package.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .basic_editor_factory import BasicEditorFactory

from .context_value import CV, CVFloat, CVInt, CVStr, CVType, ContextValue

from .editor import Editor

from .editor_factory import EditorFactory

from .editors.api import (ArrayEditor, BooleanEditor, ButtonEditor,
    CheckListEditor, CodeEditor, ColorEditor, CompoundEditor, CustomEditor,
    CSVListEditor,
    DNDEditor, StyledDateEditor, DateEditor, DefaultOverride, DirectoryEditor, DropEditor,
    EnumEditor, FileEditor, FontEditor, HTMLEditor, HistoryEditor, ImageEditor,
    ImageEnumEditor, InstanceEditor, KeyBindingEditor, ListEditor,
    ListStrEditor, NullEditor, PopupEditor, ProgressEditor, RGBColorEditor,
    RangeEditor, ScrubberEditor, SearchEditor, SetEditor, ShellEditor,
    TableEditor, TabularEditor, TextEditor, TimeEditor, TitleEditor, TreeEditor,
    TupleEditor, ValueEditor)

from .group import (Group, HFlow, HGroup, HSplit, Tabbed, VFlow, VFold, VGrid,
    VGroup, VSplit)

from .handler import Controller, Handler, ModelView, ViewHandler, default_handler

from .help import on_help_call

from .help_template import help_template

from .include import Include

from .item import (Custom, Heading, Item, Label, Readonly, Spring, UCustom,
    UItem, UReadonly, spring)

from .menu import (Action, ActionGroup, ApplyButton, CancelButton, CloseAction,
    HelpAction, HelpButton, LiveButtons, Menu, MenuBar, ModalButtons, NoButton,
    NoButtons, OKButton, OKCancelButtons, PyFaceAction, RedoAction,
    RevertAction, RevertButton, Separator, StandardMenuBar, ToolBar, UndoAction,
    UndoButton)

from .message import auto_close_message, error, message

from .table_column import (ExpressionColumn, ListColumn, NumericColumn,
    ObjectColumn, TableColumn)

from .table_filter import (EvalTableFilter, MenuTableFilter, RuleTableFilter,
    TableFilter)

from .theme import Theme, default_theme

from .toolkit import toolkit

from .toolkit_traits import ColorTrait, FontTrait, RGBColorTrait

from .tree_node import (ITreeNode, ITreeNodeAdapter, MultiTreeNode,
    ObjectTreeNode, TreeNode, TreeNodeObject)

from .ui import UI

from .ui_info import UIInfo

from .ui_traits import (ATheme, Border, HasBorder, HasMargin, Image, Margin,
    StatusItem)

from .undo import (AbstractUndoItem, ListUndoItem, UndoHistory,
    UndoHistoryUndoItem, UndoItem)

from .view import View

from .view_element import ViewElement, ViewSubElement

from . import view_elements

_constants  = toolkit().constants()
WindowColor = _constants.get( 'WindowColor', 0xFFFFFF )


def raise_to_debug() :
    """ When we would otherwise silently swallow an exception, call this instead
    to allow people to set the TRAITS_DEBUG environment variable and get the
    exception.
    """
    import os
    if os.getenv('TRAITS_DEBUG') is not None : raise

########NEW FILE########
__FILENAME__ = basic_editor_factory
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the BasicEditorFactory class, which allows creating editor
    factories that use the same class for creating all editor styles.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Any

from .editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  'BasicEditorFactory' base class:
#-------------------------------------------------------------------------------

class BasicEditorFactory ( EditorFactory ):
    """ Base class for editor factories that use the same class for creating
        all editor styles.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Editor class to be instantiated
    klass = Any

    #---------------------------------------------------------------------------
    #  Property getters.
    #---------------------------------------------------------------------------

    def _get_simple_editor_class ( self ):
        """ Returns the editor class to use for "simple" style views.
        Overridden to return the value of the 'klass' trait.

        """
        return self.klass

    def _get_custom_editor_class ( self ):
        """ Returns the editor class to use for "custom" style views.
        Overridden to return the value of the 'klass' trait.

        """
        return self.klass

    def _get_text_editor_class ( self ):
        """ Returns the editor class to use for "text" style views.
        Overridden to return the value of the 'klass' trait.

        """
        return self.klass

    def _get_readonly_editor_class ( self ):
        """ Returns the editor class to use for "readonly" style views.
        Overridden to return the value of the 'klass' trait.

        """
        return self.klass

    #---------------------------------------------------------------------------
    #  Allow an instance to be called:
    #---------------------------------------------------------------------------

    def __call__ ( self, *args, **traits ):
        return self.set( **traits )

## EOF ########################################################################


########NEW FILE########
__FILENAME__ = color_column
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------

""" Table column object for Color traits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traitsui.table_column \
    import ObjectColumn

#-------------------------------------------------------------------------------
#  'ColorColumn' class:
#-------------------------------------------------------------------------------

class ColorColumn ( ObjectColumn ):
    """ Table column object for Color traits. """

#-- ObjectColumn Overrides -----------------------------------------------------

    def get_cell_color ( self, object ):
        """ Returns the cell background color for the column for a specified
            object.
        """
        color_values = getattr( object, self.name + '_' )
        if type( color_values ) is tuple:
            tk_color = self._as_int_rgb_tuple( color_values )
        else:
            tk_color = super( ColorColumn, self ).get_cell_color( object )
        return tk_color

    def get_value ( self, object ):
        """ Gets the value of the column for a specified object.
        """
        value = getattr( self.get_object( object ), self.name )
        if type( value ) is tuple:
            value = "(%3d, %3d, %3d)" % self._as_int_rgb_tuple( value[:-1] )
        elif type( value ) is not str:
            value = str( value )

        return value

#-- Private Methods ------------------------------------------------------------

    def _as_int_rgb_tuple ( self, color_values ):
        """ Returns object color as RGB integers. """
        return ( int( 255 * color_values[0] ),
                 int( 255 * color_values[1] ),
                 int( 255 * color_values[2] ) )


########NEW FILE########
__FILENAME__ = context_value
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/18/2008
#
#------------------------------------------------------------------------------

""" Defines some helper classes and traits used to define 'bindable' editor
    values.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, Instance, Str, Int, Float, Either

#-------------------------------------------------------------------------------
#  'ContextValue' class:
#-------------------------------------------------------------------------------

class ContextValue ( HasPrivateTraits ):
    """ Defines the name of a context value that can be bound to some editor
        value.
    """

    # The extended trait name of the value that can be bound to the editor
    # (e.g. 'selection' or 'handler.selection'):
    name = Str

    #-- object Interface -------------------------------------------------------

    def __init__ ( self, name ):
        """ Initializes the object.
        """
        self.name = name

# Define a shorthand name for a ContextValue:
CV = ContextValue

#-------------------------------------------------------------------------------
#  Trait definitions useful in defining bindable editor traits:
#-------------------------------------------------------------------------------

InstanceOfContextValue = Instance( ContextValue, allow_none = False )

def CVType( type ):
    return Either( type, InstanceOfContextValue, sync_value = 'to' )

CVInt   = CVType( Int )
CVFloat = CVType( Float )
CVStr   = CVType( Str )


########NEW FILE########
__FILENAME__ = default_dock_window_theme
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/14/2007
#
#-------------------------------------------------------------------------------

""" Defines the default DockWindow theme.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .dock_window_theme import DockWindowTheme

from .theme import Theme

#-------------------------------------------------------------------------------
#  Define the default theme:
#-------------------------------------------------------------------------------

# The original DockWindows UI redone as a theme:
default_dock_window_theme = DockWindowTheme(
    use_theme_color     = False,
    tab_active          = Theme( '@std:tab_active',
                                 label = ( 0, -3 ), content = ( 7, 6, 0, 0 ) ),
    tab_inactive        = Theme( '@std:tab_inactive',
                                 label = ( 0, -1 ), content = ( 5, 0 ) ),
    tab_hover           = Theme( '@std:tab_hover',
                                 label = ( 0, -2 ), content = ( 5, 0 ) ),
    tab_background      = Theme( '@std:tab_background' ),
    tab                 = Theme( '@std:tab',
                                 content = 0, label = ( -7, 0 ) ),
    vertical_splitter   = Theme( '@std:vertical_splitter',
                                 content = 0, label  = ( 0, -25 ) ),
    horizontal_splitter = Theme( '@std:horizontal_splitter',
                                 content = 0, label = ( -24, 0 ) ),
    vertical_drag       = Theme( '@std:vertical_drag',
                                 content = ( 0, 10 ) ),
    horizontal_drag     = Theme( '@std:horizontal_drag',
                                 content = ( 10, 0 ) )
)


########NEW FILE########
__FILENAME__ = delegating_handler
#-----------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Dave Peterson <dpeterson@enthought.com>
#
#-----------------------------------------------------------------------------

"""
A handler that delegates the handling of events to a set of sub-handlers.

This is typically used as the handler for dynamic views.  See the
**traits.has_dynamic_view** module.
"""

# Enthought library imports
from traits.api import HasTraits, List
from .ui import Dispatcher

# Local imports.
from .handler import Handler

# Set up a logger:
import logging
logger = logging.getLogger( __name__ )

class DelegatingHandler ( Handler ):
    """ A handler that delegates the handling of events to a set of
        sub-handlers.
    """

    #-- Public 'DelegatingHandler' Interface -----------------------------------

    # The list of sub-handlers this object delegates to:
    sub_handlers = List( HasTraits )

    #-- Protected 'DelegatingHandler' Interface --------------------------------

    # A list of dispatchable handler methods:
    _dispatchers = List

    #---------------------------------------------------------------------------
    #  'Handler' interface:
    #---------------------------------------------------------------------------

    #-- Public Methods ---------------------------------------------------------

    def closed ( self, info, is_ok ):
        """ Handles the user interface being closed by the user.

            This method is overridden here to unregister any dispatchers that
            were set up in the *init()* method.
        """
        for d in self._dispatchers:
            d.remove()


    def init ( self, info ):
        """ Initializes the controls of a user interface.

        Parameters
        ----------
        info : *UIInfo* object
            The UIInfo object associated with the view

        Returns
        -------
        A boolean, indicating whether the user interface was successfully
        initialized. A True value indicates that the UI can be displayed;
        a False value indicates that the display operation should be
        cancelled.

        Description
        -----------
        This method is called after all user interface elements have been
        created, but before the user interface is displayed. Use this method to
        further customize the user interface before it is displayed.

        This method is overridden here to delegate to sub-handlers.
        """

        # Iterate through our sub-handlers, and for each method whose name is
        # of the form 'object_name_changed', where 'object' is the name of an
        # object in the UI's context, create a trait notification handler that
        # will call the method whenever object's 'name' trait changes.
        logger.debug( 'Initializing delegation in DelegatingHandler [%s]',
                      self )
        context = info.ui.context
        for h in self.sub_handlers:
            # fixme: I don't know why this wasn't here before... I'm not
            # sure this is right!
            h.init( info )

            for name in self._each_trait_method( h ):
                if name[-8:] == '_changed':
                    prefix = name[:-8]
                    col = prefix.find( '_', 1 )
                    if col >= 0:
                        object = context.get( prefix[ :col ] )
                        if object is not None:
                            logger.debug( '\tto method [%s] on handler[%s]',
                                          name, h )
                            method = getattr( h, name )
                            trait_name = prefix[col + 1:]
                            self._dispatchers.append(
                                Dispatcher( method, info, object, trait_name )
                            )

                            # Also invoke the method immediately so initial
                            # user interface state can be correctly set.
                            if object.base_trait( trait_name ).type != 'event':
                                method( info )

                # fixme: These are explicit workarounds for problems with:-
                #
                # 'GeometryHierarchyViewHandler'
                #
                # which is used in the :-
                #
                # 'GeometryHierarchyTreeEditor'
                #
                # which are in the 'encode.cad.ui.geometry' package.
                #
                # The tree editor has dynamic views, and hence the handler gets
                # wrapped by a 'DelegatingHandler'. Unfortunately the handler
                # has a couple of methods that aren't picked up by the usual
                # wrapping strategy:-
                #
                # 1) 'tree_item_selected'
                #
                # - which is obviously called when a tree item is selected.
                #
                # 2) 'inspect_object'
                #
                # - which is called directly as as action from the context menu
                #   defined in the tree editor.
                #
                elif name in [ 'tree_item_selected', 'inspect_object' ]:
                    self.__dict__[ name ] = self._create_delegate( h, name )

        return True

    def _create_delegate ( self, h, name ):
        """ Quick fix for handler methods that are currently left out!
        """

        def delegate ( *args, **kw ):
            method = getattr( h, name )
            return method( *args, **kw )

        return delegate


########NEW FILE########
__FILENAME__ = dockable_view_element
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/14/2005
#
#-------------------------------------------------------------------------------

""" Defines the DockableViewElement class, which allows Traits UIs and
    Traits UI elements to be docked in external PyFace DockWindow windows.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, Instance, Bool

from .ui import UI

from .group import Group

from .view import View

from .view_element import ViewSubElement

from pyface.dock.idockable import IDockable

#-------------------------------------------------------------------------------
#  'DockableViewElement' class:
#-------------------------------------------------------------------------------

class DockableViewElement ( HasPrivateTraits, IDockable ):
    """ Allows Traits UIs and Traits UI elements to be docked in external
        PyFace DockWindow windows.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The Traits UI that can be docked with an external DockWindow
    ui = Instance( UI )

    # The (optional) element of the Traits UI that can be docked
    element = Instance( ViewSubElement )

    # Should the DockControl be closed on redocking?
    should_close = Bool( False )

#-- IDockable interface --------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Should the current DockControl be closed before creating the new one:
    #---------------------------------------------------------------------------

    def dockable_should_close ( self ):
        """ Should the current DockControl be closed before creating the new
            one?
        """
        element = self.element
        if element is None:
            element = self.ui.view.content

        if not isinstance( element, Group ):
            element = Group().set( content = [ element ] )

        group      = Group().set( content = [ element ] )
        self._view = View().set( **self.ui.view.get() ).set( content = group,
                                                             title   = '' )

        # FIXME: The following private traits are being set here to facilitate
        # rebuilding the ui (which will require the context and the handler).
        # When a current dock control is closed (close_dock_control method), the
        # contents of self.ui have been disposed of and self.ui is now None.
        # Now if a new UI needs to be created by calling dockable_get_control
        # (e.g., when doing an 'undock' action on a dock window), we need to
        # pass on the context and handler to the UI. Therefore, we are setting
        # these private traits here so dockable_get_control can access them.
        # In future, we need to investigate if there is a better way to do this.

        self._context = self.ui.context.copy()
        # Make copy since context will be emptied when calling self.ui.dispose()
        self._handler = self.ui.handler

        return (self.should_close or (self.element is None))

    #---------------------------------------------------------------------------
    #  Gets a control that can be docked into a DockWindow:
    #---------------------------------------------------------------------------

    def dockable_get_control ( self, parent ):
        """ Gets a control that can be docked into a DockWindow.
        """
        # Create the new UI:
        ui = self._view.ui( self._context, parent  = parent,
                                           kind    = 'subpanel',
                                           handler = self._handler )

        # Discard the reference to the view created previously:
        self._view = None

        # If the old UI was closed, then switch to using the new one:
        if self.element is None:
            self.ui = ui
        else:
            self._ui = ui

        return ui.control

    #---------------------------------------------------------------------------
    #  Allows the object to override the default DockControl settings:
    #---------------------------------------------------------------------------

    def dockable_init_dockcontrol ( self, dock_control ):
        """ Allows the object to override the default DockControl settings.
        """
        dockable = self
        if self.element is not None:
            dockable = DockableViewElement( ui           = self._ui,
                                            element      = self.element,
                                            should_close = True )
            self._ui = None

        dock_control.set( dockable = dockable,
                          on_close = dockable.close_dock_control )

    #---------------------------------------------------------------------------
    #  Handles the closing of a DockControl containing a Traits UI:
    #---------------------------------------------------------------------------

    def close_dock_control ( self, dock_control, abort ):
        """ Handles the closing of a DockControl containing a Traits UI.
        """
        ui = self.ui

        # Ask the traits UI handler if it is OK to close the window:
        if (not abort) and (not ui.handler.close( ui.info, True )):
            # If not, tell the DockWindow not to close it:
            return False

        # Otherwise, clean up and close the traits UI:
        ui.dispose( abort = abort )

        # Break our linkage to the UI and ViewElement object:
        self.ui = self.element = None

        # And tell the DockWindow to remove the DockControl:
        return True


########NEW FILE########
__FILENAME__ = dock_window_theme
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/14/2007
#
#-------------------------------------------------------------------------------

""" Defines the theme style information for a DockWindow and its components.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, Bool

from .ui_traits import Image, ATheme

#-------------------------------------------------------------------------------
#  'DockWindowTheme' class:
#-------------------------------------------------------------------------------

class DockWindowTheme ( HasPrivateTraits ):
    """ Defines the theme style information for a DockWindow and its components.
    """

    #-- Public Trait Definitions -----------------------------------------------

    # Use the theme background color as the DockWindow background color?
    use_theme_color = Bool( True )

    # Draw notebook tabs at the top (True) or the bottom (False)?
    tabs_at_top = Bool( True )

    # Active tab theme:
    tab_active = ATheme

    # Inactive tab theme:
    tab_inactive = ATheme

    # Optional image to use for right edge of rightmost inactive tab:
    tab_inactive_edge = Image

    # Tab hover theme (used for inactive tabs):
    tab_hover = ATheme

    # Optional image to use for right edge of rightmost hover tab:
    tab_hover_edge = Image

    # Tab background theme:
    tab_background = ATheme

    # Tab theme:
    tab = ATheme

    # Vertical splitter bar theme:
    vertical_splitter = ATheme

    # Horizontal splitter bar theme:
    horizontal_splitter = ATheme

    # Vertical drag bar theme:
    vertical_drag = ATheme

    # Horizontal drag bar theme:
    horizontal_drag = ATheme

#-------------------------------------------------------------------------------
#  Define the default theme:
#-------------------------------------------------------------------------------

# The current default DockWindow theme:
_dock_window_theme = None

# Gets/Sets the default DockWindow theme:
def dock_window_theme ( theme = None ):
    global _dock_window_theme

    if _dock_window_theme is None:
        from .default_dock_window_theme import default_dock_window_theme

        _dock_window_theme = default_dock_window_theme

    old_theme = _dock_window_theme
    if theme is not None:
        _dock_window_theme = theme

    return old_theme


########NEW FILE########
__FILENAME__ = editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the abstract Editor class, which represents an editing control for
    an object trait in a Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Bool, HasPrivateTraits, HasTraits, Instance, Property,
    ReadOnly, Str, Trait, TraitError, TraitListEvent, Undefined,
    cached_property)

from traits.trait_base import not_none

from .editor_factory import EditorFactory

from .context_value import ContextValue

from .undo import UndoItem

from .item import Item

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Reference to an EditorFactory object
factory_trait = Trait( EditorFactory )

#-------------------------------------------------------------------------------
#  'Editor' abstract base class:
#-------------------------------------------------------------------------------

class Editor ( HasPrivateTraits ):
    """ Represents an editing control for an object trait in a Traits-based
        user interface.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The UI (user interface) this editor is part of:
    ui = Instance( 'traitsui.ui.UI' )

    # Full name of the object the editor is editing (e.g. 'object.link1.link2'):
    object_name = Str( 'object' )

    # The object this editor is editing (e.g. object.link1.link2):
    object = Instance( HasTraits )

    # The name of the trait this editor is editing (e.g. 'value'):
    name = ReadOnly

    # The context object the editor is editing (e.g. object):
    context_object = Property

    # The extended name of the object trait being edited. That is,
    # 'object_name.name' minus the context object name at the beginning. For
    # example: 'link1.link2.value':
    extended_name = Property

    # Original value of object.name (e.g. object.link1.link2.value):
    old_value = Any

    # Text description of the object trait being edited:
    description = ReadOnly

    # The Item object used to create this editor:
    item = Instance( Item, () )

    # The GUI widget defined by this editor:
    control = Any

    # The GUI label (if any) defined by this editor:
    label_control = Any

    # Is the underlying GUI widget enabled?
    enabled = Bool( True )

    # Is the underlying GUI widget visible?
    visible = Bool( True )

    # Is the underlying GUI widget scrollable?
    scrollable = Bool( False )

    # The EditorFactory used to create this editor:
    factory = factory_trait

    # Is the editor updating the object.name value?
    updating = Bool( False )

    # Current value for object.name:
    value = Property

    # Current value of object trait as a string:
    str_value = Property

    # The trait the editor is editing (not its value, but the trait itself):
    value_trait = Property

    # The current editor invalid state status:
    invalid = Bool( False )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, parent, **traits ):
        """ Initializes the editor object.
        """
        HasPrivateTraits.__init__( self, **traits )
        try:
            self.old_value = getattr( self.object, self.name )
        except AttributeError:
            ctrait = self.object.base_trait(self.name)
            if ctrait.type == 'event' or self.name == 'spring':
                # Getting the attribute will fail for 'Event' traits:
                self.old_value = Undefined
            else :
                raise

        # Synchronize the application invalid state status with the editor's:
        self.sync_value( self.factory.invalid, 'invalid', 'from' )

    #---------------------------------------------------------------------------
    #  Finishes editor set-up:
    #---------------------------------------------------------------------------

    def prepare ( self, parent ):
        """ Finishes setting up the editor.
        """
        name = self.extended_name
        if name != 'None':
            self.context_object.on_trait_change( self._update_editor, name,
                                                 dispatch = 'ui' )
        self.init( parent )
        self._sync_values()
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Assigns focus to the editor's underlying toolkit widget:
    #---------------------------------------------------------------------------

    def set_focus ( self ):
        """ Assigns focus to the editor's underlying toolkit widget.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self.ui is None:
            return

        name = self.extended_name
        if name != 'None':
            self.context_object.on_trait_change( self._update_editor, name,
                                                 remove = True )

        if self._user_from is not None:
            for name, handler in self._user_from:
                self.on_trait_change( handler, name, remove = True )

        if self._user_to is not None:
            for object, name, handler in self._user_to:
                object.on_trait_change( handler, name, remove = True )

        # Break linkages to references we no longer need:
        self.object = self.ui = self.item = self.factory = self.control = \
        self.label_control = self.old_value = self._context_object = None

    #---------------------------------------------------------------------------
    #  Returns the context object the editor is using (Property implementation):
    #---------------------------------------------------------------------------

    @cached_property
    def _get_context_object ( self ):
        """ Returns the context object the editor is using (Property
            implementation).
        """
        object_name = self.object_name
        context_key = object_name.split( '.', 1 )[0]
        if (object_name != '') and (context_key in self.ui.context):
            return self.ui.context[ context_key ]

        # This handles the case of a 'ListItemProxy', which is not in the
        # ui.context, but is the editor 'object':
        return self.object

    #---------------------------------------------------------------------------
    #  Returns the extended trait name being edited (Property implementation):
    #---------------------------------------------------------------------------

    @cached_property
    def _get_extended_name ( self ):
        """ Returns the extended trait name being edited (Property
            implementation).
        """
        return ('%s.%s' % ( self.object_name, self.name )).split( '.', 1 )[1]

    #---------------------------------------------------------------------------
    #  Returns the trait the editor is editing (Property implementation):
    #---------------------------------------------------------------------------

    def _get_value_trait ( self ):
        """ Returns the trait the editor is editing (Property implementation).
        """
        return self.object.trait( self.name )

    #---------------------------------------------------------------------------
    #  Gets/Sets the associated object trait's value:
    #---------------------------------------------------------------------------

    def _get_value ( self ):
        return getattr( self.object, self.name, Undefined )

    def _set_value ( self, value ):
        if self.ui and self.name != 'None':
            self.ui.do_undoable( self.__set_value, value )

    def __set_value ( self, value ):
        self._no_update = True
        try:
            try:
                handler  = self.ui.handler
                obj_name = self.object_name
                name     = self.name
                method   = (getattr( handler, '%s_%s_setattr' % ( obj_name,
                                              name ), None ) or
                            getattr( handler, '%s_setattr' % name, None ) or
                            getattr( handler, 'setattr' ))
                method( self.ui.info, self.object, name, value )
            except TraitError, excp:
                self.error( excp )
                raise
        finally:
            self._no_update = False

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified object trait value:
    #---------------------------------------------------------------------------

    def string_value ( self, value, format_func = None ):
        """ Returns the text representation of a specified object trait value.

            If the **format_func** attribute is set on the editor factory, then
            this method calls that function to do the formatting.  If the
            **format_str** attribute is set on the editor factory, then this
            method uses that string for formatting. If neither attribute is
            set, then this method just calls the built-in unicode() function.
        """
        factory = self.factory
        if factory.format_func is not None:
            return factory.format_func( value )

        if factory.format_str != '':
            return factory.format_str % value

        if format_func is not None:
            return format_func( value )

        return unicode( value )

    #---------------------------------------------------------------------------
    #  Returns the text representation of the object trait:
    #---------------------------------------------------------------------------

    def _get_str_value ( self ):
        """ Returns the text representation of the object trait.
        """
        return self.string_value( getattr( self.object, self.name, Undefined ) )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified value:
    #---------------------------------------------------------------------------

    def _str ( self, value ):
        """ Returns the text representation of a specified value.
        """
        # In Unicode!
        return unicode( value )

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #
    #  (Should normally be overridden in a subclass)
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #---------------------------------------------------------------------------
    #  Performs updates when the object trait changes:
    #---------------------------------------------------------------------------

    def _update_editor ( self, object, name, old_value, new_value ):
        """ Performs updates when the object trait changes.
        """
        # If background threads have modified the trait the editor is bound to,
        # their trait notifications are queued to the UI thread. It is possible
        # that by the time the UI thread dispatches these events, the UI the
        # editor is part of has already been closed. So we need to check if we
        # are still bound to a live UI, and if not, exit immediately:
        if self.ui is None:
            return

        # If the notification is for an object different than the one actually
        # being edited, it is due to editing an item of the form:
        # object.link1.link2.name, where one of the 'link' objects may have
        # been modified. In this case, we need to rebind the current object
        # being edited:
        if object is not self.object:
            self.object = eval( self.object_name, globals(), self.ui.context )

        # If the editor has gone away for some reason, disconnect and exit:
        if self.control is None:
            self.context_object.on_trait_change( self._update_editor,
                                    self.extended_name, remove = True )
            return

        # Log the change that was made (as long as it is not for an event):
        if object.base_trait( name ).type != 'event':
            self.log_change( self.get_undo_item, object, name,
                                                 old_value, new_value )

        # If the change was not caused by the editor itself:
        if not self._no_update:
            # Update the editor control to reflect the current object state:
            self.update_editor()

    #---------------------------------------------------------------------------
    #  Logs a change made in the editor:
    #---------------------------------------------------------------------------

    def log_change ( self, undo_factory, *undo_args ):
        """ Logs a change made in the editor.
        """
        # Indicate that the contents of the user interface have been changed:
        ui          = self.ui
        ui.modified = True

        # Create an undo history entry if we are maintaining a history:
        undoable = ui._undoable
        if undoable >= 0:
            history = ui.history
            if history is not None:
                item = undo_factory( *undo_args )
                if item is not None:
                    if undoable == history.now:
                        # Create a new undo transaction:
                        history.add( item )
                    else:
                        # Extend the most recent undo transaction:
                        history.extend( item )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #
    #  (Should normally be overridden in a subclass)
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

    #---------------------------------------------------------------------------
    #  Creates an undo history entry:
    #
    #  (Can be overridden in a subclass for special value types)
    #---------------------------------------------------------------------------

    def get_undo_item ( self, object, name, old_value, new_value ):
        """ Creates an undo history entry.
        """
        return UndoItem( object    = object,
                         name      = name,
                         old_value = old_value,
                         new_value = new_value )

    #---------------------------------------------------------------------------
    #  Returns a tuple of the form ( context_object, name[.name...], callable )
    #  for a specified extended name of the form: name or
    #  context_object_name.name[.name...]:
    #---------------------------------------------------------------------------

    def parse_extended_name ( self, name ):
        """ Returns a tuple of the form ( context_object, 'name[.name...],
            callable ) for a specified extended name of the form: 'name' or
            'context_object_name.name[.name...]'.
        """
        col = name.find( '.' )
        if col < 0:
            object = self.context_object
        else:
            object, name = self.ui.context[ name[ : col ] ], name[ col + 1: ]

        return ( object, name, eval( "lambda obj=object: obj." + name ) )

    #---------------------------------------------------------------------------
    #  Initializes and synchronizes (as needed) editor traits with the value of
    #  corresponding factory traits:
    #---------------------------------------------------------------------------

    def _sync_values ( self ):
        """ Initializes and synchronizes (as needed) editor traits with the
            value of corresponding factory traits.
        """
        factory = self.factory
        for name, trait in factory.traits( sync_value = not_none ):
            value = getattr( factory, name )
            if isinstance( value, ContextValue ):
                self_trait = self.trait( name )
                self.sync_value( value.name, name,
                                 self_trait.sync_value or trait.sync_value,
                                 self_trait.is_list is True )
            elif value is not Undefined:
                setattr( self, name, value )

    #---------------------------------------------------------------------------
    #  Sets/Unsets synchronization between an editor trait and a user object
    #  trait:
    #---------------------------------------------------------------------------

    def sync_value ( self, user_name, editor_name, mode = 'both',
                           is_list = False ):
        """ Sets or unsets synchronization between an editor trait and a user
            object trait.
        """
        if user_name != '':
            key = '%s:%s' % ( user_name, editor_name )

            if self._no_trait_update is None:
                self._no_trait_update = {}

            user_ref = 'user_object'
            col      = user_name.find( '.' )
            if col < 0:
                user_object = self.context_object
                xuser_name  = user_name
            else:
                user_object = self.ui.context[ user_name[ : col ] ]
                user_name   = xuser_name = user_name[ col + 1: ]
                col         = user_name.rfind( '.' )
                if col >= 0:
                    user_ref += ('.' + user_name[ : col ])
                    user_name = user_name[ col + 1: ]

            user_value = compile( '%s.%s' % ( user_ref, user_name ),
                                  '<string>', 'eval' )
            user_ref   = compile( user_ref, '<string>', 'eval' )

            if mode in ( 'from', 'both' ):

                def user_trait_modified ( new ):
                    # Need this to include 'user_object' in closure:
                    user_object
                    if key not in self._no_trait_update:
                        self._no_trait_update[ key ] = None
                        try:
                            setattr( self, editor_name, new )
                        except:
                            from traitsui.api import raise_to_debug
                            raise_to_debug()
                        del self._no_trait_update[ key ]

                user_object.on_trait_change( user_trait_modified, xuser_name )

                if self._user_to is None:
                    self._user_to = []
                self._user_to.append( ( user_object, xuser_name,
                                        user_trait_modified ) )

                if is_list:

                    def user_list_modified ( event ):
                        if isinstance( event, TraitListEvent ):
                            if key not in self._no_trait_update:
                                self._no_trait_update[ key ] = None
                                n = event.index
                                try:
                                    getattr( self, editor_name )[
                                        n: n + len(event.removed)] = event.added
                                except:
                                    from traitsui.api import raise_to_debug
                                    raise_to_debug()
                                del self._no_trait_update[ key ]

                    user_object.on_trait_change( user_list_modified,
                                    xuser_name + '_items' )
                    self._user_to.append( ( user_object, xuser_name + '_items',
                                            user_list_modified ) )

                try:
                    setattr( self, editor_name, eval( user_value ) )
                except:
                    from traitsui.api import raise_to_debug
                    raise_to_debug()

            if mode in ( 'to', 'both' ):

                def editor_trait_modified ( new ):
                    # Need this to include 'user_object' in closure:
                    user_object
                    if key not in self._no_trait_update:
                        self._no_trait_update[ key ] = None
                        try:
                            setattr( eval( user_ref ), user_name, new )
                        except:
                            from traitsui.api import raise_to_debug
                            raise_to_debug()
                        del self._no_trait_update[ key ]

                self.on_trait_change( editor_trait_modified, editor_name )

                if self._user_from is None:
                    self._user_from = []
                self._user_from.append( ( editor_name, editor_trait_modified ) )

                if is_list:

                    def editor_list_modified ( event ):
                        # Need this to include 'user_object' in closure:
                        user_object
                        if key not in self._no_trait_update:
                            self._no_trait_update[ key ] = None
                            n = event.index
                            try:
                                eval( user_value )[ n:
                                    n + len( event.removed ) ] = event.added
                            except:
                                from traitsui.api import raise_to_debug
                                raise_to_debug()
                            del self._no_trait_update[ key ]

                    self.on_trait_change( editor_list_modified,
                             editor_name + '_items' )
                    self._user_from.append( ( editor_name + '_items',
                                              editor_list_modified ) )

                if mode == 'to':
                    try:
                        setattr( eval( user_ref ), user_name,
                                 getattr( self, editor_name ) )
                    except:
                        from traitsui.api import raise_to_debug
                        raise_to_debug()

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        pass

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        return None


########NEW FILE########
__FILENAME__ = api

from __future__ import absolute_import

from ..toolkit import toolkit

from .array_editor import ArrayEditor
from .boolean_editor import BooleanEditor
from .button_editor import ButtonEditor
from .check_list_editor import CheckListEditor
from .code_editor import CodeEditor
from .color_editor import ColorEditor
from .compound_editor import CompoundEditor
from .csv_list_editor import CSVListEditor
from .custom_editor import CustomEditor
from .date_editor import DateEditor
from .styled_date_editor import StyledDateEditor
from .default_override import DefaultOverride
from .directory_editor import DirectoryEditor
from .dnd_editor import DNDEditor
from .drop_editor import DropEditor
from .enum_editor import EnumEditor
from .file_editor import FileEditor
from .font_editor import FontEditor
from .key_binding_editor import KeyBindingEditor
from .image_editor import ImageEditor
from .image_enum_editor import ImageEnumEditor
from .instance_editor import InstanceEditor
from .list_editor import ListEditor
from .list_str_editor import ListStrEditor
from .null_editor import NullEditor
from .range_editor import RangeEditor
from .rgb_color_editor import RGBColorEditor
from .set_editor import SetEditor
from .text_editor import TextEditor
from .table_editor import TableEditor
from .time_editor import TimeEditor
from .title_editor import TitleEditor
from .tree_editor import TreeEditor
from .tuple_editor import TupleEditor
from .history_editor import HistoryEditor
from .html_editor import HTMLEditor
from .popup_editor import PopupEditor
from .value_editor import ValueEditor
from .shell_editor import ShellEditor
from .scrubber_editor import ScrubberEditor
from .tabular_editor import TabularEditor
from .progress_editor import ProgressEditor
from .search_editor import SearchEditor

########NEW FILE########
__FILENAME__ = array_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/10/2006
#
#------------------------------------------------------------------------------

""" Defines the array editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import numpy

from traits.api import Bool, HasTraits, Int, Float, Instance, false, TraitError

from ..editor import Editor

from ..editor_factory import EditorFactory

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..group import Group

from ..item import Item

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for array editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Width of the individual fields
    width = Int( -80 )

    # Is user input set on every keystroke?
    auto_set = Bool( True )

    # Is user input set when the Enter key is pressed?
    enter_set = Bool( False )

#-------------------------------------------------------------------------------
#  'ArrayStructure' class:
#-------------------------------------------------------------------------------

class ArrayStructure ( HasTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Editor that this structure is linked to
    editor = Instance( Editor )

    # The constructed View for the array
    view = Instance( View )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, editor ):
        """ Initializes the object.
        """
        # Save the reference to the editor:
        self.editor = editor

        # Set up the field width for each item:
        width = editor.factory.width

        # Set up the correct style for each filed:
        style = 'simple'
        if editor.readonly:
            style = 'readonly'

        # Get the array we are mirroring:
        object = editor.value

        # Determine the correct trait type to use for each element:
        trait = Float

        if object.dtype.type == 'i':
            trait = Int

        if len( object.shape ) == 1:
            self.view = self._one_dim_view( object, style, width, trait )
        elif len( object.shape ) == 2:
            self.view = self._two_dim_view( object, style, width, trait )
        else:
            raise TraitError( 'Only 1D or 2D arrays supported' )

    #---------------------------------------------------------------------------
    #  1D view:
    #---------------------------------------------------------------------------

    def _one_dim_view ( self, object, style, width, trait ):
        content     = []
        shape       = object.shape
        items       = []
        format_func = self.editor.factory.format_func
        format_str  = self.editor.factory.format_str
        for i in range( shape[0] ):
            name = 'f%d' % i
            self.add_trait( name,
                            trait( object[i],
                                   event = 'field',
                                   auto_set = self.editor.factory.auto_set,
                                   enter_set = self.editor.factory.enter_set )
                          )
            items.append( Item( name        = name,
                                style       = style,
                                width       = width,
                                format_func = format_func,
                                format_str  = format_str,
                                padding     = -3 ) )

        group = Group( orientation = 'horizontal',
                       show_labels = False,
                       *items )
        content.append( group )

        return View( Group( show_labels = False, *content ) )

    #---------------------------------------------------------------------------
    #  2D view:
    #---------------------------------------------------------------------------

    def _two_dim_view ( self, object, style, width, trait ):
        content     = []
        shape       = object.shape
        format_func = self.editor.factory.format_func
        format_str  = self.editor.factory.format_str
        for i in range( shape[0] ):
            items = []
            for j in range( shape[1] ):
                name = 'f%d_%d' % ( i, j )
                self.add_trait( name,
                                trait( object[i, j],
                                   event = 'field',
                                   auto_set = self.editor.factory.auto_set,
                                   enter_set = self.editor.factory.enter_set )
                               )
                items.append( Item( name        = name,
                                    style       = style,
                                    width       = width,
                                    format_func = format_func,
                                    format_str  = format_str,
                                    padding     = -3 ) )

            group = Group( orientation = 'horizontal',
                           show_labels = False,
                           *items )
            content.append( group )

        return View( Group( show_labels = False, *content ) )

    #---------------------------------------------------------------------------
    #  Updates the underlying tuple when any field changes value:
    #---------------------------------------------------------------------------

    def _field_changed ( self ):
        """ Updates the underlying array when any field changes value.
        """

        if not self.editor._busy:
            # Get the array we are mirroring:
            object = self.editor.value
            shape  = object.shape
            value  = numpy.zeros( shape, object.dtype )

            # 1D
            if len( shape ) == 1:
                for i in range( shape[0] ):
                    value[i] = getattr( self, 'f%d' % i )
            # 2D
            elif len( shape ) == 2:
                for i in range( shape[0] ):
                    for j in range( shape[1] ):
                        value[i,j] = getattr( self, 'f%d_%d' % ( i, j ) )

            self.editor.update_array( value )



#-------------------------------------------------------------------------------
#  Toolkit-independent 'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for arrays.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the editor read-only?
    readonly = false

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._as     = _as = ArrayStructure( self )
        ui           = _as.view.ui( _as, parent, kind = 'subpanel' )
        ui.parent    = self.ui
        self.control = ui.control

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """

        if not self._busy:
            self._busy = True
            object = self.value
            shape  = object.shape
            _as    = self._as

            # 1D
            if len( shape ) == 1:
                for i in range( shape[0] ):
                    setattr( _as, 'f%d' % i, object[i] )
            # 2D
            elif len( shape ) == 2:
                for i in range( shape[0] ):
                    for j in range( shape[1] ):
                        setattr( _as, 'f%d_%d' % ( i, j ), object[i,j] )

            self._busy=False

    #---------------------------------------------------------------------------
    #  Updates the array value associated with the editor:
    #---------------------------------------------------------------------------

    def update_array ( self, value ):
        """ Updates the array value associated with the editor.
        """
        self._busy = True
        self.value = value
        self._busy = False


# Define the ArrayEditor class
ArrayEditor = ToolkitEditorFactory

### EOF ---------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = boolean_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the Boolean editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Dict, Str, Any

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.

from ..view import View

from .text_editor import ToolkitEditorFactory as EditorFactory

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Mapping from user input text to Boolean values
mapping_trait = Dict( Str, Any, { 'True':  True,
                                  'true':  True,
                                  't':     True,
                                  'yes':   True,
                                  'y':     True,
                                  'False': False,
                                  'false': False,
                                  'f':     False,
                                  'no':    False,
                                  'n':     False,
                    } )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for Boolean editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Dictionary mapping user input to other values.
    # These definitions override definitions in the 'text_editor' version
    mapping = mapping_trait

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View()

    #---------------------------------------------------------------------------
    #  EditorFactory methods
    #---------------------------------------------------------------------------

    def _get_custom_editor_class(self):
        """ Returns the editor class to use for "custom" style views.
        Overridden to return the simple_editor_class (instead of the
        CustomEditor class for the text editor's factory, which this class
        inherits from).

        """
        return self.simple_editor_class


# Define the BooleanEditor class
BooleanEditor = ToolkitEditorFactory

#- EOF -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = button_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the button editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Str, Range, Enum, Property, Trait

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.

from ..view import View

from ..ui_traits import AView, Image

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for buttons.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Value to set when the button is clicked
    value = Property

    # Optional label for the button
    label = Str

    # The name of the external object trait that the button label is synced to
    label_value = Str

    # The name of the trait on the object that contains the list of possible
    # values.  If this is set, then the value, label, and label_value traits
    # are ignored; instead, they will be set from this list.  When this button
    # is clicked, the value set will be the one selected from the drop-down.
    values_trait = Trait(None, None, Str)

    # (Optional) Image to display on the button
    image = Image

    # Extra padding to add to both the left and the right sides
    width_padding = Range( 0, 31, 7 )

    # Extra padding to add to both the top and the bottom sides
    height_padding = Range( 0, 31, 5 )

    # Presentation style
    style = Enum( 'button', 'radio', 'toolbar', 'checkbox' )

    # Orientation of the text relative to the image
    orientation = Enum( 'vertical', 'horizontal' )

    # The optional view to display when the button is clicked:
    view = AView

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( [ 'label', 'value', '|[]' ] )

    #---------------------------------------------------------------------------
    #  Implementation of the 'value' property:
    #---------------------------------------------------------------------------

    def _get_value ( self ):
        return self._value

    def _set_value ( self, value ):
        self._value = value
        if isinstance(value, basestring):
            try:
                self._value = int( value )
            except:
                try:
                    self._value = float( value )
                except:
                    pass

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        self._value = 0
        super( ToolkitEditorFactory, self ).__init__( **traits )


# Define the ButtonEditor class
ButtonEditor = ToolkitEditorFactory

### EOF ---------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = check_list_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------

""" Defines the editor factory for multi-selection enumerations, for all traits toolkit
backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Range

from ..editor_factory import EditorWithListFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorWithListFactory ):
    """ Editor factory for checklists.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Number of columns to use when the editor is displayed as a grid
    cols = Range( 1, 20 )

# Define the CheckListEditor class
CheckListEditor = ToolkitEditorFactory


########NEW FILE########
__FILENAME__ = code_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/27/2006
#
#------------------------------------------------------------------------------

""" Defines the code editor factory for all traits toolkit backends,
useful for tools such as debuggers.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Instance, Str, Color, Enum, Bool

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for code editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Object trait containing list of line numbers to mark (optional)
    mark_lines = Str

    # Background color for marking lines
    mark_color = Color( 0xECE9D8 )

    # Object trait containing the currently selected line (optional)
    selected_line = Str

    # Object trait containing the currently selected text (optional)
    selected_text = Str

    # Object trait containing the currently selected text start position (optional)
    selected_start_pos = Str

    # Object trait containing the currently selected text end position (optional)
    selected_end_pos = Str

    # Background color for selected lines
    selected_color = Color( 0xA4FFFF )

    # Where should the search toolbar be placed?
    search = Enum( 'top', 'bottom', 'none' )

    # Background color for lines that match the current search
    search_color = Color( 0xFFFF94 )

    # Current line
    line = Str

    # Current column
    column = Str

    # Should code folding be enabled?
    foldable = Bool( True )

    # Should line numbers be displayed in the margin?
    show_line_numbers = Bool( True )

    # Is user input set on every change?
    auto_set = Bool( True )

    # Should the editor auto-scroll when a new **selected_line** value is set?
    auto_scroll = Bool( True )

    # Optional key bindings associated with the editor
    key_bindings = Instance( 'traitsui.key_bindings.KeyBindings' )

    # Calltip clicked event
    calltip_clicked = Str

    # The lexer to use. Default is 'python'; 'null' indicates no lexing.
    lexer = Str('python')

    # Object trait containing the list of line numbers to dim (optional)
    dim_lines = Str

    # Object trait to dim lines to. Can be of form #rrggbb or a color spec. If
    # not specified, dark grey is used.
    dim_color = Str

    # Object trait containing the list of line numbers to put squiggles under
    # (optional)
    squiggle_lines = Str

    # Object trait for the color of squiggles. If not specified, red is used.
    squiggle_color = Str


# Define the Code Editor class.
CodeEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = color_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the color editor factory for the all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Bool

from ..toolkit import toolkit_object

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for color editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the underlying color trait mapped?
    mapped = Bool( True )

    # Do we use a native dialog for the popup or the toolkit's?
    # At present, only affects Qt.
    use_native_dialog = Bool( True )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( [ 'mapped{Is value mapped?}', '|[]>' ] )


# Define the ColorEditor class
# The function will try to return the toolkit-specific editor factory (located
# in traitsui.<toolkit>.color_editor, and if none is found, the
# ToolkitEditorFactory declared here is returned.
def ColorEditor(*args, **traits):
    """ Returns an instance of the toolkit-specific editor factory declared in
    traitsui.<toolkit>.color_editor. If such an editor factory
    cannot be located, an instance of the abstract ToolkitEditorFactory
    declared in traitsui.editors.color_editor is returned.

    Parameters
    ----------
    \*args, \*\*traits
        arguments and keywords to be passed on to the editor
        factory's constructor.
    """

    try:
        return toolkit_object('color_editor:ToolkitEditorFactory', True)(*args,
                                                                    **traits)
    except:
        return ToolkitEditorFactory(*args, **traits)

## EOF #######################################################################

########NEW FILE########
__FILENAME__ = compound_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------

""" Defines the compound editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import List, true

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# List of component editor factories used to build a compound editor
editors_trait = List( EditorFactory )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for compound editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Component editor factories used to build the editor
    editors  = editors_trait

    # Is user input set on every keystroke?
    auto_set = true


# Define the CompoundEditor class
CompoundEditor = ToolkitEditorFactory

## EOF ########################################################################

########NEW FILE########
__FILENAME__ = csv_list_editor
"""This modules defines CSVListEditor.

A CSVListEditor provides an editor for lists of simple data types.
It allows the user to edit the list in a text field, using commas
(or optionally some other character) to separate the elements.
"""

#------------------------------------------------------------------------------
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Warren Weckesser
#  Date:   July 2011
#
#------------------------------------------------------------------------------

from traits.api import Str, Int, Float, Enum, Range, Bool, Trait, TraitError
from traits.trait_handlers import RangeTypes

from .text_editor import TextEditor
from ..helper import enum_values_changed


def _eval_list_str(s, sep=',', item_eval=None,
                                ignore_trailing_sep=True):
    """Convert a string into a list.

    Parameters
    ----------
    s : str
        The string to be converted.
    sep : str or None
        `sep` is the text separator of list items.  If `sep` is None,
        each contiguous stretch of whitespace is a separator.
    item_eval : callable or None
        `item_eval` is used to evaluate the list elements.  If `item_eval`
        is None, the list will be a list substrings of `s`.
    ignore_trailing_sep : bool
        If `ignore_trailing_sep` is False, it is an error to have a separator
        at the end of the list (i.e. 'foo, bar,' is invalid).
        If `ignore_trailing_sep` is True, a separator at the end of the
        string `s` is ignored.

    Returns
    -------
    values : list
        List of converted values from the string.
    """
    if item_eval is None:
        item_eval = lambda x: x
    s = s.strip()
    if sep is not None and ignore_trailing_sep and s.endswith(sep):
        s = s[:-len(sep)]
        s = s.rstrip()
    if s == '':
        values = []
    else:
        values = [item_eval(x.strip()) for x in s.split(sep)]
    return values


def _format_list_str(values, sep=',', item_format=str):
    """Convert a list to a string.

    Each item in the list `values` is converted to a string with the
    function `item_format`, and these are joined with `sep` plus a space.
    If `sep` is None, a single space is used to join the items.

    Parameters
    ----------
    values : list
        The list of values to be represented as a string.
    sep : str
        String used to join the items.  A space is also added after
        `sep`.
    item_format : callable
        Converts its single argument to a string.

    Returns
    -------
    s : str
        The result of converting the list to a string.
    """
    if sep is None:
        joiner = ' '
    else:
        joiner = sep + ' '
    s = joiner.join(item_format(x) for x in values)
    return s


def _validate_range_value(range_object, object, name, value):
    """Validate a Range value.

    This function is used by the CSVListEditor to validate a value
    when editing a list of ranges where the Range is dynamic (that
    is, one or both of the 'low' and 'high' values are strings that
    refer to other traits in `object`.

    The function implements the same validation logic as in the method
    traits.trait_types.BaseRange._set(), but does not call the
    set_value() method; instead it simply returns the valid value.
    If the value is not valid, range_object.error(...) is called.

    Parameters
    ----------
    range_object : instance of traits.trait_types.Range

    object : instance of HasTraits
        This is the HasTraits object that holds the traits
        to which the one or both of range_object.low and
        range_object.high refer.

    name : str
        The name of the List trait in `object`.

    value : object (e.g. int, float, str)
        The value to be validated.

    Returns
    -------
    value : object
        The validated value.  It might not be the same
        type as the input argument (e.g. if the range type
        is float and the input value is an int, the return
        value will be a float).
    """
    low = eval(range_object._low)
    high = eval(range_object._high)
    if low is None and high is None:
        if isinstance(value, RangeTypes):
            return value
    else:
        new_value = range_object._typed_value(value, low, high)

        satisfies_low = (low is None or low < new_value or
            ((not range_object._exclude_low) and (low == new_value)))

        satisfies_high = (high is None or high > new_value or
            ((not range_object._exclude_high) and (high == new_value)))

        if satisfies_low and satisfies_high:
            return value

    # Note: this is the only explicit use of 'object' and 'name'.
    range_object.error(object, name, value)


def _prepare_method(cls, parent):
        """ Unbound implementation of the prepare editor method to add a
        change notification hook in the items of the list before calling
        the parent prepare method of the parent class.

        """
        name = cls.extended_name
        if name != 'None':
            cls.context_object.on_trait_change(cls._update_editor,
                                                name + '[]',
                                                dispatch='ui')
        super(cls.__class__, cls).prepare(parent)

def _dispose_method(cls):
        """ Unbound implementation of the dispose editor method to remove
        the change notification hook in the items of the list before calling
        the parent dispose method of the parent class.

        """
        if cls.ui is None:
            return

        name = cls.extended_name
        if name != 'None':
            cls.context_object.on_trait_change(cls._update_editor,
                                                name + '[]',
                                                remove=True)
        super(cls.__class__, cls).dispose()

class CSVListEditor(TextEditor):
    """A text editor for a List.

    This editor provides a single line of input text of comma separated
    values.  (Actually, the default separator is a comma, but this can
    changed.)  The editor can only be used with List traits whose inner
    trait is one of Int, Float, Str, Enum, or Range.

    The 'simple', 'text', 'custom' and readonly styles are based on
    TextEditor. The 'readonly' style provides the same formatting in the
    text field as the other editors, but the user cannot change the value.

    Like other Traits editors, the background of the text field will turn
    red if the user enters an incorrectly formatted list or if the values
    do not match the type of the inner trait.  This validation only occurs
    while editing the text field.  If, for example, the inner trait is
    Range(low='lower', high='upper'), a change in 'upper' will not trigger
    the validation code of the editor.

    The editor removes whitespace of entered items with strip(), so for
    Str types, the editor should not be used if whitespace at the beginning
    or end of the string must be preserved.

    Constructor Keyword Arguments
    -----------------------------
    sep : str or None, optional
        The separator of the values in the list.  If None, each contiguous
        sequence of whitespace is a separator.
        Default is ','.

    ignore_trailing_sep : bool, optional
        If this is False, a line containing a trailing separator is invalid.
        Default is True.

    auto_set : bool
        If True, then every keystroke sets the value of the trait.

    enter_set : bool
        If True, the user input sets the value when the Enter key is pressed.

    Example
    -------
    The following will display a window containing a single input field.
    Entering, say, '0, .5, 1' in this field will result in the list
    x = [0.0, 0.5, 1.0].

    >>> class Foo(HasTraits):
    ....    x = List(Range(low=0.0, high=1.0))
    ....    traits_view = View(Item('x', editor=CSVListEditor()))
    ....    def _x_changed(self):
    ....        print self.x
    ....
    >>> f = Foo()
    >>> f.configure_traits()

    """

    # The separator of the element in the list.
    sep = Trait(',', None, Str)

     # If False, it is an error to have a trailing separator.
    ignore_trailing_sep = Bool(True)

    # Include some of the TextEditor API:

    # Is user input set on every keystroke?
    auto_set = Bool(True)

    # Is user input set when the Enter key is pressed?
    enter_set = Bool(False)

    def _funcs(self, object, name):
        """Create the evalution and formatting functions for the editor.

        Parameters
        ----------
        object : instance of HasTraits
            This is the object that has the List trait for which we are
            creating an editor.

        name : str
            Name of the List trait on `object`.

        Returns
        -------
        evaluate, fmt_func : callable, callable
            The functions for converting a string to a list (`evaluate`)
            and a list to a string (`fmt_func`).  These are the functions
            that are ultimately given as the keyword arguments 'evaluate'
            and 'format_func' of the TextEditor that will be generated by
            the CSVListEditor editor factory functions.
        """
        t = getattr(object, name)
        # Get the list of inner traits.  Only a single inner trait is allowed.
        it_list = t.trait.inner_traits()
        if len(it_list) > 1:
            raise TraitError("Only one inner trait may be specified when "
                             "using a CSVListEditor.")

        # `it` is the single inner trait.  This will be an instance of
        # traits.traits.CTrait.
        it = it_list[0]
        # The following 'if' statement figures out the appropriate evaluation
        # function (evaluate) and formatting function (fmt_func) for the
        # given inner trait.
        if it.is_trait_type(Int) or it.is_trait_type(Float) or \
                                                it.is_trait_type(Str):
            evaluate = \
                lambda s: _eval_list_str(s, sep=self.sep,
                                item_eval=it.trait_type.evaluate,
                                ignore_trailing_sep=self.ignore_trailing_sep)
            fmt_func = lambda vals: _format_list_str(vals,
                                                    sep=self.sep)
        elif it.is_trait_type(Enum):
            values, mapping, inverse_mapping = enum_values_changed(it)
            evaluate = \
                lambda s: _eval_list_str(s, sep=self.sep,
                                item_eval=mapping.__getitem__,
                                ignore_trailing_sep=self.ignore_trailing_sep)
            fmt_func = \
                lambda vals: \
                    _format_list_str(vals, sep=self.sep,
                                     item_format=inverse_mapping.__getitem__)
        elif it.is_trait_type(Range):
            # Get the type of the values from the default value.
            # range_object will be an instance of traits.trait_types.Range.
            range_object = it.handler
            if range_object.default_value_type == 8:
                # range_object.default_value is callable.
                defval = range_object.default_value(object)
            else:
                # range_object.default_value *is* the default value.
                defval = range_object.default_value
            typ = type(defval)

            if range_object.validate is None:
                # This will be the case for dynamic ranges.
                item_eval = lambda s: _validate_range_value(
                                        range_object, object, name, typ(s))
            else:
                # Static ranges have a validate method.
                item_eval = lambda s: range_object.validate(
                                                    object, name, typ(s))

            evaluate = \
                lambda s: _eval_list_str(s, sep=self.sep,
                                item_eval=item_eval,
                                ignore_trailing_sep=self.ignore_trailing_sep)
            fmt_func = lambda vals: _format_list_str(vals,
                                                     sep=self.sep)
        else:
            raise TraitError("To use a CSVListEditor, the inner trait of the "
                             "List must be Int, Float, Range, Str or Enum.")

        return evaluate, fmt_func


    #---------------------------------------------------------------------------
    #  Methods that generate backend toolkit-specific editors.
    #---------------------------------------------------------------------------

    def simple_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "simple" style.
        """
        self.evaluate, self.format_func = self._funcs(object, name)
        return self.simple_editor_class( parent,
                                         factory     = self,
                                         ui          = ui,
                                         object      = object,
                                         name        = name,
                                         description = description )

    def custom_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "custom" style.
        """
        self.evaluate, self.format_func = self._funcs(object, name)
        return self.custom_editor_class( parent,
                                         factory     = self,
                                         ui          = ui,
                                         object      = object,
                                         name        = name,
                                         description = description )

    def text_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "text" style.
        """
        self.evaluate, self.format_func = self._funcs(object, name)
        return self.text_editor_class( parent,
                                       factory     = self,
                                       ui          = ui,
                                       object      = object,
                                       name        = name,
                                       description = description )

    def readonly_editor ( self, ui, object, name, description, parent ):
        """ Generates an "editor" that is read-only.
        """
        self.evaluate, self.format_func = self._funcs(object, name)
        return self.readonly_editor_class( parent,
                                           factory     = self,
                                           ui          = ui,
                                           object      = object,
                                           name        = name,
                                           description = description )

########NEW FILE########
__FILENAME__ = custom_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/19/2005
#
#------------------------------------------------------------------------------

""" Defines the editor factory used to wrap a non-Traits based custom control.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Callable, Tuple, Property

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( BasicEditorFactory ):
    """ Editor factory for custom editors.
    """
    # Editor class to be instantiated.
    klass = Property

    # Factory function used to create the custom control
    factory = Callable

    # Arguments to be passed to the user's custom editor factory
    args    = Tuple

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, *args, **traits ):
        if len( args ) >= 1:
            self.factory = args[0]
            self.args    = args[1:]
        super( ToolkitEditorFactory, self ).__init__( **traits )

    #---------------------------------------------------------------------------
    #  Property getters
    #---------------------------------------------------------------------------
    def _get_klass(self):
        """ Returns the editor class to be created.
        """
        return toolkit_object('custom_editor:CustomEditor')

# Define the CustomEditor class.
CustomEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = date_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Judah De Paula
#  Date:   10/7/2008
#
#------------------------------------------------------------------------------

""" A Traits UI editor that wraps a WX calendar panel.
"""

from __future__ import absolute_import

from traits.trait_types import Bool, Int, Enum, Str
from ..ui_traits import AView
from ..editor_factory import EditorFactory


class DateEditor(EditorFactory):
    """ Editor factory for date/time editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #-- ReadonlyEditor traits --------------------------------------------------

    # Message to show when Date is None.
    message = Str('Undefined')

    # The string representation of the date to show.  Uses time.strftime format.
    strftime = Str('%B %d %Y (%a)')

    # An optional view to display when a read-only text editor is clicked:
    view = AView

    #-- CustomEditor traits ----------------------------------------------------

    # Should users be able to pick future dates when using the CustomEditor?
    allow_future = Bool(True)

    # How many months to show at a time.
    months = Int(3)

    # True: Must be a List of Dates.  False: Must be a Date instance.
    multi_select = Bool(False)

    # When a user multi-selects entries and some of those entries are already
    # selected and some are not, what should be the behavior for the seletion?
    # Options::
    #
    #     'toggle'     -- Toggle each day to the opposite of the current state.
    #     'on'         -- Always turn them on.
    #     'off'        -- Always turn them off.
    #     'max_change' -- Change all to same state, with most days changing.
    #                     For example 1 selected and 9 not, then they would
    #                     all get selected.
    #     'min_change' -- Change all to same state, with min days changing.
    #                     For example 1 selected and 9 not, then they would
    #                     all get unselected.
    on_mixed_select = Enum('toggle', 'on', 'off', 'max_change', 'min_change')

    # How much space to put between the individual months.
    padding = Int(5)

    # Does the user have to hold down Shift for the left-click multiselect?
    shift_to_select = Bool(False)

########NEW FILE########
__FILENAME__ = default_override
"""
Editor factory that overrides certain attributes of the default editor.

For example, the default editor for Range(low=0, high=1500) has
'1500' as the upper label.  To change it to 'Max' instead, use

my_range = Range(low=0, high=1500,
                 editor=DefaultOverride(high_label='Max'))

Alternatively, the override can also be specified in the view:

View(Item('my_range', editor=DefaultOverride(high_label='Max'))

"""

from __future__ import absolute_import

from traits.api import Dict
from ..editor_factory import EditorFactory

class DefaultOverride(EditorFactory):
    """Editor factory for selectively overriding certain parameters
    of the default editor.

    """
    _overrides = Dict

    def __init__(self, *args, **overrides):
        EditorFactory.__init__(self, *args)
        self._overrides = overrides

    def _customise_default(self, editor_kind, ui, object, name,
                           description, parent):
        """
        Obtain the given trait's default editor and set the parameters
        specified in `overrides` above.
        """
        trait = object.trait(name)
        editor_factory = trait.trait_type.create_editor()
        for option in self._overrides:
            setattr(editor_factory, option, self._overrides[option])

        editor = getattr(editor_factory, editor_kind)(ui, object, name,
                                                      description, parent)
        return editor

    def simple_editor(self, ui, object, name, description, parent):
        return self._customise_default('simple_editor', ui, object,
                                       name, description, parent)

    def custom_editor(self, ui, object, name, description, parent):
        return self._customise_default('custom_editor', ui, object,
                                       name, description, parent)

    def text_editor(self, ui, object, name, description, parent):
        return self._customise_default('text_editor', ui, object,
                                       name, description, parent)

    def readonly_editor(self, ui, object, name, description, parent):
        return self._customise_default('readonly_editor', ui, object,
                                       name, description, parent)

########NEW FILE########
__FILENAME__ = directory_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------
""" Defines the directory editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .file_editor import ToolkitEditorFactory as EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for directory editors.
    """
    pass

# Define the DirectoryEditor class
DirectoryEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = dnd_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/25/2006
#
#------------------------------------------------------------------------------

""" Defines the editor factory for a drag-and-drop editor. A drag-and-drop
    editor represents its value as a simple image which, depending upon the
    editor style, can be a drag source only, a drop target only, or both a
    drag source and a drop target.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from ..ui_traits import Image

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for drag-and-drop editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The image to use for the target:
    image = Image

    # The image to use when the target is disabled:
    disabled_image = Image


# Define the DNDEditor class.
DNDEditor = ToolkitEditorFactory

# EOF #########################################################################

########NEW FILE########
__FILENAME__ = drop_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------
""" Defines a drop editor factory for all traits toolkit backends.
    A drop target editor handles drag and drop operations as a drop
    target.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Any, Bool

from .text_editor import ToolkitEditorFactory as EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for drop editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Allowable drop objects must be of this class (optional)
    klass = Any

    # Must allowable drop objects be bindings?
    binding = Bool(False)

    # Can the user type into the editor, or is it read only?
    readonly = Bool(True)

# Define the DropEditor class.
DropEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = enum_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------
""" Defines the editor factory for single-selection enumerations, for all traits
    user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import os, sys

from ..editor_factory import EditorWithListFactory

from traits.api import Any, Range, Enum, Bool

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Supported display modes for a custom style editor
Mode = Enum( 'radio', 'list' )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorWithListFactory ):
    """ Editor factory for enumeration editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # (Optional) Function used to evaluate text input:
    evaluate = Any

    # Is user input set on every keystroke (when text input is allowed)?
    auto_set = Bool( True )

    # Number of columns to use when displayed as a grid:
    cols = Range( 1, 20 )

    # Display modes supported for a custom style editor:
    mode = Mode

    #---------------------------------------------------------------------------
    #  'Editor' factory methods:
    #---------------------------------------------------------------------------

    def _get_custom_editor_class ( self ):
        """ Returns the editor class to use for "custom" style views.
        Overridden to return the editor class for the specified mode.
        """
        editor_file_name = \
            os.path.basename(sys.modules[self.__class__.__module__].
                            __file__)
        try:
            if self.mode == 'radio':
                return toolkit_object(editor_file_name.split('.')[0] +
                                      ':RadioEditor',
                                      raise_exceptions = True)
            else:
                return toolkit_object(editor_file_name.split('.')[0] +
                                      ':ListEditor',
                                      raise_exceptions = True)
        except:
            return super(ToolkitEditorFactory, self)._get_custom_editor_class()


# Define the EnumEditor class.
EnumEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = file_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------
""" Defines the file editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import List, Str, Bool, Int, Unicode, File

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..group import Group

from .text_editor import ToolkitEditorFactory as EditorFactory

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Wildcard filter:
filter_trait = List(Unicode)

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for file editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Wildcard filter to apply to the file dialog:
    filter = filter_trait

    # Optional extended trait name of the trait containing the list of filters:
    filter_name = Str

    # Should file extension be truncated?
    truncate_ext = Bool( False )

    # Can the user select directories as well as files?
    allow_dir = Bool( False )

    # Is user input set on every keystroke? (Overrides the default) ('simple'
    # style only):
    auto_set = False

    # Is user input set when the Enter key is pressed? (Overrides the default)
    # ('simple' style only):
    enter_set = True

    # The number of history entries to maintain:
    # FIXME: add support
    entries = Int( 10 )

    # The root path of the file tree view ('custom' style only, not supported
    # under wx). If not specified, the filesystem root is used.
    root_path = File

    # Optional extend trait name of the trait containing the root path.
    root_path_name = Str

    # Optional extended trait name used to notify the editor when the file
    # system view should be reloaded ('custom' style only):
    reload_name = Str

    # Optional extended trait name used to notify when the user double-clicks
    # an entry in the file tree view. The associated path is assigned it:
    dclick_name = Str

    # The style of file dialog to use when the 'Browse...' button is clicked
    # Should be one of 'open' or 'save'
    dialog_style = Str('open')

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ '<options>',
                        'truncate_ext{Automatically truncate file extension?}',
                        '|options:[Options]>' ],
                          [ 'filter', '|[Wildcard filters]<>' ] ] )

    extras = Group()

# Define the FileEditor class.
FileEditor = ToolkitEditorFactory

## EOF ########################################################################

########NEW FILE########
__FILENAME__ = font_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the font editor factory for all traits user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from ..editor_factory import EditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------
class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for font editors.
    """
    pass


# Define the FontEditor class
# The function will try to return the toolkit-specific editor factory (located
# in traitsui.<toolkit>.font_editor, and if none is found, the
# ToolkitEditorFactory declared here is returned.
def FontEditor(*args, **traits):
    """ Returns an instance of the toolkit-specific editor factory declared in
    traitsui.<toolkit>.font_editor. If such an editor factory
    cannot be located, an instance of the abstract ToolkitEditorFactory
    declared in traitsui.editors.font_editor is returned.

    Parameters
    ----------
    \*args, \*\*traits
        arguments and keywords to be passed on to the editor
        factory's constructor.
    """

    try:
       return toolkit_object('font_editor:ToolkitEditorFactory', True)(*args,
                                                                    **traits)
    except Exception, e:
       return ToolkitEditorFactory(*args, **traits)


## EOF ########################################################################

########NEW FILE########
__FILENAME__ = history_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#-------------------------------------------------------------------------------

""" Defines a text editor which displays a text field and maintains a history
    of previously entered values.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Int, Bool

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

# Define callable which returns the 'klass' value (i.e. the editor to use in
# the EditorFactory.
def history_editor(*args, **traits):
    return toolkit_object('history_editor:_HistoryEditor')(*args, **traits)

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------
class ToolkitEditorFactory( BasicEditorFactory ):

    # The number of entries in the history:
    entries = Int( 10 )

    # Should each keystroke update the value (or only the enter key, tab, etc.)?
    auto_set = Bool( False )


HistoryEditor = ToolkitEditorFactory( klass = history_editor )
# EOF #########################################################################

########NEW FILE########
__FILENAME__ = html_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the HTML editor factory. HTML editors interpret and display
    HTML-formatted text, but do not modify it.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Str, false

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

# Callable that returns the editor to use in the UI.
def html_editor(*args, **traits):
    return toolkit_object('html_editor:SimpleEditor')(*args, **traits)

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Template used to create code blocks embedded in the module comment
block_template = """<center><table width="95%%"><tr><td bgcolor="#ECECEC"><tt>
%s</tt></td></tr></table></center>"""

# Template used to create lists embedded in the module comment
list_template = """<%s>
%s
</%s>"""

#------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#------------------------------------------------------------------------------

class ToolkitEditorFactory ( BasicEditorFactory ):
    """ Editor factory for HTML editors.
    """
    #--------------------------------------------------------------------------
    #  Trait definitions:
    #--------------------------------------------------------------------------

    # Should implicit text formatting be converted to HTML?
    format_text = false

    # External objects referenced in the HTML are relative to this url
    base_url = Str

    # The object trait containing the base URL
    base_url_name = Str

    # Should links be opened in an external browser?
    open_externally = false

    #---------------------------------------------------------------------------
    #  Parses the contents of a formatted text string into the corresponding
    #  HTML:
    #---------------------------------------------------------------------------

    def parse_text ( self, text ):
        """ Parses the contents of a formatted text string into the
            corresponding HTML.
        """
        text  = text.replace( '\r\n', '\n' )
        lines = [ ('.' + line).strip()[1:] for line in text.split( '\n' ) ]
        ind   = min( *([ self.indent( line ) for line in lines
                         if line != '' ] + [ 1000, 1000 ]) )
        if ind >= 1000:
            ind = 0
        lines     = [ line[ ind: ] for line in lines ]
        new_lines = []
        i = 0
        n = len( lines )
        while i < n:
            line = lines[i]
            m    = self.indent( line )
            if m > 0:
                if line[m] in '-*':
                    i, line = self.parse_list( lines, i )
                else:
                    i, line = self.parse_block( lines, i )
                new_lines.append( line )
            else:
                new_lines.append( line )
                i += 1
        text       = '\n'.join( new_lines )
        paragraphs = [ p.strip() for p in text.split( '\n\n' ) ]
        for i, paragraph in enumerate( paragraphs ):
            if paragraph[:3].lower() != '<p>':
                paragraphs[i] = '<p>%s</p>' % paragraph
        return '\n'.join( paragraphs )

    #---------------------------------------------------------------------------
    #  Parses a code block:
    #---------------------------------------------------------------------------

    def parse_block ( self, lines, i ):
        """ Parses a code block.
        """
        m = 1000
        n = len( lines )
        j = i
        while j < n:
            line = lines[j]
            if line != '':
                k = self.indent( line )
                if k == 0:
                    break
                m = min( m, k )
            j += 1
        j -= 1
        while (j > i) and (lines[j] == ''):
            j -= 1
        j += 1
        temp = [ (('&nbsp;' * (self.indent( line ) - m)) +
                  line.strip()) for line in lines[ i: j ] ]
        return ( j, block_template % '\n<br>'.join( temp ) )

    #---------------------------------------------------------------------------
    #  Parses a list:
    #---------------------------------------------------------------------------

    def parse_list ( self, lines, i ):
        """ Parses a list.
        """
        line   = lines[i]
        m      = self.indent( line )
        kind   = line[m]
        result = [ '<li>' + line[ m + 1: ].strip() ]
        n      = len( lines )
        j      = i + 1
        while j < n:
            line = lines[j]
            k    = self.indent( line )
            if k < m:
                break
            if k == m:
                if line[k] != kind:
                    break
                result.append( '<li>' + line[ k + 1: ].strip() )
                j += 1
            elif line[k] in '-*':
                j, line = self.parse_list( lines, j )
                result.append( line )
            else:
                result.append( line.strip() )
                j += 1
        style = [ 'ul', 'ol' ][ kind == '*' ]
        return ( j, list_template % ( style, '\n'.join( result ), style ) )

    #---------------------------------------------------------------------------
    #  Calculates the amount of white space at the beginning of a line:
    #---------------------------------------------------------------------------

    def indent ( self, line ):
        """ Calculates the amount of white space at the beginning of a line.
        """
        return len( line ) - len( (line + '.').strip() ) + 1

HTMLEditor = ToolkitEditorFactory(klass = html_editor)

#-EOF--------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = image_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/05/2007
#
#-------------------------------------------------------------------------------

""" Traits UI 'display only' image editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Bool, Property

from ..ui_traits import Image

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'ImageEditor' editor factory class:
#-------------------------------------------------------------------------------

class ImageEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = Property

    # The optional image resource to be displayed by the editor (if not
    # specified, the editor's object value is used as the ImageResource to
    # display):
    image = Image

    # The following traits are currently supported on Qt only

    # Whether or not to scale the image to fit the available space
    scale = Bool
    
    # Whether or not to scale the image larger than the original when scaling
    allow_upscaling = Bool
    
    # Whether or not to preserve the aspect ratio when scaling
    preserve_aspect_ratio = Bool
    
    # Whether or not to allow the image to be clipped when not scaling
    allow_clipping = Bool


    def _get_klass(self):
        """ Returns the editor class to be instantiated.
        """
        return toolkit_object('image_editor:_ImageEditor')

#-- EOF -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = image_enum_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the image enumeration editor factory for all traits user interface
toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import sys

from os import getcwd

from os.path import join, dirname, exists

from traits.api import Module, Type, Unicode, on_trait_change

from .enum_editor import ToolkitEditorFactory as EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for image enumeration editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------
    # Prefix to add to values to form image names:
    prefix = Unicode

    # Suffix to add to values to form image names:
    suffix = Unicode

    # Path to use to locate image files:
    path = Unicode

    # Class used to derive the path to the image files:
    klass = Type

    # Module used to derive the path to the image files:
    module = Module


    #---------------------------------------------------------------------------
    #  Performs any initialization needed after all constructor traits have
    #  been set:
    #---------------------------------------------------------------------------

    def init ( self ):
        """ Performs any initialization needed after all constructor traits
            have been set.
        """
        super( ToolkitEditorFactory, self ).init()
        self._update_path()

    #---------------------------------------------------------------------------
    #  Handles one of the items defining the path being updated:
    #---------------------------------------------------------------------------

    @on_trait_change( 'path, klass, module' )
    def _update_path ( self ):
        """ Handles one of the items defining the path being updated.
        """
        if self.path != '':
            self._image_path = self.path
        elif self.klass is not None:
            module = self.klass.__module__
            if module == '___main___':
                module = '__main__'
            try:
                self._image_path = join( dirname( sys.modules[ module
                                                        ].__file__ ), 'images' )
            except:
                self._image_path = self.path
                dirs = [ join( dirname( sys.argv[0] ), 'images' ),
                         join( getcwd(), 'images' ) ]
                for d in dirs:
                    if exists( d ):
                        self._image_path = d
                        break
        elif self.module is not None:
            self._image_path = join( dirname( self.module.__file__ ), 'images' )

# Define the ImageEnumEditor class.
ImageEnumEditor = ToolkitEditorFactory

## EOF ########################################################################

########NEW FILE########
__FILENAME__ = instance_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the instance editor factory for all traits user interface
toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Str, List, Enum, Unicode, Type, Bool

from ..view import View, AKind

from ..ui_traits import AView

from ..instance_choice import InstanceChoice, InstanceChoiceItem

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for instance editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # List of items describing the types of selectable or editable instances
    values = List( InstanceChoiceItem )

    # Extended name of the context object trait containing the list of types of
    # selectable or editable instances
    name = Str

    # Is the current value of the object trait editable (vs. merely selectable)?
    editable = Bool(True)

    # Should the object trait value be selectable from a list of objects (a
    # value of True forces a selection list to be displayed, while a value of
    # False displays a selection list only if at least one object in the list
    # of possible object values is selectable):
    selectable = Bool( False )

    # Should the editor support drag and drop of objects to set the trait value
    # (a value of True forces the editor to allow drag and drop, while a value
    # of False only supports drag and drop if at least one item in the list of
    # possible objects supports drag and drop):
    droppable = Bool( False )

    # Should factory-created objects be cached?
    cachable = Bool(True)

    # Optional label for button
    label = Unicode

    # Optional instance view to use
    view = AView

    # Extended name of the context object trait containing the view, or name of
    # the view, to use
    view_name = Str

    # The ID to use with the view
    id = Str

    # Kind of pop-up editor (live, modal, nonmodal, wizard)
    kind = AKind

    # The orientation of the instance editor relative to the instance selector
    orientation = Enum( 'default', 'horizontal', 'vertical' )

    # The default adapter class used to create InstanceChoice compatible
    # adapters for instance objects:
    adapter = Type( InstanceChoice, allow_none = False )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ 'label{Button label}',
                            'view{View name}', '|[]' ],
                          [ 'kind@', '|[Pop-up editor style]<>' ] ] )


# Define the InstanceEditor class.
InstanceEditor = ToolkitEditorFactory

### EOF #######################################################################


########NEW FILE########
__FILENAME__ = key_binding_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------
""" Defines the key binding editor for use with the KeyBinding class. This is a
specialized editor used to associate a particular key with a control (i.e., the
key binding editor).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

# FIXME: Import from the api.py file when it has been added.
from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

# Callable which returns the editor to use in the ui.
def key_binding_editor(*args, **traits):
    return toolkit_object('key_binding_editor:KeyBindingEditor')(*args,
                                                                 **traits)

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------
KeyBindingEditor = ToolkitEditorFactory = BasicEditorFactory(klass = key_binding_editor)

### EOF ------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = list_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------
""" Defines the list editor factory for the traits user interface toolkits..
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (HasTraits, BaseTraitHandler, Range, Str, Any, Int, Instance,
        Property, Bool, Callable, Enum, PrototypedFrom)

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..item import Item

from ..ui_traits import style_trait, AView

from ..editor_factory import EditorFactory

from ..toolkit import toolkit_object

# Currently, this traits is used only for the wx backend.
from ..helper import DockStyle

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Trait whose value is a BaseTraitHandler object
handler_trait = Instance( BaseTraitHandler )

# The visible number of rows displayed
rows_trait = Range( 1, 50, 5,
                    desc = 'the number of list rows to display' )

# The visible number of columns displayed
columns_trait = Range( 1, 10, 1,
                    desc = 'the number of list columns to display' )

editor_trait = Instance( EditorFactory )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for list editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The editor to use for each list item:
    editor = editor_trait

    # Can the list be reorganized, or have items added and deleted.
    mutable = Bool(True)

    # The style of editor to use for each item:
    style = style_trait

    # The trait handler for each list item:
    trait_handler = handler_trait

    # The number of list rows to display:
    rows = rows_trait

    # The number of list columns to create:
    columns = columns_trait

    # Use a notebook for a custom view?
    use_notebook = Bool(False)

    # Show a right-click context menu for the notebook tabs?  (Qt only)
    show_notebook_menu = Bool(False)

    #-- Notebook Specific Traits -----------------------------------------------

    # Are notebook items deletable?
    deletable = Bool(False)

    # The extended name of the trait on each page object which should be used
    # to determine whether or not an individual page should be deletable.
    deletable_trait = Str()

    # FIXME: Currently, this trait is used only in the wx backend.
    # The DockWindow graphical theme
    dock_theme = Any

    # FIXME: Currently, this trait is used only in the wx backend.
    # Dock page style to use for each DockControl:
    dock_style = DockStyle

    # Export class for each item in a notebook:
    export = Str

    # Name of the view to use in notebook mode:
    view = AView

    # The type of UI to construct ('panel', 'subpanel', etc)
    ui_kind = Enum( 'subpanel', 'panel' )

    # A factory function that can be used to define that actual object to be
    # edited (i.e. view_object = factory( object )):
    factory = Callable

    # Extended name to use for each notebook page. It can be either the actual
    # name or the name of an attribute on the object in the form:
    # '.name[.name...]'
    page_name = Str

    # Name of the [object.]trait[.trait...] to synchronize notebook page
    # selection with:
    selected = Str

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ 'use_notebook{Use a notebook in a custom view}',
                            '|[Style]' ],
                          [ Item( 'page_name',
                                  enabled_when = 'object.use_notebook' ),
                            Item( 'view',
                                  enabled_when = 'object.use_notebook' ),
                            '|[Notebook options]' ],
                          [ Item( 'rows',
                                  enabled_when = 'not object.use_notebook' ),
                            '|[Number of list rows to display]<>' ] ] )

    #---------------------------------------------------------------------------
    #  'Editor' factory methods:
    #---------------------------------------------------------------------------

    def _get_custom_editor_class ( self ):
        if self.use_notebook:
            return toolkit_object('list_editor:NotebookEditor')
        return toolkit_object('list_editor:CustomEditor')

#-------------------------------------------------------------------------------
#  'ListItemProxy' class:
#   This class is used to update the list editors when the object changes
#   external to the editor.
#-------------------------------------------------------------------------------

class ListItemProxy ( HasTraits ):

    # The list proxy:
    list = Property

    # The item proxies index into the original list:
    index = Int

    # Delegate all other traits to the original object:
    _ = PrototypedFrom( '_zzz_object' )

    # Define all of the private internal use values (the funny names are an
    # attempt to avoid name collisions with delegated trait names):
    _zzz_inited = Any
    _zzz_object = Any
    _zzz_name   = Any

    def __init__ ( self, object, name, index, trait, value ):
        super( ListItemProxy, self ).__init__()

        self._zzz_inited = False
        self._zzz_object = object
        self._zzz_name   = name
        self.index       = index

        if trait is not None:
            self.add_trait( 'value', trait )
            self.value = value

        self._zzz_inited = (self.index < len( self.list ))

    def _get_list ( self ):
        return getattr( self._zzz_object, self._zzz_name )

    def _value_changed ( self, old_value, new_value ):
        if self._zzz_inited:
            self.list[ self.index ] = new_value


# Define the ListEditor class
ListEditor = ToolkitEditorFactory

### EOF ---------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = list_str_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   05/08/2007
#
#-------------------------------------------------------------------------------

""" Traits UI editor factory for editing lists of strings.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Any, Str, Enum, List, Bool, Instance, Property

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

from pyface.image_resource import ImageResource

#-------------------------------------------------------------------------------
#  'ListStrEditor' editor factory class:
#-------------------------------------------------------------------------------

class ListStrEditor ( BasicEditorFactory ):
    """ Editor factory for list of string editors.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The editor class to be created:
    klass = Property

    # The optional extended name of the trait to synchronize the selection
    # values with:
    selected = Str

    # The optional extended name of the trait to synchronize the selection
    # indices with:
    selected_index = Str

    # The optional extended name of the trait to synchronize the activated value
    # with:
    activated = Str

    # The optional extended name of the trait to synchronize the activated
    # value's index with:
    activated_index = Str

    # The optional extended name of the trait to synchronize the right clicked
    # value with:
    right_clicked = Str

    # The optional extended name of the trait to synchronize the right clicked
    # value's index with:
    right_clicked_index = Str

    # Can the user edit the values?
    editable = Bool( True )

    # Are multiple selected items allowed?
    multi_select = Bool( False )

    # Should horizontal lines be drawn between items?
    horizontal_lines = Bool( False )

    # The title for the editor:
    title = Str

    # The optional extended name of the trait containing the editor title:
    title_name = Str

    # Should a new item automatically be added to the end of the list to allow
    # the user to create new entries?
    auto_add = Bool( False )

    # The adapter from list items to editor values:
    adapter = Instance( 'traitsui.list_str_adapter.ListStrAdapter',
                        () )

    # The optional extended name of the trait containing the adapter:
    adapter_name = Str

    # What type of operations are allowed on the list:
    operations = List( Enum( 'delete', 'insert', 'append', 'edit', 'move' ),
                       [ 'delete', 'insert', 'append', 'edit', 'move' ] )

    # Are 'drag_move' operations allowed (i.e. True), or should they always be
    # treated as 'drag_copy' operations (i.e. False):
    drag_move = Bool( False )

    # The set of images that can be used:
    images = List( ImageResource )

    # Right-click context menu (Qt4 only). The value can be one of:
    #
    # - Instance( Menu ): Use this menu as the context menu
    # - string: Name of traits that will provide menu
    # - None: Use the default context menu
    # - False: Do not display a context menu
    menu = Any

    def _get_klass(self):
        """ Returns the editor class to be created.
        """
        return toolkit_object('list_str_editor:_ListStrEditor')
##EOF #########################################################################

########NEW FILE########
__FILENAME__ = null_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/26/2006
#
#-------------------------------------------------------------------------------

""" Defines a completely empty editor, intended to be used as a spacer.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

# Callable which returns the editor to use in the ui.
def null_editor(*args, **traits):
    return toolkit_object('null_editor:NullEditor')(*args, **traits)

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------
NullEditor = BasicEditorFactory(klass = null_editor)

### EOF ---------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = popup_editor
#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Float, Enum, Any, Property

from ..view import View

from ..item import Item

from ..editor_factory import EditorFactory

from ..basic_editor_factory import BasicEditorFactory

from .text_editor import TextEditor

from ..ui_traits import EditorStyle

from ..ui_editor import UIEditor

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  '_PopupEditor' class:
#-------------------------------------------------------------------------------

class _PopupEditor ( UIEditor ):

    #---------------------------------------------------------------------------
    #  Creates the traits UI for the editor:
    #---------------------------------------------------------------------------

    def init_ui ( self, parent ):
        """ Creates the traits UI for the editor.
        """
        return self.object.edit_traits( view   = self.base_view(),
                                        parent = parent )

    def base_view ( self ):
        """ Returns the View that allows the popup view to be displayed.
        """
        return View(
            Item( self.name,
                  show_label = False,
                  style      = 'readonly',
                  editor     = TextEditor( view = self.popup_view() ),
                  padding    = -4,
            ),
            kind = 'subpanel'
        )

    def popup_view ( self ):
        """ Returns the popup View.
        """
        factory = self.factory
        item    = Item( self.name,
                        show_label = False,
                        padding    = -4,
                        style      = factory.style,
                        height     = factory.height,
                        width      = factory.width )

        editor = factory.editor
        if editor is not None:
            if not isinstance( editor, EditorFactory ):
                editor = editor()
            item.editor = editor

        return View( item, kind = factory.kind )

#-------------------------------------------------------------------------------
#  'PopupEditor' class:
#-------------------------------------------------------------------------------

class PopupEditor ( BasicEditorFactory ):

    # The class used to construct editor objects:
    klass = Property

    # The kind of popup to use:
    kind = Enum( 'popover', 'popup', 'info' )

    # The editor to use for the pop-up view (can be None (use default editor),
    # an EditorFactory instance, or a callable that returns an EditorFactory
    # instance):
    editor = Any

    # The style of editor to use for the popup editor (same as Item.style):
    style = EditorStyle

    # The height of the popup (same as Item.height):
    height = Float( -1.0 )

    # The width of the popup (same as Item.width):
    width = Float( -1.0 )

    def _get_klass( self ):
        """ The class used to construct editor objects.
        """
        return toolkit_object('popup_editor:_PopupEditor')

########NEW FILE########
__FILENAME__ = progress_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

""" Defines the progress editor factory for all traits toolkit backends,
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Int, Bool, Str

from ..editor_factory import EditorFactory

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for code editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The title
    title = Str

    # The message to be displayed along side the progress guage
    message = Str

    # The starting value
    min = Int

    # The ending value
    max = Int

    # If the cancel button should be shown
    can_cancel = Bool(False)

    # If the estimated time should be shown
    show_time = Bool(False)

    # if the percent complete should be shown
    show_percent = Bool(False)


# Define the Code Editor class.
ProgressEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = range_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------
""" Defines the range editor factory for all traits user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (CTrait, Property, Range, Enum, Str, Int, Any, Unicode,
        Bool, Undefined)

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..editor_factory import EditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for range editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Number of columns when displayed as an enumeration
    cols = Range( 1, 20 )

    # Is user input set on every keystroke?
    auto_set = Bool(True)

    # Is user input set when the Enter key is pressed?
    enter_set = Bool(False)

    # Label for the low end of the range
    low_label = Unicode

    # Label for the high end of the range
    high_label = Unicode

    # FIXME: This is supported only in the wx backend so far.
    # The width of the low and high labels
    label_width = Int

    # The name of an [object.]trait that defines the low value for the range
    low_name = Str

    # The name of an [object.]trait that defines the high value for the range
    high_name = Str

    # Formatting string used to format value and labels
    format = Unicode( '%s' )

    # Is the range for floating pointer numbers (vs. integers)?
    is_float = Bool( Undefined )

    # Function to evaluate floats/ints when they are assigned to an object trait
    evaluate = Any

    # The object trait containing the function used to evaluate floats/ints
    evaluate_name = Str

    # Low end of range
    low = Property

    # High end of range
    high = Property

    # Display mode to use
    mode = Enum( 'auto', 'slider', 'xslider', 'spinner', 'enum', 'text', 'logslider' )

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ 'low', 'high',
                            '|[Range]' ],
                          [ 'low_label{Low}', 'high_label{High}',
                            '|[Range Labels]' ],
                          [ 'auto_set{Set automatically}',
                            'enter_set{Set on enter key pressed}',
                            'is_float{Is floating point range}',
                            '-[Options]>' ],
                          [ 'cols',
                            '|[Number of columns for integer custom style]<>' ]
                        ] )

    #---------------------------------------------------------------------------
    #  Performs any initialization needed after all constructor traits have
    #  been set:
    #---------------------------------------------------------------------------

    def init ( self, handler = None ):
        """ Performs any initialization needed after all constructor traits
            have been set.
        """
        if handler is not None:
            if isinstance( handler, CTrait ):
                handler = handler.handler

            if self.low_name == '':
                self.low  = handler._low

            if self.high_name == '':
                self.high = handler._high
        else:
            if (self.low is None) and (self.low_name == ''):
                self.low  = 0.0

            if (self.high is None) and (self.high_name == ''):
                self.high = 1.0

    #---------------------------------------------------------------------------
    #  Define the 'low' and 'high' traits:
    #---------------------------------------------------------------------------

    def _get_low ( self ):
        return self._low

    def _set_low ( self, low ):
        old_low         = self._low
        self._low = low = self._cast( low )
        if self.is_float is Undefined:
            self.is_float = isinstance( low, float )

        if (self.low_label == '') or (self.low_label == unicode(old_low)):
            self.low_label = unicode(low)

    def _get_high ( self ):
        return self._high

    def _set_high ( self, high ):
        old_high          = self._high
        self._high = high = self._cast( high )
        if self.is_float is Undefined:
            self.is_float = isinstance( high, float )

        if (self.high_label == '') or (self.high_label == unicode(old_high)):
            self.high_label = unicode(high)

    def _cast ( self, value ):
        if not isinstance( value, basestring ):
            return value

        try:
            return int( value )
        except ValueError:
            return float( value )

    #-- Private Methods --------------------------------------------------------

    def _get_low_high ( self, ui ):
        """ Returns the low and high values used to determine the initial range.
        """
        low, high = self.low, self.high

        if (low is None) and (self.low_name != ''):
            low = self.named_value( self.low_name, ui )
            if self.is_float is Undefined:
                self.is_float = isinstance( low, float )

        if (high is None) and (self.high_name != ''):
            high = self.named_value( self.high_name, ui )
            if self.is_float is Undefined:
                self.is_float = isinstance( high, float )

        if self.is_float is Undefined:
            self.is_float = True

        return ( low, high, self.is_float )

    #---------------------------------------------------------------------------
    #  Property getters.
    #---------------------------------------------------------------------------
    def _get_simple_editor_class( self ):
        """ Returns the editor class to use for a simple style.

        The type of editor depends on the type and extent of the range being
        edited:

        * One end of range is unspecified: RangeTextEditor
        * **mode** is specified and not 'auto': editor corresponding to **mode**
        * Floating point range with extent > 100: LargeRangeSliderEditor
        * Integer range or floating point range with extent <= 100:
          SimpleSliderEditor
        * All other cases: SimpleSpinEditor
        """
        low, high, is_float = self._low_value, self._high_value, self.is_float

        if (low is None) or (high is None):
            return toolkit_object('range_editor:RangeTextEditor')

        if (not is_float) and (abs(high - low) > 1000000000L):
            return toolkit_object('range_editor:RangeTextEditor')

        if self.mode != 'auto':
            return toolkit_object('range_editor:SimpleEditorMap')[ self.mode ]

        if is_float and (abs(high - low) > 100):
            return toolkit_object('range_editor:LargeRangeSliderEditor')

        if is_float or (abs(high - low) <= 100):
            return toolkit_object('range_editor:SimpleSliderEditor')

        return toolkit_object('range_editor:SimpleSpinEditor')

    def _get_custom_editor_class ( self ):
        """ Creates a custom style of range editor

        The type of editor depends on the type and extent of the range being
        edited:

        * One end of range is unspecified: RangeTextEditor
        * **mode** is specified and not 'auto': editor corresponding to **mode**
        * Floating point range: Same as "simple" style
        * Integer range with extent > 15: Same as "simple" style
        * Integer range with extent <= 15: CustomEnumEditor

        """
        low, high, is_float = self._low_value, self._high_value, self.is_float
        if (low is None) or (high is None):
            return toolkit_object('range_editor:RangeTextEditor')

        if self.mode != 'auto':
            return toolkit_object('range_editor:CustomEditorMap')[ self.mode ]

        if is_float or (abs(high - low) > 15):
           return self.simple_editor_class

        return toolkit_object('range_editor:CustomEnumEditor')

    def _get_text_editor_class( self ):
        """Returns the editor class to use for a text style.
        """
        return toolkit_object('range_editor:RangeTextEditor')

    #---------------------------------------------------------------------------
    #  'Editor' factory methods:
    #---------------------------------------------------------------------------

    def simple_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "simple" style.
        Overridden to set the values of the _low_value, _high_value and
        is_float traits.

        """
        self._low_value, self._high_value, self.is_float = self._get_low_high(ui)
        return super(RangeEditor, self).simple_editor(ui, object, name, description, parent)

    def custom_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "custom" style.
        Overridden to set the values of the _low_value, _high_value and
        is_float traits.

        """
        self._low_value, self._high_value, self.is_float = self._get_low_high(ui)
        return super(RangeEditor, self).custom_editor(ui, object, name, description, parent)


# Define the RangeEditor class
RangeEditor = ToolkitEditorFactory

### EOF ---------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = rgb_color_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/22/2004
#
#------------------------------------------------------------------------------

""" Defines a subclass of the base color editor factory, for colors
    that are represented as tuples of the form ( *red*, *green*, *blue* ),
    where *red*, *green* and *blue* are floats in the range from 0.0 to 1.0.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .color_editor import ToolkitEditorFactory as EditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Factory for editors for RGB colors.
    """
    pass

# Define the RGBColorEditor class
# The function will try to return the toolkit-specific editor factory (located
# in traitsui.<toolkit>.rgb_color_editor, and if none is found, the
# ToolkitEditorFactory declared here is returned.
def RGBColorEditor(*args, **traits):
    """ Returns an instance of the toolkit-specific editor factory declared in
    traitsui.<toolkit>.rgb_color_editor. If such an editor factory
    cannot be located, an instance of the abstract ToolkitEditorFactory
    declared in traitsui.editors.rgb_color_editor is returned.

    Parameters
    ----------
    \*args, \*\*traits
        arguments and keywords to be passed on to the editor
        factory's constructor.
    """

    try:
       return toolkit_object('rgb_color_editor:ToolkitEditorFactory', True)(
                                                            *args, **traits)
    except:
       return ToolkitEditorFactory(*args, **traits)

########NEW FILE########
__FILENAME__ = scrubber_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/14/2008
#
#-------------------------------------------------------------------------------

""" Editor factory for scrubber-based integer or float value editors.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Float, Color, Property

from ..ui_traits import Alignment

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# Editor factory for scrubber-based integer or float value editors.
class ScrubberEditor ( BasicEditorFactory ):

    # The editor class to be instantiated:
    klass = Property

    # The low end of the scrubber range:
    low = Float

    # The high end of the scrubber range:
    high = Float

    # The normal increment (default: auto-calculate):
    increment = Float

    # The alignment of the text within the scrubber:
    alignment = Alignment( 'center' )

    # The background color for the scrubber:
    color = Color( None )

    # The hover mode background color for the scrubber:
    hover_color = Color( None )

    # The active mode background color for the scrubber:
    active_color = Color( None )

    # The scrubber border color:
    border_color = Color( None )

    # The color to use for the value text:
    text_color = Color( 'black' )

    def _get_klass(self):
        """ Returns the toolkit-specific editor class to be instantiated.
        """
        return toolkit_object('scrubber_editor:_ScrubberEditor')

### EOF ##################################################################

########NEW FILE########
__FILENAME__ = search_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   06/25/09
#
#-------------------------------------------------------------------------------

""" A single line text widget that supports functionality common to native
    search widgets.
"""

from __future__ import absolute_import

from traits.api import Bool, Property, Str
from ..toolkit import toolkit_object
from ..basic_editor_factory import BasicEditorFactory


class SearchEditor(BasicEditorFactory):
    """ A single line text widget that supports functionality common to native
        search widgets.
    """

    # The editor class to be created:
    klass = Property

    # The descriptive text for the widget
    text = Str("Search")

    # Is user input set on every keystroke?
    auto_set = Bool(True)

    # Is user input set when the Enter key is pressed?
    enter_set = Bool(False)

    # Whether to show a search button on the widget
    search_button = Bool(True)

    # Whether to show a cancel button on the widget
    cancel_button = Bool(False)

    # Fire this event on the object whenever a search should be triggered,
    # regardless of whether the search term changed
    search_event_trait = Str

    def _get_klass(self):
        """ Returns the toolkit-specific editor class to be instantiated.
        """
        return toolkit_object('search_editor:SearchEditor')

########NEW FILE########
__FILENAME__ = set_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------
""" Defines the set editor factory for all traits user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from ..editor_factory import EditorWithListFactory

from traits.api import Bool, Str

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorWithListFactory ):
    """ Editor factory for editors for sets.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Are the items in the set ordered (vs. unordered)?
    ordered = Bool( False )

    # Can the user add and delete all items in the set at once?
    can_move_all = Bool( True )

    # Title of left column:
    left_column_title = Str

    # Title of right column:
    right_column_title = Str

# Define the SetEditor class
SetEditor = ToolkitEditorFactory

### EOF ---------------------------------------------------------------------


########NEW FILE########
__FILENAME__ = shell_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   09/27/2005
#
#-------------------------------------------------------------------------------

""" Editor that displays an interactive Python shell.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Bool, Str, Event, Property

from ..editor import Editor

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object


#-------------------------------------------------------------------------------
#  'ShellEditor' class:
#-------------------------------------------------------------------------------

class _ShellEditor ( Editor ):
    """ Base class for an editor that displays an interactive Python shell.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # An event fired to execute a command in the shell.
    command_to_execute = Event()

    # An event fired whenver the user executes a command in the shell:
    command_executed = Event( Bool )

    # Is the shell editor is scrollable? This value overrides the default.
    scrollable = True

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Moving the import here, since PythonShell is implemented in the
        # Pyface backend packages, and we want to delay loading this toolkit
        # specific class until this editor is actually used.
        from pyface.python_shell import PythonShell

        locals = None
        value  = self.value
        if self.factory.share and isinstance( value, dict ):
            locals = value
        self._shell  = shell = PythonShell( parent, locals = locals )
        self.control = shell.control
        if locals is None:
            object = self.object
            shell.bind( 'self', object )
            shell.on_trait_change( self.update_object, 'command_executed',
                                   dispatch = 'ui' )
            if not isinstance( value, dict ):
                object.on_trait_change( self.update_any, dispatch = 'ui' )
            else:
                self._base_locals = locals = {}
                for name in self._shell.interpreter().locals.keys():
                    locals[ name ] = None

        # Synchronize any editor events:
        self.sync_value( self.factory.command_to_execute,
                         'command_to_execute', 'from' )
        self.sync_value( self.factory.command_executed,
                         'command_executed', 'to' )

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        locals      = self._shell.interpreter().locals
        base_locals = self._base_locals
        if base_locals is None:
            object = self.object
            for name in object.trait_names():
                if name in locals:
                    try:
                        setattr( object, name, locals[ name ] )
                    except:
                        pass
        else:
            dic = self.value
            for name in locals.keys():
                if name not in base_locals:
                    try:
                        dic[ name ] = locals[ name ]
                    except:
                        pass

        self.command_executed = True

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.factory.share:
            value = self.value
            if isinstance( value, dict ):
                self._shell.interpreter().locals = value
        else:
            locals      = self._shell.interpreter().locals
            base_locals = self._base_locals
            if base_locals is None:
                object = self.object
                for name in object.trait_names():
                    locals[ name ] = getattr( object, name, None )
            else:
                dic = self.value
                for name, value in dic.items():
                    locals[ name ] = value

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_any ( self, object, name, old, new ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        locals = self._shell.interpreter().locals
        if self._base_locals is None:
            locals[ name ] = new
        else:
            self.value[ name ] = new

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self._shell.on_trait_change( self.update_object, 'command_executed',
                                     remove = True )
        if self._base_locals is None:
            self.object.on_trait_change( self.update_any, remove = True )

        super( _ShellEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        control = self._shell.control
        try:
            control.history      = prefs.get( 'history', [] )
            control.historyIndex = prefs.get( 'historyIndex', -1 )
        except:
            pass

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        control = self._shell.control
        return { 'history':      control.history,
                 'historyIndex': control.historyIndex }

    #---------------------------------------------------------------------------
    #  Handles the 'command_to_execute' trait being fired:
    #---------------------------------------------------------------------------

    def _command_to_execute_fired ( self, command ):
        """ Handles the 'command_to_execute' trait being fired.
        """
        # Show the command. A 'hidden' command should be executed directly on
        # the namespace trait!
        self._shell.execute_command(command, hidden=False)

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# Editor factory for shell editors.
class ToolkitEditorFactory ( BasicEditorFactory ):

    # The editor class to be instantiated.
    klass = Property

    # Should the shell interpreter use the object value's dictionary?
    share = Bool( False )

    # Extended trait name of the object event trait which triggers a command
    # execution in the shell when fired.
    command_to_execute = Str

    # Extended trait name of the object event trait which is fired when a
    # command is executed.
    command_executed = Str

    def _get_klass(self):
        """ Returns the toolkit-specific editor class to be used in the UI.
        """
        return toolkit_object('shell_editor:_ShellEditor')

# Define the ShellEditor
ShellEditor = ToolkitEditorFactory

### EOF ##################################################################

########NEW FILE########
__FILENAME__ = styled_date_editor

from traits.api import Bool, List, Str
from .date_editor import DateEditor

class CellFormat(object):
    """ Encapsulates some common visual attributes to set on the cells of a
    calendar widget.  All attributes default to None, which means that they
    will not override the existing values of the calendar widget.
    """

    italics = None
    bold = None
    underline = None

    # The color attributes should be strings representing color names,
    # from the list:
    #   red, green, blue, cyan, magenta, yellow, gray, white,
    #   darkRed, darkGreen, darkBlue, darkCyan, darkmagenta, darkYellow, darkGray,
    #   black, lightGray
    #
    # Alternatively, they can be a tuple of (R,G,B) values from 0-255.
    bgcolor = None
    fgcolor = None

    def __init__(self, **args):
        for key,val in args.items():
            setattr(self, key, val)


class ToolkitEditorFactory(DateEditor):
    """ A DateEditor that can show sets of dates in different styles.
    """

    # The name of a dictionary on the object that maps names to groups
    # (list/tuples) of datetime.date objects.  Each of these groups can be
    # styled using the **styles** dict.
    dates_trait = Str()

    # The name of a dictionary on the object that maps names of styles to
    # CellFormat objects.  The names used must match the names used in the
    # **dates** dict.
    styles_trait = Str()

    # Allow selection of arbitrary dates in the past.
    allow_past = Bool(True)

    # Allow selection of arbitrary dates in the future.
    allow_future = Bool(True)

    # A list of strings that will be offered as an alternative to specifying
    # an absolute date, and instead specify a relative date.
    relative_dates = List()

StyledDateEditor = ToolkitEditorFactory

########NEW FILE########
__FILENAME__ = table_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------
""" Defines the table editor factory for all traits user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Int, Float, List, Instance, Str, Color, Font, Any, Tuple,
        Dict, Enum, Trait, Bool, Callable, Range, on_trait_change)

from ..editor_factory import EditorFactory

from ..handler import Handler

from ..helper import Orientation

from ..item import Item

from ..table_filter import TableFilter

from ..ui_traits import AView

from ..view import View

from .enum_editor import EnumEditor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# The filter used to indicate that the user wants to customize the current
# filter
customize_filter = TableFilter( name = 'Customize...' )

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# A trait whose value can be True, False, or a callable function
BoolOrCallable = Trait( False, Bool, Callable )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for table editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # List of initial table column descriptors
    columns = List( Instance('traitsui.table_column.TableColumn') )

    # List of other table column descriptors (not initially displayed)
    other_columns = List(
                     Instance('traitsui.table_column.TableColumn') )

    # The object trait containing the list of column descriptors
    columns_name = Str

    # The desired number of visible rows in the table
    rows = Int

    # The optional extended name of the trait used to specify an external filter
    # for the table data. The value of the trait must either be an instance of
    # TableEditor, a callable that accepts one argument (a table row) and
    # returns True or False to indicate whether the specified object passes the
    # filter or not, or **None** to indicate that no filter is to be applied:
    filter_name = Str

    # Initial filter that should be applied to the table
    filter = Instance( 'traitsui.table_filter.TableFilter' )

    # List of available filters that can be applied to the table
    filters = List( Instance(
                     'traitsui.table_filter.TableFilter' ) )

    # The optional extended trait name of the trait used to notify that the
    # filter has changed and the displayed objects should be updated.
    # It should be an Event.
    update_filter_name = Str

    # Filter object used to allow a user to search the table.
    # NOTE: If left as None, the table will not be searchable.
    search = Instance( 'traitsui.table_filter.TableFilter' )

    # Default context menu to display when any cell is right-clicked
    menu = Instance( 'traitsui.menu.Menu' )

    # Default trait name containg menu
    menu_name = Str

    # Are objects deletable from the table?
    deletable = BoolOrCallable( False )

    # Is the table editable?
    editable = Bool( True )

    # Should the editor become active after the first click
    edit_on_first_click = Bool( True )

    # Can the user reorder the items in the table?
    reorderable = Bool( False )

    # Can the user configure the table columns?
    configurable = Bool( True )

    # Should the cells of the table automatically size to the optimal size?
    auto_size = Bool( True )

    # Mirrors the Qt QSizePolicy.Policy attribute, for horizontal and vertical
    # dimensions.  For these to be useful, set auto_size to False.  If these
    # are None, then the table size policy will not be set in that dimension
    # (for backwards compatibility).
    h_size_policy = Enum( None, "preferred", "fixed", "minimum", "maximum", "expanding",
                        "minimum_expanding", "ignored" )
    v_size_policy = Enum( None, "preferred", "fixed", "minimum", "maximum", "expanding",
                        "minimum_expanding", "ignored" )

    # Should a new row automatically be added to the end of the table to allow
    # the user to create new entries? If True, **row_factory** must be set.
    auto_add = Bool( False )

    # Should the table items be presented in reverse order?
    reverse = Bool( False )

    # The DockWindow graphical theme:
    dock_theme = Any

    # View to use when editing table items.
    # NOTE: If not specified, the table items are not editable in a separate
    # pane of the editor.
    edit_view = AView( ' ' )

    # The handler to apply to **edit_view**
    edit_view_handler = Instance( Handler )

    # Width to use for the edit view
    edit_view_width = Float( -1.0 )

    # Height to use for the edit view
    edit_view_height = Float( -1.0 )

    # Layout orientation of the table and its associated editor pane. This
    # attribute applies only if **edit_view** is not ' '.
    orientation = Orientation

    # Is the table sortable by clicking on the column headers?
    sortable = Bool( True )

    # Does sorting affect the model (vs. just the view)?
    sort_model = Bool( False )

    # Should grid lines be shown on the table?
    show_lines = Bool( True )

    # Should the toolbar be displayed? (Note that False will override settings
    # such as 'configurable', etc., and is a quick way to prevent the toolbar
    # from being displayed; but True will not cause a toolbar to appear if one
    # would not otherwise have been displayed)
    show_toolbar = Bool( False )

    # The vertical scroll increment for the table:
    scroll_dy = Range( 1, 32 )

    # Grid line color
    line_color = Color( 0xC4C0A9 )

    # Show column labels?
    show_column_labels = Bool( True )

    # Show row labels?
    show_row_labels = Bool( False )

    # Font to use for text in cells
    cell_font = Font

    # Color to use for text in cells
    cell_color = Color( 'black' )

    # Color to use for cell backgrounds
    # The default is the "WindowColor" constant declared in ui.api:
    # we shall set the value in a trait initializer method, in order to avoid
    # circular imports.
    cell_bg_color = Color

    # Color to use for read-only cell backgrounds
    cell_read_only_bg_color = Color( 0xF8F7F1 )

    # Whether to even-odd alternate the background color.
    alternate_bg_color = Bool(False)

    # Font to use for text in labels
    label_font = Font

    # Color to use for text in labels
    label_color = Color( 'black' )

    # Color to use for label backgrounds
    # The default is the "WindowColor" constant declared in ui.api:
    # we shall set the value in a trait initializer method, in order to avoid
    # circular imports.
    label_bg_color = Color

    # Background color of selected item
    selection_bg_color = Color( 'light blue', allow_none = True )

    # Color of selected text
    selection_color = Color( 'black' )

    # Height (in pixels) of column labels
    column_label_height = Int( 25 )

    # Width (in pixels) of row labels
    row_label_width = Int( 82 )

    # The initial height of each row (<= 0 means use default value):
    row_height = Int( 0 )

    # The optional extended name of the trait that the indices of the items
    # currently passing the table filter are synced with:
    filtered_indices = Str

    # The selection mode of the table. The meaning of the various values are as
    # follows:
    #
    # row
    #   Entire rows are selected. At most one row can be selected at once.
    #   This is the default.
    # rows
    #   Entire rows are selected. More than one row can be selected at once.
    # column
    #   Entire columns are selected. At most one column can be selected at
    #   once.
    # columns
    #   Entire columns are selected. More than one column can be selected at
    #   once.
    # cell
    #   Single cells are selected. Only one cell can be selected at once.
    # cells
    #   Single cells are selected. More than one cell can be selected at once.
    selection_mode = Enum( 'row', 'rows', 'column', 'columns', 'cell', 'cells' )

    # The optional extended name of the trait that the current selection is
    # synced with:
    selected = Str

    # The optional extended trait name of the trait that the indices of the
    # current selection are synced with:
    selected_indices = Str

    # The optional extended trait name of the trait that should be assigned
    # an ( object, column ) tuple when a table cell is clicked on (Note: If you
    # want to receive repeated clicks on the same cell, make sure the trait is
    # defined as an Event):
    click = Str

    # The optional extended trait name of the trait that should be assigned
    # an ( object, column ) tuple when a table cell is double-clicked on
    # (Note: if you want to receive repeated double-clicks on the same cell,
    # make sure the trait is defined as an Event):
    dclick = Str

    # Called when a table item is selected
    on_select = Any

    # Called when a table item is double clicked
    on_dclick = Any

    # A factory to generate new rows.
    # NOTE: If None, then the user will not be able to add new rows to the
    # table. If not None, then it must be a callable that accepts
    # **row_factory_args** and **row_factory_kw** and returns a new object
    # that can be added to the table.
    row_factory = Any

    # Arguments to pass to the **row_factory** callable when a new row is
    # created
    row_factory_args = Tuple

    # Keyword arguments to pass to the **row_factory** callable when a new row
    # is created
    row_factory_kw = Dict

    # Hooks for replacing parts of the implementation.
    table_view_factory = Callable()
    source_model_factory = Callable()
    model_factory = Callable()

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ '{Initial columns}@',
                          Item( 'columns',       resizable = True ),
                          '{Other columns}@',
                          Item( 'other_columns', resizable = True ),
                          '|{Columns}<>' ],
                        [ [ 'deletable{Are items deletable?}', '9',
                            'editable{Are items editable?}',   '9',
                            '-[Item Options]>' ],
                          [ 'show_column_labels{Show column labels?}',      '9',
                            'configurable{Are columns user configurable?}', '9',
                            'auto_size{Should columns auto size?}',
                            '-[Column Options]>' ],
                          [ 'sortable{Are columns sortable?}',
                            Item( 'sort_model{Does sorting affect the model?}',
                                  enabled_when = 'sortable' ),
                            '-[Sorting Options]>' ],
                          [ [ 'show_lines{Show grid lines?}',
                              '|>' ],
                            [ '_', 'line_color{Grid line color}@',
                              '|<>' ],
                            '|[Grid Line Options]' ],
                          '|{Options}' ],
                        [ [ 'cell_color{Text color}@',
                            'cell_bg_color{Background color}@',
                            'cell_read_only_bg_color{Read only color}@',
                            '|[Cell Colors]' ],
                          [ 'cell_font',
                            '|[Cell Font]<>' ],
                          '|{Cell}' ],
                        [ [ 'label_color{Text color}@',
                            'label_bg_color{Background color}@',
                            '|[Label Colors]' ],
                          [ 'label_font@',
                            '|[Label Font]<>' ],
                          '|{Label}' ],
                        [ [ 'selection_color{Text color}@',
                            'selection_bg_color{Background color}@',
                            '|[Selection Colors]' ],
                          '|{Selection}' ],
                        height = 0.5 )

    #---------------------------------------------------------------------------
    #  'Editor' factory methods:
    #---------------------------------------------------------------------------

    def readonly_editor ( self, ui, object, name, description, parent ):
        """ Generates an "editor" that is read-only.
        Overridden to set the value of the editable trait to False before
        generating the editor.

        """
        self.editable = False
        return super(ToolkitEditorFactory, self).readonly_editor(
                  ui, object, name, description, parent)

    def _cell_bg_color_default(self):
        """ Returns the default value of the cell background color.
        """
        # NOTE: We are initializing the 'cell_bg_color' trait in this method
        # instead of in the trait definition so as to delay importing from
        # ui.api until needed (will lead to circular imports otherwise).
        from ..api import WindowColor
        return WindowColor

    def _label_bg_color_default(self):
        """ Returns the default value of the cell background color.
        """
        # NOTE: We are initializing the 'cell_bg_color' trait in this method
        # instead of in the trait definition so as to delay importing from
        # ui.api until needed (will lead to circular imports otherwise).
        from ..api import WindowColor
        return WindowColor

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    @on_trait_change('filters[]')
    def _update_filter_editor ( self, object, name, old, new ):
        """ Handles the set of filters associated with the editor's factory
            being changed.
        """
        values = { None: '000:No filter' }
        i      = 0
        for filter in self.filters:
            if not filter.template:
                i += 1
                values[ filter ] = '%03d:%s' % ( i, filter.name )
        values[ customize_filter ] = '%03d:%s' % ( (i + 1),
                                                   customize_filter.name )
        if self._filter_editor is None:
            self._filter_editor = EnumEditor( values = values )
        else:
            self._filter_editor.values = values


# Define the TableEditor class
TableEditor = ToolkitEditorFactory

#-------------------------------------------------------------------------------
#  Base class for toolkit-specific editors
#-------------------------------------------------------------------------------

class BaseTableEditor(object):
    """ Base class for toolkit-specific editors.
    """

    #---------------------------------------------------------------------------
    #  Interface for toolkit-specific editors:
    #---------------------------------------------------------------------------

    def set_menu_context ( self, selection, object, column ):
        """Call before creating a context menu for a cell, then set self as the
           controller for the menu.
        """
        self._menu_context = { 'selection': selection,
                               'object':    object,
                               'column':    column,
                               'editor':    self,
                               'info':      self.ui.info,
                               'handler':   self.ui.handler }

    #---------------------------------------------------------------------------
    #  pyface.action 'controller' interface implementation:
    #---------------------------------------------------------------------------

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        action = menu_item.item.action
        self.eval_when( action.enabled_when, menu_item, 'enabled' )
        self.eval_when( action.checked_when, menu_item, 'checked' )

    def add_to_toolbar ( self, toolbar_item ):
        """ Adds a toolbar item to the toolbar being constructed.
        """
        self.add_to_menu( toolbar_item )

    def can_add_to_menu ( self, action ):
        """ Returns whether the action should be defined in the user interface.
        """
        if action.defined_when != '':
            if not eval( action.defined_when, globals(),
                         self._menu_context ):
                return False

        if action.visible_when != '':
            if not eval( action.visible_when, globals(),
                         self._menu_context ):
                return False

        return True

    def can_add_to_toolbar ( self, action ):
        """ Returns whether the toolbar action should be defined in the user
            interface.
        """
        return self.can_add_to_menu( action )

    def perform ( self, action, action_event = None ):
        """ Performs the action described by a specified Action object.
        """
        self.ui.do_undoable( self._perform, action )

    def _perform ( self, action ):
        method_name        = action.action
        info               = self.ui.info
        handler            = self.ui.handler
        context            = self._menu_context
        self._menu_context  = None
        selection          = context[ 'selection' ]

        if method_name.find( '.' ) >= 0:
            if method_name.find( '(' ) < 0:
                method_name += '()'
            try:
                eval( method_name, globals(), context )
            except:
                # fixme: Should the exception be logged somewhere?
                pass
            return

        method = getattr( handler, method_name, None )
        if method is not None:
            method( info, selection )
            return

        if action.on_perform is not None:
            action.on_perform( selection )
            return

        action.perform( selection )

    #---------------------------------------------------------------------------
    #  Menu support methods:
    #---------------------------------------------------------------------------

    def eval_when ( self, condition, object, trait ):
        """ Evaluates a condition within a defined context and sets a specified
        object trait based on the result, which is assumed to be a Boolean.
        """
        if condition != '':
            value = bool( eval( condition, globals(), self._menu_context ) )
            setattr( object, trait, value )

#-------------------------------------------------------------------------------
#  Helper class for toolkit-specific editors to implement 'reversed' option:
#-------------------------------------------------------------------------------

class ReversedList ( object ):
    """ A list whose order is the reverse of its input.
    """

    def __init__ ( self, list ):
        self.list = list

    def insert ( self, index, value ):
        """ Inserts a value at a specified index in the list.
        """
        return self.list.insert( self._index( index - 1 ), value )

    def index ( self, value ):
        """ Returns the index of the first occurrence of the specified value in
            the list.
        """
        list = self.list[:]
        list.reverse()

        return list.index( value )

    def __len__ ( self ):
        """ Returns the length of the list.
        """
        return len( self.list )

    def __getitem__ ( self, index ):
        """ Returns the value at a specified index in the list.
        """
        return self.list[ self._index( index ) ]

    def __setslice__ ( self, i, j, values ):
        """ Sets a slice of a list to the contents of a specified sequence.
        """
        return self.list.__setslice__( self._index( i ), self._index( j ),
                                       values )

    def __delitem__ ( self, index ):
        """ Deletes the item at a specified index.
        """
        return self.list.__delitem__( self._index( index ) )

    def _index ( self, index ):
        """ Returns the "reversed" value for a specified index.
        """
        if index < 0:
            return (-1 - index)

        result = (len( self.list ) - index - 1)
        if result >= 0:
            return result

        return index

########NEW FILE########
__FILENAME__ = tabular_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   05/20/2007
#
#-------------------------------------------------------------------------------

""" A traits UI editor for editing tabular data (arrays, list of tuples, lists
    of objects, etc).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Str, Bool, Property, List, Enum, Instance

from ..ui_traits import Image

from ..basic_editor_factory import BasicEditorFactory

from ..toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'TabularEditor' editor factory class:
#-------------------------------------------------------------------------------

class TabularEditor ( BasicEditorFactory ):
    """ Editor factory for tabular editors.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The editor class to be created:
    klass = Property

    # Should column headers (i.e. titles) be displayed?
    show_titles = Bool( True )

    # Should row headers be displated (Qt4 only)?
    show_row_titles = Bool( False )

    # The optional extended name of the trait used to indicate that a complete
    # table update is needed:
    update = Str

    # The optional extended name of the trait used to indicate that the table
    # just needs to be repainted.
    refresh = Str

    # Should the table update automatically when the table item's contents
    # change? Note that in order for this feature to work correctly, the editor
    # trait should be a list of objects derived from HasTraits. Also,
    # performance can be affected when very long lists are used, since enabling
    # this feature adds and removed Traits listeners to each item in the list.
    auto_update = Bool( False )

    # The optional extended name of the trait to synchronize the selection
    # values with:
    selected = Str

    # The optional extended name of the trait to synchronize the selection rows
    # with:
    selected_row = Str

    # Whether or not to allow selection.
    selectable = Bool( True )

    # The optional extended name of the trait to synchronize the activated value
    # with:
    activated = Str

    # The optional extended name of the trait to synchronize the activated
    # value's row with:
    activated_row = Str

    # The optional extended name of the trait to synchronize left click data
    # with. The data is a TabularEditorEvent:
    clicked = Str

    # The optional extended name of the trait to synchronize left double click
    # data with. The data is a TabularEditorEvent:
    dclicked = Str

    # The optional extended name of the trait to synchronize right click data
    # with. The data is a TabularEditorEvent:
    right_clicked = Str

    # The optional extended name of the trait to synchronize right double
    # clicked data with. The data is a TabularEditorEvent:
    right_dclicked = Str

    # The optional extended name of the trait to synchronize column
    # clicked data with. The data is a TabularEditorEvent:
    column_clicked = Str

    # The optional extended name of the trait to synchronize column
    # right clicked data with. The data is a TabularEditorEvent:
    column_right_clicked = Str

    # The optional extended name of the Event trait that should be used to
    # trigger a scroll-to command. The data is an integer giving the row.
    scroll_to_row = Str

    # Controls behavior of scroll to row
    scroll_to_row_hint = Enum("center", "top", "bottom", "visible")

    # Can the user edit the values?
    editable = Bool( True )

    # Can the user edit the labels (i.e. the first column)
    editable_labels = Bool( False )

    # Are multiple selected items allowed?
    multi_select = Bool( False )

    # Should horizontal lines be drawn between items?
    horizontal_lines = Bool( True )

    # Should vertical lines be drawn between items?
    vertical_lines = Bool( True )

    # Should the columns automatically resize? Don't allow this when the amount
    # of data is large.
    auto_resize = Bool( False )

    # Should the rows automatically resize (Qt4 only)? Don't allow
    # this when the amount of data is large.
    auto_resize_rows = Bool( False )

    # Whether to stretch the last column to fit the available space.
    stretch_last_section = Bool( True )

    # The adapter from trait values to editor values:
    adapter = Instance( 'traitsui.tabular_adapter.TabularAdapter', () )

    # What type of operations are allowed on the list:
    operations = List( Enum( 'delete', 'insert', 'append', 'edit', 'move' ),
                       [ 'delete', 'insert', 'append', 'edit', 'move' ] )

    # Are 'drag_move' operations allowed (i.e. True), or should they always be
    # treated as 'drag_copy' operations (i.e. False):
    drag_move = Bool( False )

    # The set of images that can be used:
    images = List( Image )

    def _get_klass(self):
        """ Returns the toolkit-specific editor class to be instantiated.
        """
        return toolkit_object('tabular_editor:TabularEditor')

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = text_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the text editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Dict, Str, Any, Bool

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..group import Group

from ..ui_traits import AView

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  Define a simple identity mapping:
#-------------------------------------------------------------------------------

class _Identity ( object ):
    """ A simple identity mapping.
    """
    def __call__ ( self, value ):
        return value

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Mapping from user input text to other value
mapping_trait = Dict( Str, Any )

# Function used to evaluate textual user input
evaluate_trait = Any( _Identity() )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for text editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Dictionary that maps user input to other values
    mapping = mapping_trait

    # Is user input set on every keystroke?
    auto_set = Bool( True )

    # Is user input set when the Enter key is pressed?
    enter_set = Bool( False )

    # Is multi-line text allowed?
    multi_line = Bool( True )

    # Is editor readonly (will use custom / default editor appearance with readonly flag set to true)
    # in contrasrt with readonly style for item when completely another edito is used
    read_only = Bool( False )

    # Is user input unreadable? (e.g., for a password)
    password = Bool( False )

    # Function to evaluate textual user input
    evaluate = evaluate_trait

    # The object trait containing the function used to evaluate user input
    evaluate_name = Str

    # The optional view to display when a read-only text editor is clicked:
    view = AView

    # In a read-only text editor, allow selection and copying of the text.
    readonly_allow_selection = Bool(False)

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( [ 'auto_set{Set value when text is typed}',
                          'enter_set{Set value when enter is pressed}',
                          'multi_line{Allow multiple lines of text}',
                          '<extras>',
                          '|options:[Options]>' ] )

    extras = Group( 'password{Is this a password field?}' )

# Define the TextEditor class.
TextEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = time_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Judah De Paula
#  Date:   10/7/2008
#
#------------------------------------------------------------------------------

""" A Traits UI editor that wraps a WX timer control.
"""

from __future__ import absolute_import

from traits.api import Str
from ..editor_factory import EditorFactory
from ..ui_traits import AView


class TimeEditor(EditorFactory):
    """ Editor factory for time editors.  Generates _TimeEditor()s.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #-- ReadonlyEditor traits --------------------------------------------------

    # Message to show when Time is None.
    message = Str('Undefined')

    # The string representation of the time to show.  Uses time.strftime format.
    strftime = Str('%I:%M:%S %p')

    # An optional view to display when a read-only text editor is clicked:
    view = AView

########NEW FILE########
__FILENAME__ = title_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------

""" Defines the title editor factory for all traits toolkit backends.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Bool
from ..editor_factory import EditorFactory
from ..toolkit import toolkit_object

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for Title editors.
    """

    allow_selection = Bool(False)

    def _get_simple_editor_class(self):
        """ Returns the editor class to use for "simple" style views.
        The default implementation tries to import the SimpleEditor class in the
        editor file in the backend package, and if such a class is not to found
        it returns the SimpleEditor class defined in editor_factory module in
        the backend package.

        """
        SimpleEditor = toolkit_object('title_editor:SimpleEditor')
        return SimpleEditor


#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------
TitleEditor = ToolkitEditorFactory

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = tree_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------
""" Defines the tree editor factory for all traits user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Any, Dict, Bool, Tuple, Int, List, Instance, Str, Enum

from ..tree_node import TreeNode

from ..dock_window_theme import DockWindowTheme

from ..editor_factory import EditorFactory

from ..helper import Orientation

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Size of each tree node icon
IconSize = Tuple( ( 16, 16 ), Int, Int )

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for tree editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Supported TreeNode objects
    nodes = List( TreeNode )

    # Mapping from TreeNode tuples to MultiTreeNodes
    multi_nodes = Dict

    # The column header labels if any.
    column_headers = List(Str)

    # Are the individual nodes editable?
    editable = Bool(True)

    # Selection mode.
    selection_mode = Enum('single', 'extended')

    # Is the editor shared across trees?
    shared_editor = Bool(False)

    # Reference to a shared object editor
    editor = Instance( EditorFactory )

    # The DockWindow graphical theme
    # FIXME: Implemented only in wx backend.
    dock_theme = Instance( DockWindowTheme )

    # Show icons for tree nodes?
    show_icons = Bool(True)

    # Hide the tree root node?
    hide_root = Bool(False)

    # Layout orientation of the tree and the editor
    orientation = Orientation

    # Number of tree levels (down from the root) that should be automatically
    # opened
    auto_open = Int

    # Size of the tree node icons
    # FIXME: Document as unimplemented or wx specific.
    icon_size = IconSize

    # Called when a node is selected
    on_select = Any

    # Called when a node is clicked
    on_click = Any

    # Called when a node is double-clicked
    on_dclick = Any

    # Called when a node is activated
    on_activated = Any

    # Call when the mouse hovers over a node
    on_hover = Any

    # The optional extended trait name of the trait to synchronize with the
    # editor's current selection:
    selected = Str

    # The optional extended trait name of the trait that should be assigned
    # a node object when a tree node is activated, by double-clicking or
    # pressing the Enter key when a node has focus (Note: if you want to
    # receive repeated activated events on the same node, make sure the trait
    # is defined as an Event):
    activated = Str

    # The optional extended trait name of the trait that should be assigned
    # a node object when a tree node is clicked on (Note: If you want to
    # receive repeated clicks on the same node, make sure the trait is defined
    # as an Event):
    click = Str

    # The optional extended trait name of the trait that should be assigned
    # a node object when a tree node is double-clicked on (Note: if you want to
    # receive repeated double-clicks on the same node, make sure the trait is
    # defined as an Event):
    dclick = Str

    # The optional extended trait name of the trait event that is fired
    # whenever the application wishes to veto a tree action in progress (e.g.
    # double-clicking a non-leaf tree node normally opens or closes the node,
    # but if you are handling the double-click event in your program, you may
    # wish to veto the open or close operation). Be sure to fire the veto event
    # in the event handler triggered by the operation (e.g. the 'dclick' event
    # handler.
    veto = Str

    # The optional extended trait name of the trait event that is fired when the
    # application wishes the currently visible portion of the tree widget to
    # repaint itself.
    refresh = Str

    # Mode for lines connecting tree nodes
    #
    # * 'appearance': Show lines only when they look good.
    # * 'on': Always show lines.
    # * 'off': Don't show lines.
    lines_mode = Enum ( 'appearance', 'on', 'off' )
    # FIXME: Document as unimplemented or wx specific.
    # Whether to alternate row colors or not.
    alternating_row_colors = Bool(False)

    # Any extra vertical padding to add.
    vertical_padding = Int(0)

    # Whether or not to expand on a double-click.
    expands_on_dclick = Bool(True)


    # Whether the labels should be wrapped around, if not an ellipsis is shown
    # This works only in the qt backend and if there is only one column in tree
    word_wrap = Bool(False)

# Define the TreeEditor class.
TreeEditor = ToolkitEditorFactory

### EOF #######################################################################



########NEW FILE########
__FILENAME__ = tuple_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------
""" Defines the tuple editor factory for all traits user interface toolkits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.trait_base import SequenceTypes, enumerate

from traits.api import Bool, HasTraits, List, Tuple, Unicode, Int, Any, TraitType

# CIRCULAR IMPORT FIXME: Importing from the source rather than traits.ui.api
# to avoid circular imports, as this EditorFactory will be part of
# traits.ui.api as well.
from ..view import View

from ..group import Group

from ..item import Item

from ..editor_factory import EditorFactory

from ..editor import Editor

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for tuple editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Trait definitions for each tuple field
    types = Any

    # Labels for each of the tuple fields
    labels = List( Unicode )

    # Editors for each of the tuple fields:
    editors = List( EditorFactory )

    # Number of tuple fields or rows
    cols   = Int( 1 )

    # Is user input set on every keystroke? This is applied to every field
    # of the tuple, provided the field does not already have an 'auto_set'
    # metadata or an editor defined.
    auto_set = Bool( True )

    # Is user input set when the Enter key is pressed? This is applied to
    # every field of the tuple, provided the field does not already have an
    # 'enter_set' metadata or an editor defined.
    enter_set = Bool( False )

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for tuples.

    The editor displays an editor for each of the fields in the tuple, based on
    the type of each field.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._ts     = ts = TupleStructure( self )
        self._ui     = ui = ts.view.ui( ts, parent, kind = 'subpanel' ).set(
                                        parent = self.ui )
        self.control = ui.control
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        ts = self._ts
        for i, value in enumerate( self.value ):
            setattr( ts, 'f%d' % i, value )

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._ui.get_error_controls()

#-------------------------------------------------------------------------------
#  'TupleStructure' class:
#-------------------------------------------------------------------------------

class TupleStructure ( HasTraits ):
    """ Creates a view containing items for each field in a tuple.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Editor this structure is linked to
    editor = Any

    # The constructed View for the tuple
    view = Any

    # Number of tuple fields
    fields = Int

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, editor ):
        """ Initializes the object.
        """
        factory = editor.factory
        types   = factory.types
        labels  = factory.labels
        editors = factory.editors
        cols    = factory.cols

        # Save the reference to the editor:
        self.editor = editor

        # Get the tuple we are mirroring:
        object = editor.value

        # For each tuple field, add a trait with the appropriate trait
        # definition and default value:
        content     = []
        self.fields = len( object )
        len_labels  = len( labels )
        len_editors = len( editors )

        if types is None:
            type = editor.value_trait.handler
            if isinstance( type, Tuple ):
                types = type.types

        if not isinstance( types, SequenceTypes ):
            types = [ types ]

        len_types = len( types )
        if len_types == 0:
            types     = [ Any ]
            len_types = 1

        for i, value in enumerate( object ):
            type = types[ i % len_types ]

            auto_set = enter_set = None
            if isinstance(type, TraitType):
                auto_set = type.auto_set
                enter_set = type.enter_set
            if auto_set is None:
                auto_set = editor.factory.auto_set
            if enter_set is None:
                enter_set = editor.factory.enter_set

            label = ''
            if i < len_labels:
                label = labels[i]

            field_editor = None
            if i < len_editors:
                field_editor = editors[i]

            name = 'f%d' % i
            self.add_trait( name, type( value, event = 'field',
                                               auto_set = auto_set,
                                               enter_set = enter_set ) )
            item = Item( name = name, label = label, editor = field_editor )
            if cols <= 1:
                content.append( item )
            else:
                if (i % cols) == 0:
                    group = Group( orientation = 'horizontal' )
                    content.append( group )

                group.content.append( item )

        self.view = View( Group( show_labels = (len_labels != 0), *content ) )

    #---------------------------------------------------------------------------
    #  Updates the underlying tuple when any field changes value:
    #---------------------------------------------------------------------------

    def _field_changed ( self ):
        """ Updates the underlying tuple when any field changes value.
        """
        self.editor.value = tuple( [ getattr( self, 'f%d' % i )
                                     for i in range( self.fields ) ] )


# Define the TupleEditor class.
TupleEditor = ToolkitEditorFactory

### EOF #######################################################################




########NEW FILE########
__FILENAME__ = value_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/05/2006
#
#------------------------------------------------------------------------------

""" Defines the tree-based Python value editor and the value editor factory.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Instance, Int, false

from .tree_editor import TreeEditor
from ..view import View
from ..item import Item

from ..value_tree import RootNode, value_tree_nodes

from ..editor_factory import EditorFactory

from ..editor import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class _ValueEditor ( Editor ):
    """ Simple style of editor for values, which displays a tree.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the editor read only?
    readonly = false

    # The root node of the value tree
    root = Instance( RootNode )

    # Is the value editor scrollable? This values overrides the default.
    scrollable = True

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.update_editor()
        editor = TreeEditor(
            auto_open = self.factory.auto_open,
            hide_root = True,
            editable  = False,
            nodes     = value_tree_nodes
        )
        self._ui = self.edit_traits( parent = parent, view =
                       View(
                           Item( 'root',
                                 show_label = False,
                                 editor     = editor
                           ),
                           kind = 'subpanel'
                       )
                   )
        self._ui.parent = self.ui
        self.control    = self._ui.control

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        self.root = RootNode( name     = '',
                              value    = self.value,
                              readonly = self.readonly )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self._ui.dispose()

        super( _ValueEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._ui.get_error_controls()

#-------------------------------------------------------------------------------
#  'ToolkitEditorFactory' class:
#-------------------------------------------------------------------------------

class ToolkitEditorFactory ( EditorFactory ):
    """ Editor factory for tree-based value editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Number of tree levels to automatically open
    auto_open = Int( 2 )

# Define the ValueEditor class.
ValueEditor = ToolkitEditorFactory

#--EOF-------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = editors_gen
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in /LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#
# Author: Vibha Srinivasan <vibha@enthought.com>
#------------------------------------------------------------------------------

""" Generates a file containing definitions for editors defined in the various
backends.
"""

from __future__ import absolute_import

import glob

def gen_editor_definitions(target_filename = 'editors.py'):
    """ Generates a file containing definitions for editors defined in the
       various backends.

    The idea is that if a new editor has been declared in any of the backends,
    the author needs to create a file called '<myeditor>_definition' in the
    Traits package (in traitsui). This function will be run each time
    the user runs the setup.py file, and the new editor's definition will be
    appended to the editors.py file.

    The structure of the <myeditor>_definition file should be as follows::

        myeditor_definition = '<file name in the backend package>:
                         <name of the Editor or the EditorFactory class'
    """

    definition_files = glob.glob('*_definition.py')
    new_editors = []
    for file in definition_files:
           import_path = file.rstrip('.py')
           mod = __import__(import_path, globals=globals(), level=1)
           for name in dir(mod):
               if '_definition' in name:
                   new_editors.append(getattr(mod, name))
    target_file = open(target_filename, 'a')
    for editor_name in new_editors:
            function = "\ndef %s( *args, **traits ):\n" % editor_name.split(':')[1]
            target_file.write(function)
            func_code =  ' '*4 + 'from toolkit import toolkit_object\n'
            func_code += ' '*4 + \
                         'return toolkit_object("%s")( *args, **traits )' \
                         % editor_name
            target_file.write(func_code)
            target_file.write('\n\n')
    target_file.close()

########NEW FILE########
__FILENAME__ = editor_factory
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the abstract EditorFactory class, which represents a factory for
    creating the Editor objects used in a Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import sys, os

from traits.api import HasPrivateTraits, Callable, Str, Bool, Event, Any, Property

from .helper import enum_values_changed

from .toolkit import toolkit_object

#-------------------------------------------------------------------------------
#  'EditorFactory' abstract base class:
#-------------------------------------------------------------------------------

class EditorFactory ( HasPrivateTraits ):
    """ Represents a factory for creating the Editor objects in a Traits-based
        user interface.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function to use for string formatting
    format_func = Callable

    # Format string to use for formatting (used if **format_func** is not set).
    format_str = Str

    # Is the editor being used to create table grid cells?
    is_grid_cell = Bool( False )

    # Are created editors initially enabled?
    enabled = Bool( True )

    # The extended trait name of the trait containing editor invalid state
    # status:
    invalid = Str

    # Text aligment to use in most readonly editors
    # Possible values: left, right, top, bottom, just, vcenter, hcenter, center
    # Example: left,vcenter
    text_alignment = Str

    # The editor class to use for 'simple' style views.
    simple_editor_class = Property

    # The editor class to use for 'custom' style views.
    custom_editor_class = Property

    # The editor class to use for 'text' style views.
    text_editor_class   = Property

    # The editor class to use for 'readonly' style views.
    readonly_editor_class = Property

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, *args, **traits ):
        """ Initializes the factory object.
        """
        HasPrivateTraits.__init__( self, **traits )
        self.init( *args )

    #---------------------------------------------------------------------------
    #  Performs any initialization needed after all constructor traits have
    #  been set:
    #---------------------------------------------------------------------------

    def init ( self ):
        """ Performs any initialization needed after all constructor traits
            have been set.
        """
        pass

    #---------------------------------------------------------------------------
    #  Returns the value of a specified extended name of the form: name or
    #  context_object_name.name[.name...]:
    #---------------------------------------------------------------------------

    def named_value ( self, name, ui ):
        """ Returns the value of a specified extended name of the form: name or
            context_object_name.name[.name...]:
        """
        names = name.split( '.' )

        if len( names ) == 1:
            # fixme: This will produce incorrect values if the actual Item the
            # factory is being used with does not use the default object='name'
            # value, and the specified 'name' does not contain a '.'. The
            # solution will probably involve providing the Item as an argument,
            # but it is currently not available at the time this method needs to
            # be called...
            names.insert( 0, 'object' )

        value = ui.context[ names[0] ]
        for name in names[1:]:
            value = getattr( value, name )

        return value
    #---------------------------------------------------------------------------
    #  Methods that generate backend toolkit-specific editors.
    #---------------------------------------------------------------------------

    def simple_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "simple" style.
        """
        return self.simple_editor_class( parent,
                                         factory     = self,
                                         ui          = ui,
                                         object      = object,
                                         name        = name,
                                         description = description )

    def custom_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "custom" style.
        """
        return self.custom_editor_class( parent,
                                         factory     = self,
                                         ui          = ui,
                                         object      = object,
                                         name        = name,
                                         description = description )

    def text_editor ( self, ui, object, name, description, parent ):
        """ Generates an editor using the "text" style.
        """
        return self.text_editor_class( parent,
                                       factory     = self,
                                       ui          = ui,
                                       object      = object,
                                       name        = name,
                                       description = description )

    def readonly_editor ( self, ui, object, name, description, parent ):
        """ Generates an "editor" that is read-only.
        """
        return self.readonly_editor_class( parent,
                                           factory     = self,
                                           ui          = ui,
                                           object      = object,
                                           name        = name,
                                           description = description )

    #---------------------------------------------------------------------------
    #  Private methods
    #---------------------------------------------------------------------------
    @classmethod
    def _get_toolkit_editor(cls, class_name):
        """
        Returns the editor by name class_name in the backend package.
        """
        editor_factory_classes = [factory_class for factory_class in cls.mro()
                                  if issubclass(factory_class, EditorFactory)]
        for index in range(len( editor_factory_classes )):
            try:
                factory_class = editor_factory_classes[index]
                editor_file_name = os.path.basename(
                                sys.modules[factory_class.__module__].__file__)
                return toolkit_object(':'.join([editor_file_name.split('.')[0],
                                             class_name]), True)
            except Exception, e:
                if index == len(editor_factory_classes)-1:
                    raise e
        return None

    #---------------------------------------------------------------------------
    #  Property getters
    #---------------------------------------------------------------------------

    def _get_simple_editor_class(self):
        """ Returns the editor class to use for "simple" style views.
        The default implementation tries to import the SimpleEditor class in the
        editor file in the backend package, and if such a class is not to found
        it returns the SimpleEditor class defined in editor_factory module in
        the backend package.

        """
        try:
            SimpleEditor = self._get_toolkit_editor('SimpleEditor')
        except:
            SimpleEditor = toolkit_object('editor_factory:SimpleEditor')
        return SimpleEditor


    def _get_custom_editor_class(self):
        """ Returns the editor class to use for "custom" style views.
        The default implementation tries to import the CustomEditor class in the
        editor file in the backend package, and if such a class is not to found
        it returns simple_editor_class.

        """
        try:
            CustomEditor = self._get_toolkit_editor('CustomEditor')
        except:
            CustomEditor = self.simple_editor_class
        return CustomEditor


    def _get_text_editor_class(self):
        """ Returns the editor class to use for "text" style views.
        The default implementation tries to import the TextEditor class in the
        editor file in the backend package, and if such a class is not found
        it returns the TextEditor class declared in the editor_factory module in
        the backend package.

        """
        try:
            TextEditor = self._get_toolkit_editor('TextEditor')
        except:
            TextEditor = toolkit_object('editor_factory:TextEditor')
        return TextEditor


    def _get_readonly_editor_class(self):
        """ Returns the editor class to use for "readonly" style views.
        The default implementation tries to import the ReadonlyEditor class in
        the editor file in the backend package, and if such a class is not found
        it returns the ReadonlyEditor class declared in the editor_factory
        module in the backend package.

        """
        try:
            ReadonlyEditor = self._get_toolkit_editor('ReadonlyEditor')
        except:
            ReadonlyEditor = toolkit_object('editor_factory:ReadonlyEditor')
        return ReadonlyEditor


#-------------------------------------------------------------------------------
#  'EditorWithListFactory' abstract base class:
#-------------------------------------------------------------------------------

class EditorWithListFactory ( EditorFactory ):
    """ Base class for factories of editors for objects that contain lists.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Values to enumerate (can be a list, tuple, dict, or a CTrait or
    # TraitHandler that is "mapped"):
    values = Any

    # Extended name of the trait on **object** containing the enumeration data:
    object = Str( 'object' )

    # Name of the trait on 'object' containing the enumeration data
    name = Str

    # Fired when the **values** trait has been updated:
    values_modified = Event

    #---------------------------------------------------------------------------
    #  Recomputes the mappings whenever the 'values' trait is changed:
    #---------------------------------------------------------------------------

    def _values_changed ( self ):
        """ Recomputes the mappings whenever the **values** trait is changed.
        """
        self._names, self._mapping, self._inverse_mapping = \
            enum_values_changed( self.values )

        self.values_modified = True

## EOF ########################################################################

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Written by: Jason Sugg
#  Date:   03/28/2006
#
#------------------------------------------------------------------------------

""" Defines 'pseudo' package that imports all of the traits extras symbols.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .checkbox_column import CheckboxColumn
from .saving import CanSaveMixin, SaveHandler

########NEW FILE########
__FILENAME__ = checkbox_column
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Jason Sugg
#  Date:   03/28/2006
#
#------------------------------------------------------------------------------

""" Defines the table column descriptor used for toggleable columns.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.etsconfig.api import ETSConfig

from ..table_column import ObjectColumn

if ETSConfig.toolkit == 'wx':
    from pyface.ui.wx.grid.checkbox_renderer import CheckboxRenderer
elif ETSConfig.toolkit == 'qt4':
    from ..qt4.extra.checkbox_renderer import CheckboxRenderer
else:
    raise NotImplementedError, "No checkbox renderer for backend"

#-------------------------------------------------------------------------------
#  'CheckboxColumn' class:
#-------------------------------------------------------------------------------

class CheckboxColumn ( ObjectColumn ):

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        """ Initializes the object.
        """
        super( CheckboxColumn, self ).__init__( **traits )

        # force the renderer to be a checkbox renderer
        self.renderer = CheckboxRenderer()

    #---------------------------------------------------------------------------
    #  Returns the cell background color for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_cell_color ( self, object ):
        """ Returns the cell background color for the column for a specified
            object.
        """

        # Override the parent class to ALWAYS provide the standard color:
        return self.cell_color_

    #---------------------------------------------------------------------------
    #  Returns whether the column is editable for a specified object:
    #---------------------------------------------------------------------------

    def is_editable ( self, object ):
        """ Returns whether the column is editable for a specified object.
        """

        # Although a checkbox column is always editable, we return this
        # to keep a standard editor from appearing. The editing is handled
        # in the renderer's handlers.
        return False


########NEW FILE########
__FILENAME__ = demo
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   09/15/2005
#
#-------------------------------------------------------------------------------

""" A Traits UI demo that borrows heavily from the design of the wxPython demo.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import sys
import glob
import token
import tokenize
from StringIO import StringIO
from configobj import ConfigObj

from traits.api import (HasTraits, HasPrivateTraits, Str, Instance, Property,
                        Any, Code, HTML, true, false, Dict)

from traitsui.api import (TreeEditor, ObjectTreeNode, TreeNodeObject, View,
                          Item, VSplit, Tabbed, VGroup, HGroup, Heading,
                          Handler, UIInfo, InstanceEditor, HTMLEditor, Include,
                          spring)

from os import listdir

from os.path import (join, isdir, split, splitext, dirname, basename, abspath,
                     exists, isabs)

#-------------------------------------------------------------------------------
#  Global data:
#-------------------------------------------------------------------------------

# Define the code used to populate the 'execfile' dictionary:
exec_str =  """from traits.api import *

"""

#----------------------------------------------------------------------------
#  Return a 'user-friendly' name for a specified string:
#----------------------------------------------------------------------------

def user_name_for ( name ):
    name = name.replace( '_', ' ' )
    return name[:1].upper() + name[1:]

#-------------------------------------------------------------------------------
#  Parses the contents of a specified source file into module comment and
#  source text:
#-------------------------------------------------------------------------------

def extract_docstring_from_source(source):
    """Return module docstring and source code from python source code.

    Returns
    -------
    docstring : str
        The first module-level string; i.e. the module docstring.
    source : str
        The source code, sans docstring.
    """
    # Reset file and generate python tokens
    f = StringIO(source)
    python_tokens = tokenize.generate_tokens(f.readline)

    for ttype, tstring, tstart, tend, tline in python_tokens:
        token_name = token.tok_name[ttype]
        if token_name == 'STRING' and tstart[1] == 0:
            break
    else:
        # No docstrings found. Return blank docstring and all the source.
        return '', source.strip()

    source_lines = source.splitlines()

    # Extract module docstring lines and recombine
    docstring = eval('\n'.join(source_lines[tstart[0] - 1:tend[0]]))
    source_lines = source_lines[:tstart[0] - 1] + source_lines[tend[0]:]
    source = '\n'.join(source_lines)
    source = source.strip()

    return docstring, source


def parse_source(file_name):
    """Return module docstring and source code from python source file.

    Returns
    -------
    docstring : str
        The first module-level string; i.e. the module docstring.
    source : str
        The source code, sans docstring.
    """
    try:
        fh = open(file_name, 'rb')
        source_code = fh.read()
        return extract_docstring_from_source(source_code)
    except:
        return ( '', '' )


#-------------------------------------------------------------------------------
#  'DemoFileHandler' class:
#-------------------------------------------------------------------------------

class DemoFileHandler ( Handler ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The current 'info' object (for use by the 'write' method):
    info = Instance( UIInfo )

    #---------------------------------------------------------------------------
    #  Initializes the view:
    #---------------------------------------------------------------------------

    def init ( self, info ):
        # Save the reference to the current 'info' object:
        self.info = info

        # Set up the 'print' logger:
        df         = info.object
        df.log     = ''
        sys.stdout = sys.stderr = self

        # Read in the demo source file:
        df.description, df.source = parse_source( df.path )
        # Try to run the demo source file:

        # Append the path for the demo source file to sys.path, so as to
        # resolve any local (relative) imports in the demo source file.
        sys.path.append(dirname(df.path))

        locals = df.parent.init_dic
        locals[ '__name__' ] = '___main___'
        locals['__file__'] = df.path
        sys.modules[ '__main__' ].__file__ = df.path
        try:
            execfile( df.path, locals, locals )
            demo = self._get_object( 'modal_popup', locals )
            if demo is not None:
                demo = ModalDemoButton( demo = demo )
            else:
                demo = self._get_object( 'popup', locals )
                if demo is not None:
                    demo = DemoButton( demo = demo )
                else:
                    demo = self._get_object( 'demo', locals )
            # FIXME: If a 'demo' object could not be found, then try to execute
            # the file setting __name__ to __main__. A lot of test scripts have
            # the actual test running when __name__==__main__ and so we can at
            # least run all test examples this way. Use a do_later loop so as to
            # finish building the current UI before running the test.
            if demo is None:
                locals['__name__'] = '__main__'
                #do_later(self.execute_test, df, locals)
        except Exception, excp:
            demo = DemoError( msg = str( excp ) )

        # Clean up sys.path
        sys.path.remove(dirname(df.path))
        df.demo = demo

    def execute_test(self, df, locals):
        """ Executes the file in df.path in the namespace of locals."""
        execfile(df.path, locals, locals)

    #---------------------------------------------------------------------------
    #  Closes the view:
    #---------------------------------------------------------------------------

    def closed ( self, info, is_ok ):
        """ Closes the view.
        """
        info.object.demo = None

    #---------------------------------------------------------------------------
    #  Get a specified object from the execution dictionary:
    #---------------------------------------------------------------------------

    def _get_object ( self, name, dic ):
        object = dic.get( name ) or dic.get( name.capitalize() )
        if object is not None:
            if isinstance( type( object ), type ):
                try:
                    object = object()
                except:
                    pass

            if isinstance( object, HasTraits ):
                return object

        return None

    #---------------------------------------------------------------------------
    #  Handles 'print' output:
    #---------------------------------------------------------------------------

    def write ( self, text ):
        self.info.object.log += text

    def flush ( self ):
        pass

# Create a singleton instance:
demo_file_handler = DemoFileHandler()

#-------------------------------------------------------------------------------
#  'DemoError' class:
#-------------------------------------------------------------------------------

class DemoError ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The error message text:
    msg = Code

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View(
        VGroup(
            Heading( 'Error in source file' ),
            Item( 'msg', style = 'custom', show_label = False ),
        )
    )

#-------------------------------------------------------------------------------
#  'DemoButton' class:
#-------------------------------------------------------------------------------

class DemoButton ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The demo to be launched via a button:
    demo = Instance( HasTraits )

    # The demo view item to use:
    demo_item = Item( 'demo',
        show_label = False,
        editor     = InstanceEditor( label = 'Run demo...', kind = 'live' )
    )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View(
        VGroup(
            VGroup(
                Heading( 'Click the button to run the demo:' ),
                '20'
            ),
            HGroup(
                spring,
                Include( 'demo_item' ),
                spring
            )
        ),
        resizable = True
    )

#-------------------------------------------------------------------------------
#  'ModalDemoButton' class:
#-------------------------------------------------------------------------------

class ModalDemoButton ( DemoButton ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The demo view item to use:
    demo_item = Item( 'demo',
        show_label = False,
        editor     = InstanceEditor( label = 'Run demo...', kind = 'modal' )
    )

#-------------------------------------------------------------------------------
#  'DemoTreeNodeObject' class:
#-------------------------------------------------------------------------------

class DemoTreeNodeObject ( TreeNodeObject ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Cached result of 'tno_has_children':
    _has_children = Any

    # Cached result of 'tno_get_children':
    _get_children = Any

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def tno_allows_children ( self, node ):
        """ Returns whether chidren of this object are allowed or not.
        """
        return self.allows_children

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node = None ):
        """ Returns whether or not the object has children.
        """
        if self._has_children is None:
            self._has_children = self.has_children()

        return self._has_children

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        if self._get_children is None:
            self._get_children = self.get_children()

        return self._get_children

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def has_children ( self, node ):
        """ Returns whether or not the object has children.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def get_children ( self, node ):
        """ Gets the object's children.
        """
        raise NotImplementedError

#-------------------------------------------------------------------------------
#  'DemoFile' class:
#-------------------------------------------------------------------------------

class DemoFile ( DemoTreeNodeObject ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Parent of this file:
    parent = Any

    # Name of file system path to this file:
    path = Property

    # Name of the file:
    name = Str

    # UI form of the 'name':
    nice_name = Property

    # Files don't allow children:
    allows_children = false

    # Description of what the demo does:
    description = HTML

    # Source code for the demo:
    source = Code

    # Demo object whose traits UI is to be displayed:
    demo = Instance( HasTraits )

    # Log of all print messages displayed:
    log = Code

    _nice_name = Str
    #---------------------------------------------------------------------------
    #  Implementation of the 'path' property:
    #---------------------------------------------------------------------------

    def _get_path ( self ):
        return join( self.parent.path, self.name + '.py' )

    #---------------------------------------------------------------------------
    #  Implementation of the 'nice_name' property:
    #---------------------------------------------------------------------------

    def _get_nice_name ( self ):
        if not self._nice_name:
            self._nice_name = user_name_for( self.name )
        return self._nice_name

    def _set_nice_name(self, value):
        old = self.nice_name
        self._nice_name = value
        self.trait_property_changed('nice_name', old, value)

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def has_children ( self ):
        """ Returns whether or not the object has children.
        """
        return False

#-------------------------------------------------------------------------------
#  'DemoPath' class:
#-------------------------------------------------------------------------------

class DemoPath ( DemoTreeNodeObject ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Parent of this package:
    parent = Any

    # Name of file system path to this package:
    path = Property

    # Name of the directory:
    name = Str

    # UI form of the 'name':
    nice_name = Property

    # Description of the contents of the directory:
    description = Property( HTML )

    # Source code contained in the '__init__.py' file:
    source = Property( Code )

    # Dictionary containing symbols defined by the path's '__init__.py' file:
    init_dic = Property

    # Should .py files be included?
    use_files = true

    # Paths do allow children:
    allows_children = true

    # Configuration dictionary for this node
    # This trait is set when a config file exists for the parent of this path.
    config_dict = Dict

    # Configuration file for this node.
    config_filename = Str

    # Cached value of the nice_name property.
    _nice_name = Str

    #---------------------------------------------------------------------------
    #  Implementation of the 'path' property:
    #---------------------------------------------------------------------------

    def _get_path ( self ):
        return join( self.parent.path, self.name )

    #---------------------------------------------------------------------------
    #  Implementation of the 'nice_name' property:
    #---------------------------------------------------------------------------

    def _get_nice_name ( self ):
        if not self._nice_name:
            self._nice_name = user_name_for( self.name )
        return self._nice_name

    #---------------------------------------------------------------------------
    #  Setter for the 'nice_name' property:
    #---------------------------------------------------------------------------

    def _set_nice_name(self, value):
        old = self.nice_name
        self._nice_name = value
        self.trait_property_changed('nice_name', old, value)

    #---------------------------------------------------------------------------
    #  Implementation of the 'description' property:
    #---------------------------------------------------------------------------

    def _get_description ( self ):
        if self._description is None:
            self._get_init()

        return self._description

    #---------------------------------------------------------------------------
    #  Implementation of the 'source' property:
    #---------------------------------------------------------------------------

    def _get_source ( self ):
        if self._source is None:
            self._get_init()

        return self._source

    #---------------------------------------------------------------------------
    #  Implementation of the 'init_dic' property:
    #---------------------------------------------------------------------------

    def _get_init_dic ( self ):
        init_dic = {}
        description, source = parse_source( join( self.path, '__init__.py' ) )
        exec (exec_str + source) in init_dic
        return init_dic

        # fixme: The following code should work, but doesn't, so we use the
        #        preceding code instead. Changing any trait in the object in
        #        this method causes the tree to behave as if the DemoPath object
        #        had been selected instead of a DemoFile object. May be due to
        #        an 'anytrait' listener in the TreeEditor?
        #if self._init_dic is None:
        #   self._init_dic = {}
        #   #exec self.source in self._init_dic
        #return self._init_dic.copy()

    #---------------------------------------------------------------------------
    #  Initializes the description and source from the path's '__init__.py'
    #  file:
    #---------------------------------------------------------------------------

    def _get_init ( self ):
        if self.use_files:
            # Read in the '__init__.py' source file (if any):
            self._description, source = parse_source(
                                              join( self.path, '__init__.py' ) )
        else:
            self._description = ('<img src="traits_ui_demo.jpg">')
            source = ''

        self._source = exec_str + source

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def has_children ( self ):
        """ Returns whether or not the object has children.
        """
        path = self.path
        for name in listdir( path ):
            cur_path = join( path, name )
            if isdir( cur_path ):
                return True

            if self.use_files:
                name, ext = splitext( name )
                if (ext == '.py') and (name != '__init__'):
                    return True

        return False

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def get_children ( self ):
        """ Gets the object's children.
        """
        if self.config_dict or self.config_filename:
            children = self.get_children_from_config()
        else:
            children = self.get_children_from_datastructure()
        return children

    #---------------------------------------------------------------------------
    #  Gets the object's children based on the filesystem structure.
    #---------------------------------------------------------------------------
    def get_children_from_datastructure( self ):
        """ Gets the object's children based on the filesystem structure.
        """

        dirs  = []
        files = []
        path  = self.path
        for name in listdir( path ):
            cur_path = join( path, name )
            if isdir( cur_path ):
                if self.has_py_files( cur_path ):
                    dirs.append( DemoPath( parent = self, name = name ) )

            elif self.use_files:
                name, ext = splitext( name )
                if (ext == '.py') and (name != '__init__'):
                    files.append( DemoFile( parent = self, name = name ) )

        dirs.sort(  lambda l, r: cmp( l.name, r.name ) )
        files.sort( lambda l, r: cmp( l.name, r.name ) )

        return (dirs + files)

    #---------------------------------------------------------------------------
    # Gets the object's children as specified in its configuration file or
    # dictionary.
    #---------------------------------------------------------------------------

    def get_children_from_config( self ):
        """
        Gets the object's children as specified in its configuration file or
        dictionary.
        """

        if not self.config_dict:
            if exists(self.config_filename):
                try:
                    self.config_dict = ConfigObj(self.config_filename)
                except:
                    pass
        if not self.config_dict:
            return self.get_children_from_datastructure()

        dirs = []
        files = []
        for keyword, value in self.config_dict.items():
            if not value.get('no_demo'):
                sourcedir = value.pop('sourcedir', None)
                if sourcedir is not None:
                    # This is a demo directory.
                    demoobj = DemoPath( parent = self, name = sourcedir )
                    demoobj.nice_name = keyword
                    demoobj.config_dict = value
                    dirs.append(demoobj)
                else:
                    names = []
                    filenames = value.pop('files', [])
                    if not isinstance(filenames, list):
                        filenames = [filenames]
                    for filename in filenames:
                        filename = join(self.path, filename)
                        for name in glob.iglob(filename):
                            pathname, ext = splitext(name)
                            if (ext == '.py') and \
                                (basename(pathname) != '__init__'):
                                names.append(pathname)
                    if len(names) > 1:
                        config_dict = {}
                        for name in names:
                            config_dict[basename(name)] = {'files':
                                                           name + '.py'}
                        demoobj = DemoPath( parent = self, name = '')
                        demoobj.nice_name = keyword
                        demoobj.config_dict = config_dict
                        dirs.append(demoobj)
                    elif len(names) == 1:
                        file = DemoFile(parent=self, name=names[0])
                        file.nice_name = keyword
                        files.append(file)

        dirs.sort( lambda l, r: cmp( l.nice_name, r.nice_name ) )
        files.sort( lambda l, r: cmp( l.nice_name, r.nice_name ) )

        return (dirs + files)

    #---------------------------------------------------------------------------
    #  Returns whether the specified path contains any .py files:
    #---------------------------------------------------------------------------

    def has_py_files ( self, path ):
        for name in listdir( path ):
            cur_path = join( path, name )
            if isdir( cur_path ):
                if self.has_py_files( cur_path ):
                    return True

            else:
                name, ext = splitext( name )
                if ext == '.py':
                    return True

        return False

#-------------------------------------------------------------------------------
#  Defines the demo tree editor:
#-------------------------------------------------------------------------------

path_view = View(
    Tabbed(
        Item( 'description',
              label      = 'Description',
              show_label = False,
              style      = 'readonly',
              editor=HTMLEditor(format_text=True)
        ),
        Item( 'source',
              label      = 'Source',
              show_label = False,
              style      = 'custom'
        ),
        export = 'DockWindowShell',
        id     = 'tabbed'
    ),
    id      = 'traitsui.demos.demo.path_view',
    #dock    = 'horizontal'
)

demo_view = View(
     #VSplit(
         Tabbed(
             Item( 'description',
                   label      = 'Description',
                   show_label = False,
                   style      = 'readonly',
                   editor=HTMLEditor(format_text=True)
             ),
             Item( 'source',
                   label      = 'Source',
                   show_label = False,
                   style      = 'custom'
             ),
             Item( 'demo',
                   label      = 'Demo',
                   show_label = False,
                   style      = 'custom',
                   resizable  = True,
                   # FIXME:
                   # visible_when doesn't work correctly yet (for wx atleast)
                   # for tabbed items. Needs more investigation.
                   visible_when = 'demo',
             ),
             Item( 'log',
                   show_label = False,
                   style      = 'readonly'
             ),
             export = 'DockWindowShell',
             id     = 'tabbed',
         ),
         # JDM moving log panel provisionally to its own tab, distracting here.
         #VGroup(
             #Item( 'log',
                   #show_label = False,
                   #style      = 'readonly'
             #),
             #label = 'Log'
         #),
         #export = 'DockWindowShell',
         #id     = 'vsplit'
     #),
     id      = 'traitsui.demos.demo.file_view',
     #dock    = 'horizontal',
     handler = demo_file_handler
)

demo_tree_editor = TreeEditor(
    nodes = [
        ObjectTreeNode( node_for = [ DemoPath ],
                        label    = 'nice_name',
                        view     = path_view ),
        ObjectTreeNode( node_for = [ DemoFile ],
                        label    = 'nice_name',
                        view     = demo_view )
    ]
)

#-------------------------------------------------------------------------------
#  'Demo' class:
#-------------------------------------------------------------------------------

class Demo ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Path to the root demo directory:
    path = Str

    # Root path object for locating demo files:
    root = Instance( DemoPath )

    # Title for the demo
    title = Str

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------


    def default_traits_view(self):
        """ Constructs the default traits view."""

        traits_view = View(
            Item( name       = 'root',
                  id         = 'root',
                  show_label = False,
                  editor     = demo_tree_editor
            ),
            title     = self.title,
            id        = 'traitsui.demos.demo.Demo',
            #dock      = 'horizontal',
            resizable = True,
            # JDM: Seems that QT interface does not deal well with these size
            # limits.
            # With them, we get repeated:
            #   Object::disconnect: Parentheses expected, signal AdvancedCodeWidget::lostFocus
            # But without them, it throws an exception on exit:
            #    Internal C++ object (_StickyDialog) already deleted.
            # No, actually sometimes we get the latter even with them.
            width     = 950,
            height    = 900
        )
        return traits_view

    #---------------------------------------------------------------------------
    #  Handles the 'root' trait being changed:
    #---------------------------------------------------------------------------

    def _root_changed ( self, root ):
        """ Handles the 'root' trait being changed.
        """
        root.parent = self

#-------------------------------------------------------------------------------
#  Function to run the demo:
#-------------------------------------------------------------------------------

def demo ( use_files=False, dir_name = None, config_filename = '',
           title = 'Traits UI Demos' ):
    if dir_name is None:
        dir_name = dirname(abspath( sys.argv[0] ))
    path, name = split( dir_name )
    if len(config_filename) > 0 and not isabs(config_filename):
        config_filename = join(path, name, config_filename)
    Demo( path = path,
          title = title,
          root = DemoPath( name = name,
                           use_files = use_files,
                           config_filename = config_filename )
    ).configure_traits()


########NEW FILE########
__FILENAME__ = edit_column
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Bryce Hendrix
#  Date:   09/13/2007
#
#------------------------------------------------------------------------------

""" Defines the table column descriptor used for editing the object represented
    by the row
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.etsconfig.api import ETSConfig
from ..table_column import ObjectColumn

if ETSConfig.toolkit == 'wx':
    from pyface.ui.wx.grid.edit_renderer import EditRenderer
else:
    raise NotImplementedError, "No EditColumn implementation for backend"

#-------------------------------------------------------------------------------
#  'EditColumn' class:
#-------------------------------------------------------------------------------

class EditColumn ( ObjectColumn ):

    def __init__ ( self, **traits ):
        """ Initializes the object.
        """
        super( EditColumn, self ).__init__( **traits )

        # force the renderer to be a edit renderer
        self.renderer = EditRenderer()

        self.label = ''

    def get_cell_color ( self, object ):
        """ Returns the cell background color for the column for a specified
            object.
        """

        # Override the parent class to ALWAYS provide the standard color:
        return self.cell_color_

    def is_editable ( self, object ):
        """ Returns whether the column is editable for a specified object.
        """
        return False


########NEW FILE########
__FILENAME__ = saving
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   06/18/2009
#
#------------------------------------------------------------------------------

""" Provides a lightweight framework that removes some of the drudge work
    involved with implementing user-friendly saving behavior in a Traits
    UI application.
"""

from __future__ import absolute_import

# ETS imports
from pyface.api import FileDialog, confirm, error, YES, CANCEL
from pyface.timer.api import Timer
from traits.api import HasTraits, Str, Bool, Any, Int, Instance, on_trait_change
from ..api import Handler


class CanSaveMixin(HasTraits):
    """ A mixin-class for objects that wish to support GUI saving via a
        SaveHandler. It is the responsiblity of the child class to manage
        its dirty flag, which describes whether its information has changed
        since its last save.
    """

    filepath = Str
    dirty = Bool(False)

    #-----------------------------------------------------------------
    #  object interface
    #-----------------------------------------------------------------

    def __getstate__(self):
        """ We don't want to pickle the filepath because this can change,
            obviously, if the user moves around the pickled file.
        """
        state = super(CanSaveMixin, self).__getstate__()
        del state['filepath']
        del state['dirty']
        return state

    #-----------------------------------------------------------------
    #  CanSaveMixin interface
    #-----------------------------------------------------------------

    def validate(self):
        """ Returns whether the information in the object is valid to be saved
            in tuple form. The first item is the validation state (boolean) and
            the second item is the message to display if the object did not
            validate.

            By default, an object always validates.
        """
        return (True, '')

    def save(self):
        """ Saves the object to the path specified by its 'filepath' trait. This
            method should also reset the dirty flag on this object.
        """
        raise NotImplementedError


class SaveHandler(Handler):
    """ A Handler that facilates adding saving to a Traits UI application.
    """

    # The object which is to be saved (subclass of CanSaveMixin). It is assigned
    # to info.object in the 'init' method, which in many cases is what you want.
    # If not, override that method to set it to something else.
    saveObject = Any

    # The type of files to show in the save dialogs
    wildcard = Str('All files (*.*)|*.*')

    # The option extension which should appear at the end of all filenames. If
    # the user does not explicitly specifiy it, it is appended to the filename.
    extension = Str

    # This message to display when the Handler requests a save
    savePromptMessage = Str('Would you like to save?')

    # Whether to prompt for a save on exit if the save object is dirty
    promptOnExit = Bool(True)

    # Whether to allow the user to override a validation failure through a
    # confirmation dialog. By default, validation errors cannot be overriden.
    allowValidationBypass = Bool(False)

    # Whether to automatically save after a certain amount of time has passed
    # since the last save
    autosave = Bool(False)

    # Number of seconds between each autosave. Default is 5 minutes.
    autosaveInterval = Int(300)

    # If it is possible to override validation failures, this specifies whether
    # autosave will do so. If False and a validation errors occurs, no save
    # will occur.
    autosaveValidationBypass = Bool(True)

    # Protected traits
    _timer = Instance(Timer)

    #-----------------------------------------------------------------
    #  Handler interface
    #-----------------------------------------------------------------

    def init(self, info):
        """ Set the default save object (the object being handled). Also,
            perform a questionable hack by which we remove the handled
            object from the keybinding's controllers. This means that a
            keybinding to 'save' only calls this object, not the object
            being edited as well. (For reasons unclear, the KeyBinding handler
            API is radically different from the Action API, which is the reason
            that this problem exists. Keybindings are a UI concept--they should
            *not* call the model by default.)
        """
        keybindings = info.ui.key_bindings
        if keybindings is not None:
            keybindings.controllers.remove(info.object)

        self.saveObject = info.object
        return True

    def close(self, info, is_ok):
        """ Called when the user requests to close the interface. Returns a
            boolean indicating whether the window should be allowed to close.
        """
        if self.promptOnExit:
            return self.promptForSave(info)
        else:
            return True

    def closed(self, info, is_ok):
        """ Called after the window is destroyed. Makes sure that the autosave
            timer is stopped.
        """
        if self._timer:
            self._timer.Stop()

    #-----------------------------------------------------------------
    #  SaveHandler interface
    #-----------------------------------------------------------------

    def exit(self, info):
        """ Closes the UI unless a save prompt is cancelled. Provided for
            convenience to be used with a Menu action.
        """
        if self.close(info, True):
            info.ui.dispose()

    def save(self, info):
        """ Saves the object to its current filepath. If this is not specified,
            opens a dialog to select this path. Returns whether the save
            actually occurred.
        """
        if self.saveObject.filepath == '':
            return self.saveAs(info)
        else:
            return self._validateAndSave()

    def saveAs(self, info):
        """ Saves the object to a new path, and sets this as the 'filepath' on
            the object. Returns whether the save actually occurred.
        """
        fileDialog = FileDialog(action='save as', title='Save As',
                                wildcard=self.wildcard,
                                parent=info.ui.control)
        fileDialog.open()
        if fileDialog.path == '' or fileDialog.return_code == CANCEL:
            return False
        else:
            extLen = len(self.extension)
            if extLen and fileDialog.path[-extLen-1:] != '.' + self.extension:
                fileDialog.path += '.' + self.extension
            self.saveObject.filepath = fileDialog.path
            return self._validateAndSave()

    def promptForSave(self, info, cancel=True):
        """ Prompts the user to save the object, if appropriate. Returns whether
            the user canceled the action that invoked this prompt.
        """
        if self.saveObject.dirty:
            code = confirm(info.ui.control, self.savePromptMessage,
                           title="Save now?", cancel=cancel)
            if code == CANCEL:
                return False
            elif code == YES:
                if not self.save(info):
                    return self.promptForSave(info, cancel)
        return True

    def _autosave(self):
        """ Called by the timer when an autosave should take place.
        """
        if self.saveObject.dirty and self.saveObject.filepath != '':
            success, message = self.saveObject.validate()
            if success or (self.allowValidationBypass and
                           self.autosaveValidationBypass):
                self.saveObject.save()

    @on_trait_change('autosave, autosaveInterval, saveObject')
    def _configure_timer(self):
        """ Creates, replaces, or destroys the autosave timer.
        """
        if self._timer:
            self._timer.Stop()
        if self.autosave and self.saveObject:
            self._timer = Timer(self.autosaveInterval * 1000, self._autosave)
        else:
            self._timer = None

    def _validateAndSave(self):
        """ Try to save to the current filepath. Returns whether whether the
            validation was successful/overridden (and the object saved).
        """
        success, message = self.saveObject.validate()
        if success:
            self.saveObject.save()
        else:
            title = "Validation error"
            if (self.allowValidationBypass and
                confirm(None, message, title=title) == YES):
                self.saveObject.save()
                success = True
            else:
                error(None, message, title=title)
        return success

########NEW FILE########
__FILENAME__ = test_demo
import unittest

from traitsui.extras.demo import extract_docstring_from_source


class TestParseSource(unittest.TestCase):

    def test_simple_source(self):
        source_code = '\n'.join(['"""',
                                 'Docstring',
                                 '"""',
                                 'a = 1'])
        docstring, source = extract_docstring_from_source(source_code)
        self.assertEqual(docstring, '\nDocstring\n')
        self.assertEqual(source, 'a = 1')

    def test_alternate_quotes(self):
        source_code = '\n'.join(["'''",
                                 'Docstring',
                                 "'''",
                                 'a = 1'])
        docstring, source = extract_docstring_from_source(source_code)
        self.assertEqual(docstring, '\nDocstring\n')
        self.assertEqual(source, 'a = 1')

    def test_string_in_source(self):
        source_code = '\n'.join(['"""',
                                 'Docstring',
                                 '"""',
                                 '"string in source"',
                                 'a = 1'])
        docstring, source = extract_docstring_from_source(source_code)
        self.assertEqual(docstring, '\nDocstring\n')
        self.assertEqual(source, '\n'.join(['"string in source"',
                                            'a = 1']))

    def test_string_in_docstring(self):
        source_code = '\n'.join(['"""',
                                 'Docstring',
                                 '"string in docstring"',
                                 '"""',
                                 'a = 1'])
        docstring, source = extract_docstring_from_source(source_code)
        self.assertEqual(docstring, '\n'.join(['',
                                               'Docstring',
                                               '"string in docstring"',
                                               '']))
        self.assertEqual(source, '\n'.join(['a = 1']))

    def test_ignore_class_docstring(self):
        source_code = '\n'.join(['class Foo:',
                                 '    """Class docstring"""'])
        docstring, source = extract_docstring_from_source(source_code)
        self.assertEqual(docstring, '')
        self.assertEqual(source, '\n'.join(['class Foo:',
                                            '    """Class docstring"""']))

    def test_ignore_starting_comment(self):
        source_code = '\n'.join(['# Copyright notice.',
                                 '# Something about the author.',
                                 '"""',
                                 'Docstring',
                                 '"""',
                                 'a = 1'])
        docstring, source = extract_docstring_from_source(source_code)
        self.assertEqual(docstring, '\nDocstring\n')
        self.assertEqual(source, '\n'.join(['# Copyright notice.',
                                            '# Something about the author.',
                                            'a = 1']))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = file_dialog
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines functions and classes used to create pop-up file dialogs for
    opening and saving files.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from os import R_OK, W_OK, access, mkdir

from os.path import (basename, dirname, exists, getatime, getctime, getmtime,
    getsize, isdir, isfile, join, split, splitext)

from time import localtime, strftime

from traits.api import (Bool, Button, CList, Event, File, HasPrivateTraits,
    Instance, Int, Interface, Property, Str, cached_property, provides)

from traits.trait_base import user_name_for

from .api import (CodeEditor, FileEditor, HGroup, HSplit, Handler, HistoryEditor,
    ImageEditor, InstanceEditor, Item, UIInfo, VGroup, VSplit, View, spring)

from .ui_traits import AView

from pyface.api import ImageResource

from pyface.timer.api import do_later

from .helper import commatize

from .toolkit import toolkit

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Maximum text file size to process:
MAX_SIZE = 16 * 1024 * 1024

#-------------------------------------------------------------------------------
#  'IFileDialogModel' interface:
#-------------------------------------------------------------------------------

class IFileDialogModel ( Interface ):
    """ Defines a model extension to a file dialog.
    """

    # The name of the currently selected file:
    file_name = File

#-------------------------------------------------------------------------------
#  'IFileDialogView' interface:
#-------------------------------------------------------------------------------

class IFileDialogView ( Interface ):
    """ Defines a visual extension to a file dialog.
    """

    # The view to display:
    view = AView

    # Is the view fixed or variable width?
    is_fixed = Bool

#-------------------------------------------------------------------------------
#  'IFileDialogExtension' interface:
#-------------------------------------------------------------------------------

class IFileDialogExtension ( IFileDialogModel, IFileDialogView ):
    """ Defines a (convenience) union of the IFileDialogModel and
        IFileDialogView interfaces.
    """

#-------------------------------------------------------------------------------
#  'MFileDialogModel' mix-in class:
#-------------------------------------------------------------------------------

@provides(IFileDialogModel)
class MFileDialogModel ( HasPrivateTraits ):

    # The name of the currently selected file:
    file_name = File

#-------------------------------------------------------------------------------
#  'MFileDialogView' mix-in class:
#-------------------------------------------------------------------------------

class MFileDialogView ( HasPrivateTraits ):
    """ Defines a visual extension to a file dialog.
    """

    # The view to display:
    view = AView

    # Is the view fixed or variable width?
    is_fixed = Bool( False )

# Create a default implementation:
default_view = MFileDialogView()

#-------------------------------------------------------------------------------
#  'MFileDialogExtension' mix-in class:
#-------------------------------------------------------------------------------

class MFileDialogExtension ( MFileDialogModel, MFileDialogView ):
    """ Defines a (convenience) union of the MFileDialogModel and
        MFileDialogView mix-in classes.
    """

#-------------------------------------------------------------------------------
#  'FileInfo' class:
#-------------------------------------------------------------------------------

class FileInfo ( MFileDialogModel ):
    """ Defines a file dialog extension that display various file information.
    """

    # The size of the file:
    size = Property( depends_on = 'file_name' )

    # Last file access time:
    atime = Property( depends_on = 'file_name' )

    # List file modification time:
    mtime = Property( depends_on = 'file_name' )

    # File creation time (or last metadata change time):
    ctime = Property( depends_on = 'file_name' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            Item( 'size',  label = 'File size',     style = 'readonly' ),
            Item( 'atime', label = 'Last access',   style = 'readonly' ),
            Item( 'mtime', label = 'Last modified', style = 'readonly' ),
            Item( 'ctime', label = 'Created at',    style = 'readonly' ),
            label       = 'File Information',
            show_border = True
        )
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_size ( self ):
        try:
            return commatize( getsize( self.file_name ) ) + ' bytes'
        except:
            return ''

    @cached_property
    def _get_atime ( self ):
        try:
            return strftime( '%m/%d/%Y %I:%M:%S %p',
                             localtime( getatime( self.file_name ) ) )
        except:
            return ''

    @cached_property
    def _get_mtime ( self ):
        try:
            return strftime( '%m/%d/%Y %I:%M:%S %p',
                             localtime( getmtime( self.file_name ) ) )
        except:
            return ''

    @cached_property
    def _get_ctime ( self ):
        try:
            return strftime( '%m/%d/%Y %I:%M:%S %p',
                             localtime( getctime( self.file_name ) ) )
        except:
            return ''

#-------------------------------------------------------------------------------
#  'TextInfo' class:
#-------------------------------------------------------------------------------

class TextInfo ( MFileDialogModel ):
    """ Defines a file dialog extension that displays a file's contents as text.
    """

    # The file's text content:
    text = Property( depends_on = 'file_name' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        Item( 'text',
              style      = 'readonly',
              show_label = False,
              editor     = CodeEditor()
        )
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_text ( self ):
        try:
            if getsize( self.file_name ) > MAX_SIZE:
                return 'File too big...'

            fh   = file( self.file_name, 'rb' )
            data = fh.read()
            fh.close()
        except:
            return ''

        if (data.find( '\x00' ) >= 0) or (data.find( '\xFF' ) >= 0):
            return 'File contains binary data...'

        return data

#-------------------------------------------------------------------------------
#  'ImageInfo' class:
#-------------------------------------------------------------------------------

class ImageInfo ( MFileDialogModel ):
    """ Defines a file dialog extension that display an image file's dimensions
        and content.
    """

    # The ImageResource object for the current file:
    image = Property( depends_on = 'file_name' )

    # The width of the current image:
    width = Property( depends_on = 'image' )

    # The height of the current image:
    height = Property( depends_on = 'image' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            VGroup(
                Item( 'width',  style = 'readonly' ),
                Item( 'height', style = 'readonly' ),
                label       = 'Image Dimensions',
                show_border = True
            ),
            VGroup(
                Item( 'image',
                      show_label = False,
                      editor     = ImageEditor()
                ),
                label       = 'Image',
                show_border = True,
                springy     = True
            )
        )
    )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_image ( self ):
        path, name = split( self.file_name )
        if splitext( name )[1] in ( '.png', '.gif', '.jpg', '.jpeg' ):
            image = ImageResource( name, search_path = [ path ] )
        else:
            image = ImageResource( 'unknown' )
        self._cur_image = image.create_image()
        return image

    @cached_property
    def _get_width ( self ):
        try:
            return str( toolkit().image_size( self._cur_image )[0] ) + ' pixels'
        except:
            return '---'

    @cached_property
    def _get_height ( self ):
        try:
            return str( toolkit().image_size( self._cur_image )[1] ) + ' pixels'
        except:
            return '---'

#-------------------------------------------------------------------------------
#  'CreateDirHandler' class:
#-------------------------------------------------------------------------------

class CreateDirHandler ( Handler ):
    """ Controller for the 'create new directory' popup.
    """

    # The name for the new directory to be created:
    dir_name = Str

    # The current status message:
    message = Str

    # The OK and Cancel buttons:
    ok     = Button( 'OK' )
    cancel = Button( 'Cancel' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            HGroup(
                 Item( 'handler.dir_name',
                       label = 'Name'
                 ),
                 Item( 'handler.ok',
                       show_label   = False,
                       enabled_when = "handler.dir_name.strip() != ''"
                 ),
                 Item( 'handler.cancel',
                       show_label = False
                 ),
            ),
            HGroup(
                Item( 'handler.message',
                      show_label = False,
                      style      = 'readonly',
                      springy    = True
                ),
                show_border = True
            )
        ),
        kind = 'popup'
    )

    #-- Handler Event Handlers -------------------------------------------------

    def handler_ok_changed ( self, info ):
        """ Handles the user clicking the OK button.
        """
        dir = info.object.file_name
        if not isdir( dir ):
            dir = dirname( dir )

        path = join( dir, self.dir_name )
        try:
            # Try to create the requested directory:
            mkdir( path )

            # Force the file tree view to be refreshed:
            info.object.reload    = True

            # set the new directory as the currently selected file name:
            info.object.file_name = path

            # Close this view:
            info.ui.dispose( True )
        except:
            self.message = "Could not create the '%s' directory" % self.dir_name

    def handler_cancel_changed ( self, info ):
        """ Handles the user clicking the Cancel button.
        """
        info.ui.dispose( False )

#-------------------------------------------------------------------------------
#  'FileExistsHandler' class:
#-------------------------------------------------------------------------------

class FileExistsHandler ( Handler ):
    """ Controller for the 'file already exists' popup.
    """
    # The current status message:
    message = Str

    # The OK and Cancel buttons:
    ok     = Button( 'OK' )
    cancel = Button( 'Cancel' )

    #-- Traits View Definitions ------------------------------------------------

    view = View(
        VGroup(
            HGroup(
                 Item( 'handler.message',
                       editor = ImageEditor( image = '@icons:dialog-warning' )
                 ),
                 Item( 'handler.message', style = 'readonly' ),
                 show_labels = False
            ),
            HGroup(
                 spring,
                 Item( 'handler.ok' ),
                 Item( 'handler.cancel' ),
                 show_labels = False
            )
        ),
        kind = 'popup'
    )

    #-- Handler Event Handlers -------------------------------------------------

    def handler_ok_changed ( self, info ):
        """ Handles the user clicking the OK button.
        """
        parent = info.ui.parent
        info.ui.dispose( True )
        parent.dispose( True )

    def handler_cancel_changed ( self, info ):
        """ Handles the user clicking the Cancel button.
        """
        info.ui.dispose( False )

#-------------------------------------------------------------------------------
#  'OpenFileDialog' class:
#-------------------------------------------------------------------------------

class OpenFileDialog ( Handler ):
    """ Defines the model and handler for the open file dialog.
    """

    # The starting and current file path:
    file_name = File

    # The list of file filters to apply:
    filter = CList( Str )

    # Number of history entries to allow:
    entries = Int( 10 )

    # The file dialog title:
    title = Str( 'Open File' )

    # The Traits UI persistence id to use:
    id = Str( 'traitsui.file_dialog.OpenFileDialog' )

    # A list of optional file dialog extensions:
    extensions = CList( IFileDialogModel )

    #-- Private Traits ---------------------------------------------------------

    # The UIInfo object for the view:
    info = Instance( UIInfo )

    # Event fired when the file tree view should be reloaded:
    reload = Event

    # Event fired when the user double-clicks on a file name:
    dclick = Event

    # Allow extension models to be added dynamically:
    extension__ = Instance( IFileDialogModel )

    # Is the file dialog for saving a file (or opening a file)?
    is_save_file = Bool( False )

    # Is the currently specified file name valid?
    is_valid_file = Property( depends_on = 'file_name' )

    # Can a directory be created now?
    can_create_dir = Property( depends_on = 'file_name' )

    # The OK, Cancel and create directory buttons:
    ok      = Button( 'OK' )
    cancel  = Button( 'Cancel' )
    create  = Button( image = '@icons:folder-new',
                      style = 'toolbar' )

    #-- Handler Class Method Overrides -----------------------------------------

    def init_info ( self, info ):
        """ Handles the UIInfo object being initialized during view start-up.
        """
        self.info = info

    #-- Property Implementations -----------------------------------------------

    def _get_is_valid_file ( self ):
        if self.is_save_file:
            return (isfile( self.file_name ) or (not exists( self.file_name )))

        return isfile( self.file_name )

    def _get_can_create_dir ( self ):
        dir = dirname( self.file_name )
        return (isdir( dir ) and access( dir, R_OK | W_OK ))

    #-- Handler Event Handlers -------------------------------------------------

    def object_ok_changed ( self, info ):
        """ Handles the user clicking the OK button.
        """
        if self.is_save_file and exists( self.file_name ):
            do_later( self._file_already_exists )
        else:
            info.ui.dispose( True )

    def object_cancel_changed ( self, info ):
        """ Handles the user clicking the Cancel button.
        """
        info.ui.dispose( False )

    def object_create_changed ( self, info ):
        """ Handles the user clicking the create directory button.
        """
        if not isdir( self.file_name ):
            self.file_name = dirname( self.file_name )

        CreateDirHandler().edit_traits( context = self,
                                        parent  = info.create.control )

    #-- Traits Event Handlers --------------------------------------------------

    def _dclick_changed ( self ):
        """ Handles the user double-clicking a file name in the file tree view.
        """
        if self.is_valid_file:
            self.object_ok_changed( self.info )

    #-- Private Methods --------------------------------------------------------

    def open_file_view ( self ):
        """ Returns the file dialog view to use.
        """
        # Set up the default file dialog view and size information:
        item = Item( 'file_name',
                     id         = 'file_tree',
                     style      = 'custom',
                     show_label = False,
                     width      = 0.5,
                     editor     = FileEditor( filter      = self.filter,
                                              allow_dir   = True,
                                              reload_name = 'reload',
                                              dclick_name = 'dclick' ) )
        width = height = 0.20

        # Check to see if we have any extensions being added:
        if len( self.extensions ) > 0:

            # fixme: We should use the actual values of the view's Width and
            # height traits here to adjust the overall width and height...
            width *= 2.0

            # Assume we can used a fixed width Group:
            klass = HGroup

            # Set up to build a list of view Item objects:
            items = []

            # Add each extension to the dialog:
            for i, extension in enumerate( self.extensions ):

                # Save the extension in a new trait (for use by the View):
                name = 'extension_%d' % i
                setattr( self, name, extension )

                extension_view = extension

                # Sync up the 'file_name' trait with the extension:
                self.sync_trait( 'file_name', extension, mutual = True )

                # Check to see if it also defines the optional IFileDialogView
                # interface, and if not, use the default view information:
                if not extension.has_traits_interface( IFileDialogView ):
                    extension_view = default_view

                # Get the view that the extension wants to use:
                view = extension.trait_view( extension_view.view )

                # Determine if we should use a splitter for the dialog:
                if not extension_view.is_fixed:
                    klass = HSplit

                # Add the extension as a new view item:
                items.append(
                    Item( name,
                          label = user_name_for( extension.__class__.__name__ ),
                          show_label = False,
                          style      = 'custom',
                          width      = 0.5,
                          height     = 0.5,
                          dock       = 'horizontal',
                          resizable  = True,
                          editor     = InstanceEditor( view = view, id = name )
                    ) )

            # Finally, combine the normal view element with the extensions:
            item = klass( item,
                          VSplit( id = 'splitter2', springy = True, *items ),
                          id = 'splitter' )
        # Return the resulting view:
        return View(
            VGroup(
                VGroup( item ),
                HGroup(
                    Item( 'create',
                          id           = 'create',
                          show_label   = False,
                          style        = 'custom',
                          defined_when = 'is_save_file',
                          enabled_when = 'can_create_dir',
                          tooltip      = 'Create a new directory'
                    ),
                    Item( 'file_name',
                          id      = 'history',
                          editor  = HistoryEditor( entries  = self.entries,
                                                   auto_set = True ),
                          springy = True
                    ),
                    Item( 'ok',
                          id           = 'ok',
                          show_label   = False,
                          enabled_when = 'is_valid_file'
                    ),
                    Item( 'cancel',
                          show_label = False
                    )
                )
            ),
            title        = self.title,
            id           = self.id,
            kind         = 'livemodal',
            width        = width,
            height       = height,
            close_result = False,
            resizable    = True
        )

    def _file_already_exists ( self ):
        """ Handles prompting the user when the selected file already exists,
            and the dialog is a 'save file' dialog.
        """
        FileExistsHandler( message = ("The file '%s' already exists.\nDo "
                                      "you wish to overwrite it?") %
                                      basename( self.file_name )
            ).edit_traits( context = self,
                           parent  = self.info.ok.control ).set(
                           parent  = self.info.ui )

#-------------------------------------------------------------------------------
#  Returns a file name to open or an empty string if the user cancels the
#  operation:
#-------------------------------------------------------------------------------

def open_file ( **traits ):
    """ Returns a file name to open or an empty string if the user cancels the
        operation.
    """
    fd = OpenFileDialog( **traits )
    if fd.edit_traits( view = 'open_file_view' ).result:
        return fd.file_name

    return ''

def save_file ( **traits ):
    """ Returns a file name to save to or an empty string if the user cancels
        the operation. In the case where the file selected already exists, the
        user will be prompted if they want to overwrite the file before the
        selected file name is returned.
    """
    traits.setdefault( 'title', 'Save File' )
    traits[ 'is_save_file' ] = True
    fd = OpenFileDialog( **traits )
    if fd.edit_traits( view = 'open_file_view' ).result:
        return fd.file_name

    return ''

#-- Test Case ------------------------------------------------------------------

if __name__ == '__main__':
    print save_file( extensions = [ FileInfo(), TextInfo(), ImageInfo() ],
                     filter = 'Python file (*.py)|*.py' )


########NEW FILE########
__FILENAME__ = group
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the Group class used to represent a group of items used in a
    Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from string \
    import find

from traits.api import (Bool, Delegate, Float, Instance, List, Property, Range,
    ReadOnly, Str, TraitError, cached_property)

from traits.trait_base import enumerate

from .view_element import ViewSubElement

from .item import Item

from .include import Include

from .ui_traits import SequenceTypes, ATheme, ContainerDelegate, Orientation, Layout

from .dock_window_theme import dock_window_theme, DockWindowTheme

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Delegate trait to the object being "shadowed"
ShadowDelegate = Delegate( 'shadow' )

# Amount of padding to add around item
Padding = Range( 0, 15, desc = 'amount of padding to add around each item' )

#-------------------------------------------------------------------------------
#  'Group' class:
#-------------------------------------------------------------------------------

class Group ( ViewSubElement ):
    """ Represents a grouping of items in a user interface view.
    """

    #---------------------------------------------------------------------------
    # Trait definitions:
    #---------------------------------------------------------------------------

    # A list of Group, Item, and Include objects in this group.
    content = List( ViewSubElement )

    # A unique identifier for the group.
    id = Str

    # User interface label for the group. How the label is displayed depends
    # on the **show_border** attribute, and on the **layout** attribute of
    # the group's parent group or view.
    label = Str

    style_sheet = Str

    # Default context object for group items.
    object = ContainerDelegate

    # Default editor style of items in the group.
    style = ContainerDelegate

    # Default docking style of items in group.
    dock = ContainerDelegate

    # Default image to display on notebook tabs.
    image = ContainerDelegate

    # The theme to use for a DockWindow:
    dock_theme = Instance( DockWindowTheme, allow_none = False )

    # The theme to use for the group itself:
    group_theme = ATheme

    # The theme to use for items contained in the group:
    item_theme = ContainerDelegate

    # The theme to use for the labels of items contained in the group:
    label_theme = ContainerDelegate

    # Category of elements dragged from view.
    export = ContainerDelegate

    # Spatial orientation of the group's elements. Can be 'vertical' (default)
    # or 'horizontal'.
    orientation = Orientation

    # Layout style of the group, which can be one of the following:
    #
    # * 'normal' (default): Sub-groups are displayed sequentially in a single
    #   panel.
    # * 'flow': Sub-groups are displayed sequentially, and then "wrap" when
    #   they exceed the available space in the **orientation** direction.
    # * 'split': Sub-groups are displayed in a single panel, separated by
    #   "splitter bars", which the user can drag to adjust the amount of space
    #   for each sub-group.
    # * 'tabbed': Each sub-group appears on a separate tab, labeled with the
    #   sub-group's *label* text, if any.
    #
    # This attribute is ignored for groups that contain only items, or contain
    # only one sub-group.
    layout = Layout

    # Should the group be scrollable along the direction of orientation?
    scrollable = Bool( False )

    # The number of columns in the group
    columns = Range( 1, 50 )

    # Should a border be drawn around group? If set to True, the **label** text
    # is embedded in the border. If set to False, the label appears as a banner
    # above the elements of the group.
    show_border = Bool( False )

    # Should labels be added to items in group? Only items that are directly
    # contained in the group are affected. That is, if the group contains
    # a sub-group, the display of labels in the sub-group is not affected by
    # the attribute on this group.
    show_labels = Bool( True )

    # Should labels be shown to the left of items (True) or the right (False)?
    # Only items that are directly contained in the group are affected. That is,
    # if the group contains a sub-group, the display of labels in the sub-group
    # is not affected by the attribute in this group. If **show_labels** is
    # False, this attribute is irrelevant.
    show_left = Bool( True )

    # Is this group the tab that is initially selected? If True, the group's
    # tab is displayed when the view is opened. If the **layout** of the group's
    # parent is not 'tabbed', this attribute is ignored.
    selected = Bool( False )

    # Should the group use extra space along its parent group's layout
    # orientation?
    springy = Bool( False )

    # Optional help text (for top-level group). This help text appears in the
    # View-level help window (created by the default help handler), for any
    # View that contains *only* this group. Group-level help is ignored for
    # nested groups and multiple top-level groups
    help = Str

    # Pre-condition for including the group in the display. If the expression
    # evaluates to False, the group is not defined in the display. Conditions
    # for **defined_when** are evaluated only once, when the display is first
    # constructed. Use this attribute for conditions based on attributes that
    # vary from object to object, but that do not change over time.
    defined_when = Str

    # Pre-condition for showing the group. If the expression evaluates to False,
    # the group and its items are not visible (and they disappear if they were
    # previously visible). If the value evaluates to True, the group and items
    # become visible. All **visible_when** conditions are checked each time
    # that any trait value is edited in the display. Therefore, you can use
    # **visible_when** conditions to hide or show groups in response to user
    # input.
    visible_when = Str

    # Pre-condition for enabling the group. If the expression evaluates to False,
    # the group is disabled, that is, none of the widgets accept input. All
    # **enabled_when** conditions are checked each time that any trait value
    # is edited in the display. Therefore, you can use **enabled_when**
    # conditions to enable or disable groups in response to user input.
    enabled_when = Str

    # Amount of padding (in pixels) to add around each item in the group. The
    # value must be an integer between 0 and 15. (Unlike the Item class, the
    # Group class does not support negative padding.) The padding for any
    # individual widget is the sum of the padding for its Group, the padding
    # for its Item, and the default spacing determined by the toolkit.
    padding = Padding

    # Requested width of the group (calculated from widths of contents)
    width = Property( Float, depends_on='content' )

    # Requested height of the group (calculated from heights of contents)
    height = Property( Float, depends_on='content' )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, *values, **traits ):
        """ Initializes the group object.
        """
        super( ViewSubElement, self ).__init__( **traits )

        content = self.content

        # Process any embedded Group options first:
        for value in values:
            if (isinstance(value, basestring)) and (value[0:1] in '-|'):
                # Parse Group trait options if specified as a string:
                self._parse( value )

        # Process all of the data passed to the constructor:
        for value in values:
            if isinstance( value, ViewSubElement ):
                content.append( value )
            elif type( value ) in SequenceTypes:
                # Map (...) or [...] to a Group():
                content.append( Group( *value ) )
            elif isinstance( value, basestring ):
                if value[0:1] in '-|':
                    # We've already parsed Group trait options above:
                    pass
                elif (value[:1] == '<') and (value[-1:] == '>'):
                    # Convert string to an Include value:
                    content.append( Include( value[1:-1].strip() ) )
                else:
                    # Else let the Item class try to make sense of it:
                    content.append( Item( value ) )
            else:
                raise TypeError, "Unrecognized argument type: %s" % value

        # Make sure this Group is the container for all its children:
        self.set_container()

    #-- Default Trait Values ---------------------------------------------------

    def _dock_theme_default ( self ):
        return dock_window_theme()

    #---------------------------------------------------------------------------
    #  Gets the label to use for a specified Group in a specified UI:
    #---------------------------------------------------------------------------

    def get_label ( self, ui ):
        """ Gets the label to use this group.
        """
        if self.label != '':
            return self.label

        return 'Group'

    #---------------------------------------------------------------------------
    #  Returns whether or not the object is replacable by an Include object:
    #---------------------------------------------------------------------------

    def is_includable ( self ):
        """ Returns a Boolean value indicating whether the object is replacable
        by an Include object.
        """
        return (self.id != '')

    #---------------------------------------------------------------------------
    #  Replaces any items which have an 'id' with an Include object with the
    #  same 'id', and puts the object with the 'id' into the specified
    #  ViewElements object:
    #---------------------------------------------------------------------------

    def replace_include ( self, view_elements ):
        """ Replaces any items that have an **id** attribute with an Include
        object with the same ID value, and puts the object with the ID
        into the specified ViewElements object.

        Parameters
        ----------
        view_elements : ViewElements object
            A set of Group, Item, and Include objects
        """
        for i, item in enumerate( self.content ):
            if item.is_includable():
                id = item.id
                if id in view_elements.content:
                    raise TraitError, \
                          "Duplicate definition for view element '%s'" % id
                self.content[ i ] = Include( id )
                view_elements.content[ id ] = item
            item.replace_include( view_elements )

    #---------------------------------------------------------------------------
    #  Returns a ShadowGroup for the Group which recursively resolves all
    #  imbedded Include objects and which replaces all imbedded Group objects
    #  with a corresponding ShadowGroup:
    #---------------------------------------------------------------------------

    def get_shadow ( self, ui ):
        """ Returns a ShadowGroup object for the current Group object, which
        recursively resolves all embedded Include objects and which replaces
        each embedded Group object with a corresponding ShadowGroup.
        """
        content = []
        groups  = 0
        level   = ui.push_level()
        for value in self.content:
            # Recursively replace Include objects:
            while isinstance( value, Include ):
                value = ui.find( value )

            # Convert Group objects to ShadowGroup objects, but include Item
            # objects as is (ignore any 'None' values caused by a failed
            # Include):
            if isinstance( value, Group ):
                if self._defined_when( ui, value ):
                    content.append( value.get_shadow( ui ) )
                    groups += 1
            elif isinstance( value, Item ):
                if self._defined_when( ui, value ):
                    content.append( value )

            ui.pop_level( level )

        # Return the ShadowGroup:
        return ShadowGroup( shadow = self, content = content, groups = groups )

    #---------------------------------------------------------------------------
    #  Sets the correct container for the content:
    #---------------------------------------------------------------------------

    def set_container ( self ):
        """ Sets the correct container for the content.
        """
        for item in self.content:
            item.container = self

    #---------------------------------------------------------------------------
    #  Returns whether the object should be defined in the user interface:
    #---------------------------------------------------------------------------

    def _defined_when ( self, ui, value ):
        """ Should the object be defined in the user interface?
        """
        if value.defined_when == '':
            return True
        return ui.eval_when( value.defined_when )

    #---------------------------------------------------------------------------
    #  Parses Group options specified as a string:
    #---------------------------------------------------------------------------

    def _parse ( self, value ):
        """ Parses Group options specified as a string.
        """
        # Override the defaults, since we only allow 'True' values to be
        # specified:
        self.show_border = self.show_labels = self.show_left = False

        # Parse all of the single or multi-character options:
        value, empty = self._parse_label( value )
        value = self._parse_style( value )
        value = self._option( value, '-', 'orientation', 'horizontal' )
        value = self._option( value, '|', 'orientation', 'vertical' )
        value = self._option( value, '=', 'layout',      'split' )
        value = self._option( value, '^', 'layout',      'tabbed' )
        value = self._option( value, '>', 'show_labels',  True )
        value = self._option( value, '<', 'show_left',    True )
        value = self._option( value, '!', 'selected',     True )

        show_labels      = not (self.show_labels and self.show_left)
        self.show_left   = not self.show_labels
        self.show_labels = show_labels

        # Parse all of the punctuation based sub-string options:
        value = self._split( 'id', value, ':', find,  0, 1 )
        if value != '':
            self.object = value

    #---------------------------------------------------------------------------
    #  Handles a label being found in the string definition:
    #---------------------------------------------------------------------------

    def _parsed_label ( self ):
        """ Handles a label being found in the string definition.
        """
        self.show_border = True

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of the Group:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" version of the Group.
        """
        result  = []
        items   = ',\n'.join( [ item.__repr__() for item in self.content ] )
        if len( items ) > 0:
            result.append( items )

        options = self._repr_options( 'orientation', 'show_border',
                      'show_labels', 'show_left', 'selected', 'id', 'object',
                      'label', 'style', 'layout', 'style_sheet' )
        if options is not None:
            result.append( options )

        content = ',\n'.join( result )
        if len( content ) == 0:
            return self.__class__.__name__ + '()'

        return '%s(\n%s\n)' % (
               self.__class__.__name__, self._indent( content ) )

    #---------------------------------------------------------------------------
    #  Property getters/setters for width/height attributes
    #---------------------------------------------------------------------------

    @cached_property
    def _get_width ( self ):
        """ Returns the requested width of the Group.
        """
        width = 0.0
        for item in self.content:
            if item.width >= 1:
                if self.orientation == 'horizontal':
                    width += item.width
                elif self.orientation == 'vertical':
                    width = max( width, item.width )

        if width == 0:
            width = -1.0

        return width

    @cached_property
    def _get_height ( self ):
        """ Returns the requested height of the Group.
        """
        height = 0.0
        for item in self.content:
            if item.height >= 1:
                if self.orientation == 'horizontal':
                    height = max( height, item.height )
                elif self.orientation == 'vertical':
                    height += item.height

        if height == 0:
            height = -1.0

        return height

#-------------------------------------------------------------------------------
#  'HGroup' class:
#-------------------------------------------------------------------------------

class HGroup ( Group ):
    """ A group whose items are laid out horizontally.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it horizontal group
    # behavior:
    orientation = 'horizontal'

#-------------------------------------------------------------------------------
#  'VGroup' class:
#-------------------------------------------------------------------------------

class VGroup ( Group ):
    """ A group whose items are laid out vertically.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it vertical group behavior:
    orientation = 'vertical'

#-------------------------------------------------------------------------------
#  'VGrid' class:
#-------------------------------------------------------------------------------

class VGrid ( VGroup ):
    """ A group whose items are laid out in 2 columns.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it grid behavior:
    columns = 2

#-------------------------------------------------------------------------------
#  'HFlow' class:
#-------------------------------------------------------------------------------

class HFlow ( HGroup ):
    """ A group in which items are laid out horizontally, and "wrap" when
    they exceed the available horizontal space..
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it horizontal flow
    # behavior:
    layout      = 'flow'
    show_labels = False

#-------------------------------------------------------------------------------
#  'VFlow' class:
#-------------------------------------------------------------------------------

class VFlow ( VGroup ):
    """ A group in which items are laid out vertically, and "wrap" when they
    exceed the available vertical space.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it vertical flow behavior:
    layout      = 'flow'
    show_labels = False

#-------------------------------------------------------------------------------
#  'VFold' class:
#-------------------------------------------------------------------------------

class VFold ( VGroup ):
    """ A group in which items are laid out vertically and can be collapsed
        (i.e. 'folded') by clicking their title.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it vertical folding group
    # behavior:
    layout      = 'fold'
    show_labels = False

#-------------------------------------------------------------------------------
#  'HSplit' class:
#-------------------------------------------------------------------------------

class HSplit ( Group ):
    """ A horizontal group with splitter bars to separate it from other groups.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it horizontal splitter
    # behavior:
    layout      = 'split'
    orientation = 'horizontal'

#-------------------------------------------------------------------------------
#  'VSplit' class:
#-------------------------------------------------------------------------------

class VSplit ( Group ):
    """ A vertical group with splitter bars to separate it from other groups.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it vertical splitter
    # behavior:
    layout      = 'split'
    orientation = 'vertical'

#-------------------------------------------------------------------------------
#  'Tabbed' class:
#-------------------------------------------------------------------------------

class Tabbed ( Group ):
    """ A group that is shown as a tabbed notebook.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override standard Group trait defaults to give it tabbed notebook
    # behavior:
    layout  = 'tabbed'
    springy = True

#-------------------------------------------------------------------------------
#  'ShadowGroup' class:
#-------------------------------------------------------------------------------

class ShadowGroup ( Group ):
    """ Corresponds to a Group object, but with all embedded Include
        objects resolved, and with all embedded Group objects replaced by
        corresponding ShadowGroup objects.
    """

    #---------------------------------------------------------------------------
    # Trait definitions:
    #---------------------------------------------------------------------------

    # Group object this is a "shadow" for
    shadow = ReadOnly

    # Number of ShadowGroups in **content**
    groups = ReadOnly

    # Name of the group
    id = ShadowDelegate

    # User interface label for the group
    label = ShadowDelegate

    # Default context object for group items
    object = ShadowDelegate

    # Default style of items in the group
    style = ShadowDelegate

    # Default docking style of items in the group
    dock = ShadowDelegate

    # Default image to display on notebook tabs
    image = ShadowDelegate

    # The theme to use for a DockWindow:
    dock_theme = ShadowDelegate

    # The theme to use for the group itself:
    group_theme = ShadowDelegate

    # The theme to use for item's contained in the group:
    item_theme = ShadowDelegate

    # The theme to use for the labels of items contained in the group:
    label_theme = ShadowDelegate

    # Category of elements dragged from the view
    export = ShadowDelegate

    # Spatial orientation of the group
    orientation = ShadowDelegate

    # Layout style of the group
    layout = ShadowDelegate

    # Should the group be scrollable along the direction of orientation?
    scrollable = ShadowDelegate

    # The number of columns in the group
    columns = ShadowDelegate

    # Should a border be drawn around group?
    show_border = ShadowDelegate

    # Should labels be added to items in group?
    show_labels = ShadowDelegate

    # Should labels be shown to the left of items (vs. the right)?
    show_left = ShadowDelegate

    # Is group the initially selected page?
    selected = ShadowDelegate

    # Should the group use extra space along its parent group's layout
    # orientation?
    springy = ShadowDelegate

    # Optional help text (for top-level group)
    help = ShadowDelegate

    # Pre-condition for defining the group
    defined_when = ShadowDelegate

    # Pre-condition for showing the group
    visible_when = ShadowDelegate

    # Pre-condition for enabling the group
    enabled_when = ShadowDelegate

    # Amount of padding to add around each item
    padding = ShadowDelegate

    # Style sheet for the panel
    style_sheet = ShadowDelegate

    #---------------------------------------------------------------------------
    #  Returns the contents of the ShadowGroup within a specified user interface
    #  building context. This makes sure that all Group types are of the same
    #  type (i.e. Group or Item) and that all Include objects have been replaced
    #  by their substituted values:
    #---------------------------------------------------------------------------

    def get_content ( self, allow_groups = True ):
        """ Returns the contents of the Group within a specified context for
        building a user interface.

        This method makes sure that all Group types are of the same type (i.e.,
        Group or Item) and that all Include objects have been replaced by their
        substituted values.
        """
        # Make a copy of the content:
        result = self.content[:]

        # If result includes any ShadowGroups and they are not allowed,
        # replace them:
        if self.groups != 0:
            if not allow_groups:
                i = 0
                while i < len( result ):
                    value = result[i]
                    if isinstance( value, ShadowGroup ):
                        items         = value.get_content( False )
                        result[i:i+1] = items
                        i += len( items )
                    else:
                        i += 1
            elif (self.groups != len( result )) and (self.layout == 'normal'):
                items   = []
                content = []
                for item in result:
                    if isinstance( item, ShadowGroup ):
                        self._flush_items( content, items )
                        content.append( item )
                    else:
                        items.append( item )
                self._flush_items( content, items )
                result = content

        # Return the resulting list of objects:
        return result

    #---------------------------------------------------------------------------
    #  Returns an id used to identify the group:
    #---------------------------------------------------------------------------

    def get_id ( self ):
        """ Returns an ID for the group.
        """
        if self.id != '':
            return self.id

        return ':'.join( [ item.get_id() for item in self.get_content() ] )

    #---------------------------------------------------------------------------
    #  Sets the correct container for the content:
    #---------------------------------------------------------------------------

    def set_container ( self ):
        """ Sets the correct container for the content.
        """
        pass

    #---------------------------------------------------------------------------
    #  Creates a sub-Group for any items contained in a specified list:
    #---------------------------------------------------------------------------

    def _flush_items ( self, content, items ):
        """ Creates a sub-group for any items contained in a specified list.
        """
        if len( items ) > 0:
            content.append( ShadowGroup( shadow      = self.shadow,
                                         groups      = 0,
                                         label       = '',
                                         show_border = False,
                                         content     = items ).set(
                                         show_labels = self.show_labels,
                                         show_left   = self.show_left,
                                         springy     = self.springy,
                                         orientation = self.orientation ) )
            del items[:]

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of the Group:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" version of the Group.
        """
        return repr( self.shadow )

########NEW FILE########
__FILENAME__ = handler
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the Handler class used to manage and control the editing process in
    a Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .toolkit import toolkit

from .help import on_help_call

from .view_element import ViewElement

from .helper import user_name_for

from .ui_info import UIInfo

from traits.api import HasPrivateTraits, HasTraits, Instance

#-------------------------------------------------------------------------------
#  Closes a DockControl (if allowed by the associated traits UI Handler):
#-------------------------------------------------------------------------------

def close_dock_control ( dock_control ):
    """ Closes a DockControl (if allowed by the associated Traits UI Handler).
    """
    # Retrieve the traits UI object set when we created the DockControl:
    ui = dock_control.data

    # Ask the traits UI handler if it is OK to close the window:
    if not ui.handler.close( ui.info, True ):
        # If not, tell the DockWindow not to close it:
        return False

    # Otherwise, clean up and close the traits UI:
    ui.dispose()

    # And tell the DockWindow to remove the DockControl:
    return True

#-------------------------------------------------------------------------------
#  'Handler' class:
#-------------------------------------------------------------------------------

class Handler ( HasPrivateTraits ):
    """ Provides access to and control over the run-time workings of a
    Traits-based user interface.
    """

    #---------------------------------------------------------------------------
    #  Informs the handler what the UIInfo object for a View will be:
    #---------------------------------------------------------------------------

    def init_info ( self, info ):
        """ Informs the handler what the UIInfo object for a View will be.

            This method is called before the UI for the View has been
            constructed. It is provided so that the handler can save the
            reference to the UIInfo object in case it exposes viewable traits
            whose values are properties that depend upon items in the context
            being edited.
        """
        pass

    #---------------------------------------------------------------------------
    #  Initializes the controls of a user interface:
    #---------------------------------------------------------------------------

    def init ( self, info ):
        """ Initializes the controls of a user interface.

        Parameters
        ----------
        info : UIInfo object
            The UIInfo object associated with the view

        Returns
        -------
        A Boolean, indicating whether the user interface was successfully
        initialized. A True value indicates that the UI can be displayed;
        a False value indicates that the display operation should be
        cancelled. The default implementation returns True without taking
        any other action.

        Description
        -----------
        This method is called after all user interface elements have been
        created, but before the user interface is displayed. Override this
        method to customize the user interface before it is displayed.
        """
        return True

    #---------------------------------------------------------------------------
    #  Positions a dialog-based user interface on the display:
    #---------------------------------------------------------------------------

    def position ( self, info ):
        """ Positions a dialog-based user interface on the display.

        Parameters
        ----------
        info : UIInfo object
            The UIInfo object associated with the window

        Returns
        -------
        Nothing.

        Description
        -----------
        This method is called after the user interface is initialized (by
        calling init()), but before the user interface is displayed. Override
        this method to position the window on the display device. The default
        implementation calls the position() method of the current toolkit.

        Usually, you do not need to override this method, because you can
        control the window's placement using the **x** and **y** attributes
        of the View object.
        """
        toolkit().position( info.ui )

    #---------------------------------------------------------------------------
    #  Handles a request to close a dialog-based user interface by the user:
    #---------------------------------------------------------------------------

    def close ( self, info, is_ok ):
        """ Handles the user attempting to close a dialog-based user interface.

        Parameters
        ----------
        info : UIInfo object
            The UIInfo object associated with the view
        is_ok : Boolean
            Indicates whether the user confirmed the changes (such as by
            clicking **OK**.)

        Returns
        -------
        A Boolean, indicating whether the window should be allowed to close.

        Description
        -----------
        This method is called when the user attempts to close a window, by
        clicking an **OK** or **Cancel** button, or clicking a Close control
        on the window). It is called before the window is actually destroyed.
        Override this method to perform any checks before closing a window.

        While Traits UI handles "OK" and "Cancel" events automatically, you
        can use the value of the *is_ok* parameter to implement additional
        behavior.
        """
        return True

    #---------------------------------------------------------------------------
    #  Handles a dialog-based user interface being closed by the user:
    #---------------------------------------------------------------------------

    def closed ( self, info, is_ok ):
        """ Handles a dialog-based user interface being closed by the user.

        Parameters
        ----------
        info : UIInfo object
            The UIInfo object associated with the view
        is_ok : Boolean
            Indicates whether the user confirmed the changes (such as by
            clicking **OK**.)

        Description
        -----------
        This method is called *after* the window is destroyed. Override this
        method to perform any clean-up tasks needed by the application.
        """
        return

    #---------------------------------------------------------------------------
    #  Handles the 'Revert' button being clicked:
    #---------------------------------------------------------------------------

    def revert ( self, info ):
        """ Handles the **Revert** button being clicked.
        """
        return

    #---------------------------------------------------------------------------
    #  Handles the 'Apply' button being clicked:
    #---------------------------------------------------------------------------

    def apply ( self, info ):
        """ Handles the **Apply** button being clicked.
        """
        return

    #---------------------------------------------------------------------------
    #  Shows the help associated with the view:
    #---------------------------------------------------------------------------

    def show_help ( self, info, control = None ):
        """ Shows the help associated with the view.

        Parameters
        ----------
        info : UIInfo object
            The UIInfo object associated with the view
        control : UI control
            The control that invokes the help dialog box

        Description
        -----------
        This method is called when the user clicks a **Help** button in a
        Traits user interface. The method calls the global help handler, which
        might be the default help handler, or might be a custom help handler.
        See **traitsui.help** for details about the setting the
        global help handler.
        """
        if control is None:
            control = info.ui.control
        on_help_call()( info, control )

    #---------------------------------------------------------------------------
    #  Handles setting a specified object trait's value:
    #---------------------------------------------------------------------------

    def setattr ( self, info, object, name, value ):
        """ Handles the user setting a specified object trait's value.

        Parameters
        ----------
        object : object
            The object whose attribute is being set
        name : string
            The name of the attribute being set
        value
            The value to which the attribute is being set

        Description
        -----------
        This method is called when an editor attempts to set a new value for
        a specified object trait attribute. Use this method to control what
        happens when a trait editor tries to set an attribute value. For
        example, you can use this method to record a history of changes, in
        order to implement an "undo" mechanism. No result is returned. The
        default implementation simply calls the built-in setattr() function.
        If you override this method, make sure that it actually sets the
        attribute, either by calling the parent method or by setting the
        attribute directly

        """
        setattr( object, name, value )

    #---------------------------------------------------------------------------
    #  Gets a specified View object:
    #---------------------------------------------------------------------------

    def trait_view_for ( self, info, view, object, object_name, trait_name ):
        """ Gets a specified View object.
        """
        # If a view element was passed instead of a name or None, return it:
        if isinstance( view, ViewElement ):
            return view

        # Generate a series of possible view or method names of the form:
        # - 'view'
        #   trait_view_for_'view'( object )
        # - 'class_view'
        #   trait_view_for_'class_view'( object )
        # - 'object_name_view'
        #   trait_view_for_'object_name_view'( object )
        # - 'object_name_class_view'
        #   trait_view_for_'object_name_class_view'( object )
        # where 'class' is the class name of 'object', 'object' is the object
        #       name, and 'name' is the trait name. It returns the first view
        #       or method result which is defined on the handler:
        klass = object.__class__.__name__
        cname = '%s_%s' % ( object_name, trait_name )
        aview = ''
        if view:
            aview = '_' + view
        names = [ '%s_%s%s' % ( cname, klass, aview ),
                  '%s%s'    % ( cname, aview ),
                  '%s%s'    % ( klass, aview ) ]
        if view:
            names.append( view )
        for name in names:
            result = self.trait_view( name )
            if result is not None:
                return result
            method = getattr( self, 'trait_view_for_%s' % name, None )
            if callable( method ):
                result = method( info, object )
                if result is not None:
                    return result

        # If nothing is defined on the handler, return either the requested
        # view on the object itself, or the object's default view:
        return object.trait_view( view ) or object.trait_view()


#-- 'DockWindowHandler' interface implementation -------------------------------

    #---------------------------------------------------------------------------
    #  Returns whether or not a specified object can be inserted into the view:
    #---------------------------------------------------------------------------

    def can_drop ( self, info, object ):
        """ Can the specified object be inserted into the view?
        """
        from pyface.dock.api import DockControl

        if isinstance( object, DockControl ):
            return self.can_import( info, object.export )

        drop_class = info.ui.view.drop_class
        return ((drop_class is not None) and
                    isinstance( object, drop_class ))

    #---------------------------------------------------------------------------
    #  Returns whether or not a specified external view category can be
    #  imported:
    #---------------------------------------------------------------------------

    def can_import ( self, info, category ):
        return (category in info.ui.view.imports)

    #---------------------------------------------------------------------------
    #  Returns the DockControl object for a specified object:
    #---------------------------------------------------------------------------

    def dock_control_for ( self, info, parent, object ):
        """ Returns the DockControl object for a specified object.
        """
        from pyface.dock.api import IDockable, DockControl
        from .dockable_view_element import DockableViewElement

        try:
            name = object.name
        except:
            try:
                name = object.label
            except:
                name = ''
        if len( name ) == 0:
            name = user_name_for( object.__class__.__name__ )

        image  = None
        export = ''
        if isinstance( object, DockControl ):
            dock_control = object
            image        = dock_control.image
            export       = dock_control.export
            dockable     = dock_control.dockable
            close        = dockable.dockable_should_close()
            if close:
                dock_control.close( force = True )

            control = dockable.dockable_get_control( parent )

            # If DockControl was closed, then reset it to point to the new
            # control:
            if close:
                dock_control.set( control = control,
                                  style   = parent.owner.style )
                dockable.dockable_init_dockcontrol( dock_control )
                return dock_control

        elif isinstance( object, IDockable ):
            dockable = object
            control  = dockable.dockable_get_control( parent )
        else:
            ui       = object.get_dockable_ui( parent )
            dockable = DockableViewElement( ui = ui )
            export   = ui.view.export
            control  = ui.control

        dc = DockControl( control   = control,
                          name      = name,
                          export    = export,
                          style     = parent.owner.style,
                          image     = image,
                          closeable = True )

        dockable.dockable_init_dockcontrol( dc )

        return dc

    #---------------------------------------------------------------------------
    #  Creates a new view of a specified control:
    #---------------------------------------------------------------------------

    def open_view_for ( self, control, use_mouse = True ):
        """ Creates a new view of a specified control.
        """
        from pyface.dock.api import DockWindowShell

        DockWindowShell( control, use_mouse = use_mouse )

    #---------------------------------------------------------------------------
    #  Handles a DockWindow becoming empty:
    #---------------------------------------------------------------------------

    def dock_window_empty ( self, dock_window ):
        """ Handles a DockWindow becoming empty.
        """
        if dock_window.auto_close:
            dock_window.control.GetParent.Destroy()

#-- HasTraits overrides: -------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Edits the object's traits: (Overrides HasTraits)
    #---------------------------------------------------------------------------

    def edit_traits ( self, view       = None, parent  = None, kind = None,
                            context    = None, handler = None, id   = '',
                            scrollable = None, **args ):
        """ Edits the object's traits.
        """
        if context is None:
            context = self

        if handler is None:
            handler = self

        return self.trait_view( view ).ui( context, parent, kind,
                    self.trait_view_elements(), handler, id, scrollable, args )

    #---------------------------------------------------------------------------
    #  Configure the object's traits (Overrides HasTraits):
    #---------------------------------------------------------------------------

    def configure_traits ( self, filename = None, view       = None,
                                 kind     = None, edit       = True,
                                 context  = None, handler    = None,
                                 id       = '',   scrollable = None, **args ):
        """ Configures the object's traits.
        """
        return super( HasPrivateTraits, self ).configure_traits(
                       filename, view, kind, edit, context, handler or self, id,
                       scrollable, **args )

#-- Private Methods: -----------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles an 'Undo' change request:
    #---------------------------------------------------------------------------

    def _on_undo ( self, info ):
        """ Handles an "Undo" change request.
        """
        if info.ui.history is not None:
            info.ui.history.undo()

    #---------------------------------------------------------------------------
    #  Handles a 'Redo' change request:
    #---------------------------------------------------------------------------

    def _on_redo ( self, info ):
        """ Handles a "Redo" change request.
        """
        if info.ui.history is not None:
            info.ui.history.redo()

    #---------------------------------------------------------------------------
    #  Handles a 'Revert' all changes request:
    #---------------------------------------------------------------------------

    def _on_revert ( self, info ):
        """ Handles a "Revert all changes" request.
        """
        if info.ui.history is not None:
            info.ui.history.revert()
            self.revert( info )

    #---------------------------------------------------------------------------
    #  Handles a 'Close' request:
    #---------------------------------------------------------------------------

    def _on_close ( self, info ):
        """ Handles a "Close" request.
        """
        if (info.ui.owner is not None) and self.close( info, True ):
            info.ui.owner.close()

#-------------------------------------------------------------------------------
#  Default handler:
#-------------------------------------------------------------------------------

_default_handler = Handler()

def default_handler ( handler = None ):
    """ Returns the global default handler.

    If *handler* is an instance of Handler, this function sets it as the
    global default handler.
    """
    global _default_handler

    if isinstance( handler, Handler ):
        _default_handler = handler
    return _default_handler

#-------------------------------------------------------------------------------
#  'Controller' class:
#-------------------------------------------------------------------------------

class Controller ( Handler ):
    """ Defines a handler class which provides a view and controller for a
        specified model.

        This class is used when implementing a standard MVC-based design. The
        **model** trait contains most, if not all, of the data being viewed,
        and can be referenced in a Controller instance's View definition using
        unadorned trait names. (e.g., ``Item('name')``).
    """

    #-- Trait Definitions ------------------------------------------------------

    # The model this handler defines a view and controller for
    model = Instance( HasTraits )

    # The Info object associated with the controller
    info = Instance( UIInfo )

    #-- HasTraits Method Overrides ---------------------------------------------

    def __init__ ( self, model = None, **metadata ):
        """ Initializes the object and sets the model (if supplied).
        """
        super( Controller, self ).__init__( **metadata )
        self.model = model

    def trait_context ( self ):
        """ Returns the default context to use for editing or configuring
            traits.
        """
        return { 'object': self.model, 'controller': self, 'handler': self }

    #-- Handler Method Overrides -----------------------------------------------

    #---------------------------------------------------------------------------
    #  Informs the handler what the UIInfo object for a View will be:
    #---------------------------------------------------------------------------

    def init_info ( self, info ):
        """ Informs the handler what the UIInfo object for a View will be.
        """
        self.info = info

#-------------------------------------------------------------------------------
#  'ModelView' class:
#-------------------------------------------------------------------------------

class ModelView ( Controller ):
    """ Defines a handler class which provides a view and controller for a
        specified model.

        This class is useful when creating a variant of the standard MVC-based
        design. A subclass of ModelView reformulates a number of traits on
        its **model** object as properties on the ModelView subclass itself,
        usually in order to convert them into a more user-friendly format. In
        this design, the ModelView subclass supplies not only the view and
        the controller, but also, in effect, the model (as a set of properties
        wrapped around the original model). Because of this, the ModelView
        context dictionary specifies the ModelView instance itself as the
        special *object* value, and assigns the original model object as the
        *model* value. Thus, the traits of the ModelView object can be referenced
        in its View definition using unadorned trait names.
    """

    #-- HasTraits Method Overrides ---------------------------------------------

    def trait_context ( self ):
        """ Returns the default context to use for editing or configuring
            traits.
        """
        return { 'object': self, 'handler': self, 'model': self.model }

#-------------------------------------------------------------------------------
#  'ViewHandler' class:
#-------------------------------------------------------------------------------

class ViewHandler ( Handler ):

    pass


########NEW FILE########
__FILENAME__ = help
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   02/04/2005
#
#------------------------------------------------------------------------------

""" Defines the help interface for displaying the help associated with a
    Traits UI View object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from .toolkit import toolkit

#-------------------------------------------------------------------------------
#  Default handler for showing the help associated with a view:
#-------------------------------------------------------------------------------

def default_show_help ( info, control ):
    """ Default handler for showing the help associated with a view.
    """
    toolkit().show_help( info.ui, control )

# The default handler for showing help
show_help = default_show_help

#-------------------------------------------------------------------------------
#  Allows an application to change the default show help handler:
#-------------------------------------------------------------------------------

def on_help_call ( new_show_help = None ):
    """ Sets a new global help provider function.

    Parameters
    ----------
    new_show_help : function
        The function to set as the new global help provider

    Returns
    -------
    The previous global help provider function

    Description
    -----------
    The help provider function must have a signature of
    *function*(*info*, *control*), where *info* is a UIInfo object for the
    current view, and *control* is the UI control that invokes the function
    (typically, a **Help** button). It is provided in case the help provider
    needs to position the help window relative to the **Help** button.

    To retrieve the current help provider function, call this function with
    no arguments.
    """
    global show_help

    result = show_help
    if new_show_help is not None:
        show_help = new_show_help
    return result


########NEW FILE########
__FILENAME__ = helper
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/25/2004
#
#------------------------------------------------------------------------------

""" Defines various helper functions that are useful for creating Traits-based
    user interfaces.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from string import uppercase, lowercase

from traits.api import BaseTraitHandler, CTrait, Enum, TraitError

from .ui_traits import SequenceTypes

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Layout orientation for a control and its associated editor
Orientation = Enum( 'horizontal', 'vertical' )

# Docking drag bar style:
DockStyle = Enum( 'horizontal', 'vertical', 'tab', 'fixed' )

#----------------------------------------------------------------------------
#  Return a 'user-friendly' name for a specified trait:
#----------------------------------------------------------------------------

def user_name_for ( name ):
    """ Returns a "user-friendly" name for a specified trait.
    """
    name       = name.replace( '_', ' ' )
    name       = name[:1].upper() + name[1:]
    result     = ''
    last_lower = 0
    for c in name:
        if (c in uppercase) and last_lower:
           result += ' '
        last_lower = (c in lowercase)
        result    += c
    return result

#-------------------------------------------------------------------------------
#  Format a number with embedded commas:
#-------------------------------------------------------------------------------

def commatize ( value ):
    """ Formats a specified value as an integer string with embedded commas.
        For example: commatize( 12345 ) returns "12,345".
    """
    s = str( abs( value ) )
    s = s.rjust( ((len( s ) + 2) / 3) * 3 )
    result = ','.join( [ s[ i: i+3 ] for i in range( 0, len(s), 3 ) ] ).lstrip()
    if value >= 0:
        return result

    return '-' + result

#-------------------------------------------------------------------------------
#  Recomputes the mappings for a new set of enumeration values:
#-------------------------------------------------------------------------------

def enum_values_changed ( values, strfunc=unicode ):
    """ Recomputes the mappings for a new set of enumeration values.
    """

    if isinstance( values, dict ):
        data = [ ( strfunc( v ), n ) for n, v in values.items() ]
        if len( data ) > 0:
            data.sort( lambda x, y: cmp( x[0], y[0] ) )
            col = data[0][0].find( ':' ) + 1
            if col > 0:
                data = [ ( n[ col: ], v ) for n, v in data ]
    elif not isinstance( values, SequenceTypes ):
        handler = values
        if isinstance( handler, CTrait ):
            handler = handler.handler
        if not isinstance( handler, BaseTraitHandler ):
            raise TraitError, "Invalid value for 'values' specified"
        if handler.is_mapped:
            data = [ ( strfunc( n ), n ) for n in handler.map.keys() ]
            data.sort( lambda x, y: cmp( x[0], y[0] ) )
        else:
            data = [ ( strfunc( v ), v ) for v in handler.values ]
    else:
        data = [ ( strfunc( v ), v ) for v in values ]

    names           = [ x[0] for x in data ]
    mapping         = {}
    inverse_mapping = {}
    for name, value in data:
        mapping[ name ] = value
        inverse_mapping[ value ] = name

    return ( names, mapping, inverse_mapping )

########NEW FILE########
__FILENAME__ = help_template
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/25/2004
#
#------------------------------------------------------------------------------

""" Defines the HTML help templates used for formatting Traits UI help pages.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasStrictTraits, Str

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Default HTML for a single Item's help window
ItemHTML = """
<HTML>
<BODY BGCOLOR="#E8E5D4">
<TABLE CELLPADDING="0">
  <TR>
    <TD BGCOLOR="#000000">
      <TABLE CELLSPACING = "1">
        <TR>
          <TD WIDTH="20%%" VALIGN="TOP" BGCOLOR="#9DB8F4"><B>%s</B></TD>
          <TD WIDTH="80%%" VALIGN="TOP" BGCOLOR="#C1D2F9">%s</TD>
        </TR>
      </TABLE>
    </TD>
  </TR>
</TABLE>
</BODY>
</HTML>"""

# Default HTML for a complete Group's help window
GroupHTML = """
<HTML>
<BODY BGCOLOR="#E8E5D4">%s
<TABLE CELLPADDING="0">
  <TR>
    <TD BGCOLOR="#000000">
      <TABLE CELLSPACING="1">%s</TABLE>
    </TD>
  </TR>
</TABLE>
</BODY>
</HTML>"""

# Default HTML for a single Item within a Group
ItemHelp = """
<TR>
  <TD WIDTH="20%%" VALIGN="TOP" BGCOLOR="#9DB8F4"><B>%s</B>:</TD>
  <TD WIDTH="80%%" VALIGN="TOP" BGCOLOR="#C1D2F9">%s</TD>
</TR>"""

# Default HTML for formatting a Group's 'help' trait
GroupHelp = """
<TABLE WIDTH="100%%" CELLPADDING="0">
  <TR>
    <TD BGCOLOR="#000000">
      <TABLE CELLSPACING="1">
        <TR>
          <TD BGCOLOR="#CDCDB6">%s</TD>
        </TR>
      </TABLE>
    </TD>
  </TR>
</TABLE>"""

#-------------------------------------------------------------------------------
#  'HelpTemplate' class:
#-------------------------------------------------------------------------------

class HelpTemplate ( HasStrictTraits ):
    """ Contains HTML templates for displaying help.
    """
    item_html     = Str( ItemHTML )  # Item popup help window HTML document
    group_html    = Str( GroupHTML ) # Group help window HTML document
    item_help     = Str( ItemHelp )  # Single group item HTML
    group_help    = Str( GroupHelp ) # Group level help HTML
    no_group_help = Str( '' )        # Missing group level help HTML

#-------------------------------------------------------------------------------
#  Gets/Sets the current HelpTemplate in use:
#-------------------------------------------------------------------------------

_help_template = HelpTemplate()

def help_template ( template = None ):
    """ Gets or sets the current HelpTemplate in use.
    """
    global _help_template

    if template is not None:
        _help_template = template
    return _help_template


########NEW FILE########
__FILENAME__ = image
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/03/2007

""" Defines the ImageLibrary object used to manage Traits UI image libraries.
"""

import sys
from os import (environ, listdir, remove, stat, makedirs, rename, access,
                R_OK, W_OK, X_OK)
from os.path import (join, isdir, isfile, splitext, abspath, dirname,
                     basename, exists)
from stat import ST_MTIME
from platform import system
from zipfile import is_zipfile, ZipFile, ZIP_DEFLATED
from time import time, sleep, localtime, strftime
from thread import allocate_lock
from threading import Thread

from traits.api import (HasPrivateTraits, Property, Str, Int, List, Dict,
                        File, Instance, Bool, Undefined, TraitError, Float,
                        Any, cached_property)
from traits.trait_base import get_resource_path, traits_home

from traitsui.ui_traits import HasMargin, HasBorder, Alignment
from traitsui.theme import Theme
from traitsui.toolkit import toolkit
from pyface.api import ImageResource
from pyface.resource_manager import resource_manager
from pyface.resource.resource_reference import (ImageReference,
                                                ResourceReference)

#---------------------------------------------------------------------------
#  Constants:
#---------------------------------------------------------------------------

# Standard image file extensions:
ImageFileExts = ( '.png', '.gif', '.jpg', 'jpeg' )

# The image_cache root directory:
image_cache_path = join( traits_home(), 'image_cache' )

# Names of files that should not be copied when ceating a new library copy:
dont_copy_list = ( 'image_volume.py', 'image_info.py', 'license.txt' )

#-- Code Generation Templates ----------------------------------------------

# Template for creating an ImageVolumeInfo object:
ImageVolumeInfoCodeTemplate = \
"""        ImageVolumeInfo(
            description = %(description)s,
            copyright   = %(copyright)s,
            license     = %(license)s,
            image_names = %(image_names)s
        )"""

# Template for creating an ImageVolumeInfo license text:
ImageVolumeInfoTextTemplate = \
"""Description:
    %s

Copyright:
    %s

License:
    %s

Applicable Images:
%s"""

# Template for creating an ImageVolume object:
ImageVolumeTemplate = \
"""from traitsui.image.image import ImageVolume, ImageVolumeInfo

volume = ImageVolume(
    category    = %(category)s,
    keywords    = %(keywords)s,
    aliases     = %(aliases)s,
    time_stamp  = %(time_stamp)s,
    info        = [
%(info)s
    ]
)"""

# Template for creating an ImageVolume 'images' list:
ImageVolumeImagesTemplate = \
"""from traitsui.image.image import ImageInfo
from traitsui.ui_traits   import Margin, Border

images = [
%s
]"""

# Template for creating an ImageInfo object:
ImageInfoTemplate = \
"""    ImageInfo(
        name        = %(name)s,
        image_name  = %(image_name)s,
        description = %(description)s,
        category    = %(category)s,
        keywords    = %(keywords)s,
        width       = %(width)d,
        height      = %(height)d,
        border      = Border( %(bleft)d, %(bright)d, %(btop)d, %(bbottom)d ),
        content     = Margin( %(cleft)d, %(cright)d, %(ctop)d, %(cbottom)d ),
        label       = Margin( %(lleft)d, %(lright)d, %(ltop)d, %(lbottom)d ),
        alignment   = %(alignment)s
    )"""

#-------------------------------------------------------------------------------
#  Returns the contents of the specified file:
#-------------------------------------------------------------------------------

def read_file ( file_name ):
    """ Returns the contents of the specified *file_name*.
    """
    fh = file( file_name, 'rb' )
    try:
        return fh.read()
    finally:
        fh.close()

#-------------------------------------------------------------------------------
#  Writes the specified data to the specified file:
#-------------------------------------------------------------------------------

def write_file ( file_name, data ):
    """ Writes the specified data to the specified file.
    """
    fh = file( file_name, 'wb' )
    try:
        fh.write( data )
    finally:
        fh.close()

#-------------------------------------------------------------------------------
#  Returns the value of a Python symbol loaded from a specified source code
#  string:
#-------------------------------------------------------------------------------

def get_python_value ( source, name ):
    """ Returns the value of a Python symbol loaded from a specified source
        code string.
    """
    temp = {}
    source = source.replace('traitsui', 'traitsui')
    exec source.replace( '\r', '' ) in globals(), temp
    return temp[ name ]

#-------------------------------------------------------------------------------
#  Returns a specified time as a text string:
#-------------------------------------------------------------------------------

def time_stamp_for ( time ):
    """ Returns a specified time as a text string.
    """
    return strftime( '%Y%m%d%H%M%S', localtime( time ) )

#-------------------------------------------------------------------------------
#  Adds all traits from a specified object to a dictionary with a specified name
#  prefix:
#-------------------------------------------------------------------------------

def add_object_prefix ( dict, object, prefix ):
    """ Adds all traits from a specified object to a dictionary with a specified
        name prefix.
    """
    for name, value in object.get().iteritems():
        dict[ prefix + name ] = value

#-------------------------------------------------------------------------------
#  Splits a specified **image_name** into its constituent volume and file names
#  and returns a tuple of the form: ( volume_name, file_name ).
#-------------------------------------------------------------------------------

def split_image_name ( image_name ):
    """ Splits a specified **image_name** into its constituent volume and file
        names and returns a tuple of the form: ( volume_name, file_name ).
    """
    col         = image_name.find( ':' )
    volume_name = image_name[ 1: col ]
    file_name   = image_name[ col + 1: ]
    if file_name.find( '.' ) < 0:
        file_name += '.png'

    return ( volume_name, file_name )

#-------------------------------------------------------------------------------
#  Joins a specified **volume_name** and **file_name** into an image name, and
#  return the resulting image name:
#-------------------------------------------------------------------------------

def join_image_name ( volume_name, file_name ):
    """ Joins a specified **volume_name** and **file_name** into an image name,
        and return the resulting image name.
    """
    root, ext = splitext( file_name )
    if (ext == '.png') and (root.find( '.' ) < 0):
        file_name = root

    return '@%s:%s' % ( volume_name, file_name )

#-------------------------------------------------------------------------------
#  'FastZipFile' class:
#-------------------------------------------------------------------------------

class FastZipFile ( HasPrivateTraits ):
    """ Provides fast access to zip files by keeping the underlying zip file
        open across multiple uses.
    """

    # The path to the zip file:
    path = File

    # The open zip file object (if None, the file is closed):
    zf = Property

    # The time stamp of when the zip file was most recently accessed:
    time_stamp = Float

    # The lock used to manage access to the 'zf' trait between the two threads:
    access = Any

    #-- Public Methods ---------------------------------------------------------

    def namelist ( self ):
        """ Returns the names of all files in the top-level zip file directory.
        """
        self.access.acquire()
        try:
            return self.zf.namelist()
        finally:
            self.access.release()

    def read ( self, file_name ):
        """ Returns the contents of the specified **file_name** from the zip
            file.
        """
        self.access.acquire()
        try:
            return self.zf.read( file_name )
        finally:
            self.access.release()

    def close ( self ):
        """ Temporarily closes the zip file (usually while the zip file is being
            replaced by a different version).
        """
        self.access.acquire()
        try:
            if self._zf is not None:
                self._zf.close()
                self._zf = None
        finally:
            self.access.release()

    #-- Default Value Implementations ------------------------------------------

    def _access_default ( self ):
        return allocate_lock()

    #-- Property Implementations -----------------------------------------------

    def _get_zf ( self ):
        # Restart the time-out:
        self.time_stamp = time()

        if self._zf is None:
            self._zf = ZipFile( self.path, 'r' )
            if self._running is None:
                Thread( target = self._process ).start()
                self._running = True

        return self._zf

    #-- Private Methods --------------------------------------------------------

    def _process ( self ):
        """ Waits until the zip file has not been accessed for a while, then
            closes the file and exits.
        """
        while True:
            sleep( 1 )
            self.access.acquire()
            if time() > (self.time_stamp + 2.0):
                if self._zf is not None:
                    self._zf.close()
                    self._zf = None

                self._running = None
                self.access.release()
                break

            self.access.release()

#-------------------------------------------------------------------------------
#  'ImageInfo' class:
#-------------------------------------------------------------------------------

class ImageInfo ( HasPrivateTraits ):
    """ Defines a class that contains information about a specific Traits UI
        image.
    """

    # The volume this image belongs to:
    volume = Instance( 'ImageVolume' )

    # The user friendly name of the image:
    name = Str

    # The full image name (e.g. '@standard:floppy'):
    image_name = Str

    # A description of the image:
    description = Str

    # The category that the image belongs to:
    category = Str( 'General' )

    # A list of keywords used to describe/categorize the image:
    keywords = List( Str )

    # The image width (in pixels):
    width = Int

    # The image height (in pixels):
    height = Int

    # The theme for this image:
    theme = Instance( Theme )

    # The border inset:
    border = HasBorder

    # The margin to use around the content:
    content = HasMargin

    # The margin to use around the label:
    label = HasMargin

    # The alignment to use for the label:
    alignment = Alignment

    # The copyright that applies to this image:
    copyright = Property

    # The license that applies to this image:
    license = Property

    # A read-only string containing the Python code needed to construct this
    # ImageInfo object:
    image_info_code = Property

    #-- Default Value Implementations ------------------------------------------

    def _name_default ( self ):
        return split_image_name( self.image_name )[1]

    def _width_default ( self ):
        if self.volume is None:
            return 0

        image = self.volume.image_resource( self.image_name )
        if image is None:
            self.height = 0

            return 0

        width, self.height = toolkit().image_size( image.create_image() )

        return width

    def _height_default ( self ):
        if self.volume is None:
            return 0

        image = self.volume.image_resource( self.image_name )
        if image is None:
            self.width = 0

            return 0

        self.width, height = toolkit().image_size( image.create_image() )

        return height

    def _theme_default ( self ):
        image = None
        if self.volume is not None:
            image = self.volume.image_resource( self.image_name )

        return Theme( image,
                      border    = self.border,
                      content   = self.content,
                      label     = self.label,
                      alignment = self.alignment )

    #-- Property Implementations -----------------------------------------------

    def _get_image_info_code ( self ):
        data = dict( [ ( name, repr( value ) )
                       for name, value in self.get( 'name', 'image_name',
                       'description', 'category', 'keywords' ).iteritems() ] )
        data.update( self.get( 'width', 'height' ) )
        theme = self.theme
        data[ 'alignment' ] = repr( theme.alignment )
        add_object_prefix( data, theme.border,  'b' )
        add_object_prefix( data, theme.content, 'c' )
        add_object_prefix( data, theme.label,   'l' )

        return (ImageInfoTemplate % data)

    def _get_copyright ( self ):
        return self._volume_info( 'copyright' )

    def _get_license ( self ):
        return self._volume_info( 'license' )

    #-- Private Methods --------------------------------------------------------

    def _volume_info ( self, name ):
        """ Returns the VolumeInfo object that applies to this image.
        """
        info = self.volume.volume_info( self.image_name )
        if info is not None:
            return getattr( info, name, 'Unknown' )

        return 'Unknown'

#-------------------------------------------------------------------------------
#  'ImageVolumeInfo' class:
#-------------------------------------------------------------------------------

class ImageVolumeInfo ( HasPrivateTraits ):

    # A general description of the images:
    description = Str( 'No volume description specified.' )

    # The copyright that applies to the images:
    copyright = Str( 'No copyright information specified.' )

    # The license that applies to the images:
    license = Str( 'No license information specified.' )

    # The list of image names within the volume the information applies to.
    # Note that an empty list means that the information applies to all images
    # in the volume:
    image_names = List( Str )

    # A read-only string containing the Python code needed to construct this
    # ImageVolumeInfo object:
    image_volume_info_code = Property

    # A read-only string containing the text describing the volume info:
    image_volume_info_text = Property

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_image_volume_info_code ( self ):
        data = dict( [ ( name, repr( value ) )
                       for name, value in self.get( 'description', 'copyright',
                                     'license', 'image_names' ).iteritems() ] )

        return (ImageVolumeInfoCodeTemplate % data)

    @cached_property
    def _get_image_volume_info_text ( self ):
        description = self.description.replace( '\n', '\n    ' )
        license     = self.license.replace(     '\n', '\n    ' ).strip()
        image_names = self.image_names
        image_names.sort()
        if len( image_names ) == 0:
            image_names = [ 'All' ]
        images = '\n'.join( [ '  - ' + image_name
                              for image_name in image_names ] )

        return (ImageVolumeInfoTextTemplate % ( description, self.copyright,
                                                license, images ))

    #-- Public Methods ---------------------------------------------------------

    def clone ( self ):
        """ Returns a copy of the ImageVolumeInfo object.
        """
        return self.__class__( **self.get( 'description', 'copyright',
                                           'license' ) )

#-------------------------------------------------------------------------------
#  'ImageVolume' class:
#-------------------------------------------------------------------------------

class ImageVolume ( HasPrivateTraits ):

    # The canonical name of this volume:
    name = Str

    # The list of volume descriptors that apply to this volume:
    info = List( ImageVolumeInfo )

    # The category that the volume belongs to:
    category = Str( 'General' )

    # A list of keywords used to describe the volume:
    keywords = List( Str )

    # The list of aliases for this volume:
    aliases = List( Str )

    # The path of the file that defined this volume:
    path = File

    # Is the path a zip file?
    is_zip_file = Bool( True )

    # The FastZipFile object used to access the underlying zip file:
    zip_file = Instance( FastZipFile )

    # The list of images available in the volume:
    images = List( ImageInfo )

    # A dictionary mapping image names to ImageInfo objects:
    catalog = Property( depends_on = 'images' )

    # The time stamp of when the image library was last modified:
    time_stamp = Str

    # A read-only string containing the Python code needed to construct this
    # ImageVolume object:
    image_volume_code = Property

    # A read-only string containing the Python code needed to construct the
    # 'images' list for this ImageVolume object:
    images_code = Property

    # A read-only string containing the text describing the contents of the
    # volume (description, copyright, license information, and the images they
    # apply to):
    license_text = Property

    #-- Public Methods ---------------------------------------------------------

    def update ( self ):
        """ Updates the contents of the image volume from the underlying
            image store, and saves the results.
        """
        # Unlink all our current images:
        for image in self.images:
            image.volume = None

        # Make sure the images are up to date by deleting any current value:
        del self.images

        # Save the new image volume information:
        self.save()

    def save ( self ):
        """ Saves the contents of the image volume using the current contents
            of the **ImageVolume**.
        """
        path = self.path

        if not self.is_zip_file:
            # Make sure the directory is writable:
            if not access( path, R_OK | W_OK | X_OK ):
                return False

        # Make sure the directory and zip file are writable:
        elif ((not access( dirname( path ), R_OK | W_OK | X_OK )) or
              (exists( path ) and (not access( path, W_OK )))):
            return False

        # Pre-compute the images code, because it can require a long time
        # to load all of the images so that we can determine their size, and we
        # don't want that time to interfere with the time stamp of the image
        # volume:
        images_code = self.images_code

        if not self.is_zip_file:
            # We need to time stamp when this volume info was generated, but
            # it needs to be the same or newer then the time stamp of the file
            # it is in. So we use the current time plus a 'fudge factor' to
            # allow for some slop in when the OS actually time stamps the file:
            self.time_stamp = time_stamp_for( time() + 5.0 )

            # Write the volume manifest source code to a file:
            write_file( join( path, 'image_volume.py' ),
                        self.image_volume_code )

            # Write the image info source code to a file:
            write_file( join( path, 'image_info.py' ), images_code )

            # Write a separate license file for human consumption:
            write_file( join( path, 'license.txt' ), self.license_text )

            return True

        # Create a temporary name for the new .zip file:
        file_name = path + '.###'

        # Create the new zip file:
        new_zf = ZipFile( file_name, 'w', ZIP_DEFLATED )

        try:
            # Get the current zip file:
            cur_zf = self.zip_file

            # Copy all of the image files from the current zip file to the new
            # zip file:
            for name in cur_zf.namelist():
                if name not in dont_copy_list:
                    new_zf.writestr( name, cur_zf.read( name ) )

            # Temporarily close the current zip file while we replace it with
            # the new version:
            cur_zf.close()

            # We need to time stamp when this volume info was generated, but
            # it needs to be the same or newer then the time stamp of the file
            # it is in. So we use the current time plus a 'fudge factor' to
            # allow for some slop in when the OS actually time stamps the file:
            self.time_stamp = time_stamp_for( time() + 10.0 )

            # Write the volume manifest source code to the zip file:
            new_zf.writestr( 'image_volume.py', self.image_volume_code )

            # Write the image info source code to the zip file:
            new_zf.writestr( 'image_info.py', images_code )

            # Write a separate license file for human consumption:
            new_zf.writestr( 'license.txt', self.license_text )

            # Done creating the new zip file:
            new_zf.close()
            new_zf = None

            # Rename the original file to a temporary name, so we can give the
            # new file the original name. Note that unlocking the original zip
            # file after the previous close sometimes seems to take a while,
            # which is why we repeatedly try the rename until it either succeeds
            # or takes so long that it must have failed for another reason:
            temp_name = path + '.$$$'
            for i in range( 50 ):
                try:
                    rename( path, temp_name )
                    break
                except:
                    sleep( 0.1 )

            try:
                rename( file_name, path )
                file_name = temp_name
            except:
                rename( temp_name, path )
                raise
        finally:
            if new_zf is not None:
                new_zf.close()

            remove( file_name )

        return True

    def image_resource ( self, image_name ):
        """ Returns the ImageResource object for the specified **image_name**.
        """
        # Get the name of the image file:
        volume_name, file_name = split_image_name( image_name )

        if self.is_zip_file:
            # See if we already have the image file cached in the file system:
            cache_file = self._check_cache( file_name )
            if cache_file is None:
                # If not cached, then create a zip file reference:
                ref = ZipFileReference(
                          resource_factory = resource_manager.resource_factory,
                          zip_file         = self.zip_file,
                          path             = self.path,
                          volume_name      = self.name,
                          file_name        = file_name )
            else:
                # Otherwise, create a cache file reference:
                ref = ImageReference( resource_manager.resource_factory,
                                      filename = cache_file )
        else:
            # Otherwise, create a normal file reference:
            ref = ImageReference( resource_manager.resource_factory,
                                  filename = join( self.path, file_name ) )

        # Create the ImageResource object using the reference (note that the
        # ImageResource class will not allow us to specify the reference in the
        # constructor):
        resource = ImageResource( file_name )
        resource._ref = ref

        # Return the ImageResource:
        return resource

    def image_data ( self, image_name ):
        """ Returns the image data (i.e. file contents) for the specified image
            name.
        """
        volume_name, file_name = split_image_name( image_name )

        if self.is_zip_file:
            return self.zip_file.read( file_name )
        else:
            return read_file( join( self.path, file_name ) )

    def volume_info ( self, image_name ):
        """ Returns the ImageVolumeInfo object that corresponds to the
            image specified by **image_name**.
        """
        for info in self.info:
            if ((len( info.image_names ) == 0) or
                (image_name in info.image_names)):
                return info

        # Should never occur:
        return None

    #-- Default Value Implementations ------------------------------------------

    def _info_default ( self ):
        return [ ImageVolumeInfo() ]

    def _images_default ( self ):
        return self._load_image_info()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_catalog ( self ):
        return dict( [ ( image.image_name, image ) for image in self.images ] )

    def _get_image_volume_code ( self ):
        data = dict( [ ( name, repr( value ) )
                       for name, value in self.get( 'description', 'category',
                           'keywords', 'aliases', 'time_stamp' ).iteritems() ] )
        data['info'] = ',\n'.join( [ info.image_volume_info_code
                                     for info in self.info ] )

        return (ImageVolumeTemplate % data)

    def _get_images_code ( self ):
        images = ',\n'.join( [ info.image_info_code for info in self.images ] )

        return (ImageVolumeImagesTemplate % images)

    def _get_license_text ( self ):
        return (('\n\n%s\n' % ('-' * 79)).join( [ info.image_volume_info_text
                                                  for info in self.info ] ))

    #-- Private Methods --------------------------------------------------------

    def _load_image_info ( self ):
        """ Returns the list of ImageInfo objects for the images in the volume.
        """
        # If there is no current path, then return a default list of images:
        if self.path == '':
            return []

        time_stamp  = time_stamp_for( stat( self.path )[ ST_MTIME ] )
        volume_name = self.name
        old_images  = []
        cur_images  = []

        if self.is_zip_file:
            zf = self.zip_file

            # Get the names of all top-level entries in the zip file:
            names = zf.namelist()

            # Check to see if there is an image info manifest file:
            if 'image_info.py' in names:
                # Load the manifest code and extract the images list:
                old_images = get_python_value( zf.read( 'image_info.py' ),
                                               'images' )

            # Check to see if our time stamp is up to data with the file:
            if self.time_stamp < time_stamp:

                # If not, create an ImageInfo object for all image files
                # contained in the .zip file:
                for name in names:
                    root, ext = splitext( name )
                    if ext in ImageFileExts:
                        cur_images.append( ImageInfo(
                           name       = root,
                           image_name = join_image_name( volume_name, name ) ) )

        else:
            image_info_path = join( self.path, 'image_info.py' )
            if exists( image_info_path ):
                # Load the manifest code and extract the images list:
                old_images = get_python_value( read_file( image_info_path ),
                                               'images' )

            # Check to see if our time stamp is up to data with the file:
            if self.time_stamp < time_stamp:

                # If not, create an ImageInfo object for each image file
                # contained in the path:
                for name in listdir( self.path ):
                    root, ext = splitext( name )
                    if ext in ImageFileExts:
                        cur_images.append( ImageInfo(
                           name       = root,
                           image_name = join_image_name( volume_name, name ) ) )

        # Merge the old and current images into a single up to date list:
        if len( cur_images ) == 0:
            images = old_images
        else:
            cur_image_set = dict( [ ( image.image_name, image )
                                    for image in cur_images ] )
            for old_image in old_images:
                cur_image = cur_image_set.get( old_image.image_name )
                if cur_image is not None:
                    cur_image_set[ old_image.image_name ] = old_image
                    cur_image.volume = self
                    old_image.width  = cur_image.width
                    old_image.height = cur_image.height
                    cur_image.volume = None

            images = cur_image_set.values()

        # Set the new time stamp of the volume:
        self.time_stamp = time_stamp

        # Return the resulting sorted list as the default value:
        images.sort( key = lambda item: item.image_name )

        # Make sure all images reference this volume:
        for image in images:
            image.volume = self

        return images

    def _check_cache ( self, file_name ):
        """ Checks to see if the specified zip file name has been saved in the
            image cache. If it has, it returns the fully-qualified cache file
            name to use; otherwise it returns None.
        """
        cache_file = join( image_cache_path, self.name, file_name )
        if (exists( cache_file ) and
           (time_stamp_for( stat( cache_file )[ ST_MTIME ] ) >
            self.time_stamp)):
            return cache_file

        return None

#-------------------------------------------------------------------------------
#  'ZipFileReference' class:
#-------------------------------------------------------------------------------

class ZipFileReference ( ResourceReference ):

    # The zip file to read;
    zip_file = Instance( FastZipFile )

    # The volume name:
    volume_name = Str

    # The file within the zip file:
    file_name = Str

    # The name of the cached image file:
    cache_file = File

    #-- The 'ResourceReference' API --------------------------------------------

    # The file name of the image (in this case, the cache file name):
    filename = Property

    #-- ResourceReference Interface Implementation -----------------------------

    def load ( self ):
        """ Loads the resource.
        """
        # Check if the cache file has already been created:
        cache_file = self.cache_file
        if cache_file == '':
            # Extract the data from the zip file:
            data = self.zip_file.read( self.file_name )

            # Try to create an image from the data, without writing it to a
            # file first:
            image = self.resource_factory.image_from_data( data, Undefined )
            if image is not None:
                return image

            # Make sure the correct image cache directory exists:
            cache_dir = join( image_cache_path, self.volume_name )
            if not exists( cache_dir ):
                makedirs( cache_dir )

            # Write the image data to the cache file:
            cache_file = join( cache_dir, self.file_name )
            fh         = file( cache_file, 'wb' )
            try:
                fh.write( data )
            finally:
                fh.close()

            # Save the cache file name in case we are called again:
            self.cache_file = cache_file

            # Release our reference to the zip file object:
            self.zip_file = None

        # Return the image data from the image cache file:
        return self.resource_factory.image_from_file( cache_file )

    #-- Property Implementations -----------------------------------------------

    def _get_filename ( self ):
        if self.cache_file == '':
            self.load()

        return self.cache_file

#-------------------------------------------------------------------------------
#  'ImageLibrary' class:
#-------------------------------------------------------------------------------

class ImageLibrary ( HasPrivateTraits ):
    """ Manages Traits UI image libraries.
    """

    # The list of available image volumes in the library:
    volumes = List( ImageVolume )

    # The volume dictionary (the keys are volume names, and the values are the
    # corresponding ImageVolume objects):
    catalog = Dict( Str, ImageVolume )

    # The list of available images in the library:
    images = Property( List, depends_on = 'volumes.images' )

    #-- Private Traits ---------------------------------------------------------

    # Mapping from a 'virtual' library name to a 'real' library name:
    aliases = Dict

    #-- Public methods ---------------------------------------------------------

    def image_info ( self, image_name ):
        """ Returns the ImageInfo object corresponding to a specified
            **image_name**.
        """
        volume = self.find_volume( image_name )
        if volume is not None:
            return volume.catalog.get( image_name )

        return None

    def image_resource ( self, image_name ):
        """ Returns an ImageResource object for the specified image name.
        """
        # If no volume was specified, use the standard volume:
        if image_name.find( ':' ) < 0:
            image_name = '@images:%s' % image_name[1:]

        # Find the correct volume, possible resolving any aliases used:
        volume = self.find_volume( image_name )

        # Find the image within the volume and return its ImageResource object:
        if volume is not None:
            return volume.image_resource( image_name )

        # Otherwise, the volume was not found:
        return None

    def find_volume ( self, image_name ):
        """ Returns the ImageVolume object corresponding to the specified
            **image_name** or None if the volume cannot be found.
        """
        # Extract the volume name from the image name:
        volume_name, file_name = split_image_name( image_name )

        # Find the correct volume, possibly resolving any aliases used:
        catalog = self.catalog
        aliases = self.aliases
        while volume_name not in catalog:
            volume_name = aliases.get( volume_name )
            if volume_name is None:
                return None

        return catalog[ volume_name ]

    def add_volume ( self, file_name = None ):
        """ If **file_name** is a file, it adds an image volume specified by
            **file_name** to the image library. If **file_name** is a
            directory, it adds all image libraries contained in the directory
            to the image library. If **file_name** is omitted, all image
            libraries located in the *images* directory contained in the same
            directory as the caller are added.
        """
        # If no file name was specified, derive a path from the caller's
        # source code location:
        if file_name is None:
            file_name = join( get_resource_path( 2 ), 'images' )

        if isfile( file_name ):
            # Load an image volume from the specified file:
            volume = self._add_volume( file_name )
            if volume is None:
                raise TraitError( "'%s' is not a valid image volume." %
                                  file_name )

            if volume.name in self.catalog:
                self._duplicate_volume( volume.name )

            self.catalog[ volume.name ] = volume
            self.volumes.append( volume )

        elif isdir( file_name ):
            # Load all image volumes from the specified path:
            catalog = self.catalog
            volumes = self._add_path( file_name )
            for volume in volumes:
                if volume.name in catalog:
                    self._duplicate_volume( volume.name )

                catalog[ volume.name ] = volume

            self.volumes.extend( volumes )
        else:
            # Handle an unrecognized argument:
            raise TraitError( "The add method argument must be None or a file "
                      "or directory path, but '%s' was specified." % file_name )

    def add_path ( self, volume_name, path = None ):
        """ Adds the directory specified by **path** as a *virtual* volume
            called **volume_name**. All image files contained within path
            define the contents of the volume. If **path** is None, the
            *images* contained in the 'images' subdirectory of the same
            directory as the caller are is used as the path for the *virtual*
            volume..
        """
        # Make sure we don't already have a volume with that name:
        if volume_name in self.catalog:
            raise TraitError( ("The volume name '%s' is already in the image "
                               "library.") % volume_name )

        # If no path specified, derive one from the caller's source code
        # location:
        if path is None:
            path = join( get_resource_path( 2 ), 'images' )

        # Make sure that the specified path is a directory:
        if not isdir( path ):
            raise TraitError( "The image volume path '%s' does not exist." %
                              path )

        # Create the ImageVolume to describe the path's contents:
        image_volume_path = join( path, 'image_volume.py' )
        if exists( image_volume_path ):
            volume = get_python_value( read_file( image_volume_path ),
                                       'volume' )
        else:
            volume = ImageVolume()

        # Set up the rest of the volume information:
        volume.set( name        = volume_name,
                    path        = path,
                    is_zip_file = False )

        # Try to bring the volume information up to date if necessary:
        if volume.time_stamp < time_stamp_for( stat( path )[ ST_MTIME ] ):
            # Note that the save could fail if the volume is read-only, but
            # that's OK, because we're only trying to do the save in case
            # a developer had added or deleted some image files, which would
            # require write access to the volume:
            volume.save()

        # Add the new volume to the library:
        self.catalog[ volume_name ] = volume
        self.volumes.append( volume )

    def extract ( self, file_name, image_names ):
        """ Builds a new image volume called **file_name** from the list of
            image names specified by **image_names**. Each image name should be
            of the form: '@volume:name'.
        """
        # Get the volume name and file extension:
        volume_name, ext = splitext( basename( file_name ) )

        # If no extension specified, add the '.zip' file extension:
        if ext == '':
            file_name += '.zip'

        # Create the ImageVolume object to describe the new volume:
        volume = ImageVolume( name = volume_name )

        # Make sure the zip file does not already exists:
        if exists( file_name ):
            raise TraitError( "The '%s' file already exists." % file_name )

        # Create the zip file:
        zf = ZipFile( file_name, 'w', ZIP_DEFLATED )

        # Add each of the specified images to it and the ImageVolume:
        error    = True
        aliases  = set()
        keywords = set()
        images   = []
        info     = {}
        try:
            for image_name in set( image_names ):
                # Verify the image name is legal:
                if (image_name[:1] != '@') or (image_name.find( ':' ) < 0):
                    raise TraitError( ("The image name specified by '%s' is "
                                "not of the form: @volume:name.") % image_name )

                # Get the reference volume and image file names:
                image_volume_name, image_file_name = \
                    split_image_name( image_name )

                # Get the volume for the image name:
                image_volume = self.find_volume( image_name )
                if image_volume is None:
                    raise TraitError( ("Could not find the image volume "
                                       "specified by '%s'.") % image_name )

                # Get the image info:
                image_info = image_volume.catalog.get( image_name )
                if image_info is None:
                    raise TraitError( ("Could not find the image specified by "
                                       "'%s'.") % image_name )

                # Add the image info to the list of images:
                images.append( image_info )

                # Add the image file to the zip file:
                zf.writestr( image_file_name,
                             image_volume.image_data( image_name ) )

                # Add the volume alias needed by the image (if any):
                if image_volume_name != volume_name:
                    if image_volume_name not in aliases:
                        aliases.add( image_volume_name )

                        # Add the volume keywords as well:
                        for keyword in image_volume.keywords:
                            keywords.add( keyword )

                # Add the volume info for the image:
                volume_info = image_volume.volume_info( image_name )
                vinfo       = info.get( image_volume_name )
                if vinfo is None:
                    info[ image_volume_name ] = vinfo = volume_info.clone()

                vinfo.image_names.append( image_name )

            # Create the list of images for the volume:
            images.sort( key = lambda item: item.image_name )
            volume.images = images

            # Create the list of aliases for the volume:
            volume.aliases = list( aliases )

            # Create the list of keywords for the volume:
            volume.keywords = list( keywords )

            # Create the final volume info list for the volume:
            volume.info = info.values()

            # Write the volume manifest source code to the zip file:
            zf.writestr( 'image_volume.py', volume.image_volume_code )

            # Write the image info source code to the zip file:
            zf.writestr( 'image_info.py', volume.images_code )

            # Write a separate licenses file for human consumption:
            zf.writestr( 'license.txt', volume.license_text )

            # Indicate no errors occurred:
            error = False
        finally:
            zf.close()
            if error:
                remove( file_name )

    #-- Default Value Implementations ------------------------------------------

    def _volumes_default ( self ):
        result = []

        # Check for and add the 'application' image library:
        app_library = join( dirname( abspath( sys.argv[0] ) ), 'library' )
        if isdir( app_library ):
            result.extend( self._add_path( app_library ) )

        # Get all volumes in the standard Traits UI image library directory:
        result.extend(
            self._add_path( join( get_resource_path( 1 ), 'library' ) ) )

        # Check to see if there is an environment variable specifying a list
        # of paths containing image libraries:
        paths = environ.get( 'TRAITS_IMAGES' )
        if paths is not None:
            # Determine the correct OS path separator to use:
            separator = ';'
            if system() != 'Windows':
                separator = ':'

            # Add all image volumes found in each path in the environment
            # variable:
            for path in paths.split( separator ):
                result.extend( self._add_path( path ) )

        # Return the list of default volumes found:
        return result

    def _catalog_default ( self ):
        return dict( [ ( volume.name, volume ) for volume in self.volumes ] )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_images ( self ):
        return self._get_images_list()

    #-- Private Methods --------------------------------------------------------

    def _get_images_list ( self ):
        """ Returns the list of all library images.
        """
        # Merge the list of images from each volume:
        images = []
        for volume in self.volumes:
            images.extend( volume.images )

        # Sort the result:
        images.sort( key = lambda image: image.image_name )

        # Return the images list:
        return images

    def _add_path ( self, path ):
        """ Returns a list of ImageVolume objects, one for each image library
            located in the specified **path**.
        """
        result = []

        # Make sure the path is a directory:
        if isdir( path ):

            # Find each zip file in the directory:
            for base in listdir( path ):
                if splitext( base )[1] == '.zip':

                    # Try to create a volume from the zip file and add it to
                    # the result:
                    volume = self._add_volume( join( path, base ) )
                    if volume is not None:
                        result.append( volume )

        # Return the list of volumes found:
        return result

    def _add_volume ( self, path ):
        """ Returns an ImageVolume object for the image library specified by
            **path**. If **path** does not specify a valid ImageVolume, None is
            returned.
        """
        path = abspath( path )

        # Make sure the path is a valid zip file:
        if is_zipfile( path ):

            # Create a fast zip file for reading:
            zf = FastZipFile( path = path )

            # Extract the volume name from the path:
            volume_name = splitext( basename( path ) )[0]

            # Get the names of all top-level entries in the zip file:
            names = zf.namelist()

            # Check to see if there is a manifest file:
            if 'image_volume.py' in names:
                # Load the manifest code and extract the volume object:
                volume = get_python_value( zf.read( 'image_volume.py' ),
                                           'volume' )

                # Set the volume name:
                volume.name = volume_name

                # Try to add all of the external volume references as
                # aliases for this volume:
                self._add_aliases( volume )

                # Set the path to this volume:
                volume.path = path

                # Save the reference to the zip file object we are using:
                volume.zip_file = zf

            else:
                # Create a new volume from the zip file:
                volume =  ImageVolume( name     = volume_name,
                                       path     = path,
                                       zip_file = zf )

            # If this volume is not up to date, update it:
            if volume.time_stamp < time_stamp_for( stat( path )[ ST_MTIME ] ):
                # Note that the save could fail if the volume is read-only, but
                # that's OK, because we're only trying to do the save in case
                # a developer had added or deleted some image files, which would
                # require write access to the volume:
                volume.save()

            # Return the volume:
            return volume

        # Indicate no volume was found:
        return None

    def _add_aliases ( self, volume ):
        """ Try to add all of the external volume references as aliases for
            this volume.
        """
        aliases     = self.aliases
        volume_name = volume.name
        for vname in volume.aliases:
            if ((vname in aliases) and
                (volume_name != aliases[ vname ])):
                raise TraitError( ("Image library error: "
                    "Attempt to alias '%s' to '%s' when it is "
                    "already aliased to '%s'") %
                    ( vname, volume_name, aliases[ volume_name ] ) )
            aliases[ vname ] = volume_name

    def _duplicate_volume ( self, volume_name ):
        """ Raises a duplicate volume name error.
        """
        raise TraitError( ("Attempted to add an image volume called '%s' when "
                  "a volume with that name is already defined.") % volume_name )

# Create the singleton image object:
ImageLibrary = ImageLibrary()


########NEW FILE########
__FILENAME__ = include
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/18/2004
#
#------------------------------------------------------------------------------

""" Defines the Include class, which is used to represent a substitutable
    element within a user interface View.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Str

from .view_element import ViewSubElement

#-------------------------------------------------------------------------------
#  'Include' class:
#-------------------------------------------------------------------------------

class Include ( ViewSubElement ):
    """ A substitutable user interface element, i.e., a placeholder in a view
    definition.

    When a view object constructs an attribute-editing window, any Include
    objects within the view definition are replaced with a group or item
    defined elsewhere in the object's inheritance tree, based on matching of the
    name of the element. If no matching element is found, the Include object
    is ignored.

    An Include object can reference a group or item attribute on a parent class
    or on a subclass. For example, the following class contains a view
    definition that provides for the possibility that a subclass might add
    "extra" attributes in the middle of the view::

        class Person(HasTraits):
            name = Str
            age = Int
            person_view = View('name', Include('extra'), 'age', kind='modal')

    If you directly create an instance of Person, and edit its attributes,
    the Include object is ignored.

    The following class extends Person, and defines a group of "extra"
    attributes to add to the view defined on Person::

        class LocatedPerson(Person):
            street = Str
            city = Str
            state = Str
            zip = Int
            extra = Group('street', 'city', 'state', 'zip')

    The attribute-editing window for an instance of LocatedPerson displays
    editors for these extra attributes.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The name of the substitutable content
    id = Str

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, id, **traits ):
        """ Initializes the Include object.
        """
        super( ViewSubElement, self ).__init__( **traits )
        self.id = id

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of the Include:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" version of the Include object.
        """
        return "<%s>" % self.id


########NEW FILE########
__FILENAME__ = instance_choice
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt

#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/25/2005
#
#------------------------------------------------------------------------------

""" Defines the various instance descriptors used by the instance editor and
    instance editor factory classes.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, Str, Any, Dict, Tuple, Callable, Bool

from .ui_traits import AView

from .helper import user_name_for

#-------------------------------------------------------------------------------
#  'InstanceChoiceItem' class:
#-------------------------------------------------------------------------------

class InstanceChoiceItem ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # User interface name for the item
    name = Str

    # View associated with this item
    view = AView

    # Does this item create new instances?
    is_factory = Bool( False )

    #---------------------------------------------------------------------------
    #  Returns the name of the item:
    #---------------------------------------------------------------------------

    def get_name ( self, object = None ):
        """ Returns the name of the item.
        """
        return self.name

    #---------------------------------------------------------------------------
    #  Return the view associated with the object:
    #---------------------------------------------------------------------------

    def get_view ( self ):
        """ Returns the view associated with the object.
        """
        return self.view

    #---------------------------------------------------------------------------
    #  Returns the object associated with the item:
    #---------------------------------------------------------------------------

    def get_object ( self ):
        """ Returns the object associated with the item.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Indicates whether a specified object is compatible with the item:
    #---------------------------------------------------------------------------

    def is_compatible ( self, object ):
        """ Indicates whether a specified object is compatible with the item.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Indicates whether the item can be selected by the user:
    #---------------------------------------------------------------------------

    def is_selectable ( self ):
        """ Indicates whether the item can be selected by the user.
        """
        return True

    #---------------------------------------------------------------------------
    #  Indicates whether the item supports drag and drop:
    #---------------------------------------------------------------------------

    def is_droppable ( self ):
        """ Indicates whether the item supports drag and drop.
        """
        return False

#-------------------------------------------------------------------------------
#  'InstanceChoice' class:
#-------------------------------------------------------------------------------

class InstanceChoice ( InstanceChoiceItem ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Object associated with the item
    object = Any

    # The name of the object trait containing its user interface name:
    name_trait = Str( 'name' )

    #---------------------------------------------------------------------------
    #  Returns the name of the item:
    #---------------------------------------------------------------------------

    def get_name ( self, object = None ):
        """ Returns the name of the item.
        """
        if self.name != '':
            return self.name

        name = getattr( self.object, self.name_trait, None )
        if isinstance( name, basestring ):
            return name

        return user_name_for( self.object.__class__.__name__ )

    #---------------------------------------------------------------------------
    #  Returns the object associated with the item:
    #---------------------------------------------------------------------------

    def get_object ( self ):
        """ Returns the object associated with the item.
        """
        return self.object

    #---------------------------------------------------------------------------
    #  Indicates whether a specified object is compatible with the item:
    #---------------------------------------------------------------------------

    def is_compatible ( self, object ):
        """ Indicates whether a specified object is compatible with the item.
        """
        return (object is self.object)

#-------------------------------------------------------------------------------
#  'InstanceFactoryChoice' class:
#-------------------------------------------------------------------------------

class InstanceFactoryChoice ( InstanceChoiceItem ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Indicates whether an instance compatible with this item can be dragged and
    # dropped rather than created
    droppable = Bool( False )

    # Indicates whether the item can be selected by the user
    selectable = Bool( True )

    # A class (or other callable) that can be used to create an item compatible
    # with this item
    klass = Callable

    # Tuple of arguments to pass to **klass** to create an instance
    args = Tuple

    # Dictionary of arguments to pass to **klass** to create an instance
    kw_args = Dict( Str, Any )

    # Does this item create new instances? This value overrides the default.
    is_factory = True

    #---------------------------------------------------------------------------
    #  Returns the name of the item:
    #---------------------------------------------------------------------------

    def get_name ( self, object = None ):
        """ Returns the name of the item.
        """
        if self.name != '':
            return self.name

        name = getattr( object, 'name', None )
        if isinstance(name, basestring):
            return name

        if issubclass( type( self.klass ), type ):
            klass = self.klass
        else:
            klass = self.get_object().__class__

        return user_name_for( klass.__name__ )

    #---------------------------------------------------------------------------
    #  Returns the object associated with the item:
    #---------------------------------------------------------------------------

    def get_object ( self ):
        """ Returns the object associated with the item.
        """
        return self.klass( *self.args, **self.kw_args )

    #---------------------------------------------------------------------------
    #  Indicates whether the item supports drag and drop:
    #---------------------------------------------------------------------------

    def is_droppable ( self ):
        """ Indicates whether the item supports drag and drop.
        """
        return self.droppable

    #---------------------------------------------------------------------------
    #  Indicates whether a specified object is compatible with the item:
    #---------------------------------------------------------------------------

    def is_compatible ( self, object ):
        """ Indicates whether a specified object is compatible with the item.
        """
        if issubclass( type( self.klass ), type ):
            return isinstance( object, self.klass )
        return isinstance( object, self.get_object().__class__ )

    #---------------------------------------------------------------------------
    #  Indicates whether the item can be selected by the user:
    #---------------------------------------------------------------------------

    def is_selectable ( self ):
        """ Indicates whether the item can be selected by the user.
        """
        return self.selectable

#-------------------------------------------------------------------------------
#  'InstanceDropChoice' class:
#-------------------------------------------------------------------------------

class InstanceDropChoice ( InstanceFactoryChoice ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Indicates whether an instance compatible with this item can be dragged and
    # dropped rather than created . This value overrides the default.
    droppable = True

    # Indicates whether the item can be selected by the user. This value
    # overrides the default.
    selectable = False

    # Does this item create new instances? This value overrides the default.
    is_factory = False


########NEW FILE########
__FILENAME__ = item
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the Item class, which is used to represent a single item within
    a Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import re

from string import find, rfind

from traits.api import (Bool, Callable, Constant, Delegate, Float, Instance,
    Range, Str, Undefined, Dict,)

from traits.trait_base import user_name_for

from .view_element import ViewSubElement

from .ui_traits import convert_theme, ContainerDelegate, EditorStyle

from .editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Pattern of all digits:
all_digits = re.compile( r'\d+' )

# Pattern for finding size infomation embedded in an item description:
size_pat = re.compile( r"^(.*)<(.*)>(.*)$", re.MULTILINE | re.DOTALL )

# Pattern for finding tooltip infomation embedded in an item description:
tooltip_pat = re.compile( r"^(.*)`(.*)`(.*)$", re.MULTILINE | re.DOTALL )

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Reference to an EditorFactory:
ItemEditor = Instance( EditorFactory, allow_none = True )

# Amount of padding to add around an item:
Padding = Range( -15, 15, 0, desc = 'amount of padding to add around item' )

#-------------------------------------------------------------------------------
#  'Item' class:
#-------------------------------------------------------------------------------

class Item ( ViewSubElement ):
    """ An element in a Traits-based user interface.

    Magic:

    - Items are rendered as layout elements if :attr:`name` is set to
      special values:

      * name='', the item is rendered as a static label

      * name='_', the item is rendered as a separator

      * name=' ', the item is rendered as a 5 pixel spacer

      * name='23' (any number), the item is rendered as a spacer of
        the size specified (number of pixels)
    """

    # FIXME: all the logic for the name = '', '_', ' ', '23' magic is in
    # _GroupPanel._add_items in qt/ui_panel.py, which is a very unlikely place
    # to look for it. Ideally, that logic should be in this class.

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # A unique identifier for the item. If not set, it defaults to the value
    # of **name**.
    id = Str

    # User interface label for the item in the GUI. If this attribute is not
    # set, the label is the value of **name** with slight modifications:
    # underscores are replaced by spaces, and the first letter is capitalized.
    # If an item's **name** is not specified, its label is displayed as
    # static text, without any editor widget.
    label = Str

    # Name of the trait the item is editing:
    name = Str

    # Style-sheet to apply to item / group (Qt only)
    style_sheet = Str

    # Help text describing the purpose of the item. The built-in help handler
    # displays this text in a pop-up window if the user clicks the widget's
    # label. View-level help displays the help text for all items in a view.
    # If this attribute is not set, the built-in help handler generates a
    # description based on the trait definition.
    help = Str

    # The HasTraits object whose trait attribute the item is editing:
    object = ContainerDelegate

    # Presentation style for the item:
    style = ContainerDelegate

    # Docking style for the item:
    dock = ContainerDelegate

    # Image to display on notebook tabs:
    image = ContainerDelegate

    # The theme to use for the item itself:
    item_theme = ContainerDelegate

    # The theme to use for the item's label:
    label_theme = ContainerDelegate

    # Category of elements dragged from view:
    export = ContainerDelegate

    # Should a label be displayed for the item?
    show_label = Delegate( 'container', 'show_labels' )

    # Editor to use for the item:
    editor = ItemEditor

    # Additional editor traits to be set if default traits editor to be used:
    editor_args = Dict

    # Should the item use extra space along its Group's non-layout axis? If set to
    # True, the widget expands to fill any extra space that is available in the
    # display. If set to True for more than one item in the same View, any extra
    # space is divided between them. If set to False, the widget uses only
    # whatever space it is explicitly (or implicitly) assigned. The default
    # value of Undefined means that the use (or non-use) of extra space will be
    # determined by the editor associated with the item.
    resizable = Bool( Undefined )

    # Should the item use extra space along its Group's layout axis? For
    # example, it a vertical group, should an item expand vertically to use
    # any extra space available in the group?
    springy = Bool( False )

    # Should the item use any extra space along its Group's non-layout
    # orientation? For example, in a vertical group, should an item expand
    # horizontally to the full width of the group? If left to the default value
    # of Undefined, the decision will be left up to the associated item editor.
    full_size = Bool( Undefined )

    # Should the item's label use emphasized text? If the label is not shown,
    # this attribute is ignored.
    emphasized = Bool( False )

    # Should the item receive focus initially?
    has_focus = Bool( False )

    # Pre-condition for including the item in the display. If the expression
    # evaluates to False, the item is not defined in the display. Conditions
    # for **defined_when** are evaluated only once, when the display is first
    # constructed. Use this attribute for conditions based on attributes that
    # vary from object to object, but that do not change over time. For example,
    # displaying a 'maiden_name' item only for female employees in a company
    # database.
    defined_when = Str

    # Pre-condition for showing the item. If the expression evaluates to False,
    # the widget is not visible (and disappears if it was previously visible).
    # If the value evaluates to True, the widget becomes visible. All
    # **visible_when** conditions are checked each time that any trait value
    # is edited in the display. Therefore, you can use **visible_when**
    # conditions to hide or show widgets in response to user input.
    visible_when = Str

    # Pre-condition for enabling the item. If the expression evaluates to False,
    # the widget is disabled, that is, it does not accept input. All
    # **enabled_when** conditions are checked each time that any trait value
    # is edited in the display. Therefore, you can use **enabled_when**
    # conditions to enable or disable widgets in response to user input.
    enabled_when = Str

    # Amount of extra space, in pixels, to add around the item. Values must be
    # integers between -15 and 15. Use negative values to subtract from the
    # default spacing.
    padding = Padding

    # Tooltip to display over the item, when the mouse pointer is left idle
    # over the widget. Make this text as concise as possible; use the **help**
    # attribute to provide more detailed information.
    tooltip = Str

    # A Callable to use for formatting the contents of the item. This function
    # or method is called to create the string representation of the trait value
    # to be edited. If the widget does not use a string representation, this
    # attribute is ignored.
    format_func = Callable

    # Python format string to use for formatting the contents of the item.
    # The format string is applied to the string representation of the trait
    # value before it is displayed in the widget. This attribute is ignored if
    # the widget does not use a string representation, or if the
    # **format_func** is set.
    format_str = Str

    # Requested width of the editor (in pixels or fraction of available width).
    # For pixel values (i.e. values not in the range from 0.0 to 1.0), the
    # actual displayed width is at least the maximum of **width** and the
    # optimal width of the widget as calculated by the GUI toolkit. Specify a
    # negative value to ignore the toolkit's optimal width. For example, use
    # -50 to force a width of 50 pixels. The default value of -1 ensures that
    # the toolkit's optimal width is used.
    #
    # A value in the range from 0.0 to 1.0 specifies the fraction of the
    # available width to assign to the editor. Note that the value is not an
    # absolute value, but is relative to other item's whose **width** is also
    # in the 0.0 to 1.0 range. For example, if you have two item's with a width
    # of 0.1, and one item with a width of 0.2, the first two items will each
    # receive 25% of the available width, while the third item will receive
    # 50% of the available width. The available width is the total width of the
    # view minus the width of any item's with fixed pixel sizes (i.e. width
    # values not in the 0.0 to 1.0 range).
    width = Float( -1.0 )

    # Requested height of the editor (in pixels or fraction of available
    # height). For pixel values (i.e. values not in the range from 0.0 to 1.0),
    # the actual displayed height is at least the maximum of **height** and the
    # optimal height of the widget as calculated by the GUI toolkit. Specify a
    # negative value to ignore the toolkit's optimal height. For example, use
    # -50 to force a height of 50 pixels. The default value of -1 ensures that
    # the toolkit's optimal height is used.
    #
    # A value in the range from 0.0 to 1.0 specifies the fraction of the
    # available height to assign to the editor. Note that the value is not an
    # absolute value, but is relative to other item's whose **height** is also
    # in the 0.0 to 1.0 range. For example, if you have two item's with a height
    # of 0.1, and one item with a height of 0.2, the first two items will each
    # receive 25% of the available height, while the third item will receive
    # 50% of the available height. The available height is the total height of
    # the view minus the height of any item's with fixed pixel sizes (i.e.
    # height values not in the 0.0 to 1.0 range).
    height = Float( -1.0 )

    # The extended trait name of the trait containing the item's invalid state
    # status (passed through to the item's editor):
    invalid = Str

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, value = None, **traits ):
        """ Initializes the item object.
        """
        super( Item, self ).__init__( **traits )

        if value is None:
            return

        if not isinstance( value, basestring ):
            raise TypeError, ("The argument to Item must be a string of the "
                 "form: [id:][object.[object.]*][name]['['label']']`tooltip`"
                 "[<width[,height]>][#^][$|@|*|~|;style]")

        value, empty = self._parse_label( value )
        if empty:
            self.show_label = False

        value = self._parse_style( value )
        value = self._parse_size(  value )
        value = self._parse_tooltip( value )
        value = self._option( value, '#',  'resizable',  True )
        value = self._option( value, '^',  'emphasized', True )
        value = self._split( 'id',     value, ':', find,  0, 1 )
        value = self._split( 'object', value, '.', rfind, 0, 1 )

        if value != '':
            self.name = value

    #---------------------------------------------------------------------------
    #  Returns whether or not the object is replacable by an Include object:
    #---------------------------------------------------------------------------

    def is_includable ( self ):
        """ Returns a Boolean indicating whether the object is replaceable by an
            Include object.
        """
        return (self.id != '')

    #---------------------------------------------------------------------------
    #  Returns whether or not the Item represents a spacer or separator:
    #---------------------------------------------------------------------------

    def is_spacer ( self ):
        """ Returns True if the item represents a spacer or separator.
        """
        name = self.name.strip()

        return ((name == '') or (name == '_') or
                (all_digits.match( name ) is not None))

    #---------------------------------------------------------------------------
    #  Gets the help text associated with the Item in a specified UI:
    #---------------------------------------------------------------------------

    def get_help ( self, ui ):
        """ Gets the help text associated with the Item in a specified UI.
        """
        # Return 'None' if the Item is a separator or spacer:
        if self.is_spacer():
            return None

        # Otherwise, it must be a trait Item:
        if self.help != '':
            return self.help

        object = eval( self.object_, globals(), ui.context )

        return object.base_trait( self.name ).get_help()

    #---------------------------------------------------------------------------
    #  Gets the label to use for a specified Item in a specified UI:
    #---------------------------------------------------------------------------

    def get_label ( self, ui ):
        """ Gets the label to use for a specified Item.

        If not specified, the label is set as the name of the
        corresponding trait, replacing '_' with ' ', and capitalizing
        the first letter (see :func:`user_name_for`). This is called
        the *user name*.

        Magic:

        - if attr:`item.label` is specified, and it begins with '...',
          the final label is the user name followed by the item label
        - if attr:`item.label` is specified, and it ends with '...',
          the final label is the item label followed by the user name
        """
        # Return 'None' if the Item is a separator or spacer:
        if self.is_spacer():
            return None

        label = self.label
        if label != '':
            return label

        name   = self.name
        object = eval( self.object_, globals(), ui.context )
        trait  = object.base_trait( name )
        label  = user_name_for( name )
        tlabel = trait.label
        if tlabel is None:
            return label

        if isinstance( tlabel, basestring ):
            if tlabel[0:3] == '...':
                return label + tlabel[3:]
            if tlabel[-3:] == '...':
                return tlabel[:-3] + label
            if self.label != '':
                return self.label
            return tlabel

        return tlabel( object, name, label )

    #---------------------------------------------------------------------------
    #  Returns an id used to identify the item:
    #---------------------------------------------------------------------------

    def get_id ( self ):
        """ Returns an ID used to identify the item.
        """
        if self.id != '':
            return self.id

        return self.name

    #---------------------------------------------------------------------------
    #  Parses a '<width,height>' value from the string definition:
    #---------------------------------------------------------------------------

    def _parse_size ( self, value ):
        """ Parses a '<width,height>' value from the string definition.
        """
        match = size_pat.match( value )
        if match is not None:
            data  = match.group( 2 )
            value = match.group( 1 ) + match.group( 3 )
            col   = data.find( ',' )
            if col < 0:
                self._set_float( 'width', data )
            else:
                self._set_float( 'width',  data[ : col ] )
                self._set_float( 'height', data[ col + 1: ] )

        return value

    #---------------------------------------------------------------------------
    #  Parses a '`tooltip`' value from the string definition:
    #---------------------------------------------------------------------------

    def _parse_tooltip ( self, value ):
        """ Parses a *tooltip* value from the string definition.
        """
        match = tooltip_pat.match( value )
        if match is not None:
            self.tooltip = match.group( 2 )
            value        = match.group( 1 ) + match.group( 3 )

        return value

    #---------------------------------------------------------------------------
    #  Sets a specified trait to a specified string converted to a float:
    #---------------------------------------------------------------------------

    def _set_float ( self, name, value ):
        """ Sets a specified trait to a specified string converted to a float.
        """
        value = value.strip()
        if value != '':
            setattr( self, name, float( value ) )

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of the Item:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" version of the Item.
        """

        options = self._repr_options( 'id', 'object', 'label', 'style',
                                      'show_label', 'width', 'height' )
        if options is None:
            return "Item( '%s' )" % self.name

        return "Item( '%s'\n%s\n)" % (
               self.name, self._indent( options, '      ' ) )

#-------------------------------------------------------------------------------
#  'UItem' class:
#-------------------------------------------------------------------------------

class UItem ( Item ):
    """ An Item that has no label.
    """

    show_label = Bool( False )

#-------------------------------------------------------------------------------
#  'Custom' class:
#-------------------------------------------------------------------------------

class Custom ( Item ):
    """ An Item using a 'custom' style.
    """

    style = EditorStyle( 'custom' )

#-------------------------------------------------------------------------------
#  'UCustom' class:
#-------------------------------------------------------------------------------

class UCustom ( Custom ):
    """ An Item using a 'custom' style with no label.
    """

    show_label = Bool( False )

#-------------------------------------------------------------------------------
#  'Readonly' class:
#-------------------------------------------------------------------------------

class Readonly ( Item ):
    """ An Item using a 'readonly' style.
    """

    style = EditorStyle( 'readonly' )

#-------------------------------------------------------------------------------
#  'UReadonly' class:
#-------------------------------------------------------------------------------

class UReadonly ( Readonly ):
    """ An Item using a 'readonly' style with no label.
    """

    show_label = Bool( False )

#-------------------------------------------------------------------------------
#  'Label' class:
#-------------------------------------------------------------------------------

class Label ( Item ):
    """ An item that is a label.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, label, item_theme = None, **traits ):
        super( Label, self ).__init__(
            label      = label,
            item_theme = convert_theme( item_theme ),
            **traits
        )

#-------------------------------------------------------------------------------
#  'Heading' class:
#-------------------------------------------------------------------------------

class Heading ( Label ):
    """ An item that is a fancy label.
    """

    # Override the 'style' trait to default to the fancy 'custom' style:
    style = Constant( 'custom' )

#-------------------------------------------------------------------------------
#  'Spring' class:
#-------------------------------------------------------------------------------

class Spring ( Item ):
    """ An item that is a layout "spring".
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Name of the trait the item is editing
    name = 'spring'

    # Should a label be displayed?
    show_label = Bool( False )

    # Editor to use for the item
    editor = Instance( 'traitsui.api.NullEditor', () )

    # Should the item use extra space along its Group's layout orientation?
    springy = True

# A pre-defined spring for convenience
spring = Spring()


########NEW FILE########
__FILENAME__ = key_bindings
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   05/20/2005
#
#-------------------------------------------------------------------------------

""" Defines KeyBinding and KeyBindings classes, which manage the mapping of
    keystroke events into method calls on controller objects that are supplied
    by the application.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Event, HasPrivateTraits, HasStrictTraits, Instance, List,
    Property, Str, cached_property, on_trait_change)

from .api import HGroup, Item, KeyBindingEditor, ListEditor, View, toolkit

from traits.trait_base import SequenceTypes

#-------------------------------------------------------------------------------
#  Key binding trait definition:
#-------------------------------------------------------------------------------

# Trait definition for key bindings
Binding = Str( event = 'binding', editor = KeyBindingEditor() )

#-------------------------------------------------------------------------------
#  'KeyBinding' class:
#-------------------------------------------------------------------------------

class KeyBinding ( HasStrictTraits ):
    """ Binds one or two keystrokes to a method.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # First key binding
    binding1 = Binding

    # Second key binding
    binding2 = Binding

    # Description of what application function the method performs
    description = Str

    # Name of controller method the key is bound to
    method_name = Str

    # KeyBindings object that "owns" the KeyBinding
    owner = Instance( 'KeyBindings' )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View(
        HGroup(
            Item( 'binding1' ),
            Item( 'binding2' ),
            Item( 'description', style = 'readonly' ),
            show_labels = False
        )
    )

    #---------------------------------------------------------------------------
    #  Handles a binding trait being changed:
    #---------------------------------------------------------------------------

    def _binding_changed ( self ):
        if self.owner is not None:
            self.owner.binding_modified = self

#-------------------------------------------------------------------------------
#  'KeyBindings' class:
#-------------------------------------------------------------------------------

class KeyBindings ( HasPrivateTraits ):
    """ A set of key bindings.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Set of defined key bindings (redefined dynamically)
    bindings = List( KeyBinding )

    # Optional prefix to add to each method name
    prefix = Str

    # Optional suffix to add to each method name
    suffix = Str

    #-- Private Traits ---------------------------------------------------------

    # The (optional) list of controllers associated with this KeyBindings
    # object. The controllers may also be provided with the 'do' method:
    controllers = List( transient = True )

    # The 'parent' KeyBindings object of this one (if any):
    parent = Instance( 'KeyBindings', transient = True )

    # The root of the KeyBindings tree this object is part of:
    root = Property( depends_on = 'parent' )

    # The child KeyBindings of this object (if any):
    children = List( transient = True )

    # Event fired when one of the contained KeyBinding objects is changed
    binding_modified = Event( KeyBinding )

    # Control that currently has the focus (if any)
    focus_owner = Any( transient = True )

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ Item( 'bindings',
                                style      = 'custom',
                                show_label = False,
                                editor     = ListEditor( style = 'custom' ) ),
                          '|{Click on an entry field, then press the key to '
                          'assign. Double-click a field to clear it.}<>' ],
                        title     = 'Update Key Bindings',
                        kind      = 'livemodal',
                        resizable = True,
                        width     = 0.4,
                        height    = 0.4 )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, *bindings, **traits ):
        super( KeyBindings, self ).__init__( **traits )

        if (len( bindings ) == 1) and isinstance( bindings[0], SequenceTypes ):
            bindings = bindings[0]

        n = len( bindings )
        self.add_trait( 'bindings', List( KeyBinding, minlen = n,
                                                      maxlen = n,
                                                      mode   = 'list' ) )
        self.bindings = [ binding.set( owner = self ) for binding in bindings ]

    #---------------------------------------------------------------------------
    #  Processes a keyboard event:
    #---------------------------------------------------------------------------

    def do ( self, event, controllers = [], *args, **kw ):
        """ Processes a keyboard event.
        """
        if isinstance( controllers, dict ):
            controllers = controllers.values()
        elif not isinstance( controllers, SequenceTypes ):
            controllers = [ controllers ]
        else:
            controllers = list( controllers )

        return self._do( toolkit().key_event_to_name( event ),
                         controllers, args, kw.get( 'recursive', False ) )

    #---------------------------------------------------------------------------
    #  Merges another set of key bindings into this set:
    #---------------------------------------------------------------------------

    def merge ( self, key_bindings ):
        """ Merges another set of key bindings into this set.
        """
        binding_dic = {}
        for binding in self.bindings:
            binding_dic[ binding.method_name ] = binding

        for binding in key_bindings.bindings:
            binding2 = binding_dic.get( binding.method_name )
            if binding2 is not None:
                binding2.binding1 = binding.binding1
                binding2.binding2 = binding.binding2

    #---------------------------------------------------------------------------
    #  Returns a clone of the KeyBindings object:
    #---------------------------------------------------------------------------

    def clone ( self, **traits ):
        """ Returns a clone of the KeyBindings object.
        """
        return self.__class__( *self.bindings, **traits ).set(
                               **self.get( 'prefix', 'suffix' ) )

    #---------------------------------------------------------------------------
    #  Dispose of the object:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Dispose of the object.
        """
        if self.parent is not None:
            self.parent.children.remove( self )

        del self.controllers
        del self.children
        del self.bindings

        self.parent = self._root = self.focus_owner = None

    #---------------------------------------------------------------------------
    #  Edits a possibly hierarchical set of KeyBindings:
    #---------------------------------------------------------------------------

    def edit ( self ):
        """ Edits a possibly hierarchical set of KeyBindings.
        """
        bindings = list( set( self.root._get_bindings( [] ) ) )
        bindings.sort( lambda l, r:
            cmp( '%s%02d' % ( l.binding1[-1:], len( l.binding1 ) ),
                 '%s%02d' % ( r.binding1[-1:], len( r.binding1 ) ) ) )
        KeyBindings( bindings ).edit_traits()

    #---------------------------------------------------------------------------
    #  Returns the current binding for a specified key (if any):
    #---------------------------------------------------------------------------

    def key_binding_for ( self, binding, key_name ):
        """ Returns the current binding for a specified key (if any).
        """
        if key_name != '':
            for a_binding in self.bindings:
                if ((a_binding is not binding) and
                    ((key_name == a_binding.binding1) or
                     (key_name == a_binding.binding2))):
                    return a_binding

        return None

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_root ( self ):
        root = self
        while root.parent is not None:
            root = root.parent

        return root

    #-- Event Handlers ---------------------------------------------------------

    def _binding_modified_changed ( self, binding ):
        """ Handles a binding being changed.
        """
        binding1 = binding.binding1
        binding2 = binding.binding2
        for a_binding in self.bindings:
            if binding is not a_binding:
                if binding1 == a_binding.binding1:
                    a_binding.binding1 = ''
                if binding1 == a_binding.binding2:
                    a_binding.binding2 = ''
                if binding2 == a_binding.binding1:
                    a_binding.binding1 = ''
                if binding2 == a_binding.binding2:
                    a_binding.binding2 = ''

    def _focus_owner_changed ( self, old, new ):
        """ Handles the focus owner being changed.
        """
        if old is not None:
            old.border_size = 0

    @on_trait_change( 'children[]' )
    def _children_modified ( self, removed, added ):
        """ Handles child KeyBindings being added to the object.
        """
        for item in added:
            item.parent = self

    #-- object Method Overrides ------------------------------------------------

    #---------------------------------------------------------------------------
    #  Restores the state of a previously pickled object:
    #---------------------------------------------------------------------------

    def __setstate__ ( self, state ):
        """ Restores the state of a previously pickled object.
        """
        n = len( state[ 'bindings' ] )
        self.add_trait( 'bindings', List( KeyBinding, minlen = n, maxlen = n ) )
        self.__dict__.update( state )
        self.bindings = self.bindings[:]

    #-- Private Methods --------------------------------------------------------

    def _get_bindings ( self, bindings ):
        """ Returns all of the bindings of this object and all of its children.
        """
        bindings.extend( self.bindings )
        for child in self.children:
            child._get_bindings( bindings )

        return bindings

    def _do ( self, key_name, controllers, args, recursive ):
        """ Process the specified key for the specified set of controllers for
            this KeyBindings object and all of its children.
        """
        # Search through our own bindings for a match:
        for binding in self.bindings:
            if (key_name == binding.binding1) or (key_name == binding.binding2):
                method_name = '%s%s%s' % (
                              self.prefix, binding.method_name, self.suffix )
                for controller in (controllers + self.controllers):
                    method = getattr( controller, method_name, None )
                    if method is not None:
                        result = method( *args )
                        if result is not False:
                            return True

                if binding.method_name == 'edit_bindings':
                    self.edit()
                    return True

        # If recursive, continue searching through a children's bindings:
        if recursive:
            for child in self.children:
                if child._do( key_name, controllers, args, recursive ):
                    return True

        # Indicate no one processed the key:
        return False


########NEW FILE########
__FILENAME__ = list_str_adapter
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   02/29/2008
#
#-------------------------------------------------------------------------------

"""  Defines adapter interfaces for use with the ListStrEditor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Bool, Color, Enum, Event, HasPrivateTraits, Int,
    Interface, List, Str, on_trait_change, provides)

#-------------------------------------------------------------------------------
#  'IListStrAdapter' interface:
#-------------------------------------------------------------------------------

class IListStrAdapter ( Interface ):

    # The index of the current item being adapted:
    index = Int

    # Current item being adapted:
    item = Any

    # The current value (if any):
    value = Any

    # Does the adapter know how to handler the current *item* or not:
    accepts = Bool

    # Does the value of *accepts* depend only upon the type of *item*?
    is_cacheable = Bool

#-------------------------------------------------------------------------------
#  'AnIListStrAdapter' class:
#-------------------------------------------------------------------------------

@provides(IListStrAdapter)
class AnIListStrAdapter ( HasPrivateTraits ):

    #-- Implementation of the IListStrAdapter Interface ------------------------

    # The index of the current item being adapted:
    index = Int

    # Current item being adapted:
    item = Any

    # The current value (if any):
    value = Any

    # Does the adapter know how to handler the current *item* or not:
    accepts = Bool( True )

    # Does the value of *accepts* depend only upon the type of *item*?
    is_cacheable = Bool( True )

#-------------------------------------------------------------------------------
#  'ListStrAdapter' class:
#-------------------------------------------------------------------------------

class ListStrAdapter ( HasPrivateTraits ):
    """ The base class for adapting list items to values that can be edited
        by a ListStrEditor.
    """

    #-- Trait Definitions ------------------------------------------------------

    # Specifies the default value for a new list item:
    default_value = Any( '' )

    # Specifies the default text for a new list item:
    default_text = Str

    # The default text color for list items (even, odd, any rows):
    even_text_color = Color( None, update = True )
    odd_text_color  = Color( None, update = True )
    text_color      = Color( None, update = True )

    # The default background color for list items (even, odd, any rows):
    even_bg_color = Color( None, update = True )
    odd_bg_color  = Color( None, update = True )
    bg_color      = Color( None, update = True )

    # The name of the default image to use for list items:
    image = Str( None, update = True )

    # Can the text value of each list item be edited:
    can_edit = Bool( True )

    # Specifies where a dropped item should be placed in the list relative to
    # the item it is dropped on:
    dropped = Enum( 'after', 'before' )

    # The index of the current item being adapter:
    index = Int

    # The current item being adapted:
    item = Any

    # The current value (if any):
    value = Any

    # List of optional delegated adapters:
    adapters = List( IListStrAdapter, update = True )

    #-- Private Trait Definitions ----------------------------------------------

    # Cache of attribute handlers:
    cache = Any( {} )

    # Event fired when the cache is flushed:
    cache_flushed = Event( update = True )

    #-- Adapter methods that are sensitive to item type ------------------------

    def get_can_edit ( self, object, trait, index ):
        """ Returns whether the user can edit a specified *object.trait[index]*
            list item. A True result indicates the value can be edited, while
            a False result indicates that it cannot be edited.
        """
        return self._result_for( 'get_can_edit', object, trait, index )

    def get_drag ( self, object, trait, index ):
        """ Returns the 'drag' value for a specified *object.trait[index]*
            list item. A result of *None* means that the item cannot be dragged.
        """
        return self._result_for( 'get_drag', object, trait, index )

    def get_can_drop ( self, object, trait, index, value ):
        """ Returns whether the specified *value* can be dropped on the
            specified *object.trait[index]* list item. A value of **True** means
            the *value* can be dropped; and a value of **False** indicates that
            it cannot be dropped.
        """
        return self._result_for( 'get_can_drop', object, trait, index, value )

    def get_dropped ( self, object, trait, index, value ):
        """ Returns how to handle a specified *value* being dropped on a
            specified *object.trait[index]* list item. The possible return
            values are:

            'before'
                Insert the specified *value* before the dropped on item.
            'after'
                Insert the specified *value* after the dropped on item.
        """
        return self._result_for( 'get_dropped', object, trait, index, value )

    def get_text_color ( self, object, trait, index ):
        """ Returns the text color for a specified *object.trait[index]* list
            item. A result of None means use the default list item text color.
        """
        return self._result_for( 'get_text_color', object, trait, index )

    def get_bg_color ( self, object, trait, index ):
        """ Returns the background color for a specified *object.trait[index]*
            list item. A result of None means use the default list item
            background color.
        """
        return self._result_for( 'get_bg_color', object, trait, index )

    def get_image ( self, object, trait, index ):
        """ Returns the name of the image to use for a specified
            *object.trait[index]* list item. A result of None means no image
            should be used. Otherwise, the result should either be the name of
            the image, or an ImageResource item specifying the image to use.
        """
        return self._result_for( 'get_image', object, trait, index )

    def get_item ( self, object, trait, index ):
        """ Returns the value of the *object.trait[index]* list item.
        """
        return self._result_for( 'get_item', object, trait, index )

    def get_text ( self, object, trait, index ):
        """ Returns the text to display for a specified *object.trait[index]*
            list item.
        """
        return self._result_for( 'get_text', object, trait, index )

    #-- Adapter methods that are not sensitive to item type --------------------

    def len ( self, object, trait ):
        """ Returns the number of items in the specified *object.trait* list.
        """
        return len( getattr( object, trait ) )

    def get_default_value ( self, object, trait ):
        """ Returns a new default value for the specified *object.trait* list.
        """
        return self.default_value

    def get_default_text ( self, object, trait ):
        """ Returns the default text for the specified *object.trait* list.
        """
        return self.default_text

    def get_default_image ( self, object, trait ):
        """ Returns the default image for the specified *object.trait* list.
        """
        return self.image

    def get_default_bg_color ( self, object, trait ):
        """ Returns the default background color for the specified
            *object.trait* list.
        """
        return self._get_bg_color()

    def get_default_text_color ( self, object, trait ):
        """ Returns the default text color for the specified *object.trait*
            list.
        """
        return self._get_text_color()

    def set_text ( self, object, trait, index, text ):
        """ Sets the text for a specified *object.trait[index]* list item to
            *text*.
        """
        getattr( object, trait )[ index ] = text

    def delete ( self, object, trait, index ):
        """ Deletes the specified *object.trait[index]* list item.
        """
        del getattr( object, trait )[ index ]

    def insert ( self, object, trait, index, value ):
        """ Inserts a new value at the specified *object.trait[index]* list
            index.
        """
        getattr( object, trait ) [ index: index ] = [ value ]

    #-- Private Adapter Implementation Methods ---------------------------------

    def _get_can_edit ( self ):
        return self.can_edit

    def _get_drag ( self ):
        return unicode( self.item )

    def _get_can_drop ( self ):
        return isinstance( self.value, basestring )

    def _get_dropped ( self ):
        return self.dropped

    def _get_text_color ( self ):
        if (self.index % 2) == 0:
            return self.even_text_color_ or self.text_color_

        return self.odd_text_color or self.text_color_

    def _get_bg_color ( self ):
        if (self.index % 2) == 0:
            return self.even_bg_color_ or self.bg_color_

        return self.odd_bg_color or self.bg_color_

    def _get_image ( self ):
        return self.image

    def _get_item ( self ):
        return self.item

    def _get_text ( self ):
        return unicode( self.item )

    #-- Private Methods --------------------------------------------------------

    def _result_for ( self, name, object, trait, index, value = None ):
        """ Returns/Sets the value of the specified *name* attribute for the
            specified *object.trait[index]* list item.
        """
        self.index = index
        self.value = value
        items      = getattr( object, trait )
        if index >= len( items ):
            self.item = item = None
        else:
            self.item = item = items[ index ]

        item_class = item.__class__
        key        = '%s:%s' % ( item_class.__name__, name )
        handler    = self.cache.get( key )
        if handler is not None:
            return handler()

        trait_name = name[4:]

        for adapter in self.adapters:
            adapter.index = index
            adapter.item  = item
            adapter.value = value
            if adapter.accepts and (adapter.trait( trait_name ) is not None):
                handler = lambda: getattr( adapter.set( index = self.index,
                            item = self.item, value = self.value ), trait_name )

                if adapter.is_cacheable:
                    break

                return handler()
        else:
            for klass in item_class.__mro__:
                cname = '%s_%s' % ( klass.__name__, trait_name )
                if self.trait( cname ) is not None:
                    handler = lambda: getattr( self, cname )
                    break
            else:
                handler = getattr( self, '_' + name )

        self.cache[ key ] = handler
        return handler()

    @on_trait_change( 'adapters.+update' )
    def _flush_cache ( self ):
        """ Flushes the cache when any trait on any adapter changes.
        """
        self.cache = {}
        self.cache_flushed = True


########NEW FILE########
__FILENAME__ = menu
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/19/2004
#
#------------------------------------------------------------------------------

""" Defines the standard menu bar for use with Traits UI windows and panels,
    and standard actions and buttons.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Str

# Import and rename the needed PyFace elements:
from pyface.action.api import ToolBarManager as ToolBar
from pyface.action.api import MenuBarManager as MenuBar
from pyface.action.api import MenuManager as Menu
from pyface.action.api import Group as ActionGroup
from pyface.action.api import Action as PyFaceAction

#-------------------------------------------------------------------------------
#  'Action' class (extends the core pyface Action class):
#-------------------------------------------------------------------------------

class Action ( PyFaceAction ):
    """ An action on a menu bar in a Traits UI window or panel.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Pre-condition for showing the action. If the expression evaluates to False,
    # the action is not visible (and disappears if it was previously visible).
    # If the value evaluates to True, the action becomes visible. All
    # **visible_when** conditions are checked each time that any trait value
    # is edited in the display. Therefore, you can use **visible_when**
    # conditions to hide or show actions in response to user input.
    visible_when = Str

    # Pre-condition for enabling the action. If the expression evaluates to
    # False, the action is disabled, that is, it cannot be selected. All
    # **enabled_when** conditions are checked each time that any trait value
    # is edited in the display. Therefore, you can use **enabled_when**
    # conditions to enable or disable actions in response to user input.
    enabled_when = Str

    # Boolean expression indicating when the action is displayed with a check
    # mark beside it. This attribute applies only to actions that are included
    # in menus.
    checked_when = Str

    # Pre-condition for including the action in the menu bar or toolbar. If the
    # expression evaluates to False, the action is not defined in the display.
    # Conditions for **defined_when** are evaluated only once, when the display
    # is first constructed.
    defined_when = Str

    # The method to call to perform the action, on the Handler for the window.
    # The method must accept a single parameter, which is a UIInfo object.
    # Because Actions are associated with Views rather than Handlers, you must
    # ensure that the Handler object for a particular window has a method with
    # the correct name, for each Action defined on the View for that window.
    action = Str

#-------------------------------------------------------------------------------
#  Standard actions and menu bar definitions:
#-------------------------------------------------------------------------------

# Menu separator:
Separator = ActionGroup

# The standard "close window" action:
CloseAction = Action(
    name   = 'Close',
    action = '_on_close'
)

# The standard "undo last change" action:
UndoAction = Action(
    name         = 'Undo',
    action       = '_on_undo',
    defined_when = 'ui.history is not None',
    enabled_when = 'ui.history.can_undo'
)

# The standard "redo last undo" action:
RedoAction = Action(
    name         = 'Redo',
    action       = '_on_redo',
    defined_when = 'ui.history is not None',
    enabled_when = 'ui.history.can_redo'
)

# The standard "revert all changes" action:
RevertAction = Action(
    name         = 'Revert',
    action       = '_on_revert',
    defined_when = 'ui.history is not None',
    enabled_when = 'ui.history.can_undo'
)

# The standard "show help" action:
HelpAction = Action(
    name   = 'Help',
    action = 'show_help'
)

# The standard Traits UI menu bar:
StandardMenuBar = MenuBar(
    Menu( CloseAction,
          name = 'File' ),
    Menu( UndoAction,
          RedoAction,
          RevertAction,
          name = 'Edit' ),
    Menu( HelpAction,
          name = 'Help' )
)

#-------------------------------------------------------------------------------
#  Standard buttons (i.e. actions):
#-------------------------------------------------------------------------------

NoButton = Action( name = '' )

# Appears as two buttons: **Undo** and **Redo**. When **Undo** is clicked, the
# most recent change to the data is cancelled, restoring the previous value.
# **Redo** cancels the most recent "undo" operation.
UndoButton = Action( name = 'Undo' )

# When the user clicks the **Revert** button, all changes made in the window are
# cancelled and the original values are restored. If the changes have been
# applied to the model (because the user clicked **Apply** or because the window
# is live), the model data is restored as well. The window remains open.
RevertButton = Action( name = 'Revert' )

# When theuser clicks the **Apply** button, all changes made in the window are
# applied to the model. This option is meaningful only for modal windows.
ApplyButton = Action( name = 'Apply' )

# When the user clicks the **OK** button, all changes made in the window are
# applied to the model, and the window is closed.
OKButton = Action( name = 'OK' )

# When the user clicks the **Cancel** button, all changes made in the window
# are discarded; if the window is live, the model is restored to the values it
# held before the window was opened. The window is then closed.
CancelButton = Action( name = 'Cancel' )

# When the user clicks the **Help** button, the current help handler is
# invoked. If the default help handler is used, a pop-up window is displayed,
# which contains the **help** text for the top-level Group (if any), and for
# the items in the view. If the default help handler has been overridden,
# the action is determined by the custom help handler. See
# **traitsui.help**.
HelpButton = Action( name = 'Help' )

OKCancelButtons = [ OKButton, CancelButton ]
ModalButtons = [ ApplyButton, RevertButton, OKButton, CancelButton, HelpButton ]
LiveButtons  = [ UndoButton,  RevertButton, OKButton, CancelButton, HelpButton ]

# The window has no command buttons:
NoButtons = [ NoButton ]


########NEW FILE########
__FILENAME__ = message
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   09/01/2005
#
#------------------------------------------------------------------------------

""" Displays a message to the user as a modal window.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, Str, Float

from .view import View

from .group import HGroup

from .item import Item, spring

from pyface.timer.api import do_after

#-------------------------------------------------------------------------------
#  'Message' class:
#-------------------------------------------------------------------------------

class Message ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The message to be displayed
    message = Str

#-------------------------------------------------------------------------------
#  Displays a user specified message:
#-------------------------------------------------------------------------------

def message ( message = '', title = 'Message', buttons = [ 'OK' ],
              parent  = None ):
    """ Displays a message to the user as a model window with the specified
    title and buttons.

    If *buttons* is not specified, a single **OK** button is used, which is
    appropriate for notifications, where no further action or decision on the
    user's part is required.
    """
    msg = Message( message = message )
    ui  = msg.edit_traits( parent = parent,
                           view   = View( [ 'message~', '|<>' ],
                                          title   = title,
                                          buttons = buttons,
                                          kind    = 'modal' ) )
    return ui.result

#-------------------------------------------------------------------------------
#  Displays a user specified error message:
#-------------------------------------------------------------------------------

def error ( message = '', title = 'Message', buttons = [ 'OK', 'Cancel' ],
            parent  = None ):
    """ Displays a message to the user as a modal window with the specified
    title and buttons.

    If *buttons* is not specified, **OK** and **Cancel** buttons are used,
    which is appropriate for confirmations, where the user must decide whether
    to proceed. Be sure to word the message so that it is clear that clicking
    **OK** continues the operation.
    """
    msg = Message( message = message )
    ui  = msg.edit_traits( parent = parent,
                           view   = View( [ 'message~', '|<>' ],
                                          title   = title,
                                          buttons = buttons,
                                          kind    = 'modal' ) )
    return ui.result


#-------------------------------------------------------------------------------
#  'AutoCloseMessage' class:
#-------------------------------------------------------------------------------

class AutoCloseMessage ( HasPrivateTraits ):

    # The message to be shown:
    message = Str( 'Please wait' )

    # The time (in seconds) to show the message:
    time = Float( 2.0 )

    def show ( self, parent = None, title = '' ):
        """ Display the wait message for a limited duration.
        """
        view = View(
            HGroup(
                spring,
                Item( 'message',
                      show_label = False,
                      style      = 'readonly'
                ),
                spring
            ),
            title = title
        )

        do_after( int( 1000.0 * self.time ),
                  self.edit_traits( parent = parent, view = view ).dispose )

#-------------------------------------------------------------------------------
#  Displays a user specified message that closes automatically after a specified
#  time interval:
#-------------------------------------------------------------------------------

def auto_close_message ( message = 'Please wait', time   = 2.0,
                         title   = 'Please wait', parent = None ):
    """ Displays a message to the user as a modal window with no buttons. The
        window closes automatically after a specified time interval (specified
        in seconds).
    """
    msg = AutoCloseMessage( message = message, time = time )
    msg.show( parent = parent, title = title )


########NEW FILE########
__FILENAME__ = mimedata
# Import the toolkit specific version.
from traitsui.toolkit import toolkit_object

# WIP: Currently only supports qt4 backend. API might change without
# prior notification
PyMimeData = toolkit_object('clipboard:PyMimeData')
########NEW FILE########
__FILENAME__ = color_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   02/14/2005
#
#------------------------------------------------------------------------------

""" Trait definition for a null-based (i.e., no UI) color.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Trait, TraitError

#-------------------------------------------------------------------------------
#  Convert a number into a wxColour object:
#-------------------------------------------------------------------------------

def convert_to_color ( object, name, value ):
    """ Converts a number into a wxColour object.
    """
    if type( value ) is int:
        return value & 0xFFFFFF

    elif isinstance( value, tuple ):
        return (value[0]/255., value[1]/255., value[2]/255.)

    raise TraitError

convert_to_color.info = ('an integer which in hex is of the form 0xRRGGBB, '
                         'where RR is red, GG is green, and BB is blue')

#-------------------------------------------------------------------------------
#  Standard colors:
#-------------------------------------------------------------------------------

standard_colors = {
    'aquamarine':          0x70DB93,
    'black':               0x000000,
    'blue':                0x0000FF,
    'blue violet':         0x9F5F9F,
    'brown':               0xA52A2A,
    'cadet blue':          0x5F9F9F,
    'coral':               0xFF7F00,
    'cornflower blue':     0x42426F,
    'cyan':                0x00FFFF,
    'dark grey':           0x2F2F2F,
    'dark green':          0x2F4F2F,
    'dark olive green':    0x4F4F2F,
    'dark orchid':         0x9932CC,
    'dark slate blue':     0x6B238E,
    'dark slate grey':     0x2F4F4F,
    'dark turquoise':      0x7093DB,
    'dim grey':            0x545454,
    'firebrick':           0x8E2323,
    'forest green':        0x238E23,
    'gold':                0xCC7F32,
    'goldenrod':           0xDBDB70,
    'grey':                0x808080,
    'green':               0x00FF00,
    'green yellow':        0x93DB70,
    'indian red':          0x4F2F2F,
    'khaki':               0x9F9F5F,
    'light blue':          0xBFD8D8,
    'light grey':          0xC0C0C0,
    'light steel':         0x000000,
    'blue':                0x0000FF,
    'lime green':          0x32CC32,
    'magenta':             0xFF00FF,
    'maroon':              0x8E236B,
    'medium aquamarine':   0x32CC99,
    'medium blue':         0x3232CC,
    'medium forest green': 0x6B8E23,
    'medium goldenrod':    0xEAEAAD,
    'medium orchid':       0x9370DB,
    'medium sea green':    0x426F42,
    'medium slate blue':   0x7F00FF,
    'medium spring green': 0x7FFF00,
    'medium turquoise':    0x70DBDB,
    'medium violet red':   0xDB7093,
    'midnight blue':       0x2F2F4F,
    'navy':                0x23238E,
    'orange':              0xCC3232,
    'orange red':          0xFF007F,
    'orchid':              0xDB70DB,
    'pale green':          0x8FBC8F,
    'pink':                0xBC8FEA,
    'plum':                0xEAADEA,
    'purple':              0xB000FF,
    'red':                 0xFF0000,
    'salmon':              0x6F4242,
    'sea green':           0x238E6B,
    'sienna':              0x8E6B23,
    'sky blue':            0x3299CC,
    'slate blue':          0x007FFF,
    'spring green':        0x00FF7F,
    'steel blue':          0x236B8E,
    'tan':                 0xDB9370,
    'thistle':             0xD8BFD8,
    'turquoise':           0xADEAEA,
    'violet':              0x4F2F4F,
    'violet red':          0xCC3299,
    'wheat':               0xD8D8BF,
    'white':               0xFFFFFF,
    'yellow':              0xFFFF00,
    'yellow green':        0x99CC32
}

#-------------------------------------------------------------------------------
#  Define 'null' specific color traits:
#-------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the ColorEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a Color trait which lead to this file getting
# imported. This leads to a circular import when declaring a Color trait.
def get_color_editor(*args, **traits):
    from ..api import ColorEditor
    return ColorEditor(*args, **traits)

# Color traits
NullColor = Trait( 'white', convert_to_color, standard_colors,
                   editor = get_color_editor )


########NEW FILE########
__FILENAME__ = font_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   02/14/2005
#
#------------------------------------------------------------------------------

""" Trait definition for a null-based (i.e., no UI) font.
"""

#------------------------------------------------------------------------------
#  Imports:
#------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Trait, TraitHandler, TraitError

#------------------------------------------------------------------------------
#  Convert a string into a valid 'wxFont' object (if possible):
#------------------------------------------------------------------------------

# Mapping of strings to valid wxFont families
font_families = [
    'default',
    'decorative',
    'roman',
    'script',
    'swiss',
    'modern'
]

# Mapping of strings to wxFont styles
font_styles = [
    'slant',
    'italic'
]

# Mapping of strings wxFont weights
font_weights = [
    'light',
    'bold'
]

# Strings to ignore in text representations of fonts
font_noise = ['pt', 'point', 'family']


#------------------------------------------------------------------------------
#  'TraitFont' class'
#------------------------------------------------------------------------------

class TraitFont(TraitHandler):
    """ Ensures that values assigned to a trait attribute are valid font
    descriptor strings; the value actually assigned is the corresponding
    canonical font descriptor string.
    """
    #--------------------------------------------------------------------------
    #  Validates that the value is a valid font:
    #--------------------------------------------------------------------------

    def validate(self, object, name, value):
        """ Validates that the value is a valid font descriptor string.
        """
        try:
            point_size = family = style = weight = underline = ''
            facename = ['']
            for word in value.split():
                lword = word.lower()
                if lword in font_families:
                    family = ' ' + lword
                elif lword in font_styles:
                    style = ' ' + lword
                elif lword in font_weights:
                    weight = ' ' + lword
                elif lword == 'underline':
                    underline = ' ' + lword
                elif lword not in font_noise:
                    try:
                        int(lword)
                        point_size = lword + ' pt'
                    except:
                        facename.append(word)
            fontstr = ('%s%s%s%s%s%s' % (point_size, family, style, weight,
                        underline, ' '.join(facename))).strip()
            return fontstr
        except Exception:
            pass
        raise TraitError(object, name, 'a font descriptor string',
                            repr(value))

    def info(self):
        return ("a string describing a font (e.g. '12 pt bold italic "
                "swiss family Arial' or 'default 12')")


#------------------------------------------------------------------------------
#  Define a 'null' specific font trait:
#------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the FontEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a Font trait which lead to this file getting
# imported. This leads to a circular import when declaring a Font trait.
def get_font_editor(*args, **traits):
    from ..api import FontEditor
    return FontEditor(*args, **traits)

fh = TraitFont()
NullFont = Trait(fh.validate(None, None, 'Arial 10'), fh,
                editor=get_font_editor)

########NEW FILE########
__FILENAME__ = rgb_color_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Data:   02/14/2005
#
#------------------------------------------------------------------------------

""" Trait definitions for an RGB-based color, which is a tuple of the form
    (*red*, *green*, *blue*), where *red*, *green* and *blue* are floats in the
    range from 0.0 to 1.0.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Trait, TraitError

from traits.trait_base import SequenceTypes

#-------------------------------------------------------------------------------
#  Convert a number into an RGB tuple:
#-------------------------------------------------------------------------------

def range_check ( value ):
    """ Checks that *value* can be converted to a value in the range 0.0 to 1.0.

    If so, it returns the floating point value; otherwise, it raises a TraitError.
    """
    value = float( value )
    if 0.0 <= value <= 1.0:
        return value
    raise TraitError

def convert_to_color ( object, name, value ):
    """ Converts a tuple or an integer to an RGB color value, or raises a
    TraitError if that is not possible.
    """
    if (type( value ) in SequenceTypes) and (len( value ) == 3):
        return ( range_check( value[0] ),
                 range_check( value[1] ),
                 range_check( value[2] ) )
    if type( value ) is int:
        num = int( value )
        return ( (num / 0x10000)        / 255.0
                 ((num / 0x100) & 0xFF) / 255.0,
                 (num & 0xFF)           / 255.0 )
    raise TraitError

convert_to_color.info = ('a tuple of the form (r,g,b), where r, g, and b '
    'are floats in the range from 0.0 to 1.0, or an integer which in hex is of '
    'the form 0xRRGGBB, where RR is red, GG is green, and BB is blue')

#-------------------------------------------------------------------------------
#  Standard colors:
#-------------------------------------------------------------------------------

# RGB versions of standard colors
rgb_standard_colors = {
    'aquamarine':           ( 0.439216, 0.858824, 0.576471 ),
    'black':                ( 0.0, 0.0, 0.0 ),
    'blue':                 ( 0.0, 0.0, 1.0 ),
    'blue violet':          ( 0.623529, 0.372549, 0.623529 ),
    'brown':                ( 0.647059, 0.164706, 0.164706 ),
    'cadet blue':           ( 0.372549, 0.623529, 0.623529 ),
    'coral':                ( 1.0, 0.498039, 0.0 ),
    'cornflower blue':      ( 0.258824, 0.258824, 0.435294 ),
    'cyan':                 ( 0.0, 1.0, 1.0 ),
    'dark grey':            ( 0.184314, 0.184314, 0.184314 ),
    'dark green':           ( 0.184314, 0.309804, 0.184314 ),
    'dark olive green':     ( 0.309804, 0.309804, 0.184314 ),
    'dark orchid':          ( 0.6, 0.196078, 0.8 ),
    'dark slate blue':      ( 0.419608, 0.137255, 0.556863 ),
    'dark slate grey':      ( 0.184314, 0.309804, 0.309804 ),
    'dark turquoise':       ( 0.439216, 0.576471, 0.858824 ),
    'dim grey':             ( 0.329412, 0.329412, 0.329412 ),
    'firebrick':            ( 0.556863, 0.137255, 0.137255 ),
    'forest green':         ( 0.137255, 0.556863, 0.137255 ),
    'gold':                 ( 0.8, 0.498039, 0.196078 ),
    'goldenrod':            ( 0.858824, 0.858824, 0.439216 ),
    'grey':                 ( 0.501961, 0.501961, 0.501961 ),
    'green':                ( 0.0, 1.0, 0.0 ),
    'green yellow':         ( 0.576471, 0.858824, 0.439216 ),
    'indian red':           ( 0.309804, 0.184314, 0.184314 ),
    'khaki':                ( 0.623529, 0.623529, 0.372549 ),
    'light blue':           ( 0.74902, 0.847059, 0.847059 ),
    'light grey':           ( 0.752941, 0.752941, 0.752941 ),
    'light steel':          ( 0.0, 0.0, 0.0 ),
    'blue':                 ( 0.0, 0.0, 1.0 ),
    'lime green':           ( 0.196078, 0.8, 0.196078 ),
    'magenta':              ( 1.0, 0.0, 1.0 ),
    'maroon':               ( 0.556863, 0.137255, 0.419608 ),
    'medium aquamarine':    ( 0.196078, 0.8, 0.6 ),
    'medium blue':          ( 0.196078, 0.196078, 0.8 ),
    'medium forest green':  ( 0.419608, 0.556863, 0.137255 ),
    'medium goldenrod':     ( 0.917647, 0.917647, 0.678431 ),
    'medium orchid':        ( 0.576471, 0.439216, 0.858824 ),
    'medium sea green':     ( 0.258824, 0.435294, 0.258824 ),
    'medium slate blue':    ( 0.498039, 0.0, 1.0 ),
    'medium spring green':  ( 0.498039, 1.0, 0.0 ),
    'medium turquoise':     ( 0.439216, 0.858824, 0.858824 ),
    'medium violet red':    ( 0.858824, 0.439216, 0.576471 ),
    'midnight blue':        ( 0.184314, 0.184314, 0.309804 ),
    'navy':                 ( 0.137255, 0.137255, 0.556863 ),
    'orange':               ( 0.8, 0.196078, 0.196078 ),
    'orange red':           ( 1.0, 0.0, 0.498039 ),
    'orchid':               ( 0.858824, 0.439216, 0.858824 ),
    'pale green':           ( 0.560784, 0.737255, 0.560784 ),
    'pink':                 ( 0.737255, 0.560784, 0.917647 ),
    'plum':                 ( 0.917647, 0.678431, 0.917647 ),
    'purple':               ( 0.690196, 0.0, 1.0 ),
    'red':                  ( 1.0, 0.0, 0.0 ),
    'salmon':               ( 0.435294, 0.258824, 0.258824 ),
    'sea green':            ( 0.137255, 0.556863, 0.419608 ),
    'sienna':               ( 0.556863, 0.419608, 0.137255 ),
    'sky blue':             ( 0.196078, 0.6, 0.8 ),
    'slate blue':           ( 0.0, 0.498039, 1.0 ),
    'spring green':         ( 0.0, 1.0, 0.498039 ),
    'steel blue':           ( 0.137255, 0.419608, 0.556863 ),
    'tan':                  ( 0.858824, 0.576471, 0.439216 ),
    'thistle':              ( 0.847059, 0.74902, 0.847059 ),
    'turquoise':            ( 0.678431, 0.917647, 0.917647 ),
    'violet':               ( 0.309804, 0.184314, 0.309804 ),
    'violet red':           ( 0.8, 0.196078, 0.6 ),
    'wheat':                ( 0.847059, 0.847059, 0.74902 ),
    'white':                ( 1.0, 1.0, 1.0 ),
    'yellow':               ( 1.0, 1.0, 0.0 ),
    'yellow green':         ( 0.6, 0.8, 0.196078 )
}

#-------------------------------------------------------------------------------
#  Define 'null' specific color trait:
#-------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the RGBColorEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a RGBColor trait which lead to this file getting
# imported. This will lead to a circular import when declaring a RGBColor trait.
def get_rgb_color_editor(*args, **traits):
    from ..editors.rgb_color_editor import ToolkitEditorFactory as RGBColorEditor
    return RGBColorEditor(*args, **traits)

# Trait whose value must be an RGB color
RGBColor = Trait( 'white', convert_to_color, rgb_standard_colors,
                  editor = get_rgb_color_editor )


########NEW FILE########
__FILENAME__ = toolkit
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   02/14/2005
#
#------------------------------------------------------------------------------

""" Defines the concrete implementations of the traits Toolkit interface for
    the 'null' (do nothing) user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from ..toolkit import Toolkit

from ..editor_factory import EditorFactory

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Create a dummy singleton editor factory:
null_editor_factory = EditorFactory()

#-------------------------------------------------------------------------------
#  'GUIToolkit' class:
#-------------------------------------------------------------------------------

class GUIToolkit ( Toolkit ):

    #---------------------------------------------------------------------------
    #  GUI toolkit dependent trait definitions:
    #---------------------------------------------------------------------------

    def color_trait ( self, *args, **traits ):
        from . import color_trait as ct
        return ct.NullColor( *args, **traits )

    def rgb_color_trait ( self, *args, **traits ):
        from . import rgb_color_trait as rgbct
        return rgbct.RGBColor( *args, **traits )

    def font_trait ( self, *args, **traits ):
        from . import font_trait as ft
        return ft.NullFont( *args, **traits )

    def kiva_font_trait ( self, *args, **traits ):
        from . import font_trait as ft
        return ft.NullFont( *args, **traits )

    def constants ( self, *args, **traits ):
        constants = {'WindowColor': ( 236 / 255.0, 233 / 255.0, 216 / 255.0, 1.0 )}
        return constants

    #---------------------------------------------------------------------------
    #  'EditorFactory' factory methods:
    #---------------------------------------------------------------------------

    def __getattribute__(self, attr):
        """ Return a method that returns null_editor_factory for any request to
        an unimplemented ``*_editor()`` method.

        This must be __getattribute__ to make sure that we override the
        definitions in the superclass which raise NotImplementedError.
        """
        if attr.endswith('_editor'):
            return lambda *args, **kwds: null_editor_factory
        else:
            return super(GUIToolkit, self).__getattribute__(attr)


########NEW FILE########
__FILENAME__ = array_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/10/2006
#
#------------------------------------------------------------------------------

""" Defines array editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------
# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.array_editor file.
from traitsui.editors.array_editor \
    import SimpleEditor as BaseSimpleEditor, ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( BaseSimpleEditor, Editor ):
    """ Simple style of editor for arrays.
    """

    # FIXME: This class has been re-defined here simply so it inherits from the
    # PyQt Editor class.
    pass

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor(SimpleEditor):

    # Set the value of the readonly trait.
    readonly = True

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = array_view_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traitsui.ui_editors.array_view_editor \
    import _ArrayViewEditor as BaseArrayViewEditor

from ui_editor import UIEditor

#-------------------------------------------------------------------------------
#  '_ArrayViewEditor' class:
#-------------------------------------------------------------------------------

class _ArrayViewEditor(BaseArrayViewEditor, UIEditor):
    pass

########NEW FILE########
__FILENAME__ = basic_editor_factory
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

## Deprecated proxy for the BasicEditorFactory class declared in
# traitsui, declared here just for backward compatibility.

import warnings

from traitsui.basic_editor_factory \
    import BasicEditorFactory as AbstractBasicEditorFactory

#-------------------------------------------------------------------------------
#  'BasicEditorFactory' class
#   Deprecated alias for traitsui.editor_factory.EditorFactory
#-------------------------------------------------------------------------------

class BasicEditorFactory(AbstractBasicEditorFactory):
    """ Deprecated alias for
        traitsui.basic_editor_factory.BasicEditorFactory.
    """

    def __init__(self, *args, **kwds):
        super(BasicEditorFactory, self).__init__(*args, **kwds)
        warnings.warn("DEPRECATED: Use traitsui.basic_editor_factory"
            ".BasicEditorFactory instead.", DeprecationWarning)

#---EOF-------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = boolean_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various Boolean editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.boolean_editor file.
from traitsui.editors.boolean_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

# This needs to be imported in here for use by the editor factory for boolean
# editors (declared in traitsui). The editor factory's text_editor
# method will use the TextEditor in the ui.
from text_editor \
    import SimpleEditor as TextEditor

from constants \
    import ReadonlyColor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for Boolean values, which displays a check box.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QCheckBox()
        self.control.connect(self.control, QtCore.SIGNAL('stateChanged(int)'),
                             self.update_object)
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user clicking on the checkbox:
    #---------------------------------------------------------------------------

    def update_object ( self, state ):
        """ Handles the user clicking the checkbox.
        """
        self.value = bool(state)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.value:
            self.control.setCheckState(QtCore.Qt.Checked)
        else:
            self.control.setCheckState(QtCore.Qt.Unchecked)

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( Editor ):
    """ Read-only style of editor for Boolean values, which displays static text
    of either "True" or "False".
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QLineEdit()
        self.control.setReadOnly(True)

        pal = QtGui.QPalette(self.control.palette())
        pal.setColor(QtGui.QPalette.Base, ReadonlyColor)
        self.control.setPalette(pal)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #
    #  (Should normally be overridden in a subclass)
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.value:
            self.control.setText('True')
        else:
            self.control.setText('False')

########NEW FILE########
__FILENAME__ = button_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various button editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traits.api import Unicode, List, Str, on_trait_change

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.button_editor file.
from traitsui.editors.button_editor \
    import ToolkitEditorFactory

from editor import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style editor for a button.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The button label
    label = Unicode

    # The list of items in a drop-down menu, if any
    #menu_items = List

    # The selected item in the drop-down menu.
    selected_item = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        label = self.factory.label or self.item.get_label(self.ui)

        if self.factory.values_trait:
            self.control = QtGui.QToolButton()
            self.control.toolButtonStyle = QtCore.Qt.ToolButtonTextOnly
            self.control.setText(self.string_value(label))
            self.object.on_trait_change(self._update_menu, self.factory.values_trait)
            self.object.on_trait_change(self._update_menu, self.factory.values_trait + "_items")
            self._menu = QtGui.QMenu()
            self._update_menu()
            self.control.setMenu(self._menu)

        else:
            self.control = QtGui.QPushButton(self.string_value(label))
            self._menu = None
            self.control.setAutoDefault(False)

        self.sync_value(self.factory.label_value, 'label', 'from')
        self.control.clicked.connect(self.update_object)
        self.set_tooltip()


    def _label_changed(self, label):
        self.control.setText(self.string_value(label))

    def _update_menu(self):
        self._menu.blockSignals(True)
        self._menu.clear()
        for item in getattr(self.object, self.factory.values_trait):
            action = self._menu.addAction(item)
            action.triggered.connect(lambda event, name=item: self._menu_selected(name))
        self.selected_item = ""
        self._menu.blockSignals(False)

    def _menu_selected(self, item_name):
        self.selected_item = item_name
        self.label = item_name

    def update_object(self):
        """ Handles the user clicking the button by setting the factory value
            on the object.
        """
        if self.selected_item != "":
            self.value = self.selected_item
        else:
            self.value = self.factory.value

        # If there is an associated view, then display it:
        if (self.factory is not None) and (self.factory.view is not None):
            self.object.edit_traits( view   = self.factory.view,
                                     parent = self.control )

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style editor for a button, which can contain an image.
    """

    # The mapping of button styles to Qt classes.
    _STYLE_MAP = {
        'checkbox': QtGui.QCheckBox,
        'radio':    QtGui.QRadioButton,
        'toolbar':  QtGui.QToolButton
    }

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # FIXME: We ignore orientation, width_padding and height_padding.

        factory = self.factory

        btype = self._STYLE_MAP.get(factory.style, QtGui.QPushButton)
        self.control = btype()
        self.control.setText(self.string_value(factory.label))

        if factory.image is not None:
            self.control.setIcon(factory.image.create_icon())

        QtCore.QObject.connect(self.control, QtCore.SIGNAL('clicked()'),
                self.update_object )
        self.set_tooltip()

########NEW FILE########
__FILENAME__ = check_list_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various editors for multi-selection enumerations, for the PyQt
user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import logging
from string import capitalize

from pyface.qt import QtCore, QtGui

from traits.api \
    import List, Unicode, TraitError

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.check_list_editor file.
from traitsui.editors.check_list_editor \
    import ToolkitEditorFactory

from editor_factory \
    import TextEditor as BaseTextEditor

from editor \
    import EditorWithList

logger = logging.getLogger(__name__)

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( EditorWithList ):
    """ Simple style of editor for checklists, which displays a combo box.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Checklist item names
    names = List( Unicode )

    # Checklist item values
    values = List

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.create_control( parent )
        super( SimpleEditor, self ).init( parent )

    #---------------------------------------------------------------------------
    #  Creates the initial editor control:
    #---------------------------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the initial editor control.
        """
        self.control = QtGui.QComboBox()
        QtCore.QObject.connect(self.control,
                QtCore.SIGNAL('activated(QString)'), self.update_object)

    #---------------------------------------------------------------------------
    #  Handles the list of legal check list values being updated:
    #---------------------------------------------------------------------------

    def list_updated ( self, values ):
        """ Handles updates to the list of legal checklist values.
        """
        sv = self.string_value
        if (len( values ) > 0) and isinstance( values[0], basestring ):
           values = [ ( x, sv( x, capitalize ) ) for x in values ]
        self.values = valid_values = [ x[0] for x in values ]
        self.names  =                [ x[1] for x in values ]

        # Make sure the current value is still legal:
        modified  = False
        cur_value = parse_value( self.value )
        for i in range( len( cur_value ) - 1, -1, -1 ):
            if cur_value[i] not in valid_values:
                try:
                    del cur_value[i]
                    modified = True
                except TypeError, e:
                    logger.warn('Unable to remove non-current value [%s] from '
                        'values %s', cur_value[i], values)
        if modified:
            if isinstance( self.value, basestring ):
                cur_value = ','.join( cur_value )
            self.value = cur_value

        self.rebuild_editor()

    #---------------------------------------------------------------------------
    #  Rebuilds the editor after its definition is modified:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the editor after its definition is modified.
        """
        control = self.control
        control.clear()
        for name in self.names:
            control.addItem(name)
        self.update_editor()

    #----------------------------------------------------------------------------
    #  Handles the user selecting a new value from the combo box:
    #----------------------------------------------------------------------------

    def update_object ( self, text ):
        """ Handles the user selecting a new value from the combo box.
        """
        value = self.values[self.names.index(unicode(text))]
        if not isinstance(self.value, basestring):
           value = [value]
        self.value = value

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        try:
            self.control.setCurrentIndex(
                             self.values.index(parse_value(self.value)[0]))
        except:
            pass

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of editor for checklists, which displays a set of check
        boxes.
    """

    #---------------------------------------------------------------------------
    #  Creates the initial editor control:
    #---------------------------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the initial editor control.
        """
        self.control = QtGui.QWidget()
        layout = QtGui.QGridLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)

        self._mapper = QtCore.QSignalMapper()
        QtCore.QObject.connect(self._mapper,
                QtCore.SIGNAL('mapped(const QString &)'), self.update_object)

    #---------------------------------------------------------------------------
    #  Rebuilds the editor after its definition is modified:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the editor after its definition is modified.
        """
        # Clear any existing content:
        self.clear_layout()

        cur_value = parse_value( self.value )

        # Create a sizer to manage the radio buttons:
        labels = self.names
        values = self.values
        n      = len( labels )
        cols   = self.factory.cols
        rows   = (n + cols - 1) / cols
        incr   = [ n / cols ] * cols
        rem    = n % cols
        for i in range( cols ):
            incr[i] += (rem > i)
        incr[-1] = -(reduce( lambda x, y: x + y, incr[:-1], 0 ) - 1)

        # Add the set of all possible choices:
        layout = self.control.layout()
        index = 0
        for i in range( rows ):
            for j in range( cols ):
                if n > 0:
                    cb = QtGui.QCheckBox(labels[index])
                    cb.value = values[index]

                    if cb.value in cur_value:
                        cb.setCheckState(QtCore.Qt.Checked)
                    else:
                        cb.setCheckState(QtCore.Qt.Unchecked)

                    QtCore.QObject.connect(cb,
                                           QtCore.SIGNAL('clicked()'),
                                           self._mapper,
                                           QtCore.SLOT('map()'))
                    self._mapper.setMapping(cb, labels[index])

                    layout.addWidget(cb, i, j)

                    index += incr[j]
                    n -= 1

    #---------------------------------------------------------------------------
    #  Handles the user clicking one of the 'custom' check boxes:
    #---------------------------------------------------------------------------

    def update_object(self, label):
        """ Handles the user clicking one of the custom check boxes.
        """
        cb = self._mapper.mapping(label)
        cur_value = parse_value(self.value)
        if cb.checkState() == QtCore.Qt.Checked:
            cur_value.append(cb.value)
        elif cb.value in cur_value:
            cur_value.remove(cb.value)

        if isinstance(self.value, basestring):
            cur_value = ','.join(cur_value)

        self.value = cur_value

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        new_values = parse_value( self.value )
        for cb in self.control.findChildren(QtGui.QCheckBox, None):
            if cb.value in new_values:
                cb.setCheckState(QtCore.Qt.Checked)
            else:
                cb.setCheckState(QtCore.Qt.Unchecked)

#-------------------------------------------------------------------------------
#  'TextEditor' class:
#-------------------------------------------------------------------------------

class TextEditor ( BaseTextEditor ):
    """ Text style of editor for checklists, which displays a text field.
    """

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event=None ):
        """ Handles the user changing the contents of the edit control.
        """
        try:
            value = unicode(self.control.text())
            value = eval( value )
        except:
            pass
        try:
            self.value = value
        except TraitError, excp:
            pass

#-------------------------------------------------------------------------------
#  Parse a value into a list:
#-------------------------------------------------------------------------------

def parse_value ( value ):
    """ Parses a value into a list.
    """
    if value is None:
       return []
    if type( value ) is not str:
       return value[:]
    return [ x.strip() for x in value.split( ',' ) ]

########NEW FILE########
__FILENAME__ = clipboard
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Implements a wrapper around the PyQt clipboard that handles Python objects
using pickle.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from cPickle import dumps, load, loads, PickleError
from cStringIO import StringIO
import warnings

from pyface.qt import QtCore, QtGui

from traits.api import HasTraits, Instance, Property

#-------------------------------------------------------------------------------
#  'PyMimeData' class:
#-------------------------------------------------------------------------------

class PyMimeData(QtCore.QMimeData):
    """ The PyMimeData wraps a Python instance as MIME data.
    """
    # The MIME type for instances.
    MIME_TYPE = 'application/x-ets-qt4-instance'
    NOPICKLE_MIME_TYPE = 'application/x-ets-qt4-instance-no-pickle'

    def __init__(self, data=None, pickle=True):
        """ Initialise the instance.
        """
        QtCore.QMimeData.__init__(self)

        # Keep a local reference to be returned if possible.
        self._local_instance = data

        if pickle:
            if data is not None:
                # We may not be able to pickle the data.
                try:
                    pdata = dumps(data)
                    # This format (as opposed to using a single sequence) allows
                    # the type to be extracted without unpickling the data.
                    self.setData(self.MIME_TYPE, dumps(data.__class__) + pdata)
                except (PickleError, TypeError):
                    # if pickle fails, still try to create a draggable
                    warnings.warn(("Could not pickle dragged object %s, " +
                            "using %s mimetype instead") % (repr(data),
                            self.NOPICKLE_MIME_TYPE), RuntimeWarning)
                    self.setData(self.NOPICKLE_MIME_TYPE, str(id(data)))

        else:
            self.setData(self.NOPICKLE_MIME_TYPE, str(id(data)))

    @classmethod
    def coerce(cls, md):
        """ Wrap a QMimeData or a python object to a PyMimeData.
        """
        # See if the data is already of the right type.  If it is then we know
        # we are in the same process.
        if isinstance(md, cls):
            return md

        if isinstance(md, PyMimeData):
            # if it is a PyMimeData, migrate all its data, subclasses should
            # override this method if it doesn't do thgs correctly for them
            data = md.instance()
            nmd = cls()
            nmd._local_instance = data
            for format in md.formats():
                nmd.setData(format, md.data(format))
        elif isinstance(md, QtCore.QMimeData):
            # if it is a QMimeData, migrate all its data
            nmd = cls()
            for format in md.formats():
                nmd.setData(format, md.data(format))
        else:
            # by default, try to pickle the coerced object
            pickle = True
    
            # See if the data is a list, if so check for any items which are
            # themselves of the right type.  If so, extract the instance and
            # track whether we should pickle.
            # XXX lists should suffice for now, but may want other containers
            if isinstance(md, list):
                pickle = not any(item.hasFormat(cls.NOPICKLE_MIME_TYPE)
                        for item in md if isinstance(item, QtCore.QMimeData))
                md = [item.instance() if isinstance(item, PyMimeData) else item
                        for item in md]
    
            # Arbitrary python object, wrap it into PyMimeData
            nmd = cls(md, pickle)

        return nmd

    def instance(self):
        """ Return the instance.
        """
        if self._local_instance is not None:
            return self._local_instance

        if not self.hasFormat(self.MIME_TYPE):
            # We have no pickled python data defined.
            return None

        io = StringIO(str(self.data(self.MIME_TYPE)))

        try:
            # Skip the type.
            load(io)

            # Recreate the instance.
            return load(io)
        except PickleError:
            pass

        return None

    def instanceType(self):
        """ Return the type of the instance.
        """
        if self._local_instance is not None:
            return self._local_instance.__class__

        try:
            if self.hasFormat(self.MIME_TYPE):
                return loads(str(self.data(self.MIME_TYPE)))
        except PickleError:
            pass

        return None

    def localPaths(self):
        """ The list of local paths from url list, if any.
        """
        ret = []
        for url in self.urls():
            if url.scheme() == 'file':
                ret.append(url.toLocalFile())
        return ret

#-------------------------------------------------------------------------------
#  '_Clipboard' class:
#-------------------------------------------------------------------------------

class _Clipboard(HasTraits):
    """ The _Clipboard class provides a wrapper around the PyQt clipboard.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The instance on the clipboard (if any).
    instance = Property

    # Set if the clipboard contains an instance.
    has_instance = Property

    # The type of the instance on the clipboard (if any).
    instance_type = Property

    # The application clipboard.
    clipboard = Instance(QtGui.QClipboard)

    #---------------------------------------------------------------------------
    #  Instance property methods:
    #---------------------------------------------------------------------------

    def _get_instance(self):
        """ The instance getter.
        """
        md = PyMimeData.coerce(self.clipboard.mimeData())
        if md is None:
            return None

        return md.instance()

    def _set_instance(self, data):
        """ The instance setter.
        """
        self.clipboard.setMimeData(PyMimeData(data))

    def _get_has_instance(self):
        """ The has_instance getter.
        """
        return self.clipboard.mimeData().hasFormat(PyMimeData.MIME_TYPE)

    def _get_instance_type(self):
        """ The instance_type getter.
        """
        md = PyMimeData.coerce(self.clipboard.mimeData())
        if md is None:
            return None

        return md.instanceType()

    #---------------------------------------------------------------------------
    #  Other trait handlers:
    #---------------------------------------------------------------------------

    def _clipboard_default(self):
        """ Initialise the clipboard.
        """
        return QtGui.QApplication.clipboard()

#-------------------------------------------------------------------------------
#  The singleton clipboard instance.
#-------------------------------------------------------------------------------

clipboard = _Clipboard()

########NEW FILE########
__FILENAME__ = code_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines a source code editor and code editor factory, for the PyQt user
interface toolkit, useful for tools such as debuggers.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from pyface.ui.qt4.code_editor.code_widget import AdvancedCodeWidget
from traits.api import Str, Unicode, List, Int, Event, Bool, \
    TraitError, on_trait_change
from traits.trait_base import SequenceTypes

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.code_editor file.
from traitsui.editors.code_editor import ToolkitEditorFactory

from pyface.key_pressed_event import KeyPressedEvent

from constants import OKColor, ErrorColor
from editor import Editor
from helper import pixmap_cache

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Marker line constants:
MARK_MARKER = 0 # Marks a marked line
SEARCH_MARKER = 1 # Marks a line matching the current search
SELECTED_MARKER = 2 # Marks the currently selected line

class SourceEditor ( Editor ):
    """ Editor for source code which uses the advanced code widget.
    """

    #---------------------------------------------------------------------------
    #  PyFace PythonEditor interface:
    #---------------------------------------------------------------------------

    # Event that is fired on keypresses:
    key_pressed = Event(KeyPressedEvent)

    #---------------------------------------------------------------------------
    #  Editor interface:
    #---------------------------------------------------------------------------

    # The code editor is scrollable. This value overrides the default.
    scrollable = True

    #---------------------------------------------------------------------------
    #  SoureEditor interface:
    #---------------------------------------------------------------------------

    # Is the editor read only?
    readonly = Bool( False )

    # The currently selected line
    selected_line = Int

    # The start position of the selected
    selected_start_pos = Int

    # The end position of the selected
    selected_end_pos = Int

    # The currently selected text
    selected_text = Unicode

    # The list of line numbers to mark
    mark_lines = List( Int )

    # The current line number
    line = Event

    # The current column
    column = Event

    # The lines to be dimmed
    dim_lines = List(Int)
    dim_color = Str
    dim_style_number = Int(16) # 0-15 are reserved for the python lexer

    # The lines to have squiggles drawn under them
    squiggle_lines = List(Int)
    squiggle_color = Str

    # The lexer to use.
    lexer = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------
    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QWidget()
        layout = QtGui.QVBoxLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)

        self._widget = control = AdvancedCodeWidget(None, lexer=self.factory.lexer)
        layout.addWidget(control)

        factory = self.factory

        # Set up listeners for the signals we care about
        code_editor = self._widget.code
        if self.readonly:
            code_editor.setReadOnly(True)
        else:
            code_editor.textChanged.connect(self.update_object)
        if factory.selected_text != '':
            code_editor.selectionChanged.connect(self._selection_changed)
        if (factory.line != '') or (factory.column != ''):
            code_editor.cursorPositionChanged.connect(self._position_changed)

        code_editor.line_number_widget.setVisible(factory.show_line_numbers)

        # Make sure the editor has been initialized:
        self.update_editor()

        # Set up any event listeners:
        self.sync_value( factory.mark_lines, 'mark_lines', 'from',
                         is_list = True )
        self.sync_value( factory.selected_line, 'selected_line', 'from' )
        self.sync_value( factory.selected_text, 'selected_text', 'to' )
        self.sync_value( factory.line, 'line' )
        self.sync_value( factory.column, 'column' )

        self.sync_value( factory.selected_start_pos, 'selected_start_pos', 'to')
        self.sync_value( factory.selected_end_pos, 'selected_end_pos', 'to')

        self.sync_value(factory.dim_lines, 'dim_lines', 'from', is_list=True)
        if self.factory.dim_color == '':
            self.dim_color = 'grey'
        else:
            self.sync_value(factory.dim_color, 'dim_color', 'from')

        self.sync_value(factory.squiggle_lines, 'squiggle_lines', 'from',
                        is_list=True)
        if factory.squiggle_color == '':
            self.squiggle_color = 'red'
        else:
            self.sync_value(factory.squiggle_color, 'squiggle_color', 'from')

        # Set the control tooltip:
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Make sure that the editor does not try to update as the control is
        # being destroyed:
        QtCore.QObject.disconnect(self._widget, QtCore.SIGNAL('lostFocus'),
                                  self.update_object)

        super( SourceEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self ):
        """ Handles the user entering input data in the edit control.
        """
        if not self._locked:
            try:
                value = unicode(self._widget.code.toPlainText())
                if isinstance( self.value, SequenceTypes ):
                    value = value.split()
                self.value = value
            except TraitError, excp:
                pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self._locked = True
        new_value = self.value
        if isinstance( new_value, SequenceTypes ):
            new_value = '\n'.join( [ line.rstrip() for line in new_value ] )
        control = self._widget
        if control.code.toPlainText() != new_value:
            control.code.setPlainText(new_value)

            if self.factory.selected_line:
                # TODO: update the factory selected line
                pass

            # TODO: put the cursor somewhere

        self._locked = False

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if self.factory.key_bindings is not None:
            key_bindings = prefs.get( 'key_bindings' )
            if key_bindings is not None:
                self.factory.key_bindings.merge( key_bindings )

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        return { 'key_bindings': self.factory.key_bindings }

    #---------------------------------------------------------------------------
    #  Handles the set of 'marked lines' being changed:
    #---------------------------------------------------------------------------

    def _mark_lines_changed ( self ):
        """ Handles the set of marked lines being changed.
        """
        # FIXME: Not implemented at this time.
        return

    def _mark_lines_items_changed ( self ):
        self._mark_lines_changed()

    #---------------------------------------------------------------------------
    #  Handles the currently 'selected line' being changed:
    #---------------------------------------------------------------------------

    def _selection_changed(self):
        self.selected_text = unicode(self._widget.code.textCursor().selectedText())
        start = self._widget.code.textCursor().selectionStart()
        end = self._widget.code.textCursor().selectionEnd()

        if start > end:
            start, end = end, start

        self.selected_start_pos = start
        self.selected_end_pos = end

    def _selected_line_changed ( self ):
        """ Handles a change in which line is currently selected.
        """
        control = self._widget
        line = max(1, min(control.lines(), self.selected_line))
        _, column = control.get_line_column()
        control.set_line_column(line, column)
        if self.factory.auto_scroll:
            control.centerCursor()

    #---------------------------------------------------------------------------
    #  Handles the 'line' trait being changed:
    #---------------------------------------------------------------------------

    def _line_changed ( self, line ):
        if not self._locked:
            _, column = self._widget.get_line_column()
            self._widget.set_line_column(line, column)
            if self.factory.auto_scroll:
                self._widget.centerCursor()

    #---------------------------------------------------------------------------
    #  Handles the 'column' trait being changed:
    #---------------------------------------------------------------------------

    def _column_changed ( self, column ):
        if not self._locked:
            line, _ = self._widget.get_line_column()
            self._widget.set_line_column(line, column)

    #---------------------------------------------------------------------------
    #  Handles the cursor position being changed:
    #---------------------------------------------------------------------------

    def _position_changed(self):
        """ Handles the cursor position being changed.
        """
        control = self._widget
        self._locked = True
        self.line, self.column = control.get_line_column()
        self._locked = False
        self.selected_text = control.get_selected_text()
        if self.factory.auto_scroll:
            self._widget.centerCursor()

    #---------------------------------------------------------------------------
    #  Handles a key being pressed within the editor:
    #---------------------------------------------------------------------------

    def _key_pressed_changed ( self, event ):
        """ Handles a key being pressed within the editor.
        """
        key_bindings = self.factory.key_bindings
        if key_bindings:
            processed = key_bindings.do(event.event, self.ui.handler,
                                        self.ui.info)
        else:
            processed = False
        if not processed and event.event.matches(QtGui.QKeySequence.Find):
            self._find_widget.show()

    #---------------------------------------------------------------------------
    #  Handles the styling of the editor:
    #---------------------------------------------------------------------------

    def _dim_color_changed(self):
        pass

    def _squiggle_color_changed(self):
        pass

    @on_trait_change('dim_lines, squiggle_lines')
    def _style_document(self):
        self._widget.set_warn_lines(self.squiggle_lines)



# Define the simple, custom, text and readonly editors, which will be accessed
# by the editor factory for code editors.

CustomEditor = SimpleEditor = TextEditor = SourceEditor

class ReadonlyEditor(SourceEditor):

    # Set the value of the readonly trait.
    readonly = True

########NEW FILE########
__FILENAME__ = color_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various color editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traitsui.editors.color_editor \
    import ToolkitEditorFactory as BaseToolkitEditorFactory

from editor_factory \
    import SimpleEditor as BaseSimpleEditor, \
    TextEditor as BaseTextEditor, \
    ReadonlyEditor as BaseReadonlyEditor

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Standard color samples:
color_samples = []

#---------------------------------------------------------------------------
#  The PyQt ToolkitEditorFactory class.
#---------------------------------------------------------------------------

## We need to add qt4-specific methods to the editor factory (since all editors
## will be accessing these functions. Making these functions global functions
## in this file does not work quite well, since we want custom editors to
## override these methods easily.

class ToolkitEditorFactory(BaseToolkitEditorFactory):
    """ PyQt editor factory for color editors.
    """

    #---------------------------------------------------------------------------
    #  Gets the PyQt color equivalent of the object trait:
    #---------------------------------------------------------------------------

    def to_qt4_color ( self, editor ):
        """ Gets the PyQt color equivalent of the object trait.
        """
        if self.mapped:
            return getattr( editor.object, editor.name + '_' )

        return getattr( editor.object, editor.name )

    #---------------------------------------------------------------------------
    #  Gets the application equivalent of a PyQt value:
    #---------------------------------------------------------------------------

    def from_qt4_color ( self, color ):
        """ Gets the application equivalent of a PyQt value.
        """
        return color

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def str_color ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        if isinstance(color, QtGui.QColor):
            alpha = color.alpha()
            if alpha == 255:
                return "(%d,%d,%d)" % (color.red(), color.green(), color.blue())

            return "(%d,%d,%d,%d)" % (color.red(), color.green(), color.blue(), alpha)

        return color

#-------------------------------------------------------------------------------
#  'SimpleColorEditor' class:
#-------------------------------------------------------------------------------

class SimpleColorEditor ( BaseSimpleEditor ):
    """ Simple style of color editor, which displays a text field whose
    background color is the color value. Selecting the text field displays
    a dialog box for selecting a new color value.
    """

    #---------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #---------------------------------------------------------------------------

    def popup_editor(self):
        """ Invokes the pop-up editor for an object trait.
        """
        color = self.factory.to_qt4_color(self)
        options = QtGui.QColorDialog.ShowAlphaChannel
        if not self.factory.use_native_dialog:
            options |= QtGui.QColorDialog.DontUseNativeDialog
        color = QtGui.QColorDialog.getColor(
            color,
            self.control,
            u'Select Color',
            options,
        )

        if color.isValid():
            self.value = self.factory.from_qt4_color(color)
            self.update_editor()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        super( SimpleColorEditor, self ).update_editor()
        set_color( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def string_value ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        return self.factory.str_color( color )

#-------------------------------------------------------------------------------
#  'CustomColorEditor' class:
#-------------------------------------------------------------------------------

class CustomColorEditor ( Editor ):
    """ Custom style of color editor, which displays a color editor panel.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control, self._simple_field = color_editor_for(self, parent)

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if getattr(self, '_simple_field', None) is not None:
            self._simple_field.dispose()
            self._simple_field = None
        super(CustomColorEditor, self).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self._simple_field.update_editor()

    #---------------------------------------------------------------------------
    #  Updates the object trait when a color swatch is clicked:
    #---------------------------------------------------------------------------

    def update_object_from_swatch(self, color_text):
        """ Updates the object trait when a color swatch is clicked.
        """
        color = QtGui.QColor(*[int(part) for part in color_text.split(',')])
        self.value = self.factory.from_qt4_color(color)
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def string_value ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        return self.factory.str_color( color )

#-------------------------------------------------------------------------------
#  'TextColorEditor' class:
#-------------------------------------------------------------------------------

class TextColorEditor ( BaseTextEditor ):
    """ Text style of color editor, which displays a text field whose
    background color is the color value.
    """

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object(self):
        """ Handles the user changing the contents of the edit control.
        """
        self.value = unicode(self.control.text())
        set_color( self )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        super( TextColorEditor, self ).update_editor()
        set_color( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def string_value ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        return self.factory.str_color( color )

#-------------------------------------------------------------------------------
#  'ReadonlyColorEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyColorEditor ( BaseReadonlyEditor ):
    """ Read-only style of color editor, which displays a read-only text field
    whose background color is the color value.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QLineEdit()
        self.control.setReadOnly(True)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        super( ReadonlyColorEditor, self ).update_editor()
        set_color( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def string_value ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        return self.factory.str_color( color )

#-------------------------------------------------------------------------------
#   Sets the color of the specified editor's color control:
#-------------------------------------------------------------------------------

def set_color ( editor ):
    """  Sets the color of the specified color control.
    """
    color = editor.factory.to_qt4_color(editor)
    pal = QtGui.QPalette(editor.control.palette())

    pal.setColor(QtGui.QPalette.Base, color)

    if (color.red() > 192 or color.blue() > 192 or color.green() > 192):
        pal.setColor(QtGui.QPalette.Text, QtCore.Qt.black)
    else:
        pal.setColor(QtGui.QPalette.Text, QtCore.Qt.white)

    editor.control.setPalette(pal)

#----------------------------------------------------------------------------
#  Creates a custom color editor panel for a specified editor:
#----------------------------------------------------------------------------

class FixedButton(QtGui.QPushButton):
    """ Override to work around a bug in Qt 4.7 on Macs.

    https://bugreports.qt-project.org/browse/QTBUG-15936
    """

    def hitButton(self, pos):
        return QtGui.QAbstractButton.hitButton(self, pos)


def color_editor_for(editor, parent):
    """ Creates a custom color editor panel for a specified editor.
    """
    # Create the colour samples if it hasn't already been done.
    if len(color_samples) == 0:
        color_choices = (0, 128, 192, 255)
        for r in color_choices:
            for g in color_choices:
                for b in (0, 128, 255):
                    color_samples.append(QtGui.QColor(r, g, b))

    root = QtGui.QWidget()
    panel = QtGui.QHBoxLayout(root)
    panel.setContentsMargins(0, 0, 0, 0)

    swatch_editor = editor.factory.simple_editor(editor.ui, editor.object,
            editor.name, editor.description, None)
    swatch_editor.prepare(parent)
    panel.addWidget(swatch_editor.control)

    # Add all of the color choice buttons:
    grid = QtGui.QGridLayout()
    grid.setSpacing(0)

    mapper = QtCore.QSignalMapper(panel)

    rows = 4
    cols = len(color_samples) / rows
    i = 0

    sheet_template = """
    QPushButton {
        min-height: 18px;
        max-height: 18px;
        min-width: 18px;
        max-width: 18px;
        background-color: rgb(%s);
    }
    """

    for r in range(rows):
        for c in range(cols):
            control = FixedButton()
            color = color_samples[r*cols + c]
            color_text = '%d,%d,%d,%d' % color.getRgb()
            control.setStyleSheet(sheet_template % color_text)
            control.setAttribute(QtCore.Qt.WA_LayoutUsesWidgetRect, True)

            control.clicked.connect(mapper.map)
            mapper.setMapping(control, color_text)

            grid.addWidget(control, r, c)
            editor.set_tooltip(control)

            i += 1

    mapper.mapped[unicode].connect(editor.update_object_from_swatch)

    panel.addLayout(grid)

    return root, swatch_editor


# Define the SimpleEditor, CustomEditor, etc. classes which are used by the
# editor factory for the color editor.
SimpleEditor   = SimpleColorEditor
CustomEditor   = CustomColorEditor
TextEditor     = TextColorEditor
ReadonlyEditor = ReadonlyColorEditor

########NEW FILE########
__FILENAME__ = color_trait
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Trait definition for a PyQt-based color.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

from traits.api \
    import Trait, TraitError

#-------------------------------------------------------------------------------
#  Convert a number into a QColor object:
#-------------------------------------------------------------------------------

def convert_to_color ( object, name, value ):
    """ Converts a number into a QColor object.
    """
    # Try the toolkit agnostic format.
    try:
        tup = eval(value)
    except:
        tup = value

    if isinstance(tup, tuple):
        if 3 <= len(tup) <= 4:
            try:
                color = QtGui.QColor(*tup)
            except TypeError:
                raise TraitError
        else:
            raise TraitError
    else:
        if isinstance(value, basestring):
            # Allow for spaces in the string value.
            value = value.replace(' ', '')

        # Let the standard ctors handle the value.
        try:
            color = QtGui.QColor(value)
        except TypeError:
            raise TraitError

    if not color.isValid():
        raise TraitError

    return color

convert_to_color.info = ('a string of the form (r,g,b) or (r,g,b,a) where r, '
                         'g, b, and a are integers from 0 to 255, a QColor '
                         'instance, a Qt.GlobalColor, an integer which in hex '
                         'is of the form 0xRRGGBB, a string of the form #RGB, '
                         '#RRGGBB, #RRRGGGBBB or #RRRRGGGGBBBB')

#-------------------------------------------------------------------------------
#  Standard colors:
#-------------------------------------------------------------------------------

# Note that this is slightly different from the wx implementation in that the
# names do not include spaces and the full set of SVG color keywords is
# supported.
standard_colors = {}
for name in QtGui.QColor.colorNames():
    standard_colors[str(name)] = QtGui.QColor(name)

#-------------------------------------------------------------------------------
#  Callable that returns an instance of the PyQtToolkitEditorFactory for color
#  editors.
#-------------------------------------------------------------------------------

### FIXME: We have declared the 'editor' to be a function instead of  the
# traitsui.qt4.color_editor.ToolkitEditorFactory class, since the
# latter is leading to too many circular imports. In the future, try to see if
# there is a better way to do this.
def get_color_editor(*args, **traits):
    from traitsui.qt4.color_editor import ToolkitEditorFactory
    return ToolkitEditorFactory(*args, **traits)

#-------------------------------------------------------------------------------
#  Define PyQt specific color traits:
#-------------------------------------------------------------------------------

def PyQtColor ( default = 'white', allow_none = False, **metadata ):
    """ Defines PyQt-specific color traits.
    """
    if allow_none:
        return Trait( default, None, standard_colors, convert_to_color,
                      editor = get_color_editor, **metadata )

    return Trait( default, standard_colors, convert_to_color,
                  editor = get_color_editor, **metadata )

########NEW FILE########
__FILENAME__ = compound_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the compound editor and the compound editor factory for the
PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

from traits.api \
    import Str

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.compound_editor file.
from traitsui.editors.compound_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'CompoundEditor' class:
#-------------------------------------------------------------------------------

class CompoundEditor ( Editor ):
    """ Editor for compound traits, which displays editors for each of the
    combined traits, in the appropriate style.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The kind of editor to create for each list item
    kind = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QWidget()
        layout = QtGui.QVBoxLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)

        # Add all of the component trait editors:
        self._editors = editors = []
        for factory in self.factory.editors:
            editor = getattr( factory, self.kind )( self.ui, self.object,
                                       self.name, self.description, None )
            editor.prepare(self.control)
            layout.addWidget(editor.control)
            editors.append(editor)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        for editor in self._editors:
            editor.dispose()

        super( CompoundEditor, self ).dispose()

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor(CompoundEditor):

    # The kind of editor to create for each list item. This value overrides
    # the default.
    kind = 'simple_editor'

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor(CompoundEditor):

    # The kind of editor to create for each list item. This value overrides
    # the default.

    kind = 'custom_editor'

########NEW FILE########
__FILENAME__ = constants
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines constants used by the PyQt implementation of the various text
editors and text editor factories.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

_palette = QtGui.QApplication.palette()

# Default dialog title
DefaultTitle = 'Edit properties'

# Color of valid input
OKColor = _palette.color(QtGui.QPalette.Base)

# Color to highlight input errors
ErrorColor = QtGui.QColor( 255, 192, 192 )

# Color for background of read-only fields
ReadonlyColor = QtGui.QColor( 244, 243, 238 )

# Color for background of fields where objects can be dropped
DropColor = QtGui.QColor( 215, 242, 255 )

# Color for an editable field
EditableColor = _palette.color(QtGui.QPalette.Base)

# Color for background of windows (like dialog background color)
WindowColor = _palette.color(QtGui.QPalette.Window)

del _palette

# Screen size values:

_geom = QtGui.QApplication.desktop().availableGeometry()

screen_dx = _geom.width()
screen_dy = _geom.height()

del _geom

########NEW FILE########
__FILENAME__ = csv_list_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Ioannis Tziakos
#  Date:   11 Jan 2012
#
#------------------------------------------------------------------------------

""" Defines the various text editors for the Qt user interface toolkit.
    The module is mainly a place-folder for TextEditor factories that have
    been augmented to also listen to changes in the items of the list object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#------------------------------------------------------------------------------

from .text_editor import SimpleEditor as QtSimpleEditor
from .text_editor import CustomEditor as QtCustomEditor
from .text_editor import ReadonlyEditor as QtReadonlyEditor
from ..editors.csv_list_editor import _prepare_method, _dispose_method

class SimpleEditor(QtSimpleEditor):
    """ Simple Editor style for CSVListEditor. """
    prepare = _prepare_method
    dispose = _dispose_method

class CustomEditor(QtCustomEditor):
    """ Custom Editor style for CSVListEditor. """
    prepare = _prepare_method
    dispose = _dispose_method

class ReadonlyEditor(QtReadonlyEditor):
    """ Readonly Editor style for CSVListEditor. """
    prepare = _prepare_method
    dispose = _dispose_method

TextEditor = SimpleEditor

########NEW FILE########
__FILENAME__ = custom_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the PyQt implementation of the editor used to wrap a non-Traits
based custom control.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.custom_editor file.
from traitsui.editors.custom_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( Editor ):
    """ Wrapper for a custom editor control
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory.factory
        if factory is not None:
            self.control = factory( *(( parent, self ) + self.factory.args ) )
        if self.control is None:
            self.control = QtGui.QLabel(
                'An error occurred creating a custom editor.\n'
                'Please contact the developer.')
            self.control.setStyleSheet("background-color: red; color: white")
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

########NEW FILE########
__FILENAME__ = date_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   08/03/2009
#
#------------------------------------------------------------------------------

""" A Traits UI editor for datetime.date objects.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import datetime

from pyface.qt import QtCore, QtGui

from editor import Editor
from editor_factory import ReadonlyEditor as BaseReadonlyEditor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor(Editor):
    """ Simple Traits UI date editor that wraps QDateEdit.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QDateEdit()
        if hasattr(self.factory, 'qt_date_format'):
            self.control.setDisplayFormat(self.factory.qt_date_format)

        if not self.factory.allow_future:
            self.control.setMaximumDate(QtCore.QDate.currentDate())

        if getattr(self.factory, 'maximum_date_name', None):
            obj, extended_name, func = self.parse_extended_name(self.factory.maximum_date_name)
            self.factory.maximum_date = func()

        if getattr(self.factory, 'minimum_date_name', None):
            obj, extended_name, func = self.parse_extended_name(self.factory.minimum_date_name)
            self.factory.minimum_date = func()

        if getattr(self.factory, 'minimum_date', None):
            min_date = QtCore.QDate(self.factory.minimum_date.year,
                                    self.factory.minimum_date.month,
                                    self.factory.minimum_date.day)
            self.control.setMinimumDate(min_date)

        if getattr(self.factory, 'maximum_date', None):
            max_date = QtCore.QDate(self.factory.maximum_date.year,
                                    self.factory.maximum_date.month,
                                    self.factory.maximum_date.day)
            self.control.setMaximumDate(max_date)

        signal = QtCore.SIGNAL('dateChanged(QDate)')
        QtCore.QObject.connect(self.control, signal, self.update_object)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        if value:
            q_date = QtCore.QDate(value.year, value.month, value.day)
            self.control.setDate(q_date)

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object(self, q_date):
        """ Handles the user entering input data in the edit control.
        """
        year = q_date.year()
        month = q_date.month()
        day = q_date.day()
        try:
            self.value = datetime.date(year, month, day)
        except ValueError:
            print 'Invalid date:', year, month, day
            raise

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor(Editor):
    """ Custom Traits UI date editor that wraps QCalendarWidget.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QCalendarWidget()

        if not self.factory.allow_future:
            self.control.setMaximumDate(QtCore.QDate.currentDate())

        signal = QtCore.SIGNAL('clicked(QDate)')
        QtCore.QObject.connect(self.control, signal, self.update_object)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        if value:
            q_date = QtCore.QDate(value.year, value.month, value.day)
            self.control.setSelectedDate(q_date)

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object(self, q_date):
        """ Handles the user entering input data in the edit control.
        """
        year = q_date.year()
        month = q_date.month()
        day = q_date.day()
        try:
            self.value = datetime.date(year, month, day)
        except ValueError:
            print 'Invalid date:', year, month, day
            raise

#------------------------------------------------------------------------------
# 'ReadonlyEditor' class:
#------------------------------------------------------------------------------

class ReadonlyEditor(BaseReadonlyEditor):
    """ Readonly Traits UI date editor that uses a QLabel for the view.
    """

    def _get_str_value(self):
        """ Replace the default string value with our own date verision.
        """
        if not self.value:
            return self.factory.message
        else:
            return self.value.strftime(self.factory.strftime)

########NEW FILE########
__FILENAME__ = directory_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines various directory editor for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.custom_editor file.
from traitsui.editors.directory_editor \
    import ToolkitEditorFactory

from file_editor \
    import SimpleEditor as SimpleFileEditor, \
           CustomEditor as CustomFileEditor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( SimpleFileEditor ):
    """ Simple style of editor for directories, which displays a text field
        and a **Browse** button that opens a directory-selection dialog box.
    """

    #---------------------------------------------------------------------------
    #  Creates the correct type of file dialog:
    #---------------------------------------------------------------------------

    def _create_file_dialog ( self ):
        """ Creates the correct type of file dialog.
        """
        dlg = QtGui.QFileDialog(self.control)
        dlg.selectFile(self._file_name.text())
        dlg.setFileMode(QtGui.QFileDialog.Directory)
        dlg.setOptions(QtGui.QFileDialog.ShowDirsOnly)

        return dlg

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( CustomFileEditor ):
    """ Custom style of editor for directories, which displays a tree view of
        the file system.
    """

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object(self, idx):
        """ Handles the user changing the contents of the edit control.
        """
        if self._model.isDir(idx):
            self.value = unicode(self._model.filePath(idx))

########NEW FILE########
__FILENAME__ = drop_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines a drop target editor for the PyQt user interface toolkit. A drop
target editor handles drag and drop operations as a drop target.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui, QtCore

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.drop_editor file.
from traitsui.editors.drop_editor import ToolkitEditorFactory

from text_editor import SimpleEditor as Editor
from constants import DropColor
from clipboard import PyMimeData, clipboard

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of drop editor, which displays a read-only text field that
    contains the string representation of the object trait's value.
    """

    # Background color when it is OK to drop objects.
    ok_color = DropColor

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        if self.factory.readonly:
            self.control = QtGui.QLineEdit(self.str_value)
            self.control.setReadOnly(True)
            self.set_tooltip()
        else:
            super( SimpleEditor, self ).init( parent )

        pal = QtGui.QPalette(self.control.palette())
        pal.setColor(QtGui.QPalette.Base, self.ok_color)
        self.control.setPalette(pal)

        # Install EventFilter on control to handle DND events.
        drop_event_filter = _DropEventFilter(self.control)
        self.control.installEventFilter(drop_event_filter)

        self.control._qt4_editor = self

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified object trait value:
    #---------------------------------------------------------------------------

    def string_value ( self, value ):
        """ Returns the text representation of a specified object trait value.
        """
        if value is None:
            return ''
        return str( value )

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass


class _DropEventFilter(QtCore.QObject):

    def eventFilter(self, source, event):
        typ = event.type()
        if typ == QtCore.QEvent.Drop:
            self.dropEvent(event)
        elif typ == QtCore.QEvent.DragEnter:
            self.dragEnterEvent(event)
        return super(_DropEventFilter, self).eventFilter(source, event)

    #---------------------------------------------------------------------------
    #  Handles a Python object being dropped on the control:
    #---------------------------------------------------------------------------

    def dropEvent(self, e):
        """ Handles a Python object being dropped on the tree.
        """
        editor = self.parent()._qt4_editor

        klass = editor.factory.klass

        if editor.factory.binding:
            value = getattr(clipboard, 'node', None)
        else:
            value = e.mimeData().instance()

        if (klass is None) or isinstance(value, klass):
            editor._no_update = True
            try:
                if hasattr( value, 'drop_editor_value' ):
                    editor.value = value.drop_editor_value()
                else:
                    editor.value = value
                if hasattr( value, 'drop_editor_update' ):
                    value.drop_editor_update(self)
                else:
                    self.setText(editor.str_value)
            finally:
                editor._no_update = False

            e.acceptProposedAction()

    #---------------------------------------------------------------------------
    #  Handles a Python object being dragged over the control:
    #---------------------------------------------------------------------------

    def dragEnterEvent(self, e):
        """ Handles a Python object being dragged over the tree.
        """
        editor = self.parent()._qt4_editor

        if editor.factory.binding:
            data = getattr(clipboard, 'node', None)
        else:
            md = e.mimeData()

            if not isinstance(md, PyMimeData):
                return

            data = md.instance()

        try:
            editor.object.base_trait(editor.name).validate(editor.object,
                    editor.name, data)
            e.acceptProposedAction()
        except:
            pass


# Define the Text and ReadonlyEditor for use by the editor factory.
TextEditor = ReadonlyEditor = SimpleEditor

########NEW FILE########
__FILENAME__ = editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the base class for PyQt editors.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

from traits.api \
    import HasTraits, Instance, Str, Callable

from traitsui.api \
    import Editor as UIEditor

from constants \
    import OKColor, ErrorColor

#-------------------------------------------------------------------------------
#  'Editor' class:
#-------------------------------------------------------------------------------

class Editor ( UIEditor ):
    """ Base class for PyQt editors for Traits-based UIs.
    """

    def clear_layout(self):
        """ Delete the contents of a control's layout.
        """
        layout = self.control.layout()
        while True:
            itm = layout.takeAt(0)
            if itm is None:
                break

            itm.widget().setParent(None)

    #---------------------------------------------------------------------------
    #  Handles the 'control' trait being set:
    #---------------------------------------------------------------------------

    def _control_changed ( self, control ):
        """ Handles the **control** trait being set.
        """
        # FIXME: Check we actually make use of this.
        if control is not None:
            control._editor = self

    #---------------------------------------------------------------------------
    #  Assigns focus to the editor's underlying toolkit widget:
    #---------------------------------------------------------------------------

    def set_focus ( self ):
        """ Assigns focus to the editor's underlying toolkit widget.
        """
        if self.control is not None:
            self.control.setFocus()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        new_value = self.str_value
        if self.control.text() != new_value:
            self.control.setText( new_value )

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        # Make sure the control is a widget rather than a layout.
        if isinstance(self.control, QtGui.QLayout):
            control = self.control.parentWidget()
        else:
            control = self.control

        QtGui.QMessageBox.information(control,
                self.description + ' value error', str(excp))

    #---------------------------------------------------------------------------
    #  Sets the tooltip for a specified control:
    #---------------------------------------------------------------------------

    def set_tooltip ( self, control = None ):
        """ Sets the tooltip for a specified control.
        """
        desc = self.description
        if desc == '':
            desc = self.object.base_trait( self.name ).desc
            if desc is None:
                return False

            desc = 'Specifies ' + desc

        if control is None:
            control = self.control

        control.setToolTip( desc )

        return True

    #---------------------------------------------------------------------------
    #  Handles the 'enabled' state of the editor being changed:
    #---------------------------------------------------------------------------

    def _enabled_changed(self, enabled):
        """Handles the **enabled** state of the editor being changed.
        """
        if self.control is not None:
            self._enabled_changed_helper(self.control, enabled)

    def _enabled_changed_helper(self, control, enabled):
        """A helper that allows the control to be a layout and recursively
           manages all its widgets.
        """
        if isinstance(control, QtGui.QWidget):
            control.setEnabled(enabled)
        else:
            for i in range(control.count()):
                itm = control.itemAt(i)
                self._enabled_changed_helper((itm.widget() or itm.layout()),
                        enabled)

    #---------------------------------------------------------------------------
    #  Handles the 'visible' state of the editor being changed:
    #---------------------------------------------------------------------------

    def _visible_changed(self, visible):
        """Handles the **visible** state of the editor being changed.
        """
        if self.label_control is not None:
            self.label_control.setVisible(visible)
        if self.control is None:
            # We are being called after the editor has already gone away.
            return

        self._visible_changed_helper(self.control, visible)

        page = self.control.parent()
        if page is None or page.parent() is None or page.parent().parent() is None or page.layout().count() != 1:
            return

        # The TabWidget (representing the notebook) has a StackedWidget inside it,
        # which then contains our parent.
        # Even after the tab is removed, the parent-child relationship between
        # our container widget (representing the page) and the enclosing TabWidget,
        # so the following reference is still valid.
        stack_widget = page.parent()
        notebook = stack_widget.parent()
        is_tabbed_group = notebook.property("traits_tabbed_group")
        if notebook is None or not isinstance(notebook, QtGui.QTabWidget) or not is_tabbed_group:
            return

        if not visible:
            # Store the page number and name on the parent
            for i in range(0, notebook.count()):
                if notebook.widget(i) == page:
                    self._tab_index = i
                    self._tab_text = notebook.tabText(i)
                    page.setVisible(False)
                    notebook.removeTab(i)
                    break
        else:
            # Check to see if our parent has previously-stored tab
            # index and text attributes
            if (getattr(self, "_tab_index", None) is not None and
                    getattr(self, "_tab_text", None) is not None):
                page.setVisible(True)
                notebook.insertTab(self._tab_index, page, self._tab_text)
        return

    def _visible_changed_helper(self, control, visible):
        """A helper that allows the control to be a layout and recursively
           manages all its widgets.
        """
        if isinstance(control, QtGui.QWidget):
            control.setVisible(visible)
        else:
            for i in range(control.count()):
                itm = control.itemAt(i)
                self._visible_changed_helper((itm.widget() or itm.layout()),
                        visible)

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.control

    #---------------------------------------------------------------------------
    #  Returns whether or not the editor is in an error state:
    #---------------------------------------------------------------------------

    def in_error_state ( self ):
        """ Returns whether or not the editor is in an error state.
        """
        return False

    #---------------------------------------------------------------------------
    #  Sets the editor's current error state:
    #---------------------------------------------------------------------------

    def set_error_state ( self, state = None, control = None ):
        """ Sets the editor's current error state.
        """
        if state is None:
            state = self.invalid
        state = state or self.in_error_state()

        if control is None:
            control = self.get_error_control()

        if not isinstance( control, list ):
            control = [ control ]

        for item in control:
            if item is None:
                continue

            pal = QtGui.QPalette(item.palette())

            if state:
                color = ErrorColor
                if getattr( item, '_ok_color', None ) is None:
                    item._ok_color = QtGui.QColor(pal.color(QtGui.QPalette.Base))
            else:
                color = getattr( item, '_ok_color', OKColor )

            pal.setColor(QtGui.QPalette.Base, color)
            item.setPalette(pal)

    #---------------------------------------------------------------------------
    #  Handles the editor's invalid state changing:
    #---------------------------------------------------------------------------

    def _invalid_changed ( self, state ):
        """ Handles the editor's invalid state changing.
        """
        self.set_error_state()

    #---------------------------------------------------------------------------
    #  Handles the editor's context menu action
    #---------------------------------------------------------------------------

    def perform (self, action, action_event = None ):
        """ Performs the action described by a specified Action object.
        """
        self.ui.do_undoable( self._perform, action )

    def _perform ( self, action ):
        method_name       = action.action
        info              = self._menu_context['info']
        handler           = self._menu_context['handler']
        object            = self._menu_context['object']
        selection         = self._menu_context['selection']
        self._menu_context['action'] = action

        if method_name.find( '.' ) >= 0:
            if method_name.find( '(' ) < 0:
                method_name += '()'
            try:
                eval( method_name, globals(), self._menu_context )
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()
            return

        method = getattr( handler, method_name, None )
        if method is not None:
            method( info, selection )
            return

        if action.on_perform is not None:
            action.on_perform(selection)

        action.perform(selection)

    def eval_when ( self, condition, object, trait ):
        """ Evaluates a condition within a defined context, and sets a 
        specified object trait based on the result, which is assumed to be a
        Boolean.
        """
        if condition != '':
            value = True
            try:
                if not eval( condition, globals(), self._menu_context ):
                    value = False
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()
            setattr( object, trait, value )

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        action = menu_item.item.action
        self.eval_when( action.enabled_when, menu_item, 'enabled' )
        self.eval_when( action.checked_when, menu_item, 'checked' )

    def can_add_to_menu(self, action) :
        """ Returns whether the action should be defined in the user interface.
        """
        if action.defined_when != '':

            try:
                if not eval( action.defined_when, globals(), self._menu_context ):
                    return False
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()

        if action.visible_when != '':
            try:
                if not eval( action.visible_when, globals(), self._menu_context ):
                    return False
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()

        return True

    # TODO: move this method, it should be part of ui_panel or some other
    # place that is responsible for setting up the Qt layout.
    def set_size_policy(self, direction, resizable, springy, stretch):
        """ Set the size policy of the editor's controller.

        Based on the "direction" of the group that contains this editor
        (VGroup or HGroup), set the stretch factor and the resizing
        policy of the control.

        Parameters
        ----------
        direction : QtGui.QBoxLayout.Direction
            Directionality of the group that contains this edito. Either
            QtGui.QBoxLayout.LeftToRight or QtGui.QBoxLayout.TopToBottom

        resizable : bool
            True if control should be resizable in the orientation opposite
            to the group directionality

        springy : bool
            True if control should be resizable in the orientation equal
            to the group directionality

        stretch : int
            Stretch factor used by Qt to distribute the total size to
            each component.
        """

        policy = self.control.sizePolicy()

        if direction == QtGui.QBoxLayout.LeftToRight:
            if springy:
                policy.setHorizontalStretch(stretch)
                policy.setHorizontalPolicy(QtGui.QSizePolicy.Expanding)
            if resizable:
                policy.setVerticalStretch(stretch)
                policy.setVerticalPolicy(QtGui.QSizePolicy.Expanding)

        else: # TopToBottom
            if springy:
                policy.setVerticalStretch(stretch)
                policy.setVerticalPolicy(QtGui.QSizePolicy.Expanding)
            if resizable:
                policy.setHorizontalStretch(stretch)
                policy.setHorizontalPolicy(QtGui.QSizePolicy.Expanding)

        self.control.setSizePolicy(policy)

#-------------------------------------------------------------------------------
#  'EditorWithList' class:
#-------------------------------------------------------------------------------

class EditorWithList ( Editor ):
    """ Editor for an object that contains a list.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Object containing the list being monitored
    list_object = Instance( HasTraits )

    # Name of the monitored trait
    list_name = Str

    # Function used to evaluate the current list object value:
    list_value = Callable

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Initializes the object.
        """
        factory = self.factory
        name    = factory.name
        if name != '':
            self.list_object, self.list_name, self.list_value = \
                self.parse_extended_name( name )
        else:
            self.list_object, self.list_name = factory, 'values'
            self.list_value = lambda: factory.values

        self.list_object.on_trait_change( self._list_updated,
                                          self.list_name, dispatch = 'ui' )
        self.list_object.on_trait_change( self._list_updated,
                                          self.list_name+'_items', dispatch = 'ui' )

        self._list_updated()

    #---------------------------------------------------------------------------
    #  Disconnects the listeners set up by the constructor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disconnects the listeners set up by the constructor.
        """
        self.list_object.on_trait_change( self._list_updated,
                                          self.list_name, remove = True )
        self.list_object.on_trait_change( self._list_updated,
                                          self.list_name+'_items', remove = True )

        super( EditorWithList, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the monitored trait being updated:
    #---------------------------------------------------------------------------

    def _list_updated ( self ):
        """ Handles the monitored trait being updated.
        """
        self.list_updated( self.list_value() )

    #---------------------------------------------------------------------------
    #  Handles the monitored list being updated:
    #---------------------------------------------------------------------------

    def list_updated ( self, values ):
        """ Handles the monitored list being updated.
        """
        raise NotImplementedError

#-------------------------------------------------------------------------------
#  'EditorFromView' class:
#-------------------------------------------------------------------------------

class EditorFromView ( Editor ):
    """ An editor generated from a View object.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Initializes the object.
        """
        self._ui = ui = self.init_ui( parent )
        if ui.history is None:
            ui.history = self.ui.history

        self.control = ui.control

    #---------------------------------------------------------------------------
    #  Creates and returns the traits UI defined by this editor:
    #  (Must be overridden by a subclass):
    #---------------------------------------------------------------------------

    def init_ui ( self, parent ):
        """ Creates and returns the traits UI defined by this editor.
            (Must be overridden by a subclass).
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Normally nothing needs to be done here, since it should all be handled
        # by the editor's internally created traits UI:
        pass

    #---------------------------------------------------------------------------
    #  Dispose of the editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the editor.
        """
        self._ui.dispose()

        super( EditorFromView, self ).dispose()

########NEW FILE########
__FILENAME__ = editor_factory
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the base PyQt classes the various styles of editors used in a
Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traits.api \
    import TraitError

from traitsui.editor_factory \
    import EditorFactory as BaseEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'EditorFactory' class
#   Deprecated alias for traitsui.editor_factory.EditorFactory
#-------------------------------------------------------------------------------

class EditorFactory(BaseEditorFactory):
    """ Deprecated alias for traitsui.editor_factory.EditorFactory.
    """

    def __init__(self, *args, **kwds):
        super(EditorFactory, self).__init__(*args, **kwds)
        warnings.warn("DEPRECATED: Use traitsui.editor_factory."
            ".EditorFactory instead.", DeprecationWarning)

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Base class for simple style editors, which displays a text field
    containing the text representation of the object trait value. Clicking in
    the text field displays an editor-specific dialog box for changing the
    value.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = _SimpleField(self)
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #
    #  (Normally overridden in a subclass)
    #---------------------------------------------------------------------------

    def popup_editor(self):
        """ Invokes the pop-up editor for an object trait.
        """
        pass

#-------------------------------------------------------------------------------
#  'TextEditor' class:
#-------------------------------------------------------------------------------

class TextEditor ( Editor ):
    """ Base class for text style editors, which displays an editable text
    field, containing a text representation of the object trait value.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QLineEdit(self.str_value)
        QtCore.QObject.connect(self.control,
                QtCore.SIGNAL('editingFinished()'), self.update_object)
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object(self):
        """ Handles the user changing the contents of the edit control.
        """
        try:
            self.value = unicode(self.control.text())
        except TraitError, excp:
            pass

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( Editor ):
    """ Base class for read-only style editors, which displays a read-only text
    field, containing a text representation of the object trait value.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    text_alignment_map = {
        'left'    : QtCore.Qt.AlignLeft,
        'right'   : QtCore.Qt.AlignRight,
        'just'    : QtCore.Qt.AlignJustify,
        'top'     : QtCore.Qt.AlignLeft,
        'bottom'  : QtCore.Qt.AlignBottom,
        'vcenter' : QtCore.Qt.AlignVCenter,
        'hcenter' : QtCore.Qt.AlignHCenter,
        'center'  : QtCore.Qt.AlignVCenter | QtCore.Qt.AlignHCenter
    }

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QLabel(self.str_value)

        if self.item.resizable is True or self.item.height != -1.0:
            self.control.setSizePolicy(QtGui.QSizePolicy.Expanding,
                                       QtGui.QSizePolicy.Expanding)
            self.control.setWordWrap(True)

        alignment = None
        for item in self.factory.text_alignment.split(",") :
            item_alignment = self.text_alignment_map.get(item, None)
            if item_alignment :
                if alignment :
                    alignment = alignment | item_alignment
                else :
                    alignment = item_alignment

        if alignment :
            self.control.setAlignment(alignment)

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.setText(self.str_value)

#-------------------------------------------------------------------------------
#  '_SimpleField' class:
#-------------------------------------------------------------------------------

class _SimpleField(QtGui.QLineEdit):

    def __init__(self, editor):
        QtGui.QLineEdit.__init__(self, editor.str_value)

        self.setReadOnly(True)
        self._editor = editor

    def mouseReleaseEvent(self, e):
        QtGui.QLineEdit.mouseReleaseEvent(self, e)

        if e.button() == QtCore.Qt.LeftButton:
            self._editor.popup_editor()

########NEW FILE########
__FILENAME__ = enum_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various editors and the editor factory for single-selection
    enumerations, for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from string import capitalize

from pyface.qt import QtCore, QtGui

from traits.api \
    import Bool, Property

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.enum_editor file.
from traitsui.editors.enum_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

from constants \
    import OKColor, ErrorColor

from traitsui.helper \
    import enum_values_changed

#-------------------------------------------------------------------------------
#  'BaseEditor' class:
#-------------------------------------------------------------------------------

class BaseEditor ( Editor ):
    """ Base class for enumeration editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Current set of enumeration names:
    names = Property

    # Current mapping from names to values:
    mapping = Property

    # Current inverse mapping from values to names:
    inverse_mapping = Property

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if factory.name != '':
            self._object, self._name, self._value = \
                self.parse_extended_name( factory.name )
            self.values_changed()
            self._object.on_trait_change( self._values_changed,
                                          ' ' + self._name, dispatch = 'ui' )
        else:
            factory.on_trait_change( self.rebuild_editor, 'values_modified',
                                     dispatch = 'ui' )

    #---------------------------------------------------------------------------
    #  Gets the current set of enumeration names:
    #---------------------------------------------------------------------------

    def _get_names ( self ):
        """ Gets the current set of enumeration names.
        """
        if self._object is None:
            return self.factory._names

        return self._names

    #---------------------------------------------------------------------------
    #  Gets the current mapping:
    #---------------------------------------------------------------------------

    def _get_mapping ( self ):
        """ Gets the current mapping.
        """
        if self._object is None:
            return self.factory._mapping

        return self._mapping

    #---------------------------------------------------------------------------
    #  Gets the current inverse mapping:
    #---------------------------------------------------------------------------

    def _get_inverse_mapping ( self ):
        """ Gets the current inverse mapping.
        """
        if self._object is None:
            return self.factory._inverse_mapping

        return self._inverse_mapping

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Recomputes the cached data based on the underlying enumeration model:
    #---------------------------------------------------------------------------

    def values_changed ( self ):
        """ Recomputes the cached data based on the underlying enumeration model.
        """
        self._names, self._mapping, self._inverse_mapping = \
            enum_values_changed( self._value(), self.string_value )

    #---------------------------------------------------------------------------
    #  Handles the underlying object model's enumeration set being changed:
    #---------------------------------------------------------------------------

    def _values_changed ( self ):
        """ Handles the underlying object model's enumeration set being changed.
        """
        self.values_changed()
        self.rebuild_editor()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self._object is not None:
            self._object.on_trait_change( self._values_changed,
                                          ' ' + self._name, remove = True )
        else:
            self.factory.on_trait_change( self.rebuild_editor,
                                          'values_modified', remove = True )

        super( BaseEditor, self ).dispose()

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( BaseEditor ):
    """ Simple style of enumeration editor, which displays a combo box.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( SimpleEditor, self ).init( parent )

        self.control = control = self.create_combo_box()
        control.addItems(self.names)

        QtCore.QObject.connect(control,
                               QtCore.SIGNAL('currentIndexChanged(QString)'),
                               self.update_object)

        if self.factory.evaluate is not None:
            control.setEditable(True)
            if self.factory.auto_set:
                QtCore.QObject.connect(control,
                                       QtCore.SIGNAL('editTextChanged(QString)'),
                                       self.update_text_object)
            else:
                QtCore.QObject.connect(control.lineEdit(),
                                   QtCore.SIGNAL('editingFinished()'),
                                   self.update_autoset_text_object)
            control.setInsertPolicy(QtGui.QComboBox.NoInsert)

        self._no_enum_update = 0
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Returns the QComboBox used for the editor control:
    #---------------------------------------------------------------------------

    def create_combo_box(self):
        """ Returns the QComboBox used for the editor control.
        """
        control = QtGui.QComboBox()
        control.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)
        control.setSizePolicy(QtGui.QSizePolicy.Maximum,
                              QtGui.QSizePolicy.Fixed)
        return control

    #---------------------------------------------------------------------------
    #  Adjust size policy to behave properly in group
    #---------------------------------------------------------------------------

    def set_size_policy(self, direction, resizable, springy, stretch) :
        super(SimpleEditor, self).set_size_policy(direction, resizable, springy, stretch)

        if ((direction == QtGui.QBoxLayout.LeftToRight and springy) or
            (direction != QtGui.QBoxLayout.LeftToRight and resizable)) :
            self.control.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContentsOnFirstShow)

    #---------------------------------------------------------------------------
    #  Handles the user selecting a new value from the combo box:
    #---------------------------------------------------------------------------

    def update_object (self, text):
        """ Handles the user selecting a new value from the combo box.
        """
        if self._no_enum_update == 0:
            self._no_enum_update += 1
            try:
                self.value = self.mapping[unicode(text)]
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()
            self._no_enum_update -= 1

    #---------------------------------------------------------------------------
    #  Handles the user typing text into the combo box text entry field:
    #---------------------------------------------------------------------------

    def update_text_object(self, text):
        """ Handles the user typing text into the combo box text entry field.
        """
        if self._no_enum_update == 0:
            value = unicode(text)
            try:
                value = self.mapping[value]
            except:
                try:
                    value = self.factory.evaluate(value)
                except Exception, excp:
                    self.error( excp )
                    return

            self._no_enum_update += 1
            self.value = value
            self._set_background(OKColor)
            self._no_enum_update -= 1

    def update_autoset_text_object(self):
        # Don't get the final text with the editingFinished signal
        if self.control is not None:
            text = self.control.lineEdit().text()
            return self.update_text_object(text)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self._no_enum_update == 0:
            self._no_enum_update += 1
            if self.factory.evaluate is None:
                try:
                    index = self.names.index(self.inverse_mapping[self.value])
                    self.control.setCurrentIndex(index)
                except:
                    self.control.setCurrentIndex(-1)
            else:
                try:
                    self.control.setEditText(self.str_value)
                except:
                    self.control.setEditText('')
            self._no_enum_update -= 1

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        self._set_background(ErrorColor)

    #---------------------------------------------------------------------------
    #  Sets the background color of the QLineEdit of the QComboBox.
    #---------------------------------------------------------------------------

    def _set_background(self, col):
        le = self.control.lineEdit()
        pal = QtGui.QPalette(le.palette())
        pal.setColor(QtGui.QPalette.Base, col)
        le.setPalette(pal)

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        self.control.blockSignals(True)
        self.control.clear()
        self.control.addItems(self.names)
        self.control.blockSignals(False)

        self.update_editor()

#-------------------------------------------------------------------------------
#  'RadioEditor' class:
#-------------------------------------------------------------------------------

class RadioEditor ( BaseEditor ):
    """ Enumeration editor, used for the "custom" style, that displays radio
        buttons.
    """

    # Is the button layout row-major or column-major?
    row_major = Bool( False )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( RadioEditor, self ).init( parent )

        self.control = QtGui.QWidget()
        layout = QtGui.QGridLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)

        self._mapper = QtCore.QSignalMapper()
        QtCore.QObject.connect(self._mapper, QtCore.SIGNAL('mapped(int)'),
                               self.update_object)

        self.rebuild_editor()

    #---------------------------------------------------------------------------
    #  Handles the user clicking one of the 'custom' radio buttons:
    #---------------------------------------------------------------------------

    def update_object ( self, index ):
        """ Handles the user clicking one of the custom radio buttons.
        """
        try:
            self.value = self.mapping[self.names[index]]
        except:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        layout = self.control.layout()
        value = self.value
        for i in range(layout.count()):
            rb = layout.itemAt(i).widget()
            rb.setChecked(rb.value == value)

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        # Clear any existing content:
        self.clear_layout()

        # Get the current trait value:
        cur_name = self.str_value

        # Create a sizer to manage the radio buttons:
        names   = self.names
        mapping = self.mapping
        n       = len( names )
        cols    = self.factory.cols
        rows    = (n + cols - 1) / cols
        if self.row_major:
            incr = [ 1 ] * cols
        else:
            incr = [ n / cols ] * cols
            rem  = n % cols
            for i in range( cols ):
                incr[i] += (rem > i)
            incr[-1] = -(reduce( lambda x, y: x + y, incr[:-1], 0 ) - 1)

        # Add the set of all possible choices:
        layout = self.control.layout()
        index = 0
        for i in range( rows ):
            for j in range( cols ):
                if n > 0:
                    name = names[index]
                    rb = self.create_button(name)
                    rb.value = mapping[name]

                    rb.setChecked(name == cur_name)

                    QtCore.QObject.connect(rb, QtCore.SIGNAL('clicked()'),
                                           self._mapper, QtCore.SLOT('map()'))
                    self._mapper.setMapping(rb, index)

                    self.set_tooltip(rb)
                    layout.addWidget(rb, i, j)

                    index += incr[j]
                    n -= 1

    #---------------------------------------------------------------------------
    #  Returns the QAbstractButton used for the radio button:
    #---------------------------------------------------------------------------

    def create_button(self, name):
        """ Returns the QAbstractButton used for the radio button.
        """
        label = self.string_value(name, capitalize)
        return QtGui.QRadioButton(label)

#-------------------------------------------------------------------------------
#  'ListEditor' class:
#-------------------------------------------------------------------------------

class ListEditor ( BaseEditor ):
    """ Enumeration editor, used for the "custom" style, that displays a list
        box.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( ListEditor, self ).init( parent )

        self.control = QtGui.QListWidget()
        QtCore.QObject.connect(self.control,
                QtCore.SIGNAL('currentTextChanged(QString)'),
                self.update_object)

        self.rebuild_editor()
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user selecting a list box item:
    #---------------------------------------------------------------------------

    def update_object(self, text):
        """ Handles the user selecting a list box item.
        """
        value = unicode(text)
        try:
            value = self.mapping[ value ]
        except:
            try:
                value = self.factory.evaluate( value )
            except:
                pass
        try:
            self.value = value
        except:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        control = self.control
        try:
            value = self.inverse_mapping[self.value]

            for row in range(control.count()):
                itm = control.item(row)

                if itm.text() == value:
                    control.setCurrentItem(itm)
                    control.scrollToItem(itm)
                    break
        except:
            pass

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """

        self.control.blockSignals(True)
        self.control.clear()
        for name in self.names:
            self.control.addItem(name)
        self.control.blockSignals(False)

        self.update_editor()

########NEW FILE########
__FILENAME__ = bounds_editor
from pyface.qt import QtGui, QtCore

from traits.api import Float, Any, Str, Trait
from traitsui.editors.api import RangeEditor
from traitsui.qt4.editor import Editor
from traitsui.qt4.extra.range_slider import RangeSlider

class _BoundsEditor(Editor):

    evaluate = Any

    min = Any
    max = Any
    low = Any
    high = Any
    format = Str

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if not factory.low_name:
            self.low = factory.low

        if not factory.high_name:
            self.high = factory.high

        self.max = factory.max
        self.min = factory.min

        self.format = factory.format

        self.evaluate = factory.evaluate
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        self.sync_value( factory.low_name,  'low',  'both' )
        self.sync_value( factory.high_name, 'high', 'both' )

        self.control = QtGui.QWidget()
        panel = QtGui.QHBoxLayout(self.control)
        panel.setContentsMargins(0, 0, 0, 0)

        self._label_lo = QtGui.QLineEdit(self.format % self.low)
        QtCore.QObject.connect(self._label_lo, QtCore.SIGNAL('editingFinished()'),
                self.update_low_on_enter)
        panel.addWidget(self._label_lo)

        # The default size is a bit too big and probably doesn't need to grow.
        sh = self._label_lo.sizeHint()
        sh.setWidth(sh.width() / 2)
        self._label_lo.setMaximumSize(sh)

        self.control.slider = slider = RangeSlider(QtCore.Qt.Horizontal)
        slider.setTracking(factory.auto_set)
        slider.setMinimum(0)
        slider.setMaximum(10000)
        slider.setPageStep(1000)
        slider.setSingleStep(100)
        slider.setLow(self._convert_to_slider(self.low))
        slider.setHigh(self._convert_to_slider(self.high))

        QtCore.QObject.connect(slider, QtCore.SIGNAL('sliderMoved(int)'),
                self.update_object_on_scroll)
        panel.addWidget(slider)

        self._label_hi = QtGui.QLineEdit(self.format % self.high)
        QtCore.QObject.connect(self._label_hi, QtCore.SIGNAL('editingFinished()'),
                self.update_high_on_enter)
        panel.addWidget(self._label_hi)

        # The default size is a bit too big and probably doesn't need to grow.
        sh = self._label_hi.sizeHint()
        sh.setWidth(sh.width() / 2)
        self._label_hi.setMaximumSize(sh)

        self.set_tooltip(slider)
        self.set_tooltip(self._label_lo)
        self.set_tooltip(self._label_hi)

    def update_low_on_enter(self):
        try:
            try:
                low = eval(unicode(self._label_lo.text()).strip())
                if self.evaluate is not None:
                    low = self.evaluate(low)
            except Exception, ex:
                low = self.low
                self._label_lo.setText(self.format % self.low)

            if not self.factory.is_float:
                low = int(low)

            if low > self.high:
                low = self.high - self._step_size()
                self._label_lo.setText(self.format % low)

            self.control.slider.setLow(self._convert_to_slider(low))
            self.low = low
        except:
            pass

    def update_high_on_enter(self):
        try:
            try:
                high = eval(unicode(self._label_hi.text()).strip())
                if self.evaluate is not None:
                    high = self.evaluate(high)
            except:
                high = self.high
                self._label_hi.setText(self.format % self.high)

            if not self.factory.is_float:
                high = int(high)

            if high < self.low:
                high = self.low + self._step_size()
                self._label_hi.setText(self.format % high)

            self.control.slider.setHigh(self._convert_to_slider(high))
            self.high = high
        except:
            pass

    def update_object_on_scroll(self, pos):
        low = self._convert_from_slider(self.control.slider.low())
        high = self._convert_from_slider(self.control.slider.high())

        if self.factory.is_float:
            self.low = low
            self.high = high
        else:
            self.low = int(low)
            self.high = int(high)

            # update the sliders to the int values or the sliders
            # will jiggle
            self.control.slider.setLow(self._convert_to_slider(low))
            self.control.slider.setHigh(self._convert_to_slider(high))


    def update_editor(self):
        return

    def _check_max_and_min(self):
        # check if max & min have been defined:
        if self.max is None:
            self.max = self.high
        if self.min is None:
            self.min = self.low

    def _step_size(self):
        slider_delta = self.control.slider.maximum() - self.control.slider.minimum()
        range_delta = self.max - self.min

        return float(range_delta)/slider_delta

    def _convert_from_slider(self, slider_val):
        self._check_max_and_min()
        return self.min + slider_val * self._step_size()

    def _convert_to_slider(self, value):
        self._check_max_and_min()
        return self.control.slider.minimum() + (value-self.min) / self._step_size()

    def _low_changed(self, low):
        if self.control is None:
            return
        if self._label_lo is not None:
            self._label_lo.setText(self.format % low)

        self.control.slider.setLow(self._convert_to_slider(low))

    def _high_changed(self, high):
        if self.control is None:
            return
        if self._label_hi is not None:
            self._label_hi.setText(self.format % high)

        self.control.slider.setHigh(self._convert_to_slider(self.high))

class BoundsEditor(RangeEditor):

    min = Trait(None, Float)
    max = Trait(None, Float)

    def _get_simple_editor_class(self):
        return _BoundsEditor
    def _get_custom_editor_class(self):
        return _BoundsEditor

########NEW FILE########
__FILENAME__ = checkbox_renderer
#------------------------------------------------------------------------------
# Copyright (c) 2009, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Evan Patterson
# Date: 06/26/09
#------------------------------------------------------------------------------

""" A renderer which displays a checked-box for a True value and an unchecked
    box for a false value.
"""

# System library imports
from pyface.qt import QtCore, QtGui

# ETS imports
from traitsui.qt4.table_editor import TableDelegate


class CheckboxRenderer(TableDelegate):
    """ A renderer which displays a checked-box for a True value and an
        unchecked box for a false value.
    """

    #---------------------------------------------------------------------------
    #  QAbstractItemDelegate interface
    #---------------------------------------------------------------------------

    def editorEvent(self, event, model, option, index):
        """ Reimplemented to handle mouse button clicks.
        """
        if event.type() == QtCore.QEvent.MouseButtonRelease and \
                event.button() == QtCore.Qt.LeftButton:
            column = index.model()._editor.columns[index.column()]
            obj = index.data(QtCore.Qt.UserRole)
            checked = bool(column.get_raw_value(obj))
            column.set_value(obj, not checked)
            return True
        else:
            return False

    def paint(self, painter, option, index):
        """ Reimplemented to paint the checkbox.
        """
        # Determine whether the checkbox is check or unchecked
        column = index.model()._editor.columns[index.column()]
        obj = index.data(QtCore.Qt.UserRole)
        checked = column.get_raw_value(obj)

        # First draw the background
        painter.save()
        row_brushes = [option.palette.base(), option.palette.alternateBase()]
        if option.state & QtGui.QStyle.State_Selected:
            bg_brush = option.palette.highlight()
        else:
            bg_brush = index.data(QtCore.Qt.BackgroundRole)
            if bg_brush == NotImplemented or bg_brush is None:
                if index.model()._editor.factory.alternate_bg_color:
                    bg_brush = row_brushes[index.row() % 2]
                else:
                    bg_brush = row_brushes[0]
        painter.fillRect(option.rect, bg_brush)

        # Then draw the checkbox
        style = QtGui.QApplication.instance().style()
        box = QtGui.QStyleOptionButton()
        box.palette = option.palette

        # Align the checkbox appropriately.
        box.rect = option.rect
        size = style.sizeFromContents(QtGui.QStyle.CT_CheckBox, box,
            QtCore.QSize(), None)
        box.rect.setWidth(size.width())
        margin = style.pixelMetric(QtGui.QStyle.PM_ButtonMargin, box)
        alignment = column.horizontal_alignment
        if alignment == 'left':
            box.rect.setLeft(option.rect.left() + margin)
        elif alignment == 'right':
            box.rect.setLeft(option.rect.right() - size.width() - margin)
        else:
            # FIXME: I don't know why I need the 2 pixels, but I do.
            box.rect.setLeft(option.rect.left() + option.rect.width() // 2 -
                size.width() // 2 + margin - 2)

        box.state = QtGui.QStyle.State_Enabled
        if checked:
            box.state |= QtGui.QStyle.State_On
        else:
            box.state |= QtGui.QStyle.State_Off
        style.drawControl(QtGui.QStyle.CE_CheckBox, box, painter)
        painter.restore()

    def sizeHint(self, option, index):
        """ Reimplemented to provide size hint based on a checkbox
        """
        box = QtGui.QStyleOptionButton()
        style = QtGui.QApplication.instance().style()
        return style.sizeFromContents(QtGui.QStyle.CT_CheckBox, box,
                                      QtCore.QSize(), None)

########NEW FILE########
__FILENAME__ = qt_view
#------------------------------------------------------------------------------
# Copyright (c) 2011, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Evan Patterson
#------------------------------------------------------------------------------

""" Defines a Traits UI View that allows for the customization of Qt-specific
    widget properties.
"""

# Standard library imports.
import logging

# System library imports.
from pyface.qt import QtGui

# Enthought library imports.
from traits.api import File, List, Str
from traitsui.view import View

# Logger.
logger = logging.getLogger(__name__)


class QtView(View):
    """ A View that allows the specification of Qt style sheets.
    """

    # An optional string containing a Qt style sheet.
    style_sheet = Str

    # An optional file path for a Qt style sheet.
    style_sheet_path = File

    # A list of trait names that defines the order for focus switching via
    # Tab/Shift+Tab. If the view contains multiple items for a specified trait
    # name, the order is undefined.
    tab_order = List(Str)

    #---------------------------------------------------------------------------
    #  Creates a UI user interface object:
    #---------------------------------------------------------------------------

    def ui(self, context, parent=None, kind=None, view_elements=None,
           handler=None, id='', scrollable=None, args=None):
        ui = super(QtView, self).ui(context, parent, kind, view_elements,
                                    handler, id, scrollable, args)

        if self.style_sheet:
            ui.control.setStyleSheet(self.style_sheet)

        if self.style_sheet_path:
            try:
                with open(self.style_sheet_path, 'r') as f:
                    ui.control.setStyleSheet(f.read())
            except IOError:
                logger.exception("Error loading Qt style sheet")

        if len(self.tab_order) >= 2:
            previous = self._get_editor_control(ui, self.tab_order[0])
            for i in xrange(1, len(self.tab_order)):
                current = self._get_editor_control(ui, self.tab_order[i])
                QtGui.QWidget.setTabOrder(previous, current)
                previous = current

        return ui

    #---------------------------------------------------------------------------
    #  Private interface:
    #---------------------------------------------------------------------------

    def _get_editor_control(self, ui, name):
        control = None
        editors = ui.get_editors(name)
        if editors:
            control = editors[0].control
        else:
            logger.warning("No item for '%s' trait" % name)
        return control

########NEW FILE########
__FILENAME__ = range_slider
from pyface.qt import QtGui, QtCore

class RangeSlider(QtGui.QSlider):
    """ A slider for ranges.

        This class provides a dual-slider for ranges, where there is a defined
        maximum and minimum, as is a normal slider, but instead of having a
        single slider value, there are 2 slider values.

        This class emits the same signals as the QSlider base class, with the
        exception of valueChanged
    """
    def __init__(self, *args):
        super(RangeSlider, self).__init__(*args)

        self._low = self.minimum()
        self._high = self.maximum()

        self.pressed_control = QtGui.QStyle.SC_None
        self.hover_control = QtGui.QStyle.SC_None
        self.click_offset = 0

        # 0 for the low, 1 for the high, -1 for both
        self.active_slider = 0

    def low(self):
        return self._low

    def setLow(self, low):
        self._low = low
        self.update()

    def high(self):
        return self._high

    def setHigh(self, high):
        self._high = high
        self.update()


    def paintEvent(self, event):
        # based on http://qt.gitorious.org/qt/qt/blobs/master/src/gui/widgets/qslider.cpp

        painter = QtGui.QPainter(self)
        style = QtGui.QApplication.style()

        for i, value in enumerate([self._low, self._high]):
            opt = QtGui.QStyleOptionSlider()
            self.initStyleOption(opt)

            # Only draw the groove for the first slider so it doesn't get drawn
            # on top of the existing ones every time
            if i == 0:
                opt.subControls = QtGui.QStyle.SC_SliderGroove | QtGui.QStyle.SC_SliderHandle
            else:
                opt.subControls = QtGui.QStyle.SC_SliderHandle

            if self.tickPosition() != self.NoTicks:
                opt.subControls |= QtGui.QStyle.SC_SliderTickmarks

            if self.pressed_control:
                opt.activeSubControls = self.pressed_control
                opt.state |= QtGui.QStyle.State_Sunken
            else:
                opt.activeSubControls = self.hover_control

            opt.sliderPosition = value
            opt.sliderValue = value
            style.drawComplexControl(QtGui.QStyle.CC_Slider, opt, painter, self)


    def mousePressEvent(self, event):
        event.accept()

        style = QtGui.QApplication.style()
        button = event.button()

        # In a normal slider control, when the user clicks on a point in the
        # slider's total range, but not on the slider part of the control the
        # control would jump the slider value to where the user clicked.
        # For this control, clicks which are not direct hits will slide both
        # slider parts

        if button:
            opt = QtGui.QStyleOptionSlider()
            self.initStyleOption(opt)

            self.active_slider = -1

            for i, value in enumerate([self._low, self._high]):
                opt.sliderPosition = value
                hit = style.hitTestComplexControl(style.CC_Slider, opt, event.pos(), self)
                if hit == style.SC_SliderHandle:
                    self.active_slider = i
                    self.pressed_control = hit

                    self.triggerAction(self.SliderMove)
                    self.setRepeatAction(self.SliderNoAction)
                    self.setSliderDown(True)
                    break

            if self.active_slider < 0:
                self.pressed_control = QtGui.QStyle.SC_SliderHandle
                self.click_offset = self.__pixelPosToRangeValue(self.__pick(event.pos()))
                self.triggerAction(self.SliderMove)
                self.setRepeatAction(self.SliderNoAction)
        else:
            event.ignore()

    def mouseMoveEvent(self, event):
        if self.pressed_control != QtGui.QStyle.SC_SliderHandle:
            event.ignore()
            return

        event.accept()
        new_pos = self.__pixelPosToRangeValue(self.__pick(event.pos()))
        opt = QtGui.QStyleOptionSlider()
        self.initStyleOption(opt)

        if self.active_slider < 0:
            offset = new_pos - self.click_offset
            self._high += offset
            self._low += offset
            if self._low < self.minimum():
                diff = self.minimum() - self._low
                self._low += diff
                self._high += diff
            if self._high > self.maximum():
                diff = self.maximum() - self._high
                self._low += diff
                self._high += diff
        elif self.active_slider == 0:
            if new_pos >= self._high:
                new_pos = self._high - 1
            self._low = new_pos
        else:
            if new_pos <= self._low:
                new_pos = self._low + 1
            self._high = new_pos

        self.click_offset = new_pos

        self.update()

        self.emit(QtCore.SIGNAL('sliderMoved(int)'), new_pos)

    def __pick(self, pt):
        if self.orientation() == QtCore.Qt.Horizontal:
            return pt.x()
        else:
            return pt.y()


    def __pixelPosToRangeValue(self, pos):
        opt = QtGui.QStyleOptionSlider()
        self.initStyleOption(opt)
        style = QtGui.QApplication.style()

        gr = style.subControlRect(style.CC_Slider, opt, style.SC_SliderGroove, self)
        sr = style.subControlRect(style.CC_Slider, opt, style.SC_SliderHandle, self)

        if self.orientation() == QtCore.Qt.Horizontal:
            slider_length = sr.width()
            slider_min = gr.x()
            slider_max = gr.right() - slider_length + 1
        else:
            slider_length = sr.height()
            slider_min = gr.y()
            slider_max = gr.bottom() - slider_length + 1

        return style.sliderValueFromPosition(self.minimum(), self.maximum(),
                                             pos-slider_min, slider_max-slider_min,
                                             opt.upsideDown)

if __name__ == "__main__":
    import sys
    def echo(value):
        print value
    app = QtGui.QApplication(sys.argv)
    slider = RangeSlider()
    slider.setMinimum(0)
    slider.setMaximum(10000)
    slider.setLow(0)
    slider.setHigh(10000)
    QtCore.QObject.connect(slider, QtCore.SIGNAL('sliderMoved(int)'), echo)
    slider.show()
    app.exec_()

########NEW FILE########
__FILENAME__ = table_image_renderer
#------------------------------------------------------------------------------
# Copyright (c) 2009, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Evan Patterson
# Date: 06/25/09
#------------------------------------------------------------------------------

""" A renderer which will display a cell-specific image in addition to some
    text displayed in the same way the default renderer would.
"""

# System library imports
from pyface.qt import QtCore, QtGui

# ETS imports
from traits.api import Bool
from traitsui.qt4.table_editor import TableDelegate


class TableImageRenderer(TableDelegate):
    """ A renderer which will display a cell-specific image in addition to some
        text displayed in the same way the default renderer would.
    """

    # Should the image be scaled to the size of the cell
    scale_to_cell = Bool(True)

    #---------------------------------------------------------------------------
    #  TableImageRenderer interface
    #---------------------------------------------------------------------------

    def get_image_for_obj(self, value, row, col):
        """ Return the image for the cell given the raw cell value and the row
            and column numbers.
        """
        return None

    #---------------------------------------------------------------------------
    #  QAbstractItemDelegate interface
    #---------------------------------------------------------------------------

    def paint(self, painter, option, index):
        """ Overriden to draw images.
        """
        # First draw any text/background by delegating to our superclass
        QtGui.QStyledItemDelegate.paint(self, painter, option, index)

        # Now draw the image, if possible
        value = index.data(QtCore.Qt.UserRole)
        image = self.get_image_for_obj(value, index.row(), index.column())
        if image:
            image = image.create_bitmap()
            if self.scale_to_cell:
                w = min(image.width(), option.rect.width())
                h = min(image.height(), option.rect.height())
            else:
                w = image.width()
                h = image.height()

            x = option.rect.x()
            y = option.rect.y() + (option.rect.height()-h)/2

            target = QtCore.QRect(x, y, w, h)
            painter.drawPixmap(target, image)

    def sizeHint(self, option, index):
        """ Overriden to take image size into account when providing a size
            hint.
        """
        size = QtGui.QStyledItemDelegate.sizeHint(self, option, index)

        value = index.data(QtCore.Qt.UserRole)
        image = self.get_image_for_obj(value, index.row(), index.column())
        if image:
            image = image.create_bitmap()
            size.setWidth(max(image.width(), size.width()))
            size.setHeight(max(image.height(), size.height()))

        return size

########NEW FILE########
__FILENAME__ = file_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines file editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from os.path import splitext, isfile, exists

from pyface.qt import QtCore, QtGui
from traits.api import List, Event, File, Unicode, TraitError

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.file_editor file.
from traitsui.editors.file_editor import ToolkitEditorFactory
from text_editor import SimpleEditor as SimpleTextEditor
from helper import IconButton

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Wildcard filter:
filter_trait = List(Unicode)

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( SimpleTextEditor ):
    """ Simple style of file editor, consisting of a text field and a **Browse**
        button that opens a file-selection dialog box. The user can also drag
        and drop a file onto this control.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QWidget()
        layout = QtGui.QHBoxLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)

        self._file_name = control = QtGui.QLineEdit()
        layout.addWidget(control)

        if self.factory.auto_set:
            signal = QtCore.SIGNAL('textEdited(QString)')
        else:
            # Assume enter_set is set, or else the value will never get updated.
            signal = QtCore.SIGNAL('editingFinished()')
        QtCore.QObject.connect(control, signal, self.update_object)

        button = IconButton(QtGui.QStyle.SP_DirIcon, self.show_file_dialog)
        layout.addWidget(button)

        self.set_tooltip(control)

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object(self):
        """ Handles the user changing the contents of the edit control.
        """
        if self.control is not None:
            file_name = unicode(self._file_name.text())
            try:
                if self.factory.truncate_ext:
                    file_name = splitext( file_name )[0]

                self.value = file_name
            except TraitError, excp:
                self._file_name.setText(self.value)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self._file_name.setText(self.str_value)

    #---------------------------------------------------------------------------
    #  Displays the pop-up file dialog:
    #---------------------------------------------------------------------------

    def show_file_dialog(self):
        """ Displays the pop-up file dialog.
        """
        # We don't used the canned functions because we don't know how the
        # file name is to be used (ie. an existing one to be opened or a new
        # one to be created).
        dlg = self._create_file_dialog()

        if dlg.exec_() == QtGui.QDialog.Accepted:
            files = dlg.selectedFiles()

            if len(files) > 0:
                file_name = unicode(files[0])

                if self.factory.truncate_ext:
                    file_name = splitext(file_name)[0]

                self.value = file_name
                self.update_editor()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._file_name

    #-- Private Methods --------------------------------------------------------

    def _create_file_dialog ( self ):
        """ Creates the correct type of file dialog.
        """
        dlg = QtGui.QFileDialog(self.control)
        dlg.selectFile(self._file_name.text())

        if len(self.factory.filter) > 0:
            dlg.setNameFilters(self.factory.filter)

        return dlg

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleTextEditor ):
    """ Custom style of file editor, consisting of a file system tree view.
    """

    # Is the file editor scrollable? This value overrides the default.
    scrollable = True

    # Wildcard filter to apply to the file dialog:
    filter = filter_trait

    # The root path of the file tree view.
    root_path = File

    # Event fired when the file system view should be rebuilt:
    reload = Event

    # Event fired when the user double-clicks a file:
    dclick = Event

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = _TreeView(self)

        self._model = model = QtGui.QFileSystemModel()
        self.control.setModel(model)

        # Don't apply filters to directories and don't show "." and ".."
        model.setFilter(QtCore.QDir.AllDirs | QtCore.QDir.Files |
                        QtCore.QDir.Drives | QtCore.QDir.NoDotAndDotDot)

        # Hide filtered out files instead of only disabling them
        self._model.setNameFilterDisables(False)

        # Show the full filesystem by default.
        model.setRootPath(QtCore.QDir.rootPath())

        # Hide the labels at the top and only show the column for the file name
        self.control.header().hide()
        for column in xrange(1, model.columnCount()):
            self.control.hideColumn(column)

        factory = self.factory
        self.filter = factory.filter
        self.root_path = factory.root_path
        self.sync_value(factory.filter_name, 'filter', 'from', is_list=True)
        self.sync_value(factory.root_path_name, 'root_path', 'from')
        self.sync_value(factory.reload_name, 'reload', 'from')
        self.sync_value(factory.dclick_name, 'dclick', 'to')

        self.set_tooltip()

        # This is needed to enable horizontal scrollbar.
        self.control.header().setResizeMode(0, QtGui.QHeaderView.ResizeToContents)
        self.control.header().setStretchLastSection(False)

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object(self, idx):
        """ Handles the user changing the contents of the edit control.
        """
        if self.control is not None:
            path = unicode(self._model.filePath(idx))

            if self.factory.allow_dir or isfile(path):
                if self.factory.truncate_ext:
                    path = splitext( path )[0]

                self.value = path

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if exists(self.str_value):
            index = self._model.index(self.str_value)
            self.control.expand(index)
            self.control.setCurrentIndex(index)

    #---------------------------------------------------------------------------
    #  Handles the 'filter' trait being changed:
    #---------------------------------------------------------------------------

    def _filter_changed ( self ):
        """ Handles the 'filter' trait being changed.
        """
        self._model.setNameFilters(self.filter)

    #---------------------------------------------------------------------------
    #  Handles the 'root_path' trait being changed:
    #---------------------------------------------------------------------------

    def _root_path_changed ( self ):
        """ Handles the 'root_path' trait being changed.
        """
        path = self.root_path
        if not path:
            path = QtCore.QDir.rootPath()
        self._model.setRootPath(path)
        self.control.setRootIndex(self._model.index(path))

    #---------------------------------------------------------------------------
    #  Handles the user double-clicking on a file name:
    #---------------------------------------------------------------------------

    def _on_dclick ( self, idx ):
        """ Handles the user double-clicking on a file name.
        """
        self.dclick = unicode(self._model.filePath(idx))

    #---------------------------------------------------------------------------
    #  Handles the 'reload' trait being changed:
    #---------------------------------------------------------------------------

    def _reload_changed ( self ):
        """ Handles the 'reload' trait being changed.
        """
        self._model.refresh()

#-------------------------------------------------------------------------------
#  '_TreeView' class:
#-------------------------------------------------------------------------------

class _TreeView(QtGui.QTreeView):
    """ This is an internal class needed because QAbstractItemView doesn't
        provide a signal for when the current index changes.
    """

    def __init__(self, editor):
        super(_TreeView, self).__init__()
        self.doubleClicked.connect(editor._on_dclick)
        self._editor = editor
        
    def event(self, event): 
        if event.type() == QtCore.QEvent.ToolTip:
            index = self.indexAt(event.pos())
            if index and index.isValid():
                QtGui.QToolTip.showText(event.globalPos(), index.data(), self)
            else:
                QtGui.QToolTip.hideText()
                event.ignore()
                                
            return True
            
        return super(_TreeView, self).event(event)

    def keyPressEvent(self, keyevent):
        key = keyevent.key()
        if key == QtCore.Qt.Key_Return or key == QtCore.Qt.Key_Enter:
            self._editor._on_dclick(self.selectedIndexes()[0])
            keyevent.accept()
        QtGui.QTreeView.keyPressEvent(self, keyevent)

    def currentChanged(self, current, previous):
        """ Reimplemented to tell the editor when the current index has changed.
        """
        super(_TreeView, self).currentChanged(current, previous)
        self._editor.update_object(current)

########NEW FILE########
__FILENAME__ = font_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various font editors and the font editor factory, for the
    PyQt user interface toolkit..
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traitsui.editors.font_editor \
    import ToolkitEditorFactory as BaseToolkitEditorFactory

from editor_factory \
    import SimpleEditor as BaseSimpleEditor, \
    TextEditor as BaseTextEditor, \
    ReadonlyEditor as BaseReadonlyEditor

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Standard font point sizes
PointSizes = [
   '8',  '9', '10', '11', '12', '14', '16', '18',
  '20', '22', '24', '26', '28', '36', '48', '72'
]

#---------------------------------------------------------------------------
#  The PyQtToolkitEditorFactory class.
#---------------------------------------------------------------------------
## We need to add qt4-specific methods to the editor factory, and so we create
## a subclass of the BaseToolkitEditorFactory.

class ToolkitEditorFactory(BaseToolkitEditorFactory):
    """ PyQt editor factory for font editors.
    """
    #---------------------------------------------------------------------------
    #  Returns a QFont object corresponding to a specified object's font trait:
    #---------------------------------------------------------------------------

    def to_qt4_font ( self, editor ):
        """ Returns a QFont object corresponding to a specified object's font
        trait.
        """
        return QtGui.QFont(editor.value)

    #---------------------------------------------------------------------------
    #  Gets the application equivalent of a QFont value:
    #---------------------------------------------------------------------------

    def from_qt4_font ( self, font ):
        """ Gets the application equivalent of a QFont value.
        """
        return font

    #---------------------------------------------------------------------------
    #  Returns the text representation of the specified object trait value:
    #---------------------------------------------------------------------------

    def str_font ( self, font ):
        """ Returns the text representation of the specified object trait value.
        """
        weight = { QtGui.QFont.Light: ' Light',
                   QtGui.QFont.Bold:  ' Bold'   }.get(font.weight(), '')
        style  = { QtGui.QFont.StyleOblique: ' Slant',
                   QtGui.QFont.StyleItalic:  ' Italic' }.get(font.style(), '')
        return '%s point %s%s%s' % (
               font.pointSize(), font.family(), style, weight )

#-------------------------------------------------------------------------------
#  'SimpleFontEditor' class:
#-------------------------------------------------------------------------------

class SimpleFontEditor ( BaseSimpleEditor ):
    """ Simple style of font editor, which displays a text field that contains
    a text representation of the font value (using that font if possible).
    Clicking the field displays a font selection dialog box.
    """
    #---------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #---------------------------------------------------------------------------

    def popup_editor(self):
        """ Invokes the pop-up editor for an object trait.
        """
        fnt, ok = QtGui.QFontDialog.getFont(self.factory.to_qt4_font(self),
                                            self.control)

        if ok:
            self.value = self.factory.from_qt4_font(fnt)
            self.update_editor()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        super( SimpleFontEditor, self ).update_editor()
        set_font( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

#-------------------------------------------------------------------------------
#  'CustomFontEditor' class:
#-------------------------------------------------------------------------------

class CustomFontEditor ( Editor ):
    """ Custom style of font editor, which displays the following:

        * A text field containing the text representation of the font value
          (using that font if possible).
        * A combo box containing all available type face names.
        * A combo box containing the available type sizes.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QWidget()
        layout = QtGui.QVBoxLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)

        # Add the standard font control:
        self._font = font = QtGui.QLineEdit(self.str_value)
        QtCore.QObject.connect(font, QtCore.SIGNAL('editingFinished()'),
                self.update_object)
        layout.addWidget(font)

        # Add all of the font choice controls:
        layout2 = QtGui.QHBoxLayout()

        self._facename = control = QtGui.QFontComboBox()
        control.setEditable(False)
        QtCore.QObject.connect(control,
                QtCore.SIGNAL('currentFontChanged(QFont)'),
                self.update_object_parts)
        layout2.addWidget(control)

        self._point_size = control = QtGui.QComboBox()
        control.addItems(PointSizes)
        QtCore.QObject.connect(control,
                QtCore.SIGNAL('currentIndexChanged(int)'),
                self.update_object_parts)
        layout2.addWidget(control)

        # These don't have explicit controls.
        self._bold = self._italic = False

        layout.addLayout(layout2)

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the font text control:
    #---------------------------------------------------------------------------

    def update_object (self):
        """ Handles the user changing the contents of the font text control.
        """
        self.value = unicode(self._font.text())
        self._set_font(self.factory.to_qt4_font(self))
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Handles the user modifying one of the font components:
    #---------------------------------------------------------------------------

    def update_object_parts (self):
        """ Handles the user modifying one of the font components.
        """
        fnt = self._facename.currentFont()

        fnt.setBold(self._bold)
        fnt.setItalic(self._italic)

        psz = int(self._point_size.currentText())
        fnt.setPointSize(psz)

        self.value = self.factory.from_qt4_font(fnt)

        self._font.setText(self.str_value)
        self._set_font(fnt)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        font = self.factory.to_qt4_font( self )

        self._bold = font.bold()
        self._italic = font.italic()

        self._facename.setCurrentFont(font)

        try:
           idx = PointSizes.index(str(font.pointSize()))
        except ValueError:
           idx = PointSizes.index('9')

        self._point_size.setCurrentIndex(idx)

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return [ self._font, self._facename, self._point_size ]

    #-- Private Methods --------------------------------------------------------

    def _set_font ( self, font ):
        """ Sets the font used by the text control to the specified font.
        """
        font.setPointSize( min( 10, font.pointSize() ) )
        self._font.setFont( font )

#-------------------------------------------------------------------------------
#  'TextFontEditor' class:
#-------------------------------------------------------------------------------

class TextFontEditor ( BaseTextEditor ):
    """ Text style of font editor, which displays an editable text field
    containing a text representation of the font value (using that font if
    possible).
    """
    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object(self):
        """ Handles the user changing the contents of the edit control.
        """
        self.value = unicode(self.control.text())

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        super( TextFontEditor, self ).update_editor()
        set_font( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

#-------------------------------------------------------------------------------
#  'ReadonlyFontEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyFontEditor ( BaseReadonlyEditor ):
    """ Read-only style of font editor, which displays a read-only text field
    containing a text representation of the font value (using that font if
    possible).
    """
    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        super( ReadonlyFontEditor, self ).update_editor()
        set_font( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

#-------------------------------------------------------------------------------
#  Set the editor control's font to match a specified font:
#-------------------------------------------------------------------------------

def set_font ( editor ):
    """ Sets the editor control's font to match a specified font.
    """
    editor.control.setFont(editor.factory.to_qt4_font(editor))


# Define the names SimpleEditor, CustomEditor, TextEditor and ReadonlyEditor
# which are looked up by the editor factory for the font editor.
SimpleEditor = SimpleFontEditor
CustomEditor = CustomFontEditor
TextEditor = TextFontEditor
ReadonlyEditor = ReadonlyFontEditor

########NEW FILE########
__FILENAME__ = font_trait
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Trait definition for a PyQt-based font.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

from traits.api \
    import Trait, TraitHandler, TraitError

#-------------------------------------------------------------------------------
#  Convert a string into a valid QFont object (if possible):
#-------------------------------------------------------------------------------

# Mapping of strings to valid QFont style hints.
font_families = {
    'default':    QtGui.QFont.AnyStyle,
    'decorative': QtGui.QFont.Decorative,
    'roman':      QtGui.QFont.Serif,
    'script':     QtGui.QFont.SansSerif,
    'swiss':      QtGui.QFont.SansSerif,
    'modern':     QtGui.QFont.TypeWriter
}

# Mapping of strings to QFont styles.
font_styles = {
    'slant':  QtGui.QFont.StyleOblique,
    'italic': QtGui.QFont.StyleItalic
}

# Mapping of strings to QFont weights.
font_weights = {
    'light': QtGui.QFont.Light,
    'bold':  QtGui.QFont.Bold
}

# Strings to ignore in text representations of fonts
font_noise = [ 'pt', 'point', 'family' ]

#-------------------------------------------------------------------------------
#  Converts a QFont into a string description of itself:
#-------------------------------------------------------------------------------

def font_to_str ( font ):
    """ Converts a QFont into a string description of itself.
    """
    weight = { QtGui.QFont.Light:  ' Light',
               QtGui.QFont.Bold:   ' Bold'   }.get(font.weight(), '')
    style  = { QtGui.QFont.StyleOblique:  ' Slant',
               QtGui.QFont.StyleItalic:   ' Italic' }.get(font.style(), '')
    underline = ''
    if font.underline():
        underline = ' underline'
    return '%s point %s%s%s%s' % (
           font.pointSize(), unicode(font.family()), style, weight, underline )

#-------------------------------------------------------------------------------
#  Create a TraitFont object from a string description:
#-------------------------------------------------------------------------------

def create_traitsfont(value):
    """ Create a TraitFont object from a string description.
    """
    if isinstance(value, QtGui.QFont):
        return TraitsFont(value)

    point_size = None
    family     = ''
    style      = QtGui.QFont.StyleNormal
    weight     = QtGui.QFont.Normal
    underline  = False
    facename   = []

    for word in value.split():
        lword = word.lower()
        if font_families.has_key(lword):
            f = QtGui.QFont()
            f.setStyleHint(font_families[lword])
            family = f.defaultFamily()
        elif font_styles.has_key(lword):
            style = font_styles[lword]
        elif font_weights.has_key(lword):
            weight = font_weights[lword]
        elif lword == 'underline':
            underline = True
        elif lword not in font_noise:
            if point_size is None:
                try:
                    point_size = int(lword)
                    continue
                except:
                    pass
            facename.append(word)

    if facename:
        family = ' '.join(facename)

    if family:
        fnt = TraitsFont(family)
    else:
        fnt = TraitsFont()

    fnt.setStyle(style)
    fnt.setWeight(weight)
    fnt.setUnderline(underline)

    if point_size is None:
        fnt.setPointSize(QtGui.QApplication.font().pointSize())
    else:
        fnt.setPointSize(point_size)

    return fnt

#-------------------------------------------------------------------------------
#  'TraitsFont' class:
#-------------------------------------------------------------------------------

class TraitsFont(QtGui.QFont):
    """ A Traits-specific QFont.
    """
    #---------------------------------------------------------------------------
    #  Returns the pickleable form of a TraitsFont object:
    #---------------------------------------------------------------------------

    def __reduce_ex__(self, protocol):
        """ Returns the pickleable form of a TraitsFont object.
        """
        return (create_traitsfont, (font_to_str(self), ))

    #---------------------------------------------------------------------------
    #  Returns a printable form of the font:
    #---------------------------------------------------------------------------

    def __str__(self):
        """ Returns a printable form of the font.
        """
        return font_to_str(self)

#-------------------------------------------------------------------------------
#  'TraitPyQtFont' class'
#-------------------------------------------------------------------------------

class TraitPyQtFont ( TraitHandler ):
    """ Ensures that values assigned to a trait attribute are valid font
    descriptor strings; the value actually assigned is the corresponding
    TraitsFont.
    """
    #---------------------------------------------------------------------------
    #  Validates that the value is a valid font:
    #---------------------------------------------------------------------------

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid font descriptor string. If so,
        it returns the corresponding TraitsFont; otherwise, it raises a
        TraitError.
        """
        if value is None:
            return None

        try:
            return create_traitsfont( value )
        except:
            pass

        raise TraitError, ( object, name, 'a font descriptor string',
                            repr( value ) )

    def info ( self ):
        return ( "a string describing a font (e.g. '12 pt bold italic "
                 "swiss family Arial' or 'default 12')" )

#-------------------------------------------------------------------------------
#  Callable that returns an instance of the PyQtToolkitEditorFactory for font
#  editors.
#-------------------------------------------------------------------------------

### FIXME: We have declared the 'editor' to be a function instead of  the
# traitsui.qt4.font_editor.ToolkitEditorFactory class, since the
# latter is leading to too many circular imports. In the future, try to see if
# there is a better way to do this.
def get_font_editor(*args, **traits):
    from traitsui.qt4.font_editor import ToolkitEditorFactory
    return ToolkitEditorFactory(*args, **traits)

#-------------------------------------------------------------------------------
#  Define a PyQt specific font trait:
#-------------------------------------------------------------------------------

PyQtFont = Trait(TraitsFont(), TraitPyQtFont(), editor = get_font_editor)

########NEW FILE########
__FILENAME__ = helper
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines helper functions and classes used to define PyQt-based trait
    editors and trait editor factories.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import os.path

from pyface.qt import QtCore, QtGui

from traits.api \
    import Enum, CTrait, BaseTraitHandler, TraitError

from traitsui.ui_traits \
    import convert_image, SequenceTypes

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Layout orientation for a control and its associated editor
Orientation = Enum( 'horizontal', 'vertical' )

#-------------------------------------------------------------------------------
#  Convert an image file name to a cached QPixmap:
#-------------------------------------------------------------------------------

def pixmap_cache(name, path=None):
    """ Return the QPixmap corresponding to a filename. If the filename does not
        contain a path component, 'path' is used (or if 'path' is not specified,
        the local 'images' directory is used).
    """
    if name[:1] == '@':
        image = convert_image(name.replace(' ', '_').lower())
        if image is not None:
            return image.create_image()

    name_path, name = os.path.split(name)
    name = name.replace(' ', '_').lower()
    if name_path:
        filename = os.path.join(name_path, name)
    else:
        if path is None:
            filename = os.path.join(os.path.dirname(__file__), 'images', name)
        else:
            filename = os.path.join(path, name)
    filename = os.path.abspath(filename)

    pm = QtGui.QPixmap()
    if not QtGui.QPixmapCache.find(filename, pm):
        pm.load(filename)
        QtGui.QPixmapCache.insert(filename, pm)
    return pm

#-------------------------------------------------------------------------------
#  Positions a window on the screen with a specified width and height so that
#  the window completely fits on the screen if possible:
#-------------------------------------------------------------------------------

def position_window ( window, width = None, height = None, parent = None ):
    """ Positions a window on the screen with a specified width and height so
        that the window completely fits on the screen if possible.
    """
    # Get the available geometry of the screen containing the window.
    sgeom = QtGui.QApplication.desktop().availableGeometry(window)
    screen_dx = sgeom.width()
    screen_dy = sgeom.height()

    # Use the frame geometry even though it is very unlikely that the X11 frame
    # exists at this point.
    fgeom = window.frameGeometry()
    width = width or fgeom.width()
    height = height or fgeom.height()

    if parent is None:
        parent = window._parent

    if parent is None:
        # Center the popup on the screen.
        window.move((screen_dx - width) / 2, (screen_dy - height) / 2)
        return

    # Calculate the desired size of the popup control:
    if isinstance(parent, QtGui.QWidget):
        gpos = parent.mapToGlobal(QtCore.QPoint())
        x = gpos.x()
        y = gpos.y()
        cdx = parent.width()
        cdy = parent.height()

        # Get the frame height of the parent and assume that the window will
        # have a similar frame.  Note that we would really like the height of
        # just the top of the frame.
        pw = parent.window()
        fheight = pw.frameGeometry().height() - pw.height()
    else:
        # Special case of parent being a screen position and size tuple (used
        # to pop-up a dialog for a table cell):
        x, y, cdx, cdy = parent

        fheight = 0

    x -= (width - cdx) / 2
    y += cdy + fheight

    # Position the window (making sure it will fit on the screen).
    window.move(max(0, min(x, screen_dx - width)),
                max(0, min(y, screen_dy - height)))

#-------------------------------------------------------------------------------
#  Restores the user preference items for a specified UI:
#-------------------------------------------------------------------------------

def restore_window ( ui ):
    """ Restores the user preference items for a specified UI.
    """
    prefs = ui.restore_prefs()
    if prefs is not None:
        ui.control.setGeometry( *prefs )

#-------------------------------------------------------------------------------
#  Saves the user preference items for a specified UI:
#-------------------------------------------------------------------------------

def save_window ( ui ):
    """ Saves the user preference items for a specified UI.
    """
    geom = ui.control.geometry()
    ui.save_prefs( (geom.x(), geom.y(), geom.width(), geom.height()) )

#-------------------------------------------------------------------------------
#  Safely tries to pop up an FBI window if etsdevtools.debug is installed
#-------------------------------------------------------------------------------

def open_fbi():
    try:
        from etsdevtools.developer.helper.fbi import if_fbi
        if not if_fbi():
            import traceback
            traceback.print_exc()
    except ImportError:
        pass

#-------------------------------------------------------------------------------
#  'IconButton' class:
#-------------------------------------------------------------------------------

class IconButton(QtGui.QPushButton):
    """ The IconButton class is a push button that contains a small image or a
        standard icon provided by the current style.
    """

    def __init__(self, icon, slot):
        """ Initialise the button.  icon is either the name of an image file or
            one of the QtGui.QStyle.SP_* values.
        """
        QtGui.QPushButton.__init__(self)

        # Get the current style.
        sty = QtGui.QApplication.instance().style()

        # Get the minimum icon size to use.
        ico_sz = sty.pixelMetric(QtGui.QStyle.PM_ButtonIconSize)

        if isinstance(icon, basestring):
            pm = pixmap_cache(icon)

            # Increase the icon size to accomodate the image if needed.
            pm_width = pm.width()
            pm_height = pm.height()

            if ico_sz < pm_width:
                ico_sz = pm_width

            if ico_sz < pm_height:
                ico_sz = pm_height

            ico = QtGui.QIcon(pm)
        else:
            ico = sty.standardIcon(icon)

        # Configure the button.
        self.setIcon(ico)
        self.setMaximumSize(ico_sz, ico_sz)
        self.setFlat(True)
        self.setFocusPolicy(QtCore.Qt.NoFocus)

        self.clicked.connect(slot)

#-------------------------------------------------------------------------------
#  Dock-related stubs.
#-------------------------------------------------------------------------------

DockStyle = Enum('horizontal', 'vertical', 'tab', 'fixed')

########NEW FILE########
__FILENAME__ = history_editor
#-------------------------------------------------------------------------------
#
#  Copyright(c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   08/21/2009
#
#-------------------------------------------------------------------------------

""" Defines a text editor which displays a text field and maintains a history
    of previously entered values.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from editor import Editor

#-------------------------------------------------------------------------------
#  '_HistoryEditor' class:
#-------------------------------------------------------------------------------

class _HistoryEditor(Editor):
    """ Simple style text editor, which displays a text field and maintains a
        history of previously entered values, the maximum number of which is
        specified by the 'entries' trait of the HistoryEditor factory.
    """

    #---------------------------------------------------------------------------
    #  'Editor' interface:
    #---------------------------------------------------------------------------

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = control = QtGui.QComboBox()
        control.setEditable(True)
        control.setInsertPolicy(QtGui.QComboBox.InsertAtTop)

        if self.factory.entries > 0:
            signal = QtCore.SIGNAL('rowsInserted(const QModelIndex&, int, int)')
            QtCore.QObject.connect(control.model(), signal, self._truncate)

        if self.factory.auto_set:
            signal = QtCore.SIGNAL('editTextChanged(QString)')
        else:
            signal = QtCore.SIGNAL('activated(QString)')
        QtCore.QObject.connect(control, signal, self.update_object)

        self.set_tooltip()

    def update_object(self, text):
        """ Handles the user entering input data in the edit control.
        """
        if not self._no_update:
            self.value = unicode(text)

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self._no_update = True
        self.control.setEditText(self.str_value)
        self._no_update = False

    #-- UI preference save/restore interface -----------------------------------

    def restore_prefs(self, prefs):
        """ Restores any saved user preference information associated with the
            editor.
        """
        history = prefs.get('history')
        if history:
            self._no_update = True
            self.control.addItems(history[:self.factory.entries])

            # Adding items sets the edit text, so we reset it afterwards:
            self.control.setEditText(self.str_value)

            self._no_update = False

    def save_prefs(self):
        """ Returns any user preference information associated with the editor.
        """
        history = [ str(self.control.itemText(index))
                    for index in xrange(self.control.count()) ]

        # If the view closed successfully, update the history with the current
        # editor value, as long it is different from the current object value:
        if self.ui.result:
            current = str(self.control.currentText())
            if current != self.str_value:
                history.insert(0, current)

        return { 'history': history }

    #---------------------------------------------------------------------------
    #  '_HistoryEditor' private interface:
    #---------------------------------------------------------------------------

    def _truncate(self, parent, start, end):
        """ Handle items being added to the combo box. If there are too many,
            remove items at the end.
        """
        diff = self.control.count() - self.factory.entries
        if diff > 0:
            for i in xrange(diff):
                self.control.removeItem(self.factory.entries)

########NEW FILE########
__FILENAME__ = html_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

""" Defines the HTML "editor" for the QT4 user interface toolkit.
    HTML editors interpret and display HTML-formatted text, but do not
    modify it.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import webbrowser

from pyface.qt import QtCore, QtGui, QtWebKit

from traits.api import Str

from editor import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style editor for HTML.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the HTML editor scrollable? This values override the default.
    scrollable = True

    # External objects referenced in the HTML are relative to this URL
    base_url = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtWebKit.QWebView()
        self.control.setSizePolicy( QtGui.QSizePolicy.Expanding,
                                    QtGui.QSizePolicy.Expanding )

        if self.factory.open_externally:
            page = self.control.page()
            page.setLinkDelegationPolicy( QtWebKit.QWebPage.DelegateAllLinks )
            signal = QtCore.SIGNAL( 'linkClicked(QUrl)' )
            QtCore.QObject.connect( page, signal, self._link_clicked )

        self.base_url = self.factory.base_url
        self.sync_value( self.factory.base_url_name, 'base_url', 'from' )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        text = self.str_value
        if self.factory.format_text:
            text = self.factory.parse_text( text )
        if self.base_url:
            url = self.base_url
            if not url.endswith("/"):
                url += "/"
            self.control.setHtml( text , QtCore.QUrl.fromLocalFile ( url ) )
        else:
            self.control.setHtml( text )

    #-- Event Handlers ---------------------------------------------------------

    def _base_url_changed ( self ):
        self.update_editor()

    def _link_clicked ( self, url ):
        webbrowser.open_new( url.toString() )

#-EOF--------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = image_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   07/21/2009
#
#-------------------------------------------------------------------------------

""" Traits UI 'display only' image editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt.QtGui import QFrame, QPainter, QPalette

from pyface.image_resource \
    import ImageResource

from traitsui.ui_traits \
    import convert_bitmap

# FIXME: ImageEditor is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.image_editor file.
from traitsui.editors.image_editor \
    import ImageEditor

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'QImageView' class:
#-------------------------------------------------------------------------------

# backported and modified from Enaml ImageView

class QImageView(QFrame):
    """ A custom QFrame that will paint a QPixmap as an image. The
    api is similar to QLabel, but with a few more options to control
    how the image scales.

    """
    def __init__(self, parent=None):
        """ Initialize a QImageView.

        Parameters
        ----------
        parent : QWidget or None, optional
            The parent widget of this image viewer.

        """
        super(QImageView, self).__init__(parent)
        self._pixmap = None
        self._scaled_contents = False
        self._allow_upscaling = False
        self._preserve_aspect_ratio = False
        self._allow_clipping = False
        
        self.setBackgroundRole(QPalette.Window)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def paintEvent(self, event):
        """ A custom paint event handler which draws the image according
        to the current size constraints.

        """
        pixmap = self._pixmap
        if pixmap is None:
            return

        pm_size = pixmap.size()
        pm_width = pm_size.width()
        pm_height = pm_size.height()
        if pm_width == 0 or pm_height == 0:
            return

        width = self.size().width()
        height = self.size().height()

        if not self._scaled_contents:
            # If the image isn't scaled, it is centered if possible.
            # Otherwise, it's painted at the origin and clipped.
            paint_x = max(0, int(width / 2. - pm_width / 2.))
            paint_y = max(0, int(height / 2. - pm_height / 2.))
            paint_width = pm_width
            paint_height = pm_height
        else:
            # If the image *is* scaled, it's scaled size depends on the
            # size of the paint area as well as the other scaling flags.
            if self._preserve_aspect_ratio:
                pm_ratio = float(pm_width) / pm_height
                ratio = float(width) / height
                if ratio >= pm_ratio:
                    if self._allow_upscaling:
                        paint_height = height
                    else:
                        paint_height = min(pm_height, height)
                    paint_width = int(paint_height * pm_ratio)
                else:
                    if self._allow_upscaling:
                        paint_width = width
                    else:
                        paint_width = min(pm_width, width)
                    paint_height = int(paint_width / pm_ratio)
            else:
                if self._allow_upscaling:
                    paint_height = height
                    paint_width = width
                else:
                    paint_height = min(pm_height, height)
                    paint_width = min(pm_width, width)
            # In all cases of scaling, we know that the scaled image is
            # no larger than the paint area, and can thus be centered.
            paint_x = int(width / 2. - paint_width / 2.)
            paint_y = int(height / 2. - paint_height / 2.)

        # Finally, draw the pixmap into the calculated rect.
        painter = QPainter(self)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)
        painter.drawPixmap(paint_x, paint_y, paint_width, paint_height, pixmap)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def sizeHint(self):
        """ Returns a appropriate size hint for the image based on the
        underlying QPixmap.

        """
        pixmap = self._pixmap
        if pixmap is not None:
            return pixmap.size()
        return super(QImageView, self).sizeHint()

    def minimumSizeHint(self):
        """ Returns a appropriate minimum size hint for the image based on the
        underlying QPixmap.

        """
        pixmap = self._pixmap
        if pixmap is not None and not self._allow_clipping and not self._scaled_contents:
            return pixmap.size()
        return super(QImageView, self).sizeHint()

    def pixmap(self):
        """ Returns the underlying pixmap for the image view.

        """
        return self._pixmap

    def setPixmap(self, pixmap):
        """ Set the pixmap to use as the image in the widget.

        Parameters
        ----------
        pixamp : QPixmap
            The QPixmap to use as the image in the widget.

        """
        self._pixmap  = pixmap
        self.update()

    def scaledContents(self):
        """ Returns whether or not the contents scale with the widget
        size.

        """
        return self._scaled_contents

    def setScaledContents(self, scaled):
        """ Set whether the contents scale with the widget size.

        Parameters
        ----------
        scaled : bool
            If True, the image will be scaled to fit the widget size,
            subject to the other sizing constraints in place. If False,
            the image will not scale and will be clipped as required.

        """
        self._scaled_contents = scaled
        self.update()

    def allowUpscaling(self):
        """ Returns whether or not the image can be scaled greater than
        its natural size.

        """
        return self._allow_upscaling

    def setAllowUpscaling(self, allow):
        """ Set whether or not to allow the image to be scaled beyond
        its natural size.

        Parameters
        ----------
        allow : bool
            If True, then the image may be scaled larger than its
            natural if it is scaled to fit. If False, the image will
            never be scaled larger than its natural size. In either
            case, the image may be scaled smaller.

        """
        self._allow_upscaling = allow
        self.update()

    def preserveAspectRatio(self):
        """ Returns whether or not the aspect ratio of the image is
        maintained during a resize.

        """
        return self._preserve_aspect_ratio

    def setPreserveAspectRatio(self, preserve):
        """ Set whether or not to preserve the image aspect ratio.

        Parameters
        ----------
        preserve : bool
            If True then the aspect ratio of the image will be preserved
            if it is scaled to fit. Otherwise, the aspect ratio will be
            ignored.

        """
        self._preserve_aspect_ratio = preserve
        self.update()

    def allowClipping(self):
        """ Returns whether or not the image should be clipped in the view.

        """
        return self._preserve_aspect_ratio

    def setAllowClipping(self, allow):
        """ Set whether or not the image should be clipped in the view.

        Parameters
        ----------
        allow : bool
            If True then clipping will be allowed.  Otherwise the minimum
            size hint will be the image size.

        """
        self._allow_clipping = allow
        self.update()


#-------------------------------------------------------------------------------
#  '_ImageEditor' class:
#-------------------------------------------------------------------------------

class _ImageEditor ( Editor ):
    """ Traits UI 'display only' image editor.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        image = self.factory.image
        if image is None:
            image = self.value

        self.control = QImageView()
        self.control.setPixmap( convert_bitmap( image ) )
        self.control.setScaledContents(self.factory.scale)
        self.control.setAllowUpscaling(self.factory.allow_upscaling)
        self.control.setPreserveAspectRatio(self.factory.preserve_aspect_ratio)
        self.control.setAllowClipping(self.factory.allow_clipping)

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.factory.image is None:
            value = self.value
            if isinstance( value, ImageResource ):
                self.control.setPixmap( convert_bitmap( value ) )
        self.control.setScaledContents(self.factory.scale)
        self.control.setAllowUpscaling(self.factory.allow_upscaling)
        self.control.setPreserveAspectRatio(self.factory.preserve_aspect_ratio)
        self.control.setAllowClipping(self.factory.allow_clipping)

########NEW FILE########
__FILENAME__ = image_enum_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   08/11/2009
#
#------------------------------------------------------------------------------

""" Defines the various image enumeration editors for the PyQt user interface
    toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.image_enum_editor file.
from traitsui.editors.image_enum_editor  import ToolkitEditorFactory

from editor import Editor
from enum_editor import BaseEditor as BaseEnumEditor
from enum_editor import SimpleEditor as SimpleEnumEditor
from enum_editor import RadioEditor as CustomEnumEditor
from helper import pixmap_cache

#-------------------------------------------------------------------------------
#  'BaseImageEnumEditor' class:
#-------------------------------------------------------------------------------

class BaseEditor(object):
    """ The base class for the different styles of ImageEnumEditor.
    """

    def get_pixmap(self, name):
        """ Get a pixmap representing a possible object traits value.
        """
        if name is None:
            return None
        factory = self.factory
        name = ''.join((factory.prefix, name, factory.suffix))
        return pixmap_cache(name, factory._image_path)

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor(BaseEditor, BaseEnumEditor):
    """ Read-only style of image enumeration editor, which displays a single
        static image representing the object trait's value.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QLabel()
        self.control.setPixmap(self.get_pixmap(self.str_value))
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.setPixmap(self.get_pixmap(self.str_value))

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor(BaseEditor, SimpleEnumEditor):
    """ Simple style of image enumeration editor, which displays a combo box.
    """

    #---------------------------------------------------------------------------
    #  Returns the QComboBox used for the editor control:
    #---------------------------------------------------------------------------

    def create_combo_box(self):
        """ Returns the QComboBox used for the editor control.
        """
        control = ImageEnumComboBox(self)
        control.setSizePolicy(QtGui.QSizePolicy.Maximum,
                              QtGui.QSizePolicy.Maximum)
        return control

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self._no_enum_update == 0:
            self._no_enum_update += 1
            try:
                index = self.names.index(self.inverse_mapping[self.value])
            except:
                self.control.setCurrentIndex(-1)
            else:
                cols = self.factory.cols
                rows = (len(self.names) + cols - 1) / cols
                row, col = index / cols, index % cols
                self.control.setModelColumn(col)
                self.control.setCurrentIndex(row)
            self._no_enum_update -= 1

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor(self):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        self.control.model().reset()

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor(BaseEditor, CustomEnumEditor):
    """ Simple style of image enumeration editor, which displays a combo box.
    """

    # Is the button layout row-major or column-major? This value overrides the
    # default.
    row_major = True

    #---------------------------------------------------------------------------
    #  Returns the QAbstractButton used for the radio button:
    #---------------------------------------------------------------------------

    def create_button(self, name):
        """ Returns the QAbstractButton used for the radio button.
        """
        button = QtGui.QToolButton()
        button.setAutoExclusive(True)
        button.setCheckable(True)

        pixmap = self.get_pixmap(name)
        button.setIcon(QtGui.QIcon(pixmap))
        button.setIconSize(pixmap.size())

        return button

#-------------------------------------------------------------------------------
#  Custom Qt objects used in the SimpleEditor:
#-------------------------------------------------------------------------------

class ImageEnumComboBox(QtGui.QComboBox):
    """ A combo box which displays images instead of text.
    """

    def __init__(self, editor, parent=None):
        """ Reimplemented to store the editor and set a delegate for drawing the
            items in the popup menu. If there is more than one column, use a
            TableView instead of ListView for the popup.
        """
        QtGui.QComboBox.__init__(self, parent)
        self._editor = editor

        model = ImageEnumModel(editor, self)
        self.setModel(model)

        delegate = ImageEnumItemDelegate(editor, self)
        if editor.factory.cols > 1:
            view = ImageEnumTablePopupView(self)
            view.setItemDelegate(delegate)
            self.setView(view)
            # Unless we force it, the popup for a combo box will not be wider
            # than the box itself, so we set a high minimum width.
            width = 0
            for col in xrange(self._editor.factory.cols):
                width += view.sizeHintForColumn(col)
            view.setMinimumWidth(width)
        else:
            self.setItemDelegate(delegate)

    def paintEvent(self, event):
        """ Reimplemented to draw the ComboBox frame and paint the image
            centered in it.
        """
        painter = QtGui.QStylePainter(self)
        painter.setPen(self.palette().color(QtGui.QPalette.Text))

        option = QtGui.QStyleOptionComboBox()
        self.initStyleOption(option)
        painter.drawComplexControl(QtGui.QStyle.CC_ComboBox, option)

        editor = self._editor
        pixmap = editor.get_pixmap(editor.inverse_mapping[editor.value])
        arrow = self.style().subControlRect(QtGui.QStyle.CC_ComboBox, option,
                                            QtGui.QStyle.SC_ComboBoxArrow, None)
        option.rect.setWidth(option.rect.width() - arrow.width())
        target = QtGui.QStyle.alignedRect(QtCore.Qt.LeftToRight,
                                          QtCore.Qt.AlignCenter,
                                          pixmap.size(), option.rect)
        painter.drawPixmap(target, pixmap)

    def sizeHint(self):
        """ Reimplemented to set a size hint based on the size of the larget
            image.
        """
        size = QtCore.QSize()
        for name in self._editor.names:
            size = size.expandedTo(self._editor.get_pixmap(name).size())

        option = QtGui.QStyleOptionComboBox()
        self.initStyleOption(option)
        size = self.style().sizeFromContents(QtGui.QStyle.CT_ComboBox, option,
                                             size, self)
        return size


class ImageEnumTablePopupView(QtGui.QTableView):

    def __init__(self, parent):
        """ Configure the appearence of the table view.
        """
        QtGui.QTableView.__init__(self, parent)
        hheader = self.horizontalHeader()
        hheader.setResizeMode(QtGui.QHeaderView.ResizeToContents)
        hheader.hide()
        vheader = self.verticalHeader()
        vheader.setResizeMode(QtGui.QHeaderView.ResizeToContents)
        vheader.hide()
        self.setShowGrid(False)


class ImageEnumItemDelegate(QtGui.QStyledItemDelegate):
    """ An item delegate which draws only images.
    """

    def __init__(self, editor, parent):
        """ Reimplemented to store the editor.
        """
        QtGui.QStyledItemDelegate.__init__(self, parent)
        self._editor = editor

    def displayText(self, value, locale):
        """ Reimplemented to display nothing.
        """
        return ''

    def paint(self, painter, option, mi):
        """ Reimplemented to draw images.
        """
        # Delegate to our superclass to draw the background
        QtGui.QStyledItemDelegate.paint(self, painter, option, mi)

        # Now draw the pixmap
        name = mi.data(QtCore.Qt.DisplayRole)
        pixmap = self._get_pixmap(name)
        if pixmap is not None:
            target = QtGui.QStyle.alignedRect(QtCore.Qt.LeftToRight,
                                              QtCore.Qt.AlignCenter,
                                              pixmap.size(), option.rect)
            painter.drawPixmap(target, pixmap)

    def sizeHint(self, option, mi):
        """ Reimplemented to define a size hint based on the size of the pixmap.
        """
        name = mi.data(QtCore.Qt.DisplayRole)
        pixmap = self._get_pixmap(name)
        if pixmap is None:
            return QtCore.QSize()
        return pixmap.size()

    def _get_pixmap(self, name):
        return self._editor.get_pixmap(name)


class ImageEnumModel(QtCore.QAbstractTableModel):
    """ A table model for use with the 'simple' style ImageEnumEditor.
    """

    def __init__(self, editor, parent):
        """ Reimplemented to store the editor.
        """
        super(ImageEnumModel, self).__init__(parent)
        self._editor = editor

    def rowCount(self, mi):
        """ Reimplemented to return the number of rows.
        """
        cols = self._editor.factory.cols
        result = (len(self._editor.names) + cols - 1) / cols
        return result

    def columnCount(self, mi):
        """ Reimplemented to return the number of columns.
        """
        return self._editor.factory.cols

    def data(self, mi, role):
        """ Reimplemented to return the data.
        """
        if role == QtCore.Qt.DisplayRole:
            index = mi.row() * self._editor.factory.cols + mi.column()
            if index < len(self._editor.names):
                return self._editor.names[index]

        return None

########NEW FILE########
__FILENAME__ = instance_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various instance editors and the instance editor factory for
    the PyQt user interface toolkit..
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traits.api \
    import HasTraits, Property

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.instance_editor file.
from traitsui.editors.instance_editor \
    import ToolkitEditorFactory

from traitsui.ui_traits \
    import AView

from traitsui.helper \
    import user_name_for

from traitsui.handler \
    import Handler

from traitsui.instance_choice \
    import InstanceChoiceItem

from editor \
    import Editor

from constants \
    import DropColor

from helper \
    import position_window

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

OrientationMap = {
    'default':    None,
    'horizontal': QtGui.QBoxLayout.LeftToRight,
    'vertical':   QtGui.QBoxLayout.TopToBottom
}

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( Editor ):
    """ Custom style of editor for instances. If selection among instances is
    allowed, the editor displays a combo box listing instances that can be
    selected. If the current instance is editable, the editor displays a panel
    containing trait editors for all the instance's traits.
    """

    # Background color when an item can be dropped on the editor:
    ok_color = DropColor

    # The orientation of the instance editor relative to the instance selector:
    orientation = QtGui.QBoxLayout.TopToBottom

    # Class constant:
    extra = 0

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # List of InstanceChoiceItem objects used by the editor
    items = Property

    # The view to use for displaying the instance
    view = AView

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if factory.name != '':
            self._object, self._name, self._value = \
                self.parse_extended_name( factory.name )

        # Create a panel to hold the object trait's view:
        if factory.editable:
            self.control = self._panel = parent = QtGui.QWidget()

        # Build the instance selector if needed:
        selectable = factory.selectable
        droppable  = factory.droppable
        items      = self.items
        for item in items:
            droppable  |= item.is_droppable()
            selectable |= item.is_selectable()

        if selectable:
            self._object_cache = {}
            item = self.item_for( self.value )
            if item is not None:
                self._object_cache[ id( item ) ] = self.value

            self._choice = QtGui.QComboBox()
            QtCore.QObject.connect(self._choice,
                    QtCore.SIGNAL('activated(QString)'), self.update_object)

            self.set_tooltip( self._choice )

            if factory.name != '':
                self._object.on_trait_change( self.rebuild_items,
                                              self._name, dispatch = 'ui' )
                self._object.on_trait_change( self.rebuild_items,
                                 self._name + '_items', dispatch = 'ui' )

            factory.on_trait_change( self.rebuild_items, 'values',
                                     dispatch = 'ui' )
            factory.on_trait_change( self.rebuild_items, 'values_items',
                                     dispatch = 'ui' )

            self.rebuild_items()

        elif droppable:
            self._choice = QtGui.QLineEdit()
            self._choice.setReadOnly(True)
            self.set_tooltip( self._choice )

        if droppable:
            self._choice.SetDropTarget( PythonDropTarget( self ) )

        orientation = OrientationMap[ factory.orientation ]
        if orientation is None:
            orientation = self.orientation

        if (selectable or droppable) and factory.editable:
            layout = QtGui.QBoxLayout(orientation, parent)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.addWidget(self._choice)

            if orientation == QtGui.QBoxLayout.TopToBottom:
                hline = QtGui.QFrame()
                hline.setFrameShape(QtGui.QFrame.HLine)
                hline.setFrameShadow(QtGui.QFrame.Sunken)

                layout.addWidget(hline)

            self.create_editor(parent, layout)
        elif self.control is None:
            if self._choice is None:
                self._choice = QtGui.QComboBox()
                QtCore.QObject.connect(self._choice,
                        QtCore.SIGNAL('activated(QString)'),
                        self.update_object)

            self.control = self._choice
        else:
            layout = QtGui.QBoxLayout(orientation, parent)
            layout.setContentsMargins(0, 0, 0, 0)
            self.create_editor(parent, layout)

        # Synchronize the 'view' to use:
        # fixme: A normal assignment can cause a crash (for unknown reasons) in
        # some cases, so we make sure that no notifications are generated:
        self.trait_setq( view = factory.view )
        self.sync_value( factory.view_name, 'view', 'from' )

    #---------------------------------------------------------------------------
    #  Creates the editor control:
    #---------------------------------------------------------------------------

    def create_editor(self, parent, layout):
        """ Creates the editor control.
        """
        self._panel = QtGui.QWidget()
        layout.addWidget(self._panel)

    #---------------------------------------------------------------------------
    #  Gets the current list of InstanceChoiceItem items:
    #---------------------------------------------------------------------------

    def _get_items ( self ):
        """ Gets the current list of InstanceChoiceItem items.
        """
        if self._items is not None:
            return self._items

        factory = self.factory
        if self._value is not None:
            values = self._value() + factory.values
        else:
            values = factory.values

        items = []
        adapter = factory.adapter
        for value in values:
            if not isinstance( value, InstanceChoiceItem ):
                value = adapter( object = value )
            items.append( value )

        self._items = items

        return items

    #---------------------------------------------------------------------------
    #  Rebuilds the object selector list:
    #---------------------------------------------------------------------------

    def rebuild_items ( self ):
        """ Rebuilds the object selector list.
        """
        # Clear the current cached values:
        self._items = None

        # Rebuild the contents of the selector list:
        name   = -1
        value  = self.value
        choice = self._choice
        choice.clear()
        for i, item in enumerate(self.items):
            if item.is_selectable():
                choice.addItem(item.get_name())
                if item.is_compatible( value ):
                    name = i

        # Reselect the current item if possible:
        if name >= 0:
            choice.setCurrentIndex(name)
        else:
            # Otherwise, current value is no longer valid, try to discard it:
            try:
                self.value = None
            except:
                pass

    #---------------------------------------------------------------------------
    #  Returns the InstanceChoiceItem for a specified object:
    #---------------------------------------------------------------------------

    def item_for ( self, object ):
        """ Returns the InstanceChoiceItem for a specified object.
        """
        for item in self.items:
            if item.is_compatible( object ):
                return item

        return None

    #---------------------------------------------------------------------------
    #  Returns the view to use for a specified object:
    #---------------------------------------------------------------------------

    def view_for ( self, object, item ):
        """ Returns the view to use for a specified object.
        """
        view = ''
        if item is not None:
            view = item.get_view()

        if view == '':
            view = self.view

        return self.ui.handler.trait_view_for( self.ui.info, view, object,
                                               self.object_name, self.name )

    #---------------------------------------------------------------------------
    #  Handles the user selecting a new value from the combo box:
    #---------------------------------------------------------------------------

    def update_object(self, text):
        """ Handles the user selecting a new value from the combo box.
        """
        name = unicode(text)
        for item in self.items:
            if name == item.get_name():
                id_item = id( item )
                object  = self._object_cache.get( id_item )
                if object is None:
                    object = item.get_object()
                    if (not self.factory.editable) and item.is_factory:
                        view = self.view_for( object, self.item_for( object ) )
                        view.ui( object, self.control, 'modal' )

                    if self.factory.cachable:
                        self._object_cache[ id_item ] = object

                self.value = object
                self.resynch_editor()
                break

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Synchronize the editor contents:
        self.resynch_editor()

        # Update the selector (if any):
        choice = self._choice
        item   = self.item_for( self.value )
        if (choice is not None) and (item is not None):
            name = item.get_name( self.value )
            if self._object_cache is not None:
                idx = choice.findText(name)
                if idx < 0:
                    idx = choice.count()
                    choice.addItem(name)

                choice.setCurrentIndex(idx)
            else:
                choice.setText(name)

    #---------------------------------------------------------------------------
    #  Resynchronizes the contents of the editor when the object trait changes
    #  external to the editor:
    #---------------------------------------------------------------------------

    def resynch_editor ( self ):
        """ Resynchronizes the contents of the editor when the object trait
        changes externally to the editor.
        """
        panel = self._panel
        if panel is not None:
            # Dispose of the previous contents of the panel:
            layout = panel.layout()
            if layout is None:
                layout = QtGui.QVBoxLayout(panel)
                layout.setContentsMargins(0, 0, 0, 0)
            elif self._ui is not None:
                self._ui.dispose()
                self._ui = None
            else:
                child = layout.takeAt(0)
                while child is not None:
                    child = layout.takeAt(0)

                del child

            # Create the new content for the panel:
            stretch = 0
            value   = self.value
            if not isinstance( value, HasTraits ):
                str_value = ''
                if value is not None:
                    str_value = self.str_value
                control = QtGui.QLabel(str_value)
            else:
                view    = self.view_for( value, self.item_for( value ) )
                context = value.trait_context()
                handler = None
                if isinstance( value, Handler ):
                    handler = value
                context.setdefault( 'context', self.object )
                context.setdefault( 'context_handler', self.ui.handler )
                self._ui = ui = view.ui( context, panel, 'subpanel',
                                         value.trait_view_elements(), handler,
                                         self.factory.id )
                control         = ui.control
                self.scrollable = ui._scrollable
                ui.parent       = self.ui

                if view.resizable or view.scrollable or ui._scrollable:
                    stretch = 1

            # FIXME: Handle stretch.
            layout.addWidget(control)

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Make sure we aren't hanging on to any object refs:
        self._object_cache = None

        if self._ui is not None:
            self._ui.dispose()

        if self._choice is not None:
            if self._object is not None:
                self._object.on_trait_change( self.rebuild_items,
                                              self._name, remove = True )
                self._object.on_trait_change( self.rebuild_items,
                                 self._name + '_items', remove = True )

            self.factory.on_trait_change( self.rebuild_items, 'values',
                                          remove = True )
            self.factory.on_trait_change( self.rebuild_items,
                                          'values_items', remove = True )

        super( CustomEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return (self._choice or self.control)

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        ui = self._ui
        if (ui is not None) and (prefs.get( 'id' ) == ui.id):
            ui.set_prefs( prefs.get( 'prefs' ) )

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        ui = self._ui
        if (ui is not None) and (ui.id != ''):
            return { 'id':    ui.id,
                     'prefs': ui.get_prefs() }

        return None

    #-- Traits event handlers --------------------------------------------------

    def _view_changed ( self, view ):
        self.resynch_editor()

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( CustomEditor ):
    """ Simple style of editor for instances, which displays a button. Clicking
    the button displays a dialog box in which the instance can be edited.
    """

    # Class constants:
    orientation = QtGui.QBoxLayout.LeftToRight
    extra       = 2

    #---------------------------------------------------------------------------
    #  Creates the editor control:
    #---------------------------------------------------------------------------

    def create_editor(self, parent, layout):
        """ Creates the editor control (a button).
        """
        self._button = QtGui.QPushButton()
        layout.addWidget(self._button)
        QtCore.QObject.connect(self._button, QtCore.SIGNAL('clicked()'),
                self.edit_instance)

    #---------------------------------------------------------------------------
    #  Edit the contents of the object trait when the user clicks the button:
    #---------------------------------------------------------------------------

    def edit_instance(self):
        """ Edit the contents of the object trait when the user clicks the
            button.
        """
        # Create the user interface:
        factory = self.factory
        view    = self.ui.handler.trait_view_for( self.ui.info, factory.view,
                                                  self.value, self.object_name,
                                                  self.name )
        ui = self.value.edit_traits( view, kind=factory.kind, id=factory.id )

        # Make sure the editor is properly disposed
        QtCore.QObject.connect( self._button, QtCore.SIGNAL( 'destroyed()' ),
                                lambda: ui.dispose() )

        # Check to see if the view was 'modal', in which case it will already
        # have been closed (i.e. is None) by the time we get control back:
        if ui.control is not None:
            # Position the window on the display:
            position_window( ui.control )

            # Chain our undo history to the new user interface if it does not
            # have its own:
            if ui.history is None:
                ui.history = self.ui.history

    #---------------------------------------------------------------------------
    #  Resynchronizes the contents of the editor when the object trait changes
    #  external to the editor:
    #---------------------------------------------------------------------------

    def resynch_editor ( self ):
        """ Resynchronizes the contents of the editor when the object trait
            changes externally to the editor.
        """
        button = self._button
        if button is not None:
            label = self.factory.label
            if label == '':
                label = user_name_for( self.name )

            button.setText(label)
            button.setEnabled(isinstance(self.value, HasTraits))

########NEW FILE########
__FILENAME__ = key_binding_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the key binding editor for use with the KeyBinding class. This is a
specialized editor used to associate a particular key with a control (i.e., the
key binding editor).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traits.api \
    import Bool, Event

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.key_binding_editor file.
from traitsui.editors.key_binding_editor \
    import KeyBindingEditor as ToolkitEditorFactory

from editor \
    import Editor

from key_event_to_name \
    import key_event_to_name

#-------------------------------------------------------------------------------
#  'KeyBindingEditor' class:
#-------------------------------------------------------------------------------

class KeyBindingEditor ( Editor ):
    """ An editor for modifying bindings of keys to controls.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Does the editor's control have focus currently?
    has_focus = Bool(False)

    # Keyboard event
    key = Event

    # Clear field event
    clear = Event

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init (self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = KeyBindingCtrl(self)

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        try:
            self.value = value = key_event_to_name( event )
            self._binding.text = value
        except:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.setText(self.value)

    #---------------------------------------------------------------------------
    #  Updates the current focus setting of the control:
    #---------------------------------------------------------------------------

    def update_focus ( self, has_focus ):
        """ Updates the current focus setting of the control.
        """
        if has_focus:
            self._binding.border_size     = 1
            self.object.owner.focus_owner = self._binding

    #---------------------------------------------------------------------------
    #  Handles a keyboard event:
    #---------------------------------------------------------------------------

    def _key_changed ( self, event ):
        """ Handles a keyboard event.
        """
        binding     = self.object
        key_name    = key_event_to_name( event )
        cur_binding = binding.owner.key_binding_for( binding, key_name )
        if cur_binding is not None:
            if QtGui.QMessageBox.question(self.control,
                    "Duplicate Key Definition",
                    "'%s' has already been assigned to '%s'.\n"
                    "Do you wish to continue?" % (key_name,
                        cur_binding.description),
                     QtGui.QMessageBox.Yes | QtGui.QMessageBox.No,
                     QtGui.QMessageBox.No) != QtGui.QMessageBox.Yes:
                return

        self.value = key_name

    #---------------------------------------------------------------------------
    #  Handles a clear field event:
    #---------------------------------------------------------------------------

    def _clear_changed ( self ):
        """ Handles a clear field event.
        """
        self.value = ''

#-------------------------------------------------------------------------------
#  'KeyBindingCtrl' class:
#-------------------------------------------------------------------------------

class KeyBindingCtrl(QtGui.QLabel):
    """ PyQt control for editing key bindings.
    """
    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__(self, editor, parent=None):
        super(KeyBindingCtrl, self).__init__(parent)

        self.setFocusPolicy(QtCore.Qt.StrongFocus)
        self.setIndent(4)
        self.setMinimumWidth(160)

        pal = QtGui.QPalette(self.palette())
        pal.setColor(QtGui.QPalette.Window, QtCore.Qt.white)
        self.setPalette(pal)
        self.setAutoFillBackground(True)

        # Save the reference to the controlling editor object:
        self.editor = editor

        # Indicate we don't have the focus right now:
        editor.has_focus = False

    #---------------------------------------------------------------------------
    #  Handle keyboard keys being pressed:
    #---------------------------------------------------------------------------

    def keyPressEvent(self, event):
        """ Handle keyboard keys being pressed.
        """
        # Ignore presses of the control and shift keys.
        if event.key() not in (QtCore.Qt.Key_Control, QtCore.Qt.Key_Shift):
            self.editor.key = event

    #---------------------------------------------------------------------------
    #  Do a GUI toolkit specific screen update:
    #---------------------------------------------------------------------------

    def paintEvent(self, event):
        """ Updates the screen.
        """
        QtGui.QLabel.paintEvent(self, event)

        w = self.width()
        h = self.height()
        p = QtGui.QPainter(self)

        if self.editor.has_focus:
            p.setRenderHint(QtGui.QPainter.Antialiasing, True)
            pen = QtGui.QPen(QtGui.QColor('tomato'))
            pen.setWidth(2)
            p.setPen(pen)
            p.drawRect(1, 1, w - 2, h - 2)
        else:
            p.setPen(self.palette().color(QtGui.QPalette.Mid))
            p.drawRect(0, 0, w - 1, h - 1)

        p.end()

    #---------------------------------------------------------------------------
    #  Handles getting/losing the focus:
    #---------------------------------------------------------------------------

    def focusInEvent(self, event):
        """ Handles getting the focus.
        """
        self.editor.has_focus = True
        self.update()

    def focusOutEvent(self, event):
        """ Handles losing the focus.
        """
        self.editor.has_focus = False
        self.update()

    #---------------------------------------------------------------------------
    #  Handles the user double clicking the control to clear its contents:
    #---------------------------------------------------------------------------

    def mouseDoubleClickEvent(self, event):
        """ Handles the user double clicking the control to clear its contents.
        """
        self.editor.clear = True

########NEW FILE########
__FILENAME__ = key_event_to_name
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Converts a QKeyEvent to a standardized "name".
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping from PyQt keypad key names to Pyface key names.
keypad_map = {
    QtCore.Qt.Key_Enter:     'Enter',
    QtCore.Qt.Key_0:         'Numpad 0',
    QtCore.Qt.Key_1:         'Numpad 1',
    QtCore.Qt.Key_2:         'Numpad 2',
    QtCore.Qt.Key_3:         'Numpad 3',
    QtCore.Qt.Key_4:         'Numpad 4',
    QtCore.Qt.Key_5:         'Numpad 5',
    QtCore.Qt.Key_6:         'Numpad 6',
    QtCore.Qt.Key_7:         'Numpad 7',
    QtCore.Qt.Key_8:         'Numpad 8',
    QtCore.Qt.Key_9:         'Numpad 9',
    QtCore.Qt.Key_Asterisk:  'Multiply',
    QtCore.Qt.Key_Plus:      'Add',
    QtCore.Qt.Key_Comma:     'Separator',
    QtCore.Qt.Key_Minus:     'Subtract',
    QtCore.Qt.Key_Period:    'Decimal',
    QtCore.Qt.Key_Slash:     'Divide'
}

# Mapping from PyQt non-keypad key names to Pyface key names.
key_map = {
    QtCore.Qt.Key_0:         '0',
    QtCore.Qt.Key_1:         '1',
    QtCore.Qt.Key_2:         '2',
    QtCore.Qt.Key_3:         '3',
    QtCore.Qt.Key_4:         '4',
    QtCore.Qt.Key_5:         '5',
    QtCore.Qt.Key_6:         '6',
    QtCore.Qt.Key_7:         '7',
    QtCore.Qt.Key_8:         '8',
    QtCore.Qt.Key_9:         '9',
    QtCore.Qt.Key_A:         'A',
    QtCore.Qt.Key_B:         'B',
    QtCore.Qt.Key_C:         'C',
    QtCore.Qt.Key_D:         'D',
    QtCore.Qt.Key_E:         'E',
    QtCore.Qt.Key_F:         'F',
    QtCore.Qt.Key_G:         'G',
    QtCore.Qt.Key_H:         'H',
    QtCore.Qt.Key_I:         'I',
    QtCore.Qt.Key_J:         'J',
    QtCore.Qt.Key_K:         'K',
    QtCore.Qt.Key_L:         'L',
    QtCore.Qt.Key_M:         'M',
    QtCore.Qt.Key_N:         'N',
    QtCore.Qt.Key_O:         'O',
    QtCore.Qt.Key_P:         'P',
    QtCore.Qt.Key_Q:         'Q',
    QtCore.Qt.Key_R:         'R',
    QtCore.Qt.Key_S:         'S',
    QtCore.Qt.Key_T:         'T',
    QtCore.Qt.Key_U:         'U',
    QtCore.Qt.Key_V:         'V',
    QtCore.Qt.Key_W:         'W',
    QtCore.Qt.Key_X:         'X',
    QtCore.Qt.Key_Y:         'Y',
    QtCore.Qt.Key_Z:         'Z',
    QtCore.Qt.Key_Space:     'Space',
    QtCore.Qt.Key_Backspace: 'Backspace',
    QtCore.Qt.Key_Tab:       'Tab',
    QtCore.Qt.Key_Enter:     'Enter',
    QtCore.Qt.Key_Return:    'Return',
    QtCore.Qt.Key_Escape:    'Esc',
    QtCore.Qt.Key_Delete:    'Delete',
    QtCore.Qt.Key_Cancel:    'Cancel',
    QtCore.Qt.Key_Clear:     'Clear',
    QtCore.Qt.Key_Shift:     'Shift',
    QtCore.Qt.Key_Menu:      'Menu',
    QtCore.Qt.Key_Pause:     'Pause',
    QtCore.Qt.Key_PageUp:    'Page Up',
    QtCore.Qt.Key_PageDown:  'Page Down',
    QtCore.Qt.Key_End:       'End',
    QtCore.Qt.Key_Home:      'Home',
    QtCore.Qt.Key_Left:      'Left',
    QtCore.Qt.Key_Up:        'Up',
    QtCore.Qt.Key_Right:     'Right',
    QtCore.Qt.Key_Down:      'Down',
    QtCore.Qt.Key_Select:    'Select',
    QtCore.Qt.Key_Print:     'Print',
    QtCore.Qt.Key_Execute:   'Execute',
    QtCore.Qt.Key_Insert:    'Insert',
    QtCore.Qt.Key_Help:      'Help',
    QtCore.Qt.Key_F1:        'F1',
    QtCore.Qt.Key_F2:        'F2',
    QtCore.Qt.Key_F3:        'F3',
    QtCore.Qt.Key_F4:        'F4',
    QtCore.Qt.Key_F5:        'F5',
    QtCore.Qt.Key_F6:        'F6',
    QtCore.Qt.Key_F7:        'F7',
    QtCore.Qt.Key_F8:        'F8',
    QtCore.Qt.Key_F9:        'F9',
    QtCore.Qt.Key_F10:       'F10',
    QtCore.Qt.Key_F11:       'F11',
    QtCore.Qt.Key_F12:       'F12',
    QtCore.Qt.Key_F13:       'F13',
    QtCore.Qt.Key_F14:       'F14',
    QtCore.Qt.Key_F15:       'F15',
    QtCore.Qt.Key_F16:       'F16',
    QtCore.Qt.Key_F17:       'F17',
    QtCore.Qt.Key_F18:       'F18',
    QtCore.Qt.Key_F19:       'F19',
    QtCore.Qt.Key_F20:       'F20',
    QtCore.Qt.Key_F21:       'F21',
    QtCore.Qt.Key_F22:       'F22',
    QtCore.Qt.Key_F23:       'F23',
    QtCore.Qt.Key_F24:       'F24',
    QtCore.Qt.Key_NumLock:   'Num Lock',
    QtCore.Qt.Key_ScrollLock:'Scroll Lock'
}

#-------------------------------------------------------------------------------
#  Converts a keystroke event into a corresponding key name:
#-------------------------------------------------------------------------------

def key_event_to_name(event):
    """ Converts a keystroke event into a corresponding key name.
    """
    key_code = event.key()
    modifiers = event.modifiers()
    if modifiers & QtCore.Qt.KeypadModifier:
        key = keypad_map.get(key_code)
    else:
        key = None
    if key is None:
        key = key_map.get(key_code, 'Unknown-Key')

    name = ''
    if modifiers & QtCore.Qt.ControlModifier:
        name += 'Ctrl'

    if modifiers & QtCore.Qt.AltModifier:
        name += '-Alt' if name else 'Alt'

    if modifiers & QtCore.Qt.MetaModifier:
        name += '-Meta' if name else 'Meta'

    if modifiers & QtCore.Qt.ShiftModifier and ((name != '') or (len(key) > 1)):
        name += '-Shift' if name else 'Shift'

    if key:
        if name:
            name += '-'
        name += key
    return name

########NEW FILE########
__FILENAME__ = list_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described
# in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various list editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from pyface.api import ImageResource

from traits.api import Str, Any, Bool, Dict, Instance
from traits.trait_base import user_name_for, enumerate, xgetattr

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.list_editor file.
from traitsui.editors.list_editor import ListItemProxy, \
    ToolkitEditorFactory

from editor import Editor
from helper import IconButton
from menu import MakeMenu

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for lists, which displays a scrolling list box
    with only one item visible at a time. A icon next to the list box displays
    a menu of operations on the list.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The kind of editor to create for each list item
    kind = Str

    # Is the list of items being edited mutable?
    mutable = Bool( True )

    # Signal mapper allowing to identify which icon button requested a context
    # menu
    mapper = Instance(QtCore.QSignalMapper)

    #---------------------------------------------------------------------------
    #  Class constants:
    #---------------------------------------------------------------------------

    # Whether the list is displayed in a single row
    single_row = True

    #---------------------------------------------------------------------------
    #  Normal list item menu:
    #---------------------------------------------------------------------------

    # Menu for modifying the list
    list_menu = """
       Add &Before     [_menu_before]: self.add_before()
       Add &After      [_menu_after]:  self.add_after()
       ---
       &Delete         [_menu_delete]: self.delete_item()
       ---
       Move &Up        [_menu_up]:     self.move_up()
       Move &Down      [_menu_down]:   self.move_down()
       Move to &Top    [_menu_top]:    self.move_top()
       Move to &Bottom [_menu_bottom]: self.move_bottom()
    """

    #---------------------------------------------------------------------------
    #  Empty list item menu:
    #---------------------------------------------------------------------------

    empty_list_menu = """
       Add: self.add_empty()
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Initialize the trait handler to use:
        trait_handler = self.factory.trait_handler
        if trait_handler is None:
            trait_handler = self.object.base_trait( self.name ).handler
        self._trait_handler = trait_handler

        # Create a scrolled window to hold all of the list item controls:
        self.control = QtGui.QScrollArea()
        self.control.setFrameShape(QtGui.QFrame.NoFrame)
        self.control.setWidgetResizable(True)

        #Create a mapper to identify which icon button requested a contextmenu
        self.mapper = QtCore.QSignalMapper(self.control)

        # Create a widget with a grid layout as the container.
        self._list_pane = QtGui.QWidget()
        self._list_pane.setSizePolicy(QtGui.QSizePolicy.Expanding,
                                      QtGui.QSizePolicy.Expanding)
        layout = QtGui.QGridLayout(self._list_pane)
        layout.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        layout.setContentsMargins(0, 0, 0, 0)

        # Remember the editor to use for each individual list item:
        editor = self.factory.editor
        if editor is None:
            editor = trait_handler.item_trait.get_editor()
        self._editor = getattr( editor, self.kind )

        # Set up the additional 'list items changed' event handler needed for
        # a list based trait. Note that we want to fire the update_editor_item
        # only when the items in the list change and not when intermediate
        # traits change. Therefore, replace "." by ":" in the extended_name
        # when setting up the listener.
        extended_name = self.extended_name.replace('.', ':')
        self.context_object.on_trait_change( self.update_editor_item,
                               extended_name + '_items?', dispatch = 'ui' )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self._dispose_items()

        extended_name = self.extended_name.replace('.', ':')
        self.context_object.on_trait_change( self.update_editor_item,
                                 extended_name + '_items?', remove = True )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.mapper = QtCore.QSignalMapper(self.control)
        # Disconnect the editor from any control about to be destroyed:
        self._dispose_items()

        list_pane = self._list_pane
        layout = list_pane.layout()

        # Create all of the list item trait editors:
        trait_handler = self._trait_handler
        resizable     = ((trait_handler.minlen != trait_handler.maxlen) and
                         self.mutable)
        item_trait    = trait_handler.item_trait

        is_fake = (resizable and (len( self.value ) == 0))
        if is_fake:
            self.empty_list()
        else:
            # Asking the mapper to send the sender to the callback method
            self.mapper.mapped[QtCore.QObject].connect(self.popup_menu)

        editor = self._editor
        for index, value in enumerate(self.value):
            row, column = divmod(index, self.factory.columns)

            # Account for the fact that we have <columns> number of
            # pairs
            column = column * 2

            if resizable:
                # Connecting the new button to the mapper
                control = IconButton('list_editor.png', self.mapper.map)
                # Setting the mapping and asking it to send the index of the
                # sender to the callback method
                self.mapper.setMapping(control, control)

                layout.addWidget(control, row, column)

            proxy = ListItemProxy( self.object, self.name, index, item_trait,
                                   value )
            if resizable:
                control.proxy = proxy
            peditor = editor( self.ui, proxy, 'value', self.description,
                              list_pane ).set( object_name = '' )
            peditor.prepare( list_pane )
            pcontrol = peditor.control
            pcontrol.proxy = proxy

            if isinstance(pcontrol, QtGui.QWidget):
                layout.addWidget(pcontrol, row, column+1)
            else:
                layout.addLayout(pcontrol, row, column+1)

        # QScrollArea can have problems if the widget being scrolled is set too
        # early (ie. before it contains something).
        if self.control.widget() is None:
            self.control.setWidget(list_pane)

    #---------------------------------------------------------------------------
    #  Updates the editor when an item in the object trait changes external to
    #  the editor:
    #---------------------------------------------------------------------------

    def update_editor_item ( self, event ):
        """ Updates the editor when an item in the object trait changes
        externally to the editor.
        """
        # If this is not a simple, single item update, rebuild entire editor:
        if (len( event.removed ) != 1) or (len( event.added ) != 1):
            self.update_editor()
            return

        # Otherwise, find the proxy for this index and update it with the
        # changed value:
        for control in self.control.widget().children():
            if isinstance(control, QtGui.QLayout):
                continue

            proxy = control.proxy
            if proxy.index == event.index:
                proxy.value = event.added[0]
                break

    #---------------------------------------------------------------------------
    #  Creates an empty list entry (so the user can add a new item):
    #---------------------------------------------------------------------------

    def empty_list ( self ):
        """ Creates an empty list entry (so the user can add a new item).
        """
        # Connecting the new button to the mapper
        control = IconButton('list_editor.png', self.mapper.map)
        # Setting the mapping and asking it to send the sender to the
        # callback method
        self.mapper.setMapping(control, control)
        self.mapper.mapped[QtCore.QObject].connect(self.popup_empty_menu)
        control.is_empty = True
        self._cur_control = control

        proxy    = ListItemProxy( self.object, self.name, -1, None, None )
        pcontrol = QtGui.QLabel('   (Empty List)')
        pcontrol.proxy = control.proxy = proxy

        layout = self._list_pane.layout()
        layout.addWidget(control, 0, 0)
        layout.addWidget(pcontrol, 0, 1)

    #---------------------------------------------------------------------------
    #  Returns the associated object list and current item index:
    #---------------------------------------------------------------------------

    def get_info ( self ):
        """ Returns the associated object list and current item index.
        """
        proxy = self._cur_control.proxy
        return ( proxy.list, proxy.index )

    #---------------------------------------------------------------------------
    #  Displays the empty list editor popup menu:
    #---------------------------------------------------------------------------

    def popup_empty_menu ( self , sender):
        """ Displays the empty list editor popup menu.
        """
        self._cur_control = control = sender
        menu = MakeMenu( self.empty_list_menu, self, True, control ).menu
        menu.exec_(control.mapToGlobal(QtCore.QPoint(0, 0)))

    #---------------------------------------------------------------------------
    #  Displays the list editor popup menu:
    #---------------------------------------------------------------------------

    def popup_menu ( self , sender):
        """ Displays the list editor popup menu.
        """
        self._cur_control = sender

        proxy    = sender.proxy
        index    = proxy.index
        menu     = MakeMenu( self.list_menu, self, True, sender ).menu
        len_list = len( proxy.list )
        not_full = (len_list < self._trait_handler.maxlen)

        self._menu_before.enabled( not_full )
        self._menu_after.enabled(  not_full )
        self._menu_delete.enabled( len_list > self._trait_handler.minlen )
        self._menu_up.enabled(  index > 0 )
        self._menu_top.enabled( index > 0 )
        self._menu_down.enabled(   index < (len_list - 1) )
        self._menu_bottom.enabled( index < (len_list - 1) )

        menu.exec_(sender.mapToGlobal(QtCore.QPoint(0, 0)))

    #---------------------------------------------------------------------------
    #  Adds a new value at the specified list index:
    #---------------------------------------------------------------------------

    def add_item ( self, offset ):
        """ Adds a new value at the specified list index.
        """
        list, index = self.get_info()
        index      += offset
        item_trait  = self._trait_handler.item_trait
        value       = item_trait.default_value_for( self.object, self.name )
        self.value = list[:index] + [ value ] + list[index:]
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Inserts a new item before the current item:
    #---------------------------------------------------------------------------

    def add_before ( self ):
        """ Inserts a new item before the current item.
        """
        self.add_item( 0 )

    #---------------------------------------------------------------------------
    #  Inserts a new item after the current item:
    #---------------------------------------------------------------------------

    def add_after ( self ):
        """ Inserts a new item after the current item.
        """
        self.add_item( 1 )

    #---------------------------------------------------------------------------
    #  Adds a new item when the list is empty:
    #---------------------------------------------------------------------------

    def add_empty ( self ):
        """ Adds a new item when the list is empty.
        """
        list, index = self.get_info()
        self.add_item( 0 )

    #---------------------------------------------------------------------------
    #  Delete the current item:
    #---------------------------------------------------------------------------

    def delete_item ( self ):
        """ Delete the current item.
        """
        list, index = self.get_info()
        self.value  = list[:index] + list[index+1:]
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Move the current item up one in the list:
    #---------------------------------------------------------------------------

    def move_up ( self ):
        """ Move the current item up one in the list.
        """
        list, index = self.get_info()
        self.value  = (list[:index-1] + [ list[index], list[index-1] ] +
                       list[index+1:])
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Moves the current item down one in the list:
    #---------------------------------------------------------------------------

    def move_down ( self ):
        """ Moves the current item down one in the list.
        """
        list, index = self.get_info()
        self.value  = (list[:index] + [ list[index+1], list[index] ] +
                       list[index+2:])
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Moves the current item to the top of the list:
    #---------------------------------------------------------------------------

    def move_top ( self ):
        """ Moves the current item to the top of the list.
        """
        list, index = self.get_info()
        self.value  = [ list[index] ] + list[:index] + list[index+1:]
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Moves the current item to the bottom of the list:
    #---------------------------------------------------------------------------

    def move_bottom ( self ):
        """ Moves the current item to the bottom of the list.
        """
        list, index = self.get_info()
        self.value  = list[:index] + list[index+1:] + [ list[index] ]
        self.update_editor()

    #-- Private Methods --------------------------------------------------------

    def _dispose_items ( self ):
        """ Disposes of each current list item.
        """
        layout = self._list_pane.layout()
        child = layout.takeAt(0)
        while child is not None:
            control = child.widget()
            if control is not None:
                editor = getattr( control, '_editor', None )
                if editor is not None:
                    editor.dispose()
                    editor.control = None
                control.deleteLater()
            child = layout.takeAt(0)
        del child

    #-- Trait initializers ----------------------------------------------------

    def _kind_default(self):
        """ Returns a default value for the 'kind' trait.
        """
        return self.factory.style + '_editor'

    def _mutable_default(self):
        """ Trait handler to set the mutable trait from the factory.
        """
        return self.factory.mutable

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of editor for lists, which displays the items as a series
    of text fields. If the list is editable, an icon next to each item displays
    a menu of operations on the list.
    """

    #---------------------------------------------------------------------------
    #  Class constants:
    #---------------------------------------------------------------------------

    # Whether the list is displayed in a single row. This value overrides the
    # default.
    single_row = False

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the list editor is scrollable? This values overrides the default.
    scrollable = True

#-------------------------------------------------------------------------------
#  'TextEditor' class:
#-------------------------------------------------------------------------------

class TextEditor(CustomEditor):

    # The kind of editor to create for each list item. This value overrides the
    # default.
    kind = 'text_editor'

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor(CustomEditor):

    # Is the list of items being edited mutable? This value overrides the
    # default.
    mutable = False

#-------------------------------------------------------------------------------
#  'NotebookEditor' class:
#-------------------------------------------------------------------------------

class NotebookEditor ( Editor ):
    """ An editor for lists that displays the list as a "notebook" of tabbed
    pages.
    """

    # The "Close Tab" button.
    close_button = Any()

    # Maps tab names to QWidgets representing the tab contents
    # TODO: It would be nice to be able to reuse self._pages for this, but
    # its keys are not quite what we want.
    _pagewidgets = Dict

    # Maps names of tabs to their menu QAction instances; used to toggle
    # checkboxes
    _action_dict = Dict


    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the notebook editor scrollable? This values overrides the default:
    scrollable = True

    # The currently selected notebook page object:
    selected = Any

    # Maps tab names to QWidgets representing the tab contents
    # TODO: It would be nice to be able to reuse self._pages for this, but
    # its keys are not quite what we want.
    _pagewidgets = Dict

    # Maps names of tabs to their menu QAction instances; used to toggle
    # checkboxes
    _action_dict = Dict

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._uis = []

        # Create a tab widget to hold each separate object's view:
        self.control = QtGui.QTabWidget()
        signal = QtCore.SIGNAL( 'currentChanged(int)' )
        QtCore.QObject.connect( self.control, signal, self._tab_activated )

        # Create the button to close tabs, if necessary:
        if self.factory.deletable:
            button = QtGui.QToolButton()
            button.setAutoRaise( True )
            button.setToolTip( 'Remove current tab ')
            button.setIcon ( ImageResource( 'closetab' ).create_icon() )

            self.control.setCornerWidget( button, QtCore.Qt.TopRightCorner )
            signal = QtCore.SIGNAL( 'clicked()' )
            QtCore.QObject.connect( button, signal, self.close_current )
            self.close_button = button

        if self.factory.show_notebook_menu:
            # Create the necessary attributes to manage hiding and revealing of
            # tabs via a context menu
            self._context_menu = QtGui.QMenu()
            self.control.customContextMenuRequested.connect(self._context_menu_requested)
            self.control.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        # Set up the additional 'list items changed' event handler needed for
        # a list based trait:
        self.context_object.on_trait_change( self.update_editor_item,
                               self.extended_name + '_items?', dispatch = 'ui' )

        # Set of selection synchronization:
        self.sync_value( self.factory.selected, 'selected' )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Destroy the views on each current notebook page:
        self.close_all()

        # Create a tab page for each object in the trait's value:
        for object in self.value:
            ui, view_object, monitoring = self._create_page(object)

            # Remember the page for later deletion processing:
            self._uis.append([ui.control, ui, view_object, monitoring])

        if self.selected:
            self._selected_changed(self.selected)

    #---------------------------------------------------------------------------
    #  Handles some subset of the trait's list being updated:
    #---------------------------------------------------------------------------

    def update_editor_item ( self, event ):
        """ Handles an update to some subset of the trait's list.
        """
        index = event.index

        # Delete the page corresponding to each removed item:
        page_name = self.factory.page_name[1:]

        for i in event.removed:
            page, ui, view_object, monitoring = self._uis[index]
            if monitoring:
                view_object.on_trait_change(self.update_page_name, page_name,
                        remove=True)
            ui.dispose()
            self.control.removeTab(self.control.indexOf(page))

            if self.factory.show_notebook_menu:
                for name, tmp in self._pagewidgets.items():
                    if tmp is page:
                        del self._pagewidgets[name]
                self._context_menu.removeAction(self._action_dict[name])
                del self._action_dict[name]

            del self._uis[index]

        # Add a page for each added object:
        first_page = None
        for object in event.added:
            ui, view_object, monitoring  = self._create_page(object)
            self._uis[index:index] = [[ui.control, ui, view_object, monitoring]]
            index += 1

            if first_page is None:
                first_page = ui.control

        if first_page is not None:
            self.control.setCurrentWidget(first_page)

    #---------------------------------------------------------------------------
    #  Closes the currently selected tab:
    #---------------------------------------------------------------------------

    def close_current ( self, force=False ):
        """ Closes the currently selected tab:
        """
        widget = self.control.currentWidget()
        for i in xrange( len( self._uis ) ):
            page, ui, _, _ = self._uis[i]
            if page is widget:
                if force or ui.handler.close( ui.info, True ):
                    del self.value[i]
                break

        if self.factory.show_notebook_menu:
            # Find the name associated with this widget, so we can purge its action
            # from the menu
            for name, tmp in self._pagewidgets.items():
                if tmp is widget:
                    break
            else:
                # Hmm... couldn't find the widget, assume that we don't need to do
                # anything.
                return

            action = self._action_dict[name]
            self._context_menu.removeAction(action)
            del self._action_dict[name]
            del self._pagewidgets[name]
        return

    #---------------------------------------------------------------------------
    #  Closes all currently open notebook pages:
    #---------------------------------------------------------------------------

    def close_all ( self ):
        """ Closes all currently open notebook pages.
        """
        page_name = self.factory.page_name[1:]

        for _, ui, view_object, monitoring in self._uis:
            if monitoring:
                view_object.on_trait_change(self.update_page_name, page_name,
                        remove=True)
            ui.dispose()

        # Reset the list of ui's and dictionary of page name counts:
        self._uis = []
        self._pages = {}

        self.control.clear()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self.context_object.on_trait_change( self.update_editor_item,
                                self.name + '_items?', remove = True )
        self.close_all()

        super( NotebookEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the trait defining a particular page's name being changed:
    #---------------------------------------------------------------------------

    def update_page_name ( self, object, name, old, new ):
        """ Handles the trait defining a particular page's name being changed.
        """
        for i, value in enumerate(self._uis):
            page, ui, _, _ = value
            if object is ui.info.object:
                name = None
                handler = getattr(self.ui.handler,
                        '%s_%s_page_name' % (self.object_name, self.name),
                        None)

                if handler is not None:
                    name = handler(self.ui.info, object)

                if name is None:
                    name = str(xgetattr(object, self.factory.page_name[1:], '???'))
                self.control.setTabText(self.control.indexOf(page), name)
                break

    #---------------------------------------------------------------------------
    #  Creates a page for a specified object and adds it to the tab widget:
    #---------------------------------------------------------------------------

    def _create_page ( self, object ):
        # Create the view for the object:
        view_object = object
        factory = self.factory
        if factory.factory is not None:
            view_object = factory.factory(object)
        ui = view_object.edit_traits( parent = self.control,
                                 view   = factory.view,
                                 kind   = factory.ui_kind ).set(
                                 parent = self.ui )

        # Get the name of the page being added to the notebook:
        name       = ''
        monitoring = False
        prefix     = '%s_%s_page_' % ( self.object_name, self.name )
        page_name  = factory.page_name
        if page_name[0:1] == '.':
            name       = xgetattr( view_object, page_name[1:], None )
            monitoring = (name is not None)
            if monitoring:
                handler_name = None
                method       = getattr( self.ui.handler, prefix + 'name', None )
                if method is not None:
                    handler_name = method( self.ui.info, object )
                if handler_name is not None:
                    name = handler_name
                else:
                    name = str( name ) or '???'
                view_object.on_trait_change( self.update_page_name,
                                        page_name[1:], dispatch = 'ui' )
            else:
                name = ''
        elif page_name != '':
            name = page_name

        if name == '':
            name = user_name_for( view_object.__class__.__name__ )

        # Make sure the name is not a duplicate:
        if not monitoring:
            self._pages[ name ] = count = self._pages.get( name, 0 ) + 1
            if count > 1:
                name += (' %d' % count)

        # Return the control for the ui, and whether or not its name is being
        # monitored:
        image   = None
        method  = getattr( self.ui.handler, prefix + 'image', None )
        if method is not None:
            image = method( self.ui.info, object )

        if image is None:
            self.control.addTab(ui.control, name)
        else:
            self.control.addTab(ui.control, image, name)

        if self.factory.show_notebook_menu:
            newaction = self._context_menu.addAction(name)
            newaction.setText(name)
            newaction.setCheckable(True)
            newaction.setChecked(True)
            newaction.triggered.connect(lambda e,name=name: self._menu_action(e,name=name))
            self._action_dict[name] = newaction
            self._pagewidgets[name] = ui.control

        return (ui, view_object, monitoring)

    def _tab_activated(self, idx):
        """ Handles a notebook tab being "activated" (i.e. clicked on) by the
            user.
        """
        widget = self.control.widget(idx)
        for page, ui, _, _ in self._uis:
            if page is widget:
                self.selected = ui.info.object
                break

    def _selected_changed(self, selected):
        """ Handles the **selected** trait being changed.
        """
        for page, ui, _, _ in self._uis:
            if ui.info and selected is ui.info.object:
                self.control.setCurrentWidget(page)
                break
            deletable = self.factory.deletable
            deletable_trait = self.factory.deletable_trait
            if deletable and deletable_trait:
                enabled = xgetattr(selected, deletable_trait, True)
                self.close_button.setEnabled(enabled)

    def _context_menu_requested(self, event):
        self._context_menu.popup(self.control.mapToGlobal(event))

    def _menu_action(self, event, name=""):
        """ Qt signal handler for when a item in a context menu is actually
        selected.  Not that we get this even after the underlying value has
        already changed.
        """
        action = self._action_dict[name]
        checked = action.isChecked()
        if not checked:
            for ndx in range(self.control.count()):
                if self.control.tabText(ndx) == name:
                    self.control.removeTab(ndx)
        else:
            # TODO: Fix tab order based on the context_object's list
            self.control.addTab(self._pagewidgets[name], name)

    def _context_menu_requested(self, event):
        self._context_menu.popup(self.control.mapToGlobal(event))

    def _menu_action(self, event, name=""):
        """ Qt signal handler for when a item in a context menu is actually
        selected.  Not that we get this even after the underlying value has
        already changed.
        """
        action = self._action_dict[name]
        checked = action.isChecked()
        if not checked:
            for ndx in range(self.control.count()):
                if self.control.tabText(ndx) == name:
                    self.control.removeTab(ndx)
        else:
            # TODO: Fix tab order based on the context_object's list
            self.control.addTab(self._pagewidgets[name], name)

########NEW FILE########
__FILENAME__ = list_str_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   08/05/2009
#
#-------------------------------------------------------------------------------

""" Traits UI editor for editing lists of strings.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui
import collections

from pyface.image_resource import ImageResource
from traits.api import Any, Bool, Event, Int, Instance, List, \
    Property, Str, TraitListEvent, NO_COMPARE
from traitsui.list_str_adapter import ListStrAdapter

from editor import Editor
from list_str_model import ListStrModel
from traitsui.menu import Menu

#-------------------------------------------------------------------------------
#  '_ListStrEditor' class:
#-------------------------------------------------------------------------------

class _ListStrEditor(Editor):
    """ Traits UI editor for editing lists of strings.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The list view control associated with the editor:
    list_view = Any

    # The list model associated the editor:
    model = Instance(ListStrModel)

    # The title of the editor:
    title = Str

    # The current set of selected items (which one is used depends upon the
    # initial state of the editor factory 'multi_select' trait):
    selected = Any
    multi_selected = List

    # The current set of selected item indices (which one is used depends upon
    # the initial state of the editor factory 'multi_select' trait):
    selected_index = Int(-1)
    multi_selected_indices = List(Int)

    # The most recently actived item and its index.
    # Always trigger change notification.
    activated = Any(comparison_mode=NO_COMPARE)
    activated_index = Int(comparison_mode=NO_COMPARE)

    # The most recently right_clicked item and its index:
    right_clicked = Event
    right_clicked_index = Event

    # Is the list editor scrollable? This value overrides the default.
    scrollable = True

    # Should the selected item be edited after rebuilding the editor list:
    edit = Bool(False)

    # The adapter from list items to editor values:
    adapter = Instance( ListStrAdapter )

    # Dictionary mapping image names to QIcons
    images = Any({})

    # Dictionary mapping ImageResource objects to QIcons
    image_resources = Any({})

    # The current number of item currently in the list:
    item_count = Property

    # The current search string:
    search = Str

    #---------------------------------------------------------------------------
    #  Editor interface:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        # Set up the adapter to use:
        self.adapter = factory.adapter
        self.sync_value(factory.adapter_name, 'adapter', 'from')

        # Create the list model and accompanying controls:
        self.model = ListStrModel(editor=self)

        self.control = QtGui.QWidget()
        layout = QtGui.QVBoxLayout(self.control)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        if factory.title or factory.title_name:
            header_view = QtGui.QHeaderView(QtCore.Qt.Horizontal, self.control)
            header_view.setModel(self.model)
            header_view.setMaximumHeight(header_view.sizeHint().height())
            header_view.setResizeMode(QtGui.QHeaderView.Stretch)
            layout.addWidget(header_view)

        self.list_view = _ListView(self)
        layout.addWidget(self.list_view)

        # Set up the list control's event handlers:
        if factory.multi_select:
            slot = self._on_rows_selection
        else:
            slot = self._on_row_selection
        signal = 'selectionChanged(QItemSelection,QItemSelection)'
        QtCore.QObject.connect(self.list_view.selectionModel(),
                               QtCore.SIGNAL(signal), slot)

        signal = QtCore.SIGNAL('activated(QModelIndex)')
        QtCore.QObject.connect(self.list_view, signal, self._on_activate)

        # Initialize the editor title:
        self.title = factory.title
        self.sync_value(factory.title_name, 'title', 'from')

        # Set up the selection listener
        if factory.multi_select:
            self.sync_value(factory.selected, 'multi_selected', 'both',
                            is_list=True)
            self.sync_value(factory.selected_index, 'multi_selected_indices',
                            'both', is_list=True)
        else:
            self.sync_value(factory.selected, 'selected', 'both')
            self.sync_value(factory.selected_index, 'selected_index', 'both')

        # Synchronize other interesting traits as necessary:
        self.sync_value(factory.activated, 'activated', 'to')
        self.sync_value(factory.activated_index, 'activated_index', 'to')

        self.sync_value(factory.right_clicked, 'right_clicked', 'to')
        self.sync_value(factory.right_clicked_index, 'right_clicked_index', 'to')

        # Make sure we listen for 'items' changes as well as complete list
        # replacements:
        self.context_object.on_trait_change(
            self.update_editor, self.extended_name + '_items', dispatch='ui')

        # Create the mapping from user supplied images to QIcons:
        for image_resource in factory.images:
            self._add_image(image_resource)

        # Refresh the editor whenever the adapter changes:
        self.on_trait_change(
            self.refresh_editor, 'adapter.+update', dispatch='ui')

        # Set the list control's tooltip:
        self.set_tooltip()

    def dispose(self):
        """ Disposes of the contents of an editor.
        """
        self.context_object.on_trait_change(
            self.update_editor, self.extended_name + '_items', remove=True)

        self.on_trait_change(
            self.refresh_editor, 'adapter.+update', remove=True)

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if not self._no_update:
            self.model.reset()
            # restore selection back
            if self.factory.multi_select :
                self._multi_selected_changed(self.multi_selected)
            else :
                self._selected_changed(self.selected)

    #---------------------------------------------------------------------------
    #  ListStrEditor interface:
    #---------------------------------------------------------------------------

    def refresh_editor(self):
        """ Requests that the underlying list widget to redraw itself.
        """
        self.list_view.viewport().update()

    def callx(self, func, *args, **kw):
        """ Call a function without allowing the editor to update.
        """
        old = self._no_update
        self._no_update = True
        try:
            func(*args, **kw)
        finally:
            self._no_update = old

    def setx(self, **keywords):
        """ Set one or more attributes without allowing the editor to update.
        """
        old = self._no_notify
        self._no_notify = True
        try:
            for name, value in keywords.items():
                setattr(self, name, value)
        finally:
            self._no_notify = old

    def get_image(self, image):
        """ Converts a user specified image to a QIcon.
        """
        if isinstance(image, ImageResource):
            result = self.image_resources.get(image)
            if result is not None:
                return result

            return self._add_image(image)

        return self.images.get(image)

    def is_auto_add(self, index):
        """ Returns whether or not the index is the special 'auto add' item at
            the end of the list.
        """
        return (self.factory.auto_add and
                (index >= self.adapter.len(self.object, self.name)))

    #---------------------------------------------------------------------------
    #  Private interface:
    #---------------------------------------------------------------------------

    def _add_image(self, image_resource):
        """ Adds a new image to the image map.
        """
        image = image_resource.create_icon()

        self.image_resources[image_resource] = image
        self.images[image_resource.name] = image

        return image

    #-- Property Implementations -----------------------------------------------

    def _get_item_count ( self ):
        return (self.model.rowCount(None) - self.factory.auto_add)

    #-- Trait Event Handlers ---------------------------------------------------

    def _selected_changed(self, selected):
        """ Handles the editor's 'selected' trait being changed.
        """
        if not self._no_update:
            try:
                selected_index = self.value.index(selected)
            except ValueError:
                pass
            else:
                self._selected_index_changed(selected_index)

    def _selected_index_changed(self, selected_index):
        """ Handles the editor's 'selected_index' trait being changed.
        """
        if not self._no_update:
            smodel = self.list_view.selectionModel()
            if selected_index == -1:
                smodel.clearSelection()
            else:
                mi = self.model.index(selected_index)
                smodel.select(mi, QtGui.QItemSelectionModel.ClearAndSelect)
                self.list_view.scrollTo(mi)

    def _multi_selected_changed(self, selected):
        """ Handles the editor's 'multi_selected' trait being changed.
        """
        if not self._no_update:
            indices = []
            for item in selected :
                try:
                    indices.append(self.value.index(item))
                except ValueError:
                    pass
            self._multi_selected_indices_changed(indices)

    def _multi_selected_items_changed(self, event):
        """ Handles the editor's 'multi_selected' trait being modified.
        """
        if not self._no_update:
            try:
                added = [ self.value.index(item) for item in event.added ]
                removed = [ self.value.index(item) for item in event.removed ]
            except ValueError:
                pass
            else:
                event = TraitListEvent(0, added, removed)
                self._multi_selected_indices_items_changed(event)

    def _multi_selected_indices_changed(self, selected_indices):
        """ Handles the editor's 'multi_selected_indices' trait being changed.
        """
        if not self._no_update:
            smodel = self.list_view.selectionModel()
            smodel.clearSelection()
            for selected_index in selected_indices:
                smodel.select(self.model.index(selected_index),
                              QtGui.QItemSelectionModel.Select)
            if selected_indices:
                self.list_view.scrollTo(self.model.index(selected_indices[-1]))

    def _multi_selected_indices_items_changed(self, event):
        """ Handles the editor's 'multi_selected_indices' trait being modified.
        """
        if not self._no_update:
            smodel = self.list_view.selectionModel()
            for selected_index in event.removed:
                smodel.select(self.model.index(selected_index),
                              QtGui.QItemSelectionModel.Deselect)
            for selected_index in event.added:
                smodel.select(self.model.index(selected_index),
                              QtGui.QItemSelectionModel.Select)

    #-- List Control Event Handlers --------------------------------------------

    def _on_activate(self, mi):
        """ Handle a cell being activated.
        """
        self.activated_index = index = mi.row()
        self.activated = self.adapter.get_item(self.object, self.name, index)

    def _on_context_menu(self, point):
        """ Handle a context menu request.
        """
        mi = self.list_view.indexAt(point)
        if mi.isValid():
            self.right_clicked_index = index = mi.row()
            self.right_clicked = self.adapter.get_item(
                self.object, self.name, index)

    def _on_row_selection(self, added, removed):
        """ Handle the row selection being changed.
        """
        self._no_update = True
        try:
            indices = self.list_view.selectionModel().selectedRows()
            if len(indices):
                self.selected_index = indices[0].row()
                self.selected = self.adapter.get_item(self.object, self.name,
                                                      self.selected_index)
            else:
                self.selected_index = -1
                self.selected = None
        finally:
            self._no_update = False

    def _on_rows_selection(self, added, removed):
        """ Handle the rows selection being changed.
        """
        self._no_update = True
        try:
            indices = self.list_view.selectionModel().selectedRows()
            self.multi_selected_indices = indices = [ i.row() for i in indices ]
            self.multi_selected = [ self.adapter.get_item(self.object,
                                                          self.name, i)
                                    for i in self.multi_selected_indices ]
        finally:
            self._no_update = False

    def _on_context_menu(self, pos) :
        menu = self.factory.menu

        index = self.list_view.indexAt(pos).row()

        if isinstance(menu, str) :
            menu = getattr(self.object, menu, None)

        if isinstance(menu, collections.Callable) :
            menu = menu(index)

        if menu is not None :
            qmenu = menu.create_menu( self.list_view, self )

            self._menu_context = {'selection': self.object,
                             'object':  self.object,
                             'editor':  self,
                             'index':   index,
                             'info':    self.ui.info,
                             'handler': self.ui.handler }

            qmenu.exec_(self.list_view.mapToGlobal(pos))

            self._menu_context = None

#-------------------------------------------------------------------------------
#  Qt widgets that have been configured to behave as expected by Traits UI:
#-------------------------------------------------------------------------------

class _ItemDelegate(QtGui.QStyledItemDelegate):
    """ A QStyledItemDelegate which optionally draws horizontal gridlines.
        (QListView does not support gridlines).
    """

    def __init__(self, editor, parent=None):
        """ Save the editor
        """
        QtGui.QStyledItemDelegate.__init__(self, parent)
        self._editor = editor

    def paint(self, painter, option, index):
        """ Overrident to draw gridlines.
        """
        QtGui.QStyledItemDelegate.paint(self, painter, option, index)
        if self._editor.factory.horizontal_lines:
            painter.save()
            painter.setPen(option.palette.color(QtGui.QPalette.Dark))
            painter.drawLine(option.rect.bottomLeft(),option.rect.bottomRight())
            painter.restore()

class _ListView(QtGui.QListView):
    """ A QListView configured to behave as expected by TraitsUI.
    """

    def __init__(self, editor):
        """ Initialise the object.
        """
        QtGui.QListView.__init__(self)

        self._editor = editor
        self.setItemDelegate(_ItemDelegate(editor, self))
        self.setModel(editor.model)
        factory = editor.factory

        # Configure the selection behavior
        if factory.multi_select:
            mode = QtGui.QAbstractItemView.ExtendedSelection
        else:
            mode = QtGui.QAbstractItemView.SingleSelection
        self.setSelectionMode(mode)

        # Configure drag and drop behavior
        self.setDragEnabled(True)
        self.setDragDropOverwriteMode(True)
        self.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
        self.setDropIndicatorShown(True)

        if editor.factory.menu is False :
            self.setContextMenuPolicy(QtCore.Qt.NoContextMenu)
        elif editor.factory.menu is not False :
            self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        self.connect(self, QtCore.SIGNAL('customContextMenuRequested(QPoint)'),
                editor._on_context_menu)

        # Configure context menu behavior
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

    def keyPressEvent(self, event):
        """ Reimplemented to support edit, insert, and delete by keyboard.
        """
        editor = self._editor
        factory = editor.factory

        # Note that setting 'EditKeyPressed' as an edit trigger does not work on
        # most platforms, which is why we do this here.
        if (event.key() in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return) and
            self.state() != QtGui.QAbstractItemView.EditingState and
            factory.editable and 'edit' in factory.operations):
            if factory.multi_select:
                indices = editor.multi_selected_indices
                row = indices[0] if len(indices) == 1 else -1
            else:
                row = editor.selected_index

            if row != -1:
                event.accept()
                self.edit(editor.model.index(row))

        elif (event.key() in (QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Delete) and
              factory.editable and 'delete' in factory.operations):
            event.accept()

            if factory.multi_select:
                for row in reversed(sorted(editor.multi_selected_indices)):
                    editor.model.removeRow(row)
            elif editor.selected_index != -1:
                # Deleting the selected item will reset cause the ListView's
                # selection model to select the next item before removing the
                # originally selected rows. Visually, this looks fine because
                # the next item is then placed where the deleted item used to
                # be. However, some internal state is kept which makes the
                # selected item seem off by one. So we'll reset it manually
                # here.
                row = editor.selected_index
                editor.model.removeRow(row)
                # Handle the case of deleting the last item in the list.
                editor.selected_index = min(
                    row, editor.adapter.len(editor.object, editor.name) - 1)

        elif (event.key() == QtCore.Qt.Key_Insert and
              factory.editable and 'insert' in factory.operations):
            event.accept()

            if factory.multi_select:
                indices = sorted(editor.multi_selected_indices)
                row = indices[0] if len(indices) else -1
            else:
                row = editor.selected_index
            if row == -1:
                row = editor.adapter.len(editor.object, editor.name)
            editor.model.insertRow(row)
            self.setCurrentIndex(editor.model.index(row))

        else:
            QtGui.QListView.keyPressEvent(self, event)


########NEW FILE########
__FILENAME__ = list_str_model
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   08/05/2009
#
#-------------------------------------------------------------------------------

""" Defines the table model used by the tabular editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traitsui.ui_traits import SequenceTypes

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# MIME type for internal table drag/drop operations
mime_type = 'traits-ui-list-str-editor'

#-------------------------------------------------------------------------------
#  'ListStrModel' class:
#-------------------------------------------------------------------------------

class ListStrModel(QtCore.QAbstractListModel):
    """ A model for lists of strings.
    """

    def __init__(self, editor, parent=None):
        """ Initialise the object.
        """
        QtCore.QAbstractListModel.__init__(self, parent)

        self._editor = editor

    #---------------------------------------------------------------------------
    #  QAbstractItemModel interface:
    #---------------------------------------------------------------------------

    def rowCount(self, mi):
        """ Reimplemented to return items in the list.
        """
        editor = self._editor
        return editor.adapter.len(editor.object, editor.name)

    def data(self, mi, role):
        """ Reimplemented to return the data.
        """
        editor = self._editor
        adapter = editor.adapter
        index = mi.row()

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:
            if editor.is_auto_add(index):
                text = adapter.get_default_text(editor.object, editor.name,
                                                index)
            else:
                text = adapter.get_text(editor.object, editor.name, index)
            if role == QtCore.Qt.DisplayRole and text == '':
                # FIXME: This is a hack to make empty strings editable.
                text = ' '
            return text

        elif role == QtCore.Qt.DecorationRole:
            if editor.is_auto_add(index):
                image = adapter.get_default_image(editor.object,
                                                  editor.name, index)
            else:
                image = adapter.get_image(editor.object, editor.name, index)
            image = editor.get_image(image)
            if image is not None:
                return image

        elif role == QtCore.Qt.BackgroundRole:
            if editor.is_auto_add(index):
                color = adapter.get_default_bg_color(editor.object, editor.name)
            else:
                color = adapter.get_bg_color(editor.object, editor.name, index)
            if color is not None:
                if isinstance(color, SequenceTypes):
                    q_color = QtGui.QColor(*color)
                else:
                    q_color = QtGui.QColor(color)
                return QtGui.QBrush(q_color)

        elif role == QtCore.Qt.ForegroundRole:
            if editor.is_auto_add(index):
                color = adapter.get_default_text_color(editor.object,
                                                       editor.name)
            else:
                color = adapter.get_text_color(editor.object,
                                               editor.name, index)
            if color is not None:
                if isinstance(color, SequenceTypes):
                    q_color = QtGui.QColor(*color)
                else:
                    q_color = QtGui.QColor(color)
                return QtGui.QBrush(q_color)

        return None

    def setData(self, mi, value, role):
        """ Reimplmented to allow for modification of the object trait.
        """
        editor = self._editor
        editor.adapter.set_text(editor.object, editor.name, mi.row(), value)
        signal = QtCore.SIGNAL('dataChanged(QModelIndex,QModelIndex)')
        self.emit(signal, mi, mi)
        return True

    def setItemData(self, mi, roles):
        """ Reimplmented to reject all setItemData calls.
        """
        # FIXME: This is a hack to prevent the QListView from clearing out the
        # old row after a move operation. (The QTableView doesn't do this, for
        # some reason). This behavior is not overridable so far as I can tell,
        # but there may be a better way around this issue. Note that we cannot
        # simply use a CopyAction instead because InternalMove mode is hardcoded
        # in the Qt source to allow only MoveActions.
        return False

    def flags(self, mi):
        """ Reimplemented to set editable status and movable status.
        """
        editor = self._editor
        index = mi.row()

        flags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled

        if (editor.factory.editable and 'edit' in editor.factory.operations and
            editor.adapter.get_can_edit(editor.object, editor.name, index)):
            flags |= QtCore.Qt.ItemIsEditable

        if (editor.factory.editable and 'move' in editor.factory.operations and
            editor.adapter.get_drag(editor.object, editor.name, index) is not None):
            flags |= QtCore.Qt.ItemIsDragEnabled | QtCore.Qt.ItemIsDropEnabled

        return flags

    def headerData(self, section, orientation, role):
        """ Reimplemented to return title for vertical header data.
        """
        if orientation != QtCore.Qt.Horizontal or role != QtCore.Qt.DisplayRole:
            return None

        return self._editor.title

    def insertRow(self, row, parent=QtCore.QModelIndex(), obj=None):
        """ Reimplemented to allow creation of new rows. Added an optional
            arg to allow the insertion of an existing row object.
        """
        editor = self._editor
        adapter = editor.adapter

        if obj is None:
            obj = adapter.get_default_value(editor.object, editor.name)
        self.beginInsertRows(parent, row, row)
        editor.callx(
            editor.adapter.insert, editor.object, editor.name, row, obj)
        self.endInsertRows()
        return True

    def insertRows(self, row, count, parent=QtCore.QModelIndex()):
        """ Reimplemented to allow creation of new items.
        """
        editor = self._editor
        adapter = editor.adapter

        self.beginInsertRows(parent, row, row + count - 1)
        for i in xrange(count):
            value = adapter.get_default_value(editor.object, editor.name)
            editor.callx(adapter.insert, editor.object, editor.name, row, value)
        self.endInsertRows()
        return True

    def removeRows(self, row, count, parent=QtCore.QModelIndex()):
        """ Reimplemented to allow row deletion, as well as reordering via drag
            and drop.
        """
        editor = self._editor
        adapter = editor.adapter

        self.beginRemoveRows(parent, row, row + count - 1)
        for i in xrange(count):
            editor.callx(adapter.delete, editor.object, editor.name, row)
        self.endRemoveRows()
        return True

    def mimeTypes(self):
        """ Reimplemented to expose our internal MIME type for drag and drop
            operations.
        """
        return [mime_type]

    def mimeData(self, indexes):
        """ Reimplemented to generate MIME data containing the rows of the
            current selection.
        """
        mime_data = QtCore.QMimeData()
        rows = list(set([ index.row() for index in indexes ]))
        data = QtCore.QByteArray(str(rows[0]))
        for row in rows[1:]:
            data.append(' %i' % row)
        mime_data.setData(mime_type, data)
        return mime_data

    def dropMimeData(self, mime_data, action, row, column, parent):
        """ Reimplemented to allow items to be moved.
        """
        if action == QtCore.Qt.IgnoreAction:
            return False

        data = mime_data.data(mime_type)
        if data.isNull():
            return False

        current_rows = map(int, str(data).split(' '))
        self.moveRows(current_rows, parent.row())
        return True

    def supportedDropActions(self):
        """ Reimplemented to allow items to be moved.
        """
        return QtCore.Qt.MoveAction

    #---------------------------------------------------------------------------
    #  ListStrModel interface:
    #---------------------------------------------------------------------------

    def moveRow(self, old_row, new_row):
        """ Convenience method to move a single row.
        """
        return self.moveRows([old_row], new_row)

    def moveRows(self, current_rows, new_row):
        """ Moves a sequence of rows (provided as a list of row indexes) to a
            new row.
        """
        editor = self._editor

        # Sort rows in descending order so they can be removed without
        # invalidating the indices.
        current_rows.sort()
        current_rows.reverse()

        # If the the highest selected row is lower than the destination, do an
        # insertion before rather than after the destination.
        if current_rows[-1] < new_row:
            new_row += 1

        # Remove selected rows...
        objects = []
        for row in current_rows:
            if row <= new_row:
                new_row -= 1
            obj = editor.adapter.get_item(editor.object, editor.name, row)
            objects.insert(0, obj)
            self.removeRow(row)

        # ...and add them at the new location.
        for i, obj in enumerate(objects):
            self.insertRow(new_row + i, obj=obj)

        # Update the selection for the new location.
        if editor.factory.multi_select:
            editor.setx(multi_selected = objects)
            editor.multi_selected_indices = range(new_row, new_row+len(objects))
        else:
            editor.setx(selected = objects[0])
            editor.selected_index = new_row

########NEW FILE########
__FILENAME__ = menu
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

"""
Dynamically construct PyQt Menus or MenuBars from a supplied string
description of the menu.

Menu Description Syntax::

    submenu_label {help_string}
        menuitem_label | accelerator {help_string} [~/-name]: code

*submenu_label*
    Label of a sub menu
*menuitem_label*
    Label of a menu item
{*help_string*}
    Help string to display on the status line (optional)
*accelerator*
    Accelerator key (e.g., Ctrl-C) (The '|' and keyname are optional, but must
    be used together.)
[~]
    The menu item is checkable, but is not checked initially (optional)
[/]
    The menu item is checkable, and is checked initially (optional)
[-]
    The menu item disabled initially (optional)
[*name*]
    Symbolic name used to refer to menu item (optional)
*code*
    Python code invoked when menu item is selected

A line beginning with a hyphen (-) is interpreted as a menu separator.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import re

from pyface.qt import QtGui

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

help_pat    = re.compile( r'(.*){(.*)}(.*)' )
options_pat = re.compile( r'(.*)\[(.*)\](.*)' )

#-------------------------------------------------------------------------------
#  'MakeMenu' class:
#-------------------------------------------------------------------------------

class MakeMenu:
    """ Manages creation of menus.
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, desc, owner, popup = False, window = None ):
        """ Initializes the object.
        """
        self.owner = owner
        if window is None:
            window = owner
        self.window   = window
        self.indirect = getattr( owner, 'call_menu', None )
        self.names    = {}
        self.desc     = desc.split( '\n' )
        self.index    = 0
        if popup:
            self.menu = menu = QtGui.QMenu()
            self.parse( menu, -1 )
        else:
            self.menu = menu = QtGui.QMenuBar()
            self.parse( menu, -1 )
            window.setMenuBar( menu )

    #---------------------------------------------------------------------------
    #  Recursively parses menu items from the description:
    #---------------------------------------------------------------------------

    def parse ( self, menu, indent ):
        """ Recursively parses menu items from the description.
        """

        while True:

            # Make sure we have not reached the end of the menu description yet:
            if self.index >= len( self.desc ):
                return

            # Get the next menu description line and check its indentation:
            dline    = self.desc[ self.index ]
            line     = dline.lstrip()
            indented = len( dline ) - len( line )
            if indented <= indent:
                return

            # Indicate that the current line has been processed:
            self.index += 1

            # Check for a blank or comment line:
            if (line == '') or (line[0:1] == '#'):
                continue

            # Check for a menu separator:
            if line[0:1] == '-':
                menu.addSeparator()
                continue

            # Extract the help string (if any):
            help  = ''
            match = help_pat.search( line )
            if match:
                help = ' ' + match.group(2).strip()
                line = match.group(1) + match.group(3)

            # Check for a menu item:
            col = line.find( ':' )
            if col >= 0:
                handler = line[ col + 1: ].strip()
                if handler != '':
                    if self.indirect:
                        self.indirect( cur_id, handler )
                        handler = self.indirect
                    else:
                        try:
                            exec ('def handler(self=self.owner):\n %s\n' %
                                  handler)
                        except:
                           handler = null_handler
                else:
                    try:
                        exec 'def handler(self=self.owner):\n%s\n' % (
                            self.get_body( indented ), ) in globals()
                    except:
                        handler = null_handler

                not_checked = checked = disabled = False
                name = key = ''
                line = line[:col]
                match = options_pat.search(line)
                if match:
                    line = match.group(1) + match.group(3)
                    not_checked, checked, disabled, name = option_check( '~/-',
                             match.group(2).strip() )

                label = line.strip()
                col   = label.find( '|' )
                if col >= 0:
                    key   = label[col + 1:].strip()
                    label = label[:col].strip()

                act = menu.addAction(label, handler)
                act.setCheckable(not_checked or checked)
                act.setStatusTip(help)

                if key:
                    act.setShortcut(key)

                if checked:
                    act.setChecked(True)

                if disabled:
                    act.setEnabled(False)

                if name:
                    self.names[name] = act
                    setattr(self.owner, name, MakeMenuItem(self, act))
            else:
                # Else must be the start of a sub menu:
                submenu = QtGui.QMenu(line.strip())

                # Recursively parse the sub-menu:
                self.parse(submenu, indented)

                # Add the menu to its parent:
                act = menu.addMenu(submenu)
                act.setStatusTip(help)

    #---------------------------------------------------------------------------
    #  Returns the body of an inline method:
    #---------------------------------------------------------------------------

    def get_body ( self, indent ):
        """ Returns the body of an inline method.
        """
        result = []
        while self.index < len( self.desc ):
            line = self.desc[ self.index ]
            if (len( line ) - len( line.lstrip() )) <= indent:
                break
            result.append( line )
            self.index += 1
        result = '\n'.join( result ).rstrip()
        if result != '':
            return result
        return '  pass'

    #---------------------------------------------------------------------------
    #  Returns the QAction associated with a specified name:
    #---------------------------------------------------------------------------

    def get_action(self, name):
        """ Returns the QAction associated with a specified name.
        """
        if isinstance(name, basestring):
            return self.names[name]

        return name

    #---------------------------------------------------------------------------
    #  Checks (or unchecks) a menu item specified by name:
    #---------------------------------------------------------------------------

    def checked(self, name, check=None):
        """ Checks (or unchecks) a menu item specified by name.
        """
        act = self.get_action(name)

        if check is None:
            return act.isChecked()

        act.setChecked(check)

    #---------------------------------------------------------------------------
    #  Enables (or disables) a menu item specified by name:
    #---------------------------------------------------------------------------

    def enabled(self, name, enable=None):
        """ Enables (or disables) a menu item specified by name.
        """
        act = self.get_action(name)

        if enable is None:
            return act.isEnabled()

        act.setEnabled(enable)

    #---------------------------------------------------------------------------
    #  Gets/Sets the label for a menu item:
    #---------------------------------------------------------------------------

    def label(self, name, label=None):
        """ Gets or sets the label for a menu item.
        """
        act = self.get_action(name)

        if label is None:
            return unicode(act.text())

        act.setText(label)

#-------------------------------------------------------------------------------
#  'MakeMenuItem' class:
#-------------------------------------------------------------------------------

class MakeMenuItem:
    """ A menu item for a menu managed by MakeMenu.
    """
    def __init__(self, menu, act):
        self.menu = menu
        self.act = act

    def checked(self, check=None):
        return self.menu.checked(self.act, check)

    def toggle(self):
        checked = not self.checked()
        self.checked(checked)
        return checked

    def enabled(self, enable=None):
        return self.menu.enabled(self.act, enable)

    def label(self, label=None):
        return self.menu.label(self.act, label)

#-------------------------------------------------------------------------------
#  Determine whether a string contains any specified option characters, and
#  remove them if it does:
#-------------------------------------------------------------------------------

def option_check ( test, string ):
    """ Determines whether a string contains any specified option characters,
    and removes them if it does.
    """
    result = []
    for char in test:
        col = string.find( char )
        result.append( col >= 0 )
        if col >= 0:
            string = string[ : col ] + string[ col + 1: ]
    return result + [ string.strip() ]

#-------------------------------------------------------------------------------
#  Null menu option selection handler:
#-------------------------------------------------------------------------------

def null_handler ( event ):
    print 'null_handler invoked'

########NEW FILE########
__FILENAME__ = null_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/26/2006
#
#-------------------------------------------------------------------------------

""" Defines a completely empty editor, intended to be used as a spacer.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.null_editor file.
from traitsui.editors.null_editor \
    import NullEditor as ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'NullEditor' class:
#-------------------------------------------------------------------------------

class NullEditor ( Editor ):
    """ A completely empty editor.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QWidget()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

########NEW FILE########
__FILENAME__ = range_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various range editors and the range editor factory, for the
PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from math \
    import log10

from pyface.qt import QtCore, QtGui

from traits.api \
     import TraitError, Str, Float, Any, Bool

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.range_editor file.
from traitsui.editors.range_editor \
    import ToolkitEditorFactory

from editor_factory \
    import TextEditor

from editor \
    import Editor

from constants \
    import OKColor, ErrorColor

from helper \
    import IconButton

#-------------------------------------------------------------------------------
#  'BaseRangeEditor' class:
#-------------------------------------------------------------------------------

class BaseRangeEditor ( Editor ):
    """ The base class for Range editors. Using an evaluate trait, if specified,
        when assigning numbers the object trait.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function to evaluate floats/ints
    evaluate = Any

    #---------------------------------------------------------------------------
    #  Sets the associated object trait's value:
    #---------------------------------------------------------------------------

    def _set_value ( self, value ):
        if self.evaluate is not None:
            value = self.evaluate( value )
        Editor._set_value( self, value )

#-------------------------------------------------------------------------------
#  'SimpleSliderEditor' class:
#-------------------------------------------------------------------------------

class SimpleSliderEditor ( BaseRangeEditor ):
    """ Simple style of range editor that displays a slider and a text field.

    The user can set a value either by moving the slider or by typing a value
    in the text field.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Low value for the slider range
    low = Any

    # High value for the slider range
    high = Any

    # Formatting string used to format value and labels
    format = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if not factory.low_name:
            self.low = factory.low

        if not factory.high_name:
            self.high = factory.high

        self.format = factory.format

        self.evaluate = factory.evaluate
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        self.sync_value( factory.low_name,  'low',  'from' )
        self.sync_value( factory.high_name, 'high', 'from' )

        self.control = QtGui.QWidget()
        panel = QtGui.QHBoxLayout(self.control)
        panel.setContentsMargins(0, 0, 0, 0)

        fvalue = self.value

        try:
            if not (self.low <= fvalue <= self.high):
                fvalue = self.low
            fvalue_text = self.format % fvalue
        except:
            fvalue_text = ''
            fvalue      = self.low

        ivalue = self._convert_to_slider(fvalue)

        self._label_lo = QtGui.QLabel()
        self._label_lo.setAlignment(QtCore.Qt.AlignRight |
                                    QtCore.Qt.AlignVCenter)
        if factory.label_width > 0:
            self._label_lo.setMinimumWidth(factory.label_width)
        panel.addWidget(self._label_lo)

        self.control.slider = slider = QtGui.QSlider(QtCore.Qt.Horizontal)
        slider.setTracking(factory.auto_set)
        slider.setMinimum(0)
        slider.setMaximum(10000)
        slider.setPageStep(1000)
        slider.setSingleStep(100)
        slider.setValue(ivalue)
        QtCore.QObject.connect(slider, QtCore.SIGNAL('valueChanged(int)'),
                self.update_object_on_scroll)
        panel.addWidget(slider)

        self._label_hi = QtGui.QLabel()
        panel.addWidget(self._label_hi)
        if factory.label_width > 0:
            self._label_hi.setMinimumWidth(factory.label_width)

        self.control.text = text = QtGui.QLineEdit(fvalue_text)
        QtCore.QObject.connect(text, QtCore.SIGNAL('editingFinished()'),
                self.update_object_on_enter)

        # The default size is a bit too big and probably doesn't need to grow.
        sh = text.sizeHint()
        sh.setWidth(sh.width() / 2)
        text.setMaximumSize(sh)

        panel.addWidget(text)

        low_label = factory.low_label
        if factory.low_name != '':
            low_label = self.format % self.low

        high_label = factory.high_label
        if factory.high_name != '':
            high_label = self.format % self.high

        self._label_lo.setText(low_label)
        self._label_hi.setText(high_label)

        self.set_tooltip(slider)
        self.set_tooltip(self._label_lo)
        self.set_tooltip(self._label_hi)
        self.set_tooltip(text)

    #---------------------------------------------------------------------------
    #  Handles the user changing the current slider value:
    #---------------------------------------------------------------------------

    def update_object_on_scroll(self, pos):
        """ Handles the user changing the current slider value.
        """
        value = self._convert_from_slider(pos)
        self.control.text.setText(self.format % value)
        self.value = value

    #---------------------------------------------------------------------------
    #  Handle the user pressing the 'Enter' key in the edit control:
    #---------------------------------------------------------------------------

    def update_object_on_enter (self):
        """ Handles the user pressing the Enter key in the text field.
        """
        try:
            try:
                value = eval(unicode(self.control.text.text()).strip())
            except Exception, ex:
                # The entered something that didn't eval as a number, (e.g.,
                # 'foo') pretend it didn't happen
                value = self.value
                self.control.text.setText(unicode(value))

            if not self.factory.is_float:
                value = int(value)

            self.value = value
            self.control.slider.setValue(self._convert_to_slider(self.value))
        except TraitError, excp:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        low   = self.low
        high  = self.high
        try:
            text = self.format % value
            1 / (low <= value <= high)
        except:
            text  = ''
            value = low

        ivalue = self._convert_to_slider(value)

        self.control.text.setText(text)

        blocked = self.control.slider.blockSignals(True)
        self.control.slider.setValue(ivalue)
        self.control.slider.blockSignals(blocked)

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.control.text

    #---------------------------------------------------------------------------
    #  Handles the 'low'/'high' traits being changed:
    #---------------------------------------------------------------------------

    def _low_changed ( self, low ):
        if self.value < low:
            if self.factory.is_float:
                self.value = float( low )
            else:
                self.value = int( low )

        if self._label_lo is not None:
            self._label_lo.setText(self.format % low)
            self.update_editor()

    def _high_changed ( self, high ):
        if self.value > high:
            if self.factory.is_float:
                self.value = float( high )
            else:
                self.value = int( high )

        if self._label_hi is not None:
            self._label_hi.setText(self.format % high)
            self.update_editor()

    def _convert_to_slider(self, value):
        """ Returns the slider setting corresponding to the user-supplied value.
        """
        if self.high > self.low:
            ivalue = int( (float( value - self.low ) /
                           (self.high - self.low)) * 10000.0 )
        else:
            ivalue = self.low

            if ivalue is None:
                ivalue = 0
        return ivalue

    def _convert_from_slider(self, ivalue):
        """ Returns the float or integer value corresponding to the slider
        setting.
        """
        value = self.low + ((float( ivalue ) / 10000.0) *
                            (self.high - self.low))
        if not self.factory.is_float:
            value = int(round(value))
        return value


#-------------------------------------------------------------------------------
class LogRangeSliderEditor ( SimpleSliderEditor ):
#-------------------------------------------------------------------------------
    """ A slider editor for log-spaced values
    """

    def _convert_to_slider(self, value):
        """ Returns the slider setting corresponding to the user-supplied value.
        """
        value = max(value, self.low)
        ivalue = int( (log10(value) - log10(self.low)) /
                      (log10(self.high) - log10(self.low)) * 10000.0)
        return ivalue

    def _convert_from_slider(self, ivalue):
        """ Returns the float or integer value corresponding to the slider
        setting.
        """
        value = float( ivalue ) / 10000.0 * (log10(self.high) -log10(self.low))
        # Do this to handle floating point errors, where fvalue may exceed
        # self.high.
        fvalue = min(self.low*10**(value), self.high)
        if not self.factory.is_float:
            fvalue = int(round(fvalue))
        return fvalue

#-------------------------------------------------------------------------------
#  'LargeRangeSliderEditor' class:
#-------------------------------------------------------------------------------

class LargeRangeSliderEditor ( BaseRangeEditor ):
    """ A slider editor for large ranges.

    The editor displays a slider and a text field. A subset of the total range
    is displayed in the slider; arrow buttons at each end of the slider let
    the user move the displayed range higher or lower.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Low value for the slider range
    low = Any(0)

    # High value for the slider range
    high = Any(1)

    # Low end of displayed range
    cur_low = Float

    # High end of displayed range
    cur_high = Float

    # Flag indicating that the UI is in the process of being updated
    ui_changing = Bool(False)

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        # Initialize using the factory range defaults:
        self.low = factory.low
        self.high = factory.high
        self.evaluate = factory.evaluate

        # Hook up the traits to listen to the object.
        self.sync_value( factory.low_name,  'low',  'from' )
        self.sync_value( factory.high_name, 'high', 'from' )
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        self.init_range()
        low  = self.cur_low
        high = self.cur_high

        self._set_format()

        self.control = QtGui.QWidget()
        panel = QtGui.QHBoxLayout(self.control)
        panel.setContentsMargins(0, 0, 0, 0)

        fvalue = self.value

        try:
            fvalue_text = self._format % fvalue
            1 / (low <= fvalue <= high)
        except:
            fvalue_text = ''
            fvalue      = low

        if high > low:
            ivalue = int( (float( fvalue - low ) / (high - low)) * 10000 )
        else:
            ivalue = low

        # Lower limit label:
        self.control.label_lo = label_lo = QtGui.QLabel()
        label_lo.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
        panel.addWidget(label_lo)

        # Lower limit button:
        self.control.button_lo = IconButton(QtGui.QStyle.SP_ArrowLeft,
                self.reduce_range)
        panel.addWidget(self.control.button_lo)

        # Slider:
        self.control.slider = slider = QtGui.QSlider(QtCore.Qt.Horizontal)
        slider.setTracking(factory.auto_set)
        slider.setMinimum(0)
        slider.setMaximum(10000)
        slider.setPageStep(1000)
        slider.setSingleStep(100)
        slider.setValue(ivalue)
        QtCore.QObject.connect(slider, QtCore.SIGNAL('valueChanged(int)'),
                self.update_object_on_scroll)
        panel.addWidget(slider)

        # Upper limit button:
        self.control.button_hi = IconButton(QtGui.QStyle.SP_ArrowRight,
                self.increase_range)
        panel.addWidget(self.control.button_hi)

        # Upper limit label:
        self.control.label_hi = label_hi = QtGui.QLabel()
        panel.addWidget(label_hi)

        # Text entry:
        self.control.text = text = QtGui.QLineEdit(fvalue_text)
        QtCore.QObject.connect(text, QtCore.SIGNAL('editingFinished()'),
                self.update_object_on_enter)

        # The default size is a bit too big and probably doesn't need to grow.
        sh = text.sizeHint()
        sh.setWidth(sh.width() / 2)
        text.setMaximumSize(sh)

        panel.addWidget(text)

        label_lo.setText(str(low))
        label_hi.setText(str(high))
        self.set_tooltip(slider)
        self.set_tooltip(label_lo)
        self.set_tooltip(label_hi)
        self.set_tooltip(text)

        # Update the ranges and button just in case.
        self.update_range_ui()

    #---------------------------------------------------------------------------
    #  Handles the user changing the current slider value:
    #---------------------------------------------------------------------------

    def update_object_on_scroll(self, pos):
        """ Handles the user changing the current slider value.
        """
        value = self.cur_low + ((float(pos) / 10000.0) * (self.cur_high - self.cur_low))

        self.control.text.setText(self._format % value)

        if self.factory.is_float:
            self.value = value
        else:
            self.value = int(value)

    #---------------------------------------------------------------------------
    #  Handle the user pressing the 'Enter' key in the edit control:
    #---------------------------------------------------------------------------

    def update_object_on_enter(self):
        """ Handles the user pressing the Enter key in the text field.
        """
        try:
            self.value = eval(unicode(self.control.text.text()).strip())
        except TraitError, excp:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        low   = self.low
        high  = self.high
        try:
            text = self._format % value
            1 / (low <= value <= high)
        except:
            value = low
        self.value = value

        if not self.ui_changing:
            self.init_range()
            self.update_range_ui()

    def update_range_ui ( self ):
        """ Updates the slider range controls.
        """
        low, high = self.cur_low, self.cur_high
        value = self.value
        self._set_format()
        self.control.label_lo.setText( self._format % low )
        self.control.label_hi.setText( self._format % high )

        if high > low:
            ivalue = int( (float( value - low ) / (high - low)) * 10000.0 )
        else:
            ivalue = low

        blocked = self.control.slider.blockSignals(True)
        self.control.slider.setValue( ivalue )
        self.control.slider.blockSignals(blocked)

        text = self._format % self.value
        self.control.text.setText( text )
        self.control.button_lo.setEnabled(low != self.low)
        self.control.button_hi.setEnabled(high != self.high)

    def init_range ( self ):
        """ Initializes the slider range controls.
        """
        value     = self.value
        low, high = self.low, self.high
        if (high is None) and (low is not None):
            high = -low

        mag = abs( value )
        if mag <= 10.0:
            cur_low  = max( value - 10, low )
            cur_high = min( value + 10, high )
        else:
            d        = 0.5 * (10**int( log10( mag ) + 1 ))
            cur_low  = max( low,  value - d )
            cur_high = min( high, value + d )

        self.cur_low, self.cur_high = cur_low, cur_high

    def reduce_range(self):
        """ Reduces the extent of the displayed range.
        """
        low, high = self.low, self.high
        if abs( self.cur_low ) < 10:
            self.cur_low  = max( -10, low )
            self.cur_high = min( 10, high )
        elif self.cur_low > 0:
            self.cur_high = self.cur_low
            self.cur_low  = max( low, self.cur_low / 10 )
        else:
            self.cur_high = self.cur_low
            self.cur_low  = max( low, self.cur_low * 10 )

        self.ui_changing = True
        self.value       = min( max( self.value, self.cur_low ), self.cur_high )
        self.ui_changing = False
        self.update_range_ui()

    def increase_range(self):
        """ Increased the extent of the displayed range.
        """
        low, high = self.low, self.high
        if abs( self.cur_high ) < 10:
            self.cur_low  = max( -10, low )
            self.cur_high = min(  10, high )
        elif self.cur_high > 0:
            self.cur_low  = self.cur_high
            self.cur_high = min( high, self.cur_high * 10 )
        else:
            self.cur_low  = self.cur_high
            self.cur_high = min( high, self.cur_high / 10 )

        self.ui_changing = True
        self.value       = min( max( self.value, self.cur_low ), self.cur_high )
        self.ui_changing = False
        self.update_range_ui()

    def _set_format ( self ):
        self._format = '%d'
        factory      = self.factory
        low, high    = self.cur_low, self.cur_high
        diff         = high - low
        if factory.is_float:
            if diff > 99999:
                self._format = '%.2g'
            elif diff > 1:
                self._format = '%%.%df' % max( 0, 4 -
                                                  int( log10( high - low ) ) )
            else:
                self._format = '%.3f'

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.control.text

    #---------------------------------------------------------------------------
    #  Handles the 'low'/'high' traits being changed:
    #---------------------------------------------------------------------------

    def _low_changed ( self, low ):
        if self.control is not None:
            if self.value < low:
                if self.factory.is_float:
                    self.value = float( low )
                else:
                    self.value = int( low )

            self.update_editor()

    def _high_changed ( self, high ):
        if self.control is not None:
            if self.value > high:
                if self.factory.is_float:
                    self.value = float( high )
                else:
                    self.value = int( high )

            self.update_editor()

#-------------------------------------------------------------------------------
#  'SimpleSpinEditor' class:
#-------------------------------------------------------------------------------

class SimpleSpinEditor ( BaseRangeEditor ):
    """ A simple style of range editor that displays a spin box control.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Low value for the slider range
    low = Any

    # High value for the slider range
    high = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if not factory.low_name:
            self.low = factory.low

        if not factory.high_name:
            self.high = factory.high

        self.sync_value( factory.low_name,  'low',  'from' )
        self.sync_value( factory.high_name, 'high', 'from' )
        low  = self.low
        high = self.high

        self.control = QtGui.QSpinBox()
        self.control.setMinimum(low)
        self.control.setMaximum(high)
        self.control.setValue(self.value)
        QtCore.QObject.connect(self.control,
                QtCore.SIGNAL('valueChanged(int)'), self.update_object)
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handle the user selecting a new value from the spin control:
    #---------------------------------------------------------------------------

    def update_object(self, value):
        """ Handles the user selecting a new value in the spin box.
        """
        self._locked = True
        try:
            self.value = value
        finally:
            self._locked = False

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if not self._locked:
            try:
                self.control.setValue(int(self.value))
            except:
                pass

    #---------------------------------------------------------------------------
    #  Handles the 'low'/'high' traits being changed:
    #---------------------------------------------------------------------------

    def _low_changed ( self, low ):
        if self.value < low:
            if self.factory.is_float:
                self.value = float( low )
            else:
                self.value = int( low )

        if self.control:
            self.control.setMinimum(low)
            self.control.setValue(int(self.value))

    def _high_changed ( self, high ):
        if self.value > high:
            if self.factory.is_float:
                self.value = float( high )
            else:
                self.value = int( high )

        if self.control:
            self.control.setMaximum(high)
            self.control.setValue(int(self.value))

#-------------------------------------------------------------------------------
#  'RangeTextEditor' class:
#-------------------------------------------------------------------------------

class RangeTextEditor ( TextEditor ):
    """ Editor for ranges that displays a text field. If the user enters a
    value that is outside the allowed range, the background of the field
    changes color to indicate an error.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function to evaluate floats/ints
    evaluate = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        TextEditor.init( self, parent )
        self.evaluate = self.factory.evaluate
        self.sync_value( self.factory.evaluate_name, 'evaluate', 'from' )

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object (self):
        """ Handles the user entering input data in the edit control.
        """
        try:
            value = eval(unicode(self.control.text()))
            if self.evaluate is not None:
                value = self.evaluate(value)
            self.value = value
            col = OKColor
        except:
            col = ErrorColor

        pal = QtGui.QPalette(self.control.palette())
        pal.setColor(QtGui.QPalette.Base, col)
        self.control.setPalette(pal)

#-------------------------------------------------------------------------------
#  'SimpleEnumEditor' factory adaptor:
#-------------------------------------------------------------------------------

def SimpleEnumEditor ( parent, factory, ui, object, name, description ):
    return CustomEnumEditor( parent, factory, ui, object, name, description,
                             'simple' )

#-------------------------------------------------------------------------------
#  'CustomEnumEditor' factory adaptor:
#-------------------------------------------------------------------------------

def CustomEnumEditor ( parent, factory, ui, object, name, description,
                       style = 'custom' ):
    """ Factory adapter that returns a enumeration editor of the specified
    style.
    """
    if factory._enum is None:
        import traitsui.editors.enum_editor as enum_editor
        factory._enum = enum_editor.ToolkitEditorFactory(
                            values = range( factory.low, factory.high + 1 ),
                            cols   = factory.cols )

    if style == 'simple':
        return factory._enum.simple_editor( ui, object, name, description,
                                            parent )

    return factory._enum.custom_editor( ui, object, name, description, parent )

#-------------------------------------------------------------------------------
#  Defines the mapping between editor factory 'mode's and Editor classes:
#-------------------------------------------------------------------------------

# Mapping between editor factory modes and simple editor classes
SimpleEditorMap = {
    'slider':  SimpleSliderEditor,
    'xslider': LargeRangeSliderEditor,
    'spinner': SimpleSpinEditor,
    'enum':    SimpleEnumEditor,
    'text':    RangeTextEditor,
    'logslider':     LogRangeSliderEditor
}
# Mapping between editor factory modes and custom editor classes
CustomEditorMap = {
    'slider':  SimpleSliderEditor,
    'xslider': LargeRangeSliderEditor,
    'spinner': SimpleSpinEditor,
    'enum':    CustomEnumEditor,
    'text':    RangeTextEditor,
    'logslider':     LogRangeSliderEditor
}

########NEW FILE########
__FILENAME__ = rgb_color_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines a subclass of the base PyQt color editor factory, for colors
that are represented as tuples of the form ( *red*, *green*, *blue* ), where
*red*, *green* and *blue* are floats in the range from 0.0 to 1.0.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtGui

from traits.trait_base \
    import SequenceTypes

# Note: The ToolkitEditorFactory class imported from color_editor is a
# subclass of the abstract ToolkitEditorFactory class
# (in traitsui.api) with qt4-specific methods defined.
# We need to override the implementations of the qt4-specific methods here.
from color_editor \
    import ToolkitEditorFactory as BaseColorToolkitEditorFactory

#-------------------------------------------------------------------------------
#  The PyQt4 ToolkitEditorFactory class.
#-------------------------------------------------------------------------------

class ToolkitEditorFactory(BaseColorToolkitEditorFactory):
    """ PyQt editor factory for color editors.
    """

    #---------------------------------------------------------------------------
    #  Gets the PyQt color equivalent of the object trait:
    #---------------------------------------------------------------------------

    def to_qt4_color ( self, editor ):
        """ Gets the PyQt color equivalent of the object trait.
        """
        try:
            color = getattr( editor.object, editor.name + '_' )
        except AttributeError:
            color = getattr( editor.object, editor.name )

        c = QtGui.QColor()
        c.setRgbF(color[0], color[1], color[2])

        return c

    #---------------------------------------------------------------------------
    #  Gets the application equivalent of a PyQt value:
    #---------------------------------------------------------------------------

    def from_qt4_color ( self, color ):
        """ Gets the application equivalent of a PyQt value.
        """
        return (color.redF(), color.greenF(), color.blueF())

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def str_color ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        if type( color ) in SequenceTypes:
            return "(%d,%d,%d)" % ( int( color[0] * 255.0 ),
                                    int( color[1] * 255.0 ),
                                    int( color[2] * 255.0 ) )
        return color

########NEW FILE########
__FILENAME__ = rgb_color_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

""" Trait definition for an RGB-based color, which is a tuple of the form
    (*red*, *green*, *blue*), where *red*, *green* and *blue* are floats in the
    range from 0.0 to 1.0.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api import Trait, TraitError
from traits.trait_base import SequenceTypes

from traitsui.qt4.color_trait import standard_colors

#-------------------------------------------------------------------------------
#  Convert a number into an RGB tuple:
#-------------------------------------------------------------------------------

def range_check(value):
    """ Checks that *value* can be converted to a value in the range 0.0 to 1.0.

        If so, it returns the floating point value; otherwise, it raises a
        TraitError.
    """
    value = float(value)
    if 0.0 <= value <= 1.0:
        return value
    raise TraitError

def convert_to_color(object, name, value):
    """ Converts a tuple or an integer to an RGB color value, or raises a
        TraitError if that is not possible.
    """
    if isinstance(value, SequenceTypes) and len(value) == 3:
        return (range_check(value[0]),
                range_check(value[1]),
                range_check(value[2]))
    if isinstance(value, int):
        return ((value / 0x10000)        / 255.0,
                ((value / 0x100) & 0xFF) / 255.0,
                (value & 0xFF)           / 255.0)
    raise TraitError

convert_to_color.info = ('a tuple of the form (r,g,b), where r, g, and b '
    'are floats in the range from 0.0 to 1.0, or an integer which in hex is of '
    'the form 0xRRGGBB, where RR is red, GG is green, and BB is blue')

#-------------------------------------------------------------------------------
#  Standard colors:
#-------------------------------------------------------------------------------

# RGB versions of standard colors:
rgb_standard_colors = {}
for name, color in standard_colors.items():
    rgb_standard_colors[name] = (color.redF(),
                                 color.greenF(),
                                 color.blueF())

#-------------------------------------------------------------------------------
#  Define wxPython specific color traits:
#-------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the RGBColorEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a RGBColor trait which lead to this file getting
# imported. This will lead to a circular import when declaring a RGBColor trait.
def get_rgb_color_editor(*args, **traits):
    from rgb_color_editor import ToolkitEditorFactory
    return ToolkitEditorFactory(*args, **traits)

# Trait whose value must be an RGB color:
RGBColor = Trait('white', convert_to_color, rgb_standard_colors,
                 editor=get_rgb_color_editor)



########NEW FILE########
__FILENAME__ = search_editor
#-------------------------------------------------------------------------------
#  Copyright (c) 20011, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#-------------------------------------------------------------------------------

# System library imports
from pyface.qt import QtCore, QtGui

# ETS imports
from editor import Editor


class SearchWidget(QtGui.QLineEdit):

    # FIXME: This widget needs a search button and a cancel button like the
    #        wxWidgets SearchControl.

    def __init__(self, desc):
        """ Store the descriptive text for the widget.
        """
        super(SearchWidget, self).__init__()
        self._desc = unicode(desc)
        self._set_descriptive_text()

    def focusInEvent(self, event):
        """ Handles accepting focus.

        If the text box contains the default description string, reset the text
        color and clear the box.
        """
        palette = QtGui.QApplication.instance().palette()
        self.setPalette(palette)

        if self.text() == self._desc:
            self.setText('')
            self.update()

        super(SearchWidget, self).focusInEvent(event)

    def focusOutEvent(self, event):
        """ Handles losing focus.

        When focus is lost, if the user had typed something, keep that text,
        otherwise replace it with the default description string.
        """
        if len(self.text()) == 0:
            self._set_descriptive_text()

        super(SearchWidget, self).focusOutEvent(event)

    def _set_descriptive_text(self):
        """ Sets the greyed-out descriptive text.
        """
        palette = QtGui.QApplication.instance().palette()
        palette.setColor(QtGui.QPalette.Text,
                         palette.color(QtGui.QPalette.Dark))
        self.setPalette(palette)
        self.setText(self._desc)
        self.update()


class SearchEditor(Editor):

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        if QtCore.__version_info__ < (4, 7, 0):
            control = self.control = SearchWidget(self.factory.text)
        else:
            control = self.control = QtGui.QLineEdit()
            control.setPlaceholderText(self.factory.text)

        if self.factory.auto_set:
            control.textEdited.connect(self.update_object)
        if self.factory.enter_set:
            control.editingFinished.connect(self.update_object)

    def update_object(self, event=None):
        """ Handles the user entering input data in the edit control.
        """
        if not self._no_update:
            self.value = str(self.control.text())
            if self.factory.search_event_trait != '':
                setattr(self.object, self.factory.search_event_trait, True)

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if str(self.control.text()) != self.value:
            self._no_update = True
            self.control.setText(self.str_value)
            self._no_update = False

########NEW FILE########
__FILENAME__ = set_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the set editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.set_editor file.
from traitsui.editors.set_editor \
    import ToolkitEditorFactory

from traitsui.helper \
    import enum_values_changed

from editor \
    import Editor

from traits.api \
    import Instance, Property

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for sets.

    The editor displays two list boxes, with buttons for moving the selected
    items from left to right, or vice versa. If **can_move_all** on the factory
    is True, then buttons are displayed for moving all the items to one box
    or the other. If the set is ordered, buttons are displayed for moving the
    selected item up or down in right-side list box.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The top level QLayout for the editor:
    root_layout = Instance(QtGui.QLayout)

    # Current set of enumeration names:
    names = Property

    # Current mapping from names to values:
    mapping = Property

    # Current inverse mapping from values to names:
    inverse_mapping = Property

    # Is set editor scrollable? This value overrides the default.
    scrollable = True

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QWidget()
        self.root_layout = QtGui.QGridLayout(self.control)
        self.root_layout.setContentsMargins(0, 0, 0, 0)

        factory = self.factory
        if factory.name != '':
            self._object, self._name, self._value = \
                self.parse_extended_name( factory.name )
            self.values_changed()
            self._object.on_trait_change( self._values_changed,
                                          self._name, dispatch = 'ui' )
        else:
            factory.on_trait_change( self.update_editor, 'values_modified',
                                     dispatch = 'ui' )

        blayout = QtGui.QVBoxLayout()

        self._unused = self._create_listbox(0, self._on_unused, self._on_use,
                factory.left_column_title)

        self._use_all = self._unuse_all = self._up = self._down = None

        if factory.can_move_all:
            self._use_all = self._create_button('>>', blayout,
                    self._on_use_all)

        self._use = self._create_button('>', blayout, self._on_use)
        self._unuse = self._create_button('<', blayout, self._on_unuse)

        if factory.can_move_all:
            self._unuse_all = self._create_button('<<', blayout,
                    self._on_unuse_all)

        if factory.ordered:
            self._up = self._create_button('Move Up', blayout, self._on_up)
            self._down = self._create_button('Move Down', blayout,
                    self._on_down)

        self.root_layout.addLayout(blayout, 1, 1, QtCore.Qt.AlignCenter)

        self._used = self._create_listbox(2, self._on_value, self._on_unuse,
                factory.right_column_title)

        self.context_object.on_trait_change( self.update_editor,
                               self.extended_name + '_items?', dispatch = 'ui' )

    #---------------------------------------------------------------------------
    #  Gets the current set of enumeration names:
    #---------------------------------------------------------------------------

    def _get_names ( self ):
        """ Gets the current set of enumeration names.
        """
        if self._object is None:
            return self.factory._names

        return self._names

    #---------------------------------------------------------------------------
    #  Gets the current mapping:
    #---------------------------------------------------------------------------

    def _get_mapping ( self ):
        """ Gets the current mapping.
        """
        if self._object is None:
            return self.factory._mapping

        return self._mapping

    #---------------------------------------------------------------------------
    #  Gets the current inverse mapping:
    #---------------------------------------------------------------------------

    def _get_inverse_mapping ( self ):
        """ Gets the current inverse mapping.
        """
        if self._object is None:
            return self.factory._inverse_mapping

        return self._inverse_mapping

    #---------------------------------------------------------------------------
    #  Creates a list box:
    #---------------------------------------------------------------------------

    def _create_listbox(self, col, handler1, handler2, title):
        """Creates a list box.
        """
        # Add the column title in emphasized text:
        title_widget = QtGui.QLabel(title)
        font = QtGui.QFont(title_widget.font())
        font.setBold(True)
        font.setPointSize(font.pointSize() + 1)
        title_widget.setFont(font)
        self.root_layout.addWidget(title_widget, 0, col, QtCore.Qt.AlignLeft)

        # Create the list box and add it to the column:
        list = QtGui.QListWidget()
        list.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        self.root_layout.addWidget(list, 1, col)

        list.connect(list,
                QtCore.SIGNAL('itemClicked(QListWidgetItem *)'), handler1)
        list.connect(list,
                QtCore.SIGNAL('itemDoubleClicked(QListWidgetItem *)'), handler2)

        return list

    #---------------------------------------------------------------------------
    #  Creates a button:
    #---------------------------------------------------------------------------

    def _create_button(self, label, layout, handler):
        """ Creates a button.
        """
        button = QtGui.QPushButton(label)
        button.connect(button, QtCore.SIGNAL('clicked()'), handler)
        layout.addWidget(button)
        return button

    #---------------------------------------------------------------------------
    #  Recomputes the cached data based on the underlying enumeration model:
    #---------------------------------------------------------------------------

    def values_changed ( self ):
        """ Recomputes the cached data based on the underlying enumeration model.
        """
        self._names, self._mapping, self._inverse_mapping = \
            enum_values_changed( self._value(), self.string_value )

    #---------------------------------------------------------------------------
    #  Handles the underlying object model's enumeration set being changed:
    #---------------------------------------------------------------------------

    def _values_changed ( self ):
        """ Handles the underlying object model's enumeration set being changed.
        """
        self.values_changed()
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Check for any items having been deleted from the enumeration that are
        # still present in the object value:
        mapping = self.inverse_mapping.copy()
        values  = [ v for v in self.value if v in mapping ]
        if len( values ) < len( self.value ):
            self.value = values

        # Get a list of the selected items in the right box:
        used        = self._used
        used_labels = self._get_selected_strings( used )

        # Get a list of the selected items in the left box:
        unused        = self._unused
        unused_labels = self._get_selected_strings( unused )

        # Empty list boxes in preparation for rebuilding from current values:
        used.clear()
        unused.clear()

        # Ensure right list box is kept alphabetized unless insertion
        # order is relevant:
        if not self.factory.ordered:
            values = values[:]
            values.sort()

        # Rebuild the right listbox:
        used_selections = []
        for i, value in enumerate( values ):
            label = mapping[ value ]
            used.addItem(label)
            del mapping[ value ]
            if label in used_labels:
                used_selections.append(i)

        # Rebuild the left listbox:
        unused_selections = []
        unused_items      = mapping.values()
        unused_items.sort()
        mapping            = self.mapping
        self._unused_items = [ mapping[ ui ] for ui in unused_items ]
        for i, unused_item in enumerate( unused_items ):
            unused.addItem(unused_item)
            if unused_item in unused_labels:
                unused_selections.append( i )

        # If nothing is selected, default selection should be top of left box,
        # or of right box if left box is empty:
        if (len( used_selections ) == 0) and (len( unused_selections ) == 0):
            if unused.count() == 0:
                used_selections.append(0)
            else:
                unused_selections.append(0)

        used_count = used.count()
        for i in used_selections:
            if i < used_count:
                used.item(i).setSelected(True)

        unused_count = unused.count()
        for i in unused_selections:
            if i < unused_count:
                unused.item(i).setSelected(True)

        self._check_up_down()
        self._check_left_right()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self._object is not None:
            self._object.on_trait_change( self._values_changed,
                                          self._name, remove = True )
        else:
            self.factory.on_trait_change( self.update_editor,
                                          'values_modified', remove = True )

        self.context_object.on_trait_change( self.update_editor,
                                 self.extended_name + '_items?', remove = True )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return [ self._unused, self._used ]

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def _on_value(self):
        if not self.factory.ordered:
            self._unused.clearSelection()
        self._check_left_right()
        self._check_up_down()

    def _on_unused(self):
        if not self.factory.ordered:
            self._used.clearSelection()
        self._check_left_right()
        self._check_up_down()

    def _on_use(self):
        self._unused_items, self.value = self._transfer_items( self._unused,
                                    self._used, self._unused_items, self.value )

    def _on_unuse(self):
        self.value, self._unused_items = self._transfer_items( self._used,
                                  self._unused, self.value, self._unused_items )

    def _on_use_all(self):
        self._unused_items, self.value = self._transfer_all( self._unused,
                                    self._used, self._unused_items, self.value )

    def _on_unuse_all(self):
        self.value, self._unused_items = self._transfer_all( self._used,
                                 self._unused, self.value, self._unused_items )

    def _on_up(self):
        self._move_item(-1)

    def _on_down(self):
        self._move_item(1)

    #---------------------------------------------------------------------------
    #  Private methods:
    #---------------------------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Transfers all items from one list to another:
    #---------------------------------------------------------------------------

    def _transfer_all ( self, list_from, list_to, values_from, values_to ):
        """ Transfers all items from one list to another.
        """
        values_from = values_from[:]
        values_to   = values_to[:]

        list_from.clearSelection()
        while list_from.count() > 0:
            index_to = list_to.count()
            list_from.item(0).setSelected(True)
            list_to.insertItems(index_to, self._get_selected_strings(list_from))
            list_from.takeItem(0)
            values_to.append(values_from[0])
            del values_from[0]

        list_to.item(0).setSelected(True)
        self._check_left_right()
        self._check_up_down()

        return ( values_from, values_to )

    #---------------------------------------------------------------------------
    #  Transfers the selected item from one list to another:
    #---------------------------------------------------------------------------

    def _transfer_items ( self, list_from, list_to, values_from, values_to ):
        """ Transfers the selected item from one list to another.
        """
        values_from  = values_from[:]
        values_to    = values_to[:]
        index_from   = max( self._get_first_selection( list_from ), 0 )
        index_to     = max( self._get_first_selection( list_to ),   0 )

        list_to.clearSelection()

        # Get the list of strings in the "from" box to be moved:
        selected_list = self._get_selected_strings( list_from )

        # fixme: I don't know why I have to reverse the list to get
        # correct behavior from the ordered list box.  Investigate -- LP
        selected_list.reverse()
        list_to.insertItems(index_to, selected_list)

        # Delete the transferred items from the left box:
        items_from = list_from.selectedItems()
        for i in range(len(items_from) - 1, -1, -1):
            list_from.takeItem(list_from.row(items_from[i]))
        del items_from

        # Delete the transferred items from the "unused" value list:
        for item_label in selected_list:
            val_index_from = values_from.index( self.mapping[ item_label ] )
            values_to.insert( index_to, values_from[ val_index_from ] )
            del values_from[ val_index_from ]

            # If right list is ordered, keep moved items selected:
            if self.factory.ordered:
                items = list_to.findItems(item_label,
                        QtCore.Qt.MatchFixedString|QtCore.Qt.MatchCaseSensitive)
                if items:
                    items[0].setSelected(True)

        # Reset the selection in the left box:
        count = list_from.count()
        if count > 0:
            if index_from >= count:
                index_from = count - 1
            list_from.item(index_from).setSelected(True)

        self._check_left_right()
        self._check_up_down()

        return ( values_from, values_to )

    #---------------------------------------------------------------------------
    #  Moves an item up or down with the 'used' list:
    #---------------------------------------------------------------------------

    def _move_item ( self, direction ):
        """ Moves an item up or down within the "used" list.
        """
        # Move the item up/down within the list:
        listbox    = self._used
        index_from = self._get_first_selection(listbox)
        index_to   = index_from + direction
        label = listbox.takeItem(index_from).text()
        listbox.insertItem(index_to, label)
        listbox.item(index_to).setSelected(True)

        # Enable the up/down buttons appropriately:
        self._check_up_down()

        # Move the item up/down within the editor's trait value:
        value = self.value
        if direction < 0:
            index  = index_to
            values = [ value[ index_from ], value[ index_to ] ]
        else:
            index  = index_from
            values = [ value[ index_to ], value[ index_from ] ]
        self.value = value[ : index ] + values + value[ index + 2: ]
    #---------------------------------------------------------------------------
    #  Sets the proper enable state for the up and down buttons:
    #---------------------------------------------------------------------------

    def _check_up_down ( self ):
        """ Sets the proper enabled state for the up and down buttons.
        """
        if self.factory.ordered:
            selected = self._used.selectedItems()
            self._up.setEnabled(len(selected) == 1 and
                    selected[0] is not self._used.item(0))
            self._down.setEnabled(len(selected) == 1 and
                    selected[0] is not self._used.item(self._used.count() - 1))

    #---------------------------------------------------------------------------
    #  Sets the proper enable state for the left and right buttons:
    #---------------------------------------------------------------------------

    def _check_left_right(self):
        """ Sets the proper enabled state for the left and right buttons.
        """
        self._use.setEnabled(self._unused.count() > 0 and
                self._get_first_selection(self._unused) >= 0)
        self._unuse.setEnabled(self._used.count() > 0 and
                self._get_first_selection(self._used) >= 0)

        if self.factory.can_move_all:
            self._use_all.setEnabled(self._unused.count() > 0 and
                    self._get_first_selection(self._unused) >= 0)
            self._unuse_all.setEnabled(self._used.count() > 0 and
                    self._get_first_selection(self._used) >= 0)

    #---------------------------------------------------------------------------
    # Returns a list of the selected strings in the listbox
    #---------------------------------------------------------------------------

    def _get_selected_strings(self, listbox):
        """ Returns a list of the selected strings in the given *listbox*.
        """
        return [unicode(itm.text()) for itm in listbox.selectedItems()]

    #---------------------------------------------------------------------------
    # Returns the index of the first (or only) selected item.
    #---------------------------------------------------------------------------

    def _get_first_selection ( self, listbox ):
        """ Returns the index of the first (or only) selected item.
        """
        select_list = listbox.selectedItems()
        if len(select_list) == 0:
            return -1

        return listbox.row(select_list[0])

########NEW FILE########
__FILENAME__ = shell_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#-------------------------------------------------------------------------------

""" Editor that displays an interactive Python shell.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.shell_editor file.
from traitsui.editors.shell_editor import \
    _ShellEditor as BaseShellEditor

from editor import Editor

#-------------------------------------------------------------------------------
#  'ShellEditor' class:
#-------------------------------------------------------------------------------

class _ShellEditor(BaseShellEditor, Editor):
    """ Editor that displays an interactive Python shell.
    """

    def init(self, parent):
        super(_ShellEditor, self).init(None)

########NEW FILE########
__FILENAME__ = styled_date_editor

from pyface.qt import QtCore, QtGui
from pyface.qt.QtGui import QFont

from traits.api import Dict

# For a simple editor style, we just punt and use the same simple editor
# as in the default date_editor.
from date_editor import SimpleEditor
from date_editor import CustomEditor as DateCustomEditor


class CustomEditor(DateCustomEditor):

    dates = Dict()

    styles = Dict()

    def init(self, parent):
        self.control = QtGui.QCalendarWidget()

        if not self.factory.allow_future:
            self.control.setMaximumDate(QtCore.QDate.currentDate())

        if not self.factory.allow_past:
            self.control.setMinimumDate(QtCore.QDate.currentDate())

        if self.factory.dates_trait and self.factory.styles_trait:
            self.sync_value(self.factory.dates_trait, "dates", "from")
            self.sync_value(self.factory.styles_trait, "styles", "from")

        self.control.clicked.connect(self.update_object)

        return

    def _dates_changed(self, old, new):
        # Someone changed out the entire dict.  The easiest, most robust
        # way to handle this is to reset the text formats of all the dates
        # in the old dict, and then set the dates in the new dict.
        if old:
            [map(self._reset_formatting, dates) for dates in old.values()]
        if new:
            styles = getattr(self.object, self.factory.styles_trait, None)
            self._apply_styles(styles, new)

    def _dates_items_changed(self, event):
        # Handle the added and changed items
        groups_to_set = event.added
        groups_to_set.update(event.changed)
        styles = getattr(self.object, self.factory.styles_trait, None)
        self._apply_styles(styles, groups_to_set)

        # Handle the removed items by resetting them
        [map(self._reset_formatting, dates) for dates in event.removed.values()]

    def _styles_changed(self, old, new):
        groups = getattr(self.object, self.factory.dates_trait, {})
        if not new:
            # If no new styles, then reset all the dates to a default style
            [map(self._reset_formatting, dates) for dates in groups.values()]
        else:
            self._apply_styles(new, groups)
        return

    def _styles_items_changed(self, event):
        groups = getattr(self.object, self.factory.dates_trait)
        styles = getattr(self.object, self.factory.styles_trait)

        names_to_update = event.added.keys() + event.changed.keys()
        modified_groups = dict((name, groups[name]) for name in names_to_update)
        self._apply_styles(styles, modified_groups)

        names_to_reset = event.removed.keys()
        for name in names_to_reset:
            self._reset_formatting(groups[name])
        return

    #------------------------------------------------------------------------
    # Helper functions
    #------------------------------------------------------------------------

    def _apply_style(self, style, dates):
        """ **style** is a CellFormat, **dates** is a list of datetime.date """
        for dt in dates:
            qdt = QtCore.QDate(dt)
            textformat = self.control.dateTextFormat(qdt)
            self._apply_cellformat(style, textformat)
            self.control.setDateTextFormat(qdt, textformat)
        return

    def _apply_styles(self, style_dict, date_dict):
        """ Applies the proper style out of style_dict to every (name,date_list)
        in date_dict.
        """
        if not style_dict or not date_dict:
            return
        for groupname, dates in date_dict.items():
            cellformat = style_dict.get(groupname, None)
            if not cellformat:
                continue
            for dt in dates:
                qdt = QtCore.QDate(dt)
                textformat = self.control.dateTextFormat(qdt)
                self._apply_cellformat(cellformat, textformat)
                self.control.setDateTextFormat(qdt, textformat)
        return

    def _reset_formatting(self, dates):
        # Resets the text format on the given dates
        for dt in dates:
            qdt = QtCore.QDate(dt)
            self.control.setDateTextFormat(qdt, QtGui.QTextCharFormat())

    def _apply_cellformat(self, cf, textformat):
        """ Applies the formatting in the cellformat cf to the QTextCharFormat
        object provided.
        """
        if cf.italics is not None:
            textformat.setFontItalic(cf.italics)

        if cf.underline is not None:
            textformat.setFontUnderline(cf.underline)

        if cf.bold is not None:
            if cf.bold:
                weight = QFont.Bold
            else:
                weight = QFont.Normal
            textformat.setFontWeight(weight)

        if cf.bgcolor is not None:
            textformat.setBackground(self._color_to_brush(cf.bgcolor))

        if cf.fgcolor is not None:
            textformat.setForeground(self._color_to_brush(cf.fgcolor))

        return

    def _color_to_brush(self, color):
        """ Returns a QBrush with the color specified in **color** """
        brush = QtGui.QBrush()
        if isinstance(color, basestring) and hasattr(QtCore.Qt, color):
            col = getattr(QtCore.Qt, color)
        elif isinstance(color, tuple) and len(color) == 3:
            col = QtGui.QColor()
            col.setRgb(*color)
        else:
            raise RuntimeError("Invalid color specification '%r'" % color)

        brush.setColor(col)
        return brush


########NEW FILE########
__FILENAME__ = table_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described
# in the PyQt GPL exception also apply.
#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the table editor for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from pyface.image_resource import ImageResource

from pyface.timer.api import do_later

from traits.api import Any, Bool, Button, Event, List, HasTraits, \
    Instance, Int, Property, Str, cached_property, on_trait_change

from traitsui.api import EnumEditor, InstanceEditor, Group, \
    Handler, Item, Label, TableColumn, TableFilter, UI, View, default_handler, \
    spring
from traitsui.editors.table_editor import BaseTableEditor, \
    ReversedList, ToolkitEditorFactory, customize_filter
from traitsui.ui_traits import SequenceTypes, Image

from editor import Editor
from table_model import TableModel, SortFilterTableModel

#-------------------------------------------------------------------------------
#  'TableEditor' class:
#-------------------------------------------------------------------------------

class TableEditor(Editor, BaseTableEditor):
    """ Editor that presents data in a table. Optionally, tables can have
        a set of filters that reduce the set of data displayed, according to
        their criteria.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The table view control associated with the editor:
    table_view = Any
    def _table_view_default(self):
        return TableView(editor=self)

    # A wrapper around the source model which provides filtering and sorting:
    model = Instance(SortFilterTableModel)
    def _model_default(self):
        return SortFilterTableModel(editor=self)

    # The table model associated with the editor:
    source_model = Instance(TableModel)
    def _source_model_default(self):
        return TableModel(editor=self)

    # The set of columns currently defined on the editor:
    columns = List(TableColumn)

    # The currently selected row(s), column(s), or cell(s).
    selected = Any

    # The current selected row
    selected_row = Property(Any, depends_on='selected')

    selected_indices = Property(Any, depends_on='selected')

    # Current filter object (should be a TableFilter or callable or None):
    filter = Any

    # The indices of the table items currently passing the table filter:
    filtered_indices = List(Int)

    # Current filter summary message
    filter_summary = Str('All items')

    # Update the filtered contents.
    update_filter = Event()

    # The event fired when a cell is clicked on:
    click = Event

    # The event fired when a cell is double-clicked on:
    dclick = Event

    # The Traits UI associated with the table editor toolbar:
    toolbar_ui = Instance(UI)

    # The context menu associated with empty space in the table
    empty_menu = Instance(QtGui.QMenu)

    # The context menu associated with the vertical header
    header_menu = Instance(QtGui.QMenu)

    # The context menu actions for moving rows up and down
    header_menu_up = Instance(QtGui.QAction)
    header_menu_down = Instance(QtGui.QAction)

    # The index of the row that was last right clicked on its vertical header
    header_row = Int

    # Whether to auto-size the columns or not.
    auto_size = Bool(False)

    # Dictionary mapping image names to QIcons
    images = Any({})

    # Dictionary mapping ImageResource objects to QIcons
    image_resources = Any({})

    # An image being converted:
    image = Image

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init(self, parent):
        """Finishes initializing the editor by creating the underlying toolkit
        widget."""

        factory = self.factory
        self.columns = factory.columns[:]
        if factory.table_view_factory is not None:
            self.table_view = factory.table_view_factory(editor=self)
        if factory.source_model_factory is not None:
            self.source_model = factory.source_model_factory(editor=self)
        if factory.model_factory is not None:
            self.model = factory.model_factory(editor=self)

        # Create the table view and model
        self.model.setDynamicSortFilter(True)
        self.model.setSourceModel(self.source_model)
        self.table_view.setModel(self.model)

        # Create the vertical header context menu and connect to its signals
        self.header_menu = QtGui.QMenu(self.table_view)
        signal = QtCore.SIGNAL('triggered()')
        insertable = factory.row_factory is not None and not factory.auto_add
        if factory.editable:
            if insertable:
                action = self.header_menu.addAction('Insert new item')
                QtCore.QObject.connect(action, signal, self._on_context_insert)
            if factory.deletable:
                action = self.header_menu.addAction('Delete item')
                QtCore.QObject.connect(action, signal, self._on_context_remove)
        if factory.reorderable:
            if factory.editable and (insertable or factory.deletable):
                self.header_menu.addSeparator()
            self.header_menu_up = self.header_menu.addAction('Move item up')
            QtCore.QObject.connect(self.header_menu_up, signal,
                                   self._on_context_move_up)
            self.header_menu_down = self.header_menu.addAction('Move item down')
            QtCore.QObject.connect(self.header_menu_down, signal,
                                   self._on_context_move_down)

        # Create the empty space context menu and connect its signals
        self.empty_menu = QtGui.QMenu(self.table_view)
        action = self.empty_menu.addAction('Add new item')
        QtCore.QObject.connect(action, signal, self._on_context_append)

        # When sorting is enabled, the first column is initially displayed with
        # the triangle indicating it is the sort index, even though no sorting
        # has actually been done. Sort here for UI/model consistency.
        if self.factory.sortable and not self.factory.reorderable:
            self.model.sort(0, QtCore.Qt.AscendingOrder)

        # Connect to the mode specific selection handler and select the first
        # row/column/cell. Do this before creating the edit_view to make sure
        # that it has a valid item to use when constructing its view.
        smodel = self.table_view.selectionModel()
        signal = QtCore.SIGNAL('selectionChanged(QItemSelection, QItemSelection)')
        mode_slot = getattr(self, '_on_%s_selection' % factory.selection_mode)
        QtCore.QObject.connect(smodel, signal, mode_slot)
        self.table_view.setCurrentIndex(self.model.index(0, 0))

        # Create the toolbar if necessary
        if factory.show_toolbar and len(factory.filters) > 0:
            main_view = QtGui.QWidget()
            layout = QtGui.QVBoxLayout(main_view)
            layout.setContentsMargins(0, 0, 0, 0)
            self.toolbar_ui = self.edit_traits(
                parent = parent,
                kind = 'subpanel',
                view = View(Group(Item('filter{View}',
                                       editor = factory._filter_editor ),
                                  Item('filter_summary{Results}',
                                       style = 'readonly'),
                                  spring,
                                  orientation='horizontal'),
                            resizable = True))
            self.toolbar_ui.parent = self.ui
            layout.addWidget(self.toolbar_ui.control)
            layout.addWidget(self.table_view)
        else:
            main_view = self.table_view

        # Create auxillary editor and encompassing splitter if necessary
        mode = factory.selection_mode
        if (factory.edit_view == ' ') or not mode in ('row', 'rows'):
            self.control = main_view
        else:
            self.control = QtGui.QSplitter(QtCore.Qt.Vertical)
            self.control.setSizePolicy(QtGui.QSizePolicy.Expanding,
                                       QtGui.QSizePolicy.Expanding)
            self.control.addWidget(main_view)
            self.control.setStretchFactor(0, 2)

            # Create the row editor below the table view
            editor = InstanceEditor(view=factory.edit_view, kind='subpanel')
            self._ui = self.edit_traits(
                parent = self.control,
                kind = 'subpanel',
                view = View(Item('selected_row',
                                 style = 'custom',
                                 editor = editor,
                                 show_label = False,
                                 resizable = True,
                                 width = factory.edit_view_width,
                                 height = factory.edit_view_height),
                            resizable = True,
                            handler = factory.edit_view_handler))
            self._ui.parent = self.ui
            self.control.addWidget(self._ui.control)
            self.control.setStretchFactor(1, 1)

        # Connect to the click and double click handlers
        signal = QtCore.SIGNAL('clicked(QModelIndex)')
        QtCore.QObject.connect(self.table_view, signal, self._on_click)
        signal = QtCore.SIGNAL('doubleClicked(QModelIndex)')
        QtCore.QObject.connect(self.table_view, signal, self._on_dclick)

        # Make sure we listen for 'items' changes as well as complete list
        # replacements
        self.context_object.on_trait_change(
            self.update_editor, self.extended_name + '_items', dispatch='ui')

        # Listen for changes to traits on the objects in the list
        self.context_object.on_trait_change(
            self.refresh_editor, self.extended_name + '.-', dispatch='ui')

        # Listen for changes on column definitions
        self.on_trait_change(self._update_columns, 'columns', dispatch='ui')
        self.on_trait_change(self._update_columns, 'columns_items',
                             dispatch='ui')

        # Set up the required externally synchronized traits
        is_list = (mode in ('rows', 'columns', 'cells'))
        self.sync_value(factory.click, 'click', 'to')
        self.sync_value(factory.dclick, 'dclick', 'to')
        self.sync_value(factory.columns_name, 'columns', is_list=True)
        self.sync_value(factory.selected, 'selected', is_list=is_list)
        self.sync_value(factory.selected_indices, 'selected_indices', is_list=is_list)
        self.sync_value(factory.filter_name, 'filter', 'from')
        self.sync_value(factory.filtered_indices, 'filtered_indices', 'to')
        self.sync_value(factory.update_filter_name, 'update_filter', 'from')

        self.auto_size = self.factory.auto_size

        # Initialize the ItemDelegates for each column
        self._update_columns()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose(self):
        """ Disposes of the contents of an editor."""

        # Disconnect the table view from its model to ensure that they do not
        # continue to interact (the control won't be deleted until later).
        self.table_view.setModel(None)

        # Make sure that the auxillary UIs are properly disposed
        if self.toolbar_ui is not None:
            self.toolbar_ui.dispose()
        if self._ui is not None:
            self._ui.dispose()

        # Remove listener for 'items' changes on object trait
        self.context_object.on_trait_change(
            self.update_editor, self.extended_name + '_items', remove=True)

        # Remove listener for changes to traits on the objects in the list
        self.context_object.on_trait_change(
            self.refresh_editor, self.extended_name + '.-', remove=True)

        # Remove listeners for column definition changes
        self.on_trait_change(self._update_columns, 'columns', remove=True)
        self.on_trait_change(self._update_columns, 'columns_items', remove=True)


        super(TableEditor, self).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor(self):
        """Updates the editor when the object trait changes externally to the
        editor."""

        if self._no_notify:
            return

        self.table_view.setUpdatesEnabled(False)
        try:
            filtering = len(self.factory.filters) > 0 or self.filter is not None
            if filtering:
                self._update_filtering()

            # invalidate the model, but do not reset it. Resetting the model
            # may cause problems if the selection sync'ed traits are being used
            # externally to manage the selections
            self.model.invalidate()

            self.table_view.resizeColumnsToContents()
            if self.auto_size:
                self.table_view.resizeRowsToContents()

        finally:
            self.table_view.setUpdatesEnabled(True)

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        header = self.table_view.horizontalHeader()
        if header is not None and 'column_state' in prefs:
            header.restoreState(prefs['column_state'])

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        prefs = {}
        header = self.table_view.horizontalHeader()
        if header is not None:
            prefs['column_state'] = str(header.saveState())
        return prefs

    #---------------------------------------------------------------------------
    #  Requests that the underlying table widget to redraw itself:
    #---------------------------------------------------------------------------

    def refresh_editor(self):
        """Requests that the underlying table widget to redraw itself."""

        self.table_view.viewport().update()

    #---------------------------------------------------------------------------
    #  Creates a new row object using the provided factory:
    #---------------------------------------------------------------------------

    def create_new_row(self):
        """Creates a new row object using the provided factory."""

        factory = self.factory
        kw = factory.row_factory_kw.copy()
        if '__table_editor__' in kw:
            kw[ '__table_editor__' ] = self

        return self.ui.evaluate(factory.row_factory,
                                *factory.row_factory_args, **kw)

    #---------------------------------------------------------------------------
    #  Returns the raw list of model objects:
    #---------------------------------------------------------------------------

    def items(self):
        """Returns the raw list of model objects."""

        items = self.value
        if not isinstance(items, SequenceTypes):
            items = [ items ]

        if self.factory.reverse:
            items = ReversedList(items)

        return items

    #---------------------------------------------------------------------------
    #  Perform actions without notifying the underlying table view or model:
    #---------------------------------------------------------------------------

    def callx(self, func, *args, **kw):
        """Call a function without notifying the underlying table view or
        model."""

        old = self._no_notify
        self._no_notify = True
        try:
            func(*args, **kw)
        finally:
            self._no_notify = old

    def setx(self, **keywords):
        """Set one or more attributes without notifying the underlying table
        view or model."""

        old = self._no_notify
        self._no_notify = True
        try:
            for name, value in keywords.items():
                setattr(self, name, value)
        finally:
            self._no_notify = old

    #---------------------------------------------------------------------------
    #  Sets the current selection to a set of specified objects:
    #---------------------------------------------------------------------------

    def set_selection(self, objects=[], notify=True):
        """Sets the current selection to a set of specified objects."""

        if not isinstance(objects, SequenceTypes):
            objects = [ objects ]

        mode = self.factory.selection_mode
        indexes = []
        flags = QtGui.QItemSelectionModel.ClearAndSelect

        # In the case of row or column selection, we need a dummy value for the
        # other dimension that has not been filtered.
        source_index = self.model.mapToSource(self.model.index(0, 0))
        source_row, source_column = source_index.row(), source_index.column()

        # Selection mode is 'row' or 'rows'
        if mode.startswith('row'):
            flags |= QtGui.QItemSelectionModel.Rows
            items = self.items()
            for obj in objects:
                try:
                    row = items.index(obj)
                except ValueError:
                    continue
                indexes.append(self.source_model.index(row, source_column))

        # Selection mode is 'column' or 'columns'
        elif mode.startswith('column'):
            flags |= QtGui.QItemSelectionModel.Columns
            for name in objects:
                column = self._column_index_from_name(name)
                if column != -1:
                    indexes.append(self.source_model.index(source_row, column))

        # Selection mode is 'cell' or 'cells'
        else:
            items = self.items()
            for obj, name in objects:
                try:
                    row = items.index(obj)
                except ValueError:
                    continue
                column = self._column_index_from_name(name)
                if column != -1:
                    indexes.append(self.source_model.index(row, column))

        # Perform the selection so that only one signal is emitted
        selection = QtGui.QItemSelection()
        for index in indexes:
            index = self.model.mapFromSource(index)
            if index.isValid():
                self.table_view.setCurrentIndex(index)
                selection.select(index, index)
        smodel = self.table_view.selectionModel()
        try:
            smodel.blockSignals(not notify)
            if len(selection.indexes()):
                smodel.select(selection, flags)
            else:
                smodel.clear()
        finally:
            smodel.blockSignals(False)

    #---------------------------------------------------------------------------
    #  Private methods:
    #---------------------------------------------------------------------------

    def _column_index_from_name(self, name):
        """Returns the index of the column with the given name or -1 if no
        column exists with that name."""

        for i, column in enumerate(self.columns):
            if name == column.name:
                return i
        return -1

    def _customize_filters(self, filter):
        """Allows the user to customize the current set of table filters."""

        filter_editor = TableFilterEditor(editor=self)
        ui = filter_editor.edit_traits(parent=self.control)
        if ui.result:
            self.factory.filters = filter_editor.templates
            self.filter = filter_editor.selected_filter
        else:
            self.setx(filter = filter)

    def _update_filtering(self):
        """Update the filter summary and the filtered indices."""

        items = self.items()
        num_items = len(items)

        f = self.filter
        if f is None:
            self._filtered_cache = None
            self.filtered_indices = range(num_items)
            self.filter_summary = 'All %i items' % num_items
        else:
            if not callable(f):
                f = f.filter
            self._filtered_cache = fc = [ f(item) for item in items ]
            self.filtered_indices = fi = [ i for i, ok in enumerate(fc) if ok ]
            self.filter_summary = '%i of %i items' % (len(fi), num_items)

    def _add_image(self, image_resource):
        """ Adds a new image to the image map.
        """
        image = image_resource.create_icon()

        self.image_resources[image_resource] = image
        self.images[image_resource.name] = image

        return image

    def _get_image(self, image):
        """ Converts a user specified image to a QIcon.
        """
        if isinstance(image, basestring):
            self.image = image
            image = self.image

        if isinstance(image, ImageResource):
            result = self.image_resources.get(image)
            if result is not None:
                return result
            return self._add_image(image)

        return self.images.get(image)

    #-- Trait Property getters/setters -----------------------------------------

    @cached_property
    def _get_selected_row(self):
        """Gets the selected row, or the first row if multiple rows are
        selected."""

        mode = self.factory.selection_mode

        if mode.startswith('column'):
            return None
        elif mode == 'row':
            return self.selected

        try:
            if mode == 'rows':
                return self.selected[0]
            elif mode == 'cell':
                return self.selected[0]
            elif mode == 'cells':
                return self.selected[0][0]
        except IndexError:
            return None

    @cached_property
    def _get_selected_indices(self):
        """Gets the row,column indices which match the selected trait"""

        if len(self.selected) == 0:
            return []

        selection_items = self.table_view.selectionModel().selection()
        indices = self.model.mapSelectionFromSource(selection_items).indexes()
        return [(index.row(), index.column()) for index in indices]


    def _set_selected_indices(self, indices):
        selected = []
        for row, col in indices:
            selected.append((self.value[row], self.columns[col].name))

        self.selected = selected
        self.set_selection(self.selected, False)
        return

    #-- Trait Change Handlers --------------------------------------------------

    def _filter_changed(self, old_filter, new_filter):
        """Handles the current filter being changed."""

        if not self._no_notify:
            if new_filter is customize_filter:
                do_later(self._customize_filters, old_filter)
            else:
                self._update_filtering()
                self.model.invalidate()
                self.set_selection(self.selected)

    def _update_columns(self):
        """Handle the column list being changed."""

        self.table_view.setItemDelegate(TableDelegate(self.table_view))
        for i, column in enumerate(self.columns):
            if column.renderer:
                self.table_view.setItemDelegateForColumn(i, column.renderer)

        self.model.reset()
        self.table_view.resizeColumnsToContents()
        if self.auto_size:
            self.table_view.resizeRowsToContents()

    def _selected_changed(self, new):
        """Handle the selected row/column/cell being changed externally."""
        if not self._no_notify:
            self.set_selection(self.selected, notify=False)

    def _update_filter_changed(self):
        """ The filter has changed internally.
        """
        self._filter_changed(self.filter, self.filter)

    #-- Event Handlers ---------------------------------------------------------

    def _on_row_selection(self, added, removed):
        """Handle the row selection being changed."""

        items = self.items()
        indexes = self.table_view.selectionModel().selectedRows()
        if len(indexes):
            index = self.model.mapToSource(indexes[0])
            selected = items[index.row()]
        else:
            selected = None

        self.setx(selected = selected)
        self.ui.evaluate(self.factory.on_select, self.selected)

    def _on_rows_selection(self, added, removed):
        """Handle the rows selection being changed."""

        items = self.items()
        indexes = self.table_view.selectionModel().selectedRows()
        selected = [ items[self.model.mapToSource(index).row()]
                     for index in indexes ]

        self.setx(selected = selected)
        self.ui.evaluate(self.factory.on_select, self.selected)

    def _on_column_selection(self, added, removed):
        """Handle the column selection being changed."""

        indexes = self.table_view.selectionModel().selectedColumns()
        if len(indexes):
            index = self.model.mapToSource(indexes[0])
            selected = self.columns[index.column()].name
        else:
            selected = ''

        self.setx(selected = selected)
        self.ui.evaluate(self.factory.on_select, self.selected)

    def _on_columns_selection(self, added, removed):
        """Handle the columns selection being changed."""

        indexes = self.table_view.selectionModel().selectedColumns()
        selected = [ self.columns[self.model.mapToSource(index).column()].name
                     for index in indexes ]

        self.setx(selected = selected)
        self.ui.evaluate(self.factory.on_select, self.selected)

    def _on_cell_selection(self, added, removed):
        """Handle the cell selection being changed."""

        items = self.items()
        indexes = self.table_view.selectionModel().selectedIndexes()
        if len(indexes):
            index = self.model.mapToSource(indexes[0])
            obj = items[index.row()]
            column_name = self.columns[index.column()].name
        else:
            obj = None
            column_name = ''
        selected = (obj, column_name)

        self.setx(selected = selected)
        self.ui.evaluate(self.factory.on_select, self.selected)

    def _on_cells_selection(self, added, removed):
        """Handle the cells selection being changed."""

        items = self.items()
        indexes = self.table_view.selectionModel().selectedIndexes()
        selected = []
        for index in indexes:
            index = self.model.mapToSource(index)
            obj = items[index.row()]
            column_name = self.columns[index.column()].name
            selected.append((obj, column_name))

        self.setx(selected = selected)
        self.ui.evaluate(self.factory.on_select, self.selected)

    def _on_click(self, index):
        """Handle a cell being clicked."""

        index = self.model.mapToSource(index)
        column = self.columns[index.column()]
        obj = self.items()[index.row()]

        # Fire the same event on the editor after mapping it to a model object
        # and column name:
        self.click = (obj, column)

        # Invoke the column's click handler:
        column.on_click(obj)

    def _on_dclick(self, index):
        """Handle a cell being double clicked."""

        index = self.model.mapToSource(index)
        column = self.columns[index.column()]
        obj = self.items()[index.row()]

        # Fire the same event on the editor after mapping it to a model object
        # and column name:
        self.dclick = (obj, column)

        # Invoke the column's double-click handler:
        column.on_dclick(obj)

    def _on_context_insert(self):
        """Handle 'insert item' being selected from the header context menu."""

        self.model.insertRow(self.header_row)

    def _on_context_append(self):
        """Handle 'add item' being selected from the empty space context
        menu."""

        self.model.insertRow(self.model.rowCount())

    def _on_context_remove(self):
        """Handle 'remove item' being selected from the header context menu."""

        self.model.removeRow(self.header_row)

    def _on_context_move_up(self):
        """Handle 'move up' being selected from the header context menu."""

        self.model.moveRow(self.header_row, self.header_row - 1)

    def _on_context_move_down(self):
        """Handle 'move down' being selected from the header context menu."""

        self.model.moveRow(self.header_row, self.header_row + 1)

# Define the SimpleEditor class.
SimpleEditor = TableEditor

# Define the ReadonlyEditor class.
ReadonlyEditor = TableEditor

#-------------------------------------------------------------------------------
#  Qt widgets that have been configured to behave as expected by Traits UI:
#-------------------------------------------------------------------------------

class TableDelegate(QtGui.QStyledItemDelegate):
    """ A QStyledItemDelegate which fetches Traits UI editors.
    """

    def createEditor(self, parent, option, index):
        """ Reimplemented to return the editor for a given index."""

        model = index.model()
        index = model.mapToSource(index)
        table_editor = model._editor
        column = table_editor.columns[index.column()]
        obj = table_editor.items()[index.row()]

        factory = column.get_editor(obj)
        style = column.get_style(obj)
        if factory is None:
            return None

        target, name = column.target_name(obj)
        handler = default_handler()
        if table_editor.ui.context is None:
            ui = UI(handler=handler)
        else:
            context = table_editor.ui.context.copy()
            context['table_editor_object'] = context['object']
            context['object'] = target
            ui = UI(handler=handler, context=context)

        # Create and initialize the editor
        factory_method = getattr(factory, style+'_editor')
        editor = factory_method(ui, target, name, '', parent)
        editor.prepare(parent)
        control = editor.control
        control.setParent(parent)

        # Required for QMouseEvents to propagate to the widget
        control.setFocusPolicy(QtCore.Qt.StrongFocus)

        # The table view's background will shine through unless the editor
        # paints its own background
        control.setAutoFillBackground(True)

        # Make sure that editors are disposed of correctly
        # will be disposed in closeEditor of the TableView
        control._editor = editor
        return control

    def updateEditorGeometry(self, editor, option, index):
        """ Update the editor's geometry.
        """
        editor.setGeometry(option.rect)

class TableView(QtGui.QTableView):
    """A QTableView configured to behave as expected by TraitsUI."""

    _SELECTION_MAP = {
        'row':      (QtGui.QAbstractItemView.SelectRows,
                            QtGui.QAbstractItemView.SingleSelection),
        'rows':     (QtGui.QAbstractItemView.SelectRows,
                            QtGui.QAbstractItemView.ExtendedSelection),
        'column':   (QtGui.QAbstractItemView.SelectColumns,
                            QtGui.QAbstractItemView.SingleSelection),
        'columns':  (QtGui.QAbstractItemView.SelectColumns,
                            QtGui.QAbstractItemView.ExtendedSelection),
        'cell':     (QtGui.QAbstractItemView.SelectItems,
                            QtGui.QAbstractItemView.SingleSelection),
        'cells':    (QtGui.QAbstractItemView.SelectItems,
                            QtGui.QAbstractItemView.ExtendedSelection)
    }

    def __init__(self, editor):
        """Initialise the object."""

        QtGui.QTableView.__init__(self)

        self._initial_size = False
        self._editor = editor
        factory = editor.factory

        # Configure the row headings.
        vheader = self.verticalHeader()
        insertable = factory.row_factory is not None and not factory.auto_add
        if ((factory.editable and (insertable or factory.deletable)) or
             factory.reorderable):
            vheader.installEventFilter(self)
            vheader.setResizeMode(QtGui.QHeaderView.ResizeToContents)
        else:
            vheader.hide()
        self.setAlternatingRowColors(factory.alternate_bg_color)
        self.setHorizontalScrollMode(QtGui.QAbstractItemView.ScrollPerPixel)

        # Configure the column headings.
        # We detect if there are any stretchy sections at all; if not, then
        # we make the last non-fixed-size column stretchy.
        hheader = self.horizontalHeader()
        resize_mode_map = dict(interactive = QtGui.QHeaderView.Interactive,
                               fixed = QtGui.QHeaderView.Fixed,
                               stretch = QtGui.QHeaderView.Stretch,
                               resize_to_contents = QtGui.QHeaderView.ResizeToContents)
        stretchable_columns = []
        for i, column in enumerate(editor.columns):
            hheader.setResizeMode(i, resize_mode_map[column.resize_mode])
            if column.resize_mode in ("stretch", "interactive"):
                stretchable_columns.append(i)
        if not stretchable_columns:
            # Use the behavior from before the "resize_mode" trait was added
            # to TableColumn
            hheader.setStretchLastSection(True)
        else:
            hheader.setResizeMode(stretchable_columns[-1], QtGui.QHeaderView.Stretch)
            hheader.setStretchLastSection(False)

        if factory.show_column_labels:
            hheader.setHighlightSections(False)
        else:
            hheader.hide()

        # Configure the grid lines.
        self.setShowGrid(factory.show_lines)

        # Configure the selection behaviour.
        self.setCornerButtonEnabled(False)
        behav, mode = self._SELECTION_MAP[factory.selection_mode]
        self.setSelectionBehavior(behav)
        self.setSelectionMode(mode)

        # Configure the editing behavior.
        triggers = (QtGui.QAbstractItemView.DoubleClicked |
                    QtGui.QAbstractItemView.SelectedClicked)
        if factory.edit_on_first_click and not factory.reorderable:
            triggers |= QtGui.QAbstractItemView.CurrentChanged
        self.setEditTriggers(triggers)

        # Configure the reordering and sorting behavior.
        self.setDragEnabled(True)
        self.viewport().setAcceptDrops(True)
        self.setDropIndicatorShown(True)

        if factory.reorderable:
            self.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
        if factory.sortable:
            self.setSortingEnabled(True)

        if factory._qt_stylesheet is not None:
            self.setStyleSheet(factory._qt_stylesheet)

        self.resizeColumnsToContents()


    def contextMenuEvent(self, event):
        """Reimplemented to create context menus for cells and empty space."""

        # Determine the logical indices of the cell where click occured
        hheader, vheader = self.horizontalHeader(), self.verticalHeader()
        position = event.globalPos()
        row = vheader.logicalIndexAt(vheader.mapFromGlobal(position))
        column = hheader.logicalIndexAt(hheader.mapFromGlobal(position))

        # Map the logical row index to a real index for the source model
        model = self.model()
        row = model.mapToSource(model.index(row, 0)).row()

        # Show a context menu for empty space at bottom of table...
        editor = self._editor
        if row == -1:
            factory = editor.factory
            if (factory.editable and factory.row_factory is not None and
                not factory.auto_add):
                event.accept()
                editor.empty_menu.exec_(position)

        # ...or show a context menu for a cell.
        elif column != -1:
            obj = editor.items()[row]
            column = editor.columns[column]
            menu_manager = column.get_menu(obj)
            if menu_manager is None:
                menu_manager = editor.factory.menu
            if menu_manager is not None:
                event.accept()
                selected = editor.selected
                if not isinstance(selected, SequenceTypes):
                    selected = [ selected ]
                if obj not in selected:
                    selected = [ obj ]
                editor.set_menu_context(selected, obj, column)
                menu = menu_manager.create_menu(self, controller=editor)
                menu.exec_(position)

    def eventFilter(self, obj, event):
        """Reimplemented to create context menu for the vertical header."""

        vheader = self.verticalHeader()
        if (obj is vheader and event.type() == QtCore.QEvent.ContextMenu):
            event.accept()
            editor = self._editor
            row = vheader.logicalIndexAt(event.pos().y())
            if row == -1:
                factory = editor.factory
                if factory.row_factory is not None and not factory.auto_add:
                    editor.empty_menu.exec_(event.globalPos())
            else:
                editor.header_row = row
                if editor.factory.reorderable:
                    show_up = row > 0
                    show_down = row < editor.model.rowCount() - 1
                    editor.header_menu_up.setVisible(show_up)
                    editor.header_menu_down.setVisible(show_down)
                self._editor.header_menu.exec_(event.globalPos())
            return True

        else:
            return QtGui.QTableView.eventFilter(self, obj, event)

    def resizeEvent(self, event):
        """Reimplemented to size the table columns when the size of the table
        changes. Because the layout algorithm requires that the available space
        be known, we have to wait until the UI that contains this table gives it
        its initial size."""

        QtGui.QTableView.resizeEvent(self, event)

        if self._editor.auto_size:
            self.resizeColumnsToContents()
            self.resizeRowsToContents()

        else:
            parent = self.parent()
            if (not self._initial_size and parent and
                (self.isVisible() or isinstance(parent, QtGui.QMainWindow))):
                self._initial_size = True
                if self._editor.auto_size:
                    self.resizeColumnsToContents()
                    self.resizeRowsToContents()

    def sizeHint(self):
        """Reimplemented to define a better size hint for the width of the
        TableEditor."""

        size_hint = QtGui.QTableView.sizeHint(self)

        # This method is sometimes called by Qt after the editor has been
        # disposed but before this control has been deleted:
        if self._editor.factory is None:
            return size_hint

        width = self.style().pixelMetric(QtGui.QStyle.PM_ScrollBarExtent,
                                         QtGui.QStyleOptionHeader(), self)
        for column in range(len(self._editor.columns)):
            width += self.sizeHintForColumn(column)
        size_hint.setWidth(width)
        return size_hint

    def sizeHintForColumn(self, column_index):
        """Reimplemented to support absolute width specification via
        TableColumns and to improve the metric for autosizing columns."""

        editor = self._editor
        column = editor.columns[column_index]
        requested_width = column.get_width()

        # Autosize based on column contents and label width. Qt's default
        # implementation of this function does content, we handle the label.
        if requested_width < 1:
            base_width = QtGui.QTableView.sizeHintForColumn(self, column_index)

            # Determine what font to use in the calculation
            font = column.get_text_font(None)
            if font is None:
                font = self.font()
                font.setBold(True)
            else:
                font = QtGui.QFont(font)

            # Determine the width of the column label
            text = column.get_label()
            width = QtGui.QFontMetrics(font).width(text)

            # Add margin to the calculated width as appropriate
            style = self.style()
            option = QtGui.QStyleOptionHeader()
            width += style.pixelMetric(QtGui.QStyle.PM_HeaderGripMargin,
                                       option, self) * 2
            if editor.factory.sortable and not editor.factory.reorderable:
                # Add size of sort indicator
                width += style.pixelMetric(QtGui.QStyle.PM_HeaderMarkSize,
                                           option, self)
                # Add distance between sort indicator and text
                width += style.pixelMetric(QtGui.QStyle.PM_HeaderMargin, option,
                                           self)
            return max(base_width, width)

        # Or else set width absolutely
        else:
            return requested_width

    def resizeColumnsToContents(self):
        """Reimplemented to support proportional column width specifications."""

        # TODO: The proportional size specification approach found in the
        # TableColumns is not entirely compatible with the ability to
        # specify the resize_mode.  Namely, there are combinations of
        # specifications that are redundant, and others which are 
        # contradictory.  Rework this method so that the various values
        # for **width** have a well-defined, sensible meaning for each
        # of the possible values of resize_mode.

        editor = self._editor
        available_space = self.viewport().width()
        hheader = self.horizontalHeader()

        # Compute sizes for columns with absolute or no size requests
        proportional = []
        for column_index in xrange(len(editor.columns)):
            column = editor.columns[column_index]
            requested_width = column.get_width()
            if column.resize_mode in ("interactive", "stretch") \
                    and 0 < requested_width <= 1.0:
                proportional.append((column_index, requested_width))
            elif column.resize_mode == "interactive" and requested_width < 0 \
                    and self._initial_size:
                # Keep previous size if initial sizing has been done
                available_space -= hheader.sectionSize(column_index)
            else:
                base_width = hheader.sectionSizeHint(column_index)
                width = max(base_width, self.sizeHintForColumn(column_index))
                hheader.resizeSection(column_index, width)
                available_space -= width

        # Now use the remaining space for columns with proportional width
        # requests
        for column_index, percent in proportional:
            base_width = hheader.sectionSizeHint(column_index)
            width = max(base_width, int(percent * available_space))
            hheader.resizeSection(column_index, width)

    def closeEditor(self, control, hint) :
        # dispose traits editor associated with control if any
        editor = getattr(control, "_editor", None)
        if editor is not None :
            editor.dispose()
            delattr(control, "_editor")

        return super(TableView, self).closeEditor(control, hint)

#-------------------------------------------------------------------------------
#  Editor for configuring the filters available to a TableEditor:
#-------------------------------------------------------------------------------

class TableFilterEditor(HasTraits):
    """ An editor that manages table filters.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # TableEditor this editor is associated with
    editor = Instance(TableEditor)

    # The list of filters
    filters = List(TableFilter)

    # The list of available templates from which filters can be created
    templates = Property(List(TableFilter), depends_on='filters')

    # The currently selected filter template
    selected_template = Instance(TableFilter)

    # The currently selected filter
    selected_filter = Instance(TableFilter, allow_none=True)

    # The view to use for the current filter
    selected_filter_view = Property(depends_on='selected_filter')

    # Buttons for add/removing filters
    add_button = Button('New')
    remove_button = Button('Delete')

    # The default view for this editor
    view = View(Group(Group(Group(Item('add_button',
                                       enabled_when='selected_template'),
                                  Item('remove_button',
                                       enabled_when='len(templates) > 1 and ' \
                                           'selected_filter is not None'),
                                  orientation='horizontal',
                                  show_labels=False),
                            Label('Base filter for new filters:'),
                            Item('selected_template',
                                 editor=EnumEditor(name='templates')),
                            Item('selected_filter',
                                 style='custom',
                                 editor=EnumEditor(name='filters',
                                                   mode='list')),
                            show_labels=False),
                      Item('selected_filter',
                           width=0.75,
                           style='custom',
                           editor=InstanceEditor(view_name='selected_filter_view')),
                      id='TableFilterEditorSplit',
                      show_labels=False,
                      layout='split',
                      orientation='horizontal'),
                id='traitsui.qt4.table_editor.TableFilterEditor',
                buttons=[ 'OK', 'Cancel' ],
                kind='livemodal',
                resizable=True, width=800, height=400,
                title='Customize filters')

    #---------------------------------------------------------------------------
    #  Private methods:
    #---------------------------------------------------------------------------

    #-- Trait Property getter/setters ------------------------------------------

    @cached_property
    def _get_selected_filter_view(self):
        view = None
        if self.selected_filter:
            model = self.editor.model
            index = model.mapToSource(model.index(0, 0))
            if index.isValid():
                obj = self.editor.items()[index.row()]
            else:
                obj = None
            view = self.selected_filter.edit_view(obj)
        return view

    @cached_property
    def _get_templates(self):
        templates = [ f for f in self.editor.factory.filters if f.template ]
        templates.extend(self.filters)
        return templates

    #-- Trait Change Handlers --------------------------------------------------

    def _editor_changed(self):
        self.filters = [ f.clone_traits() for f in self.editor.factory.filters
                         if not f.template ]
        self.selected_template = self.templates[0]

    def _add_button_fired(self):
        """ Create a new filter based on the selected template and select it.
        """
        new_filter = self.selected_template.clone_traits()
        new_filter.template = False
        new_filter.name = new_filter._name = 'New filter'
        self.filters.append(new_filter)
        self.selected_filter = new_filter

    def _remove_button_fired(self):
        """ Delete the currently selected filter.
        """
        if self.selected_template == self.selected_filter:
            self.selected_template = self.templates[0]

        index = self.filters.index(self.selected_filter)
        del self.filters[index]
        if index < len(self.filters):
            self.selected_filter = self.filters[index]
        else:
            self.selected_filter = None

    @on_trait_change('selected_filter:name')
    def _update_filter_list(self):
        """ A hack to make the EnumEditor watching the list of filters refresh
            their text when the name of the selected filter changes.
        """
        filters = self.filters
        self.filters = []
        self.filters = filters

########NEW FILE########
__FILENAME__ = table_model
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described
# in the PyQt GPL exception also apply.
#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the table model used by the table editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traitsui.ui_traits import SequenceTypes

from .clipboard import PyMimeData 

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping for trait alignment values to qt4 horizontal alignment constants
h_alignment_map = {
    'left':   QtCore.Qt.AlignLeft,
    'center': QtCore.Qt.AlignHCenter,
    'right':  QtCore.Qt.AlignRight,
}

# Mapping for trait alignment values to qt4 vertical alignment constants
v_alignment_map = {
    'top':    QtCore.Qt.AlignTop,
    'center': QtCore.Qt.AlignVCenter,
    'bottom': QtCore.Qt.AlignBottom,
}

# MIME type for internal table drag/drop operations
mime_type = 'traits-ui-table-editor'

def as_qcolor(color):
    """ Convert a color specification (maybe a tuple) into a QColor.
    """
    if isinstance(color, SequenceTypes):
        return QtGui.QColor(*color)
    else:
        return QtGui.QColor(color)

#-------------------------------------------------------------------------------
#  'TableModel' class:
#-------------------------------------------------------------------------------

class TableModel(QtCore.QAbstractTableModel):
    """The model for table data."""

    def __init__(self, editor, parent=None):
        """Initialise the object."""

        QtCore.QAbstractTableModel.__init__(self, parent)

        self._editor = editor

    #---------------------------------------------------------------------------
    #  QAbstractTableModel interface:
    #---------------------------------------------------------------------------

    def rowCount(self, mi):
        """Reimplemented to return the number of rows."""

        return len(self._editor.items())

    def columnCount(self, mi):
        """Reimplemented to return the number of columns."""

        return len(self._editor.columns)

    def data(self, mi, role):
        """Reimplemented to return the data."""

        obj = self._editor.items()[mi.row()]
        column = self._editor.columns[mi.column()]

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:
            text = column.get_value(obj)
            if text is not None:
                return text

        elif role == QtCore.Qt.DecorationRole:
            image = self._editor._get_image(column.get_image(obj))
            if image is not None:
                return image

        elif role == QtCore.Qt.ToolTipRole:
            tooltip = column.get_tooltip(obj)
            if tooltip:
                return tooltip

        elif role == QtCore.Qt.FontRole:
            font = column.get_text_font(obj)
            if font is not None:
                return QtGui.QFont(font)

        elif role == QtCore.Qt.TextAlignmentRole:
            string = column.get_horizontal_alignment(obj)
            h_alignment = h_alignment_map.get(string, QtCore.Qt.AlignLeft)
            string = column.get_vertical_alignment(obj)
            v_alignment = v_alignment_map.get(string, QtCore.Qt.AlignVCenter)
            return (h_alignment | v_alignment)

        elif role == QtCore.Qt.BackgroundRole:
            color = column.get_cell_color(obj)
            if color is None:
                # FIXME: Yes, this is weird. It should work fine to fall through
                # to the catch-all None at the end, but it doesn't.
                return None
            else:
                q_color = as_qcolor(color)
                return QtGui.QBrush(q_color)

        elif role == QtCore.Qt.ForegroundRole:
            color = column.get_text_color(obj)
            if color is not None:
                q_color = as_qcolor(color)
                return QtGui.QBrush(q_color)

        elif role == QtCore.Qt.UserRole:
            return obj

        elif role == QtCore.Qt.CheckStateRole:
            if column.get_type(obj) == "bool" and column.show_checkbox:
                if column.get_raw_value(obj):
                    return QtCore.Qt.Checked
                else:
                    return QtCore.Qt.Unchecked

        return None

    def flags(self, mi):
        """Reimplemented to set editable and movable status."""

        editor = self._editor

        if not mi.isValid():
            if editor.factory.reorderable:
                return QtCore.Qt.ItemIsDropEnabled
            else:
                return

        flags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled | \
                QtCore.Qt.ItemIsDragEnabled 

        obj = editor.items()[mi.row()]
        column = editor.columns[mi.column()]

        if editor.factory.editable and column.is_editable(obj):
            flags |= QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsDropEnabled

        if editor.factory.reorderable:
            flags |= QtCore.Qt.ItemIsDropEnabled

        if column.get_type(obj) == "bool" and column.show_checkbox:
            flags |= QtCore.Qt.ItemIsUserCheckable

        return flags

    def headerData(self, section, orientation, role):
        """Reimplemented to return the header data."""

        if orientation == QtCore.Qt.Horizontal:

            editor = self._editor
            column = editor.columns[section]

            if role == QtCore.Qt.DisplayRole:
                return column.get_label()

        elif orientation == QtCore.Qt.Vertical:

            if role == QtCore.Qt.DisplayRole:
                return str(section + 1)

        return None

    def insertRow(self, row, parent=QtCore.QModelIndex(), obj=None):
        """Reimplemented to allow creation of new rows. Added an optional
        arg to allow the insertion of an existing row object."""

        editor = self._editor
        if obj is None:
            obj = editor.create_new_row()

        self.beginInsertRows(parent, row, row)
        editor.callx(editor.items().insert, row, obj)
        self.endInsertRows()
        return True

    def insertRows(self, row, count, parent=QtCore.QModelIndex()):
        """Reimplemented to allow creation of new rows."""

        editor = self._editor
        items = editor.items()
        self.beginInsertRows(parent, row, row + count - 1)
        for i in xrange(count):
            editor.callx(items.insert, row + i, editor.create_new_row())
        self.endInsertRows()
        return True

    def removeRows(self, row, count, parent=QtCore.QModelIndex()):
        """Reimplemented to allow row deletion, as well as reordering via drag
        and drop."""

        editor = self._editor
        items = editor.items()
        self.beginRemoveRows(parent, row, row + count - 1)
        for i in xrange(count):
            editor.callx(items.pop, row + i)
        self.endRemoveRows()
        return True

    def mimeTypes(self):
        """Reimplemented to expose our internal MIME type for drag and drop
        operations."""

        return [mime_type, PyMimeData.MIME_TYPE, PyMimeData.NOPICKLE_MIME_TYPE]

    def mimeData(self, indexes):
        """Reimplemented to generate MIME data containing the rows of the
        current selection."""
        
        editor = self._editor
        selection_mode = editor.factory.selection_mode
        
        if selection_mode.startswith("cell"):
            data = [self._get_cell_drag_value(index.row(), index.column())
                for index in indexes]
        elif selection_mode.startswith("column"):
            columns = sorted(set(index.column() for index in indexes))
            data = self._get_columns_drag_value(columns)
        else:
            rows = sorted(set(index.row() for index in indexes))
            data = self._get_rows_drag_value(rows)
        
        mime_data = PyMimeData.coerce(data)
        
        # handle re-ordering via internal drags
        if editor.factory.reorderable:
            rows = sorted(set([ index.row() for index in indexes ]))
            data = QtCore.QByteArray(str(id(self)))
            for row in rows:
                data.append(' %i' % row)
            mime_data.setData(mime_type, data)
        return mime_data

    def dropMimeData(self, mime_data, action, row, column, parent):
        """Reimplemented to allow items to be moved."""

        if action == QtCore.Qt.IgnoreAction:
            return False
            
        # this is a drag from a table model?
        data = mime_data.data(mime_type)
        if not data.isNull() and action == QtCore.Qt.MoveAction:
            id_and_rows = map(int, str(data).split(' '))
            table_id = id_and_rows[0]
            # is it from ourself?
            if table_id == id(self):
                current_rows = id_and_rows[1:]
                if not parent.isValid():
                    row = len(self._editor.items())-1
                else:
                    row == parent.row()
                    
                self.moveRows(current_rows, row)
                return True

        data = PyMimeData.coerce(mime_data).instance()
        if data is not None:
            editor = self._editor
            
            if row == -1 and column == -1 and parent.isValid():
                row = parent.row()
                column = parent.column()
            
            if row != -1 and column != - 1:
                object = editor.items()[row]
                column = editor.columns[column]                
                if column.is_droppable(object, data):
                    column.set_value(object, data)
                    return True
            
        return False

    def supportedDropActions(self):
        """Reimplemented to allow items to be moved."""
    
        return QtCore.Qt.MoveAction

    #---------------------------------------------------------------------------
    #  Utility methods
    #---------------------------------------------------------------------------
    
    def _get_columns_drag_value(self, columns):
        """ Returns the value to use when the specified columns are dragged or
            copied and pasted. The parameter *cols* is a list of column indexes.
        """
        return [self._get_column_data(column) for column in columns]

    def _get_column_data(self, column):
        """ Return the model data for the column as a list """
        editor = self._editor
        column_obj = editor.columns[column]
        return [column_obj.get_value(item) for item in editor.items()]

    def _get_rows_drag_value(self, rows):
        """ Returns the value to use when the specified rows are dragged or
            copied and pasted. The parameter *rows* is a list of row indexes.
            Return a list of objects.
        """
        items = self._editor.items()
        return [items[row] for row in rows]

    def _get_cell_drag_value(self, row, column):
        """ Returns the value to use when the specified cell is dragged or
            copied and pasted.
        """
        editor = self._editor
        item = editor.items()[row]
        drag_value = editor.columns[column].get_drag_value(item)
        return drag_value

    #---------------------------------------------------------------------------
    #  TableModel interface:
    #---------------------------------------------------------------------------
    
    def moveRow(self, old_row, new_row):
        """Convenience method to move a single row."""

        return self.moveRows([old_row], new_row)

    def moveRows(self, current_rows, new_row):
        """Moves a sequence of rows (provided as a list of row indexes) to a new
        row."""

        # Sort rows in descending order so they can be removed without
        # invalidating the indices.
        current_rows.sort()
        current_rows.reverse()

        # If the the highest selected row is lower than the destination, do an
        # insertion before rather than after the destination.
        if current_rows[-1] < new_row:
            new_row += 1

        # Remove selected rows...
        items = self._editor.items()
        objects = []
        for row in current_rows:
            if row <= new_row:
                new_row -= 1
            objects.insert(0, items[row])
            self.removeRow(row)

        # ...and add them at the new location.
        for i, obj in enumerate(objects):
            self.insertRow(new_row + i, obj=obj)

        # Update the selection for the new location.
        self._editor.set_selection(objects)

#-------------------------------------------------------------------------------
#  'SortFilterTableModel' class:
#-------------------------------------------------------------------------------

class SortFilterTableModel(QtGui.QSortFilterProxyModel):
    """A wrapper for the TableModel which provides sorting and filtering
    capability."""

    def __init__(self, editor, parent=None):
        """Initialise the object."""

        QtGui.QSortFilterProxyModel.__init__(self, parent)

        self._editor = editor

    #---------------------------------------------------------------------------
    #  QSortFilterProxyModel interface:
    #---------------------------------------------------------------------------

    def filterAcceptsRow(self, source_row, source_parent):
        """"Reimplemented to use a TableFilter for filtering rows."""

        if self._editor._filtered_cache is None:
            return True
        else:
            return self._editor._filtered_cache[source_row]

    def filterAcceptsColumn(self, source_column, source_parent):
        """Reimplemented to save time, because we always return True."""

        return True

    def lessThan(self, left_mi, right_mi):
        """Reimplemented to sort according to the 'cmp' method defined for
        TableColumn."""

        editor = self._editor
        column = editor.columns[left_mi.column()]
        items = editor.items()
        left, right = items[left_mi.row()], items[right_mi.row()]

        return column.cmp(left, right) < 0

    #---------------------------------------------------------------------------
    #  SortFilterTableModel interface:
    #---------------------------------------------------------------------------

    def moveRow(self, old_row, new_row):
        """Convenience method to move a single row."""

        return self.moveRows([old_row], new_row)

    def moveRows(self, current_rows, new_row):
        """Delegate to source model with mapped rows."""

        source = self.sourceModel()
        current_rows = [ self.mapToSource(self.index(row, 0)).row()
                         for row in current_rows ]
        new_row = self.mapToSource(self.index(new_row, 0)).row()
        source.moveRows(current_rows, new_row)

########NEW FILE########
__FILENAME__ = tabular_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   06/22/2009
#
#-------------------------------------------------------------------------------

""" A traits UI editor for editing tabular data (arrays, list of tuples, lists
    of objects, etc).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from pyface.image_resource import ImageResource

from traits.api import (Any, Bool, Callable, Event, HasStrictTraits, Instance,
    Int, List, NO_COMPARE, Property, TraitListEvent)

from traitsui.tabular_adapter import TabularAdapter
from traitsui.ui_traits import Image

from editor import Editor
from tabular_model import TabularModel


class HeaderEventFilter(QtCore.QObject) :
    def __init__(self, editor) :
        super(HeaderEventFilter, self).__init__()
        self.editor = editor

    def eventFilter(self, obj, event) :
        if event.type() == QtCore.QEvent.ContextMenu :
            self.editor._on_column_context_menu(event.pos())
            return True
        return False


class TabularEditor(Editor):
    """ A traits UI editor for editing tabular data (arrays, list of tuples,
        lists of objects, etc).
    """

    #-- Trait Definitions ------------------------------------------------------

    # The event fired when a table update is needed:
    update = Event

    # The event fired when a simple repaint is needed:
    refresh = Event

    # The current set of selected items (which one is used depends upon the
    # initial state of the editor factory 'multi_select' trait):
    selected       = Any
    multi_selected = List

    # The current set of selected item indices (which one is used depends upon
    # the initial state of the editor factory 'multi_select' trait):
    selected_row        = Int(-1)
    multi_selected_rows = List(Int)

    # The most recently actived item and its index:
    activated     = Any(comparison_mode=NO_COMPARE)
    activated_row = Int(comparison_mode=NO_COMPARE)

    # The most recent left click data:
    clicked = Instance('TabularEditorEvent')

    # The most recent left double click data:
    dclicked = Instance('TabularEditorEvent')

    # The most recent right click data:
    right_clicked = Instance('TabularEditorEvent')

    # The most recent right double click data:
    right_dclicked = Instance('TabularEditorEvent')

    # The most recent column click data:
    column_clicked = Instance('TabularEditorEvent')

    # The most recent column click data:
    column_right_clicked = Instance('TabularEditorEvent')

    # The event triggering scrolling.
    scroll_to_row = Event(Int)

    # Is the tabular editor scrollable? This value overrides the default.
    scrollable = True

    # Row index of item to select after rebuilding editor list:
    row = Any

    # Should the selected item be edited after rebuilding the editor list:
    edit = Bool(False)

    # The adapter from trait values to editor values:
    adapter = Instance(TabularAdapter)

    # The table model associated with the editor:
    model = Instance(TabularModel)

    # Dictionary mapping image names to QIcons
    images = Any({})

    # Dictionary mapping ImageResource objects to QIcons
    image_resources = Any({})

    # An image being converted:
    image = Image

    header_event_filter = Any()

    widget_factory = Callable(lambda *args, **kwds: _TableView(*args, **kwds))

    #---------------------------------------------------------------------------
    #  Editor interface:
    #---------------------------------------------------------------------------

    def init (self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        adapter = self.adapter = factory.adapter
        self.model = TabularModel(editor=self)

        # Create the control
        control = self.control = self.widget_factory(self)

        # Set up the selection listener
        if factory.multi_select:
            self.sync_value(factory.selected, 'multi_selected', 'both',
                            is_list=True)
            self.sync_value(factory.selected_row, 'multi_selected_rows','both',
                            is_list=True)
        else:
            self.sync_value(factory.selected, 'selected', 'both')
            self.sync_value(factory.selected_row, 'selected_row', 'both')

        # Connect to the mode specific selection handler
        if factory.multi_select:
            slot = self._on_rows_selection
        else:
            slot = self._on_row_selection
        signal = 'selectionChanged(QItemSelection,QItemSelection)'
        QtCore.QObject.connect(self.control.selectionModel(),
                               QtCore.SIGNAL(signal), slot)

        # Synchronize other interesting traits as necessary:
        self.sync_value(factory.update, 'update', 'from')
        self.sync_value(factory.refresh, 'refresh', 'from')
        self.sync_value(factory.activated,     'activated',     'to')
        self.sync_value(factory.activated_row, 'activated_row', 'to')
        self.sync_value(factory.clicked,  'clicked',  'to')
        self.sync_value(factory.dclicked, 'dclicked', 'to')
        self.sync_value(factory.right_clicked,  'right_clicked',  'to')
        self.sync_value(factory.right_dclicked, 'right_dclicked', 'to')
        self.sync_value(factory.column_clicked, 'column_clicked', 'to')
        self.sync_value(factory.column_right_clicked, 'column_right_clicked', 'to')
        self.sync_value(factory.scroll_to_row, 'scroll_to_row', 'from')

        # Connect other signals as necessary
        signal = QtCore.SIGNAL('activated(QModelIndex)')
        QtCore.QObject.connect(control, signal, self._on_activate)
        signal = QtCore.SIGNAL('clicked(QModelIndex)')
        QtCore.QObject.connect(control, signal, self._on_click)
        signal = QtCore.SIGNAL('clicked(QModelIndex)')
        QtCore.QObject.connect(control, signal, self._on_right_click)
        signal = QtCore.SIGNAL('doubleClicked(QModelIndex)')
        QtCore.QObject.connect(control, signal, self._on_dclick)
        signal = QtCore.SIGNAL('sectionClicked(int)')
        QtCore.QObject.connect(control.horizontalHeader(), signal, self._on_column_click)

        control.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        signal = QtCore.SIGNAL('customContextMenuRequested(QPoint)')
        QtCore.QObject.connect(control, signal, self._on_context_menu)

        self.header_event_filter = HeaderEventFilter(self)
        control.horizontalHeader().installEventFilter(self.header_event_filter)

        # Make sure we listen for 'items' changes as well as complete list
        # replacements:
        try:
            self.context_object.on_trait_change(
                self.update_editor, self.extended_name+'_items', dispatch='ui')
        except:
            pass

        # If the user has requested automatic update, attempt to set up the
        # appropriate listeners:
        if factory.auto_update:
            self.context_object.on_trait_change(
                self.refresh_editor, self.extended_name + '.-', dispatch='ui')

        # Create the mapping from user supplied images to QImages:
        for image_resource in factory.images:
            self._add_image(image_resource)

        # Refresh the editor whenever the adapter changes:
        self.on_trait_change(self.refresh_editor, 'adapter.+update',
                             dispatch='ui')

        # Rebuild the editor columns and headers whenever the adapter's
        # 'columns' changes:
        self.on_trait_change(self.update_editor, 'adapter.columns',
                             dispatch='ui')

    def dispose (self):
        """ Disposes of the contents of an editor.
        """
        self.context_object.on_trait_change(
            self.update_editor, self.extended_name + '_items', remove=True)

        if self.factory.auto_update:
            self.context_object.on_trait_change(
                self.refresh_editor, self.extended_name + '.-', remove=True)

        self.on_trait_change(self.refresh_editor, 'adapter.+update',
                             remove=True)
        self.on_trait_change(self.update_editor, 'adapter.columns',
                             remove=True)

        self.adapter.cleanup()

        super(TabularEditor, self).dispose()

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if not self._no_update:
            self.model.reset()
            if self.factory.multi_select:
                self._multi_selected_changed(self.multi_selected)
            else :
                self._selected_changed(self.selected)

    #---------------------------------------------------------------------------
    #  TabularEditor interface:
    #---------------------------------------------------------------------------

    def refresh_editor(self):
        """ Requests the table view to redraw itself.
        """
        self.control.viewport().update()

    def callx(self, func, *args, **kw):
        """ Call a function without allowing the editor to update.
        """
        old = self._no_update
        self._no_update = True
        try:
            func(*args, **kw)
        finally:
            self._no_update = old

    def setx(self, **keywords):
        """ Set one or more attributes without allowing the editor to update.
        """
        old = self._no_notify
        self._no_notify = True
        try:
            for name, value in keywords.items():
                setattr(self, name, value)
        finally:
            self._no_notify = old

    #---------------------------------------------------------------------------
    #  UI preference save/restore interface:
    #---------------------------------------------------------------------------

    def restore_prefs(self, prefs):
        """ Restores any saved user preference information associated with the
            editor.
        """
        cws = prefs.get('cached_widths')
        num_columns = len(self.adapter.columns)
        if cws is not None and num_columns == len(cws):
            for column in xrange(num_columns):
                self.control.setColumnWidth(column, cws[column])

    def save_prefs(self):
        """ Returns any user preference information associated with the editor.
        """
        widths = [ self.control.columnWidth(column)
                   for column in xrange(len(self.adapter.columns)) ]
        return { 'cached_widths': widths }

    #---------------------------------------------------------------------------
    #  Private methods:
    #---------------------------------------------------------------------------

    def _add_image(self, image_resource):
        """ Adds a new image to the image map.
        """
        image = image_resource.create_icon()

        self.image_resources[image_resource] = image
        self.images[image_resource.name] = image

        return image

    def _get_image(self, image):
        """ Converts a user specified image to a QIcon.
        """
        if isinstance(image, basestring):
            self.image = image
            image = self.image

        if isinstance(image, ImageResource):
            result = self.image_resources.get(image)
            if result is not None:
                return result
            return self._add_image(image)

        return self.images.get(image)

    def _mouse_click(self, index, trait):
        """ Generate a TabularEditorEvent event for a specified model index and
            editor trait name.
        """
        event = TabularEditorEvent(editor=self, row=index.row(),
                                   column=index.column())
        setattr(self, trait, event)

    #-- Trait Event Handlers ---------------------------------------------------

    def _update_changed(self):
        self.update_editor()

    def _refresh_changed(self):
        self.refresh_editor()

    def _selected_changed(self, new):
        if not self._no_update:
            try:
                selected_row = self.value.index(new)
            except:
                pass
            else:
                self._selected_row_changed(selected_row)

    def _selected_row_changed(self, selected_row):
        if not self._no_update:
            smodel = self.control.selectionModel()
            if selected_row == -1:
                smodel.clearSelection()
            else:
                smodel.select(self.model.index(selected_row, 0),
                              QtGui.QItemSelectionModel.ClearAndSelect |
                              QtGui.QItemSelectionModel.Rows)

    def _multi_selected_changed(self, new):
        if not self._no_update:
            values = self.value
            try:
                rows = [ values.index(i) for i in new]
            except:
                pass
            else:
                self._multi_selected_rows_changed(rows)

    def _multi_selected_items_changed(self, event):
        values = self.value
        try:
            added = [ values.index(item) for item in event.added ]
            removed = [ values.index(item) for item in event.removed ]
        except:
            pass
        else:
            list_event = TraitListEvent(0, added, removed)
            self._multi_selected_rows_items_changed(list_event)

    def _multi_selected_rows_changed(self, selected_rows):
        if not self._no_update:
            smodel = self.control.selectionModel()
            selection = QtGui.QItemSelection()
            for row in selected_rows:
                selection.select(self.model.index(row, 0), self.model.index(row, 0))
            smodel.clearSelection()
            smodel.select(selection,
                QtGui.QItemSelectionModel.Select |
                QtGui.QItemSelectionModel.Rows)

    def _multi_selected_rows_items_changed(self, event):
        smodel = self.control.selectionModel()
        for row in event.removed:
            smodel.select(self.model.index(row, 0),
                          QtGui.QItemSelectionModel.Deselect |
                          QtGui.QItemSelectionModel.Rows)
        for row in event.added:
            smodel.select(self.model.index(row, 0),
                          QtGui.QItemSelectionModel.Select |
                          QtGui.QItemSelectionModel.Rows)

    scroll_to_row_hint_map = {
        'center'  : QtGui.QTableView.PositionAtCenter,
        'top'     : QtGui.QTableView.PositionAtTop,
        'bottom'  : QtGui.QTableView.PositionAtBottom,
        'visible' : QtGui.QTableView.EnsureVisible,
    }

    def _scroll_to_row_changed(self, row):
        """ Scroll to the given row.
        """
        scroll_hint = self.scroll_to_row_hint_map.get(self.factory.scroll_to_row_hint, self.control.PositionAtCenter)
        self.control.scrollTo(self.model.index(row, 0), scroll_hint)

    #-- Table Control Event Handlers -------------------------------------------

    def _on_activate(self, index):
        """ Handle a cell being activated.
        """
        self.activated_row = row = index.row()
        self.activated = self.adapter.get_item(self.object, self.name, row)

    def _on_click(self, index):
        """ Handle a cell being clicked.
        """
        self._mouse_click(index, 'clicked')

    def _on_dclick(self, index):
        """ Handle a cell being double clicked.
        """
        self._mouse_click(index, 'dclicked')

    def _on_column_click(self, column):
        event = TabularEditorEvent(editor=self, row=0, column=column)
        setattr(self, 'column_clicked', event)

    def _on_right_click(self, column):
        event = TabularEditorEvent(editor=self, row=0, column=column)
        setattr(self, 'right_clicked', event)

    def _on_column_right_click(self, column):
        event = TabularEditorEvent(editor=self, row=0, column=column)
        setattr(self, 'column_right_clicked', event)

    def _on_row_selection(self, added, removed):
        """ Handle the row selection being changed.
        """
        self._no_update = True
        try:
            indexes = self.control.selectionModel().selectedRows()
            if len(indexes):
                self.selected_row = indexes[0].row()
                self.selected = self.adapter.get_item(self.object, self.name,
                                                      self.selected_row)
            else:
                self.selected_row = -1
                self.selected = None
        finally:
            self._no_update = False

    def _on_rows_selection(self, added, removed):
        """ Handle the rows selection being changed.
        """
        self._no_update = True
        try:
            indexes = self.control.selectionModel().selectedRows()
            selected_rows = []
            selected = []
            for index in indexes:
                row = index.row()
                selected_rows.append(row)
                selected.append(self.adapter.get_item(self.object, self.name,
                                                      row))
            self.multi_selected_rows = selected_rows
            self.multi_selected = selected
        finally:
            self._no_update = False

    def _on_context_menu(self, pos) :
        column, row = self.control.columnAt(pos.x()), self.control.rowAt(pos.y())
        menu = self.adapter.get_menu(self.object, self.name, row, column)
        if menu :
            self._menu_context = {'selection' : self.object,
                             'object':  self.object,
                             'editor':  self,
                             'column':  column,
                             'row':     row,
                             'item':    self.adapter.get_item(self.object, self.name, row),
                             'info':    self.ui.info,
                             'handler': self.ui.handler }
            qmenu = menu.create_menu( self.control, self )
            qmenu.exec_(self.control.mapToGlobal(pos))
            self._menu_context = None

    def _on_column_context_menu(self, pos) :
        column = self.control.columnAt(pos.x())
        menu = self.adapter.get_column_menu(self.object, self.name, -1, column)
        if menu :
            self._menu_context = {'selection' : self.object, 'object':  self.object,
                             'editor':  self,
                             'column':  column,
                             'info':    self.ui.info,
                             'handler': self.ui.handler }
            qmenu = menu.create_menu( self.control, self )
            qmenu.exec_(self.control.mapToGlobal(pos))
            self._menu_context = None
        else:
            #If no menu is defined on the adapter, just trigger a click event.
            self._on_column_right_click(column)


#-------------------------------------------------------------------------------
#  'TabularEditorEvent' class:
#-------------------------------------------------------------------------------

class TabularEditorEvent(HasStrictTraits):

    # The index of the row:
    row = Int

    # The id of the column (either a string or an integer):
    column = Any

    # The row item:
    item = Property

    #-- Private Traits ---------------------------------------------------------

    # The editor the event is associated with:
    editor = Instance(TabularEditor)

    #-- Property Implementations -----------------------------------------------

    def _get_item(self):
        editor = self.editor
        return editor.adapter.get_item(editor.object, editor.name, self.row)

#-------------------------------------------------------------------------------
#  Qt widgets that have been configured to behave as expected by Traits UI:
#-------------------------------------------------------------------------------

class _ItemDelegate(QtGui.QStyledItemDelegate):
    """ A QStyledItemDelegate which draws its owns gridlines so that we can
        choose to draw only the horizontal or only the vertical gridlines if
        appropriate.
    """

    def __init__(self, table_view):
        """ Store which grid lines to draw.
        """
        QtGui.QStyledItemDelegate.__init__(self, table_view)
        self._horizontal_lines = table_view._editor.factory.horizontal_lines
        self._vertical_lines = table_view._editor.factory.vertical_lines

    def paint(self, painter, option, index):
        """ Overrident to draw gridlines.
        """
        QtGui.QStyledItemDelegate.paint(self, painter, option, index)
        painter.save()

        # FIXME: 'styleHint' is returning bogus (negative) values. Why?
        #style = QtGui.QApplication.instance().style()
        #color = style.styleHint(QtGui.QStyle.SH_Table_GridLineColor, option)
        #painter.setPen(QtGui.QColor(color))
        painter.setPen(option.palette.color(QtGui.QPalette.Dark))

        if self._horizontal_lines:
            painter.drawLine(option.rect.bottomLeft(),option.rect.bottomRight())
        if self._vertical_lines:
            painter.drawLine(option.rect.topRight(), option.rect.bottomRight())

        painter.restore()

class _TableView(QtGui.QTableView):
    """ A QTableView configured to behave as expected by TraitsUI.
    """

    def __init__(self, editor):
        """ Initialise the object.
        """
        QtGui.QTableView.__init__(self)

        self._initial_size = False
        self._editor = editor
        self.setModel(editor.model)
        factory = editor.factory

        # Configure the row headings
        vheader = self.verticalHeader()
        if factory.show_row_titles:
            vheader.setHighlightSections(False)
        else:
            vheader.hide()

        if factory.show_row_titles and factory.auto_resize_rows:
            vheader.setResizeMode(QtGui.QHeaderView.ResizeToContents)
        else:
            # Set a default height for rows. Although setting the resize mode to
            # ResizeToContents would provide the best sizes, this is far too
            # expensive when the TabularEditor has a large amount of data. Instead,
            # we make a reasonable guess based on the minimum size hint and the font
            # of the first row.
            size = vheader.minimumSectionSize()
            font = editor.adapter.get_font(editor.object, editor.name, 0)
            if font is not None:
                size = max(size, QtGui.QFontMetrics(QtGui.QFont(font)).height())
            vheader.setDefaultSectionSize(size)

        # Configure the column headings.
        hheader = self.horizontalHeader()
        hheader.setStretchLastSection(factory.stretch_last_section)
        if factory.show_titles:
            hheader.setHighlightSections(False)
        else:
            hheader.hide()

        # Turn off the grid lines--we'll draw our own
        self.setShowGrid(False)
        self.setItemDelegate(_ItemDelegate(self))

        # Configure the selection behaviour.
        self.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
        if factory.multi_select:
            mode = QtGui.QAbstractItemView.ExtendedSelection
        else:
            mode = QtGui.QAbstractItemView.SingleSelection
        self.setSelectionMode(mode)

        # Configure drag and drop behavior
        self.setDragEnabled(True)
        if factory.editable:
            self.viewport().setAcceptDrops(True)
        if factory.drag_move:
            self.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
        self.setDropIndicatorShown(True)

    def keyPressEvent(self, event):
        """ Reimplemented to support edit, insert, and delete by keyboard.
        """
        editor = self._editor
        factory = editor.factory

        # Note that setting 'EditKeyPressed' as an edit trigger does not work on
        # most platforms, which is why we do this here.
        if (event.key() in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return) and
            self.state() != QtGui.QAbstractItemView.EditingState and
            factory.editable and 'edit' in factory.operations):
            if factory.multi_select:
                rows = editor.multi_selected_rows
                row = rows[0] if len(rows) == 1 else -1
            else:
                row = editor.selected_row

            if row != -1:
                event.accept()
                self.edit(editor.model.index(row, 0))

        elif (event.key() in (QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Delete) and
              factory.editable and 'delete' in factory.operations):
            event.accept()

            if factory.multi_select:
                for row in reversed(sorted(editor.multi_selected_rows)):
                    editor.model.removeRow(row)
            elif editor.selected_row != -1:
                editor.model.removeRow(editor.selected_row)

        elif (event.key() == QtCore.Qt.Key_Insert and
              factory.editable and 'insert' in factory.operations):
            event.accept()

            if factory.multi_select:
                rows = sorted(editor.multi_selected_rows)
                row = rows[0] if len(rows) else -1
            else:
                row = editor.selected_row
            if row == -1:
                row = editor.adapter.len(editor.object, editor.name)
            editor.model.insertRow(row)
            self.setCurrentIndex(editor.model.index(row, 0))

        else:
            QtGui.QTableView.keyPressEvent(self, event)

    def sizeHint(self):
        """ Reimplemented to define a reasonable size hint.
        """
        sh = QtGui.QTableView.sizeHint(self)

        width = 0
        for column in xrange(len(self._editor.adapter.columns)):
            width += self.sizeHintForColumn(column)
        sh.setWidth(width)

        return sh

    def resizeEvent(self, event):
        """ Reimplemented to size the table columns when the size of the table
            changes. Because the layout algorithm requires that the available
            space be known, we have to wait until the UI that contains this
            table gives it its initial size.
        """
        QtGui.QTableView.resizeEvent(self, event)

        parent = self.parent()
        if (not self._initial_size and parent and
            (self.isVisible() or isinstance(parent, QtGui.QMainWindow))):
            self._initial_size = True
            self.resizeColumnsToContents()

    def sizeHintForColumn(self, column):
        """ Reimplemented to support absolute width specification via
            TabularAdapters and to avoid scanning all data to determine the size
            hint. (TabularEditor, unlike TableEditor, is expected to handle very
            large data sets.)
        """
        editor = self._editor
        if editor.factory.auto_resize:
            # Use the default implementation.
            return super(_TableView, self).sizeHintForColumn(column)

        width = editor.adapter.get_width(editor.object, editor.name, column)
        if width > 1:
            return width
        else:
            return self.horizontalHeader().sectionSizeHint(column)

    def resizeColumnsToContents(self):
        """ Reimplemented to support proportional column width specifications.
            For information about the layout algorithm, see
            https://svn.enthought.com/enthought/wiki/Traits_3_0_tabular_editor.
        """
        editor = self._editor
        if editor.factory.auto_resize:
            # Use the default implementation.
            return super(_TableView, self).resizeColumnsToContents()
        available_space = self.viewport().width()
        hheader = self.horizontalHeader()

        # Assign sizes for columns with absolute size requests
        percent_vals, percent_cols = [], []
        for column in xrange(len(editor.adapter.columns)):
            width = editor.adapter.get_width(editor.object, editor.name, column)
            if width > 1:
                available_space -= width
                hheader.resizeSection(column, width)
            else:
                if width <= 0:
                    width = 0.1
                percent_vals.append(width)
                percent_cols.append(column)

        # Now use the remaining space for columns with proportional or no width
        # requests.
        percent_total = sum(percent_vals)
        for i, column in enumerate(percent_cols):
            percent = percent_vals[i] / percent_total
            width = max(30, int(percent * available_space))
            hheader.resizeSection(column, width)


########NEW FILE########
__FILENAME__ = tabular_model
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   06/22/2009
#
#-------------------------------------------------------------------------------

""" Defines the table model used by the tabular editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traitsui.ui_traits import SequenceTypes

from .clipboard import PyMimeData

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping for trait alignment values to qt4 alignment values:
alignment_map = {
    'left':    QtCore.Qt.AlignLeft,
    'right':   QtCore.Qt.AlignRight,
    'center':  QtCore.Qt.AlignHCenter,
    'justify': QtCore.Qt.AlignJustify
}

# MIME type for internal table drag/drop operations
tabular_mime_type = 'traits-ui-tabular-editor'

#-------------------------------------------------------------------------------
#  'TabularModel' class:
#-------------------------------------------------------------------------------

class TabularModel(QtCore.QAbstractTableModel):
    """ The model for tabular data."""

    def __init__(self, editor, parent=None):
        """ Initialise the object.
        """
        QtCore.QAbstractTableModel.__init__(self, parent)

        self._editor = editor

    #---------------------------------------------------------------------------
    #  QAbstractItemModel interface:
    #---------------------------------------------------------------------------

    def data(self, mi, role):
        """ Reimplemented to return the data.
        """
        editor = self._editor
        adapter = editor.adapter
        obj, name = editor.object, editor.name
        row, column = mi.row(), mi.column()

        if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:
            return adapter.get_text(obj, name, row, column)

        elif role == QtCore.Qt.DecorationRole:
            image = editor._get_image(adapter.get_image(obj, name, row, column))
            if image is not None:
                return image

        elif role == QtCore.Qt.ToolTipRole:
            tooltip = adapter.get_tooltip(obj, name, row, column)
            if tooltip:
                return tooltip

        elif role == QtCore.Qt.FontRole:
            font = adapter.get_font(obj, name, row, column)
            if font is not None:
                return QtGui.QFont(font)

        elif role == QtCore.Qt.TextAlignmentRole:
            string = adapter.get_alignment(obj, name, column)
            alignment = alignment_map.get(string, QtCore.Qt.AlignLeft)
            return (alignment | QtCore.Qt.AlignVCenter)

        elif role == QtCore.Qt.BackgroundRole:
            color = adapter.get_bg_color(obj, name, row, column)
            if color is not None:
                if isinstance(color, SequenceTypes):
                    q_color = QtGui.QColor(*color)
                else:
                    q_color = QtGui.QColor(color)
                return QtGui.QBrush(q_color)

        elif role == QtCore.Qt.ForegroundRole:
            color = adapter.get_text_color(obj, name, row, column)
            if color is not None:
                if isinstance(color, SequenceTypes):
                    q_color = QtGui.QColor(*color)
                else:
                    q_color = QtGui.QColor(color)
                return QtGui.QBrush(q_color)

        return None

    def setData(self, mi, value, role):
        """ Reimplmented to allow for modification for the object trait.
        """
        if role != QtCore.Qt.EditRole:
            return False

        editor = self._editor
        obj, name = editor.object, editor.name
        row, column = mi.row(), mi.column()

        editor.adapter.set_text(obj, name, row, column, value)
        signal = QtCore.SIGNAL('dataChanged(QModelIndex,QModelIndex)')
        self.emit(signal, mi, mi)
        return True

    def flags(self, mi):
        """ Reimplemented to set editable status and movable status.
        """
        editor = self._editor
        row = mi.row()
        column = mi.column()
        
        if not mi.isValid():
            return QtCore.Qt.ItemIsDropEnabled

        flags = QtCore.Qt.ItemIsEnabled
        if editor.factory.selectable:
            flags |= QtCore.Qt.ItemIsSelectable

        # If the adapter defines get_can_edit_cell(), use it to determine
        # editability over the row-wise get_can_edit().
        if (editor.factory.editable and 'edit' in editor.factory.operations and
                hasattr(editor.adapter, 'get_can_edit_cell')):
            if editor.adapter.get_can_edit_cell(editor.object, editor.name,
                                                row, column):
                flags |= QtCore.Qt.ItemIsEditable
        elif (editor.factory.editable and 'edit' in editor.factory.operations and
                editor.adapter.get_can_edit(editor.object, editor.name, row)):
            flags |= QtCore.Qt.ItemIsEditable

        if editor.adapter.get_drag(editor.object, editor.name, row) is not None:
            flags |= QtCore.Qt.ItemIsDragEnabled
            
        if editor.factory.editable:
            flags |=  QtCore.Qt.ItemIsDropEnabled

        return flags

    def headerData(self, section, orientation, role):
        """ Reimplemented to return the header data.
        """
        if role != QtCore.Qt.DisplayRole:
            return None

        editor = self._editor

        label = None
        if orientation == QtCore.Qt.Vertical:
            label = editor.adapter.get_row_label(section, editor.object)
        elif orientation == QtCore.Qt.Horizontal:
            label = editor.adapter.get_label(section, editor.object)

        return label

    def rowCount(self, mi):
        """ Reimplemented to return the number of rows.
        """
        editor = self._editor
        return editor.adapter.len(editor.object, editor.name)

    def columnCount(self, mi):
        """ Reimplemented to return the number of columns.
        """
        editor = self._editor
        return len(editor.adapter.columns)

    def insertRow(self, row, parent=QtCore.QModelIndex(), obj=None):
        """ Reimplemented to allow creation of new rows. Added an optional
            arg to allow the insertion of an existing row object.
        """
        editor = self._editor
        adapter = editor.adapter

        if obj is None:
            obj = adapter.get_default_value(editor.object, editor.name)
        self.beginInsertRows(parent, row, row)
        editor.callx(editor.adapter.insert, editor.object, editor.name, row, obj)
        self.endInsertRows()
        return True

    def insertRows(self, row, count, parent=QtCore.QModelIndex()):
        """ Reimplemented to allow creation of new items.
        """
        editor = self._editor
        adapter = editor.adapter

        self.beginInsertRows(parent, row, row + count - 1)
        for i in xrange(count):
            value = adapter.get_default_value(editor.object, editor.name)
            editor.callx(adapter.insert, editor.object, editor.name, row, value)
        self.endInsertRows()
        return True

    def removeRows(self, row, count, parent=QtCore.QModelIndex()):
        """ Reimplemented to allow row deletion, as well as reordering via drag
            and drop.
        """
        editor = self._editor
        adapter = editor.adapter
        self.beginRemoveRows(parent, row, row + count - 1)
        for i in xrange(count):
            editor.callx(adapter.delete, editor.object, editor.name, row)
        self.endRemoveRows()
        n = self.rowCount(None)
        if not editor.factory.multi_select:
            editor.selected_row = row if row < n else row-1
        else:
            #FIXME: what should the selection be?
            editor.multi_selected_rows = []
        return True

    def mimeTypes(self):
        """ Reimplemented to expose our internal MIME type for drag and drop
            operations.
        """
        return [ tabular_mime_type, PyMimeData.MIME_TYPE,
                PyMimeData.NOPICKLE_MIME_TYPE ]

    def mimeData(self, indexes):
        """ Reimplemented to generate MIME data containing the rows of the
            current selection.
        """
        rows = sorted(set([ index.row() for index in indexes ]))
        items = [self._editor.adapter.get_drag(
                self._editor.object, self._editor.name, row)
                for row in rows]
        mime_data = PyMimeData.coerce(items)
        data = QtCore.QByteArray(str(id(self)))
        for row in rows:
            data.append(' %i' % row)
        mime_data.setData(tabular_mime_type, data)
        return mime_data

    def dropMimeData(self, mime_data, action, row, column, parent):
        """ Reimplemented to allow items to be moved.
        """
        if action == QtCore.Qt.IgnoreAction:
            return False

        # this is a drag from a tabular model
        data = mime_data.data(tabular_mime_type)
        if not data.isNull() and action == QtCore.Qt.MoveAction:
            id_and_rows = map(int, str(data).split(' '))
            table_id = id_and_rows[0]
            # is it from ourself?
            if table_id == id(self):
                current_rows = id_and_rows[1:]
                self.moveRows(current_rows, parent.row())
                return True
        
        # this is an external drag
        data = PyMimeData.coerce(mime_data).instance()
        if data is not None:
            if not isinstance(data, list):
                data = [data]
            editor = self._editor
            object = editor.object
            name = editor.name
            adapter = editor.adapter
            if row == -1 and parent.isValid():
                # find correct row number
                row = parent.row()
            if row == -1 and adapter.len(object, name) == 0:
                # if empty list, target is after end of list
                row = 0
            if all(adapter.get_can_drop(object, name, row, item)
                                    for item in data):
                for item in reversed(data):
                    self.dropItem(item, row)
                return True
        return False

    def supportedDropActions(self):
        """ Reimplemented to allow items to be moved.
        """
        return QtCore.Qt.MoveAction

    #---------------------------------------------------------------------------
    #  TabularModel interface:
    #---------------------------------------------------------------------------

    def dropItem(self, item, row):
        """ Handle a Python object being dropped onto a row """
        editor = self._editor
        object = editor.object
        name = editor.name
        adapter = editor.adapter
        destination = adapter.get_dropped(object, name, row, item)
        
        if destination == 'after':
            row += 1
        
        adapter.insert(object, name, row, item)

    def moveRow(self, old_row, new_row):
        """ Convenience method to move a single row.
        """
        return self.moveRows([old_row], new_row)

    def moveRows(self, current_rows, new_row):
        """ Moves a sequence of rows (provided as a list of row indexes) to a
            new row.
        """
        editor = self._editor

        # Sort rows in descending order so they can be removed without
        # invalidating the indices.
        current_rows.sort()
        current_rows.reverse()

        # If the the highest selected row is lower than the destination, do an
        # insertion before rather than after the destination.
        if current_rows[-1] < new_row:
            new_row += 1

        # Remove selected rows...
        objects = []
        for row in current_rows:
            if row <= new_row:
                new_row -= 1
            obj = editor.adapter.get_item(editor.object, editor.name, row)
            objects.insert(0, obj)
            self.removeRow(row)

        # ...and add them at the new location.
        for i, obj in enumerate(objects):
            self.insertRow(new_row + i, obj=obj)

        # Update the selection for the new location.
        if editor.factory.multi_select:
            editor.setx(multi_selected = objects)
            editor.multi_selected_rows = range(new_row, new_row + len(objects))
        else:
            editor.setx(selected = objects[0])
            editor.selected_row = new_row

########NEW FILE########
__FILENAME__ = test_clipboard
#
# (C) Copyright 2013 Enthought, Inc., Austin, TX
# All rights reserved.
#
# This file is open source software distributed according to the terms in
# LICENSE.txt
#

import unittest
from cPickle import dumps

from pyface.qt import QtCore
from traitsui.qt4.clipboard import PyMimeData

class PMDSubclass(PyMimeData):
    pass

class PyMimeDataTestCase(unittest.TestCase):
    
    # Basic functionality tests
    
    def test_pickle(self):
        md = PyMimeData(data=0)
        self.assertEqual(md._local_instance, 0)
        self.assertTrue(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertFalse(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertEqual(bytes(md.data(PyMimeData.MIME_TYPE)), dumps(int)+dumps(0))
    
    def test_nopickle(self):
        md = PyMimeData(data=0, pickle=False)
        self.assertEqual(md._local_instance, 0)
        self.assertTrue(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertFalse(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertEqual(bytes(md.data(PyMimeData.NOPICKLE_MIME_TYPE)), str(id(0)))

    def test_cant_pickle(self):
        unpicklable = lambda: None
        md = PyMimeData(data=unpicklable)
        self.assertEqual(md._local_instance, unpicklable)
        self.assertTrue(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertFalse(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertEqual(bytes(md.data(PyMimeData.NOPICKLE_MIME_TYPE)), str(id(unpicklable)))

    def test_coerce_pymimedata(self):
        md = PyMimeData(data=0)
        md2 = PyMimeData.coerce(md)
        self.assertEqual(md, md2)
        
    def test_coerce_subclass(self):
        md = PMDSubclass(data=0)
        md2 = PyMimeData.coerce(md)
        self.assertEqual(md, md2)
        
    def test_coerce_QMimeData(self):
        md = QtCore.QMimeData()
        md.setText("test")
        md2 = PyMimeData.coerce(md)
        self.assertTrue(md2.hasText())
        self.assertEqual(md2.text(), "test")
        
    def test_coerce_object(self):
        md = PyMimeData.coerce(0)
        self.assertEqual(md._local_instance, 0)
        self.assertTrue(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertFalse(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertEqual(bytes(md.data(PyMimeData.MIME_TYPE)), dumps(int)+dumps(0))
        
    def test_coerce_unpicklable(self):
        unpicklable = lambda: None
        md = PyMimeData.coerce(unpicklable)
        self.assertEqual(md._local_instance, unpicklable)
        self.assertFalse(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertTrue(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        
    def test_coerce_list(self):
        md = PyMimeData.coerce([0])
        self.assertEqual(md._local_instance, [0])
        self.assertTrue(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertFalse(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertEqual(bytes(md.data(PyMimeData.MIME_TYPE)), dumps(list)+dumps([0]))
        
    def test_coerce_list_pymimedata(self):
        md = PyMimeData(data=0)
        md2 = PyMimeData.coerce([md])
        self.assertEqual(md2._local_instance, [0])
        self.assertTrue(md2.hasFormat(PyMimeData.MIME_TYPE))
        self.assertFalse(md2.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertEqual(bytes(md2.data(PyMimeData.MIME_TYPE)), dumps(list)+dumps([0]))
        
    def test_coerce_list_pymimedata_nopickle(self):
        md = PyMimeData(data=0, pickle=False)
        md2 = PyMimeData.coerce([md])
        self.assertEqual(md2._local_instance, [0])
        self.assertFalse(md2.hasFormat(PyMimeData.MIME_TYPE))
        self.assertTrue(md2.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        
    def test_coerce_list_pymimedata_mixed(self):
        md1 = PyMimeData(data=0, pickle=False)
        md2 = PyMimeData(data=0)
        md = PyMimeData.coerce([md1, md2])
        self.assertEqual(md._local_instance, [0, 0])
        self.assertFalse(md.hasFormat(PyMimeData.MIME_TYPE))
        self.assertTrue(md.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        
    def test_subclass_coerce_pymimedata(self):
        md = PyMimeData(data=0)
        md2 = PMDSubclass.coerce(md)
        self.assertTrue(isinstance(md2, PMDSubclass))
        self.assertTrue(md2.hasFormat(PyMimeData.MIME_TYPE))
        self.assertFalse(md2.hasFormat(PyMimeData.NOPICKLE_MIME_TYPE))
        self.assertEqual(bytes(md2.data(PyMimeData.MIME_TYPE)), dumps(int)+dumps(0))
        
    def test_instance(self):
        md = PyMimeData(data=0)
        self.assertEqual(md.instance(), 0)
    
    def test_instance_unpickled(self):
        md = PyMimeData(data=0)
        # remove local instance to simulate cross-process
        md._local_instance = None
        self.assertEqual(md.instance(), 0)
    
    def test_instance_nopickle(self):
        md = PyMimeData(data=0, pickle=False)
        # remove local instance to simulate cross-process
        md._local_instance = None
        self.assertEqual(md.instance(), None)
    
    def test_instance_type(self):
        md = PyMimeData(data=0)
        self.assertEqual(md.instanceType(), int)
    
    def test_instance_type_unpickled(self):
        md = PyMimeData(data=0)
        # remove local instance to simulate cross-process
        md._local_instance = None
        self.assertEqual(md.instanceType(), int)

    def test_instance_type_nopickle(self):
        md = PyMimeData(data=0, pickle=False)
        # remove local instance to simulate cross-process
        md._local_instance = None
        self.assertEqual(md.instanceType(), None)
        

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = text_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the various text editors for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.qt import QtCore, QtGui

from traits.api \
    import TraitError

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.text_editor file.
from traitsui.editors.text_editor \
    import evaluate_trait, ToolkitEditorFactory

from editor \
    import Editor

from editor_factory \
    import ReadonlyEditor as BaseReadonlyEditor

from constants \
    import OKColor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style text editor, which displays a text field.
    """

    # Flag for window styles:
    base_style = QtGui.QLineEdit

    # Background color when input is OK:
    ok_color = OKColor

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function used to evaluate textual user input:
    evaluate = evaluate_trait

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        wtype = self.base_style
        self.evaluate = factory.evaluate
        self.sync_value(factory.evaluate_name, 'evaluate', 'from')

        if not factory.multi_line or factory.is_grid_cell or factory.password:
            wtype = QtGui.QLineEdit

        multi_line = (wtype is not QtGui.QLineEdit)
        if multi_line:
            self.scrollable = True

        control = wtype(self.str_value)

        if factory.read_only:
            control.setReadOnly(True)

        if factory.password:
            control.setEchoMode(QtGui.QLineEdit.Password)

        if factory.auto_set and not factory.is_grid_cell:
            if wtype == QtGui.QTextEdit:
                QtCore.QObject.connect(control,
                    QtCore.SIGNAL('textChanged()'), self.update_object)
            else:
                QtCore.QObject.connect(control,
                    QtCore.SIGNAL('textEdited(QString)'), self.update_object)

        else:
            # Assume enter_set is set, otherwise the value will never get
            # updated.
            QtCore.QObject.connect(control, QtCore.SIGNAL('editingFinished()'),
                    self.update_object)

        self.control = control
        self.set_error_state( False )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self ):
        """ Handles the user entering input data in the edit control.
        """
        if (not self._no_update) and (self.control is not None):
            try:
                self.value = self._get_user_value()

                if self._error is not None:
                    self._error = None
                    self.ui.errors -= 1

                self.set_error_state( False )

            except TraitError, excp:
                pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        user_value = self._get_user_value()
        try:
            unequal = bool(user_value != self.value)
        except ValueError:
            # This might be a numpy array.
            unequal = True

        if unequal:
            self._no_update = True
            self.control.setText(self.str_value)
            self._no_update = False

        if self._error is not None:
            self._error = None
            self.ui.errors -= 1
            self.set_error_state( False )

    #---------------------------------------------------------------------------
    #  Gets the actual value corresponding to what the user typed:
    #---------------------------------------------------------------------------

    def _get_user_value ( self ):
        """ Gets the actual value corresponding to what the user typed.
        """
        try:
            value = self.control.text()
        except AttributeError:
            value = self.control.toPlainText()

        value = unicode(value)

        try:
            value = self.evaluate( value )
        except:
            pass

        try:
            ret = self.factory.mapping.get(value, value)
        except TypeError:
            # The value is probably not hashable.
            ret = value

        return ret

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        if self._error is None:
            self._error = True
            self.ui.errors += 1

        self.set_error_state( True )

    #---------------------------------------------------------------------------
    #  Returns whether or not the editor is in an error state:
    #---------------------------------------------------------------------------

    def in_error_state ( self ):
        """ Returns whether or not the editor is in an error state.
        """
        return (self.invalid or self._error)

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of text editor, which displays a multi-line text field.
    """

    # FIXME: The wx version exposes a wx constant.
    # Flag for window style. This value overrides the default.
    base_style = QtGui.QTextEdit

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( BaseReadonlyEditor ):
    """ Read-only style of text editor, which displays a read-only text field.
    """

    def init(self, parent):
        super(ReadonlyEditor, self).init(parent)

        if self.factory.readonly_allow_selection:
            flags = (self.control.textInteractionFlags() |
                QtCore.Qt.TextSelectableByMouse)
            self.control.setTextInteractionFlags(flags)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        new_value = self.str_value

        if self.factory.password:
            new_value = '*' * len(new_value)

        self.control.setText(new_value)

########NEW FILE########
__FILENAME__ = time_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   08/04/2009
#
#------------------------------------------------------------------------------

""" A Traits UI editor for datetime.time objects.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import datetime

from pyface.qt import QtCore, QtGui

from editor import Editor
from editor_factory import ReadonlyEditor as BaseReadonlyEditor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor(Editor):
    """ Simple Traits UI time editor that wraps QTimeEdit.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = QtGui.QTimeEdit()

        signal = QtCore.SIGNAL('timeChanged(QTime)')
        QtCore.QObject.connect(self.control, signal, self.update_object)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        if value:
            q_date = QtCore.QTime(value.hour, value.minute, value.second)
            self.control.setTime(q_date)

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object(self, q_time):
        """ Handles the user entering input data in the edit control.
        """
        hour = q_time.hour()
        minute = q_time.minute()
        second = q_time.second()
        try:
            self.value = datetime.time(hour, minute, second)
        except ValueError:
            print 'Invalid time:', hour, minute, second
            raise

#------------------------------------------------------------------------------
# 'ReadonlyEditor' class:
#------------------------------------------------------------------------------

class ReadonlyEditor(BaseReadonlyEditor):
    """ Readonly Traits UI time editor that uses a QLabel for the view.
    """

    def _get_str_value(self):
        """ Replace the default string value with our own time verision.
        """
        if not self.value:
            return self.factory.message
        else:
            return self.value.strftime(self.factory.strftime)

########NEW FILE########
__FILENAME__ = title_editor
#------------------------------------------------------------------------------
# Copyright (c) 2008, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from pyface.qt import QtCore

from .editor import Editor

from pyface.heading_text import HeadingText

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.title_editor file.
from ..editors.title_editor import TitleEditor


class SimpleEditor ( Editor ):

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._control = HeadingText( None )
        self.control  = self._control.control
        if self.factory.allow_selection:
            flags = (self.control.textInteractionFlags() |
                QtCore.Qt.TextSelectableByMouse)
            self.control.setTextInteractionFlags(flags)
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        self._control.text = self.str_value

CustomEditor = SimpleEditor
ReadonlyEditor = SimpleEditor
TextEditor = SimpleEditor

########NEW FILE########
__FILENAME__ = toolkit
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described
# in the PyQt GPL exception also apply.
#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the concrete implementations of the traits Toolkit interface for
the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# Make sure that importing from this backend is OK:
from traitsui.toolkit import assert_toolkit_import
assert_toolkit_import('qt4')

from pyface.qt import QtCore, QtGui, qt_api

if qt_api == 'pyqt':
    # Check the version numbers are late enough:
    if QtCore.QT_VERSION < 0x040200:
        raise RuntimeError, "Need Qt v4.2 or higher, but got v%s" % QtCore.QT_VERSION_STR

# Make sure a QApplication object is created early:
import sys
if QtGui.QApplication.startingUp():
    _app = QtGui.QApplication(sys.argv)

from traits.trait_notifiers import set_ui_handler

from traitsui.toolkit import Toolkit

from constants import screen_dx, screen_dy

#-------------------------------------------------------------------------------
#  Handles UI notification handler requests that occur on a thread other than
#  the UI thread:
#-------------------------------------------------------------------------------

_QT_TRAITS_EVENT = QtCore.QEvent.Type(QtCore.QEvent.registerEventType())

class _CallAfter(QtCore.QObject):
    """ This class dispatches a handler so that it executes in the main GUI
        thread (similar to the wx function).
    """

    # The list of pending calls.
    _calls = []

    # The mutex around the list of pending calls.
    _calls_mutex = QtCore.QMutex()

    def __init__(self, handler, *args, **kwds):
        """ Initialise the call.
        """
        QtCore.QObject.__init__(self)

        # Save the details of the call.
        self._handler = handler
        self._args = args
        self._kwds = kwds

        # Add this to the list.
        self._calls_mutex.lock()
        self._calls.append(self)
        self._calls_mutex.unlock()

        # Move to the main GUI thread.
        self.moveToThread(QtGui.QApplication.instance().thread())

        # Post an event to be dispatched on the main GUI thread. Note that
        # we do not call QTimer.singleShot, which would be simpler, because
        # that only works on QThreads. We want regular Python threads to work.
        event = QtCore.QEvent(_QT_TRAITS_EVENT)
        QtGui.QApplication.instance().postEvent(self, event)

    def event(self, event):
        """ QObject event handler.
        """
        if event.type() == _QT_TRAITS_EVENT:
            # Invoke the handler
            self._handler(*self._args, **self._kwds)

            # We cannot remove from self._calls here. QObjects don't like being
            # garbage collected during event handlers (there are tracebacks,
            # plus maybe a memory leak, I think).
            QtCore.QTimer.singleShot(0, self._finished)

            return True
        else:
            return QtCore.QObject.event(self, event)

    def _finished(self):
        """ Remove the call from the list, so it can be garbage collected.
        """
        self._calls_mutex.lock()
        del self._calls[self._calls.index(self)]
        self._calls_mutex.unlock()

def ui_handler ( handler, *args, **kwds ):
    """ Handles UI notification handler requests that occur on a thread other
        than the UI thread.
    """
    _CallAfter(handler, *args, **kwds)

# Tell the traits notification handlers to use this UI handler
set_ui_handler( ui_handler )

#-------------------------------------------------------------------------------
#  'GUIToolkit' class:
#-------------------------------------------------------------------------------

class GUIToolkit ( Toolkit ):
    """ Implementation class for PyQt toolkit.
    """
    #---------------------------------------------------------------------------
    #  Create PyQt specific user interfaces using information from the
    #  specified UI object:
    #---------------------------------------------------------------------------

    def ui_panel ( self, ui, parent ):
        """ Creates a PyQt panel-based user interface using information
            from the specified UI object.
        """
        import ui_panel
        ui_panel.ui_panel( ui, parent )

    def ui_subpanel ( self, ui, parent ):
        """ Creates a PyQt subpanel-based user interface using information
            from the specified UI object.
        """
        import ui_panel
        ui_panel.ui_subpanel( ui, parent )

    def ui_livemodal ( self, ui, parent ):
        """ Creates a PyQt modal "live update" dialog user interface using
            information from the specified UI object.
        """
        import ui_live
        ui_live.ui_livemodal( ui, parent )

    def ui_live ( self, ui, parent ):
        """ Creates a PyQt non-modal "live update" window user interface
            using information from the specified UI object.
        """
        import ui_live
        ui_live.ui_live( ui, parent )

    def ui_modal ( self, ui, parent ):
        """ Creates a PyQt modal dialog user interface using information
            from the specified UI object.
        """
        import ui_modal
        ui_modal.ui_modal( ui, parent )

    def ui_nonmodal ( self, ui, parent ):
        """ Creates a PyQt non-modal dialog user interface using
            information from the specified UI object.
        """
        import ui_modal
        ui_modal.ui_nonmodal( ui, parent )

    def ui_wizard ( self, ui, parent ):
        """ Creates a PyQt wizard dialog user interface using information
            from the specified UI object.
        """
        import ui_wizard
        ui_wizard.ui_wizard( ui, parent )

    def view_application ( self, context, view, kind = None, handler = None,
                                     id = '', scrollable = None, args = None ):
        """ Creates a PyQt modal dialog user interface that
            runs as a complete application, using information from the
            specified View object.

        Parameters
        ----------
        context : object or dictionary
            A single object or a dictionary of string/object pairs, whose trait
            attributes are to be edited. If not specified, the current object is
            used.
        view : view or string
            A View object that defines a user interface for editing trait
            attribute values.
        kind : string
            The type of user interface window to create. See the
            **traitsui.view.kind_trait** trait for values and
            their meanings. If *kind* is unspecified or None, the **kind**
            attribute of the View object is used.
        handler : Handler object
            A handler object used for event handling in the dialog box. If
            None, the default handler for Traits UI is used.
        id : string
            A unique ID for persisting preferences about this user interface,
            such as size and position. If not specified, no user preferences
            are saved.
        scrollable : Boolean
            Indicates whether the dialog box should be scrollable. When set to
            True, scroll bars appear on the dialog box if it is not large enough
            to display all of the items in the view at one time.

        """
        import view_application
        return view_application.view_application( context, view, kind, handler,
                                                  id, scrollable, args )

    #---------------------------------------------------------------------------
    #  Positions the associated dialog window on the display:
    #---------------------------------------------------------------------------

    def position ( self, ui ):
        """ Positions the associated dialog window on the display.
        """
        view   = ui.view
        window = ui.control

        # Set up the default position of the window:
        parent = window.parent()
        if parent is None:
            px = 0
            py = 0
            pdx = screen_dx
            pdy = screen_dy
        else:
            pos = parent.pos()
            if int(parent.windowFlags()) & QtCore.Qt.Window == 0 :
                pos = parent.mapToGlobal(pos)
            px = pos.x()
            py = pos.y()
            pdx = parent.width()
            pdy = parent.height()

        # Get the window's prefered size.
        size_hint = window.sizeHint()

        # Calculate the correct width and height for the window:
        cur_width = size_hint.width()
        cur_height = size_hint.height()
        width  = view.width
        height = view.height

        if width < 0.0:
            width = cur_width
        elif width <= 1.0:
            width = int( width * screen_dx )
        else:
            width = int( width )

        if height < 0.0:
            height = cur_height
        elif height <= 1.0:
            height = int( height * screen_dy )
        else:
            height = int( height )

        # Calculate the correct position for the window:
        x = view.x
        y = view.y

        if x < -99999.0:
            x = px + ((pdx - width) / 2)
        elif x <= -1.0:
            x = px + pdx - width + int( x ) + 1
        elif x < 0.0:
            x = px + pdx - width + int( x * pdx )
        elif x <= 1.0:
            x = px + int( x * pdx )
        else:
            x = int( x )

        if y < -99999.0:
            y = py + ((pdy - height) / 2)
        elif y <= -1.0:
            y = py + pdy - height + int( y ) + 1
        elif x < 0.0:
            y = py + pdy - height + int( y * pdy )
        elif y <= 1.0:
            y = py + int( y * pdy )
        else:
            y = int( y )

        # Position and size the window as requested:
        layout = window.layout()
        if layout.sizeConstraint() == QtGui.QLayout.SetFixedSize:
            layout.setSizeConstraint( QtGui.QLayout.SetDefaultConstraint )
            window.move( max( 0, x ), max( 0, y ) )
            window.setFixedSize( QtCore.QSize ( width, height ) )
        else:
            window.setGeometry( max( 0, x ), max( 0, y ), width, height )

    #---------------------------------------------------------------------------
    #  Shows a 'Help' window for a specified UI and control:
    #---------------------------------------------------------------------------

    def show_help ( self, ui, control ):
        """ Shows a help window for a specified UI and control.
        """
        import ui_panel
        ui_panel.show_help(ui, control)

    #---------------------------------------------------------------------------
    #  Saves user preference information associated with a UI window:
    #---------------------------------------------------------------------------

    def save_window ( self, ui ):
        """ Saves user preference information associated with a UI window.
        """
        import helper
        helper.save_window(ui)

    #---------------------------------------------------------------------------
    #  Rebuilds a UI after a change to the content of the UI:
    #---------------------------------------------------------------------------

    def rebuild_ui ( self, ui ):
        """ Rebuilds a UI after a change to the content of the UI.
        """
        if ui.control is not None:
            ui.recycle()
            ui.info.ui = ui
        ui.rebuild( ui, ui.parent )

    #---------------------------------------------------------------------------
    #  Sets the title for the UI window:
    #---------------------------------------------------------------------------

    def set_title ( self, ui ):
        """ Sets the title for the UI window.
        """
        ui.control.setWindowTitle(ui.title)

    #---------------------------------------------------------------------------
    #  Sets the icon for the UI window:
    #---------------------------------------------------------------------------

    def set_icon ( self, ui ):
        """ Sets the icon for the UI window.
        """
        from pyface.image_resource import ImageResource

        if isinstance(ui.icon, ImageResource):
            ui.control.setWindowIcon(ui.icon.create_icon())

    #---------------------------------------------------------------------------
    #  Converts a keystroke event into a corresponding key name:
    #---------------------------------------------------------------------------

    def key_event_to_name ( self, event ):
        """ Converts a keystroke event into a corresponding key name.
        """
        import key_event_to_name
        return key_event_to_name.key_event_to_name( event )

    #---------------------------------------------------------------------------
    #  Hooks all specified events for all controls in a ui so that they can be
    #  routed to the correct event handler:
    #---------------------------------------------------------------------------

    def hook_events ( self, ui, control, events = None, handler = None ):
        """ Hooks all specified events for all controls in a UI so that they
            can be routed to the correct event handler.
        """
        if events is None:
            # FIXME: Implement drag and drop events ala toolkit.py for wx
            return

        elif events == 'keys':
            class KeyEventHook(QtCore.QObject):
                def eventFilter(self, object, event):
                    if event.type() == QtCore.QEvent.KeyPress:
                        return handler(event)
                    else:
                        return QtCore.QObject.eventFilter(self, object, event)

            # It's unsafe to parent the event filter with the object it's
            # filtering, so we store a reference to it here to ensure that it's
            # not garbage collected prematurely.
            ui._key_event_hook = KeyEventHook()
            control.installEventFilter(ui._key_event_hook)

    #---------------------------------------------------------------------------
    #  Indicates that an event should continue to be processed by the toolkit
    #---------------------------------------------------------------------------

    def skip_event ( self, event ):
        """ Indicates that an event should continue to be processed by the
            toolkit.
        """
        event.ignore()

    #---------------------------------------------------------------------------
    #  Destroys a specified GUI toolkit control:
    #---------------------------------------------------------------------------

    def destroy_control ( self, control ):
        """ Destroys a specified GUI toolkit control.
        """
        # Block signals to prevent any editors from being updated (the control
        # will not be deleted immediately).
        control.blockSignals(True)

        # This may be called from within the finished() signal handler so we
        # need to do the delete after the handler has returned.
        control.hide()
        control.deleteLater()

        # PyQt v4.3.1 and earlier deleteLater() didn't transfer ownership to
        # C++, which is necessary for the QObject system to garbage collect it.
        if qt_api == 'pyqt':
            if QtCore.PYQT_VERSION < 0x040302:
                import sip
                sip.transferto(control, None)

    #---------------------------------------------------------------------------
    #  Destroys all of the child controls of a specified GUI toolkit control:
    #---------------------------------------------------------------------------

    def destroy_children ( self, control ):
        """ Destroys all of the child controls of a specified GUI toolkit
            control.
        """
        for w in control.children():
            # Only destroy widgets.
            if isinstance(w, QtGui.QWidget):
                # This may be called from within the finished() signal handler
                # so we need to do the delete after the handler has returned.
                w.deleteLater()

    #---------------------------------------------------------------------------
    #  Returns a ( width, height ) tuple containing the size of a specified
    #  toolkit image:
    #---------------------------------------------------------------------------

    def image_size ( self, image ):
        """ Returns a ( width, height ) tuple containing the size of a
            specified toolkit image.
        """
        return ( image.width(), image.height() )

    #---------------------------------------------------------------------------
    #  Returns a dictionary of useful constants:
    #---------------------------------------------------------------------------

    def constants ( self ):
        """ Returns a dictionary of useful constants.

            Currently, the dictionary should have the following key/value pairs:

            - 'WindowColor': the standard window background color in the toolkit
              specific color format.
        """
        return {
            'WindowColor': QtGui.QApplication.palette().color(QtGui.QPalette.Window),
        }

    #---------------------------------------------------------------------------
    #  GUI toolkit dependent trait definitions:
    #---------------------------------------------------------------------------

    def color_trait ( self, *args, **traits ):
        import color_trait as ct
        return ct.PyQtColor( *args, **traits )

    def rgb_color_trait ( self, *args, **traits ):
        import rgb_color_trait as rgbct
        return rgbct.RGBColor( *args, **traits )

    def font_trait ( self, *args, **traits ):
        import font_trait as ft
        return ft.PyQtFont( *args, **traits )

    #---------------------------------------------------------------------------
    #  'Editor' class methods:
    #---------------------------------------------------------------------------

    # Generic UI-base editor:
    def ui_editor ( self ):
        import ui_editor
        return ui_editor.UIEditor

    #---------------------------------------------------------------------------
    #  'EditorFactory' factory methods:
    #---------------------------------------------------------------------------

    # Array:
    def array_editor ( self, *args, **traits ):
        import array_editor as ae
        return ae.ToolkitEditorFactory( *args, **traits )

    # Boolean:
    def boolean_editor ( self, *args, **traits ):
        import boolean_editor as be
        return be.ToolkitEditorFactory( *args, **traits )

    # Button:
    def button_editor ( self, *args, **traits ):
        import button_editor as be
        return be.ToolkitEditorFactory( *args, **traits )

    # Check list:
    def check_list_editor ( self, *args, **traits ):
        import check_list_editor as cle
        return cle.ToolkitEditorFactory( *args, **traits )

    # Code:
    def code_editor ( self, *args, **traits ):
        import code_editor as ce
        return ce.ToolkitEditorFactory( *args, **traits )

    # Color:
    def color_editor ( self, *args, **traits ):
        import color_editor as ce
        return ce.ToolkitEditorFactory( *args, **traits )

    # Compound:
    def compound_editor ( self, *args, **traits ):
        import compound_editor as ce
        return ce.ToolkitEditorFactory( *args, **traits )

    def styled_date_editor ( self, *args, **traits ):
        import styled_date_editor as sde
        return sde.ToolkitEditorFactory( *args, **traits )

    # Custom:
    def custom_editor ( self, *args, **traits ):
        import custom_editor as ce
        return ce.ToolkitEditorFactory( *args, **traits )

    # Directory:
    def directory_editor ( self, *args, **traits ):
        import directory_editor as de
        return de.ToolkitEditorFactory( *args, **traits)

    # Drop (drag and drop target):
    def drop_editor ( self, *args, **traits ):
        import drop_editor as de
        return de.ToolkitEditorFactory( *args, **traits)

    # Drag and drop:
    def dnd_editor ( self, *args, **traits ):
        import dnd_editor as dnd
        return dnd.ToolkitEditorFactory( *args, **traits)

    # Enum(eration):
    def enum_editor ( self, *args, **traits ):
        import enum_editor as ee
        return ee.ToolkitEditorFactory( *args, **traits )

    # File:
    def file_editor ( self, *args, **traits ):
        import file_editor as fe
        return fe.ToolkitEditorFactory( *args, **traits )

    # Font:
    def font_editor ( self, *args, **traits ):
        import font_editor as fe
        return fe.ToolkitEditorFactory( *args, **traits )

    # Key Binding:
    def key_binding_editor ( self, *args, **traits ):
        import key_binding_editor as kbe
        return kbe.ToolkitEditorFactory( *args, **traits )

    # History:
    def history_editor ( self, *args, **traits ):
        import history_editor as he
        return he.HistoryEditor( *args, **traits )

    # HTML:
    def html_editor ( self, *args, **traits ):
        import html_editor as he
        return he.ToolkitEditorFactory( *args, **traits )

    # Image:
    def image_editor ( self, *args, **traits ):
        import image_editor as ie
        return ie.ImageEditor( *args, **traits )

    # Image enum(eration):
    def image_enum_editor ( self, *args, **traits ):
        import image_enum_editor as iee
        return iee.ToolkitEditorFactory( *args, **traits )

    # Instance:
    def instance_editor ( self, *args, **traits ):
        import instance_editor as ie
        return ie.ToolkitEditorFactory( *args, **traits )

    # List:
    def list_editor ( self, *args, **traits ):
        import list_editor as le
        return le.ToolkitEditorFactory( *args, **traits )

    # ListStr:
    def list_str_editor ( self, *args, **traits ):
        import list_str_editor as lse
        return lse.ListStrEditor( *args, **traits )

    # Null:
    def null_editor ( self, *args, **traits ):
        import null_editor as ne
        return ne.ToolkitEditorFactory( *args, **traits )

    # Ordered set:
    def ordered_set_editor ( self, *args, **traits ):
        import ordered_set_editor as ose
        return ose.ToolkitEditorFactory( *args, **traits )

    # Plot:
    def plot_editor ( self, *args, **traits ):
        import plot_editor as pe
        return pe.ToolkitEditorFactory( *args, **traits )

    # Range:
    def range_editor ( self, *args, **traits ):
        import range_editor as re
        return re.ToolkitEditorFactory( *args, **traits )

    # RGB Color:
    def rgb_color_editor ( self, *args, **traits ):
        import rgb_color_editor as rgbce
        return rgbce.ToolkitEditorFactory( *args, **traits )

    # Set:
    def set_editor ( self, *args, **traits ):
        import set_editor as se
        return se.ToolkitEditorFactory( *args, **traits )

    # Shell:
    def shell_editor ( self, *args, **traits ):
        import shell_editor as se
        return se.ToolkitEditorFactory( *args, **traits )

    # Table:
    def table_editor ( self, *args, **traits ):
        import table_editor as te
        return te.ToolkitEditorFactory( *args, **traits )

    # Tabular:
    def tabular_editor ( self, *args, **traits ):
        import tabular_editor as te
        return te.TabularEditor( *args, **traits )

    # Text:
    def text_editor ( self, *args, **traits ):
        import text_editor as te
        return te.ToolkitEditorFactory( *args, **traits )

    # Title:
    def title_editor ( self, *args, **traits ):
        import title_editor
        return title_editor.TitleEditor( *args, **traits )

    # Tree:
    def tree_editor ( self, *args, **traits ):
        import tree_editor as te
        return te.ToolkitEditorFactory( *args, **traits )

    # Tuple:
    def tuple_editor ( self, *args, **traits ):
        import tuple_editor as te
        return te.ToolkitEditorFactory( *args, **traits )

    # Value:
    def value_editor ( self, *args, **traits ):
        import value_editor as ve
        return ve.ToolkitEditorFactory( *args, **traits )

########NEW FILE########
__FILENAME__ = tree_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the tree editor for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import copy
import collections
import logging

from pyface.qt import QtCore, QtGui

from pyface.resource_manager import resource_manager
from pyface.timer.api import do_later
from traits.api import Any, Event
from traits.trait_base import enumerate
from traitsui.api import TreeNode, ObjectTreeNode, MultiTreeNode
from traitsui.undo import ListUndoItem
from traitsui.tree_node import ITreeNodeAdapterBridge
from traitsui.menu import Menu, Action, Separator

from clipboard import clipboard, PyMimeData
from editor import Editor
from helper import pixmap_cache

logger = logging.getLogger(__name__)

#-------------------------------------------------------------------------------
#  The core tree node menu actions:
#-------------------------------------------------------------------------------
from traitsui.ui_traits import SequenceTypes


NewAction    = 'NewAction'
CopyAction   = Action( name         = 'Copy',
                       action       = 'editor._menu_copy_node',
                       enabled_when = 'editor._is_copyable(object)' )
CutAction    = Action( name         = 'Cut',
                       action       = 'editor._menu_cut_node',
                       enabled_when = 'editor._is_cutable(object)' )
PasteAction  = Action( name         = 'Paste',
                       action       = 'editor._menu_paste_node',
                       enabled_when = 'editor._is_pasteable(object)' )
DeleteAction = Action( name         = 'Delete',
                       action       = 'editor._menu_delete_node',
                       enabled_when = 'editor._is_deletable(object)' )
RenameAction = Action( name         = 'Rename',
                       action       = 'editor._menu_rename_node',
                       enabled_when = 'editor._is_renameable(object)' )

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of tree editor.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the tree editor is scrollable? This value overrides the default.
    scrollable = True

    # Allows an external agent to set the tree selection
    selection = Event

    # The currently selected object
    selected = Any

    # The event fired when a tree node is activated by double clicking or
    # pressing the Enter key on a node.
    activated = Event

    # The event fired when a tree node is clicked on:
    click = Event

    # The event fired when a tree node is double-clicked on:
    dclick = Event

    # The event fired when the application wants to veto an operation:
    veto = Event

    # The vent fired when the application wants to refresh the viewport.
    refresh = Event

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit widget
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        self._editor = None

        if factory.editable:

            # Check to see if the tree view is based on a shared trait editor:
            if factory.shared_editor:
                factory_editor = factory.editor

                # If this is the editor that defines the trait editor panel:
                if factory_editor is None:

                    # Remember which editor has the trait editor in the factory:
                    factory._editor = self

                    # Create the trait editor panel:
                    self.control = sa = QtGui.QScrollArea()
                    sa.setFrameShape(QtGui.QFrame.NoFrame)
                    sa.setWidgetResizable(True)
                    self.control._node_ui = self.control._editor_nid = None

                    # Check to see if there are any existing editors that are
                    # waiting to be bound to the trait editor panel:
                    editors = factory._shared_editors
                    if editors is not None:
                        for editor in factory._shared_editors:

                            # If the editor is part of this UI:
                            if editor.ui is self.ui:

                                # Then bind it to the trait editor panel:
                                editor._editor = self.control

                        # Indicate all pending editors have been processed:
                        factory._shared_editors = None

                    # We only needed to build the trait editor panel, so exit:
                    return

                # Check to see if the matching trait editor panel has been
                # created yet:
                editor = factory_editor._editor
                if (editor is None) or (editor.ui is not self.ui):
                    # If not, add ourselves to the list of pending editors:
                    shared_editors = factory_editor._shared_editors
                    if shared_editors is None:
                        factory_editor._shared_editors = shared_editors = []
                    shared_editors.append( self )
                else:
                    # Otherwise, bind our trait editor panel to the shared one:
                    self._editor = editor.control

                # Finally, create only the tree control:
                self.control = self._tree = _TreeWidget(self)
            else:
                # If editable, create a tree control and an editor panel:
                self._tree = _TreeWidget(self)

                self._editor = sa = QtGui.QScrollArea()
                sa.setFrameShape(QtGui.QFrame.NoFrame)
                sa.setWidgetResizable(True)
                sa._node_ui = sa._editor_nid = None

                if factory.orientation == 'horizontal':
                    orient = QtCore.Qt.Horizontal
                else:
                    orient = QtCore.Qt.Vertical

                self.control = splitter = QtGui.QSplitter(orient)
                splitter.setSizePolicy(QtGui.QSizePolicy.Expanding,
                                       QtGui.QSizePolicy.Expanding)
                splitter.addWidget(self._tree)
                splitter.addWidget(sa)
        else:
            # Otherwise, just create the tree control:
            self.control = self._tree = _TreeWidget(self)

        # Set up the mapping between objects and tree id's:
        self._map = {}

        # Initialize the 'undo state' stack:
        self._undoable = []

        # Synchronize external object traits with the editor:
        self.sync_value( factory.refresh,  'refresh' )
        self.sync_value( factory.selected, 'selected' )
        self.sync_value( factory.activated,'activated', 'to' )
        self.sync_value( factory.click,    'click',  'to' )
        self.sync_value( factory.dclick,   'dclick', 'to' )
        self.sync_value( factory.veto,     'veto',   'from' )

    #---------------------------------------------------------------------------
    #  Handles the 'selection' trait being changed:
    #---------------------------------------------------------------------------

    def _selection_changed ( self, selection ):
        """ Handles the **selection** event.
        """
        try:
            tree = self._tree
            if (not isinstance(selection, basestring) and
                isinstance(selection, collections.Iterable)):

                item_selection = QtGui.QItemSelection()
                for sel in selection:
                    item = self._object_info(sel)[2]
                    idx = tree.indexFromItem(item)
                    item_selection.append(QtGui.QItemSelectionRange(idx))

                tree.selectionModel().select(item_selection,
                    QtGui.QItemSelectionModel.ClearAndSelect)
            else:
                tree.setCurrentItem(self._object_info(selection)[2])
        except:
            from traitsui.api import raise_to_debug
            raise_to_debug()

    #---------------------------------------------------------------------------
    #  Handles the 'selected' trait being changed:
    #---------------------------------------------------------------------------

    def _selected_changed ( self, selected ):
        """ Handles the **selected** trait being changed.
        """
        if not self._no_update_selected:
            self._selection_changed( selected )

    #---------------------------------------------------------------------------
    #  Handles the 'veto' event being fired:
    #---------------------------------------------------------------------------

    def _veto_changed ( self ):
        """ Handles the 'veto' event being fired.
        """
        self._veto = True

    def _refresh_changed ( self ):
        """ Update the viewport.
        """
        self._tree.viewport().update()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self._tree is not None:
            # Stop the chatter (specifically about the changing selection).
            self._tree.blockSignals(True)

            self._delete_node(self._tree.invisibleRootItem())

            self._tree = None

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Expands from the specified node the specified number of sub-levels:
    #---------------------------------------------------------------------------

    def expand_levels ( self, nid, levels, expand = True ):
        """ Expands from the specified node the specified number of sub-levels.
        """
        if levels > 0:
            expanded, node, object = self._get_node_data( nid )
            if self._has_children( node, object ):
                self._expand_node( nid )
                if expand:
                    nid.setExpanded(True)
                for cnid in self._nodes_for( nid ):
                    self.expand_levels( cnid, levels - 1 )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        tree = self._tree
        if tree is None:
            return
        saved_state = {}

        object, node = self._node_for( self.old_value )
        old_nid = self._get_object_nid( object, node.get_children_id(object))
        if old_nid: self._delete_node(old_nid)

        object, node = self._node_for( self.old_value )
        old_nid = self._get_object_nid( object, node.get_children_id(object) )
        if old_nid:
            self._delete_node(old_nid)

        tree.clear()
        self._map = {}

        object, node = self._node_for( self.value )
        if node is not None:
            if self.factory.hide_root:
                nid = tree.invisibleRootItem()
            else:
                nid = self._create_item(tree, node, object)

            self._map[ id( object ) ] = [ ( node.get_children_id(object), nid ) ]
            self._add_listeners( node, object )
            self._set_node_data( nid, ( False, node, object) )
            if self.factory.hide_root or self._has_children( node, object ):
                self._expand_node( nid )
                if not self.factory.hide_root:
                    nid.setExpanded(True)
                    tree.setCurrentItem(nid)

            self.expand_levels( nid, self.factory.auto_open, False )
        ncolumns = self._tree.columnCount()
        if ncolumns > 1:
            for i in range(ncolumns):
                self._tree.resizeColumnToContents(i)
        # FIXME: Clear the current editor (if any)...

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._tree

    def _get_brush(self, color) :
        if isinstance(color, SequenceTypes):
            q_color = QtGui.QColor(*color)
        else:
            q_color = QtGui.QColor(color)
        return QtGui.QBrush(q_color)


    def _set_column_labels(self, nid, column_labels):
        """ Set the column labels.
        """
        for i, (header, label) in enumerate(map(None,
            self.factory.column_headers[1:], column_labels), 1):
            if header is not None and label is not None:
                nid.setText(i, label)

    #---------------------------------------------------------------------------
    #  Private Delegate class to do drawing in case of wrapped text labels
    #---------------------------------------------------------------------------

    class ItemDelegate(QtGui.QStyledItemDelegate):
        """ A delegate class to draw wrapped text labels """
        # FIXME: sizeHint() should return the size required by the label,
        # which is dependent on the width available, which is different for
        # each item due to the nested tree structure. However the option.rect
        # argument available to the sizeHint() is invalid (width=-1) so as a
        # hack sizeHintChanged is emitted in paint() and the size of drawn
        # text is returned, as paint() gets a valid option.rect argument.

        def __init__(self, *args, **kwargs):
            self.size_map = collections.defaultdict(lambda:QtCore.QSize(1,21))
            QtGui.QStyledItemDelegate.__init__(self, *args, **kwargs)

        def sizeHint(self, option, index):
            """ returns area taken by the text. """
            return self.size_map[self.editor._tree.itemFromIndex(index)]

        def paint(self, painter, option, index):
            """ Do the actual drawing of the text """
            # For icon and highlights during selection etc
            super(self.__class__, self).paint(painter, option, index)

            item = self.editor._tree.itemFromIndex(index)
            expanded, node, object = self.editor._get_node_data(item)
            text = node.get_label(object)
            if self.editor.factory.show_icons:
                iconwidth = 24 # FIXME: get width from actual
            else:
                iconwidth = 0
            rect = painter.drawText(option.rect.left() + iconwidth,
                                    option.rect.top(),
                                    option.rect.width() - iconwidth,
                                    option.rect.height(),
                                    QtCore.Qt.TextWordWrap, text)
            # Need to set the appropriate sizeHint of the item.
            if self.size_map[item] != rect.size():
                self.size_map[item] = rect.size()
                do_later(self.sizeHintChanged.emit, index)


    #---------------------------------------------------------------------------
    #  Create a TreeWidgetItem as per word wrap policy and set icon,tooltip
    #---------------------------------------------------------------------------

    def _create_item(self, nid, node, object, index=None):
        """ Create  a new TreeWidgetItem as per word_wrap policy.

        Index is the index of the new node in the parent:
            None implies append the child to the end. """
        if index is None:
            cnid = QtGui.QTreeWidgetItem(nid)
        else:
            cnid = QtGui.QTreeWidgetItem()
            nid.insertChild(index, cnid)
        if self.factory.word_wrap:
            item = self.ItemDelegate()
            item.editor = self
            self._tree.setItemDelegate(item)
        else:
            cnid.setText(0, node.get_label(object))
        cnid.setIcon(0, self._get_icon(node, object))
        cnid.setToolTip(0, node.get_tooltip(object))
        self._set_column_labels(cnid, node.get_column_labels(object))

        color = node.get_background(object)
        if color : cnid.setBackground(0, self._get_brush(color))
        color = node.get_foreground(object)
        if color : cnid.setForeground(0, self._get_brush(color))

        return cnid

    def _set_label(self, nid, text, col=0):
        """ Set the label of the specified item """
        if not self.factory.word_wrap or col!=0:
            expanded, node, object = self._get_node_data(nid)
            nid.setText(col, node.get_label(object))

    #---------------------------------------------------------------------------
    #  Appends a new node to the specified node:
    #---------------------------------------------------------------------------

    def _append_node ( self, nid, node, object ):
        """ Appends a new node to the specified node.
        """
        return self._insert_node( nid, None, node, object )

    #---------------------------------------------------------------------------
    #  Inserts a new node to the specified node:
    #---------------------------------------------------------------------------

    def _insert_node ( self, nid, index, node, object ):
        """ Inserts a new node before a specified index into the children of the
            specified node.
        """

        cnid = self._create_item(nid, node, object, index)

        has_children = self._has_children(node, object)
        self._set_node_data( cnid, ( False, node, object ) )
        self._map.setdefault( id( object ), [] ).append(
            ( node.get_children_id(object), cnid ) )
        self._add_listeners( node, object )

        # Automatically expand the new node (if requested):
        if has_children:
            if node.can_auto_open( object ):
                cnid.setExpanded(True)
            else:
                # Qt only draws the control that expands the tree if there is a
                # child.  As the tree is being populated lazily we create a
                # dummy that will be removed when the node is expanded for the
                # first time.
                cnid._dummy = QtGui.QTreeWidgetItem(cnid)

        # Return the newly created node:
        return cnid

    #---------------------------------------------------------------------------
    #  Deletes a specified tree node and all its children:
    #---------------------------------------------------------------------------

    def _delete_node ( self, nid ):
        """ Deletes a specified tree node and all its children.
        """

        for cnid in self._nodes_for( nid ):
            self._delete_node( cnid )

        # See if it is a dummy.
        pnid = nid.parent()
        if pnid is not None and getattr(pnid, '_dummy', None) is nid:
            pnid.removeChild(nid)
            del pnid._dummy
            return

        try:
            expanded, node, object = self._get_node_data(nid)
        except AttributeError:
            # The node has already been deleted.
            pass
        else:
            id_object = id(object)
            object_info = self._map[id_object]
            for i, info in enumerate(object_info):
                # QTreeWidgetItem does not have an equal operator, so use id()
                if id(nid) == id(info[1]):
                    del object_info[i]
                    break

            if len( object_info ) == 0:
                self._remove_listeners( node, object )
                del self._map[ id_object ]

        if pnid is None:
            self._tree.takeTopLevelItem(self._tree.indexOfTopLevelItem(nid))
        else:
            pnid.removeChild(nid)

        # If the deleted node had an active editor panel showing, remove it:
        # Note: QTreeWidgetItem does not have an equal operator, so use id()
        if (self._editor is not None) and (id(nid) == id(self._editor._editor_nid)):
                self._clear_editor()

    #---------------------------------------------------------------------------
    #  Expands the contents of a specified node (if required):
    #---------------------------------------------------------------------------

    def _expand_node ( self, nid ):
        """ Expands the contents of a specified node (if required).
        """
        expanded, node, object = self._get_node_data( nid )

        # Lazily populate the item's children:
        if not expanded:
            # Remove any dummy node.
            dummy = getattr(nid, '_dummy', None)
            if dummy is not None:
                nid.removeChild(dummy)
                del nid._dummy

            for child in node.get_children( object ):
                child, child_node = self._node_for( child )
                if child_node is not None:
                    self._append_node( nid, child_node, child )

            # Indicate the item is now populated:
            self._set_node_data( nid, ( True, node, object) )

    #---------------------------------------------------------------------------
    #  Returns each of the child nodes of a specified node id:
    #---------------------------------------------------------------------------

    def _nodes_for ( self, nid ):
        """ Returns all child node ids of a specified node id.
        """
        return [nid.child(i) for i in range(nid.childCount())]

    #---------------------------------------------------------------------------
    #  Return the index of a specified node id within its parent:
    #---------------------------------------------------------------------------

    def _node_index ( self, nid ):
        pnid = nid.parent()
        if pnid is None:
            if self.factory.hide_root:
                pnid = self._tree.invisibleRootItem()
            if pnid is None:
                return ( None, None, None )

        for i in range(pnid.childCount()):
            if pnid.child(i) is nid:
                _, pnode, pobject = self._get_node_data( pnid )
                return ( pnode, pobject, i )
        else:
            # doesn't match any node, so return None
            return ( None, None, None )

    #---------------------------------------------------------------------------
    #  Returns whether a specified object has any children:
    #---------------------------------------------------------------------------

    def _has_children ( self, node, object ):
        """ Returns whether a specified object has any children.
        """
        return (node.allows_children( object ) and node.has_children( object ))

    #---------------------------------------------------------------------------
    #  Returns the icon index for the specified object:
    #---------------------------------------------------------------------------

    STD_ICON_MAP = {
        '<item>':   QtGui.QStyle.SP_FileIcon,
        '<group>':  QtGui.QStyle.SP_DirClosedIcon,
        '<open>':   QtGui.QStyle.SP_DirOpenIcon
    }

    def _get_icon ( self, node, object, is_expanded = False ):
        """ Returns the index of the specified object icon.
        """
        if not self.factory.show_icons:
            return QtGui.QIcon()

        icon_name = node.get_icon(object, is_expanded)
        if isinstance(icon_name, basestring):
            icon = self.STD_ICON_MAP.get(icon_name)

            if icon is not None:
                return self._tree.style().standardIcon(icon)

            path = node.get_icon_path( object )
            if isinstance( path, basestring ):
                path = [ path, node ]
            else:
                path.append( node )
            reference = resource_manager.locate_image( icon_name, path )
            if reference is None:
                return QtGui.QIcon()
            file_name = reference.filename
        else:
            # Assume it is an ImageResource, and get its file name directly:
            file_name = icon_name.absolute_path

        return QtGui.QIcon(pixmap_cache(file_name))

    #---------------------------------------------------------------------------
    #  Adds the event listeners for a specified object:
    #---------------------------------------------------------------------------

    def _add_listeners ( self, node, object ):
        """ Adds the event listeners for a specified object.
        """

        if node.allows_children( object ):
            node.when_children_replaced( object, self._children_replaced, False)
            node.when_children_changed(  object, self._children_updated,  False)

        node.when_label_changed( object, self._label_updated, False )
        node.when_column_labels_change(object, self._column_labels_updated, False)

    #---------------------------------------------------------------------------
    #  Removes any event listeners from a specified object:
    #---------------------------------------------------------------------------

    def _remove_listeners ( self, node, object ):
        """ Removes any event listeners from a specified object.
        """

        if node.allows_children( object ):
            node.when_children_replaced( object, self._children_replaced, True )
            node.when_children_changed(  object, self._children_updated,  True )

        node.when_label_changed( object, self._label_updated, True )
        node.when_column_labels_change(object, self._column_labels_updated, False)

    #---------------------------------------------------------------------------
    #  Returns the tree node data for a specified object in the form
    #  ( expanded, node, nid ):
    #---------------------------------------------------------------------------

    def _object_info ( self, object, name = '' ):
        """ Returns the tree node data for a specified object in the form
            ( expanded, node, nid ).
        """
        info = self._map[ id( object ) ]
        for name2, nid in info:
            if name == name2:
                break
        else:
            nid = info[0][1]

        expanded, node, ignore = self._get_node_data( nid )

        return ( expanded, node, nid )

    def _object_info_for ( self, object, name = '' ):
        """ Returns the tree node data for a specified object as a list of the
            form: [ ( expanded, node, nid ), ... ].
        """
        result = []
        for name2, nid in self._map[ id( object ) ]:
            if name == name2:
                expanded, node, ignore = self._get_node_data( nid )
                result.append( ( expanded, node, nid ) )

        return result

    #---------------------------------------------------------------------------
    #  Returns the TreeNode associated with a specified object:
    #---------------------------------------------------------------------------

    def _node_for ( self, object ):
        """ Returns the TreeNode associated with a specified object.
        """
        if ((type( object ) is tuple) and (len( object ) == 2) and
            isinstance( object[1], TreeNode )):
            return object

        # Select all nodes which understand this object:
        factory = self.factory
        nodes   = [ node for node in factory.nodes
                    if node.is_node_for( object ) ]

        # If only one found, we're done, return it:
        if len( nodes ) == 1:
            return ( object, nodes[0] )

        # If none found, give up:
        if len( nodes ) == 0:
            return ( object, ITreeNodeAdapterBridge(adapter=object) )

        # Use all selected nodes that have the same 'node_for' list as the
        # first selected node:
        base  = nodes[0].node_for
        nodes = [ node for node in nodes if base == node.node_for ]

        # If only one left, then return that node:
        if len( nodes ) == 1:
            return ( object, nodes[0] )

        # Otherwise, return a MultiTreeNode based on all selected nodes...

        # Use the node with no specified children as the root node. If not
        # found, just use the first selected node as the 'root node':
        root_node = None
        for i, node in enumerate( nodes ):
            if node.children == '':
                root_node = node
                del nodes[i]
                break
        else:
            root_node = nodes[0]

        # If we have a matching MultiTreeNode already cached, return it:
        key = ( root_node, ) + tuple( nodes )
        if key in factory.multi_nodes:
            return ( object, factory.multi_nodes[ key ] )

        # Otherwise create one, cache it, and return it:
        factory.multi_nodes[ key ] = multi_node = MultiTreeNode(
                                                       root_node = root_node,
                                                       nodes     = nodes )

        return ( object, multi_node )

    #---------------------------------------------------------------------------
    #  Returns the TreeNode associated with a specified class:
    #---------------------------------------------------------------------------

    def _node_for_class ( self, klass ):
        """ Returns the TreeNode associated with a specified class.
        """
        for node in self.factory.nodes:
            if issubclass( klass, tuple( node.node_for ) ):
                return node
        return None

    #---------------------------------------------------------------------------
    #  Returns the node and class associated with a specified class name:
    #---------------------------------------------------------------------------

    def _node_for_class_name ( self, class_name ):
        """ Returns the node and class associated with a specified class name.
        """
        for node in self.factory.nodes:
            for klass in node.node_for:
                if class_name == klass.__name__:
                    return ( node, klass )
        return ( None, None )

    #---------------------------------------------------------------------------
    #  Updates the icon for a specified node:
    #---------------------------------------------------------------------------

    def _update_icon(self, nid):
        """ Updates the icon for a specified node.
        """
        expanded, node, object = self._get_node_data(nid)
        nid.setIcon(0, self._get_icon(node, object, expanded))

    #---------------------------------------------------------------------------
    #  Begins an 'undoable' transaction:
    #---------------------------------------------------------------------------

    def _begin_undo ( self ):
        """ Begins an "undoable" transaction.
        """
        ui = self.ui
        self._undoable.append( ui._undoable )
        if (ui._undoable == -1) and (ui.history is not None):
            ui._undoable = ui.history.now

    #---------------------------------------------------------------------------
    #  Ends an 'undoable' transaction:
    #---------------------------------------------------------------------------

    def _end_undo ( self ):
        if self._undoable.pop() == -1:
            self.ui._undoable = -1

    #---------------------------------------------------------------------------
    #  Gets an 'undo' item for a change made to a node's children:
    #---------------------------------------------------------------------------

    def _get_undo_item ( self, object, name, event ):
        return ListUndoItem( object  = object,
                             name    = name,
                             index   = event.index,
                             added   = event.added,
                             removed = event.removed )

    #---------------------------------------------------------------------------
    #  Performs an undoable 'append' operation:
    #---------------------------------------------------------------------------

    def _undoable_append ( self, node, object, data, make_copy = True ):
        """ Performs an undoable append operation.
        """
        try:
            self._begin_undo()
            if make_copy:
                data = copy.deepcopy( data )
            node.append_child( object, data )
        finally:
            self._end_undo()

    #---------------------------------------------------------------------------
    #  Performs an undoable 'insert' operation:
    #---------------------------------------------------------------------------

    def _undoable_insert ( self, node, object, index, data, make_copy = True ):
        """ Performs an undoable insert operation.
        """
        try:
            self._begin_undo()
            if make_copy:
                data = copy.deepcopy( data )
            node.insert_child( object, index, data )
        finally:
            self._end_undo()

    #---------------------------------------------------------------------------
    #  Performs an undoable 'delete' operation:
    #---------------------------------------------------------------------------

    def _undoable_delete ( self, node, object, index ):
        """ Performs an undoable delete operation.
        """
        try:
            self._begin_undo()
            node.delete_child( object, index )
        finally:
            self._end_undo()

    #---------------------------------------------------------------------------
    #  Gets the id associated with a specified object (if any):
    #---------------------------------------------------------------------------

    def _get_object_nid ( self, object, name = '' ):
        """ Gets the ID associated with a specified object (if any).
        """
        info = self._map.get( id( object ) )
        if info is None:
            return None
        for name2, nid in info:
            if name == name2:
                return nid
        else:
            return info[0][1]

    #---------------------------------------------------------------------------
    #  Clears the current editor pane (if any):
    #---------------------------------------------------------------------------

    def _clear_editor ( self ):
        """ Clears the current editor pane (if any).
        """
        editor = self._editor
        if editor._node_ui is not None:
            editor.setWidget(None)
            editor._node_ui.dispose()
            editor._node_ui = editor._editor_nid = None

    #---------------------------------------------------------------------------
    #  Gets/Sets the node specific data:
    #---------------------------------------------------------------------------

    @staticmethod
    def _get_node_data(nid):
        """ Gets the node specific data. """
        return nid._py_data

    @staticmethod
    def _set_node_data(nid, data):
        """ Sets the node specific data. """
        nid._py_data = data

#----- User callable methods: --------------------------------------------------

    #---------------------------------------------------------------------------
    #  Gets the object associated with a specified node:
    #---------------------------------------------------------------------------

    def get_object ( self, nid ):
        """ Gets the object associated with a specified node.
        """
        return self._get_node_data( nid )[2]

    #---------------------------------------------------------------------------
    #  Returns the object which is the immmediate parent of a specified object
    #  in the tree:
    #---------------------------------------------------------------------------

    def get_parent ( self, object, name = '' ):
        """ Returns the object that is the immmediate parent of a specified
            object in the tree.
        """
        nid = self._get_object_nid( object, name )
        if nid is not None:
            pnid = nid.parent()
            if pnid is not self._tree.invisibleRootItem():
                return self.get_object( pnid )
        return None

    #---------------------------------------------------------------------------
    #  Returns the node associated with a specified object:
    #---------------------------------------------------------------------------

    def get_node ( self, object, name = '' ):
        """ Returns the node associated with a specified object.
        """
        nid = self._get_object_nid( object, name )
        if nid is not None:
            return self._get_node_data( nid )[1]
        return None

#----- Tree event handlers: ----------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a tree node being expanded:
    #---------------------------------------------------------------------------

    def _on_item_expanded(self, nid):
        """ Handles a tree node being expanded.
        """
        expanded, node, object = self._get_node_data(nid)

        # If 'auto_close' requested for this node type, close all of the node's
        # siblings:
        if node.can_auto_close(object):
            parent = nid.parent()

            if parent is not None:
                for snid in self._nodes_for(parent):
                    if snid is not nid:
                        snid.setExpanded(False)

        # Expand the node (i.e. populate its children if they are not there
        # yet):
        self._expand_node(nid)

        self._update_icon(nid)

    #---------------------------------------------------------------------------
    #  Handles a tree node being collapsed:
    #---------------------------------------------------------------------------

    def _on_item_collapsed(self, nid):
        """ Handles a tree node being collapsed.
        """
        self._update_icon(nid)

    #---------------------------------------------------------------------------
    #  Handles a tree item click:
    #---------------------------------------------------------------------------

    def _on_item_clicked(self, nid, col):
        """ Handles a tree item being clicked.
        """
        _, node, object = self._get_node_data(nid)

        if node.click(object) is True and self.factory.on_click is not None:
            self.ui.evaluate(self.factory.on_click, object)

        # Fire the 'click' event with the object as its value:
        self.click = object

    #---------------------------------------------------------------------------
    #  Handles a tree item double click:
    #---------------------------------------------------------------------------

    def _on_item_dclicked(self, nid, col):
        """ Handles a tree item being double-clicked.
        """
        _, node, object = self._get_node_data(nid)

        if node.dclick(object) is True:
            if self.factory.on_dclick is not None:
                self.ui.evaluate(self.factory.on_dclick, object)
                self._veto = True
        else:
            self._veto = True

        # Fire the 'dclick' event with the clicked on object as value:
        self.dclick = object

    #---------------------------------------------------------------------------
    #  Handles a tree item being activated:
    #---------------------------------------------------------------------------

    def _on_item_activated(self, nid, col):
        """ Handles a tree item being activated.
        """
        _, node, object = self._get_node_data(nid)

        if node.activated(object) is True:
            if self.factory.on_activated is not None:
                self.ui.evaluate(self.factory.on_activated, object)
                self._veto = True
        else:
            self._veto = True

        # Fire the 'activated' event with the clicked on object as value:
        self.activated = object

    #---------------------------------------------------------------------------
    #  Handles a tree node being selected:
    #---------------------------------------------------------------------------

    def _on_tree_sel_changed(self):
        """ Handles a tree node being selected.
        """
        # Get the new selection:
        nids = self._tree.selectedItems()

        selected = []
        if len(nids) > 0:
            for nid in nids:
                # If there is a real selection, get the associated object:
                expanded, node, sel_object = self._get_node_data(nid)
                selected.append(sel_object)

                # Try to inform the node specific handler of the selection, if
                # there are multiple selections, we only care about the first
                # (or maybe the last makes more sense?)

                # QTreeWidgetItem does not have an equal operator, so use id()
                if id(nid) == id(nids[0]):
                    object = sel_object
                    not_handled = node.select(sel_object)
        else:
            nid = None
            object = None
            not_handled = True

        # Set the value of the new selection:
        if self.factory.selection_mode == 'single':
            self._no_update_selected = True
            self.selected = object
            self._no_update_selected = False
        else:
            self._no_update_selected = True
            self.selected = selected
            self._no_update_selected = False

        # If no one has been notified of the selection yet, inform the editor's
        # select handler (if any) of the new selection:
        if not_handled is True:
            self.ui.evaluate(self.factory.on_select, object)

        # Check to see if there is an associated node editor pane:
        editor = self._editor
        if editor is not None:
            # If we already had a node editor, destroy it:
            editor.setUpdatesEnabled(False)
            self._clear_editor()

            # If there is a selected object, create a new editor for it:
            if object is not None:
                # Try to chain the undo history to the main undo history:
                view = node.get_view( object )
                if view is None or isinstance(view, str) :
                    view = object.trait_view(view)

                if (self.ui.history is not None) or (view.kind == 'subpanel'):
                    ui = object.edit_traits( parent = editor,
                                             view   = view,
                                             kind   = 'subpanel' )
                else:
                    # Otherwise, just set up our own new one:
                    ui = object.edit_traits( parent = editor,
                                             view   = view,
                                             kind   = 'panel' )


                # Make our UI the parent of the new UI:
                ui.parent = self.ui

                # Remember the new editor's UI and node info:
                editor._node_ui    = ui
                editor._editor_nid = nid

                # Finish setting up the editor:
                ui.control.layout().setContentsMargins(0, 0, 0, 0)
                editor.setWidget(ui.control)

            # Allow the editor view to show any changes that have occurred:
            editor.setUpdatesEnabled(True)

    #---------------------------------------------------------------------------
    #  Handles the user right clicking on a tree node:
    #---------------------------------------------------------------------------

    def _on_context_menu(self, pos):
        """ Handles the user requesting a context menuright clicking on a tree node.
        """
        nid = self._tree.itemAt(pos)

        if nid is None:
            return

        _, node, object = self._get_node_data(nid)

        self._data = (node, object, nid)
        self._context = {'object':  object,
                         'editor':  self,
                         'node':    node,
                         'info':    self.ui.info,
                         'handler': self.ui.handler}

        # Try to get the parent node of the node clicked on:
        pnid = nid.parent()
        if pnid is None or pnid is self._tree.invisibleRootItem():
            parent_node = parent_object = None
        else:
            _, parent_node, parent_object = self._get_node_data(pnid)

        self._menu_node = node
        self._menu_parent_node = parent_node
        self._menu_parent_object = parent_object

        menu = node.get_menu(object)

        if menu is None:
            # Use the standard, default menu:
            menu = self._standard_menu(node, object)

        elif isinstance(menu, Menu):
            # Use the menu specified by the node:
            group = menu.find_group(NewAction)
            if group is not None:
                # Only set it the first time:
                group.id = ''
                actions  = self._new_actions( node, object )
                if len( actions ) > 0:
                    group.insert( 0, Menu( name = 'New', *actions ) )

        else:
            # All other values mean no menu should be displayed:
            menu = None

        # Only display the menu if a valid menu is defined:
        if menu is not None:
            qmenu = menu.create_menu( self._tree, self )
            qmenu.exec_(self._tree.mapToGlobal(pos))

        # Reset all menu related cached values:
        self._data = self._context = self._menu_node = \
        self._menu_parent_node = self._menu_parent_object = None

    #---------------------------------------------------------------------------
    #  Returns the standard contextual pop-up menu:
    #---------------------------------------------------------------------------

    def _standard_menu ( self, node, object ):
        """ Returns the standard contextual pop-up menu.
        """
        actions = [ CutAction, CopyAction, PasteAction, Separator(),
                    DeleteAction, Separator(), RenameAction ]

        # See if the 'New' menu section should be added:
        items = self._new_actions( node, object )
        if len( items ) > 0:
            actions[0:0] = [ Menu( name = 'New', *items ), Separator() ]

        return Menu( *actions )

    #---------------------------------------------------------------------------
    #  Returns a list of Actions that will create 'new' objects:
    #---------------------------------------------------------------------------

    def _new_actions ( self, node, object ):
        """ Returns a list of Actions that will create new objects.
        """
        object = self._data[1]
        items  = []
        add    = node.get_add( object )
        if len( add ) > 0:
            for klass in add:
                prompt = False
                if isinstance( klass, tuple ):
                    klass, prompt = klass
                add_node = self._node_for_class( klass )
                if add_node is not None:
                    class_name = klass.__name__
                    name       = add_node.get_name( object )
                    if name == '':
                        name = class_name
                    items.append(
                        Action( name   = name,
                                action = "editor._menu_new_node('%s',%s)" %
                                         ( class_name, prompt ) ) )
        return items

    #---------------------------------------------------------------------------
    #  Menu action helper methods:
    #---------------------------------------------------------------------------

    def _is_copyable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            return parent.can_copy( self._menu_parent_object )
        return ((parent is not None) and parent.can_copy( object ))

    def _is_cutable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            can_cut = (parent.can_copy( self._menu_parent_object ) and
                       parent.can_delete( self._menu_parent_object ))
        else:
            can_cut = ((parent is not None) and
                       parent.can_copy( object ) and
                       parent.can_delete( object ))
        return (can_cut and self._menu_node.can_delete_me( object ))

    def _is_pasteable ( self, object ):
        return self._menu_node.can_add(object, clipboard.instance_type)

    def _is_deletable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            can_delete = parent.can_delete( self._menu_parent_object )
        else:
            can_delete = ((parent is not None) and parent.can_delete( object ))
        return (can_delete and self._menu_node.can_delete_me( object ))

    def _is_renameable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            can_rename = parent.can_rename( self._menu_parent_object )
        else:
            can_rename = ((parent is not None) and parent.can_rename( object ))

        can_rename = (can_rename and self._menu_node.can_rename_me( object ))

        # Set the widget item's editable flag appropriately.
        nid = self._get_object_nid(object)
        flags = nid.flags()
        if can_rename:
            flags |= QtCore.Qt.ItemIsEditable
        else:
            flags &= ~QtCore.Qt.ItemIsEditable
        nid.setFlags(flags)

        return can_rename

    def _is_droppable ( self, node, object, add_object, for_insert ):
        """ Returns whether a given object is droppable on the node.
        """
        if for_insert and (not node.can_insert( object )):
            return False

        return node.can_add( object, add_object )

    def _drop_object ( self, node, object, dropped_object, make_copy = True ):
        """ Returns a droppable version of a specified object.
        """
        new_object = node.drop_object( object, dropped_object )
        if (new_object is not dropped_object) or (not make_copy):
            return new_object

        return copy.deepcopy( new_object )

#----- pyface.action 'controller' interface implementation: --------------------

    #---------------------------------------------------------------------------
    #  Adds a menu item to the menu being constructed:
    #---------------------------------------------------------------------------

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        action = menu_item.item.action
        self.eval_when( action.enabled_when, menu_item, 'enabled' )
        self.eval_when( action.checked_when, menu_item, 'checked' )

    #---------------------------------------------------------------------------
    #  Adds a tool bar item to the tool bar being constructed:
    #---------------------------------------------------------------------------

    def add_to_toolbar ( self, toolbar_item ):
        """ Adds a toolbar item to the toolbar being constructed.
        """
        self.add_to_menu( toolbar_item )

    #---------------------------------------------------------------------------
    #  Returns whether the menu action should be defined in the user interface:
    #---------------------------------------------------------------------------

    def can_add_to_menu ( self, action ):
        """ Returns whether the action should be defined in the user interface.
        """
        if action.defined_when != '':
            if not eval( action.defined_when, globals(), self._context ):
                return False

        if action.visible_when != '':
            if not eval( action.visible_when, globals(), self._context ):
                return False

        return True

    #---------------------------------------------------------------------------
    #  Returns whether the toolbar action should be defined in the user
    #  interface:
    #---------------------------------------------------------------------------

    def can_add_to_toolbar ( self, action ):
        """ Returns whether the toolbar action should be defined in the user
            interface.
        """
        return self.can_add_to_menu( action )

    #---------------------------------------------------------------------------
    #  Performs the action described by a specified Action object:
    #---------------------------------------------------------------------------

    def perform ( self, action, action_event = None ):
        """ Performs the action described by a specified Action object.
        """
        self.ui.do_undoable( self._perform, action )

    def _perform ( self, action ):
        node, object, nid = self._data
        method_name       = action.action
        info              = self.ui.info
        handler           = self.ui.handler

        if method_name.find( '.' ) >= 0:
            if method_name.find( '(' ) < 0:
                method_name += '()'
            try:
                eval( method_name, globals(),
                      { 'object':  object,
                        'editor':  self,
                        'node':    node,
                        'info':    info,
                        'handler': handler } )
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()
            return

        method = getattr( handler, method_name, None )
        if method is not None:
            method( info, object )
            return

        if action.on_perform is not None:
            action.on_perform( object )

#----- Menu support methods: ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Evaluates a condition within a defined context and sets a specified
    #  object trait based on the (assumed) boolean result:
    #---------------------------------------------------------------------------

    def eval_when ( self, condition, object, trait ):
        """ Evaluates a condition within a defined context, and sets a
        specified object trait based on the result, which is assumed to be a
        Boolean.
        """
        if condition != '':
            value = True
            try:
                if not eval( condition, globals(), self._context ):
                    value = False
            except Exception as e:
                logger.warning("Exception (%s) raised when evaluating the "
                               "condition %s. Returning True." % (e,condition))
            setattr( object, trait, value )

#----- Menu event handlers: ----------------------------------------------------

    #---------------------------------------------------------------------------
    #  Copies the current tree node object to the paste buffer:
    #---------------------------------------------------------------------------

    def _menu_copy_node ( self ):
        """ Copies the current tree node object to the paste buffer.
        """
        clipboard.instance = self._data[1]
        self._data = None

    #---------------------------------------------------------------------------
    #   Cuts the current tree node object into the paste buffer:
    #---------------------------------------------------------------------------

    def _menu_cut_node ( self ):
        """ Cuts the current tree node object into the paste buffer.
        """
        node, object, nid = self._data
        clipboard.instance = object
        self._data = None
        self._undoable_delete(*self._node_index(nid))

    #---------------------------------------------------------------------------
    #  Pastes the current contents of the paste buffer into the current node:
    #---------------------------------------------------------------------------

    def _menu_paste_node ( self ):
        """ Pastes the current contents of the paste buffer into the current
            node.
        """
        node, object, nid = self._data
        self._data = None
        self._undoable_append(node, object, clipboard.instance, False)

    #---------------------------------------------------------------------------
    #  Deletes the current node from the tree:
    #---------------------------------------------------------------------------

    def _menu_delete_node ( self ):
        """ Deletes the current node from the tree.
        """
        node, object, nid = self._data
        self._data        = None
        rc = node.confirm_delete( object )
        if rc is not False:
            if rc is not True:
                if self.ui.history is None:
                    # If no undo history, ask user to confirm the delete:
                    butn = QtGui.QMessageBox.question(
                                self._tree,
                                "Confirm Deletion",
                                "Are you sure you want to delete %s?" % node.get_label( object ),
                                QtGui.QMessageBox.Yes|QtGui.QMessageBox.No)
                    if butn != QtGui.QMessageBox.Yes:
                        return

            self._undoable_delete( *self._node_index( nid ) )

    #---------------------------------------------------------------------------
    #  Renames the current tree node:
    #---------------------------------------------------------------------------

    def _menu_rename_node ( self ):
        """ Rename the current node.
        """
        _, _, nid = self._data
        self._data = None
        self._tree.editItem(nid)

    def _on_nid_changed(self, nid, col):
        """ Handle changes to a widget item.
        """
        # The node data may not have been set up for the nid yet.  Ignore it if
        # it hasn't.
        try:
            _, node, object = self._get_node_data(nid)
        except:
            return

        new_label = unicode(nid.text(col))
        old_label = node.get_label(object)

        if new_label != old_label:
            if new_label != '':
                node.set_label(object, new_label)
            else:
                self._set_label(nid, old_label, col)

    #---------------------------------------------------------------------------
    #  Adds a new object to the current node:
    #---------------------------------------------------------------------------

    def _menu_new_node ( self, class_name, prompt = False ):
        """ Adds a new object to the current node.
        """
        node, object, nid   = self._data
        self._data          = None
        new_node, new_class = self._node_for_class_name( class_name )
        new_object          = new_class()
        if (not prompt) or new_object.edit_traits(
                            parent = self.control, kind = 'livemodal' ).result:
            self._undoable_append( node, object, new_object, False )

            # Automatically select the new object if editing is being performed:
            if self.factory.editable:
                self._tree.setCurrentItem(nid.child(nid.childCount() - 1))

#----- Model event handlers: ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles the children of a node being completely replaced:
    #---------------------------------------------------------------------------

    def _children_replaced ( self, object, name = '', new = None ):
        """ Handles the children of a node being completely replaced.
        """
        tree = self._tree
        for expanded, node, nid in self._object_info_for( object, name ):
            children = node.get_children( object )

            # Only add/remove the changes if the node has already been expanded:
            if expanded:
                # Delete all current child nodes:
                for cnid in self._nodes_for( nid ):
                    self._delete_node( cnid )

                # Add all of the children back in as new nodes:
                for child in children:
                    child, child_node = self._node_for( child )
                    if child_node is not None:
                        self._append_node( nid, child_node, child )

            # Try to expand the node (if requested):
            if node.can_auto_open( object ):
                nid.setExpanded(True)

    #---------------------------------------------------------------------------
    #  Handles the children of a node being changed:
    #---------------------------------------------------------------------------

    def _children_updated ( self, object, name, event ):
        """ Handles the children of a node being changed.
        """
        # Log the change that was made made (removing '_items' from the end of
        # the name):
        name = name[:-6]
        self.log_change( self._get_undo_item, object, name, event )

        # Get information about the node that was changed:
        start = event.index
        n     = len( event.added )
        end   = start + len( event.removed )
        tree  = self._tree

        for expanded, node, nid in self._object_info_for( object, name ):
            children = node.get_children( object )

            # If the new children aren't all at the end, remove/add them all:
            #if (n > 0) and ((start + n) != len( children )):
            #    self._children_replaced( object, name, event )
            #    return

            # Only add/remove the changes if the node has already been expanded:
            if expanded:
                # Remove all of the children that were deleted:
                for cnid in self._nodes_for( nid )[ start: end ]:
                    self._delete_node( cnid )

                remaining = len( children ) - len( event.removed )
                child_index = 0
                # Add all of the children that were added:
                for child in event.added:
                    child, child_node = self._node_for( child )
                    if child_node is not None:
                        insert_index = (start + child_index) if \
                                        (start <= remaining) else None
                        self._insert_node( nid, insert_index, child_node,
                                        child )
                        child_index += 1

            # Try to expand the node (if requested):
            if node.can_auto_open( object ):
                nid.setExpanded(True)

    #---------------------------------------------------------------------------
    #   Handles the label of an object being changed:
    #---------------------------------------------------------------------------

    def _label_updated ( self, object, name, label ):
        """  Handles the label of an object being changed.
        """
        # Prevent the itemChanged() signal from being emitted.
        blk = self._tree.blockSignals(True)

        nids = {}
        for name2, nid in self._map[ id( object ) ]:
            if nid not in nids:
                nids[ nid ] = None
                node = self._get_node_data( nid )[1]
                self._set_label(nid, node.get_label(object), 0)
                self._update_icon(nid)

        self._tree.blockSignals(blk)

    def _column_labels_updated(self, object, name, new):
        """  Handles the column labels of an object being changed.
        """
        # Prevent the itemChanged() signal from being emitted.
        blk = self._tree.blockSignals(True)

        nids = {}
        for name2, nid in self._map[ id( object ) ]:
            if nid not in nids:
                nids[ nid ] = None
                node = self._get_node_data( nid )[1]
                # Just do all of them at once. The number of columns should be
                # small.
                self._set_column_labels(nid, node.get_column_labels(object))

        self._tree.blockSignals(blk)

#-- UI preference save/restore interface ---------------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if isinstance(self.control, QtGui.QSplitter):
            if isinstance(prefs, dict):
                structure = prefs.get('structure')
            else:
                structure = prefs

            self.control.restoreState(structure)
        header = self._tree.header()
        self.setExpandsOnDoubleClick(self.factory.expands_on_dclick)

        if header is not None and 'column_state' in prefs:
            header.restoreState(prefs['column_state'])

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        prefs = {}
        if isinstance(self.control, QtGui.QSplitter):
            prefs['structure'] = str(self.control.saveState())
        header = self._tree.header()
        if header is not None:
            prefs['column_state'] = str(header.saveState())

        return prefs

#-- End UI preference save/restore interface -----------------------------------

#-------------------------------------------------------------------------------
#  '_TreeWidget' class:
#-------------------------------------------------------------------------------

class _TreeWidget(QtGui.QTreeWidget):
    """ The _TreeWidget class is a specialised QTreeWidget that reimplements
        the drag'n'drop support so that it hooks into the provided Traits
        support.
    """
    def __init__(self, editor, parent=None):
        """ Initialise the tree widget.
        """
        QtGui.QTreeWidget.__init__(self, parent)

        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        # Set up headers if necessary.
        column_count = len(editor.factory.column_headers)
        if column_count > 0:
            self.setHeaderHidden(False)
            self.setColumnCount(column_count)
            self.setHeaderLabels(editor.factory.column_headers)
        else:
            self.setHeaderHidden(True)

        self.setAlternatingRowColors(editor.factory.alternating_row_colors)
        padding = editor.factory.vertical_padding
        if padding > 0:
            self.setStyleSheet("""
            QTreeView::item {
                padding-top: %spx;
                padding-bottom: %spx;
            }
            """ % (padding, padding))

        if editor.factory.selection_mode == 'extended':
            self.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)

        self.itemExpanded.connect(editor._on_item_expanded)
        self.itemCollapsed.connect(editor._on_item_collapsed)
        self.itemClicked.connect(editor._on_item_clicked)
        self.itemDoubleClicked.connect(editor._on_item_dclicked)
        self.itemActivated.connect(editor._on_item_activated)
        self.itemSelectionChanged.connect(editor._on_tree_sel_changed)
        self.customContextMenuRequested.connect(editor._on_context_menu)
        self.itemChanged.connect(editor._on_nid_changed)

        self._editor = editor
        self._dragging = None

    def resizeEvent(self, event):
        """ Overridden to emit sizeHintChanged() of items for word wrapping """
        if self._editor.factory.word_wrap:
            for i in range(self.topLevelItemCount()):
                mi = self.indexFromItem(self.topLevelItem(i))
                id = self.itemDelegate(mi)
                id.sizeHintChanged.emit(mi)
        super(self.__class__, self).resizeEvent(event)

    def startDrag(self, actions):
        """ Reimplemented to start the drag of a tree widget item.
        """
        nid = self.currentItem()
        if nid is None:
            return

        self._dragging = nid

        _, node, object = self._editor._get_node_data(nid)

        # Convert the item being dragged to MIME data.
        drag_object = node.get_drag_object(object)
        md = PyMimeData.coerce(drag_object)

        # Render the item being dragged as a pixmap.
        nid_rect = self.visualItemRect(nid)
        rect = nid_rect.intersected(self.viewport().rect())
        pm = QtGui.QPixmap(rect.size())
        pm.fill(self.palette().base().color())
        painter = QtGui.QPainter(pm)

        option = self.viewOptions()
        option.state |= QtGui.QStyle.State_Selected
        option.rect = QtCore.QRect(nid_rect.topLeft() - rect.topLeft(), nid_rect.size())
        self.itemDelegate().paint(painter, option, self.indexFromItem(nid))

        painter.end()

        # Calculate the hotspot so that the pixmap appears on top of the
        # original item.
        hspos = self.viewport().mapFromGlobal(QtGui.QCursor.pos()) - nid_rect.topLeft()

        # Start the drag.
        drag = QtGui.QDrag(self)
        drag.setMimeData(md)
        drag.setPixmap(pm)
        drag.setHotSpot(hspos)
        drag.exec_(actions)

    def dragEnterEvent(self, e):
        """ Reimplemented to see if the current drag can be handled by the
            tree.
        """
        # Assume the drag is invalid.
        e.ignore()

        # Check if we have a python object instance, we might be interested
        data = PyMimeData.coerce(e.mimeData()).instance()
        if data is None:
            return

        # We might be able to handle it (but it depends on what the final
        # target is).
        e.acceptProposedAction()

    def dragMoveEvent(self, e):
        """ Reimplemented to see if the current drag can be handled by the
            particular tree widget item underneath the cursor.
        """
        # Assume the drag is invalid.
        e.ignore()

        action, to_node, to_object, to_index, data = self._get_action( e )

        if action is not None:
            e.acceptProposedAction()

    def dropEvent(self, e):
        """ Reimplemented to update the model and tree.
        """
        # Assume the drop is invalid.
        e.ignore()

        editor = self._editor

        dragging = self._dragging
        self._dragging = None

        action, to_node, to_object, to_index, data = self._get_action( e )

        if action == 'append':
            if dragging is not None:
                data = self._editor._drop_object( to_node, to_object, data, False )
                if data is not None:
                    try:
                        editor._begin_undo()
                        editor._undoable_delete(
                                 *editor._node_index( dragging ) )
                        editor._undoable_append( to_node, object, data, False )
                    finally:
                        editor._end_undo()
            else:
                data = editor._drop_object( to_node, to_object, data, True )
                if data is not None:
                    editor._undoable_append( to_node, to_object, data, False )
        elif action == 'insert':
            if dragging is not None:
                data = editor._drop_object( to_node, to_object, data, False )
                if data is not None:
                    from_node, from_object, from_index = \
                            editor._node_index( dragging )
                    if ((to_object is from_object) and
                        (to_index > from_index)):
                        to_index -= 1
                    try:
                        editor._begin_undo()
                        editor._undoable_delete( from_node, from_object,
                                                from_index )
                        editor._undoable_insert( to_node, to_object, to_index,
                                                data, False )
                    finally:
                        editor._end_undo()
            else:
                data = self._editor._drop_object( to_node, to_object, data, True )
                if data is not None:
                    editor._undoable_insert( to_node, to_object, to_index,
                                            data, False )
        else:
            return

        e.acceptProposedAction()

    def _get_action(self, event):
        """ Work out what action on what object to perform for a drop event
        """
        # default values to return
        action = None
        to_node = None
        to_object = None
        to_index = None
        data = None

        editor = self._editor

        # Get the tree widget item under the cursor.
        nid = self.itemAt(event.pos())
        if nid is None:
            if editor.factory.hide_root:
                nid = self.invisibleRootItem()
            else:
                return (action, to_node, to_object, to_index, data)

        # Check that the target is not the source of a child of the source.
        if self._dragging is not None:
            pnid = nid
            while pnid is not None:
                if pnid is self._dragging:
                    return (action, to_node, to_object, to_index, data)

                pnid = pnid.parent()

        data = PyMimeData.coerce(event.mimeData()).instance()
        _, node, object = editor._get_node_data(nid)

        if event.proposedAction() == QtCore.Qt.MoveAction and \
                editor._is_droppable(node, object, data, False):
            # append to node being dropped on
            action = 'append'
            to_node = node
            to_object = object
            to_index = None
        else:
            # get parent of node being dropped on
            to_node, to_object, to_index = editor._node_index(nid)
            if to_node is None:
                # no parent, can't do anything
                action = None
            elif editor._is_droppable(to_node, to_object, data, True):
                # insert into the parent of the node being dropped on
                action = 'insert'
            elif editor._is_droppable(to_node, to_object, data, False):
                # append to the parent of the node being dropped on
                action = 'append'
            else:
                # parent can't be modified, can't do anything
                action = None

        return (action, to_node, to_object, to_index, data)

########NEW FILE########
__FILENAME__ = tuple_editor
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Defines the tuple editor for the PyQt user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------


# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.tuple_editor file.
from traitsui.editors.tuple_editor \
    import SimpleEditor as BaseSimpleEditor, ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( BaseSimpleEditor, Editor ):
    """ Simple style of editor for tuples.

    The editor displays an editor for each of the fields in the tuple, based on
    the type of each field.
    """
    pass

########NEW FILE########
__FILENAME__ = ui_base
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

"""Defines the base class for the PyQt-based Traits UI modal and non-modal
   dialogs.
"""


from pyface.qt import QtCore, QtGui

from traits.api \
    import HasStrictTraits, HasPrivateTraits, Instance, List, Event

from traitsui.api \
    import UI

from traitsui.menu \
    import Action

from constants \
    import DefaultTitle

from editor \
    import Editor

from helper \
    import restore_window, save_window


#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# List of all predefined system button names:
SystemButtons = ['Undo', 'Redo', 'Apply', 'Revert', 'OK', 'Cancel', 'Help']

# List of alternative context items that might handle an Action 'perform':
PerformHandlers = ( 'object', 'model' )

def default_icon():
    from pyface.image_resource import ImageResource
    return ImageResource('frame.png')

#-------------------------------------------------------------------------------
#  'RadioGroup' class:
#-------------------------------------------------------------------------------

class RadioGroup ( HasStrictTraits ):
    """ A group of mutually-exclusive menu or toolbar actions.
    """
    # List of menu or tool bar items
    items = List

    #---------------------------------------------------------------------------
    #  Handles a menu item in the group being checked:
    #---------------------------------------------------------------------------

    def menu_checked ( self, menu_item ):
        """ Handles a menu item in the group being checked.
        """
        for item in self.items:
            if item is not menu_item:
                item.control.Check( False )
                item.item.action.checked = False

    #---------------------------------------------------------------------------
    #  Handles a tool bar item in the group being checked:
    #---------------------------------------------------------------------------

    def toolbar_checked ( self, toolbar_item ):
        """ Handles a tool bar item in the group being checked.
        """
        for item in self.items:
            if item is not toolbar_item:
                item.tool_bar.ToggleTool( item.control_id, False )
                item.item.action.checked = False

#-------------------------------------------------------------------------------
#  'ButtonEditor' class:
#-------------------------------------------------------------------------------

class ButtonEditor(Editor):
    """ Editor for buttons.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Action associated with the button
    action = Instance(Action)

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__(self, **traits):
        self.set(**traits)

    #---------------------------------------------------------------------------
    #  Handles the associated button being clicked:
    #---------------------------------------------------------------------------

    def perform(self):
        """Handles the associated button being clicked."""
        self.ui.do_undoable(self._perform, None)

    def _perform(self, event):
        method_name = self.action.action
        if method_name == '':
            method_name = '_%s_clicked' % self.action.name.lower()

        method = getattr(self.ui.handler, method_name, None)
        if method is not None:
            method(self.ui.info)
        else:
            self.action.perform(event)


class BasePanel(object):
    """Base class for Traits UI panels.
    """

    #---------------------------------------------------------------------------
    #  Performs the action described by a specified Action object:
    #---------------------------------------------------------------------------

    def perform ( self, action ):
        """ Performs the action described by a specified Action object.
        """
        self.ui.do_undoable( self._perform, action )

    def _perform ( self, action ):
        method = getattr( self.ui.handler, action.action, None )
        if method is not None:
            method( self.ui.info )
        else:
            # TODO extract to common superclass for wx and qt4

            # cf. commit cdf76eb5965c0184114c4674e06b28beee04af36
            # (July 28, 2008, dmorrill) that fixes this issue for the
            # wx backend

            # look for the method in the context of the handler
            context = self.ui.context
            for item in PerformHandlers:
                handler = context.get( item, None )
                if handler is not None:
                    method = getattr( handler, action.action, None )
                    if method is not None:
                        method()
                        break
            else:
                action.perform()

    #---------------------------------------------------------------------------
    #  Check to see if a specified 'system' button is in the buttons list, and
    # add it if it is not:
    #---------------------------------------------------------------------------

    def check_button ( self, buttons, action ):
        """ Adds *action* to the system buttons list for this dialog, if it is
        not already in the list.
        """
        name = action.name
        for button in buttons:
            if self.is_button( button, name ):
                return
        buttons.append( action )

    #---------------------------------------------------------------------------
    #  Check to see if a specified Action button is a 'system' button:
    #---------------------------------------------------------------------------

    def is_button ( self, action, name ):
        """ Returns whether a specified action button is a system button.
        """
        if isinstance(action, basestring):
            return (action == name)
        return (action.name == name)

    #---------------------------------------------------------------------------
    #  Coerces a string to an Action if necessary:
    #---------------------------------------------------------------------------

    def coerce_button ( self, action ):
        """ Coerces a string to an Action if necessary.
        """
        if isinstance(action, basestring):
            return Action( name   = action,
                           action = '?'[ (not action in SystemButtons): ] )
        return action

    #---------------------------------------------------------------------------
    #  Creates a user specified button:
    #---------------------------------------------------------------------------

    def add_button ( self, action, bbox, role, method=None, enabled=True,
                     name=None, default=False ):
        """ Creates a button.
        """
        ui = self.ui
        if ((action.defined_when != '') and
            (not ui.eval_when( action.defined_when ))):
            return None

        if name is None:
            name = action.name
        id     = action.id
        button = bbox.addButton(name, role)
        button.setAutoDefault(False)
        button.setDefault(default)
        button.setEnabled(enabled)
        if (method is None) or (action.enabled_when != '') or (id != ''):
            editor = ButtonEditor( ui      = ui,
                                   action  = action,
                                   control = button )
            if id != '':
                ui.info.bind( id, editor )
            if action.visible_when != '':
                ui.add_visible( action.visible_when, editor )
            if action.enabled_when != '':
                ui.add_enabled( action.enabled_when, editor )
            if method is None:
                method = editor.perform

        if method is not None:
            button.connect(button, QtCore.SIGNAL('clicked()'), method)

        if action.tooltip != '':
            button.setToolTip(action.tooltip)

        return button

    def _on_help(self):
        """Handles the user clicking the Help button.
        """
        # FIXME: Needs porting to PyQt.
        self.ui.handler.show_help(self.ui.info, event.GetEventObject())

    def _on_undo(self):
        """Handles a request to undo a change.
        """
        self.ui.history.undo()

    def _on_undoable(self, state):
        """Handles a change to the "undoable" state of the undo history
        """
        self.undo.setEnabled(state)

    def _on_redo(self):
        """Handles a request to redo a change.
        """
        self.ui.history.redo()

    def _on_redoable(self, state):
        """Handles a change to the "redoable" state of the undo history.
        """
        self.redo.setEnabled(state)

    def _on_revert(self):
        """Handles a request to revert all changes.
        """
        ui = self.ui
        if ui.history is not None:
            ui.history.revert()
        ui.handler.revert(ui.info)

    def _on_revertable(self, state):
        """ Handles a change to the "revert" state.
        """
        self.revert.setEnabled(state)


class _StickyDialog(QtGui.QDialog):
    """A QDialog that will only close if the traits handler allows it."""

    def __init__(self, ui, parent):
        """Initialise the dialog."""

        QtGui.QDialog.__init__(self, parent)

        # Create the main window so we can add toolbars etc.
        self._mw = QtGui.QMainWindow()
        layout = QtGui.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self._mw)
        self.setLayout(layout)

        # Set the dialog's window flags and properties.
        if ui.view.resizable:
            flags = QtCore.Qt.Window
        else:
            flags = QtCore.Qt.Dialog | QtCore.Qt.WindowSystemMenuHint
            layout.setSizeConstraint(QtGui.QLayout.SetFixedSize)
            if ui.view.resizable:
                flags |= QtCore.Qt.WindowMinimizeButtonHint | QtCore.Qt.WindowMaximizeButtonHint
        try:
            flags |= QtCore.Qt.WindowCloseButtonHint
            if ui.view.resizable:
                flags |= (QtCore.Qt.WindowMinimizeButtonHint |
                          QtCore.Qt.WindowMaximizeButtonHint)
        except AttributeError:
            # Either PyQt or Qt is too old.
            pass
        self.setWindowFlags(flags)

        self._ui = ui
        self._result = None

    def showEvent(self, e):
        self.raise_()

    def closeEvent(self, e):
        """Reimplemented to check when the clicks the window close button.
        (Note that QDialog doesn't get a close event when the dialog is closed
        in any other way.)"""

        if self._ok_to_close():
            QtGui.QDialog.closeEvent(self, e)
        else:
            # Ignore the event thereby keeping the dialog open.
            e.ignore()

    def keyPressEvent(self, e):
        """Reimplemented to ignore the Escape key if appropriate, and to ignore
        the Enter key if no default button has been explicitly set."""

        if e.key() in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return) and \
               not self._ui.view.default_button:
            return
        
        if e.key() == QtCore.Qt.Key_Escape and not self._ok_to_close():
            return
        
        QtGui.QDialog.keyPressEvent(self, e)

    def sizeHint(self):
        """Reimplemented to provide an appropriate size hint for the window.
        """
        size = QtGui.QDialog.sizeHint(self)
        view = self._ui.view
        if view.width > 0:
            size.setWidth(view.width)
        if view.height > 0:
            size.setHeight(view.height)
        return size

    def done(self, r):
        """Reimplemented to ignore calls to accept() or reject() if
        appropriate."""

        # If we already have a result then we already know that we are done.
        if self._result is not None:
            QtGui.QDialog.done(self, self._result)
        elif self._ok_to_close(bool(r)):
            QtGui.QDialog.done(self, r)

    def _ok_to_close(self, is_ok=None):
        """Let the handler decide if the dialog should be closed."""

        # The is_ok flag is also the dialog result.  If we don't know it then
        # the the user closed the dialog other than by an 'Ok' or 'Cancel'
        # button.
        if is_ok is None:
            # Use the view's default, if there is one.
            is_ok = self._ui.view.close_result
            if is_ok is None:
                # There is no default, so use False for a modal dialog and True
                # for a non-modal one.
                is_ok = not self.isModal()

        ok_to_close = self._ui.handler.close(self._ui.info, is_ok)
        if ok_to_close:
            # Save the result now.
            self._result = is_ok

        return ok_to_close


class BaseDialog(BasePanel):
    """Base class for Traits UI dialog boxes."""

    # The different dialog styles.
    NONMODAL, MODAL, POPUP = range(3)

    def init(self, ui, parent, style):
        """Initialise the dialog by creating the controls."""

        raise NotImplementedError

    def create_dialog(self, parent, style):
        """Create the dialog control."""

        self.control = control = _StickyDialog(self.ui, parent)

        view = self.ui.view

        control.setModal(style == BaseDialog.MODAL)
        control.setWindowTitle(view.title or DefaultTitle)

        QtCore.QObject.connect(control, QtCore.SIGNAL('finished(int)'),
                self._on_finished)

    def add_contents(self, panel, buttons):
        """Add a panel (either a widget, layout or None) and optional buttons
        to the dialog."""

        # If the panel is a layout then provide a widget for it.
        if isinstance(panel, QtGui.QLayout):
            w = QtGui.QWidget()
            panel.setContentsMargins(0, 0, 0, 0)
            w.setLayout(panel)
            panel = w

        if panel is not None:
            self.control._mw.setCentralWidget(panel)

        # Add the optional buttons.
        if buttons is not None:
            self.control.layout().addWidget(buttons)

        # Add the menu bar, tool bar and status bar (if any).
        self._add_menubar()
        self._add_toolbar()
        self._add_statusbar()

    def close(self, rc=True):
        """Close the dialog and set the given return code."""

        self.ui.dispose(rc)
        self.ui = self.control = None

    @staticmethod
    def display_ui(ui, parent, style):
        """Display the UI."""

        ui.owner.init(ui, parent, style)
        ui.control = ui.owner.control
        ui.control._parent = parent

        try:
            ui.prepare_ui()
        except:
            ui.control.setParent(None)
            ui.control.ui = None
            ui.control = None
            ui.owner = None
            ui.result = False
            raise

        ui.handler.position(ui.info)
        restore_window(ui)

        if style == BaseDialog.NONMODAL:
            ui.control.show()
        else:
            ui.control.setWindowModality(QtCore.Qt.ApplicationModal)
            ui.control.exec_()

    def set_icon(self, icon=None):
        """Sets the dialog's icon."""

        from pyface.image_resource import ImageResource

        if not isinstance(icon, ImageResource):
            icon = default_icon()

        self.control.setWindowIcon(icon.create_icon())

    def _on_error(self, errors):
        """Handles editing errors."""

        self.ok.setEnabled(errors == 0)

    #---------------------------------------------------------------------------
    #  Adds a menu bar to the dialog:
    #---------------------------------------------------------------------------

    def _add_menubar(self):
        """Adds a menu bar to the dialog.
        """
        menubar = self.ui.view.menubar
        if menubar is not None:
            self._last_group = self._last_parent = None
            self.control.layout().setMenuBar(
                menubar.create_menu_bar( self.control, self ) )
            self._last_group = self._last_parent = None

    #---------------------------------------------------------------------------
    #  Adds a tool bar to the dialog:
    #---------------------------------------------------------------------------

    def _add_toolbar ( self ):
        """ Adds a toolbar to the dialog.
        """
        toolbar = self.ui.view.toolbar
        if toolbar is not None:
            self._last_group = self._last_parent = None
            qt_toolbar = toolbar.create_tool_bar( self.control, self )
            qt_toolbar.setMovable( False )
            self.control._mw.addToolBar( qt_toolbar )
            self._last_group = self._last_parent = None

    #---------------------------------------------------------------------------
    #  Adds a status bar to the dialog:
    #---------------------------------------------------------------------------

    def _add_statusbar ( self ):
        """ Adds a statusbar to the dialog.
        """
        if self.ui.view.statusbar is not None:
            control = QtGui.QStatusBar()
            control.setSizeGripEnabled(self.ui.view.resizable)
            listeners = []
            for item in self.ui.view.statusbar:
                # Create the status widget with initial text
                name = item.name
                item_control = QtGui.QLabel()
                item_control.setText(self.ui.get_extended_value(name))

                # Add the widget to the control with correct size
                width = abs(item.width)
                stretch = 0
                if width <= 1.0:
                    stretch = int(100 * width)
                else:
                    item_control.setMinimumWidth(width)
                control.addWidget(item_control, stretch)

                # Set up event listener for updating the status text
                col = name.find('.')
                obj = 'object'
                if col >= 0:
                    obj = name[:col]
                    name = name[col+1:]
                obj = self.ui.context[obj]
                set_text = self._set_status_text(item_control)
                obj.on_trait_change(set_text, name, dispatch='ui')
                listeners.append((obj, set_text, name))

            self.control._mw.setStatusBar(control)
            self.ui._statusbar = listeners

    def _set_status_text(self, control):
        """ Helper function for _add_statusbar.
        """
        def set_status_text(text):
            control.setText(text)

        return set_status_text

    #---------------------------------------------------------------------------
    #  Adds a menu item to the menu bar being constructed:
    #---------------------------------------------------------------------------

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        item   = menu_item.item
        action = item.action

        if action.id != '':
            self.ui.info.bind( action.id, menu_item )

        if action.style == 'radio':
            if ((self._last_group is None) or
                (self._last_parent is not item.parent)):
                self._last_group = RadioGroup()
                self._last_parent = item.parent
            self._last_group.items.append( menu_item )
            menu_item.group = self._last_group

        if action.visible_when != '':
            self.ui.add_visible( action.visible_when, menu_item )

        if action.enabled_when != '':
            self.ui.add_enabled( action.enabled_when, menu_item )

        if action.checked_when != '':
            self.ui.add_checked( action.checked_when, menu_item )

    #---------------------------------------------------------------------------
    #  Adds a tool bar item to the tool bar being constructed:
    #---------------------------------------------------------------------------

    def add_to_toolbar ( self, toolbar_item ):
        """ Adds a toolbar item to the toolbar being constructed.
        """
        self.add_to_menu( toolbar_item )

    def can_add_to_menu(self, action, action_event=None):
        """Returns whether the action should be defined in the user interface.
        """
        if action.defined_when == '':
            return True

        return self.ui.eval_when(action.defined_when)

    def can_add_to_toolbar(self, action):
        """Returns whether the toolbar action should be defined in the user
           interface.
        """
        return self.can_add_to_menu(action)

########NEW FILE########
__FILENAME__ = ui_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#------------------------------------------------------------------------------

""" Defines the BasicUIEditor class, which allows creating editors that define
    their function by creating an embedded Traits UI.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traitsui.ui_editor import UIEditor as BaseUIEditor

from editor import Editor

#-------------------------------------------------------------------------------
#  'UIEditor' base class:
#-------------------------------------------------------------------------------

class UIEditor(BaseUIEditor, Editor):
    """ An editor that creates an embedded Traits UI.
    """
    pass

########NEW FILE########
__FILENAME__ = ui_live
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

"""Creates a PyQt user interface for a specified UI object, where the UI is
   "live", meaning that it immediately updates its underlying object(s).
"""


from pyface.qt import QtCore, QtGui

from traitsui.undo \
    import UndoHistory

from traitsui.menu \
    import UndoButton, RevertButton, OKButton, CancelButton, HelpButton

from ui_base \
    import BaseDialog

from ui_panel \
    import panel


#-------------------------------------------------------------------------------
#  Create the different 'live update' PyQt user interfaces.
#-------------------------------------------------------------------------------

def ui_live(ui, parent):
    """Creates a live, non-modal PyQt user interface for a specified UI object.
    """
    _ui_dialog(ui, parent, BaseDialog.NONMODAL)

def ui_livemodal(ui, parent):
    """Creates a live, modal PyQt user interface for a specified UI object.
    """
    _ui_dialog(ui, parent, BaseDialog.MODAL)

def ui_popup(ui, parent):
    """Creates a live, modal popup PyQt user interface for a specified UI
       object.
    """
    _ui_dialog(ui, parent, BaseDialog.POPUP)


def _ui_dialog(ui, parent, style):
    """Creates a live PyQt user interface for a specified UI object.
    """
    if ui.owner is None:
        ui.owner = _LiveWindow()

    BaseDialog.display_ui(ui, parent, style)


class _LiveWindow(BaseDialog):
    """User interface window that immediately updates its underlying object(s).
    """

    def init(self, ui, parent, style):
        """Initialise the object.

           FIXME: Note that we treat MODAL and POPUP as equivalent until we
           have an example that demonstrates how POPUP is supposed to work.
        """
        self.ui = ui
        self.control = ui.control
        view = ui.view
        history = ui.history

        if self.control is not None:
            if history is not None:
                history.on_trait_change(self._on_undoable, 'undoable',
                        remove=True)
                history.on_trait_change(self._on_redoable, 'redoable',
                        remove=True)
                history.on_trait_change(self._on_revertable, 'undoable',
                        remove=True)

            ui.reset()
        else:
            self.create_dialog(parent, style)

        self.set_icon(view.icon)

        # Convert the buttons to actions.
        buttons = [self.coerce_button(button) for button in view.buttons]
        nr_buttons = len(buttons)

        no_buttons = ((nr_buttons == 1) and self.is_button(buttons[0], ''))

        has_buttons = ((not no_buttons) and ((nr_buttons > 0) or view.undo or
                view.revert or view.ok or view.cancel))

        if has_buttons or (view.menubar is not None):
            if history is None:
                history = UndoHistory()
        else:
            history = None

        ui.history = history

        if (not no_buttons) and (has_buttons or view.help):
            bbox = QtGui.QDialogButtonBox()

            # Create the necessary special function buttons.
            if nr_buttons == 0:
                if view.undo:
                    self.check_button(buttons, UndoButton)
                if view.revert:
                    self.check_button(buttons, RevertButton)
                if view.ok:
                    self.check_button(buttons, OKButton)
                if view.cancel:
                    self.check_button(buttons, CancelButton)
                if view.help:
                    self.check_button(buttons, HelpButton)

            for raw_button, button in zip(view.buttons, buttons):
                default = raw_button == view.default_button
                
                if self.is_button(button, 'Undo'):
                    self.undo = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ActionRole, self._on_undo,
                            False, default=default)
                    history.on_trait_change(self._on_undoable, 'undoable',
                            dispatch='ui')
                    if history.can_undo:
                        self._on_undoable(True)

                    self.redo = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ActionRole, self._on_redo,
                            False, 'Redo')
                    history.on_trait_change(self._on_redoable, 'redoable',
                            dispatch='ui')
                    if history.can_redo:
                        self._on_redoable(True)

                elif self.is_button(button, 'Revert'):
                    self.revert = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ResetRole, self._on_revert,
                            False, default=default)
                    history.on_trait_change(self._on_revertable, 'undoable',
                            dispatch='ui')
                    if history.can_undo:
                        self._on_revertable(True)

                elif self.is_button(button, 'OK'):
                    self.ok = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.AcceptRole,
                            self.control.accept, default=default)
                    ui.on_trait_change(self._on_error, 'errors', dispatch='ui')

                elif self.is_button(button, 'Cancel'):
                    self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.RejectRole,
                            self.control.reject, default=default)

                elif self.is_button(button, 'Help'):
                    self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.HelpRole, self._on_help,
                            default=default)

                elif not self.is_button(button, ''):
                    self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ActionRole, default=default)

        else:
            bbox = None

        self.add_contents(panel(ui), bbox)

    def close(self, rc=True):
        """Close the dialog and set the given return code.
        """
        super(_LiveWindow, self).close(rc)

        self.undo = self.redo = self.revert = None

    def _on_finished(self, result):
        """Handles the user finishing with the dialog.
        """
        accept = bool(result)

        if not accept and self.ui.history is not None:
            self._on_revert()

        self.close(accept)

########NEW FILE########
__FILENAME__ = ui_modal
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

"""Creates a PyQt user interface for a specified UI object.
"""


from pyface.qt import QtCore, QtGui

from traitsui.menu \
    import ApplyButton, RevertButton, OKButton, CancelButton, HelpButton

from ui_base \
    import BaseDialog

from ui_panel \
    import panel


#-------------------------------------------------------------------------------
#  Create the different modal PyQt user interfaces.
#-------------------------------------------------------------------------------

def ui_modal(ui, parent):
    """Creates a modal PyQt user interface for a specified UI object.
    """
    _ui_dialog(ui, parent, BaseDialog.MODAL)

def ui_nonmodal(ui, parent):
    """Creates a non-modal PyQt user interface for a specified UI object.
    """
    _ui_dialog(ui, parent, BaseDialog.NONMODAL)


def _ui_dialog(ui, parent, style):
    """Creates a PyQt dialog box for a specified UI object.

       Changes are not immediately applied to the underlying object.  The user
       must click **Apply** or **OK** to apply changes.  The user can revert
       changes by clicking **Revert** or **Cancel**.
    """
    if ui.owner is None:
        ui.owner = _ModalDialog()

    BaseDialog.display_ui(ui, parent, style)


class _ModalDialog(BaseDialog):
    """Modal dialog box for Traits-based user interfaces.
    """

    def init(self, ui, parent, style):
        """Initialise the object.
        """
        self.ui = ui
        self.control = ui.control
        view = ui.view

        revert = apply = False

        if self.control is not None:
            if hasattr(self, 'revert'):
                revert = self.revert.isEnabled()

            if hasattr(self, 'apply'):
                apply = self.apply.isEnabled()

            ui.reset()
        else:
            self.create_dialog(parent, style)

            # Create the 'context' copies we will need while editing:
            context = ui.context
            ui._context = context
            ui.context = self._copy_context(context)
            ui._revert = self._copy_context(context)

        self.set_icon(view.icon)

        # Convert the buttons to actions.
        buttons = [self.coerce_button(button) for button in view.buttons]
        nr_buttons = len(buttons)

        if (nr_buttons != 1) or (not self.is_button(buttons[0], '')):
            bbox = QtGui.QDialogButtonBox()

            # Create the necessary special function buttons.
            if nr_buttons == 0:
                if view.apply:
                    self.check_button(buttons, ApplyButton)
                    if view.revert:
                        self.check_button(buttons, RevertButton)
                if view.ok:
                    self.check_button(buttons, OKButton)
                if view.cancel:
                    self.check_button(buttons, CancelButton)
                if view.help:
                    self.check_button(buttons, HelpButton)

            for raw_button, button in zip(view.buttons, buttons):
                default = raw_button == view.default_button
                
                if self.is_button(button, 'Apply'):
                    self.apply = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ApplyRole, self._on_apply,
                            enabled=apply, default=default)
                    ui.on_trait_change(self._on_applyable, 'modified',
                            dispatch='ui')

                elif self.is_button(button, 'Revert'):
                    self.revert = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ResetRole, self._on_revert,
                            enabled=revert, default=default)

                elif self.is_button(button, 'OK'):
                    self.ok = self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.AcceptRole,
                            self.control.accept, default=default)
                    ui.on_trait_change(self._on_error, 'errors', dispatch='ui')

                elif self.is_button(button, 'Cancel'):
                    self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.RejectRole,
                            self.control.reject, default=default)

                elif self.is_button(button, 'Help'):
                    self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.HelpRole, self._on_help,
                            default=default)

                elif not self.is_button(button, ''):
                    self.add_button(button, bbox,
                            QtGui.QDialogButtonBox.ActionRole, default=default)

        else:
            bbox = None

        self.add_contents(panel(ui), bbox)

    def close(self, rc):
        """Close the dialog and set the given return code.
        """
        super(_ModalDialog, self).close(rc)

        self.apply = self.revert = self.help = None

    def _copy_context(self, context):
        """Creates a copy of a *context* dictionary.
        """
        result = {}
        for name, value in context.items():
            if value is not None:
                result[name] = value.clone_traits()
            else:
                result[name] = None

        return result

    def _apply_context(self, from_context, to_context):
        """Applies the traits in the *from_context* to the *to_context*.
        """
        for name, value in from_context.items():
            if value is not None:
                to_context[name].copy_traits(value)
            else:
                to_context[name] = None

        if to_context is self.ui._context:
            on_apply = self.ui.view.on_apply
            if on_apply is not None:
                on_apply()

    def _on_finished(self, result):
        """Handles the user finishing with the dialog.
        """
        accept = bool(result)

        if accept:
            self._apply_context(self.ui.context, self.ui._context)
        else:
            self._apply_context(self.ui._revert, self.ui._context)

        self.close(accept)

    def _on_apply(self):
        """Handles a request to apply changes.
        """
        ui = self.ui
        self._apply_context(ui.context, ui._context)
        self.revert.setEnabled(True)
        ui.handler.apply(ui.info)
        ui.modified = False

    def _on_applyable(self, state):
        """Handles a change to the "modified" state of the user interface .
        """
        self.apply.setEnabled( state )

    def _on_revert(self):
        """Handles a request to revert changes.
        """
        ui = self.ui
        self._apply_context(ui._revert, ui.context)
        self._apply_context(ui._revert, ui._context)
        self.revert.setEnabled(False)
        ui.handler.revert(ui.info)
        ui.modified = False

########NEW FILE########
__FILENAME__ = ui_panel
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described
# in the PyQt GPL exception also apply.
#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

"""Creates a panel-based PyQt user interface for a specified UI object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import cgi
import re

from pyface.qt import QtCore, QtGui

from traits.api \
    import Any, Instance, Undefined

from traitsui.api \
    import Group

from traits.trait_base \
    import enumerate

from traitsui.undo \
    import UndoHistory

from traitsui.help_template \
    import help_template

from traitsui.menu \
    import UndoButton, RevertButton, HelpButton

from helper \
    import position_window

from ui_base \
    import BasePanel

from editor \
    import Editor


#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

#: Characters that are considered punctuation symbols at the end of a label.
#: If a label ends with one of these charactes, we do not append a colon.
LABEL_PUNCTUATION_CHARS = '?=:;,.<>/\\"\'-+#|'

# Pattern of all digits
all_digits = re.compile(r'\d+')


#-------------------------------------------------------------------------------
#  Create the different panel-based PyQt user interfaces.
#-------------------------------------------------------------------------------

def ui_panel(ui, parent):
    """Creates a panel-based PyQt user interface for a specified UI object.
    """
    _ui_panel_for(ui, parent, False)


def ui_subpanel(ui, parent):
    """Creates a subpanel-based PyQt user interface for a specified UI object.
       A subpanel does not allow control buttons (other than those specified in
       the UI object) and does not show headers for view titles.
    """
    _ui_panel_for(ui, parent, True)


def _ui_panel_for(ui, parent, is_subpanel):
    """Creates a panel-based PyQt user interface for a specified UI object.
    """
    ui.control = control = _Panel(ui, parent, is_subpanel).control

    control._parent = parent
    control._object = ui.context.get('object')
    control._ui = ui

    try:
        ui.prepare_ui()
    except:
        control.setParent(None)
        del control
        ui.control = None
        ui.result = False
        raise

    ui.restore_prefs()
    ui.result = True


class _Panel(BasePanel):
    """PyQt user interface panel for Traits-based user interfaces.
    """

    def __init__(self, ui, parent, is_subpanel):
        """Initialise the object.
        """
        self.ui = ui
        history = ui.history
        view = ui.view

        # Reset any existing history listeners.
        if history is not None:
            history.on_trait_change(self._on_undoable, 'undoable', remove=True)
            history.on_trait_change(self._on_redoable, 'redoable', remove=True)
            history.on_trait_change(self._on_revertable, 'undoable',
                    remove=True)

        # Determine if we need any buttons or an 'undo' history.
        buttons = [self.coerce_button(button) for button in view.buttons]
        nr_buttons = len(buttons)
        has_buttons = (not is_subpanel and (nr_buttons != 1 or
                                            not self.is_button(buttons[0], '')))

        if nr_buttons == 0:
            if view.undo:
                self.check_button(buttons, UndoButton)
            if view.revert:
                self.check_button(buttons, RevertButton)
            if view.help:
                self.check_button(buttons, HelpButton)

        if not is_subpanel and history is None:
            for button in buttons:
                if self.is_button(button, 'Undo') or self.is_button(button, 'Revert'):
                    history = ui.history = UndoHistory()
                    break

        # Create the panel.
        self.control = panel(ui)

        # Suppress the title if this is a subpanel or if we think it should be
        # superceded by the title of an "outer" widget (eg. a dock widget).
        title = view.title
        if (is_subpanel or (isinstance(parent, QtGui.QMainWindow) and
                            not isinstance(parent.parent(), QtGui.QDialog)) or
            isinstance(parent, QtGui.QTabWidget)):
            title = ""

        # Panels must be widgets as it is only the TraitsUI PyQt code that can
        # handle them being layouts as well.  Therefore create a widget if the
        # panel is not a widget or if we need a title or buttons.
        if not isinstance(self.control, QtGui.QWidget) or title != "" or has_buttons:
            w = QtGui.QWidget()
            layout = QtGui.QVBoxLayout(w)
            layout.setContentsMargins(0, 0, 0, 0)

            # Handle any view title.
            if title != "":
                layout.addWidget(heading_text(None, text=view.title).control)

            if isinstance(self.control, QtGui.QWidget):
                layout.addWidget(self.control)
            elif isinstance(self.control, QtGui.QLayout):
                layout.addLayout(self.control)

            self.control = w

            # Add any buttons.
            if has_buttons:

                # Add the horizontal separator
                separator = QtGui.QFrame()
                separator.setFrameStyle(QtGui.QFrame.Sunken |
                                        QtGui.QFrame.HLine)
                separator.setFixedHeight(2)
                layout.addWidget(separator)

                # Add the special function buttons
                bbox = QtGui.QDialogButtonBox(QtCore.Qt.Horizontal)
                for button in buttons:
                    role = QtGui.QDialogButtonBox.ActionRole
                    if self.is_button(button, 'Undo'):
                        self.undo = self.add_button(button, bbox, role,
                                                    self._on_undo, False,
                                                    'Undo')
                        self.redo = self.add_button(button, bbox, role,
                                                    self._on_redo, False,
                                                    'Redo')
                        history.on_trait_change(self._on_undoable, 'undoable',
                                                dispatch = 'ui')
                        history.on_trait_change(self._on_redoable, 'redoable',
                                                dispatch = 'ui')
                    elif self.is_button(button, 'Revert'):
                        role = QtGui.QDialogButtonBox.ResetRole
                        self.revert = self.add_button(button, bbox, role,
                                                      self._on_revert, False)
                        history.on_trait_change(self._on_revertable, 'undoable',
                                                dispatch = 'ui')
                    elif self.is_button(button, 'Help'):
                        role = QtGui.QDialogButtonBox.HelpRole
                        self.add_button(button, bbox, role, self._on_help)
                    elif not self.is_button(button, ''):
                        self.add_button(button, bbox, role)
                layout.addWidget(bbox)

        # Ensure the control has a size hint reflecting the View specification.
        # Yes, this is a hack, but it's too late to repair this convoluted
        # control building process, so we do what we have to...
        self.control.sizeHint = _size_hint_wrapper(self.control.sizeHint, ui)


def panel(ui):
    """Creates a panel-based PyQt user interface for a specified UI object.
       This function does not modify the UI object passed to it.  The object
       returned may be either a widget, a layout or None.
    """
    # Bind the context values to the 'info' object:
    ui.info.bind_context()

    # Get the content that will be displayed in the user interface:
    content = ui._groups
    nr_groups = len(content)

    if nr_groups == 0:
        panel = None
    if nr_groups == 1:
        panel = _GroupPanel(content[0], ui).control
    elif nr_groups > 1:
        panel = QtGui.QTabWidget()
        # Identify ourselves as being a Tabbed group so we can later
        # distinguish this from other QTabWidgets.
        panel.setProperty("traits_tabbed_group", True)
        _fill_panel(panel, content, ui)
        panel.ui = ui

    # If the UI is scrollable then wrap the panel in a scroll area.
    if ui.scrollable and panel is not None:
        # Make sure the panel is a widget.
        if isinstance(panel, QtGui.QLayout):
            w = QtGui.QWidget()
            w.setLayout(panel)
            panel = w

        sa = QtGui.QScrollArea()
        sa.setWidget(panel)
        sa.setWidgetResizable(True)
        panel = sa

    return panel


def _fill_panel(panel, content, ui, item_handler=None):
    """Fill a page based container panel with content.
    """
    active = 0

    for index, item in enumerate(content):
        page_name = item.get_label(ui)
        if page_name == "":
           page_name = "Page %d" % index

        if isinstance(item, Group):
            if item.selected:
                active = index

            gp = _GroupPanel(item, ui, suppress_label=True)
            page = gp.control
            sub_page = gp.sub_control

            # If the result is the same type with only one page, collapse it
            # down into just the page.
            if type(sub_page) is type(panel) and sub_page.count() == 1:
                new = sub_page.widget(0)
                if isinstance(panel, QtGui.QTabWidget):
                    sub_page.removeTab(0)
                else:
                    sub_page.removeItem(0)
            elif isinstance(page, QtGui.QWidget):
                new = page
            else:
                new = QtGui.QWidget()
                new.setLayout(page)

            layout = new.layout()
            if layout is not None:
                layout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)

        else:
            new = QtGui.QWidget()
            layout = QtGui.QVBoxLayout(new)
            layout.setContentsMargins(0, 0, 0, 0)
            item_handler(item, layout)

        # Add the content.
        if isinstance(panel, QtGui.QTabWidget):
            panel.addTab(new, page_name)
        else:
            panel.addItem(new, page_name)

    panel.setCurrentIndex(active)


def _size_hint_wrapper(f, ui):
    """Wrap an existing sizeHint method with sizes from a UI object.
    """
    def sizeHint():
        size = f()
        if ui.view.width > 0:
            size.setWidth(ui.view.width)
        if ui.view.height > 0:
            size.setHeight(ui.view.height)
        return size
    return sizeHint

#-------------------------------------------------------------------------------
#  Displays a help window for the specified UI's active Group:
#-------------------------------------------------------------------------------

def show_help ( ui, button ):
    """ Displays a help window for the specified UI's active Group.
    """
    group    = ui._groups[ ui._active_group ]
    template = help_template()
    if group.help != '':
        header = template.group_help % cgi.escape( group.help )
    else:
        header = template.no_group_help
    fields = []
    for item in group.get_content( False ):
        if not item.is_spacer():
            fields.append( template.item_help % (
                           cgi.escape( item.get_label( ui ) ),
                           cgi.escape( item.get_help( ui ) ) ) )
    html = template.group_html % ( header, '\n'.join( fields ) )
    HTMLHelpWindow( button, html, .25, .33 )

#-------------------------------------------------------------------------------
#  Displays a pop-up help window for a single trait:
#-------------------------------------------------------------------------------

def show_help_popup ( event ):
    """ Displays a pop-up help window for a single trait.
    """
    control  = event.GetEventObject()
    template = help_template()

    # Note: The following check is necessary because under Linux, we get back
    # a control which does not have the 'help' trait defined (it is the parent
    # of the object with the 'help' trait):
    help = getattr( control, 'help', None )
    if help is not None:
        html = template.item_html % ( control.GetLabel(), help )
        HTMLHelpWindow( control, html, .25, .13 )


class _GroupSplitter(QtGui.QSplitter):
    """ A splitter for a Traits UI Group with layout='split'.
    """

    def __init__(self, group):
        """ Store the group.
        """
        QtGui.QSplitter.__init__(self)
        self._group = group
        self._initialized = False

    def resizeEvent(self, event):
        """ Overridden to position the splitter based on the Group when the
            application is initializing.

            Because the splitter layout algorithm requires that the available
            space be known, we have to wait until the UI that contains this
            splitter gives it its initial size.
        """
        QtGui.QSplitter.resizeEvent(self, event)

        parent = self.parent()
        if (not self._initialized and parent and
            (self.isVisible() or isinstance(parent, QtGui.QMainWindow))):
            self._initialized = True
            self._resize_items()

    def showEvent(self, event):
        """ Wait for the show event to resize items if necessary.
        """
        QtGui.QSplitter.showEvent(self, event)
        if not self._initialized:
            self._initialized = True
            self._resize_items()

    def _resize_items(self):
        """ Size the splitter based on the 'width' or 'height' attributes
            of the Traits UI view elements.
        """
        use_widths = (self.orientation() == QtCore.Qt.Horizontal)

        # Get the requested size for the items.
        sizes = []
        for item in self._group.content:
            if use_widths:
                sizes.append(item.width)
            else:
                sizes.append(item.height)

        # Find out how much space is available.
        if use_widths:
            total = self.width()
        else:
            total = self.height()

        # Allocate requested space.
        avail = total
        remain = 0
        for i, sz in enumerate(sizes):
            if avail <= 0:
                break

            if sz >= 0:
                if sz >= 1:
                    sz = min(sz, avail)
                else:
                    sz *= total

                sz = int(sz)
                sizes[i] = sz
                avail -= sz
            else:
                remain += 1

        # Allocate the remainder to those parts that didn't request a width.
        if remain > 0:
            remain = int(avail / remain)

            for i, sz in enumerate(sizes):
                if sz < 0:
                    sizes[i] = remain

        # If all requested a width, allocate the remainder to the last item.
        else:
            sizes[-1] += avail

        self.setSizes(sizes)


class _GroupPanel(object):
    """A sub-panel for a single group of items.  It may be either a layout or a
       widget.
    """

    def __init__(self, group, ui, suppress_label=False):
        """Initialise the object.
        """
        # Get the contents of the group:
        content = group.get_content()

        # Save these for other methods.
        self.group = group
        self.ui = ui

        if group.orientation == 'horizontal':
            self.direction = QtGui.QBoxLayout.LeftToRight
        else:
            self.direction = QtGui.QBoxLayout.TopToBottom

        # outer is the top-level widget or layout that will eventually be
        # returned.  sub is the QTabWidget or QToolBox corresponding to any
        # 'tabbed' or 'fold' layout.  It is only used to collapse nested
        # widgets.  inner is the object (not necessarily a layout) that new
        # controls should be added to.
        outer = sub = inner = None

        # Get the group label.
        if suppress_label:
            label = ""
        else:
            label = group.label

        # Create a border if requested.
        if group.show_border:
            outer = QtGui.QGroupBox(label)
            inner = QtGui.QBoxLayout(self.direction, outer)

        elif label != "":
            outer = inner = QtGui.QBoxLayout(self.direction)
            inner.addWidget(heading_text(None, text=label).control)

        # Add the layout specific content.
        if len(content) == 0:
            pass

        elif group.layout == 'flow':
            raise NotImplementedError, "'the 'flow' layout isn't implemented"

        elif group.layout == 'split':
            # Create the splitter.
            splitter = _GroupSplitter(group)
            splitter.setOpaqueResize(False) # Mimic wx backend resize behavior
            if self.direction == QtGui.QBoxLayout.TopToBottom:
                splitter.setOrientation(QtCore.Qt.Vertical)

            # Make sure the splitter will expand to fill available space
            policy = splitter.sizePolicy()
            policy.setHorizontalStretch(50)
            policy.setVerticalStretch(50)
            if group.orientation == 'horizontal':
                policy.setVerticalPolicy(QtGui.QSizePolicy.Expanding)
            else:
                policy.setHorizontalPolicy(QtGui.QSizePolicy.Expanding)
            splitter.setSizePolicy(policy)

            if outer is None:
                outer = splitter
            else:
                inner.addWidget(splitter)

            # Create an editor.
            editor = SplitterGroupEditor(control=outer, splitter=splitter,ui=ui)
            self._setup_editor(group, editor)

            self._add_splitter_items(content, splitter)

        elif group.layout in ('tabbed', 'fold'):
            # Create the TabWidget or ToolBox.
            if group.layout == 'tabbed':
                sub = QtGui.QTabWidget()
                sub.setProperty("traits_tabbed_group", True)
            else:
                sub = QtGui.QToolBox()

            # Give tab/tool widget stretch factor equivalent to default stretch
            # factory for a resizeable item. See end of '_add_items'.
            policy = sub.sizePolicy()
            policy.setHorizontalStretch(50)
            policy.setVerticalStretch(50)
            sub.setSizePolicy(policy)

            _fill_panel(sub, content, self.ui, self._add_page_item)

            if outer is None:
                outer = sub
            else:
                inner.addWidget(sub)

            # Create an editor.
            editor = TabbedFoldGroupEditor(container=sub, control=outer, ui=ui)
            self._setup_editor(group, editor)

        else:
            # See if we need to control the visual appearance of the group.
            if group.visible_when != '' or group.enabled_when != '':
                # Make sure that outer is a widget and inner is a layout.
                # Hiding a layout is not properly supported by Qt (the
                # workaround in ``traitsui.qt4.editor._visible_changed_helper``
                # often leaves undesirable blank space).
                if outer is None:
                    outer = inner = QtGui.QBoxLayout(self.direction)
                if isinstance(outer, QtGui.QLayout):
                    widget = QtGui.QWidget()
                    widget.setLayout(outer)
                    outer = widget

                # Create an editor.
                self._setup_editor(group, GroupEditor(control=outer))

            if isinstance(content[0], Group):
                layout = self._add_groups(content, inner)
            else:
                layout = self._add_items(content, inner)
            layout.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)

            if outer is None:
                outer = layout
            elif layout is not inner:
                inner.addLayout(layout)

        if group.style_sheet :
            if isinstance(outer, QtGui.QLayout) :
                inner = outer
                outer = QtGui.QWidget()
                outer.setLayout(inner)

            # ensure this is not empty group
            if isinstance(outer, QtGui.QWidget) :
                outer.setStyleSheet(group.style_sheet)

        # Publish the top-level widget, layout or None.
        self.control = outer

        # Publish the optional sub-control.
        self.sub_control = sub

    def _add_splitter_items(self, content, splitter):
        """Adds a set of groups or items separated by splitter bars.
        """
        for item in content:

            # Get a panel for the Item or Group.
            if isinstance(item, Group):
                panel = _GroupPanel(item, self.ui, suppress_label=True).control
            else:
                panel = self._add_items([item])

            # Add the panel to the splitter.
            if panel is not None:
                if isinstance(panel, QtGui.QLayout):
                    # A QSplitter needs a widget.
                    w = QtGui.QWidget()
                    panel.setContentsMargins(0, 0, 0, 0)
                    w.setLayout(panel)
                    panel = w

                layout = panel.layout()
                if layout is not None:
                    layout.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)

                splitter.addWidget(panel)

    def _setup_editor(self, group, editor):
        """Setup the editor for a group.
        """
        if group.id != '':
            self.ui.info.bind(group.id, editor)

        if group.visible_when != '':
            self.ui.add_visible(group.visible_when, editor)

        if group.enabled_when != '':
            self.ui.add_enabled(group.enabled_when, editor)

    def _add_page_item(self, item, layout):
        """Adds a single Item to a page based panel.
        """
        self._add_items([item], layout)

    def _add_groups(self, content, outer):
        """Adds a list of Group objects to the panel, creating a layout if
           needed.  Return the outermost layout.
        """
        # Use the existing layout if there is one.
        if outer is None:
            outer = QtGui.QBoxLayout(self.direction)

        # Process each group.
        for subgroup in content:
            panel = _GroupPanel(subgroup, self.ui).control

            if isinstance(panel, QtGui.QWidget):
                outer.addWidget(panel)
            elif isinstance(panel, QtGui.QLayout):
                outer.addLayout(panel)
            else:
                # The sub-group is empty which seems to be used as a way of
                # providing some whitespace.
                outer.addWidget(QtGui.QLabel(' '))

        return outer


    def _add_items(self, content, outer=None):
        """Adds a list of Item objects, creating a layout if needed.  Return
           the outermost layout.
        """
        # Get local references to various objects we need:
        ui = self.ui
        info = ui.info
        handler = ui.handler

        group = self.group
        show_left = group.show_left
        columns = group.columns

        # See if a label is needed.
        show_labels = False
        for item in content:
            show_labels |= item.show_label

        # See if a grid layout is needed.
        if show_labels or columns > 1:
            inner = QtGui.QGridLayout()

            if outer is None:
                outer = inner
            else:
                outer.addLayout(inner)

            row = 0
            if show_left:
                label_alignment = QtCore.Qt.AlignRight
            else:
                label_alignment = QtCore.Qt.AlignLeft

        else:
            # Use the existing layout if there is one.
            if outer is None:
                outer = QtGui.QBoxLayout(self.direction)

            inner = outer

            row = -1
            label_alignment = 0

        # Process each Item in the list:
        col = -1
        for item in content:

            # Keep a track of the current logical row and column unless the
            # layout is not a grid.
            col += 1
            if row >= 0 and col >= columns:
                col = 0
                row += 1

            # Get the name in order to determine its type:
            name = item.name

            # Check if is a label:
            if name == '':
                label = item.label
                if label != "":

                    # Create the label widget.
                    if item.style == 'simple':
                        label = QtGui.QLabel(label)
                    else:
                        label = heading_text(None, text=label).control

                    self._add_widget(inner, label, row, col, show_labels)

                    if item.emphasized:
                        self._add_emphasis(label)

                # Continue on to the next Item in the list:
                continue

            # Check if it is a separator:
            if name == '_':
                cols = columns

                # See if the layout is a grid.
                if row >= 0:
                    # Move to the start of the next row if necessary.
                    if col > 0:
                        col = 0
                        row += 1

                    # Skip the row we are about to do.
                    row += 1

                    # Allow for the columns.
                    if show_labels:
                        cols *= 2

                for i in range(cols):
                    line = QtGui.QFrame()

                    if self.direction == QtGui.QBoxLayout.LeftToRight:
                        # Add a vertical separator:
                        line.setFrameShape(QtGui.QFrame.VLine)
                        if row < 0:
                            inner.addWidget(line)
                        else:
                            inner.addWidget(line, i, row)
                    else:
                        # Add a horizontal separator:
                        line.setFrameShape(QtGui.QFrame.HLine)
                        if row < 0:
                            inner.addWidget(line)
                        else:
                            inner.addWidget(line, row, i)

                    line.setFrameShadow(QtGui.QFrame.Sunken)

                # Continue on to the next Item in the list:
                continue

            # Convert a blank to a 5 pixel spacer:
            if name == ' ':
                name = '5'

            # Check if it is a spacer:
            if all_digits.match( name ):

                # If so, add the appropriate amount of space to the layout:
                n = int( name )
                if self.direction == QtGui.QBoxLayout.LeftToRight:
                    # Add a horizontal spacer:
                    spacer = QtGui.QSpacerItem(n, 1)
                else:
                    # Add a vertical spacer:
                    spacer = QtGui.QSpacerItem(1, n)

                self._add_widget(inner, spacer, row, col, show_labels)

                # Continue on to the next Item in the list:
                continue

            # Otherwise, it must be a trait Item:
            object      = eval( item.object_, globals(), ui.context )
            trait       = object.base_trait( name )
            desc        = trait.desc or ''

            # Get the editor factory associated with the Item:
            editor_factory = item.editor
            if editor_factory is None:
                editor_factory = trait.get_editor().set(**item.editor_args)

                # If still no editor factory found, use a default text editor:
                if editor_factory is None:
                    from text_editor import ToolkitEditorFactory
                    editor_factory = ToolkitEditorFactory()

                # If the item has formatting traits set them in the editor
                # factory:
                if item.format_func is not None:
                    editor_factory.format_func = item.format_func

                if item.format_str != '':
                    editor_factory.format_str = item.format_str

                # If the item has an invalid state extended trait name, set it
                # in the editor factory:
                if item.invalid != '':
                    editor_factory.invalid = item.invalid

            # Create the requested type of editor from the editor factory:
            factory_method = getattr( editor_factory, item.style + '_editor' )
            editor = factory_method(
                ui, object, name, item.tooltip, None
            ).set(item = item, object_name = item.object )

            # Tell the editor to actually build the editing widget.  Note that
            # "inner" is a layout.  This shouldn't matter as individual editors
            # shouldn't be using it as a parent anyway.  The important thing is
            # that it is not None (otherwise the main TraitsUI code can change
            # the "kind" of the created UI object).
            editor.prepare(inner)
            control = editor.control

            if item.style_sheet :
                control.setStyleSheet(item.style_sheet)

            # Set the initial 'enabled' state of the editor from the factory:
            editor.enabled = editor_factory.enabled

            # Handle any label.
            if item.show_label:
                label = self._create_label(item, ui, desc)
                self._add_widget(inner, label, row, col, show_labels,
                                 label_alignment)
            else:
                label = None

            editor.label_control = label

            # Add emphasis to the editor control if requested:
            if item.emphasized:
                self._add_emphasis(control)

            # Give the editor focus if it requested it:
            if item.has_focus:
                control.setFocus()

            # Set the correct size on the control, as specified by the user:
            stretch = 0
            item_width = item.width
            item_height = item.height
            if (item_width != -1) or (item_height != -1):
                is_horizontal = (self.direction == QtGui.QBoxLayout.LeftToRight)

                min_size = control.minimumSizeHint()
                width = min_size.width()
                height = min_size.height()

                force_width  = False
                force_height = False

                if (0.0 < item_width <= 1.0) and is_horizontal:
                    stretch = int(100 * item_width)

                item_width = int(item_width)
                if item_width < -1:
                    item_width  = -item_width
                    force_width = True
                else:
                    item_width = max(item_width, width)

                if (0.0 < item_height <= 1.0) and (not is_horizontal):
                    stretch = int(100 * item_height)

                item_height = int(item_height)
                if item_height < -1:
                    item_height = -item_height
                    force_height = True
                else:
                    item_height = max(item_height, height)

                control.setMinimumWidth(max(item_width, 0))
                control.setMinimumHeight(max(item_height, 0))
                if (stretch == 0 or not is_horizontal) and force_width :
                    control.setMaximumWidth(item_width)
                if (stretch == 0 or is_horizontal) and force_height :
                    control.setMaximumHeight(item_height)

            # Set size and stretch policies
            self._set_item_size_policy(editor, item, label, stretch)

            # Add the created editor control to the layout
            # FIXME: Need to decide what to do about border_size and padding
            self._add_widget(inner, control, row, col, show_labels)

            # ---- Update the UI object

            # Bind the editor into the UIInfo object name space so it can be
            # referred to by a Handler while the user interface is active:
            id = item.id or name
            info.bind( id, editor, item.id )

            self.ui._scrollable |= editor.scrollable

            # Also, add the editors to the list of editors used to construct
            # the user interface:
            ui._editors.append( editor )

            # If the handler wants to be notified when the editor is created,
            # add it to the list of methods to be called when the UI is
            # complete:
            defined = getattr( handler, id + '_defined', None )
            if defined is not None:
                ui.add_defined( defined )

            # If the editor is conditionally visible, add the visibility
            # 'expression' and the editor to the UI object's list of monitored
            # objects:
            if item.visible_when != '':
                ui.add_visible( item.visible_when, editor )

            # If the editor is conditionally enabled, add the enabling
            # 'expression' and the editor to the UI object's list of monitored
            # objects:
            if item.enabled_when != '':
                ui.add_enabled( item.enabled_when, editor )

        return outer


    def _set_item_size_policy(self, editor, item, label, stretch):
        """ Set size policy of an item and its label (if any).

        How it is set:

        1) The general rule is that we obey the item.resizable and
           item.springy settings. An item is considered resizable also if
           resizable is Undefined but the item is scrollable

        2) However, if the labels are on the right, and the item is of a
           kind that cannot be stretched in horizontal (e.g. a checkbox),
           we make the label stretchable instead (to avoid big gaps
           between element and label)

        If the item is resizable, the _GroupPanel is set to be resizable.
        """

        is_label_left = self.group.show_left

        is_item_resizable = (
            (item.resizable is True) or
            ((item.resizable is Undefined) and editor.scrollable)
            )
        is_item_springy = item.springy

        # handle exceptional case 2)
        item_policy = editor.control.sizePolicy().horizontalPolicy()

        if (label is not None
            and not is_label_left
            and item_policy == QtGui.QSizePolicy.Minimum):
            # this item cannot be stretched horizontally, and the label
            # exists and is on the right -> make label stretchable if necessary

            if (self.direction == QtGui.QBoxLayout.LeftToRight
                and is_item_springy):
                is_item_springy = False
                self._make_label_h_stretchable(label, stretch or 50)

            elif (self.direction == QtGui.QBoxLayout.TopToBottom
                  and is_item_resizable):
                is_item_resizable = False
                self._make_label_h_stretchable(label, stretch or 50)

        if is_item_resizable:
            stretch = stretch or 50
            # FIXME: resizable is not defined as trait, were is it used?
            self.resizable = True
        elif is_item_springy:
            stretch = stretch or 50

        editor.set_size_policy(self.direction,
                               is_item_resizable, is_item_springy, stretch)
        return stretch


    def _make_label_h_stretchable(self, label, stretch):
        """ Set size policies of a QLabel to be stretchable horizontally.

        :attr:`stretch` is the stretch factor that Qt uses to distribute the
        total size to individual elements
        """
        label_policy = label.sizePolicy()
        label_policy.setHorizontalStretch(stretch)
        label_policy.setHorizontalPolicy(
            QtGui.QSizePolicy.Expanding)
        label.setSizePolicy(label_policy)


    def _add_widget(self, layout, w, row, column, show_labels,
                    label_alignment=QtCore.Qt.AlignmentFlag(0)):
        """Adds a widget to a layout taking into account the orientation and
           the position of any labels.
        """
        # If the widget really is a widget then remove any margin so that it
        # fills the cell.
        if isinstance(w, QtGui.QWidget):
            wl = w.layout()
            if wl is not None:
                wl.setContentsMargins(0, 0, 0, 0)

        # See if the layout is a grid.
        if row < 0:
            if isinstance(w, QtGui.QWidget):
                layout.addWidget(w)
            elif isinstance(w, QtGui.QLayout):
                layout.addLayout(w)
            else:
                layout.addItem(w)

        else:
            if self.direction == QtGui.QBoxLayout.LeftToRight:
                # Flip the row and column.
                row, column = column, row

            if show_labels:
                # Convert the "logical" column to a "physical" one.
                column *= 2

                # Determine whether to place widget on left or right of
                # "logical" column.
                if (label_alignment != 0 and not self.group.show_left) or \
                   (label_alignment == 0 and self.group.show_left):
                    column += 1

            if isinstance(w, QtGui.QWidget):
                layout.addWidget(w, row, column, label_alignment)
            elif isinstance(w, QtGui.QLayout):
                layout.addLayout(w, row, column, label_alignment)
            else:
                layout.addItem(w, row, column, 1, 1, label_alignment)


    def _create_label(self, item, ui, desc, suffix=':'):
        """Creates an item label.

        When the label is on the left of its component,
        it is not empty, and it does not end with a
        punctuation character (see :attr:`LABEL_PUNCTUATION_CHARS`),
        we append a suffix (by default a colon ':') at the end of the
        label text.

        We also set the help on the QLabel control (from item.help) and
        the tooltip (it item.desc exists; we add "Specifies " at the start
        of the item.desc string).

        Parameters
        ----------
        item : Item
            The item for which we want to create a label
        ui : UI
            Current ui object
        desc : string
            Description of the item, to create an appropriate tooltip
        suffix : string
            Characters to at the end of the label

        Returns
        -------
        label_control : QLabel
            The control for the label
        """

        label = item.get_label(ui)

        # append a suffix if the label is on the left and it does
        # not already end with a punctuation character
        if (label != ''
            and label[-1] not in LABEL_PUNCTUATION_CHARS
            and self.group.show_left):
            label = label + suffix

        # create label controller
        label_control = QtGui.QLabel(label)

        if item.emphasized:
            self._add_emphasis(label_control)

        # FIXME: Decide what to do about the help.  (The non-standard wx way,
        # What's This style help, both?)
        #wx.EVT_LEFT_UP( control, show_help_popup )
        label_control.help = item.get_help(ui)

        # FIXME: do people rely on traitsui adding 'Specifies ' to the start
        # of every tooltip? It's not flexible at all
        if desc != '':
            label_control.setToolTip('Specifies ' + desc)

        return label_control


    def _add_emphasis(self, control):
        """Adds emphasis to a specified control's font.
        """
        # Set the foreground colour.
        pal = QtGui.QPalette(control.palette())
        pal.setColor(QtGui.QPalette.WindowText, QtGui.QColor(0, 0, 127))
        control.setPalette(pal)

        # Set the font.
        font = QtGui.QFont(control.font())
        font.setBold(True)
        font.setPointSize(font.pointSize())
        control.setFont(font)


class GroupEditor(Editor):
    """ A pseudo-editor that allows a group to be managed.
    """

    def __init__(self, **traits):
        """ Initialise the object.
        """
        self.set(**traits)


class SplitterGroupEditor(GroupEditor):
    """ A pseudo-editor that allows a group with a 'split' layout to be managed.
    """

    # The QSplitter for the group
    splitter = Instance(_GroupSplitter)

    #-- UI preference save/restore interface -----------------------------------

    def restore_prefs(self, prefs):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if isinstance(prefs, dict):
            structure = prefs.get('structure')
        else:
            structure = prefs

        self.splitter._resized = True
        self.splitter.restoreState(structure)

    def save_prefs(self):
        """ Returns any user preference information associated with the editor.
        """
        return { 'structure': str(self.splitter.saveState()) }


class TabbedFoldGroupEditor(GroupEditor):
    """ A pseudo-editor that allows a group with a 'tabbed' or 'fold' layout to
        be managed.
    """

    # The QTabWidget or QToolBox for the group
    container = Any

    #-- UI preference save/restore interface -----------------------------------

    def restore_prefs(self, prefs):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if isinstance(prefs, dict):
            current_index = prefs.get('current_index')
        else:
            current_index = prefs

        self.container.setCurrentIndex(int(current_index))

    def save_prefs(self):
        """ Returns any user preference information associated with the editor.
        """
        return { 'current_index': str(self.container.currentIndex()) }


#-------------------------------------------------------------------------------
#  'HTMLHelpWindow' class:
#-------------------------------------------------------------------------------

class HTMLHelpWindow ( QtGui.QDialog ):
    """ Window for displaying Traits-based help text with HTML formatting.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, parent, html, scale_dx, scale_dy ):
        """ Initializes the object.
        """
        # Local import to avoid a WebKit dependency when one isn't needed.
        from pyface.qt import QtWebKit

        QtGui.QDialog.__init__(self, parent)
        layout = QtGui.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Create the html control
        html_control = QtWebKit.QWebView()
        html_control.setSizePolicy(QtGui.QSizePolicy.Expanding,
                                   QtGui.QSizePolicy.Expanding)
        html_control.setHtml(html)
        layout.addWidget(html_control)

        # Create the OK button
        bbox = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok,
                                      QtCore.Qt.Horizontal)
        QtCore.QObject.connect(bbox, QtCore.SIGNAL('accepted()'),
                               self, QtCore.SLOT('accept()'))
        layout.addWidget(bbox)

        # Position and show the dialog
        position_window(self, parent=parent)
        self.show()

#-------------------------------------------------------------------------------
#  Creates a PyFace HeadingText control:
#-------------------------------------------------------------------------------

HeadingText = None

def heading_text(*args, **kw):
    """Create a PyFace HeadingText control.
    """
    global HeadingText

    if HeadingText is None:
        from pyface.api import HeadingText

    return HeadingText(*args, **kw)

########NEW FILE########
__FILENAME__ = value_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/05/2006
#
#------------------------------------------------------------------------------

""" Defines the tree-based Python value editor and the value editor factory,
    for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.value_editor file.
from traitsui.editors.value_editor \
    import _ValueEditor, ToolkitEditorFactory

from editor import Editor

class SimpleEditor( _ValueEditor, Editor):
    """ Returns the editor to use for simple style views.
    """

    # Override the value of the readonly trait.
    readonly = False

class ReadonlyEditor( _ValueEditor, Editor):
    """ Returns the editor to use for readonly style views.
    """

    # Override the value of the readonly trait.
    readonly = True

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = view_application
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD license.
# However, when used with the GPL version of PyQt the additional terms described in the PyQt GPL exception also apply

#
# Author: Riverbank Computing Limited
#------------------------------------------------------------------------------

""" Creates a PyQt specific modal dialog user interface that runs as a
complete application, using information from the specified UI object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# Standard library imports.
import os

# System library imports.
from pyface.qt import QtGui

# ETS imports.
from pyface.util.guisupport import is_event_loop_running_qt4, \
    start_event_loop_qt4


KEEP_ALIVE_UIS = set()


def on_ui_destroyed(object, name, old, destroyed):
    """ Remove the UI object from KEEP_ALIVE_UIS.
    """
    assert name == 'destroyed'
    if destroyed:
        assert object in KEEP_ALIVE_UIS
        KEEP_ALIVE_UIS.remove(object)
        object.on_trait_change(on_ui_destroyed, 'destroyed', remove=True)


#-------------------------------------------------------------------------------
#  Creates a 'stand-alone' PyQt application to display a specified traits UI
#  View:
#-------------------------------------------------------------------------------

def view_application ( context, view, kind, handler, id, scrollable, args ):
    """ Creates a stand-alone PyQt application to display a specified traits UI
        View.

    Parameters
    ----------
    context : object or dictionary
        A single object or a dictionary of string/object pairs, whose trait
        attributes are to be edited. If not specified, the current object is
        used.
    view : view object
        A View object that defines a user interface for editing trait attribute
        values.
    kind : string
        The type of user interface window to create. See the
        **traitsui.view.kind_trait** trait for values and
        their meanings. If *kind* is unspecified or None, the **kind**
        attribute of the View object is used.
    handler : Handler object
        A handler object used for event handling in the dialog box. If
        None, the default handler for Traits UI is used.
    scrollable : Boolean
        Indicates whether the dialog box should be scrollable. When set to
        True, scroll bars appear on the dialog box if it is not large enough
        to display all of the items in the view at one time.


    """
    if (kind == 'panel') or ((kind is None) and (view.kind == 'panel')):
        kind = 'modal'

    app = QtGui.QApplication.instance()
    if app is None or not is_event_loop_running_qt4(app):
        return ViewApplication( context, view, kind, handler, id,
                                scrollable, args ).ui.result

    ui = view.ui( context,
                  kind       = kind,
                  handler    = handler,
                  id         = id,
                  scrollable = scrollable,
                  args       = args )

    # If the UI has not been closed yet, we need to keep a reference to
    # it until it does close.
    if not ui.destroyed:
        KEEP_ALIVE_UIS.add(ui)
        ui.on_trait_change(on_ui_destroyed, 'destroyed')
    return ui.result

#-------------------------------------------------------------------------------
#  'ViewApplication' class:
#-------------------------------------------------------------------------------

class ViewApplication ( object ):
    """ Modal window that contains a stand-alone application.
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, context, view, kind, handler, id, scrollable, args ):
        """ Initializes the object.
        """
        self.context    = context
        self.view       = view
        self.kind       = kind
        self.handler    = handler
        self.id         = id
        self.scrollable = scrollable
        self.args       = args

        # FIXME: fbi is wx specific at the moment.
        if os.environ.get( 'ENABLE_FBI' ) is not None:
            try:
                from etsdevtools.developer.helper.fbi import enable_fbi
                enable_fbi()
            except:
                pass

        self.ui = self.view.ui( self.context,
                                kind       = self.kind,
                                handler    = self.handler,
                                id         = self.id,
                                scrollable = self.scrollable,
                                args       = self.args )

        start_event_loop_qt4()

########NEW FILE########
__FILENAME__ = table_column
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/01/2005
#
#------------------------------------------------------------------------------

""" Defines the table column descriptor used by the editor and editor factory
    classes for numeric and table editors.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Bool, Callable, Color, Constant, Either, Enum,
    Expression, Float, Font, HasPrivateTraits, Instance, Int, Property, Str)

from traits.trait_base import user_name_for, xgetattr

from .editor_factory import EditorFactory
from .menu import Menu
from .ui_traits import Image, AView, EditorStyle
from .view import View

# Set up a logger:
import logging
logger = logging.getLogger( __name__ )

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Flag used to indicate user has not specified a column label
UndefinedLabel = '???'

#-------------------------------------------------------------------------------
#  'TableColumn' class:
#-------------------------------------------------------------------------------

class TableColumn ( HasPrivateTraits ):
    """ Represents a column in a table editor.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Column label to use for this column:
    label = Str( UndefinedLabel )

    # Type of data contained by the column:
    type = Enum( 'text' )

    # Text color for this column:
    text_color = Color( 'black' )

    # Text font for this column:
    text_font = Font

    # Cell background color for this column:
    cell_color = Either(Color( 'white' ), None)

    # Cell background color for non-editable columns:
    read_only_cell_color = Either(Color( 0xF4F3EE ), None)

    # Cell graph color:
    graph_color = Color( 0xDDD9CC )

    # Horizontal alignment of text in the column:
    horizontal_alignment = Enum( 'left', [ 'left', 'center', 'right' ] )

    # Vertical alignment of text in the column:
    vertical_alignment = Enum( 'center', [ 'top', 'center', 'bottom' ] )

    # Horizontal cell margin
    horizontal_margin = Int(4)

    # Vertical cell margin
    vertical_margin = Int(3)

    # The image to display in the cell:
    image = Image

    # Renderer used to render the contents of this column:
    renderer = Any # A toolkit specific renderer

    # Is the table column visible (i.e., viewable)?
    visible = Bool( True )

    # Is this column editable?
    editable = Bool( True )

    # Is the column automatically edited/viewed (i.e. should the column editor
    # or popup be activated automatically on mouse over)?
    auto_editable = Bool( False )

    # Should a checkbox be displayed instead of True/False?
    show_checkbox = Bool( True )

    # Can external objects be dropped on the column?
    droppable = Bool( False )

    # Context menu to display when this column is right-clicked:
    menu = Instance( Menu )

    # The tooltip to display when the mouse is over the column:
    tooltip = Str

    # The width of the column (< 0.0: Default, 0.0..1.0: fraction of total table
    # width, > 1.0: absolute width in pixels):
    width = Float( -1.0 )

    # The width of the column while it is being edited (< 0.0: Default,
    # 0.0..1.0: fraction of total table width, > 1.0: absolute width in pixels):
    edit_width = Float( -1.0 )

    # The height of the column cell's row while it is being edited
    # (< 0.0: Default, 0.0..1.0: fraction of total table height,
    # > 1.0: absolute height in pixels):
    edit_height = Float( -1.0 )

    # The resize mode for this column.  This takes precedence over other settings
    # (like **width**, above).
    #   "interactive": column can be resized by users or programmatically
    #   "fixed": users cannot resize the column, but it can be set programmatically
    #   "stretch": the column will be resized to fill the available space
    #   "resize_to_contents": column will be sized to fit the contents, but then cannot be resized
    resize_mode = Enum("interactive", "fixed", "stretch", "resize_to_contents")

    # The view (if any) to display when clicking a non-editable cell:
    view = AView

    # Optional maximum value a numeric cell value can have:
    maximum = Float( trait_value = True )

    #---------------------------------------------------------------------------
    #  Returns the actual object being edited:
    #---------------------------------------------------------------------------

    def get_object ( self, object ):
        """ Returns the actual object being edited.
        """
        return object

    #---------------------------------------------------------------------------
    #  Gets the label of the column:
    #---------------------------------------------------------------------------

    def get_label ( self ):
        """ Gets the label of the column.
        """
        return self.label

    #---------------------------------------------------------------------------
    #  Returns the width of the column:
    #---------------------------------------------------------------------------

    def get_width ( self ):
        """ Returns the width of the column.
        """
        return self.width

    #---------------------------------------------------------------------------
    #  Returns the edit width of the column:
    #---------------------------------------------------------------------------

    def get_edit_width ( self, object ):
        """ Returns the edit width of the column.
        """
        return self.edit_width

    #---------------------------------------------------------------------------
    #  Returns the height of the column cell's row while it is being edited:
    #---------------------------------------------------------------------------

    def get_edit_height ( self, object ):
        """ Returns the height of the column cell's row while it is being
            edited.
        """
        return self.edit_height

    #---------------------------------------------------------------------------
    #  Gets the type of data for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_type ( self, object ):
        """ Gets the type of data for the column for a specified object.
        """
        return self.type

    #---------------------------------------------------------------------------
    #  Returns the text color for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_text_color ( self, object ):
        """ Returns the text color for the column for a specified object.
        """
        return self.text_color_

    #---------------------------------------------------------------------------
    #  Returns the text font for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_text_font ( self, object ):
        """ Returns the text font for the column for a specified object.
        """
        return self.text_font

    #---------------------------------------------------------------------------
    #  Returns the cell background color for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_cell_color ( self, object ):
        """ Returns the cell background color for the column for a specified
            object.
        """
        if self.is_editable( object ):
            return self.cell_color_
        return self.read_only_cell_color_

    #---------------------------------------------------------------------------
    #  Returns the cell background graph color for the column for a specified
    #  object:
    #---------------------------------------------------------------------------

    def get_graph_color ( self, object ):
        """ Returns the cell background graph color for the column for a
            specified object.
        """
        return self.graph_color_

    #---------------------------------------------------------------------------
    #  Returns the horizontal alignment for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_horizontal_alignment ( self, object ):
        """ Returns the horizontal alignment for the column for a specified
            object.
        """
        return self.horizontal_alignment

    #---------------------------------------------------------------------------
    #  Returns the vertical alignment for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_vertical_alignment ( self, object ):
        """ Returns the vertical alignment for the column for a specified
            object.
        """
        return self.vertical_alignment

    #---------------------------------------------------------------------------
    #  Returns the image to display for the column for a specified object:
    #---------------------------------------------------------------------------

    def get_image ( self, object ):
        """ Returns the image to display for the column for a specified object.
        """
        return self.image

    #---------------------------------------------------------------------------
    #  Returns the renderer for the column of a specified object:
    #---------------------------------------------------------------------------

    def get_renderer ( self, object ):
        """ Returns the renderer for the column of a specified object.
        """
        return self.renderer

    #---------------------------------------------------------------------------
    #  Returns whether the column is editable for a specified object:
    #---------------------------------------------------------------------------

    def is_editable ( self, object ):
        """ Returns whether the column is editable for a specified object.
        """
        return self.editable

    #---------------------------------------------------------------------------
    #  Returns whether the column is autoamtically edited/viewed for a specified
    #  object:
    #---------------------------------------------------------------------------

    def is_auto_editable ( self, object ):
        """ Returns whether the column is automatically edited/viewed for a
            specified object.
        """
        return self.auto_editable

    #---------------------------------------------------------------------------
    #  Returns whether a specified value is valid for dropping on the column
    #  for a specified object:
    #---------------------------------------------------------------------------

    def is_droppable ( self, object, value ):
        """ Returns whether a specified value is valid for dropping on the
            column for a specified object.
        """
        return self.droppable

    #---------------------------------------------------------------------------
    #  Returns the context menu to display when the user right-clicks on the
    #  column for a specified object:
    #---------------------------------------------------------------------------

    def get_menu ( self, object ):
        """ Returns the context menu to display when the user right-clicks on
            the column for a specified object.
        """
        return self.menu

    #---------------------------------------------------------------------------
    #  Returns the tooltip to display when the user mouses over the column for
    #  a specified object:
    #---------------------------------------------------------------------------

    def get_tooltip ( self, object ):
        """ Returns the tooltip to display when the user mouses over the column
            for a specified object.
        """
        return self.tooltip

    #---------------------------------------------------------------------------
    #  Returns the view to display when clicking a non-editable cell:
    #---------------------------------------------------------------------------

    def get_view ( self, object ):
        """ Returns the view to display when clicking a non-editable cell.
        """
        return self.view

    #---------------------------------------------------------------------------
    #  Returns the maximum value a numeric column can have:
    #---------------------------------------------------------------------------

    def get_maximum ( self, object ):
        """ Returns the maximum value a numeric column can have.
        """
        return self.maximum

    #---------------------------------------------------------------------------
    #  Called when the user clicks on the column:
    #---------------------------------------------------------------------------

    def on_click ( self, object ):
        """ Called when the user clicks on the column.
        """
        pass

    #---------------------------------------------------------------------------
    #  Called when the user double-clicks on the column:
    #---------------------------------------------------------------------------

    def on_dclick ( self, object ):
        """ Called when the user clicks on the column.
        """
        pass

    #---------------------------------------------------------------------------
    #  Returns the string representation of the table column:
    #---------------------------------------------------------------------------

    def __str__ ( self ):
        """ Returns the string representation of the table column.
        """
        return self.get_label()

#-------------------------------------------------------------------------------
#  'ObjectColumn' class:
#-------------------------------------------------------------------------------

class ObjectColumn ( TableColumn ):
    """ A column for editing objects.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Name of the object trait associated with this column:
    name = Str

    # Column label to use for this column:
    label = Property

    # Trait editor used to edit the contents of this column:
    editor = Instance( EditorFactory )

    # The editor style to use to edit the contents of this column:
    style = EditorStyle

    # Format string to apply to column values:
    format = Str( '%s' )

    # Format function to apply to column values:
    format_func = Callable

    #---------------------------------------------------------------------------
    #  Trait view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ 'name', 'label', 'type',
                            '|[Column Information]' ],
                          [ 'horizontal_alignment{Horizontal}@',
                            'vertical_alignment{Vertical}@',
                            '|[Alignment]' ],
                          [ 'editable', '9', 'droppable', '9', 'visible',
                            '-[Options]>' ],
                          '|{Column}' ],
                        [ [ 'text_color@', 'cell_color@',
                            'read_only_cell_color@',
                            '|[UI Colors]' ],
                          '|{Colors}' ],
                        [ [ 'text_font@',
                            '|[Font]<>' ],
                          '|{Font}' ],
                        [ 'menu@',
                          '|{Menu}' ],
                        [ 'editor@',
                          '|{Editor}' ] )

    #---------------------------------------------------------------------------
    #  Implementation of the 'label' property:
    #---------------------------------------------------------------------------

    def _get_label ( self ):
        """ Gets the label of the column.
        """
        if self._label is not None:
            return self._label
        return user_name_for( self.name )

    def _set_label ( self, label ):
        old, self._label = self._label, label
        if old != label:
            self.trait_property_changed( 'label', old, label )

    #---------------------------------------------------------------------------
    #  Gets the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_raw_value ( self, object ):
        """ Gets the unformatted value of the column for a specified object.
        """
        try:
            return xgetattr( self.get_object( object ), self.name )
        except:
            return None

    def get_value ( self, object ):
        """ Gets the formatted value of the column for a specified object.
        """
        try:
            if self.format_func is not None:
                return self.format_func( self.get_raw_value( object ) )

            return self.format % ( self.get_raw_value( object ), )
        except:
            logger.exception( 'Error occurred trying to format a %s value' %
                              self.__class__.__name__ )
            return 'Format!'

    #---------------------------------------------------------------------------
    #  Returns the drag value for the column:
    #---------------------------------------------------------------------------

    def get_drag_value ( self, object ):
        """Returns the drag value for the column.
        """
        return self.get_raw_value( object )

    #---------------------------------------------------------------------------
    #  Sets the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def set_value ( self, object, value ):
        """ Sets the value of the column for a specified object.
        """
        target, name = self.target_name( object )
        setattr( target, name, value )

    #---------------------------------------------------------------------------
    #  Gets the editor for the column of a specified object:
    #---------------------------------------------------------------------------

    def get_editor ( self, object ):
        """ Gets the editor for the column of a specified object.
        """
        if self.editor is not None:
            return self.editor

        target, name = self.target_name( object )

        return target.base_trait( name ).get_editor()

    #---------------------------------------------------------------------------
    #  Gets the editor style for the column of a specified object:
    #---------------------------------------------------------------------------

    def get_style ( self, object ):
        """ Gets the editor style for the column of a specified object.
        """
        return self.style

    #---------------------------------------------------------------------------
    #  Returns the result of comparing the column of two different objects:
    #---------------------------------------------------------------------------

    def cmp ( self, object1, object2 ):
        """ Returns the result of comparing the column of two different objects.
        """
        return cmp( self.get_raw_value( object1 ),
                    self.get_raw_value( object2 ) )

    #---------------------------------------------------------------------------
    #  Returns whether a specified value is valid for dropping on the column
    #  for a specified object:
    #---------------------------------------------------------------------------

    def is_droppable ( self, object, value ):
        """ Returns whether a specified value is valid for dropping on the
            column for a specified object.
        """
        if self.droppable:
            try:
                target, name = self.target_name( object )
                target.base_trait( name ).validate( target, name, value )
                return True
            except:
                pass

        return False

    #---------------------------------------------------------------------------
    #  Returns the target object and name for the column:
    #---------------------------------------------------------------------------

    def target_name ( self, object ):
        """ Returns the target object and name for the column.
        """
        object = self.get_object( object )
        name   = self.name
        col    = name.rfind( '.' )
        if col < 0:
            return ( object, name )

        return ( xgetattr( object, name[ :col ] ), name[ col + 1: ] )

#-------------------------------------------------------------------------------
#  'ExpressionColumn' class:
#-------------------------------------------------------------------------------

class ExpressionColumn ( ObjectColumn ):
    """ A column for displaying computed values.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The Python expression used to return the value of the column:
    expression = Expression

    # Is this column editable?
    editable = Constant( False )

    # The globals dictionary that should be passed to the expression evaluation:
    globals = Any( {} )

    #---------------------------------------------------------------------------
    #  Gets the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_raw_value ( self, object ):
        """ Gets the unformatted value of the column for a specified object.
        """
        try:
            return eval( self.expression_, self.globals, { 'object': object } )
        except:
            logger.exception( 'Error evaluating table column expression: %s' %
                              self.expression )
            return None

#-------------------------------------------------------------------------------
#  'NumericColumn' class:
#-------------------------------------------------------------------------------

class NumericColumn ( ObjectColumn ):
    """ A column for editing Numeric arrays.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Column label to use for this column
    label = Property

    # Text color this column when selected
    selected_text_color = Color( 'black' )

    # Text font for this column when selected
    selected_text_font = Font

    # Cell background color for this column when selected
    selected_cell_color = Color( 0xD8FFD8 )

    # Formatting string for the cell value
    format = Str( '%s' )

    # Horizontal alignment of text in the column; this value overrides the
    # default.
    horizontal_alignment = 'center'

    #---------------------------------------------------------------------------
    #  Implementation of the 'label' property:
    #---------------------------------------------------------------------------

    def _get_label ( self ):
        """ Gets the label of the column.
        """
        if self._label is not None:
            return self._label
        return self.name

    def _set_label ( self, label ):
        old, self._label = self._label, label
        if old != label:
            self.trait_property_changed( 'label', old, label )

    #---------------------------------------------------------------------------
    #  Gets the type of data for the column for a specified object row:
    #---------------------------------------------------------------------------

    def get_type ( self, object ):
        """ Gets the type of data for the column for a specified object row.
        """
        return self.type

    #---------------------------------------------------------------------------
    #  Returns the text color for the column for a specified object row:
    #---------------------------------------------------------------------------

    def get_text_color ( self, object ):
        """ Returns the text color for the column for a specified object row.
        """
        if self._is_selected( object ):
            return self.selected_text_color_
        return self.text_color_

    #---------------------------------------------------------------------------
    #  Returns the text font for the column for a specified object row:
    #---------------------------------------------------------------------------

    def get_text_font ( self, object ):
        """ Returns the text font for the column for a specified object row.
        """
        if self._is_selected( object ):
            return self.selected_text_font
        return self.text_font

    #---------------------------------------------------------------------------
    #  Returns the cell background color for the column for a specified object
    #  row:
    #---------------------------------------------------------------------------

    def get_cell_color ( self, object ):
        """ Returns the cell background color for the column for a specified
            object row.
        """
        if self.is_editable( object ):
            if self._is_selected( object ):
                return self.selected_cell_color_
            return self.cell_color_
        return self.read_only_cell_color_

    #---------------------------------------------------------------------------
    #  Returns the horizontal alignment for the column for a specified object
    #  row:
    #---------------------------------------------------------------------------

    def get_horizontal_alignment ( self, object ):
        """ Returns the horizontal alignment for the column for a specified
            object row.
        """
        return self.horizontal_alignment

    #---------------------------------------------------------------------------
    #  Returns the vertical alignment for the column for a specified object row:
    #---------------------------------------------------------------------------

    def get_vertical_alignment ( self, object ):
        """ Returns the vertical alignment for the column for a specified
            object row.
        """
        return self.vertical_alignment

    #---------------------------------------------------------------------------
    #  Returns whether the column is editable for a specified object row:
    #---------------------------------------------------------------------------

    def is_editable ( self, object ):
        """ Returns whether the column is editable for a specified object row.
        """
        return self.editable

    #---------------------------------------------------------------------------
    #  Returns whether a specified value is valid for dropping on the column
    #  for a specified object row:
    #---------------------------------------------------------------------------

    def is_droppable ( self, object, row, value ):
        """ Returns whether a specified value is valid for dropping on the
            column for a specified object row.
        """
        return self.droppable

    #---------------------------------------------------------------------------
    #  Returns the context menu to display when the user right-clicks on the
    #  column for a specified object row:
    #---------------------------------------------------------------------------

    def get_menu ( self, object, row ):
        """ Returns the context menu to display when the user right-clicks on
            the column for a specified object row.
        """
        return self.menu

    #---------------------------------------------------------------------------
    #  Gets the value of the column for a specified object row:
    #---------------------------------------------------------------------------

    def get_value ( self, object ):
        """ Gets the value of the column for a specified object row.
        """
        try:
            value = getattr( object, self.name )
            try:
                return self.format % ( value, )
            except:
                return 'Format!'
        except:
            return 'Undefined!'

    #---------------------------------------------------------------------------
    #  Sets the value of the column for a specified object row:
    #---------------------------------------------------------------------------

    def set_value ( self, object, row, value ):
        """ Sets the value of the column for a specified object row.
        """
        column = self.get_data_column( object )
        column[ row ] = type( column[ row ] )( value )

    #---------------------------------------------------------------------------
    #  Gets the editor for the column of a specified object row:
    #---------------------------------------------------------------------------

    def get_editor ( self, object ):
        """ Gets the editor for the column of a specified object row.
        """
        return super( NumericColumn, self ).get_editor( object )

    #---------------------------------------------------------------------------
    #  Gets the entire contents of the specified object column:
    #---------------------------------------------------------------------------

    def get_data_column ( self, object ):
        """ Gets the entire contents of the specified object column.
        """
        return getattr( object, self.name )

    #---------------------------------------------------------------------------
    #  Returns whether a specified object row is selected or not:
    #---------------------------------------------------------------------------

    def _is_selected ( self, object ):
        """ Returns whether a specified object row is selected.
        """
        if hasattr(object, 'model_selection') \
                and object.model_selection is not None:
            return True
        return False

#-------------------------------------------------------------------------------
#  'ListColumn' class:
#-------------------------------------------------------------------------------

class ListColumn ( TableColumn ):
    """ A column for editing lists.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    #Label to use for this column
    label = Property

    # Index of the list element associated with this column
    index = Int

    # Is this column editable? This value overrides the base class default.
    editable = False

    #---------------------------------------------------------------------------
    #  Trait view definitions:
    #---------------------------------------------------------------------------

    traits_view = View( [ [ 'index', 'label', 'type', '|[Column Information]' ],
                          [ 'text_color@', 'cell_color@', '|[UI Colors]' ] ] )

    #---------------------------------------------------------------------------
    #  Implementation of the 'label' property:
    #---------------------------------------------------------------------------

    def _get_label ( self ):
        """ Gets the label of the column.
        """
        if self._label is not None:
            return self._label
        return 'Column %d' % (self.index + 1)

    def _set_label ( self, label ):
        old, self._label = self._label, label
        if old != label:
            self.trait_property_changed( 'label', old, label )

    #---------------------------------------------------------------------------
    #  Gets the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_value ( self, object ):
        """ Gets the value of the column for a specified object.
        """
        return unicode( object[ self.index ] )

    #---------------------------------------------------------------------------
    #  Sets the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def set_value ( self, object, value ):
        """ Sets the value of the column for a specified object.
        """
        object[ self.index ] = value

    #---------------------------------------------------------------------------
    #  Gets the editor for the column of a specified object:
    #---------------------------------------------------------------------------

    def get_editor ( self, object ):
        """ Gets the editor for the column of a specified object.
        """
        return None

    #---------------------------------------------------------------------------
    #  Returns the result of comparing the column of two different objects:
    #---------------------------------------------------------------------------

    def cmp ( self, object1, object2 ):
        """ Returns the result of comparing the column of two different objects.
        """
        return cmp( object1[ self.index ], object2[ self.index ] )


########NEW FILE########
__FILENAME__ = table_filter
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/01/2005
#
#------------------------------------------------------------------------------

""" Defines the filter object used to filter items displayed in a table editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Bool, Callable, Enum, Event, Expression, HasPrivateTraits,
    Instance, List, Str, Trait)

from .editor_factory import EditorFactory
from .editors.api import EnumEditor
from .group import Group
from .include import Include
from .item import Item
from .menu import Action
from .table_column import ObjectColumn
from .view import View

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

GenericTableFilterRuleOperation = Trait( '=', {
    '=':           'eq',
    '<>':          'ne',
    '<':           'lt',
    '<=':          'le',
    '>':           'gt',
    '>=':          'ge',
    'contains':    'contains',
    'starts with': 'starts_with',
    'ends with':   'ends_with'
} )

#-------------------------------------------------------------------------------
#  'TableFilter' class:
#-------------------------------------------------------------------------------

class TableFilter ( HasPrivateTraits ):
    """ Filter for items displayed in a table.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # UI name of this filter (so the user can identify it in the UI)
    name = Str( 'Default filter' )

    # Default name that can be automatically overridden
    _name = Str( 'Default filter' )

    # A user-readable description of what kind of object satisfies the filter
    desc = Str( 'All items' )

    # A callable function that returns whether the passed object is allowed
    # by the filter
    allowed = Callable( lambda object: True, transient = True )

    # Is the filter a template (i.e., non-deletable, non-editable)?
    template = Bool( False )

    #---------------------------------------------------------------------------
    #  Class constants:
    #---------------------------------------------------------------------------

    # Traits that are ignored by the _anytrait_changed() handler
    ignored_traits = [ '_name', 'template', 'desc' ]

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    traits_view = View(
        'name{Filter name}', '_',
        Include( 'filter_view' ),
        title   = 'Edit Filter',
        width   = 0.2,
        buttons = [ 'OK',
                    'Cancel',
                    Action(
                        name         = 'Help',
                        action       = 'show_help',
                        defined_when = "ui.view_elements.content['filter_view']"
                                       ".help_id != ''"
                    )
                  ]
    )

    searchable_view = View( [
        [ Include( 'search_view' ), '|[]' ],
        [ 'handler.status~', '|[]<>' ],
        [ 'handler.find_next`Find the next matching item`',
          'handler.find_previous`Find the previous matching item`',
          'handler.select`Select all matching items`',
          'handler.OK`Exit search`', '-<>'   ],
        '|<>' ],
        title = 'Search for',
        kind  = 'livemodal',
        width = 0.25 )

    search_view = Group( Include( 'filter_view' ) )

    filter_view = Group()

    #---------------------------------------------------------------------------
    #  Returns whether a specified object meets the filter/search criteria:
    #  (Should normally be overridden)
    #---------------------------------------------------------------------------

    def filter ( self, object ):
        """ Returns whether a specified object meets the filter or search
        criteria.
        """
        return self.allowed( object )

    #---------------------------------------------------------------------------
    #  Returns a user readable description of what kind of object will
    #  satisfy the filter:
    #  (Should normally be overridden):
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a user-readable description of what kind of object
        satisfies the filter.
        """
        return self.desc

    #---------------------------------------------------------------------------
    #  Edits the contents of the filter:
    #---------------------------------------------------------------------------

    def edit ( self, object ):
        """ Edits the contents of the filter.
        """
        return self.edit_traits( view = self.edit_view( object ),
                                 kind = 'livemodal' )

    def edit_view ( self, object ):
        """ Return a view to use for editing the filter.

        The ''object'' parameter is a sample object for the table that the
        filter will be applied to. It is supplied in case the filter needs to
        extract data or metadata from the object. If the table is empty, the
        ''object'' argument is None.
        """
        return None

    #---------------------------------------------------------------------------
    #  'object' interface:
    #---------------------------------------------------------------------------

    def __str__ ( self ):
        return self.name

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def _anytrait_changed ( self, name, old, new ):
        if ((name not in self.ignored_traits) and
            ((self.name == self._name) or (self.name == ''))):
            self.name = self._name = self.description()

#-------------------------------------------------------------------------------
#  'EvalTableFilter' class:
#-------------------------------------------------------------------------------

class EvalTableFilter ( TableFilter ):
    """ A table filter based on evaluating an expression.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Override the standard **name** trait
    name = 'Default evaluation filter'

    # Python expression which will be applied to each table item
    expression = Expression

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    filter_view = Group( 'expression' )

    #---------------------------------------------------------------------------
    #  Returns whether a specified object meets the filter/search criteria:
    #  (Should normally be overridden)
    #---------------------------------------------------------------------------

    def filter ( self, object ):
        """ Returns whether a specified object meets the filter or search
        criteria.
        """
        if self._traits is None:
            self._traits = object.trait_names()
        try:
            return eval( self.expression_, globals(),
                         object.get( *self._traits ) )
        except:
            return False

    #---------------------------------------------------------------------------
    #  Returns a user readable description of what kind of object will
    #  satisfy the filter:
    #  (Should normally be overridden):
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a user readable description of what kind of object
            satisfies the filter.
        """
        return self.expression

#-------------------------------------------------------------------------------
#  'GenericTableFilterRule' class:
#-------------------------------------------------------------------------------

class GenericTableFilterRule ( HasPrivateTraits ):
    """ A general rule used by a table filter.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Filter this rule is part of
    filter = Instance( 'RuleTableFilter' )

    # Is this rule enabled?
    enabled = Bool( False )

    # Is this rule an 'and' rule or an 'or' rule?
    and_or = Enum( 'and', 'or' )

    # EnumEditor used to edit the **name** trait:
    name_editor = Instance( EditorFactory )

    # Name of the object trait that this rule applies to
    name = Str

    # Operation to be applied in the rule
    operation = GenericTableFilterRuleOperation

    # Editor used to edit the **value** trait
    value_editor = Instance( EditorFactory )

    # Value to use in the operation when applying the rule to an object
    value = Any

    #---------------------------------------------------------------------------
    #  Class constants:
    #---------------------------------------------------------------------------

    # Traits that are ignored by the _anytrait_changed() handler
    ignored_traits = [ 'filter', 'name_editor', 'value_editor' ]

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        super( GenericTableFilterRule, self ).__init__( **traits )
        if self.name == '':
            names = self.filter._trait_values.keys()
            if len( names ) > 0:
                names.sort()
                self.name    = names[0]
                self.enabled = False

    #---------------------------------------------------------------------------
    #  Handles the value of the 'name' trait changing:
    #---------------------------------------------------------------------------

    def _name_changed ( self, name ):
        """ Handles a change to the value of the **name** trait.
        """
        filter = self.filter
        if (filter is not None) and (filter._object is not None):
            self.value        = filter._trait_values.get( name )
            self.value_editor = filter._object.base_trait( name ).get_editor()

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def _anytrait_changed ( self, name, old, new ):
        if (name not in self.ignored_traits) and (self.filter is not None):
            self.filter.modified = True
            if name != 'enabled':
                self.enabled = True

    #---------------------------------------------------------------------------
    #  Clones a new object from this one, optionally copying only a specified
    #  set of traits:
    #---------------------------------------------------------------------------

    def clone_traits ( self, traits = None, memo = None, copy = None,
                             **metadata ):
        """ Clones a new object from this one, optionally copying only a
        specified set of traits."""
        return super( GenericTableFilterRule, self ).clone_traits( traits,
                       memo, copy, **metadata ).set(
                       enabled = self.enabled,
                       name    = self.name )

    #---------------------------------------------------------------------------
    #  Returns a description of the filter:
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a description of the filter.
        """
        return '%s %s %s' % ( self.name, self.operation, self.value )

    #---------------------------------------------------------------------------
    #  Returns whether the rule is true for a specified object:
    #---------------------------------------------------------------------------

    def is_true ( self, object ):
        """ Returns whether the rule is true for a specified object.
        """
        try:
            value1 = getattr( object, self.name )
            type1  = type( value1 )
            value2 = self.value
            if type1 is not type( value2 ):
                value2 = type1( value2 )
            return getattr( self, self.operation_ )( value1, value2 )
        except:
            return False

    #---------------------------------------------------------------------------
    #  Implemenations of the various rule operations:
    #---------------------------------------------------------------------------

    def eq ( self, value1, value2 ):
        return (value1 == value2)

    def ne ( self, value1, value2 ):
        return (value1 != value2)

    def lt ( self, value1, value2 ):
        return (value1 < value2)

    def le ( self, value1, value2 ):
        return (value1 <= value2)

    def gt ( self, value1, value2 ):
        return (value1 > value2)

    def ge ( self, value1, value2 ):
        return (value1 >= value2)

    def contains ( self, value1, value2 ):
        return (value1.lower().find( value2.lower() ) >= 0)

    def starts_with ( self, value1, value2 ):
        return (value1[ : len( value2 ) ].lower() == value2.lower())

    def ends_with ( self, value1, value2 ):
        return (value1[ -len( value2 ): ].lower() == value2.lower())

#-------------------------------------------------------------------------------
#  'GenericTableFilterRuleEnabledColumn' class:
#-------------------------------------------------------------------------------

class GenericTableFilterRuleEnabledColumn ( ObjectColumn ):
    """ Table column that indicates whether a filter rule is enabled.
    """

    #---------------------------------------------------------------------------
    #  Returns the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_value ( self, object ):
        """ Returns the traits editor of the column for a specified object.
        """
        return [ '', '==>' ][ object.enabled ]

#-------------------------------------------------------------------------------
#  'GenericTableFilterRuleAndOrColumn' class:
#-------------------------------------------------------------------------------

class GenericTableFilterRuleAndOrColumn ( ObjectColumn ):
    """ Table column that displays whether a filter rule is conjoining ('and')
        or disjoining ('or').
    """

    #---------------------------------------------------------------------------
    #  Returns the value of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_value ( self, object ):
        """ Returns the traits editor of the column for a specified object.
        """
        if object.and_or == 'or':
            return 'or'
        return ''

#-------------------------------------------------------------------------------
#  'GenericTableFilterRuleNameColumn' class:
#-------------------------------------------------------------------------------

class GenericTableFilterRuleNameColumn ( ObjectColumn ):
    """ Table column for the name of an object trait.
    """

    #---------------------------------------------------------------------------
    #  Returns the traits editor of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_editor ( self, object ):
        """ Returns the traits editor of the column for a specified object.
        """
        return object.name_editor

#-------------------------------------------------------------------------------
#  'GenericTableFilterRuleValueColumn' class:
#-------------------------------------------------------------------------------

class GenericTableFilterRuleValueColumn ( ObjectColumn ):
    """ Table column for the value of an object trait.
    """

    #---------------------------------------------------------------------------
    #  Returns the traits editor of the column for a specified object:
    #---------------------------------------------------------------------------

    def get_editor ( self, object ):
        """ Returns the traits editor of the column for a specified object.
        """
        return object.value_editor

#-------------------------------------------------------------------------------
#  Defines the columns to display in the generic filter rule table:
#-------------------------------------------------------------------------------

# Columns to display in the table for generic filter rules.
generic_table_filter_rule_columns = [
    GenericTableFilterRuleAndOrColumn( name = 'and_or', label = 'or' ),
    GenericTableFilterRuleNameColumn(  name = 'name' ),
    ObjectColumn(                      name = 'operation' ),
    GenericTableFilterRuleValueColumn( name = 'value' )
]

#-------------------------------------------------------------------------------
#  'RuleTableFilter' class:
#-------------------------------------------------------------------------------

class RuleTableFilter ( TableFilter ):
    """ A table filter based on rules.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Overrides the default **name** trait
    name = 'Default rule-based filter'

    # List of the filter rules to be applied
    rules = List( GenericTableFilterRule )

    # Event fired when the contents of the filter have changed
    modified = Event

    # Persistence ID of the view
    view_id = Str( 'traitsui.table_filter.RuleTableFilter' )

    # Sample object that the filter will apply to
    _object = Any

    # Map of trait names and default values
    _trait_values = Any

    #---------------------------------------------------------------------------
    #  Traits view definitions:
    #---------------------------------------------------------------------------

    error_view = View(
        Item( label = 'A menu or rule based filter can only be created for '
                      'tables with at least one entry'
        ),
        title        = 'Error Creating Filter',
        kind         = 'livemodal',
        close_result = False,
        buttons      = [ 'Cancel' ]
    )

    #---------------------------------------------------------------------------
    #  Returns whether a specified object meets the filter/search criteria:
    #  (Should normally be overridden)
    #---------------------------------------------------------------------------

    def filter ( self, object ):
        """ Returns whether a specified object meets the filter or search
        criteria.
        """
        is_first = is_true = True
        for rule in self.rules:
            if rule.and_or == 'or':
                if is_true and (not is_first):
                    return True
                is_true = True
            if is_true:
                is_true = rule.is_true( object )
            is_first = False
        return is_true

    #---------------------------------------------------------------------------
    #  Returns a user readable description of what kind of object will
    #  satisfy the filter:
    #  (Should normally be overridden):
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a user-readable description of the kind of object that
            satisfies the filter.
        """
        ors  = []
        ands = []
        if len( self.rules ) > 0:
            for rule in self.rules:
                if rule.and_or == 'or':
                    if len( ands ) > 0:
                        ors.append( ' and '.join( ands ) )
                        ands = []
                ands.append( rule.description() )

        if len( ands ) > 0:
            ors.append( ' and '.join( ands ) )

        if len( ors ) == 1:
            return ors[0]

        if len( ors ) > 1:
            return ' or '.join( [ '(%s)' % t for t in ors ] )

        return super( RuleTableFilter, self ).description()

    #---------------------------------------------------------------------------
    #  Edits the contents of the filter:
    #---------------------------------------------------------------------------

    def edit_view ( self, object ):
        """ Return a view to use for editing the filter.

        The ''object'' parameter is a sample object for the table that the
        filter will be applied to. It is supplied in case the filter needs to
        extract data or metadata from the object. If the table is empty, the
        ''object'' argument is None.
        """
        self._object = object
        if object is None:
            return self.edit_traits( view = 'error_view' )

        names              = object.editable_traits()
        self._trait_values = object.get( names )
        return View(
            [ [ 'name{Filter name}', '_' ],
              [ Item( 'rules',
                      id     = 'rules_table',
                      editor = self._get_table_editor( names ) ),
                '|<>' ] ],
            id        = self.view_id,
            title     = 'Edit Filter',
            kind      = 'livemodal',
            resizable = True,
            buttons   = [ 'OK', 'Cancel' ],
            width     = 0.4,
            height    = 0.3 )

    #---------------------------------------------------------------------------
    #  Returns a table editor to use for editing the filter:
    #---------------------------------------------------------------------------

    def _get_table_editor ( self, names ):
        """ Returns a table editor to use for editing the filter.
        """
        from .api import TableEditor

        return TableEditor( columns        = generic_table_filter_rule_columns,
                            orientation    = 'vertical',
                            deletable      = True,
                            sortable       = False,
                            configurable   = False,
                            auto_size      = False,
                            auto_add       = True,
                            row_factory    = GenericTableFilterRule,
                            row_factory_kw = {
                                'filter':      self,
                                'name_editor': EnumEditor( values = names ) } )

    #---------------------------------------------------------------------------
    #  Returns the state to be pickled (override of object):
    #---------------------------------------------------------------------------

    def __getstate__ ( self ):
        """ Returns the state to be pickled.

        This definition overrides **object**.
        """
        dict = self.__dict__.copy()
        if '_object' in dict:
            del dict[ '_object' ]
            del dict[ '_trait_values' ]
        return dict

    #---------------------------------------------------------------------------
    #  Handles the 'rules' trait being changed:
    #---------------------------------------------------------------------------

    def _rules_changed ( self, rules ):
        """ Handles a change to the **rules** trait.
        """
        for rule in rules:
            rule.filter = self

#-------------------------------------------------------------------------------
#  Defines the columns to display in the menu filter rule table:
#-------------------------------------------------------------------------------

# Columns to display in the table for menu filters.
menu_table_filter_rule_columns = [
    GenericTableFilterRuleEnabledColumn( name = 'enabled', label = '' ),
    GenericTableFilterRuleNameColumn(    name = 'name' ),
    ObjectColumn(                        name = 'operation' ),
    GenericTableFilterRuleValueColumn(   name = 'value' )
]

#-------------------------------------------------------------------------------
#  'MenuTableFilter' class:
#-------------------------------------------------------------------------------

class MenuTableFilter ( RuleTableFilter ):
    """ A table filter based on a menu of rules.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Overrides the default **name** trait
    name = 'Default menu-based filter'

    # Overrides the persistence ID of the view
    view_id = Str( 'traitsui.table_filter.MenuTableFilter' )

    #---------------------------------------------------------------------------
    #  Returns whether a specified object meets the filter/search criteria:
    #  (Should normally be overridden)
    #---------------------------------------------------------------------------

    def filter ( self, object ):
        """ Returns whether a specified object meets the filter or search
        criteria.
        """
        for rule in self.rules:
            if rule.enabled and (not rule.is_true( object )):
                return False
        return True

    #---------------------------------------------------------------------------
    #  Returns a user readable description of what kind of object will
    #  satisfy the filter:
    #  (Should normally be overridden):
    #---------------------------------------------------------------------------

    def description ( self ):
        """ Returns a user8readable description of what kind of object
            satisfies the filter.
        """
        result = ' and '.join( [ rule.description() for rule in self.rules
                                 if rule.enabled ] )
        if result != '':
            return result
        return 'All items'

    #---------------------------------------------------------------------------
    #  Returns a table editor to use for editing the filter:
    #---------------------------------------------------------------------------

    def _get_table_editor ( self, names ):
        """ Returns a table editor to use for editing the filter.
        """
        from .api import TableEditor

        names       = self._object.editable_traits()
        name_editor = EnumEditor( values = names )
        if len( self.rules ) == 0:
            self.rules  = [ GenericTableFilterRule(
                                filter      = self,
                                name_editor = name_editor ).set(
                                name        = name )
                            for name in names ]
            for rule in self.rules:
                rule.enabled = False

        return TableEditor( columns        = menu_table_filter_rule_columns,
                            orientation    = 'vertical',
                            deletable      = True,
                            sortable       = False,
                            configurable   = False,
                            auto_size      = False,
                            auto_add       = True,
                            row_factory    = GenericTableFilterRule,
                            row_factory_kw = {
                                'filter':      self,
                                'name_editor': name_editor  } )

#-------------------------------------------------------------------------------
#  Define some standard template filters:
#-------------------------------------------------------------------------------

EvalFilterTemplate = EvalTableFilter( name     = 'Evaluation filter template',
                                      template = True )
RuleFilterTemplate = RuleTableFilter( name     = 'Rule-based filter template',
                                      template = True )
MenuFilterTemplate = MenuTableFilter( name     = 'Menu-based filter template',
                                      template = True )


########NEW FILE########
__FILENAME__ = tabular_adapter
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   02/29/2008
#
#-------------------------------------------------------------------------------

""" Defines the adapter classes associated with the Traits UI TabularEditor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Bool, Color, Either, Enum, Event, Float, Font,
    HasPrivateTraits, HasTraits, Instance, Int, Interface, List, Property,
    Str, cached_property, on_trait_change, provides)

#-------------------------------------------------------------------------------
#  'ITabularAdapter' interface:
#-------------------------------------------------------------------------------

class ITabularAdapter ( Interface ):

    # The row index of the current item being adapted:
    row = Int

    # The current column id being adapted (if any):
    column = Any

    # Current item being adapted:
    item = Any

    # The current value (if any):
    value = Any

    # The list of columns the adapter supports. The items in the list have the
    # same format as the *columns* trait in the *TabularAdapter* class, with the
    # additional requirement that the *string* values must correspond to a
    # *string* value in the associated *TabularAdapter* class.
    columns = List( Str )

    # Does the adapter know how to handle the current *item* or not:
    accepts = Bool

    # Does the value of *accepts* depend only upon the type of *item*?
    is_cacheable = Bool

#-------------------------------------------------------------------------------
#  'AnITabularAdapter' class:
#-------------------------------------------------------------------------------

@provides(ITabularAdapter)
class AnITabularAdapter ( HasPrivateTraits ):

    #-- Implementation of the ITabularAdapter Interface ------------------------

    # The row index of the current item being adapted:
    row = Int

    # The current column id being adapted (if any):
    column = Any

    # Current item being adapted:
    item = Any

    # The current value (if any):
    value = Any

    # The list of columns the adapter supports. The items in the list have the
    # same format as the *columns* trait in the *TabularAdapter* class, with the
    # additional requirement that the *string* values must correspond to a
    # *string* value in the associated *TabularAdapter* class.
    columns = List( Str )

    # Does the adapter know how to handle the current *item* or not:
    accepts = Bool( True )

    # Does the value of *accepts* depend only upon the type of *item*?
    is_cacheable = Bool( True )

#-------------------------------------------------------------------------------
#  'TabularAdapter' class:
#-------------------------------------------------------------------------------

class TabularAdapter ( HasPrivateTraits ):
    """ The base class for adapting list items to values that can be edited
        by a TabularEditor.
    """

    #-- Public Trait Definitions -----------------------------------------------

    # A list of columns that should appear in the table. Each entry can have one
    # of two forms: string or ( string, any ), where *string* is the UI name of
    # the column, and *any* is a value that identifies that column to the
    # adapter. Normally this value is either a trait name or an index, but it
    # can be any value that the adapter wants. If only *string* is specified,
    # then *any* is the index of the *string* within *columns*.
    columns = List()

    #Maps UI name of column to value identifying column to the adapter, if different.
    column_dict = Property()

    # Specifies the default value for a new row:
    default_value = Any( '' )

    # The default text color for table rows (even, odd, any rows):
    odd_text_color     = Color( None, update = True )
    even_text_color    = Color( None, update = True )
    default_text_color = Color( None, update = True )

    # The default background color for table rows (even, odd, any rows):
    odd_bg_color     = Color( None, update = True )
    even_bg_color    = Color( None, update = True )
    default_bg_color = Color( None, update = True )

    # Alignment to use for a specified column:
    alignment = Enum( 'left', 'center', 'right' )

    # The Python format string to use for a specified column:
    format = Str( '%s' )

    # Width of a specified column:
    width = Float( -1 )

    # Can the text value of each item be edited:
    can_edit = Bool( True )

    # The value to be dragged for a specified row item:
    drag = Property

    # Can any arbitrary value be dropped onto the tabular view:
    can_drop = Bool( False )

    # Specifies where a dropped item should be placed in the table relative to
    # the item it is dropped on:
    dropped = Enum( 'after', 'before' )

    # The font for a row item:
    font = Font( None )

    # The text color for a row item:
    text_color = Property

    # The background color for a row item:
    bg_color = Property

    # The name of the default image to use for column items:
    image = Str( None, update = True )

    # The text of a row/column item:
    text = Property

    # The content of a row/column item (may be any Python value):
    content = Property

    # The tooltip information for a row/column item:
    tooltip = Str

    # The context menu for a row/column item:
    menu = Any

    # The context menu for column header:
    column_menu = Any

    # List of optional delegated adapters:
    adapters = List( ITabularAdapter, update = True )

    #-- Traits Set by the Editor -----------------------------------------------

    # The object whose trait is being edited:
    object = Instance( HasTraits )

    # The name of the trait being edited:
    name = Str

    # The row index of the current item being adapted:
    row = Int

    # The column index of the current item being adapted:
    column = Int

    # The current column id being adapted (if any):
    column_id = Any

    # Current item being adapted:
    item = Any

    # The current value (if any):
    value = Any

    #-- Private Trait Definitions ----------------------------------------------

    # Cache of attribute handlers:
    cache = Any( {} )

    # Event fired when the cache is flushed:
    cache_flushed = Event( update = True )

    # The mapping from column indices to column identifiers (defined by the
    # *columns* trait):
    column_map = Property( depends_on = 'columns' )

    # The mapping from column indices to column labels (defined by the *columns*
    # trait):
    label_map = Property( depends_on = 'columns' )

    # The name of the trait on a row item containing the value to use
    # as a row label. If None, the label will be the empty string.
    row_label_name = Either(None, Str)

    # For each adapter, specifies the column indices the adapter handles:
    adapter_column_indices = Property( depends_on = 'adapters,columns' )

    # For each adapter, specifies the mapping from column index to column id:
    adapter_column_map = Property( depends_on = 'adapters,columns' )

    #### TabularAdapter interface ####

    def cleanup(self):
        """ Clean up the adapter to remove references to objects.
        """
        self.trait_setq(
            object=None,
            item=None,
            value=None,
        )

    #-- Adapter methods that are sensitive to item type ------------------------

    def get_alignment ( self, object, trait, column ):
        """ Returns the alignment style to use for a specified column.
        """
        return self._result_for( 'get_alignment', object, trait, 0, column )

    def get_width ( self, object, trait, column ):
        """ Returns the width to use for a specified column.
        """
        return self._result_for( 'get_width', object, trait, 0, column )

    def get_can_edit ( self, object, trait, row ):
        """ Returns whether the user can edit a specified
            *object.trait[row]* item. A True result indicates the value
            can be edited, while a False result indicates that it cannot be
            edited.
        """
        return self._result_for( 'get_can_edit', object, trait, row, 0 )

    def get_drag ( self, object, trait, row ):
        """ Returns the 'drag' value for a specified
            *object.trait[row]* item. A result of *None* means that the
            item cannot be dragged.
        """
        return self._result_for( 'get_drag', object, trait, row, 0 )

    def get_can_drop ( self, object, trait, row, value ):
        """ Returns whether the specified *value* can be dropped on the
            specified *object.trait[row]* item. A value of **True** means the
            *value* can be dropped; and a value of **False** indicates that it
            cannot be dropped.
        """
        return self._result_for( 'get_can_drop', object, trait, row, 0, value )

    def get_dropped ( self, object, trait, row, value ):
        """ Returns how to handle a specified *value* being dropped on a
            specified *object.trait[row]* item. The possible return values are:

            'before'
                Insert the specified *value* before the dropped on item.
            'after'
                Insert the specified *value* after the dropped on item.
        """
        return self._result_for( 'get_dropped', object, trait, row, 0, value )

    def get_font ( self, object, trait, row, column = 0):
        """ Returns the font for a specified *object.trait[row]* item. A result
            of None means use the default font.
        """
        return self._result_for( 'get_font', object, trait, row, column )

    def get_text_color ( self, object, trait, row, column = 0):
        """ Returns the text color for a specified *object.trait[row]*
            item. A result of None means use the default text color.
        """
        return self._result_for( 'get_text_color', object, trait, row, column )

    def get_bg_color ( self, object, trait, row, column = 0):
        """ Returns the background color for a specified *object.trait[row]*
            item. A result of None means use the default background color.
        """
        return self._result_for( 'get_bg_color', object, trait, row, column )

    def get_image ( self, object, trait, row, column ):
        """ Returns the name of the image to use for a specified
            *object.trait[row].column* item. A result of None means no image
            should be used. Otherwise, the result should either be the name of
            the image, or an ImageResource item specifying the image to use.
        """
        return self._result_for( 'get_image', object, trait, row, column )

    def get_format ( self, object, trait, row, column ):
        """ Returns the Python format string to use for a specified column.
        """
        return self._result_for( 'get_format', object, trait, row, column )

    def get_text ( self, object, trait, row, column ):
        """ Returns the text to display for a specified
            *object.trait[row].column* item.
        """
        return self._result_for( 'get_text', object, trait, row, column )

    def get_content ( self, object, trait, row, column ):
        """ Returns the content to display for a specified
            *object.trait[row].column* item.
        """
        return self._result_for( 'get_content', object, trait, row, column )

    def set_text ( self, object, trait, row, column, text ):
        """ Sets the text for a specified *object.trait[row].column* item to
            *text*.
        """
        self._result_for( 'set_text', object, trait, row, column, text )

    def get_tooltip ( self, object, trait, row, column ):
        """ Returns the tooltip for a specified row.
        """
        return self._result_for( 'get_tooltip', object, trait, row, column )

    def get_menu ( self, object, trait, row, column ):
        """ Returns the context menu for a specified cell.
        """
        return self._result_for( 'get_menu', object, trait, row, column )

    def get_column_menu ( self, object, trait, row, column ):
        """ Returns the context menu for a specified column.
        """
        return self._result_for( 'get_column_menu', object, trait, row, column )

    #-- Adapter methods that are not sensitive to item type --------------------

    def get_item ( self, object, trait, row ):
        """ Returns the value of the *object.trait[row]* item.
        """
        try:
            return getattr( object, trait )[ row ]
        except:
            return None

    def len ( self, object, trait ):
        """ Returns the number of items in the specified *object.trait* list.
        """
        # Sometimes, during shutdown, the object has been set to None.
        if object is None:
            return 0
        else:
            return len( getattr( object, trait ) )

    def get_default_value ( self, object, trait ):
        """ Returns a new default value for the specified *object.trait* list.
        """
        return self.default_value

    def delete ( self, object, trait, row ):
        """ Deletes the specified *object.trait[row]* item.
        """
        del getattr( object, trait )[ row ]

    def insert ( self, object, trait, row, value ):
        """ Inserts a new value at the specified *object.trait[row]* index.
        """
        getattr( object, trait ) [ row: row ] = [ value ]

    def get_column ( self, object, trait, index ):
        """ Returns the column id corresponding to a specified column index.
        """
        self.object, self.name = object, trait
        return self.column_map[ index ]

    #-- Property Implementations -----------------------------------------------

    def _get_drag ( self ):
        return self.item

    def _get_text_color ( self ):
        if (self.row % 2) == 1:
            return self.even_text_color_ or self.default_text_color

        return self.odd_text_color or self.default_text_color_

    def _get_bg_color ( self ):
        if (self.row % 2) == 1:
            return self.even_bg_color_ or self.default_bg_color_

        return self.odd_bg_color or self.default_bg_color_

    def _get_text ( self ):
        return self.get_format(
            self.object, self.name, self.row, self.column ) % self.get_content(
            self.object, self.name, self.row, self.column )

    def _set_text ( self, value ):
        if isinstance( self.column_id, int ):
            self.item[ self.column_id ] = self.value
        else:
            # Convert value to the correct trait type.
            try:
                trait_handler = self.item.trait(self.column_id).handler
                setattr( self.item, self.column_id,
                                    trait_handler.evaluate(self.value))
            except:
                setattr( self.item, self.column_id, value )

    def _get_content ( self ):
        if isinstance( self.column_id, int ):
            return self.item[ self.column_id ]

        return getattr( self.item, self.column_id )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_column_dict(self):
        cols = {}
        for i, value in enumerate(self.columns):
            if isinstance(value, basestring):
                cols.update({value: value})
            else:
                cols.update({value[0]: value[1]})
        return cols

    @cached_property
    def _get_column_map ( self ):
        map = []
        for i, value in enumerate( self.columns ):
            if isinstance( value, basestring ):
                map.append( i )
            else:
                map.append( value[1] )

        return map

    def get_label(self, section, obj=None):
        """Override this method if labels will vary from object to object."""
        return self.label_map[section]

    def get_row_label(self, section, obj=None):
        if self.row_label_name is None:
            return None
        rows = getattr(obj, self.name, None)
        if rows is None:
            return None
        item = rows[section]
        return getattr(item, self.row_label_name, None)

    @cached_property
    def _get_label_map (self):
        map = []
        for i, value in enumerate( self.columns ):
            if isinstance( value, basestring ):
                map.append( value )
            else:
                map.append( value[0] )

        return map

    @cached_property
    def _get_adapter_column_indices ( self ):
        labels = self.label_map
        map    = []
        for adapter in self.adapters:
            indices = []
            for label in adapter.columns:
                if not isinstance( label, basestring ):
                    label = label[0]

                indices.append( labels.index( label ) )
            map.append(indices)
        return map

    @cached_property
    def _get_adapter_column_map ( self ):
        labels = self.label_map
        map    = []
        for adapter in self.adapters:
            mapping = {}
            for label in adapter.columns:
                id = None
                if not isinstance( label, basestring ):
                    label, id = label

                key = labels.index( label )
                if id is None:
                    id = key

                mapping[ key ] = id

            map.append( mapping )

        return map

    #-- Private Methods --------------------------------------------------------

    def _result_for ( self, name, object, trait, row, column, value = None ):
        """ Returns/Sets the value of the specified *name* attribute for the
            specified *object.trait[row].column* item.
        """
        self.object    = object
        self.name      = trait
        self.row       = row
        self.column    = column
        self.column_id = column_id = self.column_map[ column ]
        self.value     = value
        self.item      = item = self.get_item( object, trait, row )
        item_class     = item.__class__
        key            = '%s:%s:%d' % ( item_class.__name__, name, column )
        handler        = self.cache.get( key )
        if handler is not None:
            return handler()

        prefix     = name[:4]
        trait_name = name[4:]

        for i, adapter in enumerate( self.adapters ):
            if column in self.adapter_column_indices[i]:
                adapter.row    = row
                adapter.item   = item
                adapter.value  = value
                adapter.column = column_id = self.adapter_column_map[i][column]
                if adapter.accepts:
                    get_name = '%s_%s' % ( column_id, trait_name )
                    if adapter.trait( get_name ) is not None:
                        if prefix == 'get_':
                            handler = lambda: getattr( adapter.set(
                                row  = self.row, column = column_id,
                                item = self.item ), get_name )
                        else:
                            handler = lambda: setattr( adapter.set(
                                row  = self.row, column = column_id,
                                item = self.item ), get_name, self.value )

                        if adapter.is_cacheable:
                            break

                        return handler()
        else:
            if item is not None and hasattr(item_class, '__mro__'):
                for klass in item_class.__mro__:
                    handler = (self._get_handler_for( '%s_%s_%s' %
                          ( klass.__name__, column_id, trait_name ), prefix ) or
                        self._get_handler_for( '%s_%s' %
                          ( klass.__name__, trait_name ), prefix ))
                    if handler is not None:
                        break

            if handler is None:
                handler = (self._get_handler_for( '%s_%s' % ( column_id,
                              trait_name ), prefix ) or
                           self._get_handler_for( trait_name, prefix ))

        self.cache[ key ] = handler
        return handler()

    def _get_handler_for ( self, name, prefix ):
        """ Returns the handler for a specified trait name (or None if not
            found).
        """
        if self.trait( name ) is not None:
            if prefix == 'get_':
                return lambda: getattr( self, name )

            return lambda: setattr( self, name, self.value )

        return None

    @on_trait_change( 'columns,adapters.+update' )
    def _flush_cache ( self ):
        """ Flushes the cache when the columns or any trait on any adapter
            changes.
        """
        self.cache = {}
        self.cache_flushed = True


########NEW FILE########
__FILENAME__ = test_code_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#------------------------------------------------------------------------------

from traits.has_traits import HasTraits
from traits.trait_types import Bool, Enum, Instance, Str
from traitsui.handler import ModelView
from traitsui.view import View, Group
from traitsui.item import Item
from traitsui.editors.code_editor import CodeEditor


from traitsui.tests._tools import *


class CodeModel(HasTraits):
    code = Str('world domination code')

class CodeView(ModelView):
    model = Instance(CodeModel)
    show_line_numbers = Bool(True)
    style = Enum('simple', 'readonly')

    def default_traits_view(self):
        traits_view = View(
            Item('model.code',
                 editor=CodeEditor(show_line_numbers=self.show_line_numbers),
                 style=self.style)
        )
        return traits_view


@skip_if_not_qt4
def test_code_editor_show_line_numbers():
    """ CodeEditor should honor the `show_line_numbers` setting
    """
    def is_line_numbers_visible(ui):
        from pyface import qt
        txt_ctrl = ui.control.findChild(qt.QtGui.QPlainTextEdit)
        return txt_ctrl.line_number_widget.isVisible()

    def test_line_numbers_visibility(show=True):
        with store_exceptions_on_all_threads():
            code_model = CodeModel()
            code_view = CodeView(model=code_model,
                                 show_line_numbers=show)
            ui = code_view.edit_traits()
            nose.tools.assert_equal(is_line_numbers_visible(ui), show)
            ui.control.close()

    test_line_numbers_visibility(True)
    test_line_numbers_visibility(False)

@skip_if_not_qt4
def test_code_editor_readonly():
    """ Test readonly editor style for CodeEditor
    """
    from pyface import qt
    with store_exceptions_on_all_threads():
        code_model = CodeModel()
        code_view = CodeView(model=code_model,
                             style='readonly')
        ui = code_view.edit_traits()
        txt_ctrl = ui.control.findChild(qt.QtGui.QPlainTextEdit)
        nose.tools.assert_true(txt_ctrl.isReadOnly())

        # Test changing the object's text
        nose.tools.assert_equal(txt_ctrl.toPlainText(), code_model.code)
        code_model.code += 'some more code'
        nose.tools.assert_true(txt_ctrl.isReadOnly())
        nose.tools.assert_equal(txt_ctrl.toPlainText(), code_model.code)

        # Test changing the underlying object
        code_model2 = CodeModel(code=code_model.code*2)
        code_view.model = code_model2
        nose.tools.assert_true(txt_ctrl.isReadOnly())
        nose.tools.assert_equal(txt_ctrl.toPlainText(), code_model.code)

        ui.control.close()


if __name__ == '__main__':
    nose.main()

########NEW FILE########
__FILENAME__ = test_csv_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Jan 2012
#
#------------------------------------------------------------------------------

from traits.has_traits import HasTraits
from traits.trait_types import Float, List, Instance
from traitsui.handler import ModelView
from traitsui.view import View
from traitsui.item import Item
from traitsui.editors.csv_list_editor import CSVListEditor
import traitsui.editors.csv_list_editor as csv_list_editor

from traitsui.tests._tools import *


class ListOfFloats(HasTraits):
    data = List(Float)


class ListOfFloatsWithCSVEditor(ModelView):
    model = Instance(ListOfFloats)

    traits_view = View(
        Item(label="Close the window to append data"),
        Item('model.data', editor = CSVListEditor()),
        buttons = ['OK']
    )


@skip_if_null
def test_csv_editor_disposal():
    # Bug: CSVListEditor does not un-hook the traits notifications after its
    # disposal, causing errors when the hooked data is accessed after
    # the window is closed (Issue #48)

    try:
        with store_exceptions_on_all_threads():
            list_of_floats = ListOfFloats(data=[1,2,3])
            csv_view = ListOfFloatsWithCSVEditor(model=list_of_floats)
            ui = csv_view.edit_traits()
            press_ok_button(ui)

            # raise an exception if still hooked
            list_of_floats.data.append(2)

    except AttributeError:
        # if all went well, we should not be here
        assert False, "AttributeError raised"


@skip_if_null
def test_csv_editor_external_append():
    # Behavior: CSV editor is notified when an element is appended to the
    # list externally

    def _wx_get_text_value(ui):
        txt_ctrl = ui.control.FindWindowByName('text')
        return txt_ctrl.GetValue()

    def _qt_get_text_value(ui):
        from pyface import qt
        txt_ctrl = ui.control.findChild(qt.QtGui.QLineEdit)
        return txt_ctrl.text()

    with store_exceptions_on_all_threads():
        list_of_floats = ListOfFloats(data=[1.0])
        csv_view = ListOfFloatsWithCSVEditor(model=list_of_floats)
        ui = csv_view.edit_traits()

        # add element to list, make sure that editor knows about it
        list_of_floats.data.append(3.14)

        # get current value from editor
        if is_current_backend_wx():
            value_str = _wx_get_text_value(ui)
        elif is_current_backend_qt4():
            value_str = _qt_get_text_value(ui)

        expected = csv_list_editor._format_list_str([1.0, 3.14])
        nose.tools.assert_equal(value_str, expected)

        press_ok_button(ui)


if __name__ == '__main__':
    # Executing the file opens the dialog for manual testing
    list_of_floats = ListOfFloats(data=[1,2,3])
    csv_view = ListOfFloatsWithCSVEditor(model=list_of_floats)
    csv_view.configure_traits()

    # this call will raise an AttributeError in commit
    # 4ecb2fa8f0ef385d55a2a4062d821b0415777973
    # This is because the editor does not un-hook the traits notifications
    # after its disposal
    list_of_floats.data.append(2)
    print list_of_floats.data

########NEW FILE########
__FILENAME__ = test_default_override

from nose.tools import assert_equals

from traitsui.api import DefaultOverride, EditorFactory
from traits.api import HasTraits, Int


class DummyEditor(EditorFactory):

    x = Int(10)
    y = Int(20)

    def simple_editor(self, ui, object, name, description, parent):
        return ('simple_editor', self, ui, object, name, description, parent)

    def custom_editor(self, ui, object, name, description, parent):
        return ('custom_editor', self, ui, object, name, description, parent)

    def text_editor(self, ui, object, name, description, parent):
        return ('text_editor', self, ui, object, name, description, parent)

    def readonly_editor(self, ui, object, name, description, parent):
        return ('readonly_editor', self, ui, object, name, description, parent)


class NewInt(Int):
    def create_editor(self):
        return DummyEditor()


class Dummy(HasTraits):
    x = NewInt()


dummy_object = Dummy()
do = DefaultOverride(x=15, y=25, format_str='%r')


def test_simple_override():
    editor_name, editor, ui, obj, name, description, parent = do.simple_editor('ui', dummy_object, 'x', 'description', 'parent')
    assert_equals(editor_name, 'simple_editor')
    assert_equals(editor.x, 15)
    assert_equals(editor.y, 25)
    assert_equals(obj, dummy_object)
    assert_equals(name, 'x')
    assert_equals(description, 'description')
    assert_equals(parent, 'parent')

def test_text_override():
    editor_name, editor, ui, obj, name, description, parent = do.text_editor('ui', dummy_object, 'x', 'description', 'parent')
    assert_equals(editor_name, 'text_editor')
    assert_equals(editor.x, 15)
    assert_equals(editor.y, 25)
    assert_equals(obj, dummy_object)
    assert_equals(name, 'x')
    assert_equals(description, 'description')
    assert_equals(parent, 'parent')

def test_custom_override():
    editor_name, editor, ui, obj, name, description, parent = do.custom_editor('ui', dummy_object, 'x', 'description', 'parent')
    assert_equals(editor_name, 'custom_editor')
    assert_equals(editor.x, 15)
    assert_equals(editor.y, 25)
    assert_equals(obj, dummy_object)
    assert_equals(name, 'x')
    assert_equals(description, 'description')
    assert_equals(parent, 'parent')

def test_readonly_override():
    editor_name, editor, ui, obj, name, description, parent = do.readonly_editor('ui', dummy_object, 'x', 'description', 'parent')
    assert_equals(editor_name, 'readonly_editor')
    assert_equals(editor.x, 15)
    assert_equals(editor.y, 25)
    assert_equals(obj, dummy_object)
    assert_equals(name, 'x')
    assert_equals(description, 'description')
    assert_equals(parent, 'parent')

########NEW FILE########
__FILENAME__ = test_liststr_editor_selection
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Corran Webster
#  Date:   Oct 2013
#
#------------------------------------------------------------------------------

"""
Test case for bug (wx, Mac OS X)

A ListStrEditor was not checking for valid item indexes under Wx.  This was
most noticeable when the selected_index was set in the editor factory.
"""

from traits.has_traits import HasTraits
from traits.trait_types import List, Int, Str
from traitsui.item import Item
from traitsui.view import View
from traitsui.editors.list_str_editor import ListStrEditor

from traitsui.tests._tools import *


class ListStrEditorWithSelectedIndex(HasTraits):
    values = List(Str())
    selected_index = Int()
    selected_indices = List(Int())

single_select_view = View(
    Item('values',
        show_label=False,
        editor=ListStrEditor(
            selected_index='selected_index',
            editable=False),
    ),
    buttons=['OK'])
        
multi_select_view = View(
    Item('values',
        show_label=False,
        editor=ListStrEditor(
            multi_select=True,
            selected_index='selected_indices',
            editable=False),
    ),
    buttons=['OK'])
        
def get_selected(control):
    """ Returns a list of the indices of all currently selected list items.
    """
    import wx
    selected = []
    item     = -1
    while True:
        item = control.GetNextItem(item, wx.LIST_NEXT_ALL,
                                    wx.LIST_STATE_SELECTED)
        if item == -1:
            break;
        selected.append(item)
    return selected

@skip_if_not_wx
def test_wx_list_str_selected_index():
    # behavior: when starting up, the

    with store_exceptions_on_all_threads():
        obj = ListStrEditorWithSelectedIndex(
                values=['value1', 'value2'],
                selected_index=1)
        ui = obj.edit_traits(view=single_select_view)

        # the following is equivalent to setting the text in the text control,
        # then pressing OK

        liststrctrl = ui.control.FindWindowByName('listCtrl')
        selected_1 = get_selected(liststrctrl)
        
        obj.selected_index = 0
        selected_2 = get_selected(liststrctrl)

        # press the OK button and close the dialog
        press_ok_button(ui)

    # the number traits should be between 3 and 8
    assert selected_1 == [1]
    assert selected_2 == [0]

@skip_if_not_wx
def test_wx_list_str_multi_selected_index():
    # behavior: when starting up, the

    with store_exceptions_on_all_threads():
        obj = ListStrEditorWithSelectedIndex(
                values=['value1', 'value2'],
                selected_indices=[1])
        ui = obj.edit_traits(view=multi_select_view)

        # the following is equivalent to setting the text in the text control,
        # then pressing OK

        liststrctrl = ui.control.FindWindowByName('listCtrl')
        selected_1 = get_selected(liststrctrl)
        
        obj.selected_indices = [0]
        selected_2 = get_selected(liststrctrl)

        # press the OK button and close the dialog
        press_ok_button(ui)

    # the number traits should be between 3 and 8
    assert selected_1 == [1]
    assert selected_2 == [0]


if __name__ == '__main__':
    # Executing the file opens the dialog for manual testing
    editor = ListStrEditorWithSelectedIndex(
            values=['value1', 'value2'],
            selected_index=1)
    editor.configure_traits(view=single_select_view)

########NEW FILE########
__FILENAME__ = test_range_editor_spinner
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Jan 2012
#
#------------------------------------------------------------------------------

"""
Test case for bug (wx, Mac OS X)

Editing the text part of a spin control box and pressing the OK button
without de-focusing raises an AttributeError

Traceback (most recent call last):
  File "ETS/traitsui/traitsui/wx/range_editor.py", line 783, in update_object
    self.value = self.control.GetValue()
AttributeError: 'NoneType' object has no attribute 'GetValue'
"""

from traits.has_traits import HasTraits
from traits.trait_types import Int
from traitsui.item import Item
from traitsui.view import View
from traitsui.editors.range_editor import RangeEditor

from traitsui.tests._tools import *


class NumberWithSpinnerEditor(HasTraits):
    """Dialog containing a RangeEditor in 'spinner' mode for an Int.
    """

    number = Int

    traits_view = View(
        Item(label="Enter 4, then press OK without defocusing"),
        Item('number', editor=RangeEditor(low=3, high=8, mode='spinner')),
        buttons = ['OK']
    )


@skip_if_not_wx
def test_wx_spin_control_editing_should_not_crash():
    # Bug: when editing the text part of a spin control box, pressing
    # the OK button raises an AttributeError on Mac OS X

    try:
        with store_exceptions_on_all_threads():
            num = NumberWithSpinnerEditor()
            ui = num.edit_traits()

            # the following is equivalent to clicking in the text control of the
            # range editor, enter a number, and clicking ok without defocusing

            # SpinCtrl object
            spin = ui.control.FindWindowByName('wxSpinCtrl')
            spin.SetFocusFromKbd()

            # on Windows, a wxSpinCtrl does not have children, and we cannot do
            # the more fine-grained testing below
            if len(spin.GetChildren()) == 0:
                spin.SetValueString('4')
            else:
                # TextCtrl object of the spin control
                spintxt = spin.FindWindowByName('text')
                spintxt.SetValue('4')

            # press the OK button and close the dialog
            press_ok_button(ui)
    except AttributeError:
        # if all went well, we should not be here
        assert False, "AttributeError raised"


@skip_if_not_wx
def test_wx_spin_control_editing_does_not_update():
    # Bug: when editing the text part of a spin control box, pressing
    # the OK button does not update the value of the HasTraits class
    # on Mac OS X

    with store_exceptions_on_all_threads():
        num = NumberWithSpinnerEditor()
        ui = num.edit_traits()

        # the following is equivalent to clicking in the text control of the
        # range editor, enter a number, and clicking ok without defocusing

        # SpinCtrl object
        spin = ui.control.FindWindowByName('wxSpinCtrl')
        spin.SetFocusFromKbd()

        # on Windows, a wxSpinCtrl does not have children, and we cannot do
        # the more fine-grained testing below
        if len(spin.GetChildren()) == 0:
            spin.SetValueString('4')
        else:
            # TextCtrl object of the spin control
            spintxt = spin.FindWindowByName('text')
            spintxt.SetValue('4')

        # press the OK button and close the dialog
        press_ok_button(ui)

        # if all went well, the number traits has been updated and its value is 4
        assert num.number == 4


@skip_if_not_qt4
def test_qt_spin_control_editing():
    # Behavior: when editing the text part of a spin control box, pressing
    # the OK button updates the value of the HasTraits class

    from pyface import qt

    with store_exceptions_on_all_threads():
        num = NumberWithSpinnerEditor()
        ui = num.edit_traits()

        # the following is equivalent to clicking in the text control of the
        # range editor, enter a number, and clicking ok without defocusing

        # text element inside the spin control
        lineedit = ui.control.findChild(qt.QtGui.QLineEdit)
        lineedit.setFocus()
        lineedit.setText('4')

        # press the OK button and close the dialog
        press_ok_button(ui)

    # if all went well, the number traits has been updated and its value is 4
    assert num.number == 4


if __name__ == '__main__':
    # Executing the file opens the dialog for manual testing
    num = NumberWithSpinnerEditor()
    num.configure_traits()
    print num.number

########NEW FILE########
__FILENAME__ = test_range_editor_text
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Jan 2012
#
#------------------------------------------------------------------------------

"""
Test case for bug (wx, Mac OS X)

A RangeEditor in mode 'text' for an Int allows values out of range.
"""

from traits.has_traits import HasTraits
from traits.trait_types import Int
from traitsui.item import Item
from traitsui.view import View
from traitsui.editors.range_editor import RangeEditor

from traitsui.tests._tools import *


class NumberWithTextEditor(HasTraits):
    """Dialog containing a RangeEditor in 'spinner' mode for an Int.
    """

    number = Int

    traits_view = View(
        Item(label="Range should be 3 to 8. Enter 1, then press OK"),
        Item('number', editor=RangeEditor(low=3, high=8, mode='text')),
        buttons = ['OK']
    )


@skip_if_not_wx
def test_wx_spin_control_editing():
    # behavior: when editing the text part of a spin control box, pressing
    # the OK button should update the value of the HasTraits class
    # (tests a bug where this fails with an AttributeError)

    with store_exceptions_on_all_threads():
        num = NumberWithTextEditor()
        ui = num.edit_traits()

        # the following is equivalent to setting the text in the text control,
        # then pressing OK

        textctrl = ui.control.FindWindowByName('text')
        textctrl.SetValue('1')

        # press the OK button and close the dialog
        press_ok_button(ui)

    # the number traits should be between 3 and 8
    assert num.number >= 3 and num.number <=8


if __name__ == '__main__':
    # Executing the file opens the dialog for manual testing
    num = NumberWithTextEditor()
    num.configure_traits()
    print num.number

########NEW FILE########
__FILENAME__ = test_tree_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Dec 2012
#
#------------------------------------------------------------------------------


from traits.api import Bool, HasTraits, Instance, Int, List
from traitsui.api import Item, TreeEditor, TreeNode, View

from traitsui.tests._tools import *


class Bogus(HasTraits):
    """ A bogus class representing a bogus tree. """

    bogus_list = List


class BogusTreeView(HasTraits):
    """ A traitsui view visualizing Bogus objects as trees. """

    bogus = Instance(Bogus)

    hide_root = Bool

    def default_traits_view(self):
        nodes = [
            TreeNode(node_for=[Bogus], children='bogus_list', label='=Bogus'),
        ]

        tree_editor = TreeEditor(
            nodes=nodes, hide_root=self.hide_root, editable=False
        )

        traits_view = View(
            Item(name='bogus', id='engine', editor=tree_editor),
            buttons = ['OK'],
        )

        return traits_view


def _test_tree_editor_releases_listeners(hide_root):
    """ The TreeEditor should release the listener to the root node's children
    when it's disposed of.
    """

    with store_exceptions_on_all_threads():
        bogus = Bogus(bogus_list=[Bogus()])
        tree_editor_view = BogusTreeView(bogus=bogus, hide_root=hide_root)
        ui = tree_editor_view.edit_traits()

        # The TreeEditor sets a listener on the bogus object's children list
        notifiers_list = bogus.trait('bogus_list')._notifiers(False)
        nose.tools.assert_equal(1, len(notifiers_list))

        # Manually close the UI
        press_ok_button(ui)

        # The listener should be removed after the UI has been closed
        notifiers_list = bogus.trait('bogus_list')._notifiers(False)
        nose.tools.assert_equal(0, len(notifiers_list))


def test_tree_editor_listeners_with_shown_root():
    _test_tree_editor_releases_listeners(hide_root=False)

def test_tree_editor_listeners_with_hidden_root():
    _test_tree_editor_releases_listeners(hide_root=True)

########NEW FILE########
__FILENAME__ = test_font_trait

from nose.tools import assert_equals

from traits.api import HasTraits, Font

from traitsui.tests._tools import *


@skip_if_not_null
def test_font_trait_default():
    class Foo(HasTraits):
        font = Font()
    f = Foo()
    assert_equals(f.font, '10 pt Arial')


@skip_if_not_null
def test_font_trait_examples():
    """
    An assigned font string is parsed, and the substrings are
    put in the order: point size, family, style, weight, underline, facename

    The words 'pt, 'point' and 'family' are ignored.

    """
    class Foo(HasTraits):
        font = Font

    f = Foo(font='Qwerty 10')
    assert_equals(f.font, '10 pt Qwerty')

    f = Foo(font='nothing')
    assert_equals(f.font, 'nothing')

    f = Foo(font='swiss family arial')
    assert_equals(f.font, 'swiss arial')

    f = Foo(font='12 pt bold italic')
    assert_equals(f.font, '12 pt italic bold')

    f = Foo(font='123 Foo bar slant')
    assert_equals(f.font, '123 pt slant Foo bar')

    f = Foo(font='123 point Foo family bar slant')
    assert_equals(f.font, '123 pt slant Foo bar')

    f = Foo(font='16 xyzzy underline slant')
    assert_equals(f.font, '16 pt slant underline xyzzy')

########NEW FILE########
__FILENAME__ = test_actions
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Feb 2012
#
#------------------------------------------------------------------------------

"""
Test that menu and toolbar actions are triggered.
"""

import pyface

from traits.has_traits import HasTraits
from traits.trait_types import Bool
from traitsui.menu import Action, ActionGroup, Menu, MenuBar, ToolBar
from traitsui.item import Item
from traitsui.view import View

from traitsui.tests._tools import *


TestAction = Action(
    name        = 'Test',
    action      = 'test_clicked',
    tooltip     = 'Click to test'
)


class DialogWithToolbar(HasTraits):
    """Test dialog with toolbar and menu."""

    action_successful = Bool(False)

    def test_clicked(self):
        self.action_successful = True

    menubar = MenuBar(
        Menu(
            ActionGroup(TestAction),
            name='&Test menu'
        ),
    )

    toolbar = ToolBar(
        ActionGroup(TestAction),
    )

    traits_view = View(
        Item(label="Click the button on the toolbar or the menu item.\n"
                   "The 'Action successful' element should turn to True."),
        Item('action_successful', style='readonly'),
        menubar = menubar,
        toolbar = toolbar,
        buttons = ['OK']
    )


def _test_actions(trigger_action_func):
    """Template test for wx, qt4, menu, and toolbar testing.
    """
    # Behavior: when clicking on a menu or toolbar action,
    # the corresponding function should be executed

    with store_exceptions_on_all_threads():
        # create dialog with toolbar adn menu
        dialog = DialogWithToolbar()
        ui = dialog.edit_traits()

        # press toolbar or menu button
        trigger_action_func(ui)

        # verify that the action was triggered
        nose.tools.assert_true(dialog.action_successful)


# ----- Qt4 tests

def _qt_trigger_action(container_class, ui):
    toolbar = ui.control.findChild(container_class)
    action = toolbar.actions()[0]
    action.trigger()


@skip_if_not_qt4
def test_qt_toolbar_action():
    # Behavior: when clicking on a toolbar action, the corresponding function
    # should be executed

    # Bug: in the Qt4 backend, a
    # TypeError: perform() takes exactly 2 arguments (1 given) was raised
    # instead

    qt_trigger_toolbar_action = partial(
        _qt_trigger_action, pyface.ui.qt4.action.tool_bar_manager._ToolBar)

    _test_actions(qt_trigger_toolbar_action)


@skip_if_not_qt4
def test_qt_menu_action():
    # Behavior: when clicking on a menu action, the corresponding function
    # should be executed

    # Bug: in the Qt4 backend, a
    # TypeError: perform() takes exactly 2 arguments (1 given) was raised
    # instead

    qt_trigger_menu_action = partial(
        _qt_trigger_action, pyface.ui.qt4.action.menu_manager._Menu)

    _test_actions(qt_trigger_menu_action)


# ----- wx tests

@skip_if_not_wx
def test_wx_toolbar_action():
    # Behavior: when clicking on a toolbar action, the corresponding function
    # should be executed

    import wx

    def _wx_trigger_toolbar_action(ui):
        # long road to get at the Id of the toolbar button
        toolbar_item = ui.view.toolbar.groups[0].items[0]
        toolbar_item_wrapper = toolbar_item._wrappers[0]
        control_id = toolbar_item_wrapper.control_id

        # build event that clicks the button
        click_event = wx.CommandEvent(wx.wxEVT_COMMAND_TOOL_CLICKED,
                                      control_id)

        # send the event to the toolbar
        toolbar = ui.control.FindWindowByName('toolbar')
        toolbar.ProcessEvent(click_event)

    _test_actions(_wx_trigger_toolbar_action)


# TODO: I couldn't find a way to press menu items programmatically for wx


if __name__ == '__main__':
    # Execute from command line for manual testing
    vw = DialogWithToolbar()
    vw.configure_traits()


########NEW FILE########
__FILENAME__ = test_labels
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Feb 2012
#
#------------------------------------------------------------------------------

"""
Test the creation and layout of labels.
"""

from traits.has_traits import HasTraits
from traits.trait_types import Bool, Str
from traitsui.view import View
from traitsui.item import Item
from traitsui.group import VGroup, HGroup

from traitsui.tests._tools import *


_DIALOG_WIDTH = 500


class ShowRightLabelsDialog(HasTraits):
    """ Dialog with labels on the left/right to test the label text.
    """

    bool_item = Bool(True)

    traits_view = View(
        VGroup(
            VGroup(
                Item('bool_item'),
                show_left=False
            ),
            VGroup(
                Item('bool_item'),
                show_left=True
            ),
        ),
    )


class HResizeTestDialog(HasTraits):
    """ Dialog with checkbox and text elements and labels on the right.
    We test the separation between element and label in HGroups.
    """

    bool_item = Bool(True)
    txt_item = Str

    traits_view = View(
        VGroup(
            HGroup(
                Item('bool_item', springy=True),
                show_left=False
            ),
            VGroup(
                Item('txt_item', resizable=True),
                show_left=False
            ),
            ),
        width  = _DIALOG_WIDTH,
        height = 100,
        resizable=True
    )


class VResizeTestDialog(HasTraits):
    """ Dialog with checkbox and text elements and labels on the right.
    We test the separation between element and label in VGroups.
    """

    bool_item = Bool(True)
    txt_item = Str

    traits_view = View(
        VGroup(
            VGroup(
                Item('bool_item', resizable=True),
                show_left=False
            ),
            VGroup(
                Item('txt_item', resizable=True),
                show_left=False
            ),
            ),
        width  = _DIALOG_WIDTH,
        height = 100,
        resizable=True
    )


class NoLabelResizeTestDialog(HasTraits):
    """ Test the combination show_label=False, show_left=False.
    """

    bool_item = Bool(True)

    traits_view = View(
        VGroup(
            Item('bool_item', resizable=True, show_label=False),
            show_left=False
        ),
        resizable=True
    )


@skip_if_not_qt4
def test_qt_show_labels_right_without_colon():
    # Behavior: traitsui should not append a colon ':' to labels
    # that are shown to the *right* of the corresponding elements

    from pyface import qt

    with store_exceptions_on_all_threads():
        dialog = ShowRightLabelsDialog()
        ui = dialog.edit_traits()

        # get reference to label objects
        labels = ui.control.findChildren(qt.QtGui.QLabel)

        # the first is shown to the right, so no colon
        nose.tools.assert_false(labels[0].text().endswith(':'))

        # the second is shown to the right, it should have a colon
        nose.tools.assert_true(labels[1].text().endswith(':'))


def _test_qt_labels_right_resizing(dialog_class):
    # Bug: In the Qt backend, resizing a checkbox element with a label on the
    # right resizes the checkbox, even though it cannot be.
    # The final effect is that the label remains attached to the right margin,
    # with a big gap between it and the checkbox. In this case, the label
    # should be made resizable instead.
    # On the other hand, a text element should keep the current behavior and
    # resize.

    from pyface import qt

    with store_exceptions_on_all_threads():
        dialog = dialog_class()
        ui = dialog.edit_traits()

        # all labels
        labels = ui.control.findChildren(qt.QtGui.QLabel)

        # the checkbox and its label should be close to one another; the
        # size of the checkbox should be small
        checkbox_label = labels[0]
        checkbox = ui.control.findChild(qt.QtGui.QCheckBox)

        # horizontal space between checkbox and label should be small
        h_space = checkbox_label.x() - checkbox.x()
        nose.tools.assert_less(h_space, 100)
        # and the checkbox size should also be small
        nose.tools.assert_less(checkbox.width(), 100)

        # the text item and its label should be close to one another; the
        # size of the text item should be large
        text_label = labels[0]
        text = ui.control.findChild(qt.QtGui.QLineEdit)

        # horizontal space between text and label should be small
        h_space = text_label.x() - text.x()
        nose.tools.assert_less(h_space, 100)
        # and the text item size should be large
        nose.tools.assert_greater(text.width(), _DIALOG_WIDTH-200)

        # the size of the window should still be 500
        nose.tools.assert_equal(ui.control.width(), _DIALOG_WIDTH)


@skip_if_not_qt4
def test_qt_labels_right_resizing_vertical():
    _test_qt_labels_right_resizing(VResizeTestDialog)


@skip_if_not_qt4
def test_qt_labels_right_resizing_horizontal():
    _test_qt_labels_right_resizing(HResizeTestDialog)


@skip_if_not_qt4
def test_qt_no_labels_on_the_right_bug():
    # Bug: If one set show_left=False, show_label=False on a non-resizable
    # item like a checkbox, the Qt backend tried to set the label's size
    # policy and failed because label=None.

    with store_exceptions_on_all_threads():
        dialog = NoLabelResizeTestDialog()
        ui = dialog.edit_traits()



if __name__ == "__main__":
    # Execute from command line for manual testing
    vw = HResizeTestDialog()
    vw.configure_traits()

########NEW FILE########
__FILENAME__ = test_layout
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Feb 2012
#
#------------------------------------------------------------------------------

"""
Test the layout of elements is consistent with the layout parameters.
"""

from traits.has_traits import HasTraits
from traits.trait_types import Str

from traitsui.item import Item
from traitsui.view import View
from traitsui.group import HGroup, VGroup

from traitsui.tests._tools import *


_DIALOG_WIDTH = 500
_DIALOG_HEIGHT = 500
_TXT_WIDTH = 100

class VResizeDialog(HasTraits):

    txt = Str('hallo')

    traits_view = View(
        VGroup(
            Item('txt', width=_TXT_WIDTH, resizable=True),
        ),
        width  = _DIALOG_WIDTH,
        height = _DIALOG_HEIGHT,
        resizable=True
    )


class HResizeDialog(HasTraits):

    txt = Str('hallo')

    traits_view = View(
        HGroup(
            Item('txt', width=_TXT_WIDTH, resizable=True),
        ),
        width  = _DIALOG_WIDTH,
        height = _DIALOG_HEIGHT,
        resizable=True
    )


@skip_if_not_qt4
def test_qt_resizable_in_vgroup():
    # Behavior: Item.resizable controls whether a component can resize along
    # the non-layout axis of its group. In a VGroup, resizing should work
    # only in the horizontal direction.

    from pyface import qt

    with store_exceptions_on_all_threads():
        dialog = VResizeDialog()
        ui = dialog.edit_traits()

        text = ui.control.findChild(qt.QtGui.QLineEdit)

        # horizontal size should be large
        nose.tools.assert_greater(text.width(), _DIALOG_WIDTH-100)

        # vertical size should be unchanged
        nose.tools.assert_less(text.height(), 100)


@skip_if_not_qt4
def test_qt_resizable_in_hgroup():
    # Behavior: Item.resizable controls whether a component can resize along
    # the non-layout axis of its group. In a HGroup, resizing should work
    # only in the vertical direction.

    from pyface import qt

    with store_exceptions_on_all_threads():
        dialog = HResizeDialog()
        ui = dialog.edit_traits()

        text = ui.control.findChild(qt.QtGui.QLineEdit)

        # vertical size should be large
        nose.tools.assert_greater(text.height(), _DIALOG_HEIGHT-100)

        # horizontal size should be unchanged
        # ??? maybe not: some elements (e.g., the text field) have
        # 'Expanding' as their default behavior
        #nose.tools.assert_less(text.width(), _TXT_WIDTH+100)


if __name__ == "__main__":
    # Execute from command line for manual testing
    vw = VResizeDialog()
    vw.configure_traits()

########NEW FILE########
__FILENAME__ = test_regression
#------------------------------------------------------------------------------
#
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#------------------------------------------------------------------------------
""" General regression tests for various fixed bugs.
"""

import unittest

from traits.api import DelegatesTo, Event, HasTraits, Instance, Undefined
from traitsui.api import Editor, TextEditor


class Parent(HasTraits):
    button = Event()


class Child(HasTraits):
    parent = Instance(Parent)
    button = DelegatesTo('parent')


class TestRegression(unittest.TestCase):
    def test_editor_on_delegates_to_event(self):
        """ Make sure that DelegatesTo on Events passes Editor creation.
        """
        child = Child(parent=Parent())
        editor = Editor(None, factory=TextEditor(), object=child, name='button')
        self.assertIs(editor.old_value, Undefined)

    def test_attribute_error(self):
        """ Make sure genuine AttributeErrors raise on Editor creation.
        """
        self.assertRaises(AttributeError, Editor,
                          None, factory=TextEditor(), object=Parent(),
                          name='not_a_trait')

########NEW FILE########
__FILENAME__ = test_ui
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Feb 2012
#
#------------------------------------------------------------------------------

"""
Test cases for the UI object.
"""

from traits.has_traits import HasTraits
from traits.trait_types import Str, Int
import traitsui
from traitsui.item import Item
from traitsui.view import View

from traitsui.tests._tools import *


class FooDialog(HasTraits):
    """Test dialog that does nothing useful."""

    my_int = Int(2)
    my_str = Str('hallo')

    traits_view = View(
        Item('my_int'),
        Item('my_str'),
        buttons = ['OK']
    )


@skip_if_not_wx
def test_reset_with_destroy_wx():
    # Characterization test:
    # UI.reset(destroy=True) destroys all ui children of the top control

    foo = FooDialog()
    ui = foo.edit_traits()

    ui.reset(destroy=True)

    # the top control is still there
    nose.tools.assert_is_not_none(ui.control)
    # but its children are gone
    nose.tools.assert_equal(len(ui.control.GetChildren()), 0)


@skip_if_not_qt4
def test_reset_with_destroy_qt():
    # Characterization test:
    # UI.reset(destroy=True) destroys all ui children of the top control

    from pyface import qt

    foo = FooDialog()
    ui = foo.edit_traits()

    # decorate children's `deleteLater` function to check that it is called
    # on `reset`. check only with the editor parts (only widgets are scheduled,
    # see traitsui.qt4.toolkit.GUIToolkit.destroy_children)
    for c in ui.control.children():
        c.deleteLater = count_calls(c.deleteLater)

    ui.reset(destroy=True)

    # the top control is still there
    nose.tools.assert_is_not_none(ui.control)

    # but its children are scheduled for removal
    for c in ui.control.children():
        if isinstance(c, qt.QtGui.QWidget):
            nose.tools.assert_equal(c.deleteLater._n_calls, 1)


@skip_if_not_wx
def test_reset_without_destroy_wx():
    # Characterization test:
    # UI.reset(destroy=False) destroys all editor controls, but leaves editors
    # and ui children intact

    import wx

    foo = FooDialog()
    ui = foo.edit_traits()

    nose.tools.assert_equal(len(ui._editors), 2)
    nose.tools.assert_is_instance(ui._editors[0],
                                  traitsui.wx.text_editor.SimpleEditor)
    nose.tools.assert_is_instance(ui._editors[0].control,
                                  wx._controls.TextCtrl)

    ui.reset(destroy=False)

    nose.tools.assert_equal(len(ui._editors), 2)
    nose.tools.assert_is_instance(ui._editors[0],
                                  traitsui.wx.text_editor.SimpleEditor)
    nose.tools.assert_is_none(ui._editors[0].control)

    # children are still there: check first text control
    text_ctrl = ui.control.FindWindowByName('text')
    nose.tools.assert_is_not_none(text_ctrl)


@skip_if_not_qt4
def test_reset_without_destroy_qt():
    # Characterization test:
    # UI.reset(destroy=False) destroys all editor controls, but leaves editors
    # and ui children intact

    from pyface import qt

    foo = FooDialog()
    ui = foo.edit_traits()

    nose.tools.assert_equal(len(ui._editors), 2)
    nose.tools.assert_is_instance(ui._editors[0],
                                  traitsui.qt4.text_editor.SimpleEditor)
    nose.tools.assert_is_instance(ui._editors[0].control,
                                  qt.QtGui.QLineEdit)

    ui.reset(destroy=False)

    nose.tools.assert_equal(len(ui._editors), 2)
    nose.tools.assert_is_instance(ui._editors[0],
                                  traitsui.qt4.text_editor.SimpleEditor)
    nose.tools.assert_is_none(ui._editors[0].control)

    # children are still there: check first text control
    text_ctrl = ui.control.findChild(qt.QtGui.QLineEdit)
    nose.tools.assert_is_not_none(text_ctrl)


@skip_if_not_wx
def test_destroy_after_ok_wx():
    # Behavior: after pressing 'OK' in a dialog, the method UI.finish is
    # called and the view control and its children are destroyed

    import wx

    foo = FooDialog()
    ui = foo.edit_traits()

    # keep references to the children of the ui to check that they were deleted
    ui_children = []
    for c in ui.control.GetChildren():
        ui_children.append(c)

    # press the OK button and close the dialog
    okbutton = ui.control.FindWindowByName('button')
    click_event = wx.CommandEvent(wx.wxEVT_COMMAND_BUTTON_CLICKED,
                                  okbutton.GetId())
    okbutton.ProcessEvent(click_event)

    nose.tools.assert_is_none(ui.control)
    # and its children have been destroyed
    for c in ui_children:
        with nose.tools.assert_raises(wx._core.PyDeadObjectError):
            c.GetName()


@skip_if_not_qt4
def test_destroy_after_ok_qt():
    # Behavior: after pressing 'OK' in a dialog, the method UI.finish is
    # called and the view control and its children are destroyed

    from pyface import qt

    foo = FooDialog()
    ui = foo.edit_traits()

    # decorate children's `deleteLater` function to check that it is called
    for c in ui.control.children():
        c.deleteLater = count_calls(c.deleteLater)

    # keep references to the children of the ui to check that they were deleted
    ui_children = []
    for c in ui.control.children():
        ui_children.append(c)

    # press the OK button and close the dialog
    okb = ui.control.findChild(qt.QtGui.QPushButton)
    okb.click()

    nose.tools.assert_is_none(ui.control)
    # children are scheduled for removal
    for c in ui_children:
        if isinstance(c, qt.QtGui.QWidget):
            nose.tools.assert_equal(c.deleteLater._n_calls, 1)

########NEW FILE########
__FILENAME__ = test_visible_when_layout
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Feb 2012
#
#------------------------------------------------------------------------------

"""
Test the layout when element appear and disappear with visible_when.
"""

from traits.has_traits import HasTraits
from traits.trait_types import Enum, Bool, Str

from traitsui.group import HGroup, VGroup
from traitsui.include import Include
from traitsui.item import Item
from traitsui.view import View

from traitsui.tests._tools import *

_TEXT_WIDTH = 200
_TEXT_HEIGHT = 100

class VisibleWhenProblem(HasTraits):

    which = Enum('one', 'two')

    on  = Bool
    txt = Str

    onoff_group = HGroup(
        VGroup(
            Item('on', resizable=False, width=-100, height=-70),
            show_left = False,
            show_border = True, visible_when='which == "one"'
        ),
    )

    text_group = VGroup(
        Item('txt', width=-_TEXT_WIDTH, height=-_TEXT_HEIGHT),
        visible_when='which == "two"',
        show_border = True,
    )

    traits_view = View(
        Item('which'),
        VGroup(
            Include('onoff_group'),
            Include('text_group'),
            ),
        resizable = True,
        buttons = ['OK', 'Cancel']
    )


@skip_if_null
def test_visible_when_layout():
    # Bug: The size of a dialog that contains elements that are activated
    # by "visible_when" can end up being the *sum* of the sizes of the
    # elements, even though the elements are mutually exclusive (e.g.,
    # a typical case is a dropbox that lets you select different cases).
    # The expected behavior is that the size of the dialog should be at most
    # the size of the largest combination of elements.

    with store_exceptions_on_all_threads():
        dialog = VisibleWhenProblem()
        ui = dialog.edit_traits()

        # have the dialog switch from group one to two and back to one
        dialog.which = 'two'
        dialog.which = 'one'

        # the size of the window should not be larger than the largest
        # combination (in this case, the `text_group` plus the `which` item
        size = get_dialog_size(ui.control)
        # leave some margin for labels, dropbox, etc
        nose.tools.assert_less(size[0], _TEXT_WIDTH+100)
        nose.tools.assert_less(size[1], _TEXT_HEIGHT+150)


if __name__ == '__main__':
    # Execute from command line for manual testing
    vw = VisibleWhenProblem(txt='ciao')
    ui = vw.configure_traits()

########NEW FILE########
__FILENAME__ = _tools
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Author: Pietro Berkes
#  Date:   Jan 2012
#
#------------------------------------------------------------------------------

from functools import partial
from contextlib import contextmanager
import nose

import sys
import traceback

from traits.etsconfig.api import ETSConfig
import traits.trait_notifiers

# ######### Testing tools

@contextmanager
def store_exceptions_on_all_threads():
    """Context manager that captures all exceptions, even those coming from
    the UI thread. On exit, the first exception is raised (if any).

    It also temporarily overwrites the global function
    traits.trait_notifier.handle_exception , which logs exceptions to
    console without re-raising them by default.
    """

    exceptions = []

    def _print_uncaught_exception(type, value, tb):
        message = 'Uncaught exception:\n'
        message += ''.join(traceback.format_exception(type, value, tb))
        print message

    def excepthook(type, value, tb):
        exceptions.append(value)
        _print_uncaught_exception(type, value, tb)

    def handle_exception(object, trait_name, old, new):
        type, value, tb = sys.exc_info()
        exceptions.append(value)
        _print_uncaught_exception(type, value, tb)

    _original_handle_exception = traits.trait_notifiers.handle_exception
    try:
        sys.excepthook = excepthook
        traits.trait_notifiers.handle_exception = handle_exception
        yield
    finally:
        if len(exceptions) > 0:
            raise exceptions[0]
        sys.excepthook = sys.__excepthook__
        traits.trait_notifiers.handle_exception = _original_handle_exception


def _is_current_backend(backend_name=''):
    return ETSConfig.toolkit == backend_name


def skip_if_not_backend(test_func, backend_name=''):
    """Decorator that skip tests if the backend is not the desired one."""

    if not _is_current_backend(backend_name):
        # preserve original name so that it appears in the report
        orig_name = test_func.__name__
        def test_func():
            raise nose.SkipTest
        test_func.__name__ = orig_name

    return test_func


#: Return True if current backend is 'wx'
is_current_backend_wx = partial(_is_current_backend, backend_name='wx')

#: Return True if current backend is 'qt4'
is_current_backend_qt4 = partial(_is_current_backend, backend_name='qt4')

#: Return True if current backend is 'null'
is_current_backend_null = partial(_is_current_backend, backend_name='null')


#: Test decorator: Skip test if backend is not 'wx'
skip_if_not_wx = partial(skip_if_not_backend, backend_name='wx')

#: Test decorator: Skip test if backend is not 'qt4'
skip_if_not_qt4 = partial(skip_if_not_backend, backend_name='qt4')

#: Test decorator: Skip test if backend is not 'null'
skip_if_not_null = partial(skip_if_not_backend, backend_name='null')


def skip_if_null(test_func):
    """Decorator that skip tests if the backend is set to 'null'.

    Some tests handle both wx and Qt in one go, but many things are not
    defined in the null backend. Use this decorator to skip the test.
    """

    if _is_current_backend('null'):
        # preserve original name so that it appears in the report
        orig_name = test_func.__name__
        def test_func():
            raise nose.SkipTest
        test_func.__name__ = orig_name

    return test_func


def count_calls(func):
    """Decorator that stores the number of times a function is called.

    The counter is stored in func._n_counts.
    """

    def wrapped(*args, **kwargs):
        wrapped._n_calls += 1
        return func(*args, **kwargs)

    wrapped._n_calls = 0

    return wrapped


# ######### Utility tools to test on both qt4 and wx

def get_children(node):
    if ETSConfig.toolkit == 'wx':
        return node.GetChildren()
    else:
        return node.children()


def press_ok_button(ui):
    """Press the OK button in a wx or qt dialog."""

    if is_current_backend_wx():
        import wx

        ok_button = ui.control.FindWindowByName('button')
        click_event = wx.CommandEvent(wx.wxEVT_COMMAND_BUTTON_CLICKED,
                                      ok_button.GetId())
        ok_button.ProcessEvent(click_event)

    elif is_current_backend_qt4():
        from pyface import qt

        # press the OK button and close the dialog
        ok_button = ui.control.findChild(qt.QtGui.QPushButton)
        ok_button.click()


def get_dialog_size(ui_control):
    """Return the size of the dialog.

    Return a tuple (width, height) with the size of the dialog in pixels.
    E.g.:

        >>> get_dialog_size(ui.control)
    """

    if is_current_backend_wx():
        return ui_control.GetSizeTuple()

    elif is_current_backend_qt4():
        return ui_control.size().width(), ui_control.size().height()


# ######### Debug tools

def apply_on_children(func, node, _level=0):
    """Print the result of applying a function on `node` and its children.
    """
    print '-'*_level + str(node)
    print ' '*_level + str(func(node)) + '\n'
    for child in get_children(node):
        apply_on_children(func, child, _level+1)


def wx_print_names(node):
    """Print the name and id of `node` and its children.

    Use as::

        >>> ui = xxx.edit_traits()
        >>> wx_print_names(ui.control)
    """
    apply_on_children(lambda n: (n.GetName(), n.GetId()), node)


def qt_print_names(node):
    """Print the name of `node` and its children.

    Use as::

        >>> ui = xxx.edit_traits()
        >>> qt_print_names(ui.control)
    """
    apply_on_children(lambda n: n.objectName(), node)


def wx_announce_when_destroyed(node):
    """Prints a message when `node` is destroyed.

    Use as:

        >>> ui = xxx.edit_traits()
        >>> apply_on_children(wx_announce_when_destroyed, ui.control)
    """

    _destroy_method = node.Destroy

    def destroy_wrapped():
        print 'Destroying:', node
        #print 'Stack is'
        #traceback.print_stack()
        _destroy_method()
        print 'Destroyed:', node

    node.Destroy = destroy_wrapped
    return 'Node {} decorated'.format(node.GetName())


def wx_find_event_by_number(evt_num):
    """Find all wx event names that correspond to a certain event number.

    Example:

        >>> wx_find_event_by_number(10010)
        ['wxEVT_COMMAND_MENU_SELECTED', 'wxEVT_COMMAND_TOOL_CLICKED']
    """

    import wx
    possible = [attr for attr in dir(wx)
                if attr.startswith('wxEVT') and getattr(wx, attr) == evt_num]

    return possible

########NEW FILE########
__FILENAME__ = theme
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/13/2007
#
#-------------------------------------------------------------------------------

""" Defines 'theme' related classes.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits

from .ui_traits import Image, HasBorder, HasMargin, Alignment

#-------------------------------------------------------------------------------
#  'Theme' class:
#-------------------------------------------------------------------------------

class Theme ( HasPrivateTraits ):

    #-- Public Traits ----------------------------------------------------------

    # The background image to use for the theme:
    image = Image

    # The border inset:
    border = HasBorder

    # The margin to use around the content:
    content = HasMargin

    # The margin to use around the label:
    label = HasMargin

    # The alignment to use for positioning the label:
    alignment = Alignment( cols = 4 )

    # Note: The 'content_color' and 'label_color' traits should be added by a
    # toolkit-specific category...

    #-- Constructor ------------------------------------------------------------

    def __init__ ( self, image = None, **traits ):
        """ Initializes the object.
        """
        if image is not None:
            self.image = image

        super( Theme, self ).__init__( **traits )

# Create a default theme:
default_theme = Theme()


########NEW FILE########
__FILENAME__ = toolkit
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the stub functions used for creating concrete implementations of
    the standard EditorFactory subclasses supplied with the Traits package.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, TraitError

from traits.trait_base import ETSConfig

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# List of implemented UI toolkits:
TraitUIToolkits = [ 'wx', 'qt4', 'null' ]

#-------------------------------------------------------------------------------
#  Data:
#-------------------------------------------------------------------------------

# The current GUI toolkit object being used:
_toolkit = None

#-------------------------------------------------------------------------------
#  Low-level GUI toolkit selection function:
#-------------------------------------------------------------------------------

def _import_toolkit ( name ):
    return __import__( name, globals=globals(), level=1 ).toolkit


def assert_toolkit_import(name):
    """ Raise an error if a toolkit with the given name should not be allowed
    to be imported.
    """
    if ETSConfig.toolkit and ETSConfig.toolkit != name:
        raise RuntimeError, "Importing from %s backend after selecting %s " \
                "backend!" % (name, ETSConfig.toolkit)


def toolkit_object(name, raise_exceptions=False):
    """ Return the toolkit specific object with the given name.  The name
    consists of the relative module path and the object name separated by a
    colon.
    """

    mname, oname = name.split(':')

    class Unimplemented ( object ):
        """ This is returned if an object isn't implemented by the selected
        toolkit.  It raises an exception if it is ever instantiated.
        """

        def __init__( self, *args, **kwargs ):
            raise NotImplementedError( "The %s traits backend doesn't "
                "implement %s" % ( ETSConfig.toolkit, oname ) )

    be_obj   = Unimplemented
    be_mname = toolkit().__module__.split('.')[-2] + '.' + mname
    try:
        module = __import__(
            be_mname, globals=globals(), fromlist=[oname], level=1
        )
        try:
            be_obj = getattr(module, oname)
        except AttributeError, e:
            if raise_exceptions: raise e
    except ImportError, e:
        if raise_exceptions: raise e

    return be_obj


def toolkit ( *toolkits ):
    """ Selects and returns a low-level GUI toolkit.

    Use this function to get a reference to the current toolkit.
    """

    global _toolkit
    # If _toolkit has already been set, simply return it.
    if _toolkit is not None:
        return _toolkit

    if ETSConfig.toolkit:
        # If a toolkit has already been set for ETSConfig, then use it:
        _toolkit = _import_toolkit(ETSConfig.toolkit)
        return _toolkit
    else:
        if len( toolkits ) == 0:
            toolkits = TraitUIToolkits

        for toolkit_name in toolkits:
            try:
                _toolkit = _import_toolkit( toolkit_name )

                # In case we have just decided on a toolkit, tell everybody else:
                ETSConfig.toolkit = toolkit_name

                return _toolkit

            except (AttributeError, ImportError):
                pass
        else:
            # Try using the null toolkit and printing a warning
            try:
                _toolkit = _import_toolkit( 'null' )
                import warnings
                warnings.warn( "Unable to import the '%s' backend for traits UI; "
                               "using the 'null' toolkit instead." % toolkit_name )
                return _toolkit

            except ImportError:
                raise TraitError( "Could not find any UI toolkit called '%s'" %
                                  toolkit_name )

#-------------------------------------------------------------------------------
#  'Toolkit' class (abstract base class):
#-------------------------------------------------------------------------------

class Toolkit ( HasPrivateTraits ):
    """ Abstract base class for GUI toolkits.
    """

    #---------------------------------------------------------------------------
    #  Create GUI toolkit specific user interfaces using information from the
    #  specified UI object:
    #---------------------------------------------------------------------------

    def ui_panel ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific panel-based user interface using
            information from the specified UI object.
        """
        raise NotImplementedError

    def ui_subpanel ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific subpanel-based user interface using
            information from the specified UI object.
        """
        raise NotImplementedError

    def ui_livemodal ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific modal "live update" dialog user
            interface using information from the specified UI object.
        """
        raise NotImplementedError

    def ui_live ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific non-modal "live update" window user
            interface using information from the specified UI object.
        """
        raise NotImplementedError

    def ui_modal ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific modal dialog user interface using
            information from the specified UI object.
        """
        raise NotImplementedError

    def ui_nonmodal ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific non-modal dialog user interface using
            information from the specified UI object.
        """
        raise NotImplementedError

    def ui_popup ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific temporary "live update" popup dialog
            user interface using information from the specified UI object.
        """
        raise NotImplementedError

    def ui_popover ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific temporary "live update" popup dialog
            user interface using information from the specified UI object.
        """
        raise NotImplementedError

    def ui_info ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific temporary "live update" popup dialog
            user interface using information from the specified UI object.
        """
        raise NotImplementedError

    def ui_wizard ( self, ui, parent ):
        """ Creates a GUI-toolkit-specific wizard dialog user interface using
            information from the specified UI object.
        """
        raise NotImplementedError

    def view_application ( self, context, view, kind = None, handler = None,
                                      id = '', scrollable = None, args = None ):
        """ Creates a GUI-toolkit-specific modal dialog user interface that
            runs as a complete application using information from the
            specified View object.

        Parameters
        ----------
        context : object or dictionary
            A single object or a dictionary of string/object pairs, whose trait
            attributes are to be edited. If not specified, the current object is
            used.
        view : view or string
            A View object that defines a user interface for editing trait
            attribute values.
        kind : string
            The type of user interface window to create. See the
            **traitsui.view.kind_trait** trait for values and
            their meanings. If *kind* is unspecified or None, the **kind**
            attribute of the View object is used.
        handler : Handler object
            A handler object used for event handling in the dialog box. If
            None, the default handler for Traits UI is used.
        id : string
            A unique ID for persisting preferences about this user interface,
            such as size and position. If not specified, no user preferences
            are saved.
        scrollable : Boolean
            Indicates whether the dialog box should be scrollable. When set to
            True, scroll bars appear on the dialog box if it is not large enough
            to display all of the items in the view at one time.

        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Positions the associated dialog window on the display:
    #---------------------------------------------------------------------------

    def position ( self, ui ):
        """ Positions the associated dialog window on the display.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Shows a 'Help' window for a specified UI and control:
    #---------------------------------------------------------------------------

    def show_help ( self, ui, control ):
        """ Shows a Help window for a specified UI and control.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Sets the title for the UI window:
    #---------------------------------------------------------------------------

    def set_title ( self, ui ):
        """ Sets the title for the UI window.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Sets the icon for the UI window:
    #---------------------------------------------------------------------------

    def set_icon ( self, ui ):
        """ Sets the icon for the UI window.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Saves user preference information associated with a UI window:
    #---------------------------------------------------------------------------

    def save_window ( self, ui ):
        """ Saves user preference information associated with a UI window.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Rebuilds a UI after a change to the content of the UI:
    #---------------------------------------------------------------------------

    def rebuild_ui ( self, ui ):
        """ Rebuilds a UI after a change to the content of the UI.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Converts a keystroke event into a corresponding key name:
    #---------------------------------------------------------------------------

    def key_event_to_name ( self, event ):
        """ Converts a keystroke event into a corresponding key name.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Hooks all specified events for all controls in a ui so that they can be
    #  routed to the corrent event handler:
    #---------------------------------------------------------------------------

    def hook_events ( self, ui, control, events = None, handler = None ):
        """ Hooks all specified events for all controls in a UI so that they
            can be routed to the correct event handler.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Routes a 'hooked' event to the corrent handler method:
    #---------------------------------------------------------------------------

    def route_event ( self, ui, event ):
        """ Routes a "hooked" event to the corrent handler method.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Indicates that an event should continue to be processed by the toolkit
    #---------------------------------------------------------------------------

    def skip_event ( self, event ):
        """ Indicates that an event should continue to be processed by the
            toolkit.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Destroys a specified GUI toolkit control:
    #---------------------------------------------------------------------------

    def destroy_control ( self, control ):
        """ Destroys a specified GUI toolkit control.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Destroys all of the child controls of a specified GUI toolkit control:
    #---------------------------------------------------------------------------

    def destroy_children ( self, control ):
        """ Destroys all of the child controls of a specified GUI toolkit
            control.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Returns a ( width, height ) tuple containing the size of a specified
    #  toolkit image:
    #---------------------------------------------------------------------------

    def image_size ( self, image ):
        """ Returns a ( width, height ) tuple containing the size of a
            specified toolkit image.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Returns a dictionary of useful constants:
    #---------------------------------------------------------------------------

    def constants ( self ):
        """ Returns a dictionary of useful constants.

            Currently, the dictionary should have the following key/value pairs:

            - WindowColor': the standard window background color in the toolkit
              specific color format.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Returns a renderer used to render 'themed' table cells for a specified
    #  TableColumn object:
    #---------------------------------------------------------------------------

    def themed_cell_renderer ( self, column ):
        """ Returns a renderer used to render 'themed' table cells for a
            specified TableColum object.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  GUI toolkit dependent trait definitions:
    #---------------------------------------------------------------------------

    def color_trait ( self, *args, **traits ):
        raise NotImplementedError

    def rgb_color_trait ( self, *args, **traits ):
        raise NotImplementedError

    def rgba_color_trait ( self, *args, **traits ):
        raise NotImplementedError

    def font_trait ( self, *args, **traits ):
        raise NotImplementedError

    def kiva_font_trait ( self, *args, **traits ):
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  'Editor' class methods:
    #---------------------------------------------------------------------------

    def ui_editor ( self ):
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  'EditorFactory' factory methods:
    #---------------------------------------------------------------------------

    def array_editor ( self, *args, **traits ):
        raise NotImplementedError

    def boolean_editor ( self, *args, **traits ):
        raise NotImplementedError

    def button_editor ( self, *args, **traits ):
        raise NotImplementedError

    def check_list_editor ( self, *args, **traits ):
        raise NotImplementedError

    def code_editor ( self, *args, **traits ):
        raise NotImplementedError

    def color_editor ( self, *args, **traits ):
        raise NotImplementedError

    def compound_editor ( self, *args, **traits ):
        raise NotImplementedError

    def custom_editor ( self, *args, **traits ):
        raise NotImplementedError

    def directory_editor ( self, *args, **traits ):
        raise NotImplementedError

    def drop_editor ( self, *args, **traits ):
        raise NotImplementedError

    def dnd_editor ( self, *args, **traits ):
        raise NotImplementedError

    def enum_editor ( self, *args, **traits ):
        raise NotImplementedError

    def file_editor ( self, *args, **traits ):
        raise NotImplementedError

    def font_editor ( self, *args, **traits ):
        raise NotImplementedError

    def key_binding_editor ( self, *args, **traits ):
        raise NotImplementedError

    def history_editor ( self, *args, **traits ):
        raise NotImplementedError

    def html_editor ( self, *args, **traits ):
        raise NotImplementedError

    def image_editor ( self, *args, **traits ):
        raise NotImplementedError

    def image_enum_editor ( self, *args, **traits ):
        raise NotImplementedError

    def instance_editor ( self, *args, **traits ):
        raise NotImplementedError

    def list_editor ( self, *args, **traits ):
        raise NotImplementedError

    def list_str_editor ( self, *args, **traits ):
        raise NotImplementedError

    def null_editor ( self, *args, **traits ):
        raise NotImplementedError

    def ordered_set_editor ( self, *args, **traits ):
        raise NotImplementedError

    def plot_editor ( self, *args, **traits ):
        raise NotImplementedError

    def range_editor ( self, *args, **traits ):
        raise NotImplementedError

    def rgb_color_editor ( self, *args, **traits ):
        raise NotImplementedError

    def rgba_color_editor ( self, *args, **traits ):
        raise NotImplementedError

    def shell_editor ( self, *args, **traits ):
        raise NotImplementedError

    def table_editor ( self, *args, **traits ):
        raise NotImplementedError

    def tabular_editor ( self, *args, **traits ):
        raise NotImplementedError

    def text_editor ( self, *args, **traits ):
        raise NotImplementedError

    def title_editor ( self, *args, **traits ):
        raise NotImplementedError

    def tree_editor ( self, *args, **traits ):
        raise NotImplementedError

    def tuple_editor ( self, *args, **traits ):
        raise NotImplementedError

    def value_editor ( self, *args, **traits ):
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = toolkit_traits

from __future__ import absolute_import

from .toolkit import toolkit

def ColorTrait ( *args, **traits ):
    return toolkit().color_trait( *args, **traits )

def RGBColorTrait ( *args, **traits ):
    return toolkit().rgb_color_trait( *args, **traits )

def FontTrait ( *args, **traits ):
    return toolkit().font_trait( *args, **traits )


########NEW FILE########
__FILENAME__ = tree_node
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/03/2004
#
#------------------------------------------------------------------------------

""" Defines the tree node descriptor used by the tree editor and tree editor
    factory classes.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (AdaptedTo, Adapter, Any, Bool, Callable, Either,
    HasPrivateTraits, Instance, Interface, isinterface, List, Property, Str,
    cached_property)

from traits.trait_base import SequenceTypes, get_resource_path, xgetattr, xsetattr

from .ui_traits import AView

#-------------------------------------------------------------------------------
#  'TreeNode' class:
#-------------------------------------------------------------------------------

class TreeNode ( HasPrivateTraits ):
    """ Represents a tree node. Used by the tree editor and tree editor factory
        classes.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Name of trait containing children (if '', the node is a leaf).
    children = Str

    # Either the name of a trait containing a label, or a constant label, if
    # the string starts with '='.
    label = Str

    # The name of a trait containing a list of labels for any columns.
    column_labels = Str

    # Either the name of a trait containing a tooltip, or constant tooltip, if
    # the string starts with '='.
    tooltip = Str

    # Name to use for a new instance
    name = Str

    # Can the object's children be renamed?
    rename = Bool( True )

    # Can the object be renamed?
    rename_me = Bool( True )

    # Can the object's children be copied?
    copy = Bool( True )

    # Can the object's children be deleted?
    delete = Bool( True )

    # Can the object be deleted (if its parent allows it)?
    delete_me = Bool( True )

    # Can children be inserted (vs. appended)?
    insert = Bool( True )

    # Should tree nodes be automatically opened (expanded)?
    auto_open = Bool( False )

    # Automatically close sibling tree nodes?
    auto_close = Bool( False )

    # List of object classes than can be added or copied
    add = List( Any )

    # List of object classes that can be moved
    move = List( Any )

    # List of object classes and/or interfaces that the node applies to
    node_for = List( Any )

    # Tuple of object classes that the node applies to
    node_for_class = Property( depends_on = 'node_for' )

    # List of object interfaces that the node applies to
    node_for_interface = Property( depends_on = 'node_for' )

    # Function for formatting the label
    formatter = Callable

    # Functions for formatting the other columns.
    column_formatters = List(Either(None, Callable))

    # Function for formatting the tooltip
    tooltip_formatter = Callable

    # Function for handling selecting an object
    on_select = Callable

    # Function for handling clicking an object
    on_click = Callable

    # Function for handling double-clicking an object
    on_dclick = Callable

    # Function for handling activation of an object
    # (double-click or Enter key press when node is in focus)
    on_activated = Callable

    # View to use for editing the object
    view = AView

    # Right-click context menu. The value can be one of:
    #
    # - Instance( Menu ): Use this menu as the context menu
    # - None: Use the default context menu
    # - False: Do not display a context menu
    menu = Any

    # Name of leaf item icon
    icon_item = Str( '<item>' )

    # Name of group item icon
    icon_group = Str( '<group>' )

    # Name of opened group item icon
    icon_open = Str( '<open>' )

    # Resource path used to locate the node icon
    icon_path = Str

    # Selector or name for background color
    background = Any

    # Selector or name for foreground color
    foreground = Any

    # fixme: The 'menu' trait should really be defined as:
    #        Instance( 'traitsui.menu.MenuBar' ), but it doesn't work
    #        right currently.

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        super( TreeNode, self ).__init__( **traits )
        if self.icon_path == '':
            self.icon_path = get_resource_path()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_node_for_class ( self ):
        return tuple( [ klass for klass in self.node_for
                        if not isinterface(klass) ] )

    @cached_property
    def _get_node_for_interface ( self ):
        return [ klass for klass in self.node_for
                 if isinterface(klass) ]

    #-- Overridable Methods: ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def allows_children ( self, object ):
        """ Returns whether this object can have children.
        """
        return (self.children != '')

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def has_children ( self, object ):
        """ Returns whether the object has children.
        """
        return (len( self.get_children( object ) ) > 0)

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def get_children ( self, object ):
        """ Gets the object's children.
        """
        return getattr( object, self.children )

    #---------------------------------------------------------------------------
    #  Gets the object's children identifier:
    #---------------------------------------------------------------------------

    def get_children_id ( self, object ):
        """ Gets the object's children identifier.
        """
        return self.children

    #---------------------------------------------------------------------------
    #  Appends a child to the object's children:
    #---------------------------------------------------------------------------

    def append_child ( self, object, child ):
        """ Appends a child to the object's children.
        """
        getattr( object, self.children ).append( child )

    #---------------------------------------------------------------------------
    #  Inserts a child into the object's children:
    #---------------------------------------------------------------------------

    def insert_child ( self, object, index, child ):
        """ Inserts a child into the object's children.
        """
        getattr( object, self.children )[ index: index ] = [ child ]

    #---------------------------------------------------------------------------
    #  Confirms that a specified object can be deleted or not:
    #  Result = True:  Delete object with no further prompting
    #         = False: Do not delete object
    #         = other: Take default action (may prompt user to confirm delete)
    #---------------------------------------------------------------------------

    def confirm_delete ( self, object ):
        """ Checks whether a specified object can be deleted.

        Returns
        -------
        * **True** if the object should be deleted with no further prompting.
        * **False** if the object should not be deleted.
        * Anything else: Caller should take its default action (which might
          include prompting the user to confirm deletion).
        """
        return None

    #---------------------------------------------------------------------------
    #  Deletes a child at a specified index from the object's children:
    #---------------------------------------------------------------------------

    def delete_child ( self, object, index ):
        """ Deletes a child at a specified index from the object's children.
        """
        del getattr( object, self.children )[ index ]

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children replaced' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def when_children_replaced ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
        specified object.
        """
        object.on_trait_change( listener, self.children, remove = remove,
                                dispatch = 'fast_ui' )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children changed' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def when_children_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
        specified object.
        """
        object.on_trait_change( listener, self.children + '_items',
                                remove = remove, dispatch = 'fast_ui' )

    #---------------------------------------------------------------------------
    #  Gets the label to display for a specified object:
    #---------------------------------------------------------------------------

    def get_label ( self, object ):
        """ Gets the label to display for a specified object.
        """
        label = self.label
        if label[:1] == '=':
            return label[1:]

        label = xgetattr( object, label, '' )

        if self.formatter is None:
            return label

        return self.formatter( object, label )

    #---------------------------------------------------------------------------
    #  Sets the label for a specified object:
    #---------------------------------------------------------------------------

    def set_label ( self, object, label ):
        """ Sets the label for a specified object.
        """
        label_name = self.label
        if label_name[:1] != '=':
            xsetattr( object, label_name, label )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'label changed' on a specified object:
    #---------------------------------------------------------------------------

    def when_label_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for the label being changed on a
        specified object.
        """
        label = self.label
        if label[:1] != '=':
            object.on_trait_change( listener, label, remove = remove,
                                    dispatch = 'ui' )

    def get_column_labels(self, object):
        """ Get the labels for any columns that have been defined.
        """
        trait = self.column_labels
        labels = xgetattr(object, trait, [])
        formatted = []
        for formatter, label in map(None, self.column_formatters, labels):
            # If the list of column formatters is shorter than the list of
            # labels, then map(None) will extend it with Nones. Just pass the label
            # as preformatted. Similarly, explicitly using None in the list will
            # pass through the item.
            if formatter is None:
                formatted.append(label)
            else:
                formatted.append(formatter(label))
        return formatted

    def when_column_labels_change(self, object, listener, remove):
        """ Sets up or removes a listener for the column labels being changed on
        a specified object.

        This will fire when either the list is reassigned or when it is
        modified. I.e., it listens both to the trait change event and the
        trait_items change event. Implement the listener appropriately to handle
        either case.
        """
        trait = self.column_labels
        if trait != '':
            object.on_trait_change(listener, trait, remove=remove, dispatch='ui')
            object.on_trait_change(listener, trait+'_items', remove=remove, dispatch='ui')

    #---------------------------------------------------------------------------
    #  Gets the tooltip to display for a specified object:
    #---------------------------------------------------------------------------

    def get_tooltip ( self, object ):
        """ Gets the tooltip to display for a specified object.
        """
        tooltip = self.tooltip
        if tooltip == '':
            return tooltip

        if tooltip[:1] == '=':
            return tooltip[1:]

        tooltip = xgetattr( object, tooltip, '' )

        if self.tooltip_formatter is None:
            return tooltip

        return self.tooltip_formatter( object, tooltip )

    #---------------------------------------------------------------------------
    #  Returns the icon for a specified object:
    #---------------------------------------------------------------------------

    def get_icon ( self, object, is_expanded ):
        """ Returns the icon for a specified object.
        """
        if not self.allows_children( object ):
            return self.icon_item

        if is_expanded:
            return self.icon_open

        return self.icon_group

    #---------------------------------------------------------------------------
    #  Returns the path used to locate an object's icon:
    #---------------------------------------------------------------------------

    def get_icon_path ( self, object ):
        """ Returns the path used to locate an object's icon.
        """
        return self.icon_path

    #---------------------------------------------------------------------------
    #  Returns the name to use when adding a new object instance (displayed in
    #  the 'New' submenu):
    #---------------------------------------------------------------------------

    def get_name ( self, object ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """
        return self.name

    #---------------------------------------------------------------------------
    #  Gets the View to use when editing an object:
    #---------------------------------------------------------------------------

    def get_view ( self, object ):
        """ Gets the view to use when editing an object.
        """
        return self.view

    #---------------------------------------------------------------------------
    #  Returns the right-click context menu for an object:
    #---------------------------------------------------------------------------

    def get_menu ( self, object ):
        """ Returns the right-click context menu for an object.
        """
        return self.menu

    def get_background(self, object) :
        background = self.background
        if isinstance(background, basestring) :
            background = getattr(object, background, background)
        return background

    def get_foreground(self, object) :
        foreground = self.foreground
        if isinstance(foreground, basestring) :
            foreground = getattr(object, foreground, foreground)
        return foreground

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be renamed:
    #---------------------------------------------------------------------------

    def can_rename ( self, object ):
        """ Returns whether the object's children can be renamed.
        """
        return self.rename

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be renamed:
    #---------------------------------------------------------------------------

    def can_rename_me ( self, object ):
        """ Returns whether the object can be renamed.
        """
        return self.rename_me

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be copied:
    #---------------------------------------------------------------------------

    def can_copy ( self, object ):
        """ Returns whether the object's children can be copied.
        """
        return self.copy

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def can_delete ( self, object ):
        """ Returns whether the object's children can be deleted.
        """
        return self.delete

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be deleted:
    #---------------------------------------------------------------------------

    def can_delete_me ( self, object ):
        """ Returns whether the object can be deleted.
        """
        return self.delete_me

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be inserted (or just
    #  appended):
    #---------------------------------------------------------------------------

    def can_insert ( self, object ):
        """ Returns whether the object's children can be inserted (vs.
        appended).
        """
        return self.insert

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-opened:
    #---------------------------------------------------------------------------

    def can_auto_open ( self, object ):
        """ Returns whether the object's children should be automatically
        opened.
        """
        return self.auto_open

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-closed:
    #---------------------------------------------------------------------------

    def can_auto_close ( self, object ):
        """ Returns whether the object's children should be automatically
        closed.
        """
        return self.auto_close

    #---------------------------------------------------------------------------
    #  Returns whether or not this is the node that should handle a specified
    #  object:
    #---------------------------------------------------------------------------

    def is_node_for ( self, object ):
        """ Returns whether this is the node that handles a specified object.
        """
        return (isinstance( object, self.node_for_class ) or
                object.has_traits_interface( *self.node_for_interface ))

    #---------------------------------------------------------------------------
    #  Returns whether a given 'add_object' can be added to an object:
    #---------------------------------------------------------------------------

    def can_add ( self, object, add_object ):
        """ Returns whether a given object is droppable on the node.
        """
        klass = self._class_for( add_object )
        if self.is_addable( klass ):
            return True

        for item in self.move:
            if type( item ) in SequenceTypes:
                item = item[0]
            if issubclass( klass, item ):
                return True

        return False

    #---------------------------------------------------------------------------
    #  Returns the list of classes that can be added to the object:
    #---------------------------------------------------------------------------

    def get_add ( self, object ):
        """ Returns the list of classes that can be added to the object.
        """
        return self.add

    #---------------------------------------------------------------------------
    #  Returns the 'draggable' version of a specified object:
    #---------------------------------------------------------------------------

    def get_drag_object ( self, object ):
        """ Returns a draggable version of a specified object.
        """
        return object

    #---------------------------------------------------------------------------
    #  Returns a droppable version of a specified object:
    #---------------------------------------------------------------------------

    def drop_object ( self, object, dropped_object ):
        """ Returns a droppable version of a specified object.
        """
        klass = self._class_for( dropped_object )
        if self.is_addable( klass ):
            return dropped_object

        for item in self.move:
            if type( item ) in SequenceTypes:
                if issubclass( klass, item[0] ):
                    return item[1]( object, dropped_object )
            elif issubclass( klass, item ):
                return dropped_object

        return dropped_object

    #---------------------------------------------------------------------------
    #  Handles an object being selected:
    #---------------------------------------------------------------------------

    def select ( self, object ):
        """ Handles an object being selected.
        """
        if self.on_select is not None:
            self.on_select( object )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Handles an object being clicked:
    #---------------------------------------------------------------------------

    def click ( self, object ):
        """ Handles an object being clicked.
        """
        if self.on_click is not None:
            self.on_click( object )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Handles an object being double-clicked:
    #---------------------------------------------------------------------------

    def dclick ( self, object ):
        """ Handles an object being double-clicked.
        """
        if self.on_dclick is not None:
            self.on_dclick( object )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Handles an object being activated:
    #---------------------------------------------------------------------------

    def activated ( self, object ):
        """ Handles an object being activated.
        """
        if self.on_activated is not None:
            self.on_activated( object )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Returns whether or not a specified object class can be added to the node:
    #---------------------------------------------------------------------------

    def is_addable ( self, klass ):
        """ Returns whether a specified object class can be added to the node.
        """
        for item in self.add:
            if type( item ) in SequenceTypes:
                item = item[0]

            if issubclass( klass, item ):
                return True

        return False

    #---------------------------------------------------------------------------
    #  Returns the class of an object:
    #---------------------------------------------------------------------------

    def _class_for ( self, object ):
        """ Returns the class of an object.
        """
        if isinstance( object, type ):
            return object

        return object.__class__

#-------------------------------------------------------------------------------
#  'ITreeNode' class
#-------------------------------------------------------------------------------

class ITreeNode ( Interface ):

    def allows_children ( self ):
        """ Returns whether this object can have children.
        """

    def has_children ( self ):
        """ Returns whether the object has children.
        """

    def get_children ( self ):
        """ Gets the object's children.
        """

    def get_children_id ( self ):
        """ Gets the object's children identifier.
        """

    def append_child ( self, child ):
        """ Appends a child to the object's children.
        """

    def insert_child ( self, index, child ):
        """ Inserts a child into the object's children.
        """

    def confirm_delete ( self ):
        """ Checks whether a specified object can be deleted.

        Returns
        -------
        * **True** if the object should be deleted with no further prompting.
        * **False** if the object should not be deleted.
        * Anything else: Caller should take its default action (which might
          include prompting the user to confirm deletion).
        """

    def delete_child ( self, index ):
        """ Deletes a child at a specified index from the object's children.
        """

    def when_children_replaced ( self, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
            specified object.
        """

    def when_children_changed ( self, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
            specified object.
        """

    def get_label ( self ):
        """ Gets the label to display for a specified object.
        """

    def set_label ( self, label ):
        """ Sets the label for a specified object.
        """

    def when_label_changed ( self, listener, remove ):
        """ Sets up or removes a listener for the label being changed on a
            specified object.
        """

    def get_column_labels(self, object):
        """ Get the labels for any columns that have been defined.
        """

    def when_column_labels_change(self, object, listener, remove):
        """ Sets up or removes a listener for the column labels being changed on
        a specified object.

        This will fire when either the list is reassigned or when it is
        modified. I.e., it listens both to the trait change event and the
        trait_items change event. Implement the listener appropriately to handle
        either case.
        """

    def get_tooltip ( self ):
        """ Gets the tooltip to display for a specified object.
        """

    def get_icon ( self, is_expanded ):
        """ Returns the icon for a specified object.
        """

    def get_icon_path ( self ):
        """ Returns the path used to locate an object's icon.
        """

    def get_name ( self ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """

    def get_view ( self ):
        """ Gets the view to use when editing an object.
        """

    def get_menu ( self ):
        """ Returns the right-click context menu for an object.
        """

    def can_rename ( self ):
        """ Returns whether the object's children can be renamed.
        """

    def can_rename_me ( self ):
        """ Returns whether the object can be renamed.
        """

    def can_copy ( self ):
        """ Returns whether the object's children can be copied.
        """

    def can_delete ( self ):
        """ Returns whether the object's children can be deleted.
        """

    def can_delete_me ( self ):
        """ Returns whether the object can be deleted.
        """

    def can_insert ( self ):
        """ Returns whether the object's children can be inserted (vs.
            appended).
        """

    def can_auto_open ( self ):
        """ Returns whether the object's children should be automatically
            opened.
        """

    def can_auto_close ( self ):
        """ Returns whether the object's children should be automatically
            closed.
        """

    def can_add ( self, add_object ):
        """ Returns whether a given object is droppable on the node.
        """

    def get_add ( self ):
        """ Returns the list of classes that can be added to the object.
        """

    def get_drag_object ( self ):
        """ Returns a draggable version of a specified object.
        """

    def drop_object ( self, dropped_object ):
        """ Returns a droppable version of a specified object.
        """

    def select ( self ):
        """ Handles an object being selected.
        """

    def click ( self ):
        """ Handles an object being clicked.
        """

    def dclick ( self ):
        """ Handles an object being double-clicked.
        """

    def activated ( self ):
        """ Handles an object being activated.
        """

#-------------------------------------------------------------------------------
#  'ITreeNodeAdapter' class
#-------------------------------------------------------------------------------

class ITreeNodeAdapter ( Adapter ):
    """ Abstract base class for an adapter that implements the ITreeNode
        interface.

        Usage:

        1. Create a subclass of ITreeNodeAdapter.
        2. Add an 'adapts( xxx_class, ITreeNode )' declaration (usually placed
           right after the 'class' statement) to define what class (or classes)
           this is an ITreeNode adapter for.
        3. Override any of the following methods as necessary, using the
           'self.adaptee' trait to access the adapted object if needed.

       Note: This base class implements all of the ITreeNode interface methods,
       but does not necessarily provide useful implementations for all of the
       methods. It allows you to get a new adapter class up and running quickly,
       but you should carefully review your final adapter implementation class
       to make sure it behaves correctly in your application.
    """

    def allows_children ( self ):
        """ Returns whether this object can have children.
        """
        return False

    def has_children ( self ):
        """ Returns whether the object has children.
        """
        return False

    def get_children ( self ):
        """ Gets the object's children.
        """
        return []

    def get_children_id ( self ):
        """ Gets the object's children identifier.
        """
        return ''

    def append_child ( self, child ):
        """ Appends a child to the object's children.
        """
        pass

    def insert_child ( self, index, child ):
        """ Inserts a child into the object's children.
        """
        pass

    def confirm_delete ( self ):
        """ Checks whether a specified object can be deleted.

        Returns
        -------
        * **True** if the object should be deleted with no further prompting.
        * **False** if the object should not be deleted.
        * Anything else: Caller should take its default action (which might
          include prompting the user to confirm deletion).
        """
        return False

    def delete_child ( self, index ):
        """ Deletes a child at a specified index from the object's children.
        """
        pass

    def when_children_replaced ( self, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
            specified object.
        """
        pass

    def when_children_changed ( self, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
            specified object.
        """
        pass

    def get_label ( self ):
        """ Gets the label to display for a specified object.
        """
        return 'No label specified'

    def set_label ( self, label ):
        """ Sets the label for a specified object.
        """
        pass

    def when_label_changed ( self, listener, remove ):
        """ Sets up or removes a listener for the label being changed on a
            specified object.
        """
        pass

    def get_column_labels(self):
        """ Get the labels for any columns that have been defined.
        """
        return []

    def when_column_labels_change(self, listener, remove):
        """ Sets up or removes a listener for the column labels being changed on
        a specified object.

        This will fire when either the list is reassigned or when it is
        modified. I.e., it listens both to the trait change event and the
        trait_items change event. Implement the listener appropriately to handle
        either case.
        """
        pass

    def get_tooltip ( self ):
        """ Gets the tooltip to display for a specified object.
        """
        return ''

    def get_icon ( self, is_expanded ):
        """ Returns the icon for a specified object.
        """
        return '<item>'

    def get_icon_path ( self ):
        """ Returns the path used to locate an object's icon.
        """
        return ''

    def get_name ( self ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """
        return ''

    def get_view ( self ):
        """ Gets the view to use when editing an object.
        """
        return None

    def get_menu ( self ):
        """ Returns the right-click context menu for an object.
        """
        return None

    def get_background ( self ):
        """ Returns the background for object
        """
        return None

    def get_foreground ( self ):
        """ Returns the foreground for object
        """
        return None

    def can_rename ( self ):
        """ Returns whether the object's children can be renamed.
        """
        return False

    def can_rename_me ( self ):
        """ Returns whether the object can be renamed.
        """
        return False

    def can_copy ( self ):
        """ Returns whether the object's children can be copied.
        """
        return False

    def can_delete ( self ):
        """ Returns whether the object's children can be deleted.
        """
        return False

    def can_delete_me ( self ):
        """ Returns whether the object can be deleted.
        """
        return False

    def can_insert ( self ):
        """ Returns whether the object's children can be inserted (vs.
            appended).
        """
        return False

    def can_auto_open ( self ):
        """ Returns whether the object's children should be automatically
            opened.
        """
        return False

    def can_auto_close ( self ):
        """ Returns whether the object's children should be automatically
            closed.
        """
        return False

    def can_add ( self, add_object ):
        """ Returns whether a given object is droppable on the node.
        """
        return False

    def get_add ( self ):
        """ Returns the list of classes that can be added to the object.
        """
        return []

    def get_drag_object ( self ):
        """ Returns a draggable version of a specified object.
        """
        return self.adaptee

    def drop_object ( self, dropped_object ):
        """ Returns a droppable version of a specified object.
        """
        return dropped_object

    def select ( self ):
        """ Handles an object being selected.
        """
        pass

    def click ( self ):
        """ Handles an object being clicked.
        """
        pass

    def dclick ( self ):
        """ Handles an object being double-clicked.
        """
        pass

    def activated ( self ):
        """ Handles an object being activated.
        """
        pass

#-------------------------------------------------------------------------------
#  'ITreeNodeAdapterBridge' class
#-------------------------------------------------------------------------------

class ITreeNodeAdapterBridge ( HasPrivateTraits ):
    """ Private class for use by a toolkit-specific implementation of the
        TreeEditor to allow bridging the TreeNode interface used by the editor
        to the ITreeNode interface used by object adapters.
    """

    # The ITreeNode adapter being bridged:
    adapter = AdaptedTo( ITreeNode )

    #-- TreeNode implementation ------------------------------------------------

    def allows_children ( self, object ):
        """ Returns whether this object can have children.
        """
        return self.adapter.allows_children()

    def has_children ( self, object ):
        """ Returns whether the object has children.
        """
        return self.adapter.has_children()

    def get_children ( self, object ):
        """ Gets the object's children.
        """
        return self.adapter.get_children()

    def get_children_id ( self, object ):
        """ Gets the object's children identifier.
        """
        return self.adapter.get_children_id()

    def append_child ( self, object, child ):
        """ Appends a child to the object's children.
        """
        return self.adapter.append_child( child )

    def insert_child ( self, object, index, child ):
        """ Inserts a child into the object's children.
        """
        return self.adapter.insert_child( index, child )

    def confirm_delete ( self, object ):
        """ Checks whether a specified object can be deleted.

        Returns
        -------
        * **True** if the object should be deleted with no further prompting.
        * **False** if the object should not be deleted.
        * Anything else: Caller should take its default action (which might
          include prompting the user to confirm deletion).
        """
        return self.adapter.confirm_delete()

    def delete_child ( self, object, index ):
        """ Deletes a child at a specified index from the object's children.
        """
        return self.adapter.delete_child( index )

    def when_children_replaced ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
            specified object.
        """
        return self.adapter.when_children_replaced( listener, remove )

    def when_children_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
            specified object.
        """
        return self.adapter.when_children_changed( listener, remove )

    def get_label ( self, object ):
        """ Gets the label to display for a specified object.
        """
        return self.adapter.get_label()

    def set_label ( self, object, label ):
        """ Sets the label for a specified object.
        """
        return self.adapter.set_label( label )

    def when_label_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for the label being changed on a
            specified object.
        """
        return self.adapter.when_label_changed( listener, remove )

    def get_column_labels(self, object):
        """ Get the labels for any columns that have been defined.
        """
        return self.adapter.get_column_labels()

    def when_column_labels_change(self, object, listener, remove):
        """ Sets up or removes a listener for the column labels being changed on
        a specified object.

        This will fire when either the list is reassigned or when it is
        modified. I.e., it listens both to the trait change event and the
        trait_items change event. Implement the listener appropriately to handle
        either case.
        """
        return self.adapter.when_column_labels_change(listener, remove)

    def get_tooltip ( self, object ):
        """ Gets the tooltip to display for a specified object.
        """
        return self.adapter.get_tooltip()

    def get_icon ( self, object, is_expanded ):
        """ Returns the icon for a specified object.
        """
        return self.adapter.get_icon( is_expanded )

    def get_icon_path ( self, object ):
        """ Returns the path used to locate an object's icon.
        """
        return self.adapter.get_icon_path()

    def get_name ( self, object ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """
        return self.adapter.get_name()

    def get_view ( self, object ):
        """ Gets the view to use when editing an object.
        """
        return self.adapter.get_view()

    def get_menu ( self, object ):
        """ Returns the right-click context menu for an object.
        """
        return self.adapter.get_menu()

    def get_background ( self, object ):
        """ Returns the background for object
        """
        return self.adapter.get_background()

    def get_foreground ( self, object ):
        """ Returns the foreground for object
        """
        return self.adapter.get_foreground()

    def can_rename ( self, object ):
        """ Returns whether the object's children can be renamed.
        """
        return self.adapter.can_rename()

    def can_rename_me ( self, object ):
        """ Returns whether the object can be renamed.
        """
        return self.adapter.can_rename_me()

    def can_copy ( self, object ):
        """ Returns whether the object's children can be copied.
        """
        return self.adapter.can_copy()

    def can_delete ( self, object ):
        """ Returns whether the object's children can be deleted.
        """
        return self.adapter.can_delete()

    def can_delete_me ( self, object ):
        """ Returns whether the object can be deleted.
        """
        return self.adapter.can_delete_me()

    def can_insert ( self, object ):
        """ Returns whether the object's children can be inserted (vs.
            appended).
        """
        return self.adapter.can_insert()

    def can_auto_open ( self, object ):
        """ Returns whether the object's children should be automatically
            opened.
        """
        return self.adapter.can_auto_open()

    def can_auto_close ( self, object ):
        """ Returns whether the object's children should be automatically
            closed.
        """
        return self.adapter.can_auto_close()

    def can_add ( self, object, add_object ):
        """ Returns whether a given object is droppable on the node.
        """
        return self.adapter.can_add( add_object )

    def get_add ( self, object ):
        """ Returns the list of classes that can be added to the object.
        """
        return self.adapter.get_add()

    def get_drag_object ( self, object ):
        """ Returns a draggable version of a specified object.
        """
        return self.adapter.get_drag_object()

    def drop_object ( self, object, dropped_object ):
        """ Returns a droppable version of a specified object.
        """
        return self.adapter.drop_object( dropped_object )

    def select ( self, object ):
        """ Handles an object being selected.
        """
        return self.adapter.select()

    def click ( self, object ):
        """ Handles an object being clicked.
        """
        return self.adapter.click()

    def dclick ( self, object ):
        """ Handles an object being double-clicked.
        """
        return self.adapter.dclick()

    def activated ( self, object ):
        """ Handles an object being activated.
        """
        return self.adapter.activated()


# FIXME RTK: add the column_labels API to the following TreeNodes, too.


#-------------------------------------------------------------------------------
#  'ObjectTreeNode' class
#-------------------------------------------------------------------------------

class ObjectTreeNode ( TreeNode ):

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def allows_children ( self, object ):
        """ Returns whether this object can have children.
        """
        return object.tno_allows_children( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def has_children ( self, object ):
        """ Returns whether the object has children.
        """
        return object.tno_has_children( self )

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def get_children ( self, object ):
        """ Gets the object's children.
        """
        return object.tno_get_children( self )

    #---------------------------------------------------------------------------
    #  Gets the object's children identifier:
    #---------------------------------------------------------------------------

    def get_children_id ( self, object ):
        """ Gets the object's children identifier.
        """
        return object.tno_get_children_id( self )

    #---------------------------------------------------------------------------
    #  Appends a child to the object's children:
    #---------------------------------------------------------------------------

    def append_child ( self, object, child ):
        """ Appends a child to the object's children.
        """
        return object.tno_append_child( self, child )

    #---------------------------------------------------------------------------
    #  Inserts a child into the object's children:
    #---------------------------------------------------------------------------

    def insert_child ( self, object, index, child ):
        """ Inserts a child into the object's children.
        """
        return object.tno_insert_child( self, index, child )

    #---------------------------------------------------------------------------
    #  Confirms that a specified object can be deleted or not:
    #  Result = True:  Delete object with no further prompting
    #         = False: Do not delete object
    #         = other: Take default action (may prompt user to confirm delete)
    #---------------------------------------------------------------------------

    def confirm_delete ( self, object ):
        """ Checks whether a specified object can be deleted.

        Returns
        -------
        * **True** if the object should be deleted with no further prompting.
        * **False** if the object should not be deleted.
        * Anything else: Caller should take its default action (which might
          include prompting the user to confirm deletion).
        """
        return object.tno_confirm_delete( self )

    #---------------------------------------------------------------------------
    #  Deletes a child at a specified index from the object's children:
    #---------------------------------------------------------------------------

    def delete_child ( self, object, index ):
        """ Deletes a child at a specified index from the object's children.
        """
        return object.tno_delete_child( self, index )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children replaced' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def when_children_replaced ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
            specified object.
        """
        return object.tno_when_children_replaced( self, listener, remove )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children changed' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def when_children_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
            specified object.
        """
        return object.tno_when_children_changed( self, listener, remove )

    #---------------------------------------------------------------------------
    #  Gets the label to display for a specified object:
    #---------------------------------------------------------------------------

    def get_label ( self, object ):
        """ Gets the label to display for a specified object.
        """
        return object.tno_get_label( self )

    #---------------------------------------------------------------------------
    #  Sets the label for a specified object:
    #---------------------------------------------------------------------------

    def set_label ( self, object, label ):
        """ Sets the label for a specified object.
        """
        return object.tno_set_label( self, label )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'label changed' on a specified object:
    #---------------------------------------------------------------------------

    def when_label_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for the label being changed on a
            specified object.
        """
        return object.tno_when_label_changed( self, listener, remove )

    #---------------------------------------------------------------------------
    #  Gets the tooltip to display for a specified object:
    #---------------------------------------------------------------------------

    def get_tooltip ( self, object ):
        """ Gets the tooltip to display for a specified object.
        """
        return object.tno_get_tooltip( self )

    #---------------------------------------------------------------------------
    #  Returns the icon for a specified object:
    #---------------------------------------------------------------------------

    def get_icon ( self, object, is_expanded ):
        """ Returns the icon for a specified object.
        """
        return object.tno_get_icon( self, is_expanded )

    #---------------------------------------------------------------------------
    #  Returns the path used to locate an object's icon:
    #---------------------------------------------------------------------------

    def get_icon_path ( self, object ):
        """ Returns the path used to locate an object's icon.
        """
        return object.tno_get_icon_path( self )

    #---------------------------------------------------------------------------
    #  Returns the name to use when adding a new object instance (displayed in
    #  the 'New' submenu):
    #---------------------------------------------------------------------------

    def get_name ( self, object ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """
        return object.tno_get_name( self )

    #---------------------------------------------------------------------------
    #  Gets the View to use when editing an object:
    #---------------------------------------------------------------------------

    def get_view ( self, object ):
        """ Gets the view to use when editing an object.
        """
        return object.tno_get_view( self )

    #---------------------------------------------------------------------------
    #  Returns the right-click context menu for an object:
    #---------------------------------------------------------------------------

    def get_menu ( self, object ):
        """ Returns the right-click context menu for an object.
        """
        return object.tno_get_menu( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be renamed:
    #---------------------------------------------------------------------------

    def can_rename ( self, object ):
        """ Returns whether the object's children can be renamed.
        """
        return object.tno_can_rename( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be renamed:
    #---------------------------------------------------------------------------

    def can_rename_me ( self, object ):
        """ Returns whether the object can be renamed.
        """
        return object.tno_can_rename_me( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be copied:
    #---------------------------------------------------------------------------

    def can_copy ( self, object ):
        """ Returns whether the object's children can be copied.
        """
        return object.tno_can_copy( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def can_delete ( self, object ):
        """ Returns whether the object's children can be deleted.
        """
        return object.tno_can_delete( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be deleted:
    #---------------------------------------------------------------------------

    def can_delete_me ( self, object ):
        """ Returns whether the object can be deleted.
        """
        return object.tno_can_delete_me( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be inserted (or just
    #  appended):
    #---------------------------------------------------------------------------

    def can_insert ( self, object ):
        """ Returns whether the object's children can be inserted (vs.
        appended).
        """
        return object.tno_can_insert( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-opened:
    #---------------------------------------------------------------------------

    def can_auto_open ( self, object ):
        """ Returns whether the object's children should be automatically
            opened.
        """
        return object.tno_can_auto_open( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-closed:
    #---------------------------------------------------------------------------

    def can_auto_close ( self, object ):
        """ Returns whether the object's children should be automatically
            closed.
        """
        return object.tno_can_auto_close( self )

    #---------------------------------------------------------------------------
    #  Returns whether or not this is the node that should handle a specified
    #  object:
    #---------------------------------------------------------------------------

    def is_node_for ( self, object ):
        """ Returns whether this is the node that should handle a
            specified object.
        """
        if isinstance( object, TreeNodeObject ):
            return object.tno_is_node_for( self )

        return False

    #---------------------------------------------------------------------------
    #  Returns whether a given 'add_object' can be added to an object:
    #---------------------------------------------------------------------------

    def can_add ( self, object, add_object ):
        """ Returns whether a given object is droppable on the node.
        """
        return object.tno_can_add( self, add_object )

    #---------------------------------------------------------------------------
    #  Returns the list of classes that can be added to the object:
    #---------------------------------------------------------------------------

    def get_add ( self, object ):
        """ Returns the list of classes that can be added to the object.
        """
        return object.tno_get_add( self )

    #---------------------------------------------------------------------------
    #  Returns the 'draggable' version of a specified object:
    #---------------------------------------------------------------------------

    def get_drag_object ( self, object ):
        """ Returns a draggable version of a specified object.
        """
        return object.tno_get_drag_object( self )

    #---------------------------------------------------------------------------
    #  Returns a droppable version of a specified object:
    #---------------------------------------------------------------------------

    def drop_object ( self, object, dropped_object ):
        """ Returns a droppable version of a specified object.
        """
        return object.tno_drop_object( self, dropped_object )

    #---------------------------------------------------------------------------
    #  Handles an object being selected:
    #---------------------------------------------------------------------------

    def select ( self, object ):
        """ Handles an object being selected.
        """
        return object.tno_select( self )

    #---------------------------------------------------------------------------
    #  Handles an object being clicked:
    #---------------------------------------------------------------------------

    def click ( self, object ):
        """ Handles an object being clicked.
        """
        return object.tno_click( self )

    #---------------------------------------------------------------------------
    #  Handles an object being double-clicked:
    #---------------------------------------------------------------------------

    def dclick ( self, object ):
        """ Handles an object being double-clicked.
        """
        return object.tno_dclick( self )

    #---------------------------------------------------------------------------
    #  Handles an object being activated:
    #---------------------------------------------------------------------------

    def activated ( self, object ):
        """ Handles an object being activated.
        """
        return object.tno_activated( self )

#-------------------------------------------------------------------------------
#  'TreeNodeObject' class:
#-------------------------------------------------------------------------------

class TreeNodeObject ( HasPrivateTraits ):
    """ Represents the object that corresponds to a tree node.
    """

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def tno_allows_children ( self, node ):
        """ Returns whether this object allows children.
        """
        return (node.children != '')

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether this object has children.
        """
        return (len( self.tno_get_children( node ) ) > 0)

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        return getattr( self, node.children )

    #---------------------------------------------------------------------------
    #  Gets the object's children identifier:
    #---------------------------------------------------------------------------

    def tno_get_children_id ( self, node ):
        """ Gets the object's children identifier.
        """
        return node.children

    #---------------------------------------------------------------------------
    #  Appends a child to the object's children:
    #---------------------------------------------------------------------------

    def tno_append_child ( self, node, child ):
        """ Appends a child to the object's children.
        """
        getattr( self, node.children ).append( child )

    #---------------------------------------------------------------------------
    #  Inserts a child into the object's children:
    #---------------------------------------------------------------------------

    def tno_insert_child ( self, node, index, child ):
        """ Inserts a child into the object's children.
        """
        getattr( self, node.children )[ index: index ] = [ child ]

    #---------------------------------------------------------------------------
    #  Confirms that a specified object can be deleted or not:
    #  Result = True:  Delete object with no further prompting
    #         = False: Do not delete object
    #         = other: Take default action (may prompt user to confirm delete)
    #---------------------------------------------------------------------------

    def tno_confirm_delete ( self, node ):
        """ Checks whether a specified object can be deleted.

        Returns
        -------
        * **True** if the object should be deleted with no further prompting.
        * **False** if the object should not be deleted.
        * Anything else: Caller should take its default action (which might
          include prompting the user to confirm deletion).
        """
        return None

    #---------------------------------------------------------------------------
    #  Deletes a child at a specified index from the object's children:
    #---------------------------------------------------------------------------

    def tno_delete_child ( self, node, index ):
        """ Deletes a child at a specified index from the object's children.
        """
        del getattr( self, node.children )[ index ]

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children replaced' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def tno_when_children_replaced ( self, node, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
        specified object.
        """
        self.on_trait_change( listener, node.children, remove = remove,
                              dispatch = 'fast_ui' )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children changed' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def tno_when_children_changed ( self, node, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
        specified object.
        """
        self.on_trait_change( listener, node.children + '_items',
                              remove = remove, dispatch = 'fast_ui' )

    #---------------------------------------------------------------------------
    #  Gets the label to display for a specified object:
    #---------------------------------------------------------------------------

    def tno_get_label ( self, node ):
        """ Gets the label to display for a specified object.
        """
        label = node.label
        if label[:1] == '=':
            return label[1:]

        label = xgetattr( self, label )

        if node.formatter is None:
            return label

        return node.formatter( self, label )

    #---------------------------------------------------------------------------
    #  Sets the label for a specified node:
    #---------------------------------------------------------------------------

    def tno_set_label ( self, node, label ):
        """ Sets the label for a specified object.
        """
        label_name = node.label
        if label_name[:1] != '=':
            xsetattr( self, label_name, label )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'label changed' on a specified object:
    #---------------------------------------------------------------------------

    def tno_when_label_changed ( self, node, listener, remove ):
        """ Sets up or removes a listener for  the label being changed on a
        specified object.
        """
        label = node.label
        if label[:1] != '=':
            self.on_trait_change( listener, label, remove = remove,
                                  dispatch = 'ui' )

    #---------------------------------------------------------------------------
    #  Gets the tooltip to display for a specified object:
    #---------------------------------------------------------------------------

    def tno_get_tooltip ( self, node ):
        """ Gets the tooltip to display for a specified object.
        """
        tooltip = node.tooltip
        if tooltip == '':
            return tooltip

        if tooltip[:1] == '=':
            return tooltip[1:]

        tooltip = xgetattr( self, tooltip )

        if node.tooltip_formatter is None:
            return tooltip

        return node.tooltip_formatter( self, tooltip )

    #---------------------------------------------------------------------------
    #  Returns the icon for a specified object:
    #---------------------------------------------------------------------------

    def tno_get_icon ( self, node, is_expanded ):
        """ Returns the icon for a specified object.
        """
        if not self.tno_allows_children( node ):
            return node.icon_item

        if is_expanded:
            return node.icon_open

        return node.icon_group

    #---------------------------------------------------------------------------
    #  Returns the path used to locate an object's icon:
    #---------------------------------------------------------------------------

    def tno_get_icon_path ( self, node ):
        """ Returns the path used to locate an object's icon.
        """
        return node.icon_path

    #---------------------------------------------------------------------------
    #  Returns the name to use when adding a new object instance (displayed in
    #  the 'New' submenu):
    #---------------------------------------------------------------------------

    def tno_get_name ( self, node ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """
        return node.name

    #---------------------------------------------------------------------------
    #  Gets the View to use when editing an object:
    #---------------------------------------------------------------------------

    def tno_get_view ( self, node ):
        """ Gets the view to use when editing an object.
        """
        return node.view

    #---------------------------------------------------------------------------
    #  Returns the right-click context menu for an object:
    #---------------------------------------------------------------------------

    def tno_get_menu ( self, node ):
        """ Returns the right-click context menu for an object.
        """
        return node.menu

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be renamed:
    #---------------------------------------------------------------------------

    def tno_can_rename ( self, node ):
        """ Returns whether the object's children can be renamed.
        """
        return node.rename

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be renamed:
    #---------------------------------------------------------------------------

    def tno_can_rename_me ( self, node ):
        """ Returns whether the object can be renamed.
        """
        return node.rename_me

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be copied:
    #---------------------------------------------------------------------------

    def tno_can_copy ( self, node ):
        """ Returns whether the object's children can be copied.
        """
        return node.copy

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def tno_can_delete ( self, node ):
        """ Returns whether the object's children can be deleted.
        """
        return node.delete

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be deleted:
    #---------------------------------------------------------------------------

    def tno_can_delete_me ( self, node ):
        """ Returns whether the object can be deleted.
        """
        return node.delete_me

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be inserted (or just
    #  appended):
    #---------------------------------------------------------------------------

    def tno_can_insert ( self, node ):
        """ Returns whether the object's children can be inserted (vs.
        appended).
        """
        return node.insert

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-opened:
    #---------------------------------------------------------------------------

    def tno_can_auto_open ( self, node ):
        """ Returns whether the object's children should be automatically
        opened.
        """
        return node.auto_open

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-closed:
    #---------------------------------------------------------------------------

    def tno_can_auto_close ( self, node ):
        """ Returns whether the object's children should be automatically
        closed.
        """
        return node.auto_close

    #---------------------------------------------------------------------------
    #  Returns whether or not this is the node that should handle a specified
    #  object:
    #---------------------------------------------------------------------------

    def tno_is_node_for ( self, node ):
        """ Returns whether this is the node that should handle a
            specified object.
        """
        return (isinstance( self, node.node_for_class ) or
                self.has_traits_interface( *node.node_for_interface ))

    #---------------------------------------------------------------------------
    #  Returns whether a given 'add_object' can be added to an object:
    #---------------------------------------------------------------------------

    def tno_can_add ( self, node, add_object ):
        """ Returns whether a given object is droppable on the node.
        """
        klass = node._class_for( add_object )
        if node.is_addable( klass ):
            return True

        for item in node.move:
            if type( item ) in SequenceTypes:
                item = item[0]
            if issubclass( klass, item ):
                return True

        return False

    #---------------------------------------------------------------------------
    #  Returns the list of classes that can be added to the object:
    #---------------------------------------------------------------------------

    def tno_get_add ( self, node ):
        """ Returns the list of classes that can be added to the object.
        """
        return node.add

    #---------------------------------------------------------------------------
    #  Returns the 'draggable' version of a specified object:
    #---------------------------------------------------------------------------

    def tno_get_drag_object ( self, node ):
        """ Returns a draggable version of a specified object.
        """
        return self

    #---------------------------------------------------------------------------
    #  Returns a droppable version of a specified object:
    #---------------------------------------------------------------------------

    def tno_drop_object ( self, node, dropped_object ):
        """ Returns a droppable version of a specified object.
        """
        if node.is_addable( dropped_object ):
            return dropped_object

        for item in node.move:
            if type( item ) in SequenceTypes:
                if isinstance( dropped_object, item[0] ):
                    return item[1]( self, dropped_object )
            else:
                if isinstance( dropped_object, item ):
                    return dropped_object

    #---------------------------------------------------------------------------
    #  Handles an object being selected:
    #---------------------------------------------------------------------------

    def tno_select ( self, node ):
        """ Handles an object being selected.
        """
        if node.on_select is not None:
            node.on_select( self )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Handles an object being clicked:
    #---------------------------------------------------------------------------

    def tno_click ( self, node ):
        """ Handles an object being clicked.
        """
        if node.on_click is not None:
            node.on_click( self )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Handles an object being double-clicked:
    #---------------------------------------------------------------------------

    def tno_dclick ( self, node ):
        """ Handles an object being double-clicked.
        """
        if node.on_dclick is not None:
            node.on_dclick( self )
            return None

        return True

    #---------------------------------------------------------------------------
    #  Handles an object being activated:
    #---------------------------------------------------------------------------

    def tno_activated ( self, node ):
        """ Handles an object being activated.
        """
        if node.on_activated is not None:
            node.on_activated( self )
            return None

        return True

#-------------------------------------------------------------------------------
#  'MultiTreeNode' object:
#-------------------------------------------------------------------------------

class MultiTreeNode ( TreeNode ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # TreeNode that applies to the base object itself
    root_node = Instance( TreeNode )

    # List of TreeNodes (one for each sub-item list)
    nodes = List( TreeNode )

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def allows_children ( self, object ):
        """ Returns whether this object can have children (True for this
        class).
        """
        return True

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def has_children ( self, object ):
        """ Returns whether this object has children (True for this class).
        """
        return True

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def get_children ( self, object ):
        """ Gets the object's children.
        """
        return [ ( object, node ) for node in self.nodes ]

    #---------------------------------------------------------------------------
    #  Gets the object's children identifier:
    #---------------------------------------------------------------------------

    def get_children_id ( self, object ):
        """ Gets the object's children identifier.
        """
        return ''

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children replaced' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def when_children_replaced ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
        specified object.
        """
        pass

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children changed' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def when_children_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
        specified object.
        """
        pass

    #---------------------------------------------------------------------------
    #  Gets the label to display for a specified object:
    #---------------------------------------------------------------------------

    def get_label ( self, object ):
        """ Gets the label to display for a specified object.
        """
        return self.root_node.get_label( object )

    #---------------------------------------------------------------------------
    #  Sets the label for a specified object:
    #---------------------------------------------------------------------------

    def set_label ( self, object, label ):
        """ Sets the label for a specified object.
        """
        return self.root_node.set_label( object, label )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'label changed' on a specified object:
    #---------------------------------------------------------------------------

    def when_label_changed ( self, object, listener, remove ):
        """ Sets up or removes a listener for the label being changed on a
        specified object.
        """
        return self.root_node.when_label_changed( object, listener, remove )

    #---------------------------------------------------------------------------
    #  Returns the icon for a specified object:
    #---------------------------------------------------------------------------

    def get_icon ( self, object, is_expanded ):
        """ Returns the icon for a specified object.
        """
        return self.root_node.get_icon( object, is_expanded )

    #---------------------------------------------------------------------------
    #  Returns the path used to locate an object's icon:
    #---------------------------------------------------------------------------

    def get_icon_path ( self, object ):
        """ Returns the path used to locate an object's icon.
        """
        return self.root_node.get_icon_path( object )

    #---------------------------------------------------------------------------
    #  Returns the name to use when adding a new object instance (displayed in
    #  the 'New' submenu):
    #---------------------------------------------------------------------------

    def get_name ( self, object ):
        """ Returns the name to use when adding a new object instance
            (displayed in the "New" submenu).
        """
        return self.root_node.get_name( object )

    #---------------------------------------------------------------------------
    #  Gets the View to use when editing an object:
    #---------------------------------------------------------------------------

    def get_view ( self, object ):
        """ Gets the view to use when editing an object.
        """
        return self.root_node.get_view( object )

    #---------------------------------------------------------------------------
    #  Returns the right-click context menu for an object:
    #---------------------------------------------------------------------------

    def get_menu ( self, object ):
        """ Returns the right-click context menu for an object.
        """
        return self.root_node.get_menu( object )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be renamed:
    #---------------------------------------------------------------------------

    def can_rename ( self, object ):
        """ Returns whether the object's children can be renamed (False for
        this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be renamed:
    #---------------------------------------------------------------------------

    def can_rename_me ( self, object ):
        """ Returns whether the object can be renamed (False for this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be copied:
    #---------------------------------------------------------------------------

    def can_copy ( self, object ):
        """ Returns whether the object's children can be copied.
        """
        return self.root_node.can_copy( object )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def can_delete ( self, object ):
        """ Returns whether the object's children can be deleted (False for
        this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object can be deleted:
    #---------------------------------------------------------------------------

    def can_delete_me ( self, object ):
        """ Returns whether the object can be deleted (True for this class).
        """
        return True

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be inserted (or just
    #  appended):
    #---------------------------------------------------------------------------

    def can_insert ( self, object ):
        """ Returns whether the object's children can be inserted (False,
        meaning that children are appended, for this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-opened:
    #---------------------------------------------------------------------------

    def can_auto_open ( self, object ):
        """ Returns whether the object's children should be automatically
        opened.
        """
        return self.root_node.can_auto_open( object )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children should be auto-closed:
    #---------------------------------------------------------------------------

    def can_auto_close ( self, object ):
        """ Returns whether the object's children should be automatically
        closed.
        """
        return self.root_node.can_auto_close( object )

    #---------------------------------------------------------------------------
    #  Returns whether a given 'add_object' can be added to an object:
    #---------------------------------------------------------------------------

    def can_add ( self, object, add_object ):
        """ Returns whether a given object is droppable on the node (False for
        this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns the list of classes that can be added to the object:
    #---------------------------------------------------------------------------

    def get_add ( self, object ):
        """ Returns the list of classes that can be added to the object.
        """
        return []

    #-------------------------------------------------------------------------------
    #  Returns the 'draggable' version of a specified object:
    #-------------------------------------------------------------------------------

    def get_drag_object ( self, object ):
        """ Returns a draggable version of a specified object.
        """
        return self.root_node.get_drag_object( object )

    #---------------------------------------------------------------------------
    #  Returns a droppable version of a specified object:
    #---------------------------------------------------------------------------

    def drop_object ( self, object, dropped_object ):
        """ Returns a droppable version of a specified object.
        """
        return self.root_node.drop_object( object, dropped_object )

    #---------------------------------------------------------------------------
    #  Handles an object being selected:
    #---------------------------------------------------------------------------

    def select ( self, object ):
        """ Handles an object being selected.
        """
        return self.root_node.select( object )

    #---------------------------------------------------------------------------
    #  Handles an object being clicked:
    #---------------------------------------------------------------------------

    def click ( self, object ):
        """ Handles an object being clicked.
        """
        return self.root_node.click( object )

    #---------------------------------------------------------------------------
    #  Handles an object being double-clicked:
    #---------------------------------------------------------------------------

    def dclick ( self, object ):
        """ Handles an object being double-clicked.
        """
        return self.root_node.dclick( object )

    #---------------------------------------------------------------------------
    #  Handles an object being activated:
    #---------------------------------------------------------------------------

    def activated ( self, object ):
        """ Handles an object being activated.
        """
        return self.root_node.activated( object )


########NEW FILE########
__FILENAME__ = ui
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the UI class used to represent an active traits-based user
    interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import shelve
import os

from traits.api import (Any, Bool, Callable, DictStrAny, Event, HasPrivateTraits,
    Instance, Int, List, Property, Str, TraitError, on_trait_change,
    property_depends_on)

from traits.trait_base import traits_home, is_str

from .editor import Editor

from .view_elements import ViewElements

from .handler import Handler, ViewHandler

from .toolkit import toolkit

from .ui_info import UIInfo

from .item import Item

from .group import Group, ShadowGroup

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# List of **kind** types for views that must have a **parent** window specified
kind_must_have_parent = ( 'panel', 'subpanel' )

#-------------------------------------------------------------------------------
#  'UI' class:
#-------------------------------------------------------------------------------

class UI ( HasPrivateTraits ):
    """ Information about the user interface for a View.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The ViewElements object from which this UI resolves Include items
    view_elements = Instance( ViewElements )

    # Context objects that the UI is editing
    context = DictStrAny

    # Handler object used for event handling
    handler = Instance( Handler )

    # View template used to construct the user interface
    view = Instance( 'traitsui.view.View' )

    # Panel or dialog associated with the user interface
    control = Any

    # The parent UI (if any) of this UI
    parent = Instance( 'UI' )

    # Toolkit-specific object that "owns" **control**
    owner = Any

    # UIInfo object containing context or editor objects
    info = Instance( UIInfo )

    # Result from a modal or wizard dialog:
    result = Bool( False )

    # Undo and Redo history
    history = Any

    # The KeyBindings object (if any) for this UI:
    key_bindings = Property # Instance( KeyBindings )

    # The unique ID for this UI for persistence
    id = Str

    # Have any modifications been made to UI contents?
    modified = Bool( False )

    # Event when the user interface has changed
    updated = Event( Bool )

    # Title of the dialog, if any
    title = Str

    # The ImageResource of the icon, if any
    icon = Any

    # Should the created UI have scroll bars?
    scrollable = Bool( False )

    # The number of currently pending editor error conditions
    errors = Int

    # The code used to rebuild an updated user interface
    rebuild = Callable

    # Set to True when the UI has finished being destroyed.
    destroyed = Bool( False )

    #-- Private Traits ---------------------------------------------------------

    # Original context when used with a modal dialog
    _context = DictStrAny

    # Copy of original context used for reverting changes
    _revert = DictStrAny

    # List of methods to call once the user interface is created
    _defined = List

    # List of (visible_when,Editor) pairs
    _visible = List

    # List of (enabled_when,Editor) pairs
    _enabled = List

    # List of (checked_when,Editor) pairs
    _checked = List

    # Search stack used while building a user interface
    _search = List

    # List of dispatchable Handler methods
    _dispatchers = List

    # List of editors used to build the user interface
    _editors = List

    # List of names bound to the **info** object
    _names = List

    # Index of currently the active group in the user interface
    _active_group = Int

    # List of top-level groups used to build the user interface
    _groups = Property
    _groups_cache = Any

    # Count of levels of nesting for undoable actions
    _undoable = Int( -1 )

    # Code used to rebuild an updated user interface
    _rebuild = Callable

    # The statusbar listeners that have been set up:
    _statusbar = List

    # Does the UI contain any scrollable widgets?
    #
    # The _scrollable trait is set correctly, but not used currently because
    # its value is arrived at too late to be of use in building the UI.
    _scrollable = Bool( False )

    # List of traits that are reset when a user interface is recycled
    # (i.e. rebuilt).
    recyclable_traits = [
        '_context', '_revert', '_defined', '_visible', '_enabled', '_checked',
        '_search', '_dispatchers', '_editors', '_names', '_active_group',
        '_undoable', '_rebuild', '_groups_cache'
    ]

    # List of additional traits that are discarded when a user interface is
    # disposed.
    disposable_traits = [
        'view_elements', 'info', 'handler', 'context', 'view', 'history',
        'key_bindings', 'icon', 'rebuild',
    ]

    #---------------------------------------------------------------------------
    #  Initializes the traits object:
    #---------------------------------------------------------------------------

    def traits_init ( self ):
        """ Initializes the traits object.
        """
        self.info = UIInfo( ui = self )
        self.handler.init_info( self.info )

    #---------------------------------------------------------------------------
    #  Creates a user interface from the associated View template object:
    #---------------------------------------------------------------------------

    def ui ( self, parent, kind ):
        """ Creates a user interface from the associated View template object.
        """
        if (parent is None) and (kind in kind_must_have_parent):
            kind = 'live'
        self.view.on_trait_change( self._updated_changed, 'updated',
                                   dispatch = 'ui' )
        self.rebuild = getattr( toolkit(), 'ui_' + kind )
        self.rebuild( self, parent )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of a user interface:
    #---------------------------------------------------------------------------

    def dispose ( self, result = None, abort = False ):
        """ Disposes of the contents of a user interface.
        """
        if result is not None:
            self.result = result

        # Only continue if the view has not already been disposed of:
        if self.control is not None:
            # Save the user preference information for the user interface:
            if not abort:
                self.save_prefs()

            # Finish disposing of the user interface:
            self.finish()

    #---------------------------------------------------------------------------
    #  Recycles the user interface prior to rebuilding it:
    #---------------------------------------------------------------------------

    def recycle ( self ):
        """ Recycles the user interface prior to rebuilding it.
        """
        # Reset all user interface editors:
        self.reset( destroy = False )

        # Discard any context object associated with the ui view control:
        self.control._object = None

        # Reset all recyclable traits:
        self.reset_traits( self.recyclable_traits )

    #---------------------------------------------------------------------------
    #  Finishes a user interface:
    #---------------------------------------------------------------------------

    def finish ( self ):
        """ Finishes disposing of a user interface.
        """

        # Reset the contents of the user interface
        self.reset( destroy = True )

        # Make sure that 'visible', 'enabled', and 'checked' handlers are not
        # called after the editor has been disposed:
        for object in self.context.values():
            object.on_trait_change( self._evaluate_when, remove = True )

        # Notify the handler that the view has been closed:
        self.handler.closed( self.info, self.result )

        # Clear the back-link from the UIInfo object to us:
        self.info.ui = None

        # Destroy the view control:
        self.control._object = None
        toolkit().destroy_control( self.control )
        self.control = None

        # Dispose of any KeyBindings object we reference:
        if self.key_bindings is not None:
            self.key_bindings.dispose()

        # Break the linkage to any objects in the context dictionary:
        self.context.clear()

        # Remove specified symbols from our dictionary to aid in clean-up:
        self.reset_traits( self.recyclable_traits )
        self.reset_traits( self.disposable_traits )

        self.destroyed = True

    #---------------------------------------------------------------------------
    #  Resets the contents of the user interface:
    #---------------------------------------------------------------------------

    def reset ( self, destroy = True ):
        """ Resets the contents of a user interface.
        """
        for editor in self._editors:
            if editor._ui is not None:
                # Propagate result to enclosed ui objects:
                editor._ui.result = self.result
            editor.dispose()

            # Zap the control. If there are pending events for the control in
            # the UI queue, the editor's '_update_editor' method will see that
            # the control is None and discard the update request:
            editor.control = None

        # Remove any statusbar listeners that have been set up:
        for object, handler, name in self._statusbar:
            object.on_trait_change( handler, name, remove = True )

        del self._statusbar[:]

        if destroy:
            toolkit().destroy_children( self.control )

        for dispatcher in self._dispatchers:
            dispatcher.remove()

    #---------------------------------------------------------------------------
    #  Find the definition of the specified Include object in the current user
    #  interface building context:
    #---------------------------------------------------------------------------

    def find ( self, include ):
        """ Finds the definition of the specified Include object in the current
            user interface building context.
        """
        context = self.context
        result  = None

        # Get the context 'object' (if available):
        if len( context ) == 1:
            object = context.values()[0]
        else:
            object = context.get( 'object' )

        # Try to use our ViewElements objects:
        ve = self.view_elements

        # If none specified, try to get it from the UI context:
        if (ve is None) and (object is not None):
            # Use the context object's ViewElements (if available):
            ve = object.trait_view_elements()

        # Ask the ViewElements to find the requested item for us:
        if ve is not None:
            result = ve.find( include.id, self._search )

        # If not found, then try to search the 'handler' and 'object' for a
        # method we can call that will define it:
        if result is None:
            handler = context.get( 'handler' )
            if handler is not None:
                method = getattr( handler, include.id, None )
                if callable( method ):
                    result = method()

            if (result is None) and (object is not None):
                method = getattr( object, include.id, None )
                if callable( method ):
                    result = method()

        return result

    #---------------------------------------------------------------------------
    #  Returns the current search stack level:
    #---------------------------------------------------------------------------

    def push_level ( self ):
        """ Returns the current search stack level.
        """
        return len( self._search )

    #---------------------------------------------------------------------------
    #  Restores a previously pushed search stack level:
    #---------------------------------------------------------------------------

    def pop_level ( self, level ):
        """ Restores a previously pushed search stack level.
        """
        del self._search[ : len( self._search ) - level ]

    #---------------------------------------------------------------------------
    #  Performs all post user interface creation processing:
    #---------------------------------------------------------------------------

    def prepare_ui ( self ):
        """ Performs all processing that occurs after the user interface is
            created.
        """
        # Invoke all of the editor 'name_defined' methods we've accumulated:
        info = self.info.set( initialized = False )
        for method in self._defined:
            method( info )

        # Then reset the list, since we don't need it anymore:
        del self._defined[:]

        # Synchronize all context traits with associated editor traits:
        self.sync_view()

        # Hook all keyboard events:
        toolkit().hook_events( self, self.control, 'keys', self.key_handler )

        # Hook all events if the handler is an extended 'ViewHandler':
        handler = self.handler
        if isinstance( handler, ViewHandler ):
            toolkit().hook_events( self, self.control )

        # Invoke the handler's 'init' method, and abort if it indicates failure:
        if handler.init( info ) == False:
            raise TraitError, 'User interface creation aborted'

        # For each Handler method whose name is of the form
        # 'object_name_changed', where 'object' is the name of an object in the
        # UI's 'context', create a trait notification handler that will call
        # the method whenever 'object's 'name' trait changes. Also invoke the
        # method immediately so initial user interface state can be correctly
        # set:
        context = self.context
        for name in self._each_trait_method( handler ):
            if name[-8:] == '_changed':
                prefix = name[:-8]
                col    = prefix.find( '_', 1 )
                if col >= 0:
                    object = context.get( prefix[ : col ] )
                    if object is not None:
                        method     = getattr( handler, name )
                        trait_name = prefix[ col + 1: ]
                        self._dispatchers.append( Dispatcher(
                             method, info, object, trait_name ) )
                        if object.base_trait( trait_name ).type != 'event':
                            method( info )

        # If there are any Editor object's whose 'visible', 'enabled' or
        # 'checked' state is controlled by a 'visible_when', 'enabled_when' or
        # 'checked_when' expression, set up an 'anytrait' changed notification
        # handler on each object in the 'context' that will cause the 'visible',
        # 'enabled' or 'checked' state of each affected Editor to be set. Also
        # trigger the evaluation immediately, so the visible, enabled or checked
        # state of each Editor can be correctly initialized:
        if (len( self._visible ) +
            len( self._enabled ) +
            len( self._checked )) > 0:
            for object in context.values():
                object.on_trait_change( self._evaluate_when, dispatch = 'ui' )
            self._do_evaluate_when(at_init=True)

        # Indicate that the user interface has been initialized:
        info.initialized = True

    #---------------------------------------------------------------------------
    #  Synchronize context object traits with view editor traits:
    #---------------------------------------------------------------------------

    def sync_view ( self ):
        """ Synchronize context object traits with view editor traits.
        """
        for name, object in self.context.items():
            self._sync_view( name, object, 'sync_to_view',   'from' )
            self._sync_view( name, object, 'sync_from_view', 'to'   )
            self._sync_view( name, object, 'sync_with_view', 'both' )

    def _sync_view ( self, name, object, metadata, direction ):
        info = self.info
        for trait_name, trait in object.traits( **{metadata: is_str} ).items():
            for sync in getattr( trait, metadata ).split( ',' ):
                try:
                    editor_id, editor_name = [ item.strip()
                                               for item in sync.split( '.' ) ]
                except:
                    raise TraitError( "The '%s' metadata for the '%s' trait in "
                        "the '%s' context object should be of the form: "
                        "'id1.trait1[,...,idn.traitn]." %
                        ( metadata, trait_name, name ) )

                editor = getattr( info, editor_id, None )
                if editor is not None:
                    editor.sync_value( '%s.%s' % ( name, trait_name ),
                                       editor_name, direction )
                else:
                    raise TraitError( "No editor with id = '%s' was found for "
                        "the '%s' metadata for the '%s' trait in the '%s' "
                        "context object." %
                        ( editor_id,metadata, trait_name, name ) )

    #---------------------------------------------------------------------------
    #  Gets the current value of a specified extended trait name:
    #---------------------------------------------------------------------------

    def get_extended_value ( self, name ):
        """ Gets the current value of a specified extended trait name.
        """
        names = name.split( '.' )
        if len( names ) > 1:
            value = self.context[ names[0] ]
            del names[0]
        else:
            value = self.context[ 'object' ]

        for name in names:
            value = getattr( value, name )

        return value

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the UI:
    #---------------------------------------------------------------------------

    def restore_prefs ( self ):
        """ Retrieves and restores any saved user preference information
        associated with the UI.
        """
        id = self.id
        if id != '':
            db = self.get_ui_db()
            if db is not None:
                try:
                    ui_prefs = db.get( id )
                    db.close()
                    return self.set_prefs( ui_prefs )
                except:
                    pass

        return None

    #---------------------------------------------------------------------------
    #  Restores user preference information for the UI:
    #---------------------------------------------------------------------------

    def set_prefs ( self, prefs ):
        """ Sets the values of user preferences for the UI.
        """
        if isinstance( prefs, dict ):
            info = self.info
            for name in self._names:
                editor = getattr( info, name, None )
                if isinstance( editor, Editor ) and (editor.ui is self):
                    editor_prefs = prefs.get( name )
                    if editor_prefs != None:
                        editor.restore_prefs( editor_prefs )

            if self.key_bindings is not None:
                key_bindings = prefs.get( '$' )
                if key_bindings is not None:
                    self.key_bindings.merge( key_bindings )

            return prefs.get( '' )

        return None

    #---------------------------------------------------------------------------
    #  Saves any user preference information associated with the UI:
    #---------------------------------------------------------------------------

    def save_prefs ( self, prefs = None ):
        """ Saves any user preference information associated with the UI.
        """
        if prefs is None:
            toolkit().save_window( self )
            return

        id = self.id
        if id != '':
            db = self.get_ui_db( mode = 'c' )
            if db is not None:
                db[ id ] = self.get_prefs( prefs )
                db.close()

    #---------------------------------------------------------------------------
    #  Gets the preferences to be saved for the user interface:
    #---------------------------------------------------------------------------

    def get_prefs ( self, prefs = None ):
        """ Gets the preferences to be saved for the user interface.
        """
        ui_prefs = {}
        if prefs is not None:
            ui_prefs[''] = prefs

        if self.key_bindings is not None:
            ui_prefs['$'] = self.key_bindings

        info = self.info
        for name in self._names:
            editor = getattr( info, name, None )
            if isinstance( editor, Editor ) and (editor.ui is self):
                prefs = editor.save_prefs()
                if prefs != None:
                    ui_prefs[ name ] = prefs

        return ui_prefs

    #---------------------------------------------------------------------------
    #  Gets a reference to the traits UI preference database:
    #---------------------------------------------------------------------------

    def get_ui_db ( self, mode = 'r' ):
        """ Returns a reference to the Traits UI preference database.
        """
        try:
            return shelve.open( os.path.join( traits_home(), 'traits_ui' ),
                                flag = mode, protocol = -1 )
        except:
            return None

    #---------------------------------------------------------------------------
    #  Returns a list of editors for the given trait name.
    #---------------------------------------------------------------------------

    def get_editors ( self, name ):
        """ Returns a list of editors for the given trait name.
        """
        return [ editor for editor in self._editors if editor.name == name ]

    #---------------------------------------------------------------------------
    #  Returns the list of editor error controls contained by the user
    #  interface:
    #---------------------------------------------------------------------------

    def get_error_controls ( self ):
        """ Returns the list of editor error controls contained by the user
            interface.
        """
        controls = []
        for editor in self._editors:
            control = editor.get_error_control()
            if isinstance( control, list ):
                controls.extend( control )
            else:
                controls.append( control )

        return controls

    #---------------------------------------------------------------------------
    #  Adds a Handler method to the list of methods to be called once the user
    #  interface has been constructed:
    #---------------------------------------------------------------------------

    def add_defined ( self, method ):
        """ Adds a Handler method to the list of methods to be called once the
            user interface has been constructed.
        """
        self._defined.append( method )

    #---------------------------------------------------------------------------
    #  Add's a conditionally enabled Editor object to the list of monitored
    #  'visible_when' objects:
    #---------------------------------------------------------------------------

    def add_visible ( self, visible_when, editor ):
        """ Adds a conditionally enabled Editor object to the list of monitored
            'visible_when' objects.
        """
        try:
            self._visible.append( ( compile( visible_when, '<string>', 'eval' ),
                                    editor ) )
        except:
            pass
            # fixme: Log an error here...

    #---------------------------------------------------------------------------
    #  Add's a conditionally enabled Editor object to the list of monitored
    #  'enabled_when' objects:
    #---------------------------------------------------------------------------

    def add_enabled ( self, enabled_when, editor ):
        """ Adds a conditionally enabled Editor object to the list of monitored
            'enabled_when' objects.
        """
        try:
            self._enabled.append( ( compile( enabled_when, '<string>', 'eval' ),
                                    editor ) )
        except:
            pass
            # fixme: Log an error here...

    #---------------------------------------------------------------------------
    #  Add's a conditionally checked (menu/toolbar) Editor object to the list of
    #  monitored 'checked_when' objects:
    #---------------------------------------------------------------------------

    def add_checked ( self, checked_when, editor ):
        """ Adds a conditionally enabled (menu) Editor object to the list of
            monitored 'checked_when' objects.
        """
        try:
            self._checked.append( ( compile( checked_when, '<string>', 'eval' ),
                                    editor ) )
        except:
            pass
            # fixme: Log an error here...

    #---------------------------------------------------------------------------
    #  Performs an 'undoable' action:
    #---------------------------------------------------------------------------

    def do_undoable ( self, action, *args, **kw ):
        """ Performs an action that can be undone.
        """
        undoable = self._undoable
        try:
            if (undoable == -1) and (self.history is not None):
                self._undoable = self.history.now

            action( *args, **kw )
        finally:
            if undoable == -1:
                self._undoable = -1

    #---------------------------------------------------------------------------
    #  Routes a 'hooked' event to the correct handler method:
    #---------------------------------------------------------------------------

    def route_event ( self, event ):
        """ Routes a "hooked" event to the correct handler method.
        """
        toolkit().route_event( self, event )

    #---------------------------------------------------------------------------
    #  Handles key events when the view has a set of KeyBindings:
    #---------------------------------------------------------------------------

    def key_handler ( self, event, skip = True ):
        """ Handles key events.
        """
        key_bindings = self.key_bindings
        handled      = ((key_bindings is not None) and
                         key_bindings.do( event, [], self.info,
                                          recursive = (self.parent is None) ))

        if (not handled) and (self.parent is not None):
            handled = self.parent.key_handler( event, False )

        if (not handled) and skip:
            toolkit().skip_event(event)

        return handled

    #---------------------------------------------------------------------------
    #  Evaluates a specified function in the UI's context:
    #---------------------------------------------------------------------------

    def evaluate ( self, function, *args, **kw_args ):
        """ Evaluates a specified function in the UI's **context**.
        """
        if function is None:
            return None

        if callable( function ):
            return function( *args, **kw_args )

        context = self.context.copy()
        context[ 'ui' ]      = self
        context[ 'handler' ] = self.handler
        return eval( function, globals(), context )( *args, **kw_args )

    #---------------------------------------------------------------------------
    #  Evaluates an expression in the UI's 'context' and returns the result:
    #---------------------------------------------------------------------------

    def eval_when ( self, when, result = True ):
        """ Evaluates an expression in the UI's **context** and returns the
            result.
        """
        context = self._get_context( self.context )
        try:
            result = eval( when, globals(), context )
        except:
            from traitsui.api import raise_to_debug
            raise_to_debug()

        del context[ 'ui' ]

        return result

    #---------------------------------------------------------------------------
    #  Gets the context to use for evaluating an expression:
    #---------------------------------------------------------------------------

    def _get_context ( self, context ):
        """ Gets the context to use for evaluating an expression.
        """
        name = 'object'
        n    = len( context )
        if (n == 2) and ('handler' in context):
            for name, value in context.items():
                if name != 'handler':
                    break
        elif n == 1:
            name = context.keys()[0]

        value = context.get( name )
        if value is not None:
            context2 = value.trait_get()
            context2.update( context )
        else:
            context2 = context.copy()

        context2['ui'] = self

        return context2

    #---------------------------------------------------------------------------
    #  Sets the 'visible', 'enabled' and/or 'checked' state for all Editors
    #  controlled by a 'visible_when', 'enabled_when' or 'checked_when'
    #  expression:
    #---------------------------------------------------------------------------

    def _evaluate_when(self):
        """ Set the 'visible', 'enabled', and 'checked' states for all Editors
            controlled by a 'visible_when', 'enabled_when' or 'checked_when'
            expression.
        """
        self._do_evaluate_when(at_init=False)


    def _do_evaluate_when(self, at_init=False):
        """ Set the 'visible', 'enabled', and 'checked' states for all Editors.

        This function does the job of _evaluate_when. We define it here to
        work around the traits dispatching mechanism that automatically
        determines the number of arguments of a notification method.

        :attr:`at_init` is set to true when this function is called the first
        time at initialization. In that case, we want to force the state of
        the items to be set (normally it is set only if it changes).
        """
        self._evaluate_condition(self._visible, 'visible', at_init)
        self._evaluate_condition(self._enabled, 'enabled', at_init)
        self._evaluate_condition(self._checked, 'checked', at_init)


    #---------------------------------------------------------------------------
    #  Evaluates a list of ( eval, editor ) pairs and sets a specified trait on
    #  each editor to reflect the boolean truth of the expression evaluated:
    #---------------------------------------------------------------------------

    def _evaluate_condition(self, conditions, trait, at_init=False):
        """ Evaluates a list of (eval, editor) pairs and sets a specified trait
        on each editor to reflect the Boolean value of the expression.

        1) All conditions are evaluated
        2) The elements whose condition evaluates to False are updated
        3) The elements whose condition evaluates to True are updated

        E.g., we first make invisible all elements for which 'visible_when'
        evaluates to False, and then we make visible the ones
        for which 'visible_when' is True. This avoids mutually exclusive
        elements to be visible at the same time, and thus making a dialog
        unnecessarily large.

        The state of an editor is updated only when it changes, unless
        at_init is set to True.

        Parameters
        ----------
        conditions : list of (str, Editor) tuple
            A list of tuples, each formed by 1) a string that contains a
            condition that evaluates to either True or False, and
            2) the editor whose state depends on the condition

        trait : str
            The trait that is set by the condition.
            Either 'visible, 'enabled', or 'checked'.

        at_init : bool
            If False, the state of an editor is set only when it changes
            (e.g., a visible element would not be updated to visible=True
            again). If True, the state is always updated (used at
            initialization).
        """

        context = self._get_context( self.context )


        # list of elements that should be activated
        activate = []
        # list of elements that should be de-activated
        deactivate = []

        for when, editor in conditions:
            try:
                cond_value = eval(when, globals(), context)
                editor_state = getattr(editor, trait)

                # add to update lists only if at_init is True (called on
                # initialization), or if the editor state has to change

                if cond_value and (at_init or not editor_state):
                    activate.append(editor)

                if not cond_value and (at_init or editor_state):
                    deactivate.append(editor)

            except Exception:
                # catch errors in the validate_when expression
                from traitsui.api import raise_to_debug
                raise_to_debug()

        # update the state of the editors
        for editor in deactivate:
            setattr(editor, trait, False)
        for editor in activate:
            setattr(editor, trait, True)


    #---------------------------------------------------------------------------
    #  Implementation of the '_groups' property:
    #  (Returns the top-level Groups for the view (after resolving Includes))
    #---------------------------------------------------------------------------

    def _get__groups ( self ):
        """ Returns the top-level Groups for the view (after resolving
        Includes. (Implements the **_groups** property.)
        """
        if self._groups_cache is None:
            shadow_group       = self.view.content.get_shadow( self )
            self._groups_cache = shadow_group.get_content()
            for item in self._groups_cache:
                if isinstance( item, Item ):
                    self._groups_cache = [
                        ShadowGroup( shadow  = Group( *self._groups_cache ),
                                     content = self._groups_cache,
                                     groups  = 1 )
                    ]
                    break
        return self._groups_cache

    #-- Property Implementations -----------------------------------------------

    @property_depends_on( 'view, context' )
    def _get_key_bindings ( self ):
        view, context = self.view, self.context
        if (view is None) or (context is None):
            return None

        # Get the KeyBindings object to use:
        values       = context.values()
        key_bindings = view.key_bindings
        if key_bindings is None:
            from .key_bindings import KeyBindings

            return KeyBindings( controllers = values)

        return key_bindings.clone( controllers = values )

    #-- Traits Event Handlers --------------------------------------------------

    def _updated_changed ( self ):
        if self.rebuild is not None:
            toolkit().rebuild_ui( self )

    def _title_changed ( self ):
        if self.control is not None:
            toolkit().set_title( self )

    def _icon_changed ( self ):
        if self.control is not None:
            toolkit().set_icon( self )

    @on_trait_change( 'parent, view, context' )
    def _pvc_changed ( self ):
        parent = self.parent
        if (parent is not None) and (self.key_bindings is not None):
            # If we don't have our own history, use our parent's:
            if self.history is None:
                self.history = parent.history

            # Link our KeyBindings object as a child of our parent's
            # KeyBindings object (if any):
            if parent.key_bindings is not None:
                parent.key_bindings.children.append( self.key_bindings )

#-------------------------------------------------------------------------------
#  'Dispatcher' class:
#-------------------------------------------------------------------------------

class Dispatcher ( object ):

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, method, info, object, method_name ):
        """ Initializes the object.
        """
        self.method      = method
        self.info        = info
        self.object      = object
        self.method_name = method_name
        object.on_trait_change( self.dispatch, method_name, dispatch = 'ui' )

    #---------------------------------------------------------------------------
    #  Dispatches the method:
    #---------------------------------------------------------------------------

    def dispatch ( self ):
        """ Dispatches the method.
        """
        self.method( self.info )

    #---------------------------------------------------------------------------
    #  Remove the dispatcher:
    #---------------------------------------------------------------------------

    def remove ( self ):
        """ Removes the dispatcher.
        """
        self.object.on_trait_change( self.dispatch, self.method_name,
                                     remove = True )


########NEW FILE########
__FILENAME__ = ui_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/03/2006
#
#------------------------------------------------------------------------------

""" Defines the BasicUIEditor class, which allows creating editors that define
    their function by creating an embedded Traits UI.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Instance

from .ui import UI

from .editor import Editor

#-------------------------------------------------------------------------------
#  'UIEditor' base class:
#-------------------------------------------------------------------------------

class UIEditor ( Editor ):
    """ An editor that creates an embedded Traits UI.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The Traits UI created by the editor
    editor_ui = Instance( UI )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.editor_ui = self.init_ui( parent ).set( parent = self.ui )
        self.control   = self.editor_ui.control

    #---------------------------------------------------------------------------
    #  Creates the traits UI for the editor (can be overridden by a subclass):
    #---------------------------------------------------------------------------

    def init_ui ( self, parent ):
        """ Creates the traits UI for the editor.
        """
        return self.value.edit_traits( view    = self.trait_view(),
                                       context = { 'object': self.value,
                                                   'editor': self },
                                       parent  = parent )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        # Do nothing, since the embedded traits UI should handle the updates
        # itself, without our meddling:
        pass

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Make sure the embedded traits UI is disposed of properly:
        if self.editor_ui is not None:
            self.editor_ui.dispose()

        super( UIEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.editor_ui.get_error_controls()

#-- UI preference save/restore interface ---------------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        self.editor_ui.set_prefs( prefs )

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        return self.editor_ui.get_prefs()

#-- EOF ----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = array_view_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/29/2007

#-------------------------------------------------------------------------------

""" Defines an ArrayViewEditor for displaying 1-d or 2-d arrays of values.
"""

#-- Imports --------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import Instance, Property, List, Str, Bool, Font

from ..api import View, Item, TabularEditor, BasicEditorFactory

from ..tabular_adapter import TabularAdapter

from ..toolkit import toolkit_object

from ..ui_editor import UIEditor

#-- Tabular Adapter Definition -------------------------------------------------

class ArrayViewAdapter ( TabularAdapter ):

    # Is the array 1D or 2D?
    is_2d = Bool( True )

    # Should array rows and columns be transposed:
    transpose  = Bool( False )

    alignment  = 'right'
    index_text = Property

    def _get_index_text ( self ):
        return str( self.row )

    def _get_content ( self ):
        if self.is_2d:
            return self.item[ self.column_id ]

        return self.item

    def get_item ( self, object, trait, row ):
        """ Returns the value of the *object.trait[row]* item.
        """
        if self.is_2d:
            if self.transpose:
                return getattr( object, trait )[:,row]

            return super( ArrayViewAdapter, self ).get_item( object, trait,
                                                             row )

        return getattr( object, trait )[ row ]

    def len ( self, object, trait ):
        """ Returns the number of items in the specified *object.trait* list.
        """
        if self.transpose:
            return getattr( object, trait ).shape[1]

        return super( ArrayViewAdapter, self ).len( object, trait )

# Define the actual abstract Traits UI array view editor (each backend should
# implement its own editor that inherits from this class.
class _ArrayViewEditor ( UIEditor ):

    # Indicate that the editor is scrollable/resizable:
    scrollable = True

    # Should column titles be displayed:
    show_titles = Bool( False )

    # The tabular adapter being used for the editor view:
    adapter = Instance( ArrayViewAdapter )

    #-- Private Methods --------------------------------------------------------

    def _array_view ( self ):
        """ Return the view used by the editor.
        """
        return View(
            Item( 'object.object.' + self.name,
                  id         = 'tabular_editor',
                  show_label = False,
                  editor     = TabularEditor( show_titles = self.show_titles,
                                              editable    = False,
                                              adapter     = self.adapter )
        ),
        id        = 'array_view_editor',
        resizable = True
    )

    def init_ui ( self, parent ):
        """ Creates the Traits UI for displaying the array.
        """
        # Make sure that the value is an array of the correct shape:
        shape = self.value.shape
        len_shape = len( shape )
        if (len_shape == 0) or (len_shape > 2):
            raise ValueError( "ArrayViewEditor can only display 1D or 2D "
                              "arrays" )

        factory          = self.factory
        cols             = 1
        titles           = factory.titles
        n                = len( titles )
        self.show_titles = (n > 0)
        is_2d            = (len_shape == 2)
        if is_2d:
            index = 1
            if factory.transpose:
                index = 0
            cols = shape[ index ]
            if self.show_titles:
                if n > cols:
                    titles = titles[:cols]
                elif n < cols:
                    if (cols % n) == 0:
                        titles, old_titles, i = [], titles, 0
                        while len( titles ) < cols:
                            titles.extend( '%s%d' % ( title, i )
                                           for title in old_titles )
                            i += 1
                    else:
                        titles.extend( [ '' ] * (cols - n) )
            else:
                titles = [ 'Data %d' % i for i in range( cols ) ]

        columns = [ ( title, i ) for i, title in enumerate( titles ) ]

        if factory.show_index:
            columns.insert( 0, ( 'Index', 'index' ) )

        self.adapter = ArrayViewAdapter( is_2d     = is_2d,
                                         columns   = columns,
                                         transpose = factory.transpose,
                                         format    = factory.format,
                                         font      = factory.font )

        return self.edit_traits( view   = '_array_view',
                                 parent = parent,
                                 kind   = 'subpanel' )

# Define the ArrayViewEditor class used by client code:
class ArrayViewEditor ( BasicEditorFactory ):

    # The editor implementation class:
    klass = Property

    # Should an index column be displayed:
    show_index = Bool( True )

    # List of (optional) column titles:
    titles = List( Str )

    # Should the array be logically transposed:
    transpose = Bool( False )

    # The format used to display each array element:
    format = Str( '%s' )

    # The font to use for displaying each array element:
    font = Font( 'Courier 10' )

    def _get_klass( self ):
        """ The class used to construct editor objects.
        """
        return toolkit_object('array_view_editor:_ArrayViewEditor')


########NEW FILE########
__FILENAME__ = ui_info
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/13/2004
#
#------------------------------------------------------------------------------

""" Defines the UIInfo class used to represent the object and editor content of
    an active Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasPrivateTraits, Instance, Constant, Bool

#-------------------------------------------------------------------------------
#  'UIInfo' class:
#-------------------------------------------------------------------------------

class UIInfo ( HasPrivateTraits ):
    """ Represents the object and editor content of an active Traits-based
    user interface
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Bound to a UI object at UIInfo construction time
    ui = Instance( 'traitsui.ui.UI', allow_none = True )

    # Indicates whether the UI has finished initialization
    initialized = Bool( False )

    #---------------------------------------------------------------------------
    #  Bind's all of the associated context objects as traits of the object:
    #---------------------------------------------------------------------------

    def bind_context ( self ):
        """ Binds all of the associated context objects as traits of the
            object.
        """
        for name, value in self.ui.context.items():
            self.bind( name, value )

    #---------------------------------------------------------------------------
    #  Binds a name to a value if it is not already bound:
    #---------------------------------------------------------------------------

    def bind ( self, name, value, id = None ):
        """ Binds a name to a value if it is not already bound.
        """
        if id is None:
            id = name

        if not hasattr( self, name ):
            self.add_trait( name, Constant( value ) )
            if id != '':
                self.ui._names.append( id )


########NEW FILE########
__FILENAME__ = ui_traits
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/14/2004
#
#------------------------------------------------------------------------------

""" Defines common traits used within the traits.ui package.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Delegate, Enum, Expression, Float, HasStrictTraits,
    Instance, List, Range, Str, Trait, TraitError, TraitPrefixList, TraitType)

from traits.trait_base import get_resource_path

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Orientation trait:
Orientation = Trait( 'vertical',
                     TraitPrefixList( 'vertical', 'horizontal' ) )

# Styles for user interface elements:
EditorStyle = style_trait = Trait( 'simple',
                     TraitPrefixList( 'simple', 'custom', 'text', 'readonly' ),
                     cols = 4 )

# Group layout trait:
Layout = Trait( 'normal',
                TraitPrefixList( 'normal', 'split', 'tabbed', 'flow', 'fold' ) )

# Trait for the default object being edited:
AnObject = Expression( 'object' )

# The default dock style to use:
DockStyle = dock_style_trait = Enum( 'fixed', 'horizontal', 'vertical', 'tab',
                                     desc = "the default docking style to use" )

# The category of elements dragged out of the view:
ExportType = Str( desc = 'the category of elements dragged out of the view' )

# Delegate a trait value to the object's **container** trait:
ContainerDelegate = container_delegate = Delegate( 'container',
                                                   listenable = False )

# An identifier for the external help context:
HelpId = help_id_trait = Str( desc = "the external help context identifier" )

# A button to add to a view:
AButton = Any
#AButton = Trait( '', Str, Instance( 'traitsui.menu.Action' ) )

# The set of buttons to add to the view:
Buttons = List( AButton,
                desc = 'the action buttons to add to the bottom of the view' )

# View trait specified by name or instance:
AView = Any
#AView = Trait( '', Str, Instance( 'traitsui.view.View' ) )

# FIXME: on AButton and AView: TraitCompound handlers with deferred-import
# Instance traits are just broken. The Instance trait tries to update the
# top-level CTrait's fast_validate table when the import is resolved. However,
# sometimes the CTrait gets copied for unknown reasons and the copy's
# fast_validate table is not updated although the TraitCompound's slow_validates
# table is modified.

#-------------------------------------------------------------------------------
#  'StatusItem' class:
#-------------------------------------------------------------------------------

class StatusItem ( HasStrictTraits ):

    # The name of the trait the status information will be synched with:
    name = Str( 'status' )

    # The width of the status field. The possible values are:
    #
    #   - abs( width )  > 1.0: Width of the field in pixels = abs( width )
    #   - abs( width ) <= 1.0: Relative width of the field when compared to
    #                          the other relative width fields.
    width = Float( 0.5 )

    def __init__ ( self, value = None, **traits ):
        """ Initializes the item object.
        """
        super( StatusItem, self ).__init__( **traits )

        if value is not None:
            self.name = value

#-------------------------------------------------------------------------------
#  'ViewStatus' trait:
#-------------------------------------------------------------------------------

class ViewStatus ( TraitType ):
    """ Defines a trait whose value must be a single StatusItem instance or a
        list of StatusItem instances.
    """

    # Define the default value for the trait:
    default_value = None

    # A description of the type of value this trait accepts:
    info_text = ('None, a string, a single StatusItem instance, or a list or '
                 'tuple of strings and/or StatusItem instances')

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.
        """
        if isinstance( value, basestring ):
            return [ StatusItem( name = value ) ]

        if isinstance( value, StatusItem ):
            return [ value ]

        if value is None:
            return value

        result = []
        if isinstance( value, SequenceTypes ):
            for item in value:
                if isinstance( item, basestring ):
                    result.append( StatusItem( name = item ) )
                elif isinstance( item, StatusItem ):
                    result.append( item )
                else:
                    break
            else:
                return result

        self.error( object, name, value )

#-------------------------------------------------------------------------------
#  'Image' trait:
#-------------------------------------------------------------------------------

image_resource_cache = {}
image_bitmap_cache   = {}

def convert_image ( value, level = 3 ):
    """ Converts a specified value to an ImageResource if possible.
    """
    global image_resource_cache

    if not isinstance( value, basestring ):
        return value

    key             = value
    is_traits_image = (value[:1] == '@')
    if not is_traits_image:
        search_path = get_resource_path( level )
        key         = '%s[%s]' % ( value, search_path )

    result = image_resource_cache.get( key )
    if result is None:
        if is_traits_image:
            try:
                from .image.image import ImageLibrary

                result = ImageLibrary.image_resource( value )
            except:
                result = None
        else:
            from pyface.image_resource import ImageResource
            result = ImageResource( value, search_path = [ search_path ] )

        image_resource_cache[ key ] = result

    return result

def convert_bitmap ( image_resource ):
    """ Converts an ImageResource to a bitmap using a cache.
    """
    global image_bitmap_cache

    bitmap = image_bitmap_cache.get( image_resource )
    if (bitmap is None) and (image_resource is not None):
        #try:
        image_bitmap_cache[ image_resource ] = bitmap = \
            image_resource.create_bitmap()
        #except:
        #    pass

    return bitmap

class Image ( TraitType ):
    """ Defines a trait whose value must be a PyFace ImageResource or a string
        that can be converted to one.
    """

    # Define the default value for the trait:
    default_value = None

    # A description of the type of value this trait accepts:
    info_text = 'an ImageResource or string that can be used to define one'

    def __init__ ( self, value = None, **metadata ):
        """ Creates an Image trait.

        Parameters
        ----------
        value : string or ImageResource
            The default value for the Image, either an ImageResource object,
            or a string from which an ImageResource object can be derived.
        """
        super( Image, self ).__init__( convert_image( value ), **metadata )

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.
        """
        from pyface.image_resource import ImageResource

        if value is None:
            return None

        new_value = convert_image( value, 4 )
        if isinstance( new_value, ImageResource ):
            return new_value

        self.error( object, name, value )

    def create_editor ( self ):
        """ Returns the default UI editor for the trait.
        """
        from .editors.api import ImageEditor
        return ImageEditor()

#-------------------------------------------------------------------------------
#  'ATheme' trait:
#-------------------------------------------------------------------------------

def convert_theme ( value, level = 3 ):
    """ Converts a specified value to a Theme if possible.
    """
    if not isinstance( value, basestring ):
        return value

    if (value[:1] == '@') and (value.find( ':' ) >= 2):
        try:
            from .image.image import ImageLibrary

            info = ImageLibrary.image_info( value )
        except:
            info = None

        if info is not None:
            return info.theme

    from .theme import Theme
    return Theme( image = convert_image( value, level + 1 ) )

class ATheme ( TraitType ):
    """ Defines a trait whose value must be a traits UI Theme or a string that
        can be converted to one.
    """

    # Define the default value for the trait:
    default_value = None

    # A description of the type of value this trait accepts:
    info_text = 'a Theme or string that can be used to define one'

    def __init__ ( self, value = None, **metadata ):
        """ Creates an ATheme trait.

        Parameters
        ----------
        value : string or Theme
            The default value for the ATheme, either a Theme object, or a
            string from which a Theme object can be derived.
        """
        super( ATheme, self ).__init__( convert_theme( value ), **metadata )

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.
        """
        from .theme import Theme

        if value is None:
            return None

        new_value = convert_theme( value, 4 )
        if isinstance( new_value, Theme ):
            return new_value

        self.error( object, name, value )

#-------------------------------------------------------------------------------
#  'BasePMB' class:
#-------------------------------------------------------------------------------

class BaseMB ( HasStrictTraits ):

    def __init__ ( self, *args, **traits ):
        """ Initializes the object.
        """
        n = len( args )
        if n > 0:
            if n == 1:
                left = right = top = bottom = args[0]
            elif n == 2:
                left = right  = args[0]
                top  = bottom = args[1]
            elif n == 4:
                left, right, top, bottom = args
            else:
                raise TraitError( '0, 1, 2 or 4 arguments expected, but %d '
                                  'specified' % n )
            self.set( left = left, right = right, top = top, bottom = bottom )

        super( BaseMB, self ).__init__( **traits )

#-------------------------------------------------------------------------------
#  'Margin' class:
#-------------------------------------------------------------------------------

class Margin ( BaseMB ):

    # The amount of padding/margin at the top:
    top = Range( -32, 32, 0 )

    # The amount of padding/margin at the bottom:
    bottom = Range( -32, 32, 0 )

    # The amount of padding/margin on the left:
    left = Range( -32, 32, 0 )

    # The amount of padding/margin on the right:
    right = Range( -32, 32, 0 )

#-------------------------------------------------------------------------------
#  'Border' class:
#-------------------------------------------------------------------------------

class Border ( BaseMB ):

    # The amount of border at the top:
    top = Range( 0, 32, 0 )

    # The amount of border at the bottom:
    bottom = Range( 0, 32, 0 )

    # The amount of border on the left:
    left = Range( 0, 32, 0 )

    # The amount of border on the right:
    right = Range( 0, 32, 0 )

#-------------------------------------------------------------------------------
#  'HasMargin' trait:
#-------------------------------------------------------------------------------

class HasMargin ( TraitType ):
    """ Defines a trait whose value must be a Margin object or an integer or
        tuple value that can be converted to one.
    """

    # The desired value class:
    klass = Margin

    # Define the default value for the trait:
    default_value = Margin( 0 )

    # A description of the type of value this trait accepts:
    info_text = ('a Margin instance, or an integer in the range from -32 to 32 '
                 'or a tuple with 1, 2 or 4 integers in that range that can be '
                 'used to define one')

    def validate ( self, object, name, value ):
        """ Validates that a specified value is valid for this trait.
        """
        if isinstance( value, int ):
            try:
                value = self.klass( value )
            except:
                self.error( object, name, value )
        elif isinstance( value, tuple ):
            try:
                value = self.klass( *value )
            except:
                self.error( object, name, value )

        if isinstance( value, self.klass ):
            return value

        self.error( object, name, value )

    def get_default_value ( self ):
        """ Returns a tuple of the form: ( default_value_type, default_value )
            which describes the default value for this trait.
        """
        dv  = self.default_value
        dvt = self.default_value_type
        if dvt < 0:
            if isinstance( dv, int ):
                dv = self.klass( dv )
            elif isinstance( dv, tuple ):
                dv = self.klass( *dv )

            if not isinstance( dv, self.klass ):
                return super( HasMargin, self ).get_default_value()

            self.default_value_type = dvt = 7
            dv = ( self.klass, (), dv.get() )

        return ( dvt, dv )

#-------------------------------------------------------------------------------
#  'HasBorder' trait:
#-------------------------------------------------------------------------------

class HasBorder ( HasMargin ):
    """ Defines a trait whose value must be a Border object or an integer
        or tuple value that can be converted to one.
    """

    # The desired value class:
    klass = Border

    # Define the default value for the trait:
    default_value = Border( 0 )

    # A description of the type of value this trait accepts:
    info_text = ('a Border instance, or an integer in the range from 0 to 32 '
                 'or a tuple with 1, 2 or 4 integers in that range that can be '
                 'used to define one')

#-------------------------------------------------------------------------------
#  Other trait definitions:
#-------------------------------------------------------------------------------

# The position of an image relative to its associated text:
Position = Enum( 'left', 'right', 'above', 'below' )

# The alignment of text within a control:
Alignment = Enum( 'default', 'left', 'center', 'right' )

# The spacing between two items:
Spacing = Range( -32, 32, 3 )

#-------------------------------------------------------------------------------
#  Other definitions:
#-------------------------------------------------------------------------------

# Types that represent sequences:
SequenceTypes = ( tuple, list )


########NEW FILE########
__FILENAME__ = undo
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the manager for Undo and Redo history for Traits user interface
    support.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from operator import isSequenceType

from traits.api import (Event, HasPrivateTraits, HasStrictTraits, HasTraits,
    Instance, Int, List, Property, Str, Trait)

from traits.trait_base import enumerate

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

NumericTypes = ( int, long, float, complex )
SimpleTypes  = ( str, unicode, int, long, float, complex )

#-------------------------------------------------------------------------------
#  'AbstractUndoItem' class:
#-------------------------------------------------------------------------------

class AbstractUndoItem ( HasPrivateTraits ):
    """ Abstract base class for undo items.
    """
    #---------------------------------------------------------------------------
    #  Undoes the change:
    #---------------------------------------------------------------------------

    def undo ( self ):
        """ Undoes the change.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Re-does the change:
    #---------------------------------------------------------------------------

    def redo ( self ):
        """ Re-does the change.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Merges two undo items if possible:
    #---------------------------------------------------------------------------

    def merge_undo ( self, undo_item ):
        """ Merges two undo items if possible.
        """
        return False

#-------------------------------------------------------------------------------
#  'UndoItem' class:
#-------------------------------------------------------------------------------

class UndoItem ( AbstractUndoItem ):
    """ A change to an object trait, which can be undone.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Object the change occurred on
    object    = Trait( HasTraits )
    # Name of the trait that changed
    name      = Str
    # Old value of the changed trait
    old_value = Property
    # New value of the changed trait
    new_value = Property

    #---------------------------------------------------------------------------
    #  Implementation of the 'old_value' and 'new_value' properties:
    #---------------------------------------------------------------------------

    def _get_old_value ( self ):
        return self._old_value

    def _set_old_value ( self, value ):
        if isinstance( value, list ):
            value = value[:]
        self._old_value = value

    def _get_new_value ( self ):
        return self._new_value

    def _set_new_value ( self, value ):
        if isinstance( value, list ):
            value = value[:]
        self._new_value = value

    #---------------------------------------------------------------------------
    #  Undoes the change:
    #---------------------------------------------------------------------------

    def undo ( self ):
        """ Undoes the change.
        """
        try:
            setattr( self.object, self.name, self.old_value )
        except:
            pass

    #---------------------------------------------------------------------------
    #  Re-does the change:
    #---------------------------------------------------------------------------

    def redo ( self ):
        """ Re-does the change.
        """
        try:
            setattr( self.object, self.name, self.new_value )
        except:
            pass

    #---------------------------------------------------------------------------
    #  Merges two undo items if possible:
    #---------------------------------------------------------------------------

    def merge_undo ( self, undo_item ):
        """ Merges two undo items if possible.
        """
        # Undo items are potentially mergeable only if they are of the same
        # class and refer to the same object trait, so check that first:
        if (isinstance( undo_item, self.__class__ ) and
           (self.object is undo_item.object) and
           (self.name == undo_item.name)):
            v1 = self.new_value
            v2 = undo_item.new_value
            t1 = type( v1 )
            if t1 is type( v2 ):

                if isinstance(t1, basestring):
                    # Merge two undo items if they have new values which are
                    # strings which only differ by one character (corresponding
                    # to a single character insertion, deletion or replacement
                    # operation in a text editor):
                    n1 = len( v1 )
                    n2 = len( v2 )
                    n  = min( n1, n2 )
                    i  = 0
                    while (i < n) and (v1[i] == v2[i]):
                        i += 1
                    if v1[i + (n2 <= n1):] == v2[i + (n2 >= n1):]:
                        self.new_value = v2
                        return True

                elif isSequenceType( v1 ):
                    # Merge sequence types only if a single element has changed
                    # from the 'original' value, and the element type is a
                    # simple Python type:
                    v1 = self.old_value
                    if isSequenceType( v1 ):
                        # Note: wxColour says it's a sequence type, but it
                        # doesn't support 'len', so we handle the exception
                        # just in case other classes have similar behavior:
                        try:
                            if len( v1 ) == len( v2 ):
                                diffs = 0
                                for i, item in enumerate( v1 ):
                                    titem = type( item )
                                    item2 = v2[i]
                                    if ((titem not in SimpleTypes)   or
                                        (titem is not type( item2 )) or
                                        (item != item2)):
                                        diffs += 1
                                        if diffs >= 2:
                                            return False
                                if diffs == 0:
                                    return False
                                self.new_value = v2
                                return True
                        except:
                            pass

                elif t1 in NumericTypes:
                    # Always merge simple numeric trait changes:
                    self.new_value = v2
                    return True
        return False

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' form of the object:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" form of the object.
        """
        n  = self.name
        cn = self.object.__class__.__name__
        return 'undo( %s.%s = %s )\nredo( %s.%s = %s )' % (
                      cn, n, self.old_value, cn, n, self.new_value )

#-------------------------------------------------------------------------------
#  'ListUndoItem' class:
#-------------------------------------------------------------------------------

class ListUndoItem ( AbstractUndoItem ):
    """ A change to a list, which can be undone.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Object that the change occurred on
    object    = Trait( HasTraits )
    # Name of the trait that changed
    name      = Str
    # Starting index
    index     = Int
    # Items added to the list
    added     = List
    # Items removed from the list
    removed   = List

    #---------------------------------------------------------------------------
    #  Undoes the change:
    #---------------------------------------------------------------------------

    def undo ( self ):
        """ Undoes the change.
        """
        try:
            list = getattr( self.object, self.name )
            list[ self.index: (self.index + len( self.added )) ] = self.removed
        except:
            pass

    #---------------------------------------------------------------------------
    #  Re-does the change:
    #---------------------------------------------------------------------------

    def redo ( self ):
        """ Re-does the change.
        """
        try:
            list = getattr( self.object, self.name )
            list[ self.index: (self.index + len( self.removed )) ] = self.added
        except:
            pass

    #---------------------------------------------------------------------------
    #  Merges two undo items if possible:
    #---------------------------------------------------------------------------

    def merge_undo ( self, undo_item ):
        """ Merges two undo items if possible.
        """
        # Discard undo items that are identical to us. This is to eliminate
        # the same undo item being created by multiple listeners monitoring the
        # same list for changes:
        if (isinstance( undo_item, self.__class__ )        and
           (self.object is undo_item.object)               and
           (self.name  == undo_item.name)                  and
           (self.index == undo_item.index)):
            added   = undo_item.added
            removed = undo_item.removed
            if ((len( self.added )   == len( added )) and
                (len( self.removed ) == len( removed ))):
                for i, item in enumerate( self.added ):
                    if item is not added[i]:
                        break
                else:
                    for i, item in enumerate( self.removed ):
                        if item is not removed[i]:
                            break
                    else:
                        return True
        return False

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' form of the object:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a 'pretty print' form of the object.
        """
        return 'undo( %s.%s[%d:%d] = %s )' % (
                self.object.__class__.__name__, self.name, self.index,
                self.index + len( self.removed ), self.added )

#-------------------------------------------------------------------------------
#  'UndoHistory' class:
#-------------------------------------------------------------------------------

class UndoHistory ( HasStrictTraits ):
    """ Manages a list of undoable changes.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # List of accumulated undo changes
    history  = List
    # The current position in the list
    now      = Int
    # Fired when state changes to undoable
    undoable = Event( False )
    # Fired when state changes to redoable
    redoable = Event( False )
    # Can an action be undone?
    can_undo = Property
    # Can an action be redone?
    can_redo = Property

    #---------------------------------------------------------------------------
    #  Adds an UndoItem to the history:
    #---------------------------------------------------------------------------

    def add ( self, undo_item, extend = False ):
        """ Adds an UndoItem to the history.
        """
        if extend:
            self.extend( undo_item )
            return

        # Try to merge the new undo item with the previous item if allowed:
        now = self.now
        if now > 0:
            previous = self.history[ now - 1 ]
            if (len( previous ) == 1) and previous[0].merge_undo( undo_item ):
                self.history[ now: ] = []
                return

        old_len = len( self.history )
        self.history[ now: ] = [ [ undo_item ] ]
        self.now += 1
        if self.now == 1:
            self.undoable = True
        if self.now <= old_len:
            self.redoable = False

    #---------------------------------------------------------------------------
    #  Extends the most recent 'undo' item:
    #---------------------------------------------------------------------------

    def extend ( self, undo_item ):
        """ Extends the undo history.

        If possible the method merges the new UndoItem with the last item in
        the history; otherwise, it appends the new item.
        """
        if self.now > 0:
            undo_list =  self.history[ self.now - 1 ]
            if not undo_list[-1].merge_undo( undo_item ):
                undo_list.append( undo_item )

    #---------------------------------------------------------------------------
    #  Undo an operation:
    #---------------------------------------------------------------------------

    def undo ( self ):
        """ Undoes an operation.
        """
        if self.can_undo:
            self.now -= 1
            items = self.history[ self.now ]
            for i in range( len( items ) - 1, -1, -1 ):
                items[i].undo()
            if self.now == 0:
                self.undoable = False
            if self.now == (len( self.history ) - 1):
                self.redoable = True

    #---------------------------------------------------------------------------
    #  Redo an operation:
    #---------------------------------------------------------------------------

    def redo ( self ):
        """ Redoes an operation.
        """
        if self.can_redo:
            self.now += 1
            for item in self.history[ self.now - 1 ]:
                item.redo()
            if self.now == 1:
                self.undoable = True
            if self.now == len( self.history ):
                self.redoable = False

    #---------------------------------------------------------------------------
    #  Reverts all changes made so far and clears the history:
    #---------------------------------------------------------------------------

    def revert ( self ):
        """ Reverts all changes made so far and clears the history.
        """
        history = self.history[ : self.now ]
        self.clear()
        for i in range( len( history ) - 1, -1, -1 ):
            items = history[i]
            for j in range( len( items ) - 1, -1, -1 ):
                items[j].undo()

    #---------------------------------------------------------------------------
    #  Clears the undo history
    #---------------------------------------------------------------------------

    def clear ( self ):
        """ Clears the undo history.
        """
        old_len  = len( self.history )
        old_now  = self.now
        self.now = 0
        del self.history[:]
        if old_now > 0:
            self.undoable = False
        if old_now < old_len:
            self.redoable = False

    #---------------------------------------------------------------------------
    #  Are there any undoable operations?
    #---------------------------------------------------------------------------

    def _get_can_undo ( self ):
        """ Are there any undoable operations?
        """
        return self.now > 0

    #---------------------------------------------------------------------------
    #  Are there any redoable operations?
    #---------------------------------------------------------------------------

    def _get_can_redo ( self ):
        """ Are there any redoable operations?
        """
        return self.now < len( self.history )

#-------------------------------------------------------------------------------
#  'UndoHistoryUndoItem' class:
#-------------------------------------------------------------------------------

class UndoHistoryUndoItem ( AbstractUndoItem ):
    """ An undo item for the undo history.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The undo history to undo or redo
    history = Instance( UndoHistory )

    #---------------------------------------------------------------------------
    #  Undoes the change:
    #---------------------------------------------------------------------------

    def undo ( self ):
        """ Undoes the change.
        """
        history = self.history
        for i in range( history.now - 1, -1, -1 ):
            items = history.history[i]
            for j in range( len( items ) - 1, -1, -1 ):
                items[j].undo()

    #---------------------------------------------------------------------------
    #  Re-does the change:
    #---------------------------------------------------------------------------

    def redo ( self ):
        """ Re-does the change.
        """
        history = self.history
        for i in range( 0, history.now ):
            for item in history.history[i]:
                item.redo()


########NEW FILE########
__FILENAME__ = value_tree
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/05/2006
#
#------------------------------------------------------------------------------

""" Defines tree node classes and editors for various types of values.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import inspect

from types import FunctionType, MethodType

from traits.api import Any, Bool, HasPrivateTraits, HasTraits, Instance, List, Str

from .tree_node import ObjectTreeNode, TreeNode, TreeNodeObject

from .editors.tree_editor import TreeEditor

#-------------------------------------------------------------------------------
#  'SingleValueTreeNodeObject' class:
#-------------------------------------------------------------------------------

class SingleValueTreeNodeObject ( TreeNodeObject ):
    """ A tree node for objects of types that have a single value.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The parent of this node
    parent = Instance( TreeNodeObject )

    # Name of the value
    name = Str

    # User-specified override of the default label
    label = Str

    # The value itself
    value = Any

    # Is the value readonly?
    readonly = Bool( False )

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def tno_allows_children ( self, node ):
        """ Returns whether this object can have children (False for this
        class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether the object has children (False for this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be renamed:
    #---------------------------------------------------------------------------

    def tno_can_rename ( self, node ):
        """ Returns whether the object's children can be renamed (False for
        this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be copied:
    #---------------------------------------------------------------------------

    def tno_can_copy ( self, node ):
        """ Returns whether the object's children can be copied (True for this
        class).
        """
        return True

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def tno_can_delete ( self, node ):
        """ Returns whether the object's children can be deleted (False for
        this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be inserted (or just
    #  appended):
    #---------------------------------------------------------------------------

    def tno_can_insert ( self, node ):
        """ Returns whether the object's children can be inserted (False,
        meaning children are appended, for this class).
        """
        return False

    #---------------------------------------------------------------------------
    #  Returns the icon for a specified object:
    #---------------------------------------------------------------------------

    def tno_get_icon ( self, node, is_expanded ):
        """ Returns the icon for a specified object.
        """
        return ('@icons:%s_node' % self.__class__.__name__[ : -4 ].lower())

    #---------------------------------------------------------------------------
    #  Sets the label for a specified node:
    #---------------------------------------------------------------------------

    def tno_set_label ( self, node, label ):
        """ Sets the label for a specified object.
        """
        if label == '?':
            label = ''
        self.label = label

    #---------------------------------------------------------------------------
    #  Gets the label to display for a specified object:
    #---------------------------------------------------------------------------

    def tno_get_label ( self, node ):
        """ Gets the label to display for a specified object.
        """
        if self.label != '':
            return self.label

        if self.name == '':
            return self.format_value( self.value )

        return '%s: %s' % ( self.name, self.format_value( self.value ) )

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return repr( value )

    #---------------------------------------------------------------------------
    #  Returns the correct node type for a specified value:
    #---------------------------------------------------------------------------

    def node_for ( self, name, value ):
        """ Returns the correct node type for a specified value.
        """
        for type, node in basic_types():
            if isinstance( value, type ):
                break
        else:
            node = OtherNode
            if inspect.isclass( value ):
                node = ClassNode

            elif hasattr( value, '__class__' ):
                node = ObjectNode

        return node( parent   = self,
                     name     = name,
                     value    = value,
                     readonly = self.readonly )

#-------------------------------------------------------------------------------
#  'MultiValueTreeNodeObject' class:
#-------------------------------------------------------------------------------

class MultiValueTreeNodeObject ( SingleValueTreeNodeObject ):
    """ A tree node for objects of types that have multiple values.
    """

    #---------------------------------------------------------------------------
    #  Returns whether chidren of this object are allowed or not:
    #---------------------------------------------------------------------------

    def tno_allows_children ( self, node ):
        """ Returns whether this object can have children (True for this class).
        """
        return True

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether the object has children (True for this class).
        """
        return True

#-------------------------------------------------------------------------------
#  'StringNode' class:
#-------------------------------------------------------------------------------

class StringNode ( SingleValueTreeNodeObject ):
    """ A tree node for strings.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        n = len( value )
        if len( value ) > 80:
            value = '%s...%s' % ( value[ :42 ], value[ -35: ] )

        return '%s [%d]' % ( repr( value ), n )

#-------------------------------------------------------------------------------
#  'NoneNode' class:
#-------------------------------------------------------------------------------

class NoneNode ( SingleValueTreeNodeObject ):
    """ A tree node for None values.
    """
    pass

#-------------------------------------------------------------------------------
#  'BoolNode' class:
#-------------------------------------------------------------------------------

class BoolNode ( SingleValueTreeNodeObject ):
    """ A tree node for Boolean values.
    """
    pass

#-------------------------------------------------------------------------------
#  'IntNode' class:
#-------------------------------------------------------------------------------

class IntNode ( SingleValueTreeNodeObject ):
    """ A tree node for integer values.
    """
    pass

#-------------------------------------------------------------------------------
#  'FloatNode' class:
#-------------------------------------------------------------------------------

class FloatNode ( SingleValueTreeNodeObject ):
    """ A tree node for floating point values.
    """
    pass

#-------------------------------------------------------------------------------
#  'ComplexNode' class:
#-------------------------------------------------------------------------------

class ComplexNode ( SingleValueTreeNodeObject ):
    """ A tree node for complex number values.
    """
    pass

#-------------------------------------------------------------------------------
#  'OtherNode' class:
#-------------------------------------------------------------------------------

class OtherNode ( SingleValueTreeNodeObject ):
    """ A tree node for single-value types for which there is not another
    node type.
    """
    pass

#-------------------------------------------------------------------------------
#  'TupleNode' class:
#-------------------------------------------------------------------------------

class TupleNode ( MultiValueTreeNodeObject ):
    """ A tree node for tuples.
    """
    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return 'Tuple(%d)' % len( value )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether the object has children, based on the length of
            the tuple.
        """
        return (len( self.value ) > 0)

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        node_for = self.node_for
        value    = self.value
        if len( value ) > 500:
            return ([ node_for( '[%d]' % i, x )
                      for i, x in enumerate( value[ : 250 ] ) ] +
                    [ StringNode( value = '...', readonly = True ) ] +
                    [ node_for( '[%d]' % i, x )
                      for i, x in enumerate( value[ -250: ] ) ])

        return [ node_for( '[%d]' % i, x ) for i, x in enumerate( value ) ]

#-------------------------------------------------------------------------------
#  'ListNode' class:
#-------------------------------------------------------------------------------

class ListNode ( TupleNode ):
    """ A tree node for lists.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return 'List(%d)' % len( value )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def tno_can_delete ( self, node ):
        """ Returns whether the object's children can be deleted.
        """
        return (not self.readonly)

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be inserted (or just
    #  appended):
    #---------------------------------------------------------------------------

    def tno_can_insert ( self, node ):
        """ Returns whether the object's children can be inserted (vs.
        appended).
        """
        return (not self.readonly)

#-------------------------------------------------------------------------------
#  'SetNode' class:
#-------------------------------------------------------------------------------

class SetNode ( ListNode ):
    """ A tree node for sets.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return 'Set(%d)' % len( value )

#-------------------------------------------------------------------------------
#  'ArrayNode' class:
#-------------------------------------------------------------------------------

class ArrayNode ( TupleNode ):
    """ A tree node for arrays.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return 'Array(%s)' % ','.join( [ str( n ) for n in value.shape ] )

#-------------------------------------------------------------------------------
#  'DictNode' class:
#-------------------------------------------------------------------------------

class DictNode ( TupleNode ):
    """ A tree node for dictionaries.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return 'Dict(%d)' % len( value )

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        node_for = self.node_for
        items    = [ ( repr( k ), v ) for k, v in self.value.items() ]
        items.sort( lambda l, r: cmp( l[0], r[0] ) )
        if len( items ) > 500:
            return ([ node_for( '[%s]' % k, v ) for k, v in items[: 250 ] ] +
                    [ StringNode( value = '...', readonly = True ) ]        +
                    [ node_for( '[%s]' % k, v ) for k, v in items[ -250: ] ])

        return [ node_for( '[%s]' % k, v ) for k, v in items ]

    #---------------------------------------------------------------------------
    #  Returns whether or not the object's children can be deleted:
    #---------------------------------------------------------------------------

    def tno_can_delete ( self, node ):
        """ Returns whether the object's children can be deleted.
        """
        return (not self.readonly)

#-------------------------------------------------------------------------------
#  'FunctionNode' class:
#-------------------------------------------------------------------------------

class FunctionNode ( SingleValueTreeNodeObject ):
    """ A tree node for functions
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return 'Function %s()' % ( value.func_code.co_name )

#---------------------------------------------------------------------------
#  'MethodNode' class:
#---------------------------------------------------------------------------

class MethodNode ( MultiValueTreeNodeObject ):

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        type = 'B'
        if value.im_self is None:
            type = 'Unb'

        return '%sound method %s.%s()' % (
                   type,
                   value.im_class.__name__,
                   value.im_func.func_code.co_name )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether the object has children.
        """
        return (self.value.im_func != None)

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        return [ self.node_for( 'Object', self.value.im_self ) ]

#-------------------------------------------------------------------------------
#  'ObjectNode' class:
#-------------------------------------------------------------------------------

class ObjectNode ( MultiValueTreeNodeObject ):
    """ A tree node for objects.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        try:
            klass = value.__class__.__name__
        except:
            klass = '???'
        return '%s(0x%08X)' % ( klass, id( value ) )

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether the object has children.
        """
        try:
            return (len( self.value.__dict__ ) > 0)
        except:
            return False

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        items = [ ( k, v ) for k, v in self.value.__dict__.items() ]
        items.sort( lambda l, r: cmp( l[0], r[0] ) )
        return [ self.node_for( '.' + k, v ) for k, v in items ]

#-------------------------------------------------------------------------------
#  'ClassNode' class:
#-------------------------------------------------------------------------------

class ClassNode ( ObjectNode ):
    """ A tree node for classes.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return value.__name__

#-------------------------------------------------------------------------------
#  'TraitsNode' class:
#-------------------------------------------------------------------------------

class TraitsNode ( ObjectNode ):
    """ A tree node for traits.
    """

    #---------------------------------------------------------------------------
    #  Returns whether or not the object has children:
    #---------------------------------------------------------------------------

    def tno_has_children ( self, node ):
        """ Returns whether the object has children.
        """
        return (len( self._get_names() ) > 0)

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        names = self._get_names()
        names.sort()
        value    = self.value
        node_for = self.node_for
        nodes    = []
        for name in names:
            try:
                item_value = getattr( value, name, '<unknown>' )
            except Exception, excp:
                item_value = '<%s>' % excp
            nodes.append( node_for( '.' + name, item_value ) )

        return nodes

    #---------------------------------------------------------------------------
    #  Gets the names of all defined traits/attributes:
    #---------------------------------------------------------------------------

    def _get_names ( self ):
        """ Gets the names of all defined traits or attributes.
        """
        value = self.value
        names = {}
        for name in value.trait_names( type = lambda x: x != 'event' ):
            names[ name ] = None
        for name in value.__dict__.keys():
            names[ name ] = None
        return names.keys()

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children replaced' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def tno_when_children_replaced ( self, node, listener, remove ):
        """ Sets up or removes a listener for children being replaced on a
        specified object.
        """
        self._listener = listener
        self.value.on_trait_change( self._children_replaced, remove = remove,
                                    dispatch = 'ui' )

    def _children_replaced ( self ):
        self._listener( self )

    #---------------------------------------------------------------------------
    #  Sets up/Tears down a listener for 'children changed' on a specified
    #  object:
    #---------------------------------------------------------------------------

    def tno_when_children_changed ( self, node, listener, remove ):
        """ Sets up or removes a listener for children being changed on a
        specified object.
        """
        pass

#-------------------------------------------------------------------------------
#  'RootNode' class:
#-------------------------------------------------------------------------------

class RootNode ( MultiValueTreeNodeObject ):
    """ A root node.
    """

    #---------------------------------------------------------------------------
    #  Returns the formatted version of the value:
    #---------------------------------------------------------------------------

    def format_value ( self, value ):
        """ Returns the formatted version of the value.
        """
        return ''

    #---------------------------------------------------------------------------
    #  Gets the object's children:
    #---------------------------------------------------------------------------

    def tno_get_children ( self, node ):
        """ Gets the object's children.
        """
        return [ self.node_for( '', self.value ) ]

#-------------------------------------------------------------------------------
#  Define the mapping of object types to nodes:
#-------------------------------------------------------------------------------

_basic_types = None

def basic_types ( ):
    global _basic_types

    if _basic_types is None:
        # Create the mapping of object types to nodes:
        _basic_types = [
            ( type( None ), NoneNode ),
            ( str,          StringNode ),
            ( unicode,      StringNode ),
            ( bool,         BoolNode ),
            ( int,          IntNode ),
            ( float,        FloatNode ),
            ( complex,      ComplexNode ),
            ( tuple,        TupleNode ),
            ( list,         ListNode ),
            ( set,          SetNode ),
            ( dict,         DictNode ),
            ( FunctionType, FunctionNode ),
            ( MethodType,   MethodNode ),
            ( HasTraits,    TraitsNode )
        ]

        try:
            from numpy import array

            _basic_types.append( ( type( array( [ 1 ] ) ), ArrayNode ) )
        except ImportError:
            pass

    return _basic_types

#-------------------------------------------------------------------------------
#  '_ValueTree' class:
#-------------------------------------------------------------------------------

class _ValueTree ( HasPrivateTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # List of arbitrary Python values contained in the tree:
    values = List( SingleValueTreeNodeObject )

#-------------------------------------------------------------------------------
#  Defines the value tree editor(s):
#-------------------------------------------------------------------------------

# Nodes in a value tree:
value_tree_nodes = [
    ObjectTreeNode(
        node_for = [ NoneNode, StringNode, BoolNode, IntNode, FloatNode,
                     ComplexNode, OtherNode, TupleNode, ListNode, ArrayNode,
                     DictNode, SetNode, FunctionNode, MethodNode, ObjectNode,
                     TraitsNode, RootNode, ClassNode ] )
]

# Editor for a value tree:
value_tree_editor = TreeEditor(
    auto_open = 3,
    hide_root = True,
    editable  = False,
    nodes     = value_tree_nodes
)

# Editor for a value tree with a root:
value_tree_editor_with_root = TreeEditor(
    auto_open = 3,
    editable  = False,
    nodes     = [
        ObjectTreeNode(
            node_for = [ NoneNode, StringNode, BoolNode, IntNode, FloatNode,
                         ComplexNode, OtherNode, TupleNode, ListNode, ArrayNode,
                         DictNode, SetNode, FunctionNode, MethodNode,
                         ObjectNode, TraitsNode, RootNode, ClassNode ]
        ),
        TreeNode( node_for = [ _ValueTree ],
                  auto_open  = True,
                  children   = 'values',
                  move       = [ SingleValueTreeNodeObject ],
                  copy       = False,
                  label      = '=Values',
                  icon_group = 'traits_node',
                  icon_open  = 'traits_node' )
    ]
)

#-------------------------------------------------------------------------------
#  Defines a 'ValueTree' trait:
#-------------------------------------------------------------------------------

# Trait for a value tree:
ValueTree = Instance( _ValueTree, (), editor = value_tree_editor_with_root )


########NEW FILE########
__FILENAME__ = view
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/07/2004
#
#------------------------------------------------------------------------------

""" Defines the View class used to represent the structural content of a
    Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import (Any, Bool, Callable, Enum, Event, Float, Instance, List, Str,
    Trait, TraitPrefixList)

from .view_element import ViewElement, ViewSubElement

from .ui import UI

from .ui_traits import (AButton, ATheme, AnObject, Buttons, DockStyle,
    EditorStyle, ExportType, HelpId, Image, SequenceTypes, ViewStatus)

from .handler import Handler, default_handler

from .group import Group

from .item import Item

from .include import Include

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Name of the view trait:
AnId = Str( desc = 'the name of the view' )

# Contents of the view trait (i.e., a single Group object):
Content = Instance( Group, desc = 'the content of the view' )

# An optional model/view factory for converting the model into a viewable
# 'model_view' object
AModelView = Callable( desc = 'the factory function for converting a model '
                              'into a model/view object' )

# Reference to a Handler object trait:
AHandler = Any( desc = 'the handler for the view' )

# Dialog window title trait:
ATitle = Str( desc = 'the window title for the view' )

# Dialog window icon trait
#icon_trait = Instance( 'pyface.image_resource.ImageResource',
#                     desc = 'the ImageResource of the icon file for the view' )

# User interface 'kind' trait. The values have the following meanings:
#
# * 'panel': An embeddable panel. This type of window is intended to be used as
#   part of a larger interface.
# * 'subpanel': An embeddable panel that does not display command buttons,
#   even if the View specifies them.
# * 'modal': A modal dialog box that operates on a clone of the object until
#   the user commits the change.
# * 'nonmodal':  A nonmodal dialog box that operates on a clone of the object
#   until the user commits the change
# * 'live': A nonmodal dialog box that immediately updates the object.
# * 'livemodal': A modal dialog box that immediately updates the object.
# * 'popup': A temporary, frameless popup dialog that immediately updates the
#   object and is active only while the mouse pointer is in the dialog.
# * 'info': A temporary, frameless popup dialog that immediately updates the
#   object and is active only while the dialog is still over the invoking
#   control.
# * 'wizard': A wizard modal dialog box. A wizard contains a sequence of
#   pages, which can be accessed by clicking **Next** and **Back** buttons.
#   Changes to attribute values are applied only when the user clicks the
#   **Finish** button on the last page.
AKind = Trait( 'live', TraitPrefixList(
                   'panel', 'subpanel', 'modal', 'nonmodal', 'livemodal',
                   'live', 'popup', 'popover', 'info', 'wizard' ),
               desc = 'the kind of view window to create',
               cols = 4 )

# Apply changes handler:
OnApply = Callable( desc = 'the routine to call when modal changes are applied '
                           'or reverted' )

# Is the dialog window resizable?
IsResizable = Bool( False, desc = 'whether dialog can be resized or not' )

# Is the view scrollable?
IsScrollable = Bool( False, desc = 'whether view should be scrollable or not' )

# The valid categories of imported elements that can be dragged into the view:
ImportTypes = List( Str, desc = 'the categories of elements that can be '
                                'dragged into the view' )

# The view position and size traits:
Width       = Float( -1E6, desc = 'the width of the view window' )
Height      = Float( -1E6, desc = 'the height of the view window' )
XCoordinate = Float( -1E6, desc = 'the x coordinate of the view window' )
YCoordinate = Float( -1E6, desc = 'the y coordinate of the view window' )

# The result that should be returned if the user clicks the window or dialog
# close button or icon
CloseResult = Enum( None, True, False,
                    desc = 'the result to return when the user clicks the '
                           'window or dialog close button or icon' )

# The KeyBindings trait:
AKeyBindings = Instance( 'traitsui.key_bindings.KeyBindings',
                         desc = 'the global key bindings for the view' )

#-------------------------------------------------------------------------------
#  'View' class:
#-------------------------------------------------------------------------------

class View ( ViewElement ):
    """ A Traits-based user interface for one or more objects.

        The attributes of the View object determine the contents and layout of
        an attribute-editing window. A View object contains a set of Group,
        Item, and Include objects. A View object can be an attribute of an
        object derived from HasTraits, or it can be a standalone object.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # A unique identifier for the view:
    id = AnId

    # The top-level Group object for the view:
    content = Content

    # The menu bar for the view. Usually requires a custom **handler**:
    menubar = Any # Instance( pyface.action.MenuBarManager )

    # The toolbar for the view. Usually requires a custom **handler**:
    toolbar = Any # Instance( pyface.action.ToolBarManager )

    # Status bar items to add to the view's status bar. The value can be:
    #
    #   - **None**: No status bar for the view (the default).
    #   - string: Same as [ StatusItem( name = string ) ].
    #   - StatusItem: Same as [ StatusItem ].
    #   - [ [StatusItem|string], ... ]: Create a status bar with one field for
    #     each StatusItem in the list (or tuple). The status bar fields are
    #     defined from left to right in the order specified. A string value is
    #     converted to: StatusItem( name = string ):
    statusbar = ViewStatus

    # List of button actions to add to the view. The **traitsui.menu**
    # module defines standard buttons, such as **OKButton**, and standard sets
    # of buttons, such as **ModalButtons**, which can be used to define a value
    # for this attribute. This value can also be a list of button name strings,
    # such as ``['OK', 'Cancel', 'Help']``. If set to the empty list, the
    # view contains a default set of buttons (equivalent to **LiveButtons**:
    # Undo/Redo, Revert, OK, Cancel, Help). To suppress buttons in the view,
    # use the **NoButtons** variable, defined in **traitsui.menu**.
    buttons = Buttons

    # The default button to activate when Enter is pressed. If not specified,
    # pressing Enter will not activate any button.
    default_button = AButton

    # The set of global key bindings for the view. Each time a key is pressed
    # while the view has keyboard focus, the key is checked to see if it is one
    # of the keys recognized by the KeyBindings object. If it is, the matching
    # KeyBinding's method name is checked to see if it is defined on any of the
    # object's in the view's context. If it is, the method is invoked. If the
    # result of the method is **False**, then the search continues with the
    # next object in the context. If any invoked method returns a non-False
    # value, processing stops and the key is marked as having been handled. If
    # all invoked methods return **False**, or no matching KeyBinding object is
    # found, the key is processed normally. If the view has a non-empty *id*
    # trait, the contents of the **KeyBindings** object will be saved as part
    # of the view's persistent data:
    key_bindings = AKeyBindings

    # The Handler object that provides GUI logic for handling events in the
    # window. Set this attribute only if you are using a custom Handler. If
    # not set, the default Traits UI Handler is used.
    handler = AHandler

    # The factory function for converting a model into a model/view object:
    model_view = AModelView

    # Title for the view, displayed in the title bar when the view appears as a
    # secondary window (i.e., dialog or wizard). If not specified, "Edit
    # properties" is used as the title.
    title = ATitle

    # The name of the icon to display in the dialog window title bar:
    icon = Any

    # The kind of user interface to create:
    kind = AKind

    # The default object being edited:
    object = AnObject

    # The default editor style of elements in the view:
    style = EditorStyle

    # The default docking style to use for sub-groups of the view. The following
    # values are possible:
    #
    # * 'fixed': No rearrangement of sub-groups is allowed.
    # * 'horizontal': Moveable elements have a visual "handle" to the left by
    #   which the element can be dragged.
    # * 'vertical': Moveable elements have a visual "handle" above them by
    #   which the element can be dragged.
    # * 'tabbed': Moveable elements appear as tabbed pages, which can be
    #   arranged within the window or "stacked" so that only one appears at
    #   at a time.
    dock = DockStyle

    # The image to display on notebook tabs:
    image = Image

    # Called when modal changes are applied or reverted:
    on_apply = OnApply

    # Can the user resize the window?
    resizable = IsResizable

    # Can the user scroll the view? If set to True, window-level scroll bars
    # appear whenever the window is too small to show all of its contents at
    # one time. If set to False, the window does not scroll, but individual
    # widgets might still contain scroll bars.
    scrollable = IsScrollable

    # The category of exported elements:
    export = ExportType

    # The valid categories of imported elements:
    imports = ImportTypes

    # External help context identifier, which can be used by a custom help
    # handler. This attribute is ignored by the default help handler.
    help_id = HelpId

    # Requested x-coordinate (horizontal position) for the view window. This
    # attribute can be specified in the following ways:
    #
    # * A positive integer: indicates the number of pixels from the left edge
    #   of the screen to the left edge of the window.
    # * A negative integer: indicates the number of pixels from the right edge
    #   of the screen to the right edge of the window.
    # * A floating point value between 0 and 1: indicates the fraction of the
    #   total screen width between the left edge of the screen and the left edge
    #   of the window.
    # * A floating point value between -1 and 0: indicates the fraction of the
    #   total screen width between the right edge of the screen and the right
    #   edge of the window.
    x = XCoordinate

    # Requested y-coordinate (vertical position) for the view window. This
    # attribute behaves exactly like the **x** attribute, except that its value
    # indicates the position of the top or bottom of the view window relative
    # to the top or bottom of the screen.
    y = YCoordinate

    # Requested width for the view window, as an (integer) number of pixels, or
    # as a (floating point) fraction of the screen width.
    width = Width

    # Requested height for the view window, as an (integer) number of pixels, or
    # as a (floating point) fraction of the screen height.
    height = Height

    # Class of dropped objects that can be added:
    drop_class = Any

    # Event when the view has been updated:
    updated = Event

    # What result should be returned if the user clicks the window or dialog
    # close button or icon?
    close_result = CloseResult

    # The default theme to use for a contained item:
    item_theme = ATheme

    # The default theme to use for a contained item's label:
    label_theme = ATheme

    # Note: Group objects delegate their 'object' and 'style' traits to the View

    #-- Deprecated Traits (DO NOT USE) -----------------------------------------

    ok     = Bool( False )
    cancel = Bool( False )
    undo   = Bool( False )
    redo   = Bool( False )
    apply  = Bool( False )
    revert = Bool( False )
    help   = Bool( False )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, *values, **traits ):
        """ Initializes the object.
        """
        ViewElement.__init__( self, **traits )
        self.set_content( *values )

    #---------------------------------------------------------------------------
    #  Sets the content of a view:
    #---------------------------------------------------------------------------

    def set_content ( self, *values ):
        """ Sets the content of a view.
        """
        content = []
        accum   = []
        for value in values:
            if isinstance( value, ViewSubElement ):
                content.append( value )
            elif type( value ) in SequenceTypes:
                content.append( Group( *value ) )
            elif (isinstance( value, basestring ) and
                 (value[:1] == '<') and (value[-1:] == '>')):
                # Convert string to an Include value:
                content.append( Include( value[1:-1].strip() ) )
            else:
                content.append( Item( value ) )

        # If there are any 'Item' objects in the content, wrap the content in a
        # Group:
        for item in content:
            if isinstance( item, Item ):
                content = [ Group( *content ) ]
                break

        # Wrap all of the content up into a Group and save it as our content:
        self.content = Group( container = self, *content )

    #---------------------------------------------------------------------------
    #  Creates a UI user interface object:
    #---------------------------------------------------------------------------

    def ui ( self, context, parent        = None, kind       = None,
                            view_elements = None, handler    = None,
                            id            = '',   scrollable = None,
                            args          = None ):
        """ Creates a **UI** object, which generates the actual GUI window or
        panel from a set of view elements.

        Parameters
        ----------
        context : object or dictionary
            A single object or a dictionary of string/object pairs, whose trait
            attributes are to be edited. If not specified, the current object is
            used.
        parent : window component
            The window parent of the View object's window
        kind : string
            The kind of window to create. See the **AKind** trait for details.
            If *kind* is unspecified or None, the **kind** attribute of the
            View object is used.
        view_elements : ViewElements object
            The set of Group, Item, and Include objects contained in the view.
            Do not use this parameter when calling this method directly.
        handler : Handler object
            A handler object used for event handling in the dialog box. If
            None, the default handler for Traits UI is used.
        id : string
            A unique ID for persisting preferences about this user interface,
            such as size and position. If not specified, no user preferences
            are saved.
        scrollable : Boolean
            Indicates whether the dialog box should be scrollable. When set to
            True, scroll bars appear on the dialog box if it is not large enough
            to display all of the items in the view at one time.

        """
        handler = handler or self.handler or default_handler()
        if not isinstance( handler, Handler ):
            handler = handler()

        if args is not None:
            handler.set( **args )

        if not isinstance( context, dict ):
            context = context.trait_context()

        context.setdefault( 'handler', handler )
        handler = context[ 'handler' ]

        if self.model_view is not None:
            context[ 'object' ] = self.model_view( context[ 'object' ] )

        self_id = self.id
        if self_id != '':
            if id != '':
                id = '%s:%s' % ( self_id, id )
            else:
                id = self_id

        if scrollable is None:
            scrollable = self.scrollable

        ui = UI( view          = self,
                 context       = context,
                 handler       = handler,
                 view_elements = view_elements,
                 title         = self.title,
                 id            = id,
                 scrollable    = scrollable )

        if kind is None:
            kind = self.kind

        ui.ui( parent, kind )

        return ui

    #---------------------------------------------------------------------------
    #  Replaces any items which have an 'id' with an Include object with the
    #  same 'id', and puts the object with the 'id' into the specified
    #  ViewElements object:
    #---------------------------------------------------------------------------

    def replace_include ( self, view_elements ):
        """ Replaces any items that have an ID with an Include object with
            the same ID, and puts the object with the ID into the specified
            ViewElements object.
        """
        if self.content is not None:
            self.content.replace_include( view_elements )

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of the View:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" version of the View.
        """
        if self.content is None:
            return '()'
        return "( %s )" %  ', '.join(
               [ item.__repr__() for item in self.content.content ] )


########NEW FILE########
__FILENAME__ = view_element
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/18/2004
#
#------------------------------------------------------------------------------

""" Defines the abstract ViewElement class that all trait view template items
    (i.e., View, Group, Item, Include) derive from.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

import re

from string import rfind

from traits.api import HasPrivateTraits, Trait, Bool

from .ui_traits import (ATheme, AnObject, DockStyle, EditorStyle, ExportType,
    HelpId, Image)

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

label_pat  = re.compile( r"^(.*)\[(.*)\](.*)$", re.MULTILINE | re.DOTALL )
label_pat2 = re.compile( r"^(.*){(.*)}(.*)$",   re.MULTILINE | re.DOTALL )

#-------------------------------------------------------------------------------
#  'ViewElement' class (abstract):
#-------------------------------------------------------------------------------

class ViewElement ( HasPrivateTraits ):
    """ An element of a view.
    """

    #---------------------------------------------------------------------------
    #  Replaces any items which have an 'id' with an Include object with the
    #  same 'id', and puts the object with the 'id' into the specified
    #  ViewElements object:
    #---------------------------------------------------------------------------

    def replace_include ( self, view_elements ):
        """ Searches the current object's **content** attribute for objects that
        have an **id** attribute, and replaces each one with an Include object
        with the same **id** value, and puts the replaced object into the
        specified ViewElements object.

        Parameters
        ----------
        view_elements : ViewElements object
            Object containing Group, Item, and Include objects
        """
        pass # Normally overridden in a subclass

    #---------------------------------------------------------------------------
    #  Returns whether or not the object is replacable by an Include object:
    #---------------------------------------------------------------------------

    def is_includable ( self ):
        """ Returns whether the object is replacable by an Include object.
        """
        return False # Normally overridden in a subclass

#-------------------------------------------------------------------------------
#  'DefaultViewElement' class:
#-------------------------------------------------------------------------------

class DefaultViewElement ( ViewElement ):
    """ A view element that can be used as a default value for traits whose
        value is a view element.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The default context object to edit:
    object = AnObject

    # The default editor style to use:
    style = EditorStyle

    # The default dock style to use:
    dock = DockStyle

    # The default notebook tab image to use:
    image = Image

    # The category of elements dragged out of the view:
    export = ExportType

    # Should labels be added to items in a group?
    show_labels = Bool( True )

    # The default theme to use for a contained item:
    item_theme = ATheme

    # The default theme to use for a contained item's label:
    label_theme = ATheme

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# The container trait used by ViewSubElements:
Container = Trait( DefaultViewElement(), ViewElement )

#-------------------------------------------------------------------------------
#  'ViewSubElement' class (abstract):
#-------------------------------------------------------------------------------

class ViewSubElement ( ViewElement ):
    """ Abstract class representing elements that can be contained in a view.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The object this ViewSubElement is contained in; must be a ViewElement.
    container = Container

    # External help context identifier:
    help_id = HelpId

    #---------------------------------------------------------------------------
    #  Splits a string at a specified character:
    #---------------------------------------------------------------------------

    def _split ( self, name, value, char, finder, assign, result ):
        """ Splits a string at a specified character.
        """
        col = finder( value, char )
        if col < 0:
            return value

        items = ( value[:col].strip(), value[col+1:].strip() )
        if items[ assign ] != '':
            setattr( self, name, items[ assign ] )

        return items[ result ]

    #---------------------------------------------------------------------------
    #  Sets an object trait if a specified option string is found:
    #---------------------------------------------------------------------------

    def _option ( self, string, option, name, value ):
        """ Sets a object trait if a specified option string is found.
        """
        col = string.find( option )
        if col >= 0:
            string = string[ : col ] + string[ col + len( option ): ]
            setattr( self, name, value )

        return string

    #---------------------------------------------------------------------------
    #  Parses any of the one character forms of the 'style' trait:
    #---------------------------------------------------------------------------

    def _parse_style ( self, value ):
        """ Parses any of the one-character forms of the **style** trait.
        """
        value = self._option( value, '$', 'style', 'simple' )
        value = self._option( value, '@', 'style', 'custom' )
        value = self._option( value, '*', 'style', 'text' )
        value = self._option( value, '~', 'style', 'readonly' )
        value = self._split( 'style',  value, ';', rfind, 1, 0 )

        return value

    #---------------------------------------------------------------------------
    #  Parses a '[label]' value from the string definition:
    #---------------------------------------------------------------------------

    def _parse_label ( self, value ):
        """ Parses a '[label]' value from the string definition.
        """
        match = label_pat.match( value )
        if match is not None:
            self._parsed_label()
        else:
            match = label_pat2.match( value )

        empty = False
        if match is not None:
            self.label = match.group( 2 ).strip()
            empty      = (self.label == '')
            value      = match.group( 1 ) + match.group( 3 )

        return ( value, empty )

    #---------------------------------------------------------------------------
    #  Handles a label being found in the string definition:
    #---------------------------------------------------------------------------

    def _parsed_label ( self ):
        """ Handles a label being found in the string definition.
        """
        pass

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of a specified trait value:
    #---------------------------------------------------------------------------

    def _repr_value ( self, value, prefix = '', suffix = '', ignore = '' ):
        """ Returns a "pretty print" version of a specified Item trait value.
        """
        if value == ignore:
            return ''

        return '%s%s%s' % ( prefix, value, suffix )

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of a list of traits:
    #---------------------------------------------------------------------------

    def _repr_options ( self, *names ):
        """ Returns a 'pretty print' version of a list of traits.
        """
        result = []
        for name in names:
            value = getattr( self, name )
            if value != self.trait( name ).default_value_for( self, name ):
                result.append( ( name, repr( value ) ) )

        if len( result ) > 0:
            n = max( [ len( name ) for name, value in result ] )
            return ',\n'.join( [ '%s = %s' % ( name.ljust( n ), value )
                                 for name, value in result ] )

        return None

    #---------------------------------------------------------------------------
    #  Indents each line in a specified string by a specified number of spaces:
    #---------------------------------------------------------------------------

    def _indent ( self, string, indent = '    ' ):
        """ Indents each line in a specified string by 4 spaces.
        """
        return '\n'.join( [ indent + s for s in string.split( '\n' ) ] )


########NEW FILE########
__FILENAME__ = view_elements
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/18/2004
#
#------------------------------------------------------------------------------

""" Define the ViewElements class, which is used to define a (typically
    class-based) hierarchical name space of related ViewElement objects.

    Normally there is a ViewElements object associated with each Traits-based
    class, which contains all of the ViewElement objects associated with the
    class. The ViewElements object is also linked to the ViewElements objects
    of its associated class's parent classes.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from __future__ import absolute_import

from traits.api import HasStrictTraits, List, Dict, Str, Int, Any, TraitError

from traits.trait_base import enumerate

from .view_element import ViewElement

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Trait for contents of a ViewElements object
content_trait = Dict( str, ViewElement )

#-------------------------------------------------------------------------------
#  'ViewElements' class:
#-------------------------------------------------------------------------------

class ViewElements ( HasStrictTraits ):
    """ Defines a hierarchical name space of related ViewElement objects.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Dictionary containing the named ViewElement items
    content = content_trait

    #---------------------------------------------------------------------------
    #  Finds a specified ViewElement within the specified (optional) search
    #  context:
    #---------------------------------------------------------------------------

    def find ( self, name, stack = None ):
        """ Finds a specified ViewElement within the specified (optional) search
            context.
        """
        # Assume search starts from the beginning the of the search order:
        i = 0

        # If a stack was specified, see if there is a matching entry in the
        # stack already:
        if stack is not None:
            for ssi in stack:
                if name == ssi.id:
                    # Match found, resume search at next ViewElements object
                    # in the search order:
                    i = ssi.context + 1
                    break

        # Search for a matching name starting at the specified ViewElements
        # object in the search order:
        for j, ves in enumerate( self._get_search_order()[i:] ):
            result = ves.content.get( name )
            if result is not None:
                # Match found. If there is a stack, push matching name and
                # ViewElements context onto it:
                if stack is not None:
                    stack[0:0] = [ SearchStackItem( id      = name,
                                                    context = i + j ) ]

                # Return the ViewElement object that matched the name:
                return result

        # Indicate no match was found:
        return None

    #---------------------------------------------------------------------------
    #  Returns a sorted list of all names accessible from the ViewElements
    #  object that are of a specified (ViewElement) type:
    #---------------------------------------------------------------------------

    def filter_by ( self, klass = None ):
        """ Returns a sorted list of all names accessible from the ViewElements
            object that are of a specified (ViewElement) type.
        """
        if klass is None:
            from . import view
            klass = view.View
        result = []

        # Add each item in the search order which is of the right class and
        # which is not already in the result list:
        for ves in self._get_search_order():
            for name, ve in ves.content.items():
                if isinstance( ve, klass ) and (name not in result):
                    result.append( name )

        # Sort the resulting list of names:
        result.sort()

        # Return the result:
        return result

    #---------------------------------------------------------------------------
    #  Handles the 'parents' list being updated:
    #---------------------------------------------------------------------------

    def _parents__changed ( self ):
        self._search_order = None

    def _parents_items_changed ( self ):
        self._search_order = None

    #---------------------------------------------------------------------------
    #  Returns the current search order (computing it if necessary):
    #---------------------------------------------------------------------------

    def _get_search_order ( self ):
        if self._search_order is None:
            self._search_order = self._mro()
        return self._search_order

    #---------------------------------------------------------------------------
    #  Compute the Python 'C3' algorithm used to determine a class's 'mro'
    #  and apply it to the 'parents' of the ViewElements to determine the
    #  correct search order:
    #---------------------------------------------------------------------------

    def _mro ( self ):
        return self._merge(
                  [ [ self ] ] +
                  [ parent._get_search_order()[:] for parent in self.parents ] +
                  [ self.parents[:] ] )

    def _merge ( self, seqs ):
        result = []
        while True:
            # Remove any empty sequences from the list:
            seqs = [ seq for seq in seqs if len( seq ) > 0 ]
            if len( seqs ) == 0:
                return result

            # Find merge candidates among the sequence heads:
            for seq in seqs:
                candidate = seq[0]
                if len( [ s for s in seqs if candidate in s[1:] ] ) == 0:
                    break
            else:
                raise TraitError, "Inconsistent ViewElements hierarchy"

            # Add the candidate to the result:
            result.append( candidate )

            # Then remove the candidate:
            for seq in seqs:
                if seq[0] == candidate:
                    del seq[0]

    #---------------------------------------------------------------------------
    #  Returns a 'pretty print' version of the ViewElements object:
    #---------------------------------------------------------------------------

    def __repr__ ( self ):
        """ Returns a "pretty print" version of the ViewElements object.
        """
        return self.content.__repr__()

#-------------------------------------------------------------------------------
#  Define forward reference traits:
#-------------------------------------------------------------------------------

ViewElements.add_class_trait( 'parents',       List( ViewElements ) )
ViewElements.add_class_trait( '_search_order', Any )

#-------------------------------------------------------------------------------
#  'SearchStackItem' class:
#-------------------------------------------------------------------------------

class SearchStackItem ( HasStrictTraits ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Name that was looked up
    id = Str

    # Index into the 'mro' list of ViewElements that the ID was found in
    context = Int


########NEW FILE########
__FILENAME__ = animated_gif_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/02/2007
#
#-------------------------------------------------------------------------------

""" Defines an editor for playing animated GIF files.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

# Define the wx version dependent version of the editor:
if wx.__version__[:3] == '2.6':
    from animated_gif_editor_26 import AnimatedGIFEditor
else:
    from animated_gif_editor_28 import AnimatedGIFEditor


########NEW FILE########
__FILENAME__ = animated_gif_editor_26
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/02/2007
#
#-------------------------------------------------------------------------------

""" Defines an editor for playing animated GIF files.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from wx.animate \
    import GIFAnimationCtrl

from traits.api \
    import Bool, Str

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

from pyface.timer.api \
    import do_after

#-------------------------------------------------------------------------------
#  '_AnimatedGIFEditor' class:
#-------------------------------------------------------------------------------

class _AnimatedGIFEditor ( Editor ):
    """ Editor that displays an animated GIF file.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the animated GIF file currently playing?
    playing = Bool( True )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = GIFAnimationCtrl( parent, -1 )
        self.control.GetPlayer().UseBackgroundColour( True )
        self.sync_value( self.factory.playing, 'playing', 'from' )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        control = self.control
        if self.playing:
            control.Stop()

        control.LoadFile( self.value )
        self._file_loaded = True

        # Note: It seems to be necessary to Play/Stop the control to avoid a
        # hard wx crash when 'PlayNextFrame' is called the first time (must be
        # some kind of internal initialization issue):
        control.Play()
        control.Stop()

        if self.playing or self._not_first:
            self._playing_changed()
        else:
            do_after( 300, self._frame_changed )

        self._not_first = True

    #---------------------------------------------------------------------------
    #  Handles the editor 'playing' trait being changed:
    #---------------------------------------------------------------------------

    def _playing_changed ( self ):
        """ Handles the editor 'playing' trait being changed.
        """
        if self._file_loaded:
            try:
                if self.playing:
                    self.control.Play()
                else:
                    player = self.control.GetPlayer()
                    player.SetCurrentFrame( 0 )
                    player.PlayNextFrame()
                    player.Stop()
            except:
                pass

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for animated GIF editors:
class AnimatedGIFEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _AnimatedGIFEditor

    # The optional trait used to control whether the animated GIF file is
    # playing or not:
    playing = Str


########NEW FILE########
__FILENAME__ = animated_gif_editor_28
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/02/2007
#
#-------------------------------------------------------------------------------

""" Defines an editor for playing animated GIF files.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from wx.animate \
    import Animation, AnimationCtrl

from traits.api \
    import Bool, Str

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

#-------------------------------------------------------------------------------
#  '_AnimatedGIFEditor' class:
#-------------------------------------------------------------------------------

class _AnimatedGIFEditor ( Editor ):
    """ Editor that displays an animated GIF file.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the animated GIF file currently playing?
    playing = Bool( True )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._animate = Animation( self.value )
        self.control  = AnimationCtrl( parent, -1, self._animate )
        self.control.SetUseWindowBackgroundColour()
        self.sync_value( self.factory.playing, 'playing', 'from' )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if not self.playing:
            self.control.Stop()

        self.control.LoadFile( self.value )
        self._file_loaded = True

        if self.playing:
            self.control.Play()

    #---------------------------------------------------------------------------
    #  Handles the editor 'playing' trait being changed:
    #---------------------------------------------------------------------------

    def _playing_changed ( self ):
        if self._file_loaded:
            if self.playing:
                self.control.Play()
            else:
                self.control.Stop()

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for animated GIF editors:
class AnimatedGIFEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _AnimatedGIFEditor

    # The optional trait used to control whether the animated GIF file is
    # playing or not:
    playing = Str


########NEW FILE########
__FILENAME__ = array_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/10/2006
#
#------------------------------------------------------------------------------

""" Defines array editors for the WX user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.array_editor file.
from traitsui.editors.array_editor \
    import SimpleEditor as BaseSimpleEditor, ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( BaseSimpleEditor, Editor ):
    """ Simple style of editor for arrays.
    """
    # FIXME: This class has been re-defined here simply so it inherits from the
    # wx Editor class.
    pass

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor(SimpleEditor):

    # Set the value of the readonly trait.
    readonly = True

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = array_view_editor
#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traitsui.ui_editors.array_view_editor \
    import _ArrayViewEditor as BaseArrayViewEditor

from ui_editor \
    import UIEditor

#-------------------------------------------------------------------------------
#  '_ArrayViewEditor' class:
#-------------------------------------------------------------------------------

class _ArrayViewEditor ( BaseArrayViewEditor, UIEditor ):
    pass

#--EOF-------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = basic_editor_factory
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

## Deprecated proxy for the BasicEditorFactory class declared in
# traitsui, declared here just for backward compatibility.

import warnings

from traitsui.basic_editor_factory \
    import BasicEditorFactory as AbstractBasicEditorFactory

#-------------------------------------------------------------------------------
#  'BasicEditorFactory' class
#   Deprecated alias for traitsui.editor_factory.EditorFactory
#-------------------------------------------------------------------------------

class BasicEditorFactory(AbstractBasicEditorFactory):
    """ Deprecated alias for
        traitsui.basic_editor_factory.BasicEditorFactory.
    """

    def __init__(self, *args, **kwds):
        super(BasicEditorFactory, self).__init__(*args, **kwds)
        warnings.warn("DEPRECATED: Use traitsui.basic_editor_factory"
            ".BasicEditorFactory instead.", DeprecationWarning)

#---EOF-------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = boolean_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various Boolean editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.boolean_editor file.
from traitsui.editors.boolean_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

# This needs to be imported in here for use by the editor factory for boolean
# editors (declared in traitsui). The editor factory's text_editor
# method will use the TextEditor in the ui.
from text_editor \
    import SimpleEditor as TextEditor

from constants \
    import ReadonlyColor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for Boolean values, which displays a check box.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = wx.CheckBox( parent, -1, '' )
        wx.EVT_CHECKBOX( parent, self.control.GetId(), self.update_object )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user clicking on the checkbox:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user clicking the checkbox.
        """
        self.value = (self.control.GetValue() != 0)

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.SetValue( self.value )

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( Editor ):
    """ Read-only style of editor for Boolean values, which displays static text
    of either "True" or "False".
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = wx.TextCtrl( parent, -1, '', style = wx.TE_READONLY )
        self.control.SetBackgroundColour( ReadonlyColor )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #
    #  (Should normally be overridden in a subclass)
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.value:
            self.control.SetValue( 'True' )
        else:
            self.control.SetValue( 'False' )

########NEW FILE########
__FILENAME__ = button_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various button editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------


import wx

from traits.api \
    import Str

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.button_editor file.
from traitsui.editors.button_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style editor for a button.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The button label
    label = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        label = self.factory.label or self.item.get_label( self.ui )
        self.control = wx.Button( parent, -1, self.string_value( label ) )
        self.sync_value( self.factory.label_value, 'label', 'from' )
        wx.EVT_BUTTON( parent, self.control.GetId(), self.update_object )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the 'label' trait being changed:
    #---------------------------------------------------------------------------

    def _label_changed ( self, label ):
        self.control.SetLabel( self.string_value( label ) )

    #---------------------------------------------------------------------------
    #  Handles the user clicking the button by setting the value on the object:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user clicking the button by setting the factory value
            on the object.
        """
        factory    = self.factory
        self.value = factory.value

        # If there is an associated view, then display it:
        if factory.view is not None:
            self.object.edit_traits( view   = factory.view,
                                     parent = self.control )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        wx.EVT_BUTTON( self.control.GetParent(), self.control.GetId(), None )

        super( SimpleEditor, self ).dispose()

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style editor for a button, which can contain an image.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        from pyface.image_button import ImageButton

        factory       = self.factory
        self._control = ImageButton(
            parent,
            label          = self.string_value( factory.label ),
            image          = factory.image,
            style          = factory.style,
            orientation    = factory.orientation,
            width_padding  = factory.width_padding,
            height_padding = factory.height_padding
        )
        self.control = self._control.control
        self._control.on_trait_change( self.update_object, 'clicked',
                                       dispatch = 'ui' )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self._control.on_trait_change( self.update_object, 'clicked',
                                       remove = True )

        super( CustomEditor, self ).dispose()

### EOF #######################################################################


########NEW FILE########
__FILENAME__ = check_list_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various editors for multi-selection enumerations, for the
wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import logging

import wx

from string \
    import capitalize

from traits.api \
    import List, Str, TraitError

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.check_list_editor file.
from traitsui.editors.check_list_editor \
    import ToolkitEditorFactory

from editor_factory \
    import TextEditor as BaseTextEditor

from editor \
    import EditorWithList

from helper \
    import TraitsUIPanel

logger = logging.getLogger(__name__)

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( EditorWithList ):
    """ Simple style of editor for checklists, which displays a combo box.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Checklist item names
    names = List( Str )

    # Checklist item values
    values = List

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.create_control( parent )
        super( SimpleEditor, self ).init( parent )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Creates the initial editor control:
    #---------------------------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the initial editor control.
        """
        self.control = wx.Choice( parent, -1,
                                  wx.Point( 0, 0 ), wx.Size( 100, 20 ), [] )
        wx.EVT_CHOICE( parent, self.control.GetId(), self.update_object )

    #---------------------------------------------------------------------------
    #  Handles the list of legal check list values being updated:
    #---------------------------------------------------------------------------

    def list_updated ( self, values ):
        """ Handles updates to the list of legal checklist values.
        """
        sv = self.string_value
        if (len( values ) > 0) and isinstance( values[0], basestring ):
           values = [ ( x, sv( x, capitalize ) ) for x in values ]
        self.values = valid_values = [ x[0] for x in values ]
        self.names  =                [ x[1] for x in values ]

        # Make sure the current value is still legal:
        modified  = False
        cur_value = parse_value( self.value )
        for i in range( len( cur_value ) - 1, -1, -1 ):
            if cur_value[i] not in valid_values:
                try:
                    del cur_value[i]
                    modified = True
                except TypeError, e:
                    logger.warn('Unable to remove non-current value [%s] from '
                        'values %s', cur_value[i], values)
        if modified:
            if isinstance( self.value, basestring ):
                cur_value = ','.join( cur_value )
            self.value = cur_value

        self.rebuild_editor()

    #---------------------------------------------------------------------------
    #  Rebuilds the editor after its definition is modified:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the editor after its definition is modified.
        """
        control = self.control
        control.Clear()
        for name in self.names:
            control.Append( name )

        self.update_editor()

    #----------------------------------------------------------------------------
    #  Handles the user selecting a new value from the combo box:
    #----------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user selecting a new value from the combo box.
        """
        value = self.values[ self.names.index( event.GetString() ) ]
        if type( self.value ) is not str:
           value = [ value ]

        self.value = value

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        try:
            self.control.SetSelection(
                             self.values.index( parse_value( self.value )[0] ) )
        except:
            pass

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of editor for checklists, which displays a set of check
        boxes.
    """

    #---------------------------------------------------------------------------
    #  Creates the initial editor control:
    #---------------------------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the initial editor control.
        """
        # Create a panel to hold all of the check boxes
        self.control = panel = TraitsUIPanel( parent, -1 )

    #---------------------------------------------------------------------------
    #  Rebuilds the editor after its definition is modified:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the editor after its definition is modified.
        """
        panel = self.control
        panel.SetSizer( None )
        panel.DestroyChildren()

        cur_value = parse_value( self.value )

        # Create a sizer to manage the radio buttons:
        labels = self.names
        values = self.values
        n      = len( labels )
        cols   = self.factory.cols
        rows   = (n + cols - 1) / cols
        incr   = [ n / cols ] * cols
        rem    = n % cols

        for i in range( cols ):
            incr[i] += (rem > i)
        incr[-1] = -(reduce( lambda x, y: x + y, incr[:-1], 0 ) - 1)

        if cols > 1:
           sizer = wx.GridSizer( 0, cols, 2, 4 )
        else:
           sizer = wx.BoxSizer( wx.VERTICAL )

        # Add the set of all possible choices:
        index = 0
        for i in range( rows ):
            for j in range( cols ):
                if n > 0:
                    label   = labels[ index ]
                    control = wx.CheckBox( panel, -1, label )
                    control.value = value = values[ index ]
                    control.SetValue( value in cur_value )
                    wx.EVT_CHECKBOX( panel, control.GetId(), self.update_object)
                    index += incr[j]
                    n     -= 1
                else:
                    control = wx.CheckBox( panel, -1, '' )
                    control.Show( False )

                sizer.Add( control, 0, wx.NORTH, 5 )

        # Lay out the controls:
        panel.SetSizerAndFit( sizer )

        # FIXME: There are cases where one of the parent panel's of the check
        # list editor has a fixed 'min size' which prevents the check list
        # editor from expanding correctly, so we currently are making sure
        # that all of the parent panels do not have a fixed min size before
        # doing the layout/refresh:
        parent = panel.GetParent()
        while isinstance( parent, wx.Panel ):
            parent.SetMinSize( wx.Size( -1, -1 ) )
            panel  = parent
            parent = parent.GetParent()

        panel.Layout()
        panel.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the user clicking one of the 'custom' check boxes:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user clicking one of the custom check boxes.
        """
        control   = event.GetEventObject()
        cur_value = parse_value( self.value )
        if control.GetValue():
            cur_value.append( control.value )
        else:
            cur_value.remove( control.value )
        if isinstance(self.value, basestring):
            cur_value = ','.join( cur_value )
        self.value = cur_value

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        new_values = parse_value( self.value )
        for control in self.control.GetChildren():
            if control.IsShown():
               control.SetValue( control.value in new_values )

#-------------------------------------------------------------------------------
#  'TextEditor' class:
#-------------------------------------------------------------------------------

class TextEditor ( BaseTextEditor ):
    """ Text style of editor for checklists, which displays a text field.
    """

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user changing the contents of the edit control.
        """
        try:
            value = self.control.GetValue()
            value = eval( value )
        except:
            pass
        try:
            self.value = value
        except TraitError, excp:
            pass

#-------------------------------------------------------------------------------
#  Parse a value into a list:
#-------------------------------------------------------------------------------

def parse_value ( value ):
    """ Parses a value into a list.
    """
    if value is None:
       return []

    if type( value ) is not str:
       return value[:]

    return [ x.strip() for x in value.split( ',' ) ]

### EOF ########################################################################


########NEW FILE########
__FILENAME__ = code_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/27/2006
#
#------------------------------------------------------------------------------

""" Defines a source code editor for the wxPython user interface toolkit,
    useful for tools such as debuggers.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx
import wx.stc as stc

from traits.api \
    import Str, List, Int, Event, Bool, TraitError, on_trait_change

from traits.trait_base \
    import SequenceTypes

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.code_editor file.
from traitsui.editors.code_editor \
    import ToolkitEditorFactory

from pyface.api \
    import PythonEditor

from pyface.util.python_stc \
    import faces

from editor \
    import Editor

from constants \
    import OKColor, ErrorColor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Marker line constants:

# Marks a marked line
MARK_MARKER = 0

# Marks a line matching the current search
SEARCH_MARKER = 1

# Marks the currently selected line
SELECTED_MARKER = 2

#-------------------------------------------------------------------------------
#  'SourceEditor' class:
#-------------------------------------------------------------------------------

class SourceEditor ( Editor ):
    """ Editor for source code, which displays a PyFace PythonEditor.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The code editor is scrollable. This value overrides the default.
    scrollable = True

    # Is the editor read only?
    readonly = Bool( False )

    # The currently selected line
    selected_line = Int

    # The currently selected text
    selected_text = Str

    # The list of line numbers to mark
    mark_lines = List( Int )

    # The current line number
    line = Event

    # The current column
    column = Event

    # calltip clicked event
    calltip_clicked = Event

    # The STC lexer use
    lexer = Int

    # The lines to be dimmed
    dim_lines = List(Int)
    dim_color = Str
    _dim_style_number = Int(16) # 0-15 are reserved for the python lexer

    # The lines to have squiggles drawn under them
    squiggle_lines = List(Int)
    squiggle_color = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory      = self.factory
        self._editor = editor  = PythonEditor( parent,
                                 show_line_numbers = factory.show_line_numbers )
        self.control = control = editor.control

        # There are a number of events which aren't well documented that look
        # to be useful in future implmentations, below are a subset of the
        # events that look interesting:
        #    EVT_STC_AUTOCOMP_SELECTION
        #    EVT_STC_HOTSPOT_CLICK
        #    EVT_STC_HOTSPOT_DCLICK
        #    EVT_STC_DOUBLECLICK
        #    EVT_STC_MARGINCLICK

        control.SetSize( wx.Size( 300, 124 ) )

        # Clear out the goofy hotkeys for zooming text
        control.CmdKeyClear(ord('B'), stc.STC_SCMOD_CTRL)
        control.CmdKeyClear(ord('N'), stc.STC_SCMOD_CTRL)

        # Set up the events
        wx.EVT_KILL_FOCUS( control, self.wx_update_object )
        stc.EVT_STC_CALLTIP_CLICK( control, control.GetId(),
                                   self._calltip_clicked )

        if factory.auto_scroll and (factory.selected_line != ''):
            wx.EVT_SIZE( control, self._update_selected_line )

        if factory.auto_set:
            editor.on_trait_change( self.update_object, 'changed',
                                    dispatch = 'ui' )

        if factory.key_bindings is not None:
            editor.on_trait_change( self.key_pressed, 'key_pressed',
                                    dispatch = 'ui' )

        if self.readonly:
            control.SetReadOnly( True )

        # Set up the lexer
        control.SetLexer(stc.STC_LEX_CONTAINER)
        control.Bind(stc.EVT_STC_STYLENEEDED, self._style_needed)
        try:
            self.lexer = getattr(stc, 'STC_LEX_' + self.factory.lexer.upper())
        except AttributeError:
            self.lexer = stc.STC_LEX_NULL

        # Define the markers we use:
        control.MarkerDefine( MARK_MARKER, stc.STC_MARK_BACKGROUND,
                              background = factory.mark_color_ )
        control.MarkerDefine( SEARCH_MARKER, stc.STC_MARK_BACKGROUND,
                              background = factory.search_color_ )
        control.MarkerDefine( SELECTED_MARKER, stc.STC_MARK_BACKGROUND,
                              background = factory.selected_color_ )

        # Make sure the editor has been initialized:
        self.update_editor()

        # Set up any event listeners:
        self.sync_value( factory.mark_lines, 'mark_lines', 'from',
                         is_list = True )
        self.sync_value( factory.selected_line, 'selected_line', 'from' )
        self.sync_value( factory.selected_text, 'selected_text', 'to' )
        self.sync_value( factory.line, 'line' )
        self.sync_value( factory.column, 'column' )
        self.sync_value( factory.calltip_clicked, 'calltip_clicked')

        self.sync_value(factory.dim_lines, 'dim_lines', 'from', is_list=True)
        if self.factory.dim_color == '':
            self.dim_color = 'dark grey'
        else:
            self.sync_value(factory.dim_color, 'dim_color', 'from')

        self.sync_value(factory.squiggle_lines, 'squiggle_lines', 'from',
                        is_list=True)
        if factory.squiggle_color == '':
            self.squiggle_color = 'red'
        else:
            self.sync_value(factory.squiggle_color, 'squiggle_color', 'from')

        # Check if we need to monitor the line or column position being changed:
        if (factory.line != '') or (factory.column != '') or \
                (factory.selected_text != ''):
            stc.EVT_STC_UPDATEUI( control, control.GetId(),
                                  self._position_changed )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def wx_update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        self.update_object()
        event.Skip()

    def update_object ( self ):
        """ Handles the user entering input data in the edit control.
        """
        if not self._locked:
            try:
                value = self.control.GetText()
                if isinstance( self.value, SequenceTypes ):
                    value = value.split()
                self.value = value
                self.control.SetBackgroundColour( OKColor )
                self.control.Refresh()
            except TraitError, excp:
                pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self._locked = True
        new_value    = self.value
        if isinstance( new_value, SequenceTypes ):
            new_value = '\n'.join( [ line.rstrip() for line in new_value ] )
        control = self.control
        if control.GetText() != new_value:
            readonly = control.GetReadOnly()
            control.SetReadOnly( False )
            l1  = control.GetFirstVisibleLine()
            pos = control.GetCurrentPos()
            control.SetText( new_value )
            control.GotoPos( pos )
            control.ScrollToLine( l1 )
            control.SetReadOnly( readonly )
            self._mark_lines_changed()
            self._selected_line_changed()
            self._style_document()

        self._locked = False

    #---------------------------------------------------------------------------
    #  Handles the calltip being clicked:
    #---------------------------------------------------------------------------

    def _calltip_clicked ( self, event ):
        self.calltip_clicked = True

    #---------------------------------------------------------------------------
    #  Handles the set of 'marked lines' being changed:
    #---------------------------------------------------------------------------

    def _mark_lines_changed ( self ):
        """ Handles the set of marked lines being changed.
        """
        lines   = self.mark_lines
        control = self.control
        lc      = control.GetLineCount()
        control.MarkerDeleteAll( MARK_MARKER )

        for line in lines:
            if 0 < line <= lc:
                control.MarkerAdd( line - 1, MARK_MARKER )

        control.Refresh()

    def _mark_lines_items_changed ( self ):
        self._mark_lines_changed()

    #---------------------------------------------------------------------------
    #  Handles the currently 'selected line' being changed:
    #---------------------------------------------------------------------------

    def _selected_line_changed ( self ):
        """ Handles a change in which line is currently selected.
        """
        line    = self.selected_line
        control = self.control
        line    = max( 1, min( control.GetLineCount(), line ) ) - 1
        control.MarkerDeleteAll( SELECTED_MARKER )
        control.MarkerAdd( line, SELECTED_MARKER )
        control.GotoLine( line )
        if self.factory.auto_scroll:
            control.ScrollToLine( line - (control.LinesOnScreen() / 2) )

        control.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the 'line' trait being changed:
    #---------------------------------------------------------------------------

    def _line_changed ( self, line ):
        if not self._locked:
            self.control.GotoLine( line - 1 )

    #---------------------------------------------------------------------------
    #  Handles the 'column' trait being changed:
    #---------------------------------------------------------------------------

    def _column_changed ( self, column ):
        if not self._locked:
            control = self.control
            line    = control.LineFromPosition( control.GetCurrentPos() )
            control.GotoPos( control.PositionFromLine( line ) + column - 1 )

    #---------------------------------------------------------------------------
    #  Handles the cursor position being changed:
    #---------------------------------------------------------------------------

    def _position_changed ( self, event ):
        """ Handles the cursor position being changed.
        """
        control      = self.control
        pos          = control.GetCurrentPos()
        line         = control.LineFromPosition( pos )
        self._locked = True
        self.line    = line + 1
        self.column  = pos - control.PositionFromLine( line ) + 1
        self._locked = False
        self.selected_text = control.GetSelectedText()

    #---------------------------------------------------------------------------
    #  Handles a key being pressed within the editor:
    #---------------------------------------------------------------------------

    def key_pressed ( self, event ):
        """ Handles a key being pressed within the editor.
        """
        self.factory.key_bindings.do( event.event, self.ui.handler,
                                      self.ui.info )

    #---------------------------------------------------------------------------
    #  Handles the styling of the editor:
    #---------------------------------------------------------------------------

    def _dim_color_changed(self):
        self.control.StyleSetForeground(self._dim_style_number, self.dim_color)
        self.control.StyleSetFaceName(self._dim_style_number, "courier new")
        self.control.StyleSetSize(self._dim_style_number, faces['size'])
        self.control.Refresh()

    def _squiggle_color_changed(self):
        self.control.IndicatorSetStyle(2, stc.STC_INDIC_SQUIGGLE)
        self.control.IndicatorSetForeground(2, self.squiggle_color)
        self.control.Refresh()

    @on_trait_change('dim_lines, squiggle_lines')
    def _style_document(self):
        """ Force the STC to fire a STC_STYLENEEDED event for the entire
            document.
        """
        self.control.ClearDocumentStyle()
        self.control.Colourise(0, -1)
        self.control.Refresh()

    def _style_needed(self, event):
        """ Handles an STC request for styling for some area.
        """
        position = self.control.GetEndStyled()
        start_line = self.control.LineFromPosition(position)
        end = event.GetPosition()
        end_line = self.control.LineFromPosition(end)

        # Fixes a strange a bug with the STC widget where creating a new line
        # after a dimmed line causes it to mysteriously lose its styling
        if start_line in self.dim_lines:
            start_line -= 1

        # Trying to Colourise only the lines that we want does not seem to work
        # so we do the whole area and then override the styling on certain lines
        if self.lexer != stc.STC_LEX_NULL:
            self.control.SetLexer(self.lexer)
            self.control.Colourise(position, end)
            self.control.SetLexer(stc.STC_LEX_CONTAINER)

        for line in xrange(start_line, end_line+1):
            # We don't use LineLength here because it includes newline
            # characters. Styling these leads to strange behavior.
            position = self.control.PositionFromLine(line)
            style_length = self.control.GetLineEndPosition(line) - position

            if line+1 in self.dim_lines:
                # Set styling mask to only style text bits, not indicator bits
                self.control.StartStyling(position, 0x1f)
                self.control.SetStyling(style_length, self._dim_style_number)
            elif self.lexer == stc.STC_LEX_NULL:
                self.control.StartStyling(position, 0x1f)
                self.control.SetStyling(style_length, stc.STC_STYLE_DEFAULT)

            if line+1 in self.squiggle_lines:
                self.control.StartStyling(position, stc.STC_INDIC2_MASK)
                self.control.SetStyling(style_length, stc.STC_INDIC2_MASK)
            else:
                self.control.StartStyling(position, stc.STC_INDIC2_MASK)
                self.control.SetStyling(style_length, stc.STC_STYLE_DEFAULT)

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        self.control.SetBackgroundColour( ErrorColor )
        self.control.Refresh()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self.factory.auto_set:
            self._editor.on_trait_change( self.update_object, 'changed',
                                          remove = True )
        if self.factory.key_bindings is not None:
            self._editor.on_trait_change( self.key_pressed, 'key_pressed',
                                          remove = True )

        wx.EVT_KILL_FOCUS( self.control, None )

        super( SourceEditor, self ).dispose()

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if self.factory.key_bindings is not None:
            key_bindings = prefs.get( 'key_bindings' )
            if key_bindings is not None:
                self.factory.key_bindings.merge( key_bindings )

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        return { 'key_bindings': self.factory.key_bindings }

# Define the simple, custom, text and readonly editors, which will be accessed
# by the editor factory for code editors.

CustomEditor = SimpleEditor = TextEditor = SourceEditor

class ReadonlyEditor(SourceEditor):

    # Set the value of the readonly trait.
    readonly = True

### EOF ########################################################################

########NEW FILE########
__FILENAME__ = color_column
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#
#------------------------------------------------------------------------------

""" Table column object for Color traits.
"""

import warnings
warnings.warn("traitsui.wx.color_column is deprecated. Use the "
    "backend-independent implementation in traitsui.color_column")

from traitsui.color_column import ColorColumn


########NEW FILE########
__FILENAME__ = color_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#------------------------------------------------------------------------------

""" Defines the various color editors for the Wx user interface toolkit.
"""

#------------------------------------------------------------------------------
#  Imports:
#------------------------------------------------------------------------------

import wx
import wx.combo

from traits.api import List, TraitError
from traitsui.editors.color_editor \
    import ToolkitEditorFactory as BaseToolkitEditorFactory

from editor_factory import SimpleEditor as BaseSimpleEditor
from editor_factory import ReadonlyEditor as BaseReadonlyEditor
from editor_factory import TextEditor as BaseTextEditor

from color_trait import w3c_color_database
from helper import TraitsUIPanel

# Version dependent imports (ColourPtr not defined in wxPython 2.5):
try:
    ColorTypes = (wx.Colour, wx.ColourPtr)
except:
    ColorTypes = wx.Colour


#---------------------------------------------------------------------------
#  The Wx ToolkitEditorFactory class.
#---------------------------------------------------------------------------

class ToolkitEditorFactory(BaseToolkitEditorFactory):
    """ Wx editor factory for color editors.
    """

    def to_wx_color(self, editor, color=None):
        """ Gets the wxPython color equivalent of the object trait.
        """
        if color is None:
            if self.mapped:
                color = getattr(editor.object, editor.name + '_')
            else:
                color = getattr(editor.object, editor.name)

        if isinstance(color, tuple):
            color = wx.Colour(*[int(round(c * 255.0)) for c in color])
        return color

    #--------------------------------------------------------------------------
    #  Gets the application equivalent of a wxPython value:
    #--------------------------------------------------------------------------

    def from_wx_color(self, color):
        """ Gets the application equivalent of a wxPython value.
        """
        return color.Red(), color.Green(), color.Blue()

    #--------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #--------------------------------------------------------------------------

    def str_color(self, color):
        """ Returns the text representation of a specified color value.
        """
        if isinstance(color, ColorTypes):
            alpha = color.Alpha()
            if alpha == 255:
                return "rgb(%d,%d,%d)" % (
                        color.Red(), color.Green(), color.Blue())

            return "rgb(%d,%d,%d,%d)" % (
                    color.Red(), color.Green(), color.Blue(), alpha)

        return str(color)


#------------------------------------------------------------------------------
#  'ColorComboBox' class:
#------------------------------------------------------------------------------

class ColorComboBox(wx.combo.OwnerDrawnComboBox):
    def OnDrawItem(self, dc, rect, item, flags):

        r = wx.Rect(rect.x, rect.y, rect.width, rect.height)
        r.Deflate(3, 0)
        swatch_size = r.height - 2

        color_name = self.GetString(item)

        dc.DrawText(color_name, r.x + 3,
                    r.y + (r.height - dc.GetCharHeight()) / 2)

        if color_name == 'custom':
            swatch = wx.Rect(r.x + r.width - swatch_size, r.y + 1,
                             swatch_size, swatch_size)
            dc.GradientFillLinear(swatch, wx.Colour(255, 255, 0),
                                  wx.Colour(0, 0, 255))
        else:
            color = w3c_color_database.Find(color_name)

            brush = wx.Brush(color)
            dc.SetBrush(brush)
            dc.DrawRectangle(r.x + r.width - swatch_size, r.y + 1,
                             swatch_size, swatch_size)


#------------------------------------------------------------------------------
#  'SimpleColorEditor' class:
#------------------------------------------------------------------------------

class SimpleColorEditor(BaseSimpleEditor):
    """ Simple style of color editor, which displays a text field whose
    background color is the color value. Selecting the text field displays
    a dialog box for selecting a new color value.
    """

    #--------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #--------------------------------------------------------------------------

    choices = List()

    def _choices_default(self):
        """ by default, uses the W3C 16 color names.
        """
        return ['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green',
                'lime', 'maroon', 'navy', 'olive', 'purple', 'red',
                'silver', 'teal', 'white', 'yellow', 'custom']

    def init(self, parent):
        """
        Finishes initializing the editor by creating the underlying widget.
        """
        current_color = self.factory.to_wx_color(self)
        current_color_name = current_color.GetAsString()

        self.control = ColorComboBox(parent, -1, current_color_name,
                                wx.Point(0, 0), wx.Size(40, -1), self.choices,
                                style=wx.wx.CB_READONLY)

        self.control.Bind(wx.EVT_COMBOBOX, self.color_selected)
        return

    #--------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #--------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        current_color = self.factory.to_wx_color(self)
        self.control.SetValue(self.string_value(current_color))

    def color_selected(self, event):
        """
        Event for when color is selected
        """

        color_name = self.choices[event.Selection]

        if color_name == 'custom':
            color_dialog = wx.ColourDialog(self.control)
            result = color_dialog.ShowModal()
            if result == wx.ID_CANCEL:
                return

            color = color_dialog.GetColourData().GetColour()
            self.value = self.factory.from_wx_color(color)
        else:
            try:
                color = w3c_color_database.Find(color_name)
                self.value = self.factory.from_wx_color(color)
            except ValueError:
                pass

        return

    def string_value(self, color):
        """ Returns the text representation of a specified color value.
        """
        color_name = w3c_color_database.FindName(color)
        if color_name != '':
            return color_name

        return color.GetAsString()


#------------------------------------------------------------------------------
#  'CustomColorEditor' class:
#------------------------------------------------------------------------------

class CustomColorEditor(BaseSimpleEditor):
    """ Simple style of color editor, which displays a text field whose
    background color is the color value. Selecting the text field displays
    a dialog box for selecting a new color value.
    """

    #--------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #--------------------------------------------------------------------------

    def init(self, parent):
        """
        Finishes initializing the editor by creating the underlying widget.
        """
        self.control = self._panel = parent = TraitsUIPanel(parent, -1)
        sizer = wx.BoxSizer(wx.HORIZONTAL)

        # 'text_control' is the text display of the color.
        text_control = wx.TextCtrl(parent, -1, self.str_value,
                                   style=wx.TE_PROCESS_ENTER)
        wx.EVT_KILL_FOCUS(text_control, self.update_object)
        wx.EVT_TEXT_ENTER(parent, text_control.GetId(), self.update_object)

        # 'button_control' shows the 'Edit' button.
        button_control = wx.Button(parent, label='Edit', style=wx.BU_EXACTFIT)
        wx.EVT_BUTTON(button_control, button_control.GetId(),
                      self.open_color_dialog)

        sizer.Add(text_control, wx.ALIGN_LEFT)
        sizer.AddSpacer(8)
        sizer.Add(button_control, wx.ALIGN_RIGHT)
        self.control.SetSizer(sizer)

        self._text_control = text_control
        self._button_control = button_control

        self.set_tooltip()

        return

    def update_object(self, event):
        """ Handles the user changing the contents of the edit control.
        """
        if not isinstance(event, wx._core.CommandEvent):
            return
        try:
            # The TextCtrl object was saved as self._text_control in init().
            value = self._text_control.GetValue()
            self.value = w3c_color_database.Find(value)
            self.set_color()
        except TraitError:
            pass

    def set_color(self):
        # The CustomColorEditor uses this method instead of the global
        # set_color function.
        color = self.factory.to_wx_color(self)
        self._text_control.SetBackgroundColour(color)
        self.control.SetBackgroundColour(color)
        self._text_control.SetValue(self.string_value(color))

    #--------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #--------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.set_color()

    def open_color_dialog(self, event):
        """ Opens the color dialog and sets the value upon return
        """
        color_data = wx.ColourData()
        color_data.SetColour(self.value)

        color_dialog = wx.ColourDialog(self.control, color_data)
        result = color_dialog.ShowModal()
        if result == wx.ID_CANCEL:
            return

        color = color_dialog.GetColourData().GetColour()
        self.value = color
        self.set_color()

    def color_selected(self, event):
        """
        Event for when color is selected
        """
        color = event.GetColour()
        try:
            self.value = self.factory.from_wx_color(color)
        except ValueError:
            pass

        return

    def string_value(self, color):
        """ Returns the text representation of a specified color value.
        """
        color_name = w3c_color_database.FindName(color)
        if color_name != '':
            return color_name

        return self.factory.str_color(color)


#------------------------------------------------------------------------------
#  'ReadonlyColorEditor' class:
#------------------------------------------------------------------------------

class ReadonlyColorEditor(BaseReadonlyEditor):
    """ Read-only style of color editor, which displays a read-only text field
    whose background color is the color value.
    """

    #--------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #--------------------------------------------------------------------------

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = wx.TextCtrl(parent, style=wx.TE_READONLY)

    #--------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #--------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        #super(ReadonlyColorEditor, self).update_editor()
        self.control.SetValue(self.string_value(self.value))
        set_color(self)

    #--------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #--------------------------------------------------------------------------

    def string_value(self, color):
        """ Returns the text representation of a specified color value.
        """
        color_name = w3c_color_database.FindName(color)
        if color_name != '':
            return color_name

        return self.factory.str_color(color)


#------------------------------------------------------------------------------
#  'ReadonlyColorEditor' class:
#------------------------------------------------------------------------------

class TextColorEditor(BaseTextEditor):
    """ Text style of color editor, which displays a text field
    whose background color is the color value.
    """

    #--------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #--------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.SetValue(self.string_value(self.value))
        set_color(self)

    def update_object(self, event):
        """ Handles the user changing the contents of the edit control.
        """
        if not isinstance(event, wx._core.CommandEvent):
            return
        try:
            self.value = w3c_color_database.Find(self.control.GetValue())
            set_color(self)
        except TraitError:
            pass

    #--------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #--------------------------------------------------------------------------

    def string_value(self, color):
        """ Returns the text representation of a specified color value.
        """
        color_name = w3c_color_database.FindName(color)
        if color_name != '':
            return color_name

        return self.factory.str_color(color)


#------------------------------------------------------------------------------
#   Sets the color of the specified editor's color control:
#------------------------------------------------------------------------------

def set_color(editor):
    """  Sets the color of the specified color control.
    """
    color = editor.factory.to_wx_color(editor)
    editor.control.SetBackgroundColour(color)


# Define the SimpleEditor, CustomEditor, etc. classes which are used by the
# editor factory for the color editor.
SimpleEditor = SimpleColorEditor
CustomEditor = CustomColorEditor
TextEditor = TextColorEditor
ReadonlyEditor = ReadonlyColorEditor

########NEW FILE########
__FILENAME__ = color_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/22/2004
#
#------------------------------------------------------------------------------

""" Trait definition for a wxPython-based color.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------
import wx

from traits.api \
    import Trait, TraitError

# Version dependent imports (ColourPtr not defined in wxPython 2.5):
try:
    ColourPtr = wx.ColourPtr
except:
    class ColourPtr ( object ): pass


#-------------------------------------------------------------------------------
#  W3CColourDatabase
#-------------------------------------------------------------------------------

class W3CColourDatabase(object):
    """ Proxy for the ColourDatabase which allows for finding W3C colors.

        This class is necessary because the wx 'green' is the W3C 'lime',
        and we need some means to lookup the color names since wx has
        only a few hardcoded.

        This class is a proxy because AddColour expects a wx.ColourDatabase
        instance, not an instance of a subclass
    """


    _database = wx.ColourDatabase()

    def __init__(self):
        self._color_names = ['aqua', 'black', 'blue', 'fuchsia', 'gray',
                             'green', 'lime', 'maroon', 'navy', 'olive',
                             'purple', 'red', 'silver', 'teal', 'white',
                             'yellow']

        self.AddColour('aqua', wx.Colour(0, 0xff, 0xff, 255))
        self.AddColour('fuchsia', wx.Colour(0xff, 0, 0xff, 255))
        self.AddColour('green', wx.Colour(0, 0x80, 0, 255))
        self.AddColour('lime', wx.Colour(0, 0xff, 0, 255))
        self.AddColour('maroon', wx.Colour(0x80, 0x0, 0, 255))
        self.AddColour('navy', wx.Colour(0x00, 0x0, 0x80, 255))
        self.AddColour('olive', wx.Colour(0x80, 0x80, 0, 255))
        self.AddColour('purple', wx.Colour(0x80, 0x00, 0x80, 255))
        self.AddColour('silver', wx.Colour(0xc0, 0xc0, 0xc0, 255))
        self.AddColour('teal', wx.Colour(0, 0x80, 0x80, 255))

    def AddColour(self, name, color):
        if name not in self._color_names:
            self._color_names.append(name)
        return self._database.AddColour(name, color)

    def Find(self, color_name):
        return self._database.Find(color_name)

    def FindName(self, color):
        for color_name in self._color_names:
            if self.Find(color_name) == color:
                return color_name

        return ''

w3c_color_database = W3CColourDatabase()

#-------------------------------------------------------------------------------
#  Convert a number into a wxColour object:
#-------------------------------------------------------------------------------

def tuple_to_wxcolor(tup):
    if 3 <= len(tup) <= 4:
        for c in tup:
            if not isinstance(c, int):
                raise TraitError

        return wx.Colour(*tup)
    else:
        raise TraitError

def convert_to_color ( object, name, value ):
    """ Converts a number into a wxColour object.
    """
    if isinstance( value, tuple ):
        return tuple_to_wxcolor(value)

    elif isinstance( value, ColourPtr ):
        return wx.Colour( value.Red(), value.Green(), value.Blue() )

    elif isinstance( value, wx.Colour ):
        return value

    elif isinstance( value, str ):

        if value in standard_colors:
            return standard_colors[value]

        # Check for tuple-ness
        tmp = value.strip()
        if tmp.startswith("(") and tmp.endswith(")") and tmp.count(",") in (2,3):
            tup = eval(tmp)
            return tuple_to_wxcolor(tup)

    elif isinstance( value, int ):
        num = int( value )
        return wx.Colour( num / 0x10000, (num / 0x100) & 0xFF, num & 0xFF )

    raise TraitError

convert_to_color.info = ('a string of the form (r,g,b) or (r,g,b,a) where r, '
                         'g, b, and a are integers from 0 to 255, a wx.Colour '
                         'instance, an integer which in hex is of the form '
                         '0xRRGGBB, where RR is red, GG is green, and BB is '
                         'blue')

#-------------------------------------------------------------------------------
#  Standard colors:
#-------------------------------------------------------------------------------

standard_colors = {}
for name in [ 'aquamarine', 'black', 'blue', 'blue violet', 'brown',
              'cadet blue', 'coral', 'cornflower blue', 'cyan', 'dark grey',
              'dark green', 'dark olive green', 'dark orchid',
              'dark slate blue', 'dark slate grey', 'dark turquoise',
              'dim grey', 'firebrick', 'forest green', 'gold', 'goldenrod',
              'grey', 'green', 'green yellow', 'indian red', 'khaki',
              'light blue', 'light grey', 'light steel blue', 'lime green',
              'magenta', 'maroon', 'medium aquamarine', 'medium blue',
              'medium forest green', 'medium goldenrod', 'medium orchid',
              'medium sea green', 'medium slate blue', 'medium spring green',
              'medium turquoise', 'medium violet red', 'midnight blue', 'navy',
              'orange', 'orange red', 'orchid', 'pale green', 'pink', 'plum',
              'purple', 'red', 'salmon', 'sea green', 'sienna', 'sky blue',
              'slate blue', 'spring green', 'steel blue', 'tan', 'thistle',
              'turquoise', 'violet', 'violet red', 'wheat', 'white', 'yellow',
              'yellow green' ]:
    try:
        wx_color = w3c_color_database.Find(name)
        standard_colors[ name ] = convert_to_color( None, None,
                                                    wx_color )
    except:
        pass

#-------------------------------------------------------------------------------
#  Define wxPython specific color traits:
#-------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the ColorEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a Color trait which lead to this file getting
# imported. This leads to a circular import when declaring a Color trait.
def get_color_editor(*args, **traits):
    from color_editor import ToolkitEditorFactory
    return ToolkitEditorFactory(*args, **traits)

def WxColor ( default = 'white', allow_none = False, **metadata ):
    """ Defines wxPython-specific color traits.
    """

    if allow_none:
        return Trait( default, None, standard_colors, convert_to_color,
                      editor = get_color_editor, **metadata )

    return Trait( default, standard_colors, convert_to_color,
                  editor = get_color_editor, **metadata )

########NEW FILE########
__FILENAME__ = compound_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the compound editor and the compound editor factory for the
    wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Str

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.compound_editor file.
from traitsui.editors.compound_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

from helper \
    import TraitsUIPanel

#-------------------------------------------------------------------------------
#  'CompoundEditor' class:
#-------------------------------------------------------------------------------

class CompoundEditor ( Editor ):
    """ Editor for compound traits, which displays editors for each of the
    combined traits, in the appropriate style.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The kind of editor to create for each list item
    kind = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Create a panel to hold all of the component trait editors:
        self.control = panel = TraitsUIPanel( parent, -1 )
        sizer        = wx.BoxSizer( wx.VERTICAL )

        # Add all of the component trait editors:
        self._editors = editors = []
        for factory in self.factory.editors:
            editor = getattr( factory, self.kind )( self.ui, self.object,
                                       self.name, self.description, panel )
            editor.prepare( panel )
            sizer.Add( editor.control, 1,
                       wx.TOP | wx.BOTTOM | editor.layout_style, 3 )
            editors.append( editor )

        # Set-up the layout:
        panel.SetSizerAndFit( sizer )

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        for editor in self._editors:
            editor.dispose()

        super( CompoundEditor, self ).dispose()

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor(CompoundEditor):

    # The kind of editor to create for each list item. This value overrides
    # the default.
    kind = 'simple_editor'

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor(CompoundEditor):

    # The kind of editor to create for each list item. This value overrides
    # the default.

    kind = 'custom_editor'

#-- EOF ----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = constants
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/22/2004
#
#------------------------------------------------------------------------------

""" Defines constants used by the wxPython implementation of the various text
    editors and text editor factories.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import sys

import wx

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Define platform and wx version constants:
is_mac  = (sys.platform == 'darwin')
is_wx26 = (float( '.'.join( wx.__version__.split( '.' )[0:2] ) ) < 2.8)

# Default dialog title
DefaultTitle = 'Edit properties'

# Color of valid input
OKColor = wx.WHITE

# Color to highlight input errors
ErrorColor = wx.Colour( 255, 192, 192 )

# Color for background of read-only fields
ReadonlyColor = wx.Colour( 244, 243, 238 )

# Color for background of fields where objects can be dropped
DropColor = wx.Colour( 215, 242, 255 )

# Color for an editable field
EditableColor = wx.WHITE

# Color for background of windows (like dialog background color)
if is_mac:
    WindowColor = wx.Colour( 232, 232, 232 )
    BorderedGroupColor = wx.Colour( 224, 224, 224 )
else:
    WindowColor = wx.SystemSettings_GetColour( wx.SYS_COLOUR_MENUBAR )

# Standard width of an image bitmap
standard_bitmap_width = 120

# Width of a scrollbar
scrollbar_dx = wx.SystemSettings_GetMetric( wx.SYS_VSCROLL_X )

# Screen size values:
screen_dx = wx.SystemSettings_GetMetric( wx.SYS_SCREEN_X )
screen_dy = wx.SystemSettings_GetMetric( wx.SYS_SCREEN_Y )


########NEW FILE########
__FILENAME__ = csv_list_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Ioannis Tziakos
#  Date:   11 Jan 2012
#
#------------------------------------------------------------------------------

""" Defines the various text editors for the wxPython user interface toolkit.
    The module is mainly a place-folder for TextEditor factories that have
    been augmented to also listen to changes in the items of the list object.

"""

#-------------------------------------------------------------------------------
#  Imports:
#------------------------------------------------------------------------------

from .text_editor import SimpleEditor as WXSimpleEditor
from .text_editor import CustomEditor as WXCustomEditor
from .text_editor import ReadonlyEditor as WXReadonlyEditor
from ..editors.csv_list_editor import _prepare_method, _dispose_method

class SimpleEditor(WXSimpleEditor):
    """ Simple Editor style for CSVListEditor. """
    prepare = _prepare_method
    dispose = _dispose_method

class CustomEditor(WXCustomEditor):
    """ Custom Editor style for CSVListEditor. """
    prepare = _prepare_method
    dispose = _dispose_method

class ReadonlyEditor(WXReadonlyEditor):
    """ Readonly Editor style for CSVListEditor. """
    prepare = _prepare_method
    dispose = _dispose_method

TextEditor = SimpleEditor

########NEW FILE########
__FILENAME__ = custom_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/19/2005
#
#------------------------------------------------------------------------------

""" Defines the wxPython implementation of the editor used to wrap a non-Traits
based custom control.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.custom_editor file.
from traitsui.editors.custom_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

from helper \
    import open_fbi

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( Editor ):
    """ Wrapper for a custom editor control
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory.factory
        if factory is not None:
            try:
                self.control = factory( *(( parent, self ) + self.factory.args ) )
            except:
                open_fbi()
        if self.control is None:
            self.control = control = wx.StaticText( parent, -1,
                'An error occurred creating a custom editor.\n'
                'Please contact the developer.' )
            control.SetBackgroundColour( wx.RED )
            control.SetForegroundColour( wx.WHITE )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = date_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005--2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Judah De Paula <judah@enthought.com>
#  Date:   2/26/2009
#
#------------------------------------------------------------------------------
"""
A Traits UI editor that wraps a WX calendar panel.

Future Work
-----------
The class needs to be extend to provide the four basic editor types,
Simple, Custom, Text, and ReadOnly.
"""
import datetime

import wx
import wx.calendar

from traits.api import Bool
from traitsui.wx.editor import Editor
from traitsui.wx.constants import WindowColor
from traitsui.wx.text_editor \
    import ReadonlyEditor as TextReadonlyEditor


#------------------------------------------------------------------------------
#--  Simple Editor
#------------------------------------------------------------------------------

class SimpleEditor (Editor):
    """
    Simple Traits UI date editor.  Shows a text box, and a date-picker widget.
    """

    def init ( self, parent ):
        """
        Finishes initializing the editor by creating the underlying widget.
        """
        # MS-Win's DatePickerCtrl comes with a check-box we don't want.
        # GenericDatePickerCtrl was exposed in wxPython version 2.8.8 only.
        if 'wxMSW' in wx.PlatformInfo and wx.VERSION > (2,8,8):
            date_widget = wx.GenericDatePickerCtrl
        else:
            # Linux / OS-X / windows
            date_widget = wx.DatePickerCtrl

        self.control = date_widget(parent,
                                   size=(120,-1),
                                   style = wx.DP_DROPDOWN
                                         | wx.DP_SHOWCENTURY
                                         | wx.DP_ALLOWNONE)
        self.control.Bind(wx.EVT_DATE_CHANGED, self.day_selected)
        return


    def day_selected(self, event):
        """
        Event for when calendar is selected, update/create date string.
        """
        date = event.GetDate()
        # WX sometimes has year == 0 temporarily when doing state changes.
        if date.IsValid() and date.GetYear() != 0:
            year = date.GetYear()
            # wx 2.8.8 has 0-indexed months.
            month = date.GetMonth() + 1
            day = date.GetDay()
            try:
                self.value = datetime.date(year, month, day)
            except ValueError:
                print 'Invalid date:', year, month, day
                raise
        return


    def update_editor ( self ):
        """
        Updates the editor when the object trait changes externally to the
        editor.
        """
        if self.value:
            date = self.control.GetValue()
            # FIXME: A Trait assignment should support fixing an invalid
            # date in the widget.
            if date.IsValid():
                # Important: set the day before setting the month, otherwise wx may fail
                # to set the month.
                date.SetYear(self.value.year)
                date.SetDay(self.value.day)
                # wx 2.8.8 has 0-indexed months.
                date.SetMonth(self.value.month - 1)
                self.control.SetValue(date)
                self.control.Refresh()
        return
#-- end SimpleEditor definition -----------------------------------------------


#------------------------------------------------------------------------------
#--  Custom Editor
#------------------------------------------------------------------------------

SELECTED_FG = wx.Colour(255, 0, 0)
UNAVAILABLE_FG = wx.Colour(192, 192, 192)
DRAG_HIGHLIGHT_FG = wx.Colour(255, 255, 255)
DRAG_HIGHLIGHT_BG = wx.Colour(128, 128, 255)
try:
    MOUSE_BOX_FILL = wx.Colour(0, 0, 255, 32)
    NORMAL_HIGHLIGHT_FG = wx.Colour(0, 0, 0, 0)
    NORMAL_HIGHLIGHT_BG = wx.Colour(255, 255, 255, 0)
# Alpha channel in wx.Colour does not exist prior to version 2.7.1.1
except TypeError:
    MOUSE_BOX_FILL = wx.Colour(0, 0, 255)
    NORMAL_HIGHLIGHT_FG = wx.Colour(0, 0, 0)
    NORMAL_HIGHLIGHT_BG = wx.Colour(255, 255, 255)

class wxMouseBoxCalendarCtrl(wx.calendar.CalendarCtrl):
    """
    Subclass to add a mouse-over box-selection tool.

    Description
    -----------
    Add a Mouse drag-box highlight feature that can be used by the
    CustomEditor to detect user selections.  CalendarCtrl must be subclassed
    to get a device context to draw on top of the Calendar, otherwise the
    calendar widgets are always painted on top of the box during repaints.
    """

    def __init__(self, *args, **kwargs):
        super(wxMouseBoxCalendarCtrl, self).__init__(*args, **kwargs)

        self.selecting = False
        self.box_selected = []
        self.sel_start = (0,0)
        self.sel_end = (0,0)
        self.Bind(wx.EVT_RIGHT_DOWN, self.start_select)
        self.Bind(wx.EVT_RIGHT_UP, self.end_select)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.end_select)
        self.Bind(wx.EVT_MOTION, self.on_select)
        self.Bind(wx.EVT_PAINT, self.on_paint)
        self.Bind(wx.calendar.EVT_CALENDAR_SEL_CHANGED, self.highlight_changed)


    def boxed_days(self):
        """
        Compute the days that are under the box selection.

        Returns
        -------
        A list of wx.DateTime objects under the mouse box.
        """
        x1, y1 = self.sel_start
        x2, y2 = self.sel_end
        if x1 > x2:
            x1, x2 = x2, x1
        if y1 > y2:
            y1, y2 = y2, y1

        grid = []
        for i in range(x1, x2, 15):
            for j in range(y1, y2, 15):
                grid.append(wx.Point(i,j))
            grid.append(wx.Point(i, y2))
        # Avoid jitter along the edge since the final points change.
        for j in range(y1, y2, 20):
            grid.append(wx.Point(x2, j))
        grid.append(wx.Point(x2, y2))

        selected_days = []
        for point in grid:
            (result, date, weekday) = self.HitTest(point)
            if result == wx.calendar.CAL_HITTEST_DAY:
                if date not in selected_days:
                    selected_days.append(date)

        return selected_days


    def highlight_changed(self, event=None):
        """
        Hide the default highlight to take on the selected date attr.

        Description
        -----------
        A feature of the wx CalendarCtrl is that there are selected days,
        that always are shown and the user can move around with left-click.
        But it's confusing and misleading when there are multiple
        CalendarCtrl objects linked in one editor.  So we hide the
        highlights in this CalendarCtrl by making it mimic the attribute
        of the selected day.

        Highlights apparently can't take on a border style, so to be truly
        invisible, normal days cannot have borders.
        """
        if event:
            event.Skip()
        date = self.GetDate()

        attr = self.GetAttr(date.GetDay())
        if attr is None:
            bg_color = NORMAL_HIGHLIGHT_BG
            fg_color = NORMAL_HIGHLIGHT_FG
        else:
            bg_color = attr.GetBackgroundColour()
            fg_color = attr.GetTextColour()
        self.SetHighlightColours(fg_color, bg_color)
        self.Refresh()
        return


    #-- event handlers --------------------------------------------------------
    def start_select(self, event):
        event.Skip()
        self.selecting = True
        self.box_selected = []
        self.sel_start = (event.m_x, event.m_y)
        self.sel_end = self.sel_start


    def end_select(self, event):
        event.Skip()
        self.selecting = False
        self.Refresh()


    def on_select(self, event):
        event.Skip()
        if not self.selecting:
            return

        self.sel_end = (event.m_x, event.m_y)
        self.box_selected = self.boxed_days()
        self.Refresh()


    def on_paint(self, event):
        event.Skip()
        dc = wx.PaintDC(self)

        if not self.selecting:
            return

        x = self.sel_start[0]
        y = self.sel_start[1]
        w = self.sel_end[0] - x
        h = self.sel_end[1] - y

        gc = wx.GraphicsContext.Create(dc)
        pen = gc.CreatePen(wx.BLACK_PEN)
        gc.SetPen(pen)

        points = [(x,y), (x+w, y), (x+w,y+h), (x,y+h), (x,y)]

        gc.DrawLines(points)

        brush = gc.CreateBrush(wx.Brush(MOUSE_BOX_FILL))
        gc.SetBrush(brush)
        gc.DrawRectangle(x, y, w, h)
#-- end wxMouseBoxCalendarCtrl ------------------------------------------------


class MultiCalendarCtrl(wx.Panel):
    """
    WX panel containing calendar widgets for use by the CustomEditor.

    Description
    -----------
    Handles multi-selection of dates by special handling of the
    wxMouseBoxCalendarCtrl widget.  Doing single-select across multiple
    calendar widgets is also supported though most of the interesting
    functionality is then unused.
    """

    def __init__(self, parent, ID, editor, multi_select, shift_to_select,
                 on_mixed_select, allow_future, months, padding,
                 *args, **kwargs):
        super(MultiCalendarCtrl, self).__init__(parent, ID, *args, **kwargs)

        self.sizer = wx.BoxSizer()
        self.SetSizer(self.sizer)
        self.SetBackgroundColour(WindowColor)
        self.date = wx.DateTime_Now()
        self.today = self.date_from_datetime(self.date)

        # Object attributes
        self.multi_select = multi_select
        self.shift_to_select = shift_to_select
        self.on_mixed_select = on_mixed_select
        self.allow_future = allow_future
        self.editor = editor
        self.selected_days = editor.value
        self.months = months
        self.padding = padding
        self.cal_ctrls = []

        # State to remember when a user is doing a shift-click selection.
        self._first_date = None
        self._drag_select = []
        self._box_select = []

        # Set up the individual month frames.
        for i in range(-(self.months-1), 1):
            cal = self._make_calendar_widget(i)
            self.cal_ctrls.insert(0, cal)
            if i != 0:
                self.sizer.AddSpacer(wx.Size(padding, padding))

        # Initial painting
        self.selected_list_changed()
        return


    def date_from_datetime(self, dt):
        """
        Convert a wx DateTime object to a Python Date object.

        Parameters
        ----------
        dt : wx.DateTime
            A valid date to convert to a Python Date object
        """
        new_date = datetime.date(dt.GetYear(), dt.GetMonth()+1, dt.GetDay())
        return new_date


    def datetime_from_date(self, date):
        """
        Convert a Python Date object to a wx DateTime object. Ignores time.

        Parameters
        ----------
        date : datetime.Date object
            A valid date to convert to a wx.DateTime object.  Since there
            is no time information in a Date object the defaults of DateTime
            are used.
        """
        dt = wx.DateTime()
        dt.SetYear(date.year)
        dt.SetMonth(date.month-1)
        dt.SetDay(date.day)
        return dt


    def shift_datetime(self, old_date, months):
        """
        Create a new DateTime from *old_date* with an offset number of *months*.

        Parameters
        ----------
        old_date : DateTime
            The old DateTime to make a date copy of.  Does not copy time.
        months : int
            A signed int to add or subtract from the old date months.  Does
            not support jumping more than 12 months.
        """
        new_date = wx.DateTime()
        new_month = old_date.GetMonth() + months
        new_year = old_date.GetYear()
        if new_month < 0:
            new_month += 12
            new_year -= 1
        elif new_month > 11:
            new_month -= 12
            new_year += 1

        new_day = min(old_date.GetDay(), 28)
        new_date.Set(new_day, new_month, new_year)
        return new_date


    def selected_list_changed(self, evt=None):
        """ Update the date colors of the days in the widgets. """
        for cal in self.cal_ctrls:
            cur_month = cal.GetDate().GetMonth() + 1
            cur_year = cal.GetDate().GetYear()
            selected_days = self.selected_days

            # When multi_select is False wrap in a list to pass the for-loop.
            if self.multi_select == False:
                if selected_days == None:
                    selected_days = []
                else:
                    selected_days = [selected_days]

            # Reset all the days to the correct colors.
            for day in range(1,32):
                try:
                    paint_day = datetime.date(cur_year, cur_month, day)
                    if not self.allow_future and paint_day > self.today:
                        attr = wx.calendar.CalendarDateAttr(colText=UNAVAILABLE_FG)
                        cal.SetAttr(day, attr)
                    elif paint_day in selected_days:
                        attr = wx.calendar.CalendarDateAttr(colText=SELECTED_FG)
                        cal.SetAttr(day, attr)
                    else:
                        cal.ResetAttr(day)
                except ValueError:
                    # Blindly creating Date objects sometimes produces invalid.
                    pass

            cal.highlight_changed()
        return


    def _make_calendar_widget(self, month_offset):
        """
        Add a calendar widget to the screen and hook up callbacks.

        Parameters
        ----------
        month_offset : int
            The number of months from today, that the calendar should
            start at.
        """
        date = self.shift_datetime(self.date, month_offset)
        panel = wx.Panel(self, -1)
        cal = wxMouseBoxCalendarCtrl(panel,
            -1,
            date,
            style = wx.calendar.CAL_SUNDAY_FIRST
                  | wx.calendar.CAL_SEQUENTIAL_MONTH_SELECTION
                  #| wx.calendar.CAL_SHOW_HOLIDAYS
        )
        self.sizer.Add(panel)
        cal.highlight_changed()

        # Set up control to sync the other calendar widgets and coloring:
        self.Bind(wx.calendar.EVT_CALENDAR_MONTH, self.month_changed, cal)
        self.Bind(wx.calendar.EVT_CALENDAR_YEAR, self.month_changed, cal)

        wx.EVT_LEFT_DOWN(cal, self._left_down)

        if self.multi_select:
            wx.EVT_LEFT_UP(cal, self._left_up)
            wx.EVT_RIGHT_UP(cal, self._process_box_select)
            wx.EVT_LEAVE_WINDOW(cal, self._process_box_select)
            wx.EVT_MOTION(cal, self._mouse_drag)
            self.Bind(wx.calendar.EVT_CALENDAR_WEEKDAY_CLICKED,
                      self._weekday_clicked, cal)
        return cal


    def unhighlight_days(self, days):
        """
        Turn off all highlights in all cals, but leave any selected color.

        Parameters
        ----------
        days : List(Date)
            The list of dates to add.  Possibly includes dates in the future.
        """
        for cal in self.cal_ctrls:
            c = cal.GetDate()
            for date in days:
                if date.year == c.GetYear() and date.month == c.GetMonth()+1:

                    # Unselected days either need to revert to the
                    # unavailable color, or the default attribute color.
                    if (not self.allow_future and
                       ((date.year, date.month, date.day) >
                       (self.today.year, self.today.month, self.today.day))):
                        attr = wx.calendar.CalendarDateAttr(colText=UNAVAILABLE_FG)
                    else:
                        attr = wx.calendar.CalendarDateAttr(
                            colText=NORMAL_HIGHLIGHT_FG,
                            colBack=NORMAL_HIGHLIGHT_BG)
                    if date in self.selected_days:
                        attr.SetTextColour(SELECTED_FG)
                    cal.SetAttr(date.day, attr)
            cal.highlight_changed()
        return


    def highlight_days(self, days):
        """
        Color the highlighted list of days across all calendars.

        Parameters
        ----------
        days : List(Date)
            The list of dates to add.  Possibly includes dates in the future.
        """
        for cal in self.cal_ctrls:
            c = cal.GetDate()
            for date in days:
                if date.year == c.GetYear() and date.month == c.GetMonth()+1:
                    attr = wx.calendar.CalendarDateAttr(
                            colText=DRAG_HIGHLIGHT_FG,
                            colBack=DRAG_HIGHLIGHT_BG
                            )
                    cal.SetAttr(date.day, attr)
            cal.highlight_changed()
            cal.Refresh()


    def add_days_to_selection(self, days):
        """
        Add a list of days to the selection, using a specified style.

        Parameters
        ----------
        days : List(Date)
            The list of dates to add.  Possibly includes dates in the future.

        Description
        -----------
        When a user multi-selects entries and some of those entries are
        already selected and some are not, what should be the behavior for
        the seletion? Options::

            'toggle'     -- Toggle each day to it's opposite state.
            'on'         -- Always turn them on.
            'off'        -- Always turn them off.
            'max_change' -- Change all to same state, with most days changing.
                            For example 1 selected and 9 not, then they would
                            all get selected.
            'min_change' -- Change all to same state, with min days changing.
                            For example 1 selected and 9 not, then they would
                            all get unselected.
        """
        if not days:
            return
        style = self.on_mixed_select
        new_list = list(self.selected_days)

        if style == 'toggle':
            for day in days:
                if self.allow_future or day <= self.today:
                    if day in new_list:
                        new_list.remove(day)
                    else:
                        new_list.append(day)

        else:
            already_selected = len([day for day in days
                                    if day in new_list])

            if style == 'on' or already_selected == 0:
                add_items = True

            elif style == 'off' or already_selected == len(days):
                add_items = False

            elif (self.on_mixed_select == 'max_change' and
                  already_selected <= (len(days) / 2.0)):
                add_items = True

            elif (self.on_mixed_select == 'min_change' and
                  already_selected > (len(days) / 2.0)):
                add_items = True

            else:
                # Cases where max_change is off or min_change off.
                add_items = False

            for day in days:
                # Skip if we don't allow future, and it's a future day.
                if self.allow_future or day <= self.today:
                    if add_items and day not in new_list:
                        new_list.append(day)
                    elif not add_items and day in new_list:
                        new_list.remove(day)

        self.selected_days = new_list
        # Link the list back to the model to make a Traits List change event.
        self.editor.value = new_list
        return


    def single_select_day(self, dt):
        """
        In non-multiselect switch the selection to a new date.

        Parameters
        ----------
        dt : wx.DateTime
            The newly selected date that should become the new calendar
            selection.

        Description
        -----------
        Only called when we're using  the single-select mode of the
        calendar widget, so we can assume that the selected_dates is
        a None or a Date singleton.
        """
        selection = self.date_from_datetime(dt)

        if dt.IsValid() and (self.allow_future or selection <= self.today):
            self.selected_days = selection
            self.selected_list_changed()
            # Modify the trait on the editor so that the events propagate.
            self.editor.value = self.selected_days
            return


    def _shift_drag_update(self, event):
        """ Shift-drag in progress. """
        cal = event.GetEventObject()
        result, dt, weekday = cal.HitTest(event.GetPosition())

        self.unhighlight_days(self._drag_select)
        self._drag_select = []

        # Prepare for an abort, don't highlight new selections.
        if ((self.shift_to_select and not event.ShiftDown())
            or result != wx.calendar.CAL_HITTEST_DAY):

            cal.highlight_changed()
            for cal in self.cal_ctrls:
                cal.Refresh()
            return

        # Construct the list of selections.
        last_date = self.date_from_datetime(dt)
        if last_date <= self._first_date:
            first, last = last_date, self._first_date
        else:
            first, last = self._first_date, last_date
        while first <= last:
            if self.allow_future or first <= self.today:
                self._drag_select.append(first)
            first = first + datetime.timedelta(1)

        self.highlight_days(self._drag_select)
        return


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _process_box_select(self, event):
        """
        Possibly move the calendar box-selected days into our selected days.
        """
        event.Skip()
        self.unhighlight_days(self._box_select)

        if not event.Leaving():
            self.add_days_to_selection(self._box_select)
            self.selected_list_changed()

        self._box_select = []


    def _weekday_clicked(self, evt):
        """ A day on the weekday bar has been clicked.  Select all days. """
        evt.Skip()
        weekday = evt.GetWeekDay()
        cal = evt.GetEventObject()
        month = cal.GetDate().GetMonth()+1
        year = cal.GetDate().GetYear()

        days = []
        # Messy math to compute the dates of each weekday in the month.
        # Python uses Monday=0, while wx uses Sunday=0.
        month_start_weekday = (datetime.date(year, month, 1).weekday()+1) %7
        weekday_offset = (weekday - month_start_weekday) % 7
        for day in range(weekday_offset, 31, 7):
            try:
                day = datetime.date(year, month, day+1)
                if self.allow_future or day <= self.today:
                    days.append(day)
            except ValueError:
                pass
        self.add_days_to_selection(days)

        self.selected_list_changed()
        return


    def _left_down(self, event):
        """ Handle user selection of days. """
        event.Skip()
        cal = event.GetEventObject()
        result, dt, weekday = cal.HitTest(event.GetPosition())

        if result == wx.calendar.CAL_HITTEST_DAY and not self.multi_select:
            self.single_select_day(dt)
            return

        # Inter-month-drag selection.  A quick no-movement mouse-click is
        # equivalent to a multi-select of a single day.
        if (result == wx.calendar.CAL_HITTEST_DAY
            and (not self.shift_to_select or event.ShiftDown())
            and not cal.selecting):

            self._first_date = self.date_from_datetime(dt)
            self._drag_select = [self._first_date]
            # Start showing the highlight colors with a mouse_drag event.
            self._mouse_drag(event)

        return


    def _left_up(self, event):
        """ Handle the end of a possible run-selection. """
        event.Skip()
        cal = event.GetEventObject()
        result, dt, weekday = cal.HitTest(event.GetPosition())

        # Complete a drag-select operation.
        if (result == wx.calendar.CAL_HITTEST_DAY
            and (not self.shift_to_select or event.ShiftDown())
            and self._first_date):

            last_date = self.date_from_datetime(dt)
            if last_date <= self._first_date:
                first, last = last_date, self._first_date
            else:
                first, last = self._first_date, last_date

            newly_selected = []
            while first <= last:
                newly_selected.append(first)
                first = first + datetime.timedelta(1)
            self.add_days_to_selection(newly_selected)
            self.unhighlight_days(newly_selected)

        # Reset a drag-select operation, even if it wasn't completed because
        # of a loss of focus or the Shift key prematurely released.
        self._first_date = None
        self._drag_select = []

        self.selected_list_changed()
        return


    def _mouse_drag(self, event):
        """ Called when the mouse in being dragged within the main panel. """
        event.Skip()
        cal = event.GetEventObject()
        if not cal.selecting and self._first_date:
            self._shift_drag_update(event)
        if cal.selecting:
            self.unhighlight_days(self._box_select)
            self._box_select = [self.date_from_datetime(dt)
                                for dt in cal.boxed_days()]
            self.highlight_days(self._box_select)
        return


    def month_changed(self, evt=None):
        """
        Link the calendars together so if one changes, they all change.

        TODO: Maybe wx.calendar.CAL_HITTEST_INCMONTH could be checked and
        the event skipped, rather than now where we undo the update after
        the event has gone through.
        """
        evt.Skip()
        cal_index = self.cal_ctrls.index(evt.GetEventObject())
        current_date = self.cal_ctrls[cal_index].GetDate()
        for i, cal in enumerate(self.cal_ctrls):
            # Current month is already updated, just need to shift the others
            if i != cal_index:
                new_date = self.shift_datetime(current_date, cal_index - i)
                cal.SetDate(new_date)
                cal.highlight_changed()

        # Back-up if we're not allowed to move into future months.
        if not self.allow_future:
            month = self.cal_ctrls[0].GetDate().GetMonth()+1
            year = self.cal_ctrls[0].GetDate().GetYear()
            if (year, month) > (self.today.year, self.today.month):
                for i, cal in enumerate(self.cal_ctrls):
                    new_date = self.shift_datetime(wx.DateTime_Now(), -i)
                    cal.SetDate(new_date)
                    cal.highlight_changed()

        # Redraw the selected days.
        self.selected_list_changed()


#-- end CalendarCtrl ----------------------------------------------------------


class CustomEditor(Editor):
    """
    Show multiple months with MultiCalendarCtrl. Allow multi-select.

    Trait Listeners
    ---------------
    The wx editor directly modifies the *value* trait of the Editor, which
    is the named trait of the corresponding Item in your View.  Therefore
    you can listen for changes to the user's selection by directly listening
    to the item changed event.

    TODO
    ----
    Some more listeners need to be hooked up.  For example, in single-select
    mode, changing the value does not cause the calendar to update.  Also,
    the selection-add and remove is noisy, triggering an event for each
    addition rather than waiting until everything has been added and removed.

    Sample
    ------
    Example usage::

        class DateListPicker(HasTraits):
            calendar = List
            traits_view = View(Item('calendar', editor=DateEditor(),
                                    style='custom', show_label=False))
    """

    #-- Editor interface ------------------------------------------------------

    def init (self, parent):
        """
        Finishes initializing the editor by creating the underlying widget.
        """
        if self.factory.multi_select and not isinstance(self.value, list):
            raise ValueError('Multi-select is True, but editing a non-list.')
        elif not self.factory.multi_select and isinstance(self.value, list):
            raise ValueError('Multi-select is False, but editing a list.')

        calendar_ctrl = MultiCalendarCtrl(parent,
                                          -1,
                                          self,
                                          self.factory.multi_select,
                                          self.factory.shift_to_select,
                                          self.factory.on_mixed_select,
                                          self.factory.allow_future,
                                          self.factory.months,
                                          self.factory.padding)
        self.control = calendar_ctrl
        return


    def update_editor ( self ):
        """
        Updates the editor when the object trait changes externally to the
        editor.
        """
        self.control.selected_list_changed()
        return
#-- end CustomEditor definition -----------------------------------------------


#------------------------------------------------------------------------------
#--  Text Editor
#------------------------------------------------------------------------------
# TODO: Write me.  Possibly use TextEditor as a model to show a string
# representation of the date, and have enter-set do a date evaluation.
class TextEditor (SimpleEditor):
    pass
#-- end TextEditor definition -------------------------------------------------


#------------------------------------------------------------------------------
#--  Readonly Editor
#------------------------------------------------------------------------------

class ReadonlyEditor (TextReadonlyEditor):
    """ Use a TextEditor for the view. """

    def _get_str_value(self):
        """ Replace the default string value with our own date verision. """
        if not self.value:
            return self.factory.message
        else:
            return self.value.strftime(self.factory.strftime)

#-- end ReadonlyEditor definition ---------------------------------------------

#-- eof -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = directory_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines various directory editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from os.path \
    import isdir

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.custom_editor file.
from traitsui.editors.directory_editor \
    import ToolkitEditorFactory

from file_editor \
    import SimpleEditor as SimpleFileEditor, \
           CustomEditor as CustomFileEditor, \
           PopupFile

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( SimpleFileEditor ):
    """ Simple style of editor for directories, which displays a text field
        and a **Browse** button that opens a directory-selection dialog box.
    """

    #---------------------------------------------------------------------------
    #  Creates the correct type of file dialog or popup:
    #---------------------------------------------------------------------------

    def _create_file_dialog ( self ):
        """ Creates the correct type of file dialog.
        """
        dlg = wx.DirDialog( self.control, message = 'Select a Directory' )
        dlg.SetPath( self._file_name.GetValue() )
        return dlg

    def _create_file_popup ( self ):
        """ Creates the correct type of file popup.
        """
        return PopupDirectory( control   = self.control,
                               file_name = self.str_value,
                               filter    = self.factory.filter,
                               height    = 300 )

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( CustomFileEditor ):
    """ Custom style of editor for directories, which displays a tree view of
        the file system.
    """

    #---------------------------------------------------------------------------
    #  Returns the basic style to use for the control:
    #---------------------------------------------------------------------------

    def get_style ( self ):
        """ Returns the basic style to use for the control.
        """
        return (wx.DIRCTRL_DIR_ONLY | wx.DIRCTRL_EDIT_LABELS)

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user changing the contents of the edit control.
        """
        if self.control is not None:
            path = self.control.GetPath()
            if isdir( path ):
                self.value = path

#-------------------------------------------------------------------------------
#  'PopupDirectory' class:
#-------------------------------------------------------------------------------

class PopupDirectory ( PopupFile ):

    def get_style ( self ):
        """ Returns the basic style to use for the popup.
        """
        return (wx.DIRCTRL_DIR_ONLY | wx.DIRCTRL_EDIT_LABELS)

    def is_valid ( self, path ):
        """ Returns whether or not the path is valid.
        """
        return isdir( path )

### EOF ########################################################################

########NEW FILE########
__FILENAME__ = dnd_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/25/2006
#
#------------------------------------------------------------------------------

""" Defines the various editors for a drag-and-drop editor,
    for the wxPython user interface toolkit. A drag-and-drop editor represents
    its value as a simple image which, depending upon the editor style, can be
    a drag source only, a drop target only, or both a drag source and a drop
    target.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx
import numpy

from cPickle \
    import load

from traits.api \
    import Bool

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.dnd_editor file.
from traitsui.editors.dnd_editor \
    import ToolkitEditorFactory

from pyface.wx.drag_and_drop \
    import PythonDropSource, PythonDropTarget, clipboard

try:
    from apptools.io import File
except ImportError:
    File = None

try:
    from apptools.naming.api import Binding
except ImportError:
    Binding = None

from pyface.image_resource \
    import ImageResource

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# The image to use when the editor accepts files:
file_image = ImageResource( 'file' ).create_image()

# The image to use when the editor accepts objects:
object_image = ImageResource( 'object' ).create_image()

# The image to use when the editor is disabled:
inactive_image = ImageResource( 'inactive' ).create_image()

# String types:
string_type = ( str, unicode )

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simply style of editor for a drag-and-drop editor, which is both a drag
        source and a drop target.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the editor a drop target?
    drop_target = Bool( True )

    # Is the editor a drag source?
    drag_source = Bool( True )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Determine the drag/drop type:
        value         = self.value
        self._is_list = isinstance( value, list )
        self._is_file = (isinstance( value, string_type ) or
                         (self._is_list and (len( value ) > 0) and
                          isinstance( value[0], string_type )))

        # Get the right image to use:
        image = self.factory.image
        if image is not None:
            image = image.create_image()
            disabled_image = self.factory.disabled_image
            if disabled_image is not None:
                disabled_image = disabled_image.create_image()
        else:
            disabled_image = inactive_image
            image          = object_image
            if self._is_file:
                image = file_image

        self._image = image.ConvertToBitmap()
        if disabled_image is not None:
            self._disabled_image = disabled_image.ConvertToBitmap()
        else:
            data = numpy.reshape( numpy.fromstring( image.GetData(),
                                                    numpy.uint8 ),
                      ( -1, 3 ) ) * numpy.array( [ [ 0.297, 0.589, 0.114 ] ] )
            g = data[ :, 0 ] + data[ :, 1 ] + data[ :, 2 ]
            data[ :, 0 ] = data[ :, 1 ] = data[ :, 2 ] = g
            image.SetData( numpy.ravel( data.astype(numpy.uint8) ).tostring() )
            image.SetMaskColour( 0, 0, 0 )
            self._disabled_image = image.ConvertToBitmap()

        # Create the control and set up the event handlers:
        self.control = control = wx.Window( parent, -1,
                         size = wx.Size( image.GetWidth(), image.GetHeight() ) )
        self.set_tooltip()

        if self.drop_target:
            control.SetDropTarget( PythonDropTarget( self ) )

        wx.EVT_LEFT_DOWN( control, self._left_down )
        wx.EVT_LEFT_UP(   control, self._left_up )
        wx.EVT_MOTION(    control, self._mouse_move )
        wx.EVT_PAINT(     control, self._on_paint )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        control = self.control
        wx.EVT_LEFT_DOWN( control, None )
        wx.EVT_LEFT_UP(   control, None )
        wx.EVT_MOTION(    control, None )
        wx.EVT_PAINT(     control, None )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        return

#-- Private Methods ------------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Returns the processed version of a drag request's data:
    #---------------------------------------------------------------------------

    def _get_drag_data ( self, data ):
        """ Returns the processed version of a drag request's data.
        """
        if isinstance( data, list ):

            if Binding is not None and isinstance( data[0], Binding ):
                data = [ item.obj for item in data ]

            if File is not None and isinstance( data[0], File ):
                data = [ item.absolute_path for item in data ]
                if not self._is_file:
                    result = []
                    for file in data:
                        item = self._unpickle( file )
                        if item is not None:
                            result.append( item )
                    data = result

        else:
            if Binding is not None and isinstance( data, Binding ):
                data = data.obj

            if File is not None and isinstance( data, File ):
                data = data.absolute_path
                if not self._is_file:
                    object = self._unpickle( data )
                    if object is not None:
                        data = object

        return data

    #---------------------------------------------------------------------------
    #  Returns the unpickled version of a specified file (if possible):
    #---------------------------------------------------------------------------

    def _unpickle ( self, file_name ):
        """ Returns the unpickled version of a specified file (if possible).
        """
        fh = None
        try:
            fh     = file( file_name, 'rb' )
            object = load( fh )
        except:
            object = None

        if fh is not None:
            fh.close()

        return object

#-- wxPython Event Handlers ----------------------------------------------------

    def _on_paint ( self, event ):
        """ Called when the control needs repainting.
        """
        image   = self._image
        control = self.control
        if not control.IsEnabled():
            image = self._disabled_image

        wdx, wdy = control.GetClientSizeTuple()
        wx.PaintDC( control ).DrawBitmap( image,
            (wdx - image.GetWidth())  / 2, (wdy - image.GetHeight()) / 2, True )

    def _left_down ( self, event ):
        """ Handles the left mouse button being pressed.
        """
        if self.control.IsEnabled() and self.drag_source:
            self._x, self._y = event.GetX(), event.GetY()
            self.control.CaptureMouse()

        event.Skip()

    def _left_up ( self, event ):
        """ Handles the left mouse button being released.
        """
        if self._x is not None:
            self._x = None
            self.control.ReleaseMouse()

        event.Skip()

    def _mouse_move ( self, event ):
        """ Handles the mouse being moved.
        """
        if self._x is not None:
            if ((abs( self._x - event.GetX() ) +
                 abs( self._y - event.GetY() )) >= 3):
                self.control.ReleaseMouse()
                self._x = None
                if self._is_file:
                    FileDropSource(   self.control, self.value )
                else:
                    PythonDropSource( self.control, self.value )

        event.Skip()

#----- Drag and drop event handlers: -------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a Python object being dropped on the control:
    #---------------------------------------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the tree.
        """
        try:
            self.value = self._get_drag_data( data )
            return drag_result
        except:
            return wx.DragNone

    #---------------------------------------------------------------------------
    #  Handles a Python object being dragged over the control:
    #---------------------------------------------------------------------------

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        try:
            self.object.base_trait( self.name ).validate( self.object,
                                        self.name, self._get_drag_data( data ) )
            return drag_result
        except:
            return wx.DragNone

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of drag-and-drop editor, which is not a drag source.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the editor a drag source? This value overrides the default.
    drag_source = False

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( SimpleEditor ):
    """ Read-only style of drag-and-drop editor, which is not a drop target.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the editor a drop target? This value overrides the default.
    drop_target = False

#-------------------------------------------------------------------------------
#  'FileDropSource' class:
#-------------------------------------------------------------------------------

class FileDropSource ( wx.DropSource ):
    """ Represents a draggable file.
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, source, files ):
        """ Initializes the object.
        """
        self.handler    = None
        self.allow_move = True

        # Put the data to be dragged on the clipboard:
        clipboard.data        = files
        clipboard.source      = source
        clipboard.drop_source = self

        data_object = wx.FileDataObject()
        if isinstance( files, string_type ):
            files = [ files ]

        for file in files:
            data_object.AddFile( file )

        # Create the drop source and begin the drag and drop operation:
        super( FileDropSource, self ).__init__( source )
        self.SetData( data_object )
        self.result = self.DoDragDrop( True )

    #---------------------------------------------------------------------------
    #  Called when the data has been dropped:
    #---------------------------------------------------------------------------

    def on_dropped ( self, drag_result ):
        """ Called when the data has been dropped. """
        return

## EOF ########################################################################

########NEW FILE########
__FILENAME__ = drop_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   04/13/2005
#
#------------------------------------------------------------------------------

""" Defines a drop target editor for the wxPython user interface toolkit. A
    drop target editor handles drag and drop operations as a drop target.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.drop_editor file.
from traitsui.editors.drop_editor \
    import ToolkitEditorFactory

from pyface.wx.drag_and_drop \
    import PythonDropTarget, clipboard

from text_editor \
    import SimpleEditor as Editor

from constants \
    import DropColor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of drop editor, which displays a read-only text field that
    contains the string representation of the object trait's value.
    """

    # Background color when it is OK to drop objects.
    ok_color = DropColor

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        if self.factory.readonly:
            self.control = wx.TextCtrl( parent, -1, self.str_value,
                                        style = wx.TE_READONLY )
            self.set_tooltip()
        else:
            super( SimpleEditor, self ).init( parent )
        self.control.SetBackgroundColour( self.ok_color )
        self.control.SetDropTarget( PythonDropTarget( self ) )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified object trait value:
    #---------------------------------------------------------------------------

    def string_value ( self, value ):
        """ Returns the text representation of a specified object trait value.
        """
        if value is None:
            return ''
        return str( value )

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

#----- Drag and drop event handlers: -------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a Python object being dropped on the control:
    #---------------------------------------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the tree.
        """
        klass = self.factory.klass
        value = data
        if self.factory.binding:
            value = getattr( clipboard, 'node', None )
        if (klass is None) or isinstance( data, klass ):
            self._no_update = True
            try:
                if hasattr( value, 'drop_editor_value' ):
                    self.value = value.drop_editor_value()
                else:
                    self.value = value
                if hasattr( value, 'drop_editor_update' ):
                    value.drop_editor_update( self.control )
                else:
                    self.control.SetValue( self.str_value )
            finally:
                self._no_update = False
            return drag_result

        return wx.DragNone

    #---------------------------------------------------------------------------
    #  Handles a Python object being dragged over the control:
    #---------------------------------------------------------------------------

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        if self.factory.binding:
            data = getattr( clipboard, 'node', None )
        try:
            self.object.base_trait( self.name ).validate( self.object,
                                                          self.name, data )
            return drag_result
        except:
            return wx.DragNone

# Define the Text and ReadonlyEditor for use by the editor factory.
TextEditor = ReadonlyEditor = SimpleEditor

### EOF ########################################################################

########NEW FILE########
__FILENAME__ = editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the base class for wxPython editors.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasTraits, Int, Instance, Str, Callable

# CIRCULAR IMPORT FIXME:
# We are importing from the source instead of from the api in order to
# avoid circular imports. The 'toolkit.py' file imports from 'helper' which in
# turns imports from this file. Therefore, trying to import
# 'traitsui.wx' (which imports the toolkit) will lead to importing
# all of the editor factories declared in traitsui.api. In addition,# some of the editor factories have a Color trait defined, and this will lead
# to an import of the wx 'toolkit' causing a circular import problem.
# Another solution could be to move the GroupEditor object from helper to this
# file.
from traitsui.editor \
    import Editor as UIEditor

from constants \
    import WindowColor, OKColor, ErrorColor

#-------------------------------------------------------------------------------
#  'Editor' class:
#-------------------------------------------------------------------------------

class Editor ( UIEditor ):
    """ Base class for wxPython editors for Traits-based UIs.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Style for embedding control in a sizer:
    layout_style = Int( wx.EXPAND )

    # The maximum extra padding that should be allowed around the editor:
    border_size = Int( 4 )

    #---------------------------------------------------------------------------
    #  Handles the 'control' trait being set:
    #---------------------------------------------------------------------------

    def _control_changed ( self, control ):
        """ Handles the **control** trait being set.
        """
        if control is not None:
            control._editor = self

    #---------------------------------------------------------------------------
    #  Assigns focus to the editor's underlying toolkit widget:
    #---------------------------------------------------------------------------

    def set_focus ( self ):
        """ Assigns focus to the editor's underlying toolkit widget.
        """
        if self.control is not None:
            self.control.SetFocus()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        new_value = self.str_value
        if self.control.GetValue() != new_value:
            self.control.SetValue( new_value )

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        dlg = wx.MessageDialog( self.control, str( excp ),
                                self.description + ' value error',
                                wx.OK | wx.ICON_INFORMATION )
        dlg.ShowModal()
        dlg.Destroy()

    #---------------------------------------------------------------------------
    #  Sets the tooltip for a specified control:
    #---------------------------------------------------------------------------

    def set_tooltip ( self, control = None ):
        """ Sets the tooltip for a specified control.
        """
        desc = self.description
        if desc == '':
            desc = self.object.base_trait( self.name ).desc
            if desc is None:
                return False

            desc = 'Specifies ' + desc

        if control is None:
            control = self.control

        control.SetToolTipString( desc )

        return True

    #---------------------------------------------------------------------------
    #  Handles the 'enabled' state of the editor being changed:
    #---------------------------------------------------------------------------

    def _enabled_changed ( self, enabled ):
        """ Handles the **enabled** state of the editor being changed.
        """
        control = self.control
        if control is not None:
            control.Enable( enabled )
            control.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the 'visible' state of the editor being changed:
    #---------------------------------------------------------------------------

    def _visible_changed ( self, visible ):
        """ Handles the **visible** state of the editor being changed.
        """
        control = self.control
        parent = control.GetParent()

        # Handle the case where the item whose visibility has changed is a
        # notebook page:
        sizer = parent.GetSizer()
        from pyface.dock.api import DockSizer
        if isinstance(sizer, DockSizer):
            dock_controls = sizer.GetContents().get_controls(False)
            for dock_control in dock_controls:
                if dock_control.control is control:
                    dock_control.visible = visible
            sizer.Layout()

        # Handle a normal item:
        else:
            if self.label_control is not None:
                self.label_control.Show( visible )
            control.Show( visible )
            # If only control.Layout() is called there are certain cases where
            # the newly visible items are sized incorrectly (see ticket 1797)
            if parent is None:
                control.Layout()
            else:
                parent.Layout()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.control

    #---------------------------------------------------------------------------
    #  Returns whether or not the editor is in an error state:
    #---------------------------------------------------------------------------

    def in_error_state ( self ):
        """ Returns whether or not the editor is in an error state.
        """
        return False

    #---------------------------------------------------------------------------
    #  Sets the editor's current error state:
    #---------------------------------------------------------------------------

    def set_error_state ( self, state = None, control = None ):
        """ Sets the editor's current error state.
        """
        if state is None:
            state = self.invalid
        state = state or self.in_error_state()

        if control is None:
            control = self.get_error_control() or []

        if not isinstance( control, list ):
            control = [ control ]

        for item in control:
            if state:
                color = ErrorColor
                if getattr( item, '_ok_color', None ) is None:
                    item._ok_color = item.GetBackgroundColour()
            else:
                color = getattr( item, '_ok_color', None )
                if color is None:
                    color = OKColor
                    if isinstance( item, wx.Panel ):
                        color = WindowColor

            item.SetBackgroundColour( color )
            item.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the editor's invalid state changing:
    #---------------------------------------------------------------------------

    def _invalid_changed ( self, state ):
        """ Handles the editor's invalid state changing.
        """
        self.set_error_state()

#-------------------------------------------------------------------------------
#  'EditorWithList' class:
#-------------------------------------------------------------------------------

class EditorWithList ( Editor ):
    """ Editor for an object that contains a list.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Object containing the list being monitored
    list_object = Instance( HasTraits )

    # Name of the monitored trait
    list_name = Str

    # Function used to evaluate the current list object value:
    list_value = Callable

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Initializes the object.
        """
        factory = self.factory
        name    = factory.name
        if name != '':
            self.list_object, self.list_name, self.list_value = \
                self.parse_extended_name( name )
        else:
            self.list_object, self.list_name = factory, 'values'
            self.list_value = lambda: factory.values

        self.list_object.on_trait_change(
            self._list_updated, self.list_name + '[]', dispatch = 'ui' )

        self._list_updated()

    #---------------------------------------------------------------------------
    #  Disconnects the listeners set up by the constructor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disconnects the listeners set up by the constructor.
        """
        self.list_object.on_trait_change(
            self._list_updated, self.list_name + '[]', remove = True )

        super( EditorWithList, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the monitored trait being updated:
    #---------------------------------------------------------------------------

    def _list_updated ( self ):
        """ Handles the monitored trait being updated.
        """
        self.list_updated( self.list_value() )

    #---------------------------------------------------------------------------
    #  Handles the monitored list being updated:
    #---------------------------------------------------------------------------

    def list_updated ( self, values ):
        """ Handles the monitored list being updated.
        """
        raise NotImplementedError

#-------------------------------------------------------------------------------
#  'EditorFromView' class:
#-------------------------------------------------------------------------------

class EditorFromView ( Editor ):
    """ An editor generated from a View object.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Initializes the object.
        """
        self._ui = ui = self.init_ui( parent )
        if ui.history is None:
            ui.history = self.ui.history

        self.control = ui.control

    #---------------------------------------------------------------------------
    #  Creates and returns the traits UI defined by this editor:
    #  (Must be overridden by a subclass):
    #---------------------------------------------------------------------------

    def init_ui ( self, parent ):
        """ Creates and returns the traits UI defined by this editor.
            (Must be overridden by a subclass).
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Normally nothing needs to be done here, since it should all be handled
        # by the editor's internally created traits UI:
        pass

    #---------------------------------------------------------------------------
    #  Dispose of the editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the editor.
        """
        self._ui.dispose()

        super( EditorFromView, self ).dispose()


########NEW FILE########
__FILENAME__ = editors_gen
#------------------------------------------------------------------------------
# Copyright (c) 2008, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the GPL v2
# license.
#
# Author: Vibha Srinivasan <vibha@enthought.com>
#------------------------------------------------------------------------------

""" Generates a file containing definitions for all of the editors defined in
the WX backend.
"""

import os, glob, sys
from traitsui.api import Editor
from traitsui.editor_factory import EditorFactory

def gen_editor_definitions(target_filename):
    """ Generates a file containing definitions for all of the editors
    defined in the Qt backend.
    """

    target_file = open(target_filename, 'w')
    dirpath = os.path.dirname(os.path.abspath(__file__))
    # Find all the files which define a TraitsUIEditor
    editor_files = []
    for (root, dirs, files) in os.walk(dirpath):
        if '.svn' in dirs:
            dirs.remove('.svn')
        editor_files.extend(glob.glob(os.path.join(root, '*_editor.py')))

    for absfilename in editor_files:
        (dirname, filename) = (os.path.dirname(absfilename),
                               os.path.basename(absfilename).rstrip('.py'))
        import_path = 'traitsui.wx' + \
                       dirname.replace(dirpath, '').replace(os.sep, '.') +\
                       '.' + filename
        __import__(import_path)
        module = sys.modules[import_path]
        class_names = []
        for name in dir(module):
            try:
                if issubclass(getattr(module, name), EditorFactory) and \
                    name not in ['EditorFactory', 'BasicEditorFactory']:
                    class_names.append(name)
                elif issubclass(getattr(module, name), Editor) and \
                     name != 'Editor':
                    class_names.append(name)
            except:
                try:
                    if isinstance(getattr(module, name), EditorFactory) or \
                        isinstance(getattr(module, name), Editor):
                        class_names.insert(0, name)
                except:
                    pass

        if len(class_names) > 0:
            # FIXME: Is there a better way to sort these names?
            if 'ToolkitEditorFactory' in class_names:
                class_name = 'ToolkitEditorFactory'
            else:
                class_name = ''.join([name.capitalize() for name in
                                     filename.split('_')])
                if class_name not in class_names:
                    class_name = class_names[0]
            function = "def %(filename)s(*args, **traits):"%locals()
            target_file.write(function)
            target_file.write('\n')
            func_code = ' '*4 + "import %(import_path)s as editor"%locals()+'\n'
            func_code+= ' '*4 + "return editor.%(class_name)s(*args, **traits)" \
                    % locals()
            target_file.write(func_code)
            target_file.write('\n\n')

    target_file.close()

########NEW FILE########
__FILENAME__ = editor_factory
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the base wxPython EditorFactory class and classes the various
    styles of editors used in a Traits-based user interface.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import warnings

import wx

from traits.api \
    import TraitError, Any, Bool, Event, Str

from traitsui.editor_factory \
    import EditorFactory as BaseEditorFactory

from editor \
    import Editor

from constants \
    import WindowColor

#-------------------------------------------------------------------------------
#  'EditorFactory' class
#   Deprecated alias for traitsui.editor_factory.EditorFactory
#-------------------------------------------------------------------------------

class EditorFactory(BaseEditorFactory):
    """ Deprecated alias for traitsui.editor_factory.EditorFactory.
    """

    def __init__(self, *args, **kwds):
        super(EditorFactory, self).__init__(*args, **kwds)
        warnings.warn("DEPRECATED: Use traitsui.editor_factory."
            ".EditorFactory instead.", DeprecationWarning)

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Base class for simple style editors, which displays a text field
        containing the text representation of the object trait value. Clicking
        in the text field displays an editor-specific dialog box for changing
        the value.
    """

    # Has the left mouse button been pressed:
    left_down = Bool( False )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = self.create_control( parent )
        wx.EVT_LEFT_DOWN( self.control, self._enable_popup_editor )
        wx.EVT_LEFT_UP(   self.control, self._show_popup_editor  )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Creates the control to use for the simple editor:
    #---------------------------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the control to use for the simple editor.
        """
        return wx.TextCtrl( parent, -1, self.str_value, style = wx.TE_READONLY )

    #---------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #
    #  (Normally overridden in a subclass)
    #---------------------------------------------------------------------------

    def popup_editor ( self, event ):
        """ Invokes the pop-up editor for an object trait.
        """
        pass

    def _enable_popup_editor ( self, event ):
        """ Mark the left mouse button as being pressed currently.
        """
        self.left_down = True

    def _show_popup_editor ( self, event ):
        """ Display the popup editor if the left mouse button was pressed
            previously.
        """
        if self.left_down:
            self.left_down = False
            self.popup_editor( event )

#-------------------------------------------------------------------------------
#  'TextEditor' class:
#-------------------------------------------------------------------------------

class TextEditor ( Editor ):
    """ Base class for text style editors, which displays an editable text
        field, containing a text representation of the object trait value.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = wx.TextCtrl( parent, -1, self.str_value,
                                    style = wx.TE_PROCESS_ENTER )
        wx.EVT_KILL_FOCUS( self.control, self.update_object )
        wx.EVT_TEXT_ENTER( parent, self.control.GetId(), self.update_object )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user changing the contents of the edit control.
        """
        try:
            self.value = self.control.GetValue()
        except TraitError, excp:
            pass

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( Editor ):
    """ Base class for read-only style editors, which displays a read-only text
        field, containing a text representation of the object trait value.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # layout_style = 0  # Style for imbedding control in a sizer (override)

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        if (self.item.resizable is True) or (self.item.height != -1.0):
            self.control = wx.TextCtrl( parent, -1, self.str_value,
                       style = wx.NO_BORDER | wx.TE_MULTILINE | wx.TE_READONLY )
            self.control.SetBackgroundColour( WindowColor )
        else:
            self.control = wx.StaticText( parent, -1, self.str_value,
                                          style = wx.ALIGN_LEFT )
            self.layout_style = 0

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        new_value = self.str_value
        if (self.item.resizable is True) or (self.item.height!= -1.0):
            if self.control.GetValue() != new_value:
                self.control.SetValue( new_value )
        elif self.control.GetLabel() != new_value:
            self.control.SetLabel( new_value )


########NEW FILE########
__FILENAME__ = enum_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various editors for single-selection enumerations, for the
wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from string \
    import capitalize

from traits.api \
    import Property

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.drop_editor file.
from traitsui.editors.enum_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

from constants \
    import OKColor, ErrorColor

from helper \
    import enum_values_changed, TraitsUIPanel, disconnect, disconnect_no_id

#-------------------------------------------------------------------------------
#  'BaseEditor' class:
#-------------------------------------------------------------------------------

class BaseEditor ( Editor ):
    """ Base class for enumeration editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Current set of enumeration names:
    names = Property

    # Current mapping from names to values:
    mapping = Property

    # Current inverse mapping from values to names:
    inverse_mapping = Property

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if factory.name != '':
            self._object, self._name, self._value = \
                self.parse_extended_name( factory.name )
            self.values_changed()
            self._object.on_trait_change( self._values_changed,
                                          ' ' + self._name, dispatch = 'ui' )
        else:
            factory.on_trait_change( self.rebuild_editor, 'values_modified',
                                     dispatch = 'ui' )

    #---------------------------------------------------------------------------
    #  Gets the current set of enumeration names:
    #---------------------------------------------------------------------------

    def _get_names ( self ):
        """ Gets the current set of enumeration names.
        """
        if self._object is None:
            return self.factory._names

        return self._names

    #---------------------------------------------------------------------------
    #  Gets the current mapping:
    #---------------------------------------------------------------------------

    def _get_mapping ( self ):
        """ Gets the current mapping.
        """
        if self._object is None:
            return self.factory._mapping

        return self._mapping

    #---------------------------------------------------------------------------
    #  Gets the current inverse mapping:
    #---------------------------------------------------------------------------

    def _get_inverse_mapping ( self ):
        """ Gets the current inverse mapping.
        """
        if self._object is None:
            return self.factory._inverse_mapping

        return self._inverse_mapping

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        raise NotImplementedError

    #---------------------------------------------------------------------------
    #  Recomputes the cached data based on the underlying enumeration model:
    #---------------------------------------------------------------------------

    def values_changed ( self ):
        """ Recomputes the cached data based on the underlying enumeration model.
        """
        self._names, self._mapping, self._inverse_mapping = \
            enum_values_changed( self._value() )

    #---------------------------------------------------------------------------
    #  Handles the underlying object model's enumeration set being changed:
    #---------------------------------------------------------------------------

    def _values_changed ( self ):
        """ Handles the underlying object model's enumeration set being changed.
        """
        self.values_changed()
        self.rebuild_editor()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self._object is not None:
            self._object.on_trait_change( self._values_changed,
                                          ' ' + self._name, remove = True )
        else:
            self.factory.on_trait_change( self.rebuild_editor,
                                          'values_modified', remove = True )

        super( BaseEditor, self ).dispose()

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( BaseEditor ):
    """ Simple style of enumeration editor, which displays a combo box.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( SimpleEditor, self ).init( parent )

        factory = self.factory

        if factory.evaluate is None:
            self.control = control = wx.Choice( parent, -1, wx.Point( 0, 0 ),
                                                wx.Size( -1, -1 ), self.names )
            wx.EVT_CHOICE( parent, self.control.GetId(), self.update_object )
        else:
            self.control = control = wx.ComboBox( parent, -1, '',
                                wx.Point( 0, 0 ), wx.Size( -1, -1 ), self.names,
                                style = wx.CB_DROPDOWN )
            wx.EVT_COMBOBOX( parent, control.GetId(), self.update_object )
            wx.EVT_TEXT_ENTER( parent, control.GetId(),
                               self.update_text_object )
            wx.EVT_KILL_FOCUS( control, self.on_kill_focus )

            if (not factory.is_grid_cell) and factory.auto_set:
                wx.EVT_TEXT( parent, control.GetId(), self.update_text_object )

        self._no_enum_update = 0
        self.set_tooltip()

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        disconnect( self.control,
                    wx.EVT_COMBOBOX, wx.EVT_TEXT_ENTER, wx.EVT_TEXT )

        disconnect_no_id( self.control, wx.EVT_KILL_FOCUS )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the user selecting a new value from the combo box:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user selecting a new value from the combo box.
        """
        self._no_enum_update += 1
        try:
            new_value = self.mapping[ event.GetString() ]
            if new_value == self.value and self.factory.is_grid_cell:
                # If the enum editor is in a grid cell and the value did not
                # change, we want the enum editor to go away, reverting back to
                # the normal cell appearance. This is for 2 reasons:
                #  1. it looks nicer
                #  2. if the grid id suddenly closed, wx freaks & causes a
                #     segfault

                grid = self.control.Parent.Parent
                grid.EnableEditing(False)
                grid.EnableEditing(True)

            self.value = new_value

        except:
            from traitsui.api import raise_to_debug
            raise_to_debug()

        self._no_enum_update -= 1

    #---------------------------------------------------------------------------
    #  Handles the user typing text into the combo box text entry field:
    #---------------------------------------------------------------------------

    def update_text_object ( self, event ):
        """ Handles the user typing text into the combo box text entry field.
        """
        if self._no_enum_update == 0:
            value = self.control.GetValue()
            try:
                value = self.mapping[ value ]
            except:
                try:
                    value = self.factory.evaluate( value )
                except Exception, excp:
                    self.error( excp )
                    return

            self._no_enum_update += 1
            try:
                self.value = value
                self.control.SetBackgroundColour( OKColor )
                self.control.Refresh()
            except:
                pass
            self._no_enum_update -= 1

    #---------------------------------------------------------------------------
    #  Handles the control losing the keyboard focus:
    #---------------------------------------------------------------------------

    def on_kill_focus ( self, event ):
        """ Handles the control losing the keyboard focus.
        """
        self.update_text_object( event )
        event.Skip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self._no_enum_update == 0:
            if self.factory.evaluate is None:
                try:
                    self.control.SetStringSelection(
                                     self.inverse_mapping[ self.value ] )
                except:
                    pass
            else:
                try:
                    self.control.SetValue( self.str_value )
                except:
                    pass

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        self.control.SetBackgroundColour( ErrorColor )
        self.control.Refresh()

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        # Note: This code is unnecessarily complex due to a strange bug in
        # wxWidgets implementation of the wx.Combobox control that has strange
        # behavior when the current text field value is one of the selection
        # values when 'Clear' is called. In this case, even saving and
        # restoring the text field value does not work, so we go to great
        # lengths to detect this case and avoid using 'Clear', but still get
        # the equivalent visual results. Modify this code at your own risk...

        control  = self.control
        clear    = True
        cur_name = None
        if self.factory.evaluate is not None:
            n         = control.GetCount()
            cur_names = [ control.GetString( i ) for i in range( n ) ]
            cur_name  = control.GetValue()
            if cur_name in self.names:
                clear   = False
                include = True
                for i in range( n - 1, -1, -1 ):
                    if cur_name == cur_names[i]:
                        include = False
                    else:
                        control.Delete( i )
                for name in self.names:
                    if include or (name != cur_name):
                        control.Append( name )
                cur_name = None
            else:
                point = control.GetInsertionPoint()

        if clear:
            control.Clear()
            control.AppendItems( self.names )

        if cur_name is not None:
            self._no_enum_update += 1
            control.SetValue( cur_name )
            control.SetInsertionPoint( point )
            self._no_enum_update -= 1

        self.update_editor()

#-------------------------------------------------------------------------------
#  'RadioEditor' class:
#-------------------------------------------------------------------------------

class RadioEditor ( BaseEditor ):
    """ Enumeration editor, used for the "custom" style, that displays radio
        buttons.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( RadioEditor, self ).init( parent )

        # Create a panel to hold all of the radio buttons:
        self.control = TraitsUIPanel( parent, -1 )
        self.rebuild_editor()

    #---------------------------------------------------------------------------
    #  Handles the user clicking one of the 'custom' radio buttons:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user clicking one of the custom radio buttons.
        """
        try:
            self.value = event.GetEventObject().value
        except:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        for button in self.control.GetChildren():
            state = (button.value == value)
            button.SetValue( state )
            if state:
                button.SetFocus()

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        # Clear any existing content:
        panel = self.control
        panel.SetSizer( None )
        panel.DestroyChildren()

        # Get the current trait value:
        cur_name = self.str_value

        # Create a sizer to manage the radio buttons:
        names   = self.names
        mapping = self.mapping
        n       = len( names )
        cols    = self.factory.cols
        rows    = (n + cols - 1) / cols
        incr    = [ n / cols ] * cols
        rem     = n % cols
        for i in range( cols ):
            incr[i] += (rem > i)
        incr[-1] = -(reduce( lambda x, y: x + y, incr[:-1], 0 ) - 1)
        if cols > 1:
            sizer = wx.GridSizer( 0, cols, 2, 4 )
        else:
            sizer = wx.BoxSizer( wx.VERTICAL )

        # Add the set of all possible choices:
        style = wx.RB_GROUP
        index = 0
        for i in range( rows ):
            for j in range( cols ):
                if n > 0:
                    name    = label = names[ index ]
                    label   = self.string_value( label, capitalize )
                    control = wx.RadioButton( panel, -1, label, style = style )
                    control.value = mapping[ name ]
                    style         = 0
                    control.SetValue( name == cur_name )
                    wx.EVT_RADIOBUTTON( panel, control.GetId(),
                                        self.update_object )
                    self.set_tooltip( control )
                    index += incr[j]
                    n     -= 1
                else:
                    control = wx.RadioButton( panel, -1, '' )
                    control.value = ''
                    control.Show( False )
                sizer.Add( control, 0, wx.NORTH, 5 )

        # Set-up the layout:
        panel.SetSizerAndFit( sizer )

#-------------------------------------------------------------------------------
#  'ListEditor' class:
#-------------------------------------------------------------------------------

class ListEditor ( BaseEditor ):
    """ Enumeration editor, used for the "custom" style, that displays a list
        box.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( ListEditor, self ).init( parent )

        # Create a panel to hold all of the radio buttons:
        self.control = wx.ListBox( parent, -1, wx.Point( 0, 0 ),
                                   wx.Size( -1, -1 ), self.names,
                                   style = wx.LB_SINGLE | wx.LB_NEEDED_SB )
        wx.EVT_LISTBOX( parent, self.control.GetId(), self.update_object )
        self.set_tooltip()

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        disconnect( self.control, wx.EVT_LISTBOX )

        super( ListEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the user selecting a list box item:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user selecting a list box item.
        """
        if not self._ignore_update:
            value = self.control.GetStringSelection()
            try:
                value = self.mapping[ value ]
            except:
                try:
                    value = self.factory.evaluate( value )
                except:
                    pass
            try:
                self.value = value
            except:
                pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        control = self.control
        try:
            index = control.FindString( self.inverse_mapping[ self.value ] )
            if index >= 0:
                control.SetSelection( index )
        except:
            pass

    #---------------------------------------------------------------------------
    #  Rebuilds the contents of the editor whenever the original factory
    #  object's 'values' trait changes:
    #---------------------------------------------------------------------------

    def rebuild_editor ( self ):
        """ Rebuilds the contents of the editor whenever the original factory
            object's **values** trait changes.
        """
        self._ignore_update = True
        self.control.Clear()
        self.control.AppendItems( self.names )
        self._ignore_update = False

        # fixme: Is this line necessary?
        self.update_editor()

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = bounds_editor
import wx

from traits.api import Float, Any, Str, Trait
from traitsui.editors.api import RangeEditor
from traitsui.wx.editor import Editor
from traitsui.wx.helper import TraitsUIPanel, Slider


class _BoundsEditor(Editor):

    evaluate = Any

    min = Any
    max = Any
    low = Any
    high = Any
    format = Str

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if not factory.low_name:
            self.low = factory.low
            self.min = self.low

        if not factory.high_name:
            self.high = factory.high
            self.max = self.high

        self.max = factory.max
        self.min = factory.min

        self.format = factory.format

        self.evaluate = factory.evaluate
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        self.sync_value( factory.low_name,  'low',  'both' )
        self.sync_value( factory.high_name, 'high', 'both' )

        self.control = panel = TraitsUIPanel( parent, -1 )
        sizer = wx.FlexGridSizer(2,3, 0, 0)

        # low text box
        self._label_lo = wx.TextCtrl(panel, -1, self.format % self.low,
                                         size=wx.Size(56, 20),
                                         style=wx.TE_PROCESS_ENTER )
        sizer.Add(self._label_lo, 0, wx.ALIGN_CENTER)
        wx.EVT_TEXT_ENTER(panel, self._label_lo.GetId(), self.update_low_on_enter)
        wx.EVT_KILL_FOCUS(self._label_lo, self.update_low_on_enter)

        # low slider
        self.control.lslider = Slider(panel, -1, 0, 0, 10000,
                                              size=wx.Size( 100, 20 ),
                                              style=wx.SL_HORIZONTAL|wx.SL_AUTOTICKS )
        self.control.lslider.SetValue(self._convert_to_slider(self.low))
        self.control.lslider.SetTickFreq( 1000, 1 )
        self.control.lslider.SetPageSize( 1000 )
        self.control.lslider.SetLineSize( 100 )
        wx.EVT_SCROLL( self.control.lslider, self.update_object_on_scroll )
        sizer.Add(self.control.lslider, 1, wx.EXPAND)
        sizer.AddStretchSpacer(0)

        # high slider
        sizer.AddStretchSpacer(0)
        self.control.rslider = Slider(panel, -1, self._convert_to_slider(self.high), 0, 10000,
                                              size=wx.Size( 100, 20 ),
                                              style=wx.SL_HORIZONTAL|wx.SL_AUTOTICKS )
        self.control.rslider.SetTickFreq( 1000, 1 )
        self.control.rslider.SetPageSize( 1000 )
        self.control.rslider.SetLineSize( 100 )
        wx.EVT_SCROLL( self.control.rslider, self.update_object_on_scroll )
        sizer.Add(self.control.rslider, 1, wx.EXPAND)

        # high text box
        self._label_hi = wx.TextCtrl(panel, -1, self.format % self.high,
                                         size=wx.Size(56, 20),
                                         style=wx.TE_PROCESS_ENTER )
        sizer.Add(self._label_hi, 0, wx.ALIGN_CENTER)
        wx.EVT_TEXT_ENTER(panel, self._label_hi.GetId(), self.update_high_on_enter)
        wx.EVT_KILL_FOCUS(self._label_hi, self.update_high_on_enter)

        self.set_tooltip(self.control.lslider)
        self.set_tooltip(self.control.rslider)
        self.set_tooltip(self._label_lo)
        self.set_tooltip(self._label_hi)


        # Set-up the layout:
        panel.SetSizerAndFit(sizer)


    def update_low_on_enter(self, value):
        try:
            try:
                low = eval(unicode(self._label_lo.GetValue()).strip())
                if self.evaluate is not None:
                    low = self.evaluate(low)
            except Exception, ex:
                low = self.low
                self._label_lo.SetValue(self.format % self.low)

            if not self.factory.is_float:
                low = int(low)

            if low > self.high:
                low = self.high - self._step_size()
                self._label_lo.SetValue(self.format % low)

            self.control.lslider.SetValue(self._convert_to_slider(low))
            self.low = low
        except:
            pass

    def update_high_on_enter(self, value):
        try:
            try:
                high = eval(unicode(self._label_hi.GetValue()).strip())
                if self.evaluate is not None:
                    high = self.evaluate(high)
            except:
                high = self.high
                self._label_hi.SetValue(self.format % self.high)

            if not self.factory.is_float:
                high = int(high)

            if high < self.low:
                high = self.low + self._step_size()
                self._label_hi.SetValue(self.format % high)

            self.control.rslider.SetValue(self._convert_to_slider(high))
            self.high = high
        except:
            pass

    def update_object_on_scroll(self, evt):
        low = self._convert_from_slider(self.control.lslider.GetValue())
        high = self._convert_from_slider(self.control.rslider.GetValue())

        if low >= high:
            if evt.Position == self.control.lslider.GetValue():
                low = self.high - self._step_size()
            else:
                high = self.low + self._step_size()

        if self.factory.is_float:
            self.low = low
            self.high = high
        else:
            self.low = int(low)
            self.high = int(high)

            # update the sliders to the int values or the sliders
            # will jiggle
            self.control.lslider.SetValue(self._convert_to_slider(low))
            self.control.rslider.SetValue(self._convert_to_slider(high))


    def update_editor(self):
        return

    def _check_max_and_min(self):
        # check if max & min have been defined:
        if self.max is None:
            self.max = self.high
        if self.min is None:
            self.min = self.low

    def _step_size(self):
        slider_delta = self.control.lslider.GetMax() - self.control.lslider.GetMin()
        range_delta = self.max - self.min

        return float(range_delta)/slider_delta

    def _convert_from_slider(self, slider_val):
        self._check_max_and_min()
        return self.min + slider_val * self._step_size()

    def _convert_to_slider(self, value):
        self._check_max_and_min()
        return self.control.lslider.GetMin() + (value-self.min) / self._step_size()

    def _low_changed(self, low):
        if self.control is None:
            return
        if self._label_lo is not None:
            self._label_lo.SetValue(self.format % low)

        self.control.lslider.SetValue(self._convert_to_slider(low))

    def _high_changed(self, high):
        if self.control is None:
            return
        if self._label_hi is not None:
            self._label_hi.SetValue(self.format % high)

        self.control.rslider.SetValue(self._convert_to_slider(self.high))

class BoundsEditor(RangeEditor):

    min = Trait(None, Float)
    max = Trait(None, Float)

    def _get_simple_editor_class(self):
        return _BoundsEditor
    def _get_custom_editor_class(self):
        return _BoundsEditor

########NEW FILE########
__FILENAME__ = led_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/02/2007
#
#-------------------------------------------------------------------------------

""" Traits UI 'display only' LED numeric editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from wx.gizmos \
    import LEDNumberCtrl, LED_ALIGN_LEFT, LED_ALIGN_CENTER, LED_ALIGN_RIGHT

from traits.api \
    import Enum

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# LED alignment styles:
LEDStyles = {
    'left':   LED_ALIGN_LEFT,
    'center': LED_ALIGN_CENTER,
    'right':  LED_ALIGN_RIGHT,
}

#-------------------------------------------------------------------------------
#  '_LEDEditor' class:
#-------------------------------------------------------------------------------

class _LEDEditor ( Editor ):
    """ Traits UI 'display only' LED numeric editor.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = LEDNumberCtrl( parent, -1 )
        self.control.SetAlignment( LEDStyles[ self.factory.alignment ] )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.SetValue( self.str_value )

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for LED editors:
class LEDEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _LEDEditor

    # The alignment of the numeric text within the control:
    alignment = Enum( 'right', 'left', 'center' )


########NEW FILE########
__FILENAME__ = flash_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/11/2007
#
#-------------------------------------------------------------------------------

""" Traits UI MS Flash editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import  wx

if wx.Platform == '__WXMSW__':
    from wx.lib.flashwin import FlashWindow

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

#-------------------------------------------------------------------------------
#  '_FlashEditor' class:
#-------------------------------------------------------------------------------

class _FlashEditor ( Editor ):
    """ Traits UI Flash editor.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the table editor is scrollable? This value overrides the default.
    scrollable = True

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = FlashWindow( parent )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.str_value.strip()
        if value.find( '://' ) < 0:
            value = 'file://' + value

        wx.BeginBusyCursor()
        self.control.LoadMovie( 0, value )
        wx.EndBusyCursor()

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for Flash editors:
class FlashEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _FlashEditor


########NEW FILE########
__FILENAME__ = ie_html_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/11/2007
#
#-------------------------------------------------------------------------------

""" Traits UI MS Internet Explorer editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import re
import webbrowser

import wx

if wx.Platform == '__WXMSW__':
    # The new version of IEHTMLWindow (wx 2.8.8.0) is mostly compatible with
    # the old one, but it has changed the API for handling COM events, so we
    # cannot use it.
    try:
        import wx.lib.iewin_old as iewin
    except ImportError:
        import wx.lib.iewin as iewin

from traits.api \
    import Bool, Event, Property, Str

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

#-------------------------------------------------------------------------------
#  Constants
#-------------------------------------------------------------------------------

RELATIVE_OBJECTS_PATTERN = re.compile(r'src=["\'](?!https?:)([\s\w/\.]+?)["\']',
                                      re.IGNORECASE)

#-------------------------------------------------------------------------------
#  '_IEHTMLEditor' class:
#-------------------------------------------------------------------------------

class _IEHTMLEditor ( Editor ):
    """ Traits UI MS Internet Explorer editor.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the table editor is scrollable? This value overrides the default.
    scrollable = True

    # External objects referenced in the HTML are relative to this url
    base_url = Str

    # Event fired when the browser home page should be displayed:
    home = Event

    # Event fired when the browser should show the previous page:
    back = Event

    # Event fired when the browser should show the next page:
    forward = Event

    # Event fired when the browser should stop loading the current page:
    stop = Event

    # Event fired when the browser should refresh the current page:
    refresh = Event

    # Event fired when the browser should search the current page:
    search = Event

    # The current browser status:
    status = Str

    # The current browser page title:
    title = Str

    # The URL of the page that just finished loading:
    page_loaded = Str

    # The current page content as HTML:
    html = Property

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = ie = iewin.IEHtmlWindow( parent, -1,
                                      style = wx.NO_FULL_REPAINT_ON_RESIZE )
        self.set_tooltip()

        factory = self.factory
        self.base_url = factory.base_url
        self.sync_value( factory.home,          'home',        'from' )
        self.sync_value( factory.back,          'back',        'from' )
        self.sync_value( factory.forward,       'forward',     'from' )
        self.sync_value( factory.stop,          'stop',        'from' )
        self.sync_value( factory.refresh,       'refresh',     'from' )
        self.sync_value( factory.search,        'search',      'from' )
        self.sync_value( factory.status,        'status',      'to' )
        self.sync_value( factory.title,         'title',       'to' )
        self.sync_value( factory.page_loaded,   'page_loaded', 'to' )
        self.sync_value( factory.html,          'html',        'to' )
        self.sync_value( factory.base_url_name, 'base_url',    'from' )

        parent.Bind( iewin.EVT_StatusTextChange, self._status_modified,     ie )
        parent.Bind( iewin.EVT_TitleChange,      self._title_modified,      ie )
        parent.Bind( iewin.EVT_DocumentComplete, self._page_loaded_modified,ie )
        parent.Bind( iewin.EVT_NewWindow2,       self._new_window_modified, ie )
        parent.Bind( iewin.EVT_BeforeNavigate2,  self._navigate_requested,  ie )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.str_value.strip()

        # We can correct URLs via the BeforeNavigate Event, but the COM
        # interface provides no such option for images. Sadly, we are forced
        # to take a more brute force approach.
        if self.base_url:
            rep = lambda m: r'src="%s%s"' % ( self.base_url, m.group( 1 ) )
            value = re.sub( RELATIVE_OBJECTS_PATTERN, rep, value )

        if value == '':
            self.control.LoadString( '<html><body></body></html>' )

        elif value[:1] == '<':
            self.control.LoadString( value )

        elif (value[:4] != 'http') or (value.find( '://' ) < 0):
            try:
                file = open( value, 'rb' )
                self.control.LoadStream( file )
                file.close()
            except:
                pass

        else:
            self.control.Navigate( value )

    #-- Property Implementations -----------------------------------------------

    def _get_html ( self ):
        return self.control.GetText()

    def _set_html ( self, value ):
        self.control.LoadString( value )

    #-- Event Handlers ---------------------------------------------------------

    def _home_changed ( self ):
        self.control.GoHome()

    def _back_changed ( self ):
        self.control.GoBack()

    def _forward_changed ( self ):
        self.control.GoForward()

    def _stop_changed ( self ):
        self.control.Stop()

    def _search_changed ( self ):
        self.control.GoSearch()

    def _refresh_changed ( self ):
        self.control.Refresh( iewin.REFRESH_COMPLETELY )

    def _status_modified ( self, event ):
        self.status = event.Text

    def _title_modified ( self, event ):
        self.title = event.Text

    def _page_loaded_modified ( self, event ):
        self.page_loaded = event.URL
        self.trait_property_changed( 'html', '', self.html )

    def _new_window_modified ( self, event ):
        # If the event is cancelled, new windows can be disabled.
        # At this point we've opted to allow new windows
        pass

    def _navigate_requested ( self, event ):
        # The way NavigateToString works is to navigate to about:blank then
        # load the supplied HTML into the document property. This borks
        # relative URLs.
        if event.URL.startswith ( 'about:' ):
            base = self.base_url
            if not base.endswith( '/' ):
                base += '/'
            event.URL = base + event.URL[6:]

        if self.factory.open_externally:
            event.Cancel = True
            webbrowser.get( 'windows-default' ).open_new( event.URL )

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for MS Internet Explorer editors:
class IEHTMLEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _IEHTMLEditor

    # External objects referenced in the HTML are relative to this url
    base_url = Str

    # The object trait containing the base URL
    base_url_name = Str

    # Should links be opened in an external browser?
    open_externally = Bool(False)

    # Optional name of trait used to tell browser to show Home page:
    home = Str

    # Optional name of trait used to tell browser to view the previous page:
    back = Str

    # Optional name of trait used to tell browser to view the next page:
    forward = Str

    # Optional name of trait used to tell browser to stop loading page:
    stop = Str

    # Optional name of trait used to tell browser to refresh the current page:
    refresh = Str

    # Optional name of trait used to tell browser to search the current page:
    search = Str

    # Optional name of trait used to contain the current browser status:
    status = Str

    # Optional name of trait used to contain the current browser page title:
    title = Str

    # Optional name of trait used to contain the URL of the page that just
    # completed loading:
    page_loaded = Str

    # Optional name of trait used to get/set the page content as HTML:
    html = Str


########NEW FILE########
__FILENAME__ = file_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines file editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from os.path \
    import abspath, splitext, isfile, exists

from traits.api \
    import List, Str, Event, Any, on_trait_change, TraitError

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.file_editor file.
from traitsui.editors.file_editor \
    import ToolkitEditorFactory

from text_editor \
    import SimpleEditor as SimpleTextEditor

from helper \
    import TraitsUIPanel, PopupControl

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Wildcard filter:
filter_trait = List( Str )

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( SimpleTextEditor ):
    """ Simple style of file editor, consisting of a text field and a **Browse**
        button that opens a file-selection dialog box. The user can also drag
        and drop a file onto this control.
    """

    # The history control (used if the factory 'entries' > 0):
    history = Any

    # The popup file control (an Instance( PopupFile )):
    popup = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = panel = TraitsUIPanel( parent, -1 )
        sizer        = wx.BoxSizer( wx.HORIZONTAL )
        factory      = self.factory

        if factory.entries > 0:
            from history_control import HistoryControl

            self.history = HistoryControl( entries  = factory.entries,
                                           auto_set = factory.auto_set )
            control      = self.history.create_control( panel )
            pad          = 3
            button       = wx.Button( panel, -1, '...',
                                      size = wx.Size( 28, -1 ) )
        else:
            if factory.enter_set:
                control = wx.TextCtrl( panel, -1, '',
                                       style = wx.TE_PROCESS_ENTER )
                wx.EVT_TEXT_ENTER( panel, control.GetId(), self.update_object )
            else:
                control = wx.TextCtrl( panel, -1, '' )

            wx.EVT_KILL_FOCUS( control, self.update_object )

            if factory.auto_set:
                wx.EVT_TEXT( panel, control.GetId(), self.update_object )

            bmp    = wx.ArtProvider.GetBitmap( wx.ART_FOLDER_OPEN,
                                               size = ( 15, 15 ) )
            button = wx.BitmapButton( panel, -1, bitmap = bmp )
            
            pad    = 8

        self._file_name = control
        sizer.Add( control, 1, wx.EXPAND | wx.ALIGN_CENTER )
        sizer.Add( button,  0, wx.LEFT   | wx.ALIGN_CENTER, pad )
        wx.EVT_BUTTON( panel, button.GetId(), self.show_file_dialog )
        panel.SetDropTarget( FileDropTarget( self ) )
        panel.SetSizerAndFit( sizer )
        self._button = button

        self.set_tooltip( control )

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        panel = self.control
        wx.EVT_BUTTON( panel, self._button.GetId(), None )
        self._button = None

        if self.history is not None:
            self.history.dispose()
            self.history = None
        else:
            factory = self.factory
            control, self._file_name = self._file_name, None
            wx.EVT_KILL_FOCUS( control,                None )
            wx.EVT_TEXT_ENTER( panel, control.GetId(), None )
            wx.EVT_TEXT(       panel, control.GetId(), None )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the history 'value' trait being changed:
    #---------------------------------------------------------------------------

    @on_trait_change( 'history:value' )
    def _history_value_changed ( self, value ):
        """ Handles the history 'value' trait being changed.
        """
        if not self._no_update:
            self._update( value )

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user changing the contents of the edit control.
        """
        self._update( self._file_name.GetValue() )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.history is not None:
            self._no_update    = True
            self.history.value = self.str_value
            self._no_update    = False
        else:
            self._file_name.SetValue( self.str_value )

    #---------------------------------------------------------------------------
    #  Displays the pop-up file dialog:
    #---------------------------------------------------------------------------

    def show_file_dialog ( self, event ):
        """ Displays the pop-up file dialog.
        """
        if self.history is not None:
            self.popup = self._create_file_popup()
        else:
            dlg       = self._create_file_dialog()
            rc        = (dlg.ShowModal() == wx.ID_OK)
            file_name = abspath( dlg.GetPath() )
            dlg.Destroy()
            if rc:
                if self.factory.truncate_ext:
                    file_name = splitext( file_name )[0]

                self.value = file_name
                self.update_editor()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._file_name

    #-- Traits Event Handlers --------------------------------------------------

    @on_trait_change( 'popup:value' )
    def _popup_value_changed ( self, file_name ):
        """ Handles the popup value being changed.
        """
        if self.factory.truncate_ext:
            file_name = splitext( file_name )[0]

        self.value      = file_name
        self._no_update = True
        self.history.set_value( self.str_value )
        self._no_update = False

    @on_trait_change( 'popup:closed' )
    def _popup_closed_changed ( self ):
        """ Handles the popup control being closed.
        """
        self.popup = None

    #-- UI preference save/restore interface -----------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if self.history is not None:
            self.history.history = \
                prefs.get( 'history', [] )[ : self.factory.entries ]

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        if self.history is not None:
            return { 'history': self.history.history[:] }

        return None

    #-- Private Methods --------------------------------------------------------

    def _create_file_dialog ( self ):
        """ Creates the correct type of file dialog.
        """
        if len( self.factory.filter ) > 0:
            wildcard = '|'.join( self.factory.filter[:] )
        else:
            wildcard = 'All Files (*.*)|*.*'

        if self.factory.dialog_style == 'save':
            style = wx.FD_SAVE
        elif self.factory.dialog_style == 'open':
            style = wx.FD_OPEN
        else:
            style = wx.FD_DEFAULT_STYLE

        dlg = wx.FileDialog( self.control,
                             message  = 'Select a File',
                             wildcard = wildcard,
                             style=style)

        dlg.SetFilename( self._get_value() )

        return dlg

    def _create_file_popup ( self ):
        """ Creates the correct type of file popup.
        """
        return PopupFile( control   = self.control,
                          file_name = self.str_value,
                          filter    = self.factory.filter,
                          height    = 300 )

    def _update ( self, file_name ):
        """ Updates the editor value with a specified file name.
        """
        try:
            if self.factory.truncate_ext:
                file_name = splitext( file_name )[0]

            self.value = file_name
        except TraitError, excp:
            pass

    def _get_value ( self ):
        """ Returns the current file name from the edit control.
        """
        if self.history is not None:
            return self.history.value

        return self._file_name.GetValue()

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleTextEditor ):
    """ Custom style of file editor, consisting of a file system tree view.
    """

    # Is the file editor scrollable? This value overrides the default.
    scrollable = True

    # Wildcard filter to apply to the file dialog:
    filter = filter_trait

    # Event fired when the file system view should be rebuilt:
    reload = Event

    # Event fired when the user double-clicks a file:
    dclick = Event

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        style   = self.get_style()
        factory = self.factory
        if (len( factory.filter ) > 0) or (factory.filter_name != ''):
            style |= wx.DIRCTRL_SHOW_FILTERS

        self.control = wx.GenericDirCtrl( parent, style = style )
        self._tree   = tree = self.control.GetTreeCtrl()
        id           = tree.GetId()
        wx.EVT_TREE_SEL_CHANGED(     tree, id, self.update_object )
        wx.EVT_TREE_ITEM_ACTIVATED(  tree, id, self._on_dclick )
        wx.EVT_TREE_ITEM_GETTOOLTIP( tree, id, self._on_tooltip )

        self.filter = factory.filter
        self.sync_value( factory.filter_name, 'filter', 'from', is_list = True )
        self.sync_value( factory.reload_name, 'reload', 'from' )
        self.sync_value( factory.dclick_name, 'dclick', 'to' )

        self.set_tooltip()

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        tree, self._tree = self._tree, None
        id = tree.GetId()

        wx.EVT_TREE_SEL_CHANGED(    tree, id, None )
        wx.EVT_TREE_ITEM_ACTIVATED( tree, id, None )

        super( CustomEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user changing the contents of the edit control.
        """
        if self.control is not None:
            path = self.control.GetPath()
            if self.factory.allow_dir or isfile( path ):
                if self.factory.truncate_ext:
                    path = splitext( path )[0]

                self.value = path

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if exists( self.str_value ):
            self.control.SetPath( self.str_value )

    #---------------------------------------------------------------------------
    #  Returns the basic style to use for the control:
    #---------------------------------------------------------------------------

    def get_style ( self ):
        """ Returns the basic style to use for the control.
        """
        return wx.DIRCTRL_EDIT_LABELS

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._tree

    #---------------------------------------------------------------------------
    #  Handles the 'filter' trait being changed:
    #---------------------------------------------------------------------------

    def _filter_changed ( self ):
        """ Handles the 'filter' trait being changed.
        """
        self.control.SetFilter( '|'.join( self.filter[:] ) )

    #---------------------------------------------------------------------------
    #  Handles the user double-clicking on a file name:
    #---------------------------------------------------------------------------

    def _on_dclick ( self, event ):
        """ Handles the user double-clicking on a file name.
        """
        self.dclick = self.control.GetPath()

    #---------------------------------------------------------------------------
    #  Handles the user hovering on a file name for a tooltip:
    #---------------------------------------------------------------------------

    def _on_tooltip ( self, event ):
        """ Handles the user hovering on a file name for a tooltip.
        """
        text = self._tree.GetItemText(event.GetItem())
        event.SetToolTip(text)

    #---------------------------------------------------------------------------
    #  Handles the 'reload' trait being changed:
    #---------------------------------------------------------------------------

    def _reload_changed ( self ):
        """ Handles the 'reload' trait being changed.
        """
        self.control.ReCreateTree()

#-------------------------------------------------------------------------------
#  'PopupFile' class:
#-------------------------------------------------------------------------------

class PopupFile ( PopupControl ):

    # The initially specified file name:
    file_name = Str

    # The file name filter to support:
    filter = filter_trait

    # Override of PopupControl trait to make the popup resizable:
    resizable = True

    #-- PopupControl Method Overrides ------------------------------------------

    def create_control ( self, parent ):
        """ Creates the file control and gets it ready for use.
        """
        style = self.get_style()
        if len( self.filter ) > 0:
            style |= wx.DIRCTRL_SHOW_FILTERS

        self._files = files = wx.GenericDirCtrl( parent, style = style,
                                          filter = '|'.join( self.filter ) )
        files.SetPath( self.file_name )
        self._tree  = tree = files.GetTreeCtrl()
        wx.EVT_TREE_SEL_CHANGED( tree, tree.GetId(), self._select_file )

    def dispose ( self ):
        wx.EVT_TREE_SEL_CHANGED( self._tree, self._tree.GetId(), None )
        self._tree = self._files = None

    def get_style ( self ):
        """ Returns the base style for this type of popup.
        """
        return wx.DIRCTRL_EDIT_LABELS

    def is_valid ( self, path ):
        """ Returns whether or not the path is valid.
        """
        return isfile( path )

    #-- Private Methods --------------------------------------------------------

    def _select_file ( self, event ):
        """ Handles a file being selected in the file control.
        """
        path = self._files.GetPath()

        # We have to make sure the selected path is different than the original
        # path because when a filter is changed we get called with the currently
        # selected path, even though no file was actually selected by the user.
        # So we only count it if it is a different path.
        #
        # We also check the last character of the path, because under Windows
        # we get a call when the filter is changed for each drive letter. If the
        # drive is not available, it can take the 'isfile' call a long time to
        # time out, so we attempt to ignore them by doing a quick test to see
        # if it could be a valid file name, and ignore it if it is not:
        if ((path != abspath( self.file_name )) and
            (path[-1:] not in ( '/\\' ))        and
            self.is_valid( path )):
            self.value = path

#-------------------------------------------------------------------------------
#  'FileDropTarget' class:
#-------------------------------------------------------------------------------

class FileDropTarget ( wx.FileDropTarget ):
    """ A target for a drag and drop operation, which accepts a file.
    """
    def __init__ ( self, editor ):
        wx.FileDropTarget.__init__( self )
        self.editor = editor

    def OnDropFiles ( self, x, y, file_names ):
        self.editor.value = file_names[-1]
        self.editor.update_editor()

        return True

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = font_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various font editors and the font editor factory, for the
    wxPython user interface toolkit..
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api import Bool

from traitsui.editors.font_editor \
    import ToolkitEditorFactory as BaseToolkitEditorFactory

from editor_factory \
    import SimpleEditor as BaseSimpleEditor, \
    TextEditor as BaseTextEditor, \
    ReadonlyEditor as BaseReadonlyEditor

from editor \
    import Editor

from helper \
    import TraitsUIPanel, disconnect

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Standard font point sizes
PointSizes = [
   '8',  '9', '10', '11', '12', '14', '16', '18',
  '20', '22', '24', '26', '28', '36', '48', '72'
]

# All available font styles
Styles = ['Normal', 'Slant', 'Italic']

# All available font weights
Weights = ['Normal', 'Light', 'Bold']

# All available font facenames
facenames = None

#---------------------------------------------------------------------------
#  The wxPython ToolkitEditorFactory class.
#---------------------------------------------------------------------------
## We need to add wx-specific methods to the editor factory, and so we create
## a subclass of the BaseToolkitEditorFactory.

class ToolkitEditorFactory(BaseToolkitEditorFactory):
    """ wxPython editor factory for font editors.
    """

    show_style = Bool(False)
    show_weight = Bool(False)

    #---------------------------------------------------------------------------
    #  Returns a wxFont object corresponding to a specified object's font trait:
    #---------------------------------------------------------------------------

    def to_wx_font ( self, editor ):
        """ Returns a wxFont object corresponding to a specified object's font
        trait.
        """
        font = editor.value
        return wx.Font( font.GetPointSize(), font.GetFamily(), font.GetStyle(),
                        font.GetWeight(),    font.GetUnderlined(),
                        font.GetFaceName() )

    #---------------------------------------------------------------------------
    #  Gets the application equivalent of a wxPython Font value:
    #---------------------------------------------------------------------------

    def from_wx_font ( self, font ):
        """ Gets the application equivalent of a wxPython Font value.
        """
        return font

    #---------------------------------------------------------------------------
    #  Returns the text representation of the specified object trait value:
    #---------------------------------------------------------------------------

    def str_font ( self, font ):
        """ Returns the text representation of the specified object trait value.
        """
        weight = { wx.LIGHT: ' Light',
                    wx.BOLD:  ' Bold'   }.get( font.GetWeight(), '' )
        style  = { wx.SLANT: ' Slant',
                    wx.ITALIC:' Italic' }.get( font.GetStyle(), '' )
        return '%s point %s%s%s' % (
                font.GetPointSize(), font.GetFaceName(), style, weight )

    #---------------------------------------------------------------------------
    #  Returns a list of all available font facenames:
    #---------------------------------------------------------------------------

    def all_facenames ( self ):
        """ Returns a list of all available font facenames.
        """
        global facenames

        if facenames is None:
            facenames = FontEnumerator().facenames()
            facenames.sort()
        return facenames

#-------------------------------------------------------------------------------
#  'SimpleFontEditor' class:
#-------------------------------------------------------------------------------

class SimpleFontEditor ( BaseSimpleEditor ):
    """ Simple style of font editor, which displays a text field that contains
        a text representation of the font value (using that font if possible).
        Clicking the field displays a font selection dialog box.
    """

    #---------------------------------------------------------------------------
    #  Invokes the pop-up editor for an object trait:
    #---------------------------------------------------------------------------

    def popup_editor ( self, event ):
        """ Invokes the pop-up editor for an object trait.
        """
        font_data = wx.FontData()
        font_data.SetInitialFont( self.factory.to_wx_font( self ) )
        dialog = wx.FontDialog( self.control, font_data )
        if dialog.ShowModal() == wx.ID_OK:
            self.value = self.factory.from_wx_font(
                              dialog.GetFontData().GetChosenFont() )
            self.update_editor()

        dialog.Destroy()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        super( SimpleFontEditor, self ).update_editor()
        set_font( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

#-------------------------------------------------------------------------------
#  'CustomFontEditor' class:
#-------------------------------------------------------------------------------

class CustomFontEditor ( Editor ):
    """ Custom style of font editor, which displays the following:

        * A combo box containing all available type face names.
        * A combo box containing the available type sizes.
        * A combo box containing the available type styles
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Create a panel to hold all of the buttons:
        self.control = panel = TraitsUIPanel( parent, -1 )
        sizer = wx.BoxSizer( wx.VERTICAL )

        # Add all of the font choice controls:
        sizer2    = wx.BoxSizer( wx.HORIZONTAL )
        facenames = self.factory.all_facenames()
        control   = self._facename = wx.Choice( panel, -1, wx.Point( 0, 0 ),
                                                wx.Size( -1, -1 ), facenames )

        sizer2.Add( control, 4, wx.EXPAND )
        wx.EVT_CHOICE( panel, control.GetId(), self.update_object_parts )

        control = self._point_size = wx.Choice( panel, -1, wx.Point( 0, 0 ),
                                                wx.Size( -1, -1 ), PointSizes )
        sizer2.Add( control, 1, wx.EXPAND | wx.LEFT, 3 )
        wx.EVT_CHOICE( panel, control.GetId(), self.update_object_parts )

        if self.factory.show_style:
            self._style = wx.Choice(panel, -1, wx.Point(0,0),
                                    wx.Size(-1, -1), Styles)
            sizer2.Add(self._style, 1, wx.EXPAND | wx.LEFT, 3)
            wx.EVT_CHOICE( panel, self._style.GetId(), self.update_object_parts )

        if self.factory.show_weight:
            self._weight = wx.Choice(panel, -1, wx.Point(0,0),
                                    wx.Size(-1, -1), Weights)
            sizer2.Add(self._weight, 1, wx.EXPAND | wx.LEFT, 3)
            wx.EVT_CHOICE( panel, self._weight.GetId(), self.update_object_parts )

        sizer.Add( sizer2, 0, wx.EXPAND )


        # Set-up the layout:
        panel.SetSizer( sizer )

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        disconnect( self._facename,   wx.EVT_CHOICE )
        disconnect( self._point_size, wx.EVT_CHOICE )
        if self.factory.show_style:
            disconnect(self._style, wx.EVT_CHOICE)
        if self.factory.show_weight:
            disconnect(self._weight, wx.EVT_CHOICE)

        super( CustomFontEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the user modifying one of the font components:
    #---------------------------------------------------------------------------

    def update_object_parts ( self, event ):
        """ Handles the user modifying one of the font components.
        """
        point_size = int( self._point_size.GetStringSelection() )
        facename   = self._facename.GetStringSelection()

        style = wx.FONTSTYLE_NORMAL
        if self.factory.show_style:
            style += self._style.GetCurrentSelection()

        weight = wx.FONTWEIGHT_NORMAL
        if self.factory.show_weight:
            weight += self._weight.GetCurrentSelection()

        font       = wx.Font( point_size, wx.DEFAULT, style, weight,
                              faceName = facename )
        self.value = self.factory.from_wx_font( font )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        font = self.factory.to_wx_font( self )

        try:
           self._facename.SetStringSelection( font.GetFaceName() )
        except:
           self._facename.SetSelection( 0 )

        try:
           self._point_size.SetStringSelection( str( font.GetPointSize() ) )
        except:
           self._point_size.SetSelection( 0 )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )


#-------------------------------------------------------------------------------
#  'TextFontEditor' class:
#-------------------------------------------------------------------------------

class TextFontEditor ( BaseTextEditor ):
    """ Text style of font editor, which displays an editable text field
        containing a text representation of the font value (using that font if
        possible).
    """

    #---------------------------------------------------------------------------
    #  Handles the user changing the contents of the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user changing the contents of the edit control.
        """
        self.value = self.control.GetValue()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        super( TextFontEditor, self ).update_editor()
        set_font( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

#-------------------------------------------------------------------------------
#  'ReadonlyFontEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyFontEditor ( BaseReadonlyEditor ):
    """ Read-only style of font editor, which displays a read-only text field
        containing a text representation of the font value (using that font if
        possible).
    """

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        super( ReadonlyFontEditor, self ).update_editor()
        set_font( self )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified font value:
    #---------------------------------------------------------------------------

    def string_value ( self, font ):
        """ Returns the text representation of a specified font value.
        """
        return self.factory.str_font( font )

#-------------------------------------------------------------------------------
#  Set the editor control's font to match a specified font:
#-------------------------------------------------------------------------------

def set_font ( editor ):
    """ Sets the editor control's font to match a specified font.
    """
    font = editor.factory.to_wx_font( editor )
    font.SetPointSize( min( 10, font.GetPointSize() ) )
    editor.control.SetFont( font )

#-------------------------------------------------------------------------------
#  'FontEnumerator' class:
#-------------------------------------------------------------------------------

class FontEnumerator ( wx.FontEnumerator ):
    """ An enumeration of fonts.
    """
    #---------------------------------------------------------------------------
    #  Returns a list of all available font facenames:
    #---------------------------------------------------------------------------

    def facenames ( self ):
        """ Returns a list of all available font facenames.
        """
        self._facenames = []
        self.EnumerateFacenames()
        return self._facenames

    #---------------------------------------------------------------------------
    #  Adds a facename to the list of facenames:
    #---------------------------------------------------------------------------

    def OnFacename ( self, facename ):
        """ Adds a facename to the list of facenames.
        """
        self._facenames.append( facename )
        return True

# Define the names SimpleEditor, CustomEditor, TextEditor and ReadonlyEditor
# which are looked up by the editor factory for the font editor.
SimpleEditor = SimpleFontEditor
CustomEditor = CustomFontEditor
TextEditor = TextFontEditor
ReadonlyEditor = ReadonlyFontEditor

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = font_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/22/2004
#
#------------------------------------------------------------------------------

""" Trait definition for a wxPython-based font.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Trait, TraitHandler, TraitError

#-------------------------------------------------------------------------------
#  Convert a string into a valid 'wxFont' object (if possible):
#-------------------------------------------------------------------------------

# Mapping of strings to valid wxFont families
font_families = {
    'default':    wx.DEFAULT,
    'decorative': wx.DECORATIVE,
    'roman':      wx.ROMAN,
    'script':     wx.SCRIPT,
    'swiss':      wx.SWISS,
    'modern':     wx.MODERN
}

# Mapping of strings to wxFont styles
font_styles = {
    'slant':  wx.SLANT,
    'italic': wx.ITALIC
}

# Mapping of strings wxFont weights
font_weights = {
    'light': wx.LIGHT,
    'bold':  wx.BOLD
}

# Strings to ignore in text representations of fonts
font_noise = [ 'pt', 'point', 'family' ]

#-------------------------------------------------------------------------------
#  Converts a wx.Font into a string description of itself:
#-------------------------------------------------------------------------------

def font_to_str ( font ):
    """ Converts a wx.Font into a string description of itself.
    """
    weight = { wx.LIGHT:  ' Light',
               wx.BOLD:   ' Bold'   }.get( font.GetWeight(), '' )
    style  = { wx.SLANT:  ' Slant',
               wx.ITALIC: ' Italic' }.get( font.GetStyle(), '' )
    underline = ''
    if font.GetUnderlined():
        underline = ' underline'
    return '%s point %s%s%s%s' % (
           font.GetPointSize(), font.GetFaceName(), style, weight, underline )

#-------------------------------------------------------------------------------
#  Create a TraitFont object from a string description:
#-------------------------------------------------------------------------------

def create_traitsfont ( value ):
    """ Create a TraitFont object from a string description.
    """
    if isinstance( value, wx.Font ):
        value = font_to_str( value )

    point_size = None
    family     = wx.DEFAULT
    style      = wx.NORMAL
    weight     = wx.NORMAL
    underline  = 0
    facename   = []
    for word in value.split():
        lword = word.lower()
        if font_families.has_key( lword ):
            family = font_families[ lword ]
        elif font_styles.has_key( lword ):
            style = font_styles[ lword ]
        elif font_weights.has_key( lword ):
            weight = font_weights[ lword ]
        elif lword == 'underline':
            underline = 1
        elif lword not in font_noise:
            if point_size is None:
                try:
                    point_size = int( lword )
                    continue
                except:
                    pass
            facename.append( word )
    return TraitsFont( point_size or 10, family, style, weight, underline,
                    ' '.join( facename ) )

#-------------------------------------------------------------------------------
#  'TraitsFont' class:
#-------------------------------------------------------------------------------

class TraitsFont ( wx.Font ):
    """ A Traits-specific wx.Font.
    """
    #---------------------------------------------------------------------------
    #  Returns the pickleable form of a TraitsFont object:
    #---------------------------------------------------------------------------

    def __reduce_ex__ ( self, protocol ):
        """ Returns the pickleable form of a TraitsFont object.
        """
        return ( create_traitsfont, ( font_to_str( self ), ) )

    #---------------------------------------------------------------------------
    #  Returns a printable form of the font:
    #---------------------------------------------------------------------------

    def __str__ ( self ):
        """ Returns a printable form of the font.
        """
        return font_to_str( self )

#-------------------------------------------------------------------------------
#  'TraitWXFont' class'
#-------------------------------------------------------------------------------

class TraitWXFont ( TraitHandler ):
    """ Ensures that values assigned to a trait attribute are valid font
    descriptor strings; the value actually assigned is the corresponding
    TraitsFont.
    """
    #---------------------------------------------------------------------------
    #  Validates that the value is a valid font:
    #---------------------------------------------------------------------------

    def validate ( self, object, name, value ):
        """ Validates that the value is a valid font descriptor string. If so,
        it returns the corresponding TraitsFont; otherwise, it raises a
        TraitError.
        """
        if value is None:
            return None

        try:
            return create_traitsfont( value )
        except:
            pass

        raise TraitError, ( object, name, 'a font descriptor string',
                            repr( value ) )

    def info ( self ):
        return ( "a string describing a font (e.g. '12 pt bold italic "
                 "swiss family Arial' or 'default 12')" )

#-------------------------------------------------------------------------------
#  Define a wxPython specific font trait:
#-------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the FontEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a Font trait which lead to this file getting
# imported. This leads to a circular import when declaring a Font trait.
def get_font_editor(*args, **traits):
    from font_editor import ToolkitEditorFactory
    return ToolkitEditorFactory(*args, **traits)

fh     = TraitWXFont()
WxFont = Trait( wx.SystemSettings_GetFont( wx.SYS_DEFAULT_GUI_FONT ), fh, editor = get_font_editor )

########NEW FILE########
__FILENAME__ = helper
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/25/2004
#
#------------------------------------------------------------------------------

""" Defines helper functions and classes used to define wxPython-based trait
    editors and trait editor factories.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx
import wx.lib.scrolledpanel

import sys

from os.path \
    import join, dirname, abspath

from traits.api \
    import HasPrivateTraits, Enum, CTrait, Instance, Any, Int, \
           Event, Bool, BaseTraitHandler, TraitError

from traitsui.ui_traits \
    import convert_image, SequenceTypes

from pyface.timer.api \
    import do_later

from constants \
    import standard_bitmap_width, screen_dx, screen_dy

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Layout orientation for a control and its associated editor
Orientation = Enum( 'horizontal', 'vertical' )

#-------------------------------------------------------------------------------
#  Data:
#-------------------------------------------------------------------------------

# Bitmap cache dictionary (indexed by filename)
_bitmap_cache = {}

### NOTE: This needs major improvements:

app_path    = None
traits_path = None

#-------------------------------------------------------------------------------
#  Convert an image file name to a cached bitmap:
#-------------------------------------------------------------------------------

def bitmap_cache ( name, standard_size, path = None ):
    """ Converts an image file name to a cached bitmap.
    """
    global app_path, traits_path

    if name[:1] == '@':
        image = convert_image( name.replace( ' ', '_' ).lower() )
        if image is not None:
            return image.create_image().ConvertToBitmap()

    if path is None:
        if traits_path is None:
           import  traitsui.wx
           traits_path = join( dirname( traitsui.wx.__file__ ),
                               'images' )
        path = traits_path
    elif path == '':
        if app_path is None:
            app_path = join( dirname( sys.argv[0] ), '..', 'images' )
        path = app_path

    filename = abspath( join( path, name.replace( ' ', '_' ).lower() + '.gif' ))
    bitmap   = _bitmap_cache.get( filename + ('*'[ not standard_size: ]) )
    if bitmap is not None:
        return bitmap

    std_bitmap = bitmap = wx.BitmapFromImage( wx.Image( filename ) )
    _bitmap_cache[ filename ] = bitmap

    dx = bitmap.GetWidth()
    if dx < standard_bitmap_width:
        dy = bitmap.GetHeight()
        std_bitmap = wx.EmptyBitmap( standard_bitmap_width, dy )
        dc1 = wx.MemoryDC()
        dc2 = wx.MemoryDC()
        dc1.SelectObject( std_bitmap )
        dc2.SelectObject( bitmap )
        dc1.SetPen( wx.TRANSPARENT_PEN )
        dc1.SetBrush( wx.WHITE_BRUSH )
        dc1.DrawRectangle( 0, 0, standard_bitmap_width, dy )
        dc1.Blit( (standard_bitmap_width - dx) / 2, 0, dx, dy, dc2, 0, 0 )

    _bitmap_cache[ filename + '*' ] = std_bitmap

    if standard_size:
        return std_bitmap

    return bitmap

#-------------------------------------------------------------------------------
#  Returns an appropriate width for a wxChoice widget based upon the list of
#  values it contains:
#-------------------------------------------------------------------------------

def choice_width ( values ):
    """ Returns an appropriate width for a wxChoice widget based upon the list
        of values it contains:
    """
    return max( [ len( x ) for x in values ] ) * 6

#-------------------------------------------------------------------------------
#  Saves the user preference items for a specified UI:
#-------------------------------------------------------------------------------

def save_window ( ui ):
    """ Saves the user preference items for a specified UI.
    """
    control = ui.control
    ui.save_prefs( control.GetPositionTuple() + control.GetSizeTuple() )

#-------------------------------------------------------------------------------
#  Restores the user preference items for a specified UI:
#-------------------------------------------------------------------------------

def restore_window ( ui, is_popup = False ):
    """ Restores the user preference items for a specified UI.
    """
    prefs = ui.restore_prefs()
    if prefs is not None:
        x, y, dx, dy = prefs

        # Check to see if the window's position is within a display.
        # If it is not entirely within 1 display, move it and/or
        # resize it to the closest window

        closest = find_closest_display(x,y)
        x, y, dx, dy = get_position_for_display(x, y, dx, dy, closest)

        if is_popup:
            position_window( ui.control, dx, dy )
        else:
            if (dx, dy) == (0,0):
                # The window was saved minimized
                ui.control.SetDimensions( x, y, -1, -1 )
            else:
                ui.control.SetDimensions( x, y, dx, dy )


def find_closest_display(x, y):
    """ For a virtual screen position, find the closest display.
        There are a few reasons to use this function:
            * the number of displays changed
            * the size of the displays changed
            * the orientation of one or more displays changed.
    """
    closest = None
    for display_num in range(wx.Display.GetCount()):
        display = wx.Display(display_num)
        if closest is None:
            closest = display
        else:
            def _distance(x, y, display):
                dis_x, dis_y, dis_w, dis_h = display.GetGeometry()
                dis_mid_x = (dis_x+dis_w)/2
                dis_mid_y = (dis_y+dis_h)/2

                return (x-dis_mid_x)**2 + (y-dis_mid_y)**2

            if _distance(x, y, display) < _distance(x, y, closest):
                closest = display

    return closest

def get_position_for_display(x, y, dx, dy, display):
    """ calculates a valid position and size for a window to fit
        inside a display
    """
    dis_x, dis_y, dis_w, dis_h = display.GetGeometry()
    dx = min(dx, dis_w)
    dy = min(dy, dis_h)
    if ((x + dx) > (dis_x + dis_w)) or (x < dis_x):
        x = dis_x
    if ((y + dy) > (dis_y + dis_h)) or (y < dis_y):
        y = dis_y

    return x, y, dx, dy

#-------------------------------------------------------------------------------
#  Positions a window on the screen with a specified width and height so that
#  the window completely fits on the screen if possible:
#-------------------------------------------------------------------------------

def position_window ( window, width = None, height = None, parent = None ):
    """ Positions a window on the screen with a specified width and height so
        that the window completely fits on the screen if possible.
    """
    dx, dy = window.GetSizeTuple()
    width  = width  or dx
    height = height or dy

    if parent is None:
        parent = window._parent

    if parent is None:
        # Center the popup on the screen:
        window.SetDimensions( (screen_dx - width)  / 2,
                              (screen_dy - height) / 2, width, height )
        return

    # Calculate the desired size of the popup control:
    if isinstance( parent, wx.Window ):
        x, y     = parent.ClientToScreenXY( 0, 0 )
        parent_dx, parent_dy = parent.GetSizeTuple()
    else:
        # Special case of parent being a screen position and size tuple (used
        # to pop-up a dialog for a table cell):
        x, y, parent_dx, parent_dy = parent

    adjacent = (getattr( window, '_kind', 'popup' ) == 'popup')
    width    = min( max( parent_dx, width ), screen_dx )
    height   = min( height, screen_dy )

    closest = find_closest_display(x,y)

    if adjacent:
        y += parent_dy

    x, y, dx, dy = get_position_for_display(x, y, width, height, closest)

    window.SetDimensions(x, y, dx, dy)

#-------------------------------------------------------------------------------
#  Returns the top-level window for a specified control:
#-------------------------------------------------------------------------------

def top_level_window_for ( control ):
    """ Returns the top-level window for a specified control.
    """
    parent = control.GetParent()
    while parent is not None:
        control = parent
        parent  = control.GetParent()

    return control

#-------------------------------------------------------------------------------
#  Recomputes the mappings for a new set of enumeration values:
#-------------------------------------------------------------------------------

def enum_values_changed ( values ):
    """ Recomputes the mappings for a new set of enumeration values.
    """

    if isinstance( values, dict ):
        data = [ ( unicode( v ), n ) for n, v in values.items() ]
        if len( data ) > 0:
            data.sort( lambda x, y: cmp( x[0], y[0] ) )
            col = data[0][0].find( ':' ) + 1
            if col > 0:
                data = [ ( n[ col: ], v ) for n, v in data ]
    elif not isinstance( values, SequenceTypes ):
        handler = values
        if isinstance( handler, CTrait ):
            handler = handler.handler
        if not isinstance( handler, BaseTraitHandler ):
            raise TraitError, "Invalid value for 'values' specified"
        if handler.is_mapped:
            data = [ ( unicode( n ), n ) for n in handler.map.keys() ]
            data.sort( lambda x, y: cmp( x[0], y[0] ) )
        else:
            data = [ ( unicode( v ), v ) for v in handler.values ]
    else:
        data = [ ( unicode( v ), v ) for v in values ]

    names           = [ x[0] for x in data ]
    mapping         = {}
    inverse_mapping = {}
    for name, value in data:
        mapping[ name ] = value
        inverse_mapping[ value ] = name

    return ( names, mapping, inverse_mapping )

#-------------------------------------------------------------------------------
#  Disconnects a wx event handle from its associated control:
#-------------------------------------------------------------------------------

def disconnect ( control, *events ):
    """ Disconnects a wx event handle from its associated control.
    """
    id = control.GetId()
    for event in events:
        event( control, id, None )

def disconnect_no_id ( control, *events ):
    """ Disconnects a wx event handle from its associated control.
    """
    for event in events:
        event( control, None )

#-------------------------------------------------------------------------------
#  Creates a wx.Panel that correctly sets its background color to be the same
#  as its parents:
#-------------------------------------------------------------------------------

class TraitsUIPanel ( wx.Panel ):

    def __init__ ( self, parent, *args, **kw ):
        """ Creates a wx.Panel that correctly sets its background color to be
            the same as its parents.
        """
        bg_color = kw.pop('bg_color', None)
        wx.Panel.__init__( self, parent, *args, **kw )

        wx.EVT_CHILD_FOCUS(      self, self.OnChildFocus )

        if bg_color:
            self.SetBackgroundColour(bg_color)
        else:
            self.SetBackgroundColour( parent.GetBackgroundColour() )

    def OnChildFocus ( self, event ):
        """ If the ChildFocusEvent contains one of the Panel's direct children,
            then we will Skip it to let it pass up the widget hierarchy.

            Otherwise, we consume the event to make sure it doesn't go any
            farther. This works around a problem in wx 2.8.8.1 where each Panel
            in a nested hierarchy generates many events that might consume too
            many resources. We do, however, let one event bubble up to the top
            so that it may inform a top-level ScrolledPanel that a descendant
            has acquired focus.
        """
        if event.GetWindow() in self.GetChildren():
            event.Skip()

#-------------------------------------------------------------------------------
#  'ChildFocusOverride' class:
#-------------------------------------------------------------------------------

# PyEvtHandler was only introduced in wxPython 2.8.8. Fortunately, it is only
# necessary in wxPython 2.8.8.
if wx.__version__ < '2.8.8':

    class ChildFocusOverride ( object ):
        def __init__ ( self, window ):
            # Set up the event listener.
            window.Bind( wx.EVT_CHILD_FOCUS, window.OnChildFocus )

else:

    class ChildFocusOverride ( wx.PyEvtHandler ):
        """ Override the scroll-to-focus behaviour in wx 2.8.8's ScrolledWindow
            C++ implementation for ScrolledPanel.

            Instantiating this class with the ScrolledPanel will register the
            new instance as the event handler for the panel.
        """

        def __init__ ( self, window ):
            self.window = window
            wx.PyEvtHandler.__init__( self )

            # Make self the event handler for the window.
            window.PushEventHandler( self )

        def ProcessEvent ( self, event ):
            if isinstance( event, wx.ChildFocusEvent ):
                # Handle this one with our code and don't let the C++ event handler
                # get it.
                return self.window.OnChildFocus( event )
            else:
                # Otherwise, just pass this along in the event handler chain.
                result = self.GetNextHandler().ProcessEvent( event )
                return result

#-------------------------------------------------------------------------------
#  'TraitsUIScrolledPanel' class:
#-------------------------------------------------------------------------------

class TraitsUIScrolledPanel ( wx.lib.scrolledpanel.ScrolledPanel ):

    def __init__ ( self, parent, id = -1, pos = wx.DefaultPosition,
                   size = wx.DefaultSize, style = wx.TAB_TRAVERSAL,
                   name = "scrolledpanel" ):

        wx.PyScrolledWindow.__init__( self, parent, id, pos = pos, size = size,
                                      style = style, name = name )
        # FIXME: The ScrolledPanel class calls SetInitialSize in its __init__
        # method, but for some reason, that leads to very a small window size.
        # Calling SetSize seems to work okay, but its not clear why
        # SetInitialSize does not work.
        self.SetSize( size )
        self.SetBackgroundColour( parent.GetBackgroundColour() )

        # Override the C++ ChildFocus event handler:
        ChildFocusOverride( self )

    def OnChildFocus ( self, event ):
        """ Handle a ChildFocusEvent.

        Returns a boolean so it can be used as a library call, too.
        """
        self.ScrollChildIntoView( self.FindFocus() )

        return True

    def ScrollChildIntoView ( self, child ):
        """ Scrolls the panel such that the specified child window is in view.
            This method overrides the original in the base class so that
            nested subpanels are handled correctly.
        """
        if child is None:
            return

        sppux, sppuy = self.GetScrollPixelsPerUnit()
        vsx, vsy     = self.GetViewStart()

        crx, cry, crdx, crdy = child.GetRect()
        subwindow = child.GetParent()
        while subwindow not in [self, None]:
            # Make sure that the descendant's position information is relative
            # to us, not its local parent.
            pwx,pwy   = subwindow.GetRect()[:2]
            crx, cry  = crx + pwx, cry + pwy
            subwindow = subwindow.GetParent()

        cr = wx.Rect( crx, cry, crdx, crdy )

        client_size      = self.GetClientSize()
        new_vsx, new_vsy = -1, -1

        # Is it before the left edge?
        if (cr.x < 0) and (sppux > 0):
            new_vsx = vsx + (cr.x / sppux)

        # Is it above the top?
        if (cr.y < 0) and (sppuy > 0):
            new_vsy = vsy + (cr.y / sppuy)

        # For the right and bottom edges, scroll enough to show the whole
        # control if possible, but if not just scroll such that the top/left
        # edges are still visible:

        # Is it past the right edge ?
        if (cr.right > client_size.width) and (sppux > 0):
            diff = (cr.right - client_size.width) / sppux
            if (cr.x - (diff * sppux)) > 0:
                new_vsx = vsx + diff + 1
            else:
                new_vsx = vsx + (cr.x / sppux)

        # Is it below the bottom ?
        if (cr.bottom > client_size.height) and (sppuy > 0):
            diff = (cr.bottom - client_size.height) / sppuy
            if (cr.y - (diff * sppuy)) > 0:
                new_vsy = vsy + diff + 1
            else:
                new_vsy = vsy + (cr.y / sppuy)

        # Perform the scroll if any adjustments are needed:
        if (new_vsx != -1) or (new_vsy != -1):
            self.Scroll( new_vsx, new_vsy )

#-------------------------------------------------------------------------------
#  Initializes standard wx event handlers for a specified control and object:
#-------------------------------------------------------------------------------

# Standard wx event handlers:
handlers = (
    ( wx.EVT_ERASE_BACKGROUND, '_erase_background' ),
    ( wx.EVT_PAINT,            '_paint' ),
    ( wx.EVT_SIZE,             '_size' ),
    ( wx.EVT_LEFT_DOWN,        '_left_down' ),
    ( wx.EVT_LEFT_UP,          '_left_up' ),
    ( wx.EVT_LEFT_DCLICK,      '_left_dclick' ),
    ( wx.EVT_MIDDLE_DOWN,      '_middle_down' ),
    ( wx.EVT_MIDDLE_UP,        '_middle_up' ),
    ( wx.EVT_MIDDLE_DCLICK,    '_middle_dclick' ),
    ( wx.EVT_RIGHT_DOWN,       '_right_down' ),
    ( wx.EVT_RIGHT_UP,         '_right_up' ),
    ( wx.EVT_RIGHT_DCLICK,     '_right_dclick' ),
    ( wx.EVT_MOTION,           '_motion' ),
    ( wx.EVT_ENTER_WINDOW,     '_enter' ),
    ( wx.EVT_LEAVE_WINDOW,     '_leave' ),
    ( wx.EVT_MOUSEWHEEL,       '_wheel' )
)

def init_wx_handlers ( control, object, prefix = '' ):
    """ Initializes a standard set of wx event handlers for a specified control
        and object using a specified prefix.
    """
    global handlers

    for handler, name in handlers:
        method = getattr( object, prefix + name, None )
        if method is not None:
            handler( control, method )

#-------------------------------------------------------------------------------
#  Safely tries to pop up an FBI window if etsdevtools.debug is installed
#-------------------------------------------------------------------------------

def open_fbi():
    try:
        from etsdevtools.developer.helper.fbi import if_fbi
        if not if_fbi():
            import traceback
            traceback.print_exc()
    except ImportError:
        pass

#-------------------------------------------------------------------------------
#  'GroupEditor' class:
#-------------------------------------------------------------------------------

class GroupEditor ( Editor ):

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        """ Initializes the object.
        """
        self.set( **traits )

#-------------------------------------------------------------------------------
#  'PopupControl' class:
#-------------------------------------------------------------------------------

class PopupControl ( HasPrivateTraits ):

    #-- Constructor Traits -----------------------------------------------------

    # The control the popup should be positioned relative to:
    control = Instance( wx.Window )

    # The minimum width of the popup:
    width = Int

    # The minimum height of the popup:
    height = Int

    # Should the popup be resizable?
    resizable = Bool( False )

    #-- Public Traits ----------------------------------------------------------

    # The value (if any) set by the popup control:
    value = Any

    # Event fired when the popup control is closed:
    closed = Event

    #-- Private Traits ---------------------------------------------------------

    # The popup control:
    popup = Instance( wx.Window )

    #-- Public Methods ---------------------------------------------------------

    def __init__ ( self, **traits ):
        """ Initializes the object.
        """
        super( PopupControl, self ).__init__( **traits )

        style = wx.SIMPLE_BORDER
        if self.resizable:
            style = wx.RESIZE_BORDER

        self.popup = popup = wx.Frame( None, -1, '', style = style )
        wx.EVT_ACTIVATE( popup, self._on_close_popup )
        self.create_control( popup )
        self._position_control()
        popup.Show()

    def create_control ( self ):
        """ Creates the control.

            Must be overridden by a subclass.
        """
        raise NotImplementedError

    def dispose ( self ):
        """ Called when the popup is being closed to allow any custom clean-up.

            Can be overridden by a subclass.
        """
        pass

    #-- Event Handlers ---------------------------------------------------------

    def _value_changed ( self, value ):
        """ Handles the 'value' being changed.
        """
        do_later( self._close_popup )

    #-- Private Methods --------------------------------------------------------

    def _position_control ( self ):
        """ Initializes the popup control's initial position and size.
        """
        # Calculate the desired size of the popup control:
        px,  cy  = self.control.ClientToScreenXY( 0, 0 )
        cdx, cdy = self.control.GetSizeTuple()
        pdx, pdy = self.popup.GetSizeTuple()
        pdx, pdy = max( pdx, cdx, self.width ), max( pdy, self.height )

        # Calculate the best position and size for the pop-up:
        py = cy + cdy
        if (py + pdy) > screen_dy:
            if (cy - pdy) < 0:
                bottom = screen_dy - py
                if cy > bottom:
                    py, pdy = 0, cy
                else:
                    pdy = bottom
            else:
                py = cy - pdy

        # Finally, position the popup control:
        self.popup.SetDimensions( px, py, pdx, pdy )

    def _on_close_popup ( self, event ):
        """ Closes the popup control when it is deactivated.
        """
        if not event.GetActive():
            self._close_popup()

    def _close_popup ( self ):
        """ Closes the dialog.
        """
        wx.EVT_ACTIVATE( self.popup, None )
        self.dispose()
        self.closed = True
        self.popup.Destroy()
        self.popup = self.control = None

#-------------------------------------------------------------------------------
#  'BufferDC' class:
#-------------------------------------------------------------------------------

class BufferDC ( wx.MemoryDC ):
    """ An off-screen buffer class.

        This class implements a off-screen output buffer. Data is meant to
        be drawn in the buffer and then blitted directly to the output device
        context.
    """

    def __init__ ( self, dc, width = None, height = None ):
        """Initializes the buffer."""
        wx.MemoryDC.__init__( self )

        # If only a single argument is passed, it is assumed to be a wx.Window
        # and that we have been created within a 'paint' event for that window:
        if width is None:
            width, height = dc.GetClientSize()
            dc = wx.PaintDC( dc )

        self.dc     = dc
        self.bitmap = wx.EmptyBitmap( width, height )

        self.SelectObject( self.bitmap )

        self.SetFont( dc.GetFont() )

    def copy ( self, x = 0, y = 0 ):
        """ Performs the blit of the buffer contents to the specified device
            context location.
        """
        self.dc.Blit( x, y, self.bitmap.GetWidth(), self.bitmap.GetHeight(),
                      self, 0, 0 )

#-------------------------------------------------------------------------------
#  'Slider' class:
#-------------------------------------------------------------------------------

class Slider ( wx.Slider ):
    """ This is a 'fixed' version of the wx.Slider control which does not
        erase its background, which can cause a lot of update flicker and is
        completely unnecessary.
    """

    def __init__ ( self, *args, **kw ):
        super( Slider, self ).__init__( *args, **kw )

        wx.EVT_ERASE_BACKGROUND( self, self._erase_background )

    def _erase_background ( self, event ):
        pass


########NEW FILE########
__FILENAME__ = history_control
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the a text entry field (actually a combo-box) with a drop-down list
    of values previously entered into the control.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasPrivateTraits, Instance, Str, List, Int, Bool

from pyface.timer.api \
    import do_later

from constants \
    import OKColor, ErrorColor

#-------------------------------------------------------------------------------
#  'HistoryControl' class:
#-------------------------------------------------------------------------------

class HistoryControl ( HasPrivateTraits ):

    # The UI control:
    control = Instance( wx.Window )

    # The current value of the control:
    value = Str

    # Should 'value' be updated on every keystroke?
    auto_set = Bool( False )

    # The current history of the control:
    history = List( Str )

    # The maximum number of history entries allowed:
    entries = Int( 10 )

    # Is the current value valid?
    error = Bool( False )

    #-- Public Methods ---------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the control.
        """
        self.control = control = wx.ComboBox( parent, -1, self.value,
                                          wx.Point( 0, 0 ), wx.Size( -1, -1 ),
                                          self.history, style = wx.CB_DROPDOWN )
        wx.EVT_COMBOBOX( parent, control.GetId(), self._update_value )
        wx.EVT_KILL_FOCUS( control, self._kill_focus )
        wx.EVT_TEXT_ENTER( parent, control.GetId(),
                           self._update_text_value )
        if self.auto_set:
            wx.EVT_TEXT( parent, control.GetId(), self._update_value_only )

        return control

    def dispose ( self ):
        """ Disposes of the control at the end of its life cycle.
        """
        control, self.control = self.control, None
        parent = control.GetParent()
        wx.EVT_COMBOBOX(   parent, control.GetId(), None )
        wx.EVT_TEXT_ENTER( parent, control.GetId(), None )
        wx.EVT_KILL_FOCUS( control, None )

    def set_value ( self, value ):
        """ Sets the specified value and adds it to the history.
        """
        self._update( value )

    #-- Traits Event Handlers --------------------------------------------------

    def _value_changed ( self, value ):
        """ Handles the 'value' trait being changed.
        """
        if not self._no_update:
            control = self.control
            if control is not None:
                control.SetValue( value )
                self._restore = False

    def _history_changed ( self ):
        """ Handles the 'history' being changed.
        """
        if not self._no_update:
            if self._first_time is None:
                self._first_time = False
                if (self.value == '') and (len( self.history ) > 0):
                    self.value = self.history[0]

            self._load_history( select = False )

    def _error_changed ( self, error ):
        """ Handles the 'error' trait being changed.
        """
        if error:
            self.control.SetBackgroundColour( ErrorColor )
        else:
            self.control.SetBackgroundColour( OKColor )

        self.control.Refresh()

    #-- Wx Event Handlers ------------------------------------------------------

    def _update_value ( self, event ):
        """ Handles the user selecting something from the drop-down list of the
            combobox.
        """
        self._update( event.GetString() )

    def _update_value_only ( self, event ):
        """ Handles the user typing into the text field in 'auto_set' mode.
        """
        self._no_update = True
        self.value      = event.GetString()
        self._no_update = False

    def _update_text_value ( self, event, select = True ):
        """ Handles the user typing something into the text field of the
            combobox.
        """
        if not self._no_update:
            self._update( self.control.GetValue(), select )

    def _kill_focus ( self, event ):
        """ Handles the combobox losing focus.
        """
        self._update_text_value( event, False )
        event.Skip()

    #-- Private Methods --------------------------------------------------------

    def _update ( self, value, select = True ):
        """ Updates the value and history list based on a specified value.
        """
        self._no_update = True

        if value.strip() != '':
            history = self.history
            if (len( history ) == 0) or (value != history[0]):
                if value in history:
                    history.remove( value )
                history.insert( 0, value )
                del history[ self.entries: ]
                self._load_history( value, select )

        self.value = value

        self._no_update = False

    def _load_history ( self, restore = None, select = True ):
        """ Loads the current history list into the control.
        """
        control = self.control
        control.Freeze()

        if restore is None:
            restore = control.GetValue()

        control.Clear()
        for value in self.history:
            control.Append( value )

        self._restore = True
        do_later( self._thaw_value, restore, select )

    def _thaw_value ( self, restore, select ):
        """ Restores the value of the combobox control.
        """
        control = self.control
        if control is not None:
           if self._restore:
               control.SetValue( restore )

               if select:
                   control.SetMark( 0, len( restore ) )

           control.Thaw()


########NEW FILE########
__FILENAME__ = history_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#-------------------------------------------------------------------------------

""" Defines a text editor which displays a text field and maintains a history
    of previously entered values.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import Any, on_trait_change

from pyface.timer.api \
    import do_later

from editor \
    import Editor

from history_control \
    import HistoryControl

#-------------------------------------------------------------------------------
#  '_HistoryEditor' class:
#-------------------------------------------------------------------------------

class _HistoryEditor ( Editor ):
    """ Simple style text editor, which displays a text field and maintains a
        history of previously entered values, the maximum number of which is
        specified by the 'entries' trait of the HistoryEditor factory.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The history control:
    history = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.history = history = HistoryControl(
                                     value    = self.value,
                                     entries  = self.factory.entries,
                                     auto_set = self.factory.auto_set )
        self.control = history.create_control( parent )

        self.set_tooltip()

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self.history.dispose()
        self.history = None

        super( _HistoryEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    @on_trait_change( 'history:value' )
    def _value_changed ( self, value ):
        """ Handles the history object's 'value' trait being changed.
        """
        if not self._dont_update:
            history = self.history
            try:
                self._dont_update = True
                self.value        = history.value
                history.error     = False
            except:
                history.error = True

            do_later( self.set, _dont_update = False )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if not self._dont_update:
            self._dont_update  = True
            self.history.value = self.value
            self.history.error = False
            self._dont_update  = False

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        self.history.history = \
            prefs.get( 'history', [] )[ : self.factory.entries ]

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        # If the view closed successfully, try to update the history with the
        # current value:
        if self.ui.result:
            self._dont_update = True
            self.history.set_value( self.value )
            self._dont_update = False

        return { 'history': self.history.history[:] }

# EOF #########################################################################

########NEW FILE########
__FILENAME__ = html_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the HTML "editor" for the wxPython user interface toolkit.
    HTML editors interpret and display HTML-formatted text, but do not
    modify it.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import os.path
import webbrowser

import wx.html as wh

from traits.api import Str

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.html_editor file.
from traitsui.editors.html_editor import ToolkitEditorFactory

from editor import Editor

#-------------------------------------------------------------------------------
#  URLResolvingHtmlWindow class:
#-------------------------------------------------------------------------------

class URLResolvingHtmlWindow( wh.HtmlWindow ):
    """ Overrides OnOpeningURL method of HtmlWindow to append the base URL
        local links.
    """

    def __init__( self, parent, open_externally, base_url ):
        wh.HtmlWindow.__init__( self, parent )
        self.open_externally = open_externally
        self.base_url = base_url

    def OnLinkClicked ( self, link_info ):
        """ Handle the base url and opening in a new browser window for links.
        """
        if self.open_externally:
            url = link_info.GetHref()
            if (self.base_url and
                not url.startswith( ( 'http://', 'https://' ) )):
                url = self.base_url + url
            if not url.startswith( ( 'file://', 'http://', 'https://' ) ):
                url = 'file://' + url
            webbrowser.open_new( url )

    def OnOpeningURL( self, url_type, url ):
        """ According to the documentation, this method is supposed to be called
            for both images and link clicks, but it appears to only be called
            for image loading, hence the base url handling code in
            OnLinkClicked.
        """
        if (self.base_url and not os.path.isabs(url) and
            not url.startswith( ( 'http://', 'https://', self.base_url ) )):
            return self.base_url + url
        else:
            return wh.HTML_OPEN

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for HTML, which displays interpreted HTML.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the HTML editor scrollable? This values override the default.
    scrollable = True

    # External objects referenced in the HTML are relative to this URL
    base_url = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = URLResolvingHtmlWindow( parent ,
                                               self.factory.open_externally,
                                               self.base_url )
        self.control.SetBorders( 2 )

        self.base_url = self.factory.base_url
        self.sync_value( self.factory.base_url_name, 'base_url', 'from' )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        text = self.str_value
        if self.factory.format_text:
            text = self.factory.parse_text( text )
        self.control.SetPage( text )

    #-- Event Handlers ---------------------------------------------------------

    def _base_url_changed(self):
        url = self.base_url
        if not url.endswith( '/' ):
            url += '/'
        self.control.base_url = url
        self.update_editor()

#--EOF-------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = image_control
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/29/2004
#
#------------------------------------------------------------------------------

""" Defines a wxPython ImageControl widget that is used by various trait
    editors to display trait values iconically.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

#-------------------------------------------------------------------------------
#  'ImageControl' class:
#-------------------------------------------------------------------------------

class ImageControl ( wx.Window ):
    """ A wxPython control that displays an image, which can be selected or
        unselected by mouse clicks.
    """

    # Pens used to draw the 'selection' marker:
    _selectedPenDark = wx.Pen(
        wx.SystemSettings_GetColour( wx.SYS_COLOUR_3DSHADOW ), 1,
        wx.SOLID )

    _selectedPenLight = wx.Pen(
        wx.SystemSettings_GetColour( wx.SYS_COLOUR_3DHIGHLIGHT ), 1,
        wx.SOLID )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, parent, bitmap, selected = None, handler = None,
                         padding = 10 ):
        """ Initializes the object.
        """
        wx.Window.__init__( self, parent, -1,
                            size = wx.Size( bitmap.GetWidth()  + padding,
                                            bitmap.GetHeight() + padding ) )
        self._bitmap      = bitmap
        self._selected    = selected
        self._handler     = handler
        self._mouse_over  = False
        self._button_down = False

        # Set up the 'paint' event handler:
        wx.EVT_PAINT( self, self._on_paint )

        # Set up mouse event handlers:
        wx.EVT_LEFT_DOWN(    self, self._on_left_down )
        wx.EVT_LEFT_UP(      self, self._on_left_up )
        wx.EVT_ENTER_WINDOW( self, self._on_enter )
        wx.EVT_LEAVE_WINDOW( self, self._on_leave )

    #---------------------------------------------------------------------------
    #  Gets/Sets the current selection state of the image:
    #---------------------------------------------------------------------------

    def Selected ( self, selected = None ):
        """ Gets or sets the selection state of the image.
        """
        if selected is not None:
            selected = (selected != 0)
            if selected != self._selected:
                if selected:
                    for control in self.GetParent().GetChildren():
                        if (isinstance( control, ImageControl ) and
                            control.Selected()):
                            control.Selected( False )
                            break

                self._selected = selected
                self.Refresh()

        return self._selected

    #---------------------------------------------------------------------------
    #  Gets/Sets the current bitmap image:
    #---------------------------------------------------------------------------

    def Bitmap ( self, bitmap = None ):
        """ Gets or sets the bitmap image.
        """
        if bitmap is not None:
            if bitmap != self._bitmap:
                self._bitmap = bitmap
                self.Refresh()

        return self._bitmap

    #---------------------------------------------------------------------------
    #  Gets/Sets the current click handler:
    #---------------------------------------------------------------------------

    def Handler ( self, handler = None ):
        """ Gets or sets the click handler.
        """
        if handler is not None:
            if handler != self._handler:
                self._handler = handler
                self.Refresh()

        return self._handler

    #---------------------------------------------------------------------------
    #  Handles the mouse entering the control:
    #---------------------------------------------------------------------------

    def _on_enter ( self, event = None ):
        """ Handles the mouse entering the control.
        """
        if self._selected is not None:
            self._mouse_over = True
            self.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the mouse leaving the control:
    #---------------------------------------------------------------------------

    def _on_leave ( self, event = None ):
        """ Handles the mouse leaving the control.
        """
        if self._mouse_over:
            self._mouse_over = False
            self.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the user pressing the mouse button:
    #---------------------------------------------------------------------------

    def _on_left_down ( self, event = None ):
        """ Handles the user pressing the mouse button.
        """
        if self._selected is not None:
            self.CaptureMouse()
            self._button_down = True
            self.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the user clicking the control:
    #---------------------------------------------------------------------------

    def _on_left_up ( self, event = None ):
        """ Handles the user clicking the control.
        """
        need_refresh = self._button_down
        if need_refresh:
            self.ReleaseMouse()
            self._button_down = False

        if self._selected is not None:
            wdx, wdy = self.GetClientSizeTuple()
            x        = event.GetX()
            y        = event.GetY()
            if (0 <= x < wdx) and (0 <= y < wdy):
                if self._selected != -1:
                    self.Selected( True )
                elif need_refresh:
                    self.Refresh()
                if self._handler is not None:
                    self._handler( self )
                return

        if need_refresh:
            self.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the control being re-painted:
    #---------------------------------------------------------------------------

    def _on_paint ( self, event = None ):
        """ Handles the control being re-painted.
        """
        wdc      = wx.PaintDC( self )
        wdx, wdy = self.GetClientSizeTuple()
        bitmap   = self._bitmap
        bdx      = bitmap.GetWidth()
        bdy      = bitmap.GetHeight()
        wdc.DrawBitmap( bitmap, (wdx - bdx) / 2, (wdy - bdy) / 2, True )

        pens = [ self._selectedPenLight, self._selectedPenDark ]
        bd   = self._button_down

        if self._mouse_over:
            wdc.SetBrush( wx.TRANSPARENT_BRUSH )
            wdc.SetPen( pens[ bd ] )
            wdc.DrawLine( 0, 0, wdx, 0 )
            wdc.DrawLine( 0, 1, 0, wdy )
            wdc.SetPen( pens[ 1 - bd ] )
            wdc.DrawLine( wdx - 1, 1, wdx - 1, wdy )
            wdc.DrawLine( 1, wdy - 1, wdx - 1, wdy - 1 )

        if self._selected is True:
            wdc.SetBrush( wx.TRANSPARENT_BRUSH )
            wdc.SetPen( pens[ bd ] )
            wdc.DrawLine( 1, 1, wdx - 1, 1 )
            wdc.DrawLine( 1, 1, 1, wdy - 1 )
            wdc.DrawLine( 2, 2, wdx - 2, 2 )
            wdc.DrawLine( 2, 2, 2, wdy - 2 )
            wdc.SetPen( pens[ 1 - bd ] )
            wdc.DrawLine( wdx - 2, 2, wdx - 2, wdy - 1 )
            wdc.DrawLine( 2, wdy - 2, wdx - 2, wdy - 2 )
            wdc.DrawLine( wdx - 3, 3, wdx - 3, wdy - 2 )
            wdc.DrawLine( 3, wdy - 3, wdx - 3, wdy - 3 )


########NEW FILE########
__FILENAME__ = image_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/05/2007
#
#-------------------------------------------------------------------------------

""" Traits UI 'display only' image editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from pyface.image_resource \
    import ImageResource

from traitsui.ui_traits \
    import convert_bitmap

# FIXME: ImageEditor is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.image_editor file.
from traitsui.editors.image_editor \
    import ImageEditor

from editor \
    import Editor

from image_control \
    import ImageControl

#-------------------------------------------------------------------------------
#  '_ImageEditor' class:
#-------------------------------------------------------------------------------

class _ImageEditor ( Editor ):
    """ Traits UI 'display only' image editor.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        image = self.factory.image
        if image is None:
            image = self.value

        self.control = ImageControl( parent, convert_bitmap( image ),
                                     padding = 0 )

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.factory.image is None:
            value = self.value
            if isinstance( value, ImageResource ):
                self.control.Bitmap( convert_bitmap( value ) )

### EOF #######################################################################


########NEW FILE########
__FILENAME__ = image_enum_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various image enumeration editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Any

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.image_enum_editor file.
from traitsui.editors.image_enum_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

from helper \
    import bitmap_cache, position_window, TraitsUIPanel

from constants \
    import WindowColor

from image_control \
    import ImageControl

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( Editor ):
    """ Read-only style of image enumeration editor, which displays a single
    ImageControl, representing the object trait's value.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = ImageControl( parent, bitmap_cache( '%s%s%s' %
            ( self.factory.prefix, self.str_value, self.factory.suffix ),
            False, self.factory._image_path ) )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.Bitmap( bitmap_cache( '%s%s%s' %
            ( self.factory.prefix, self.str_value, self.factory.suffix ),
            False, self.factory._image_path ) )

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( ReadonlyEditor ):
    """ Simple style of image enumeration editor, which displays an
    ImageControl, representing the object trait's value. Clicking an image
    displays a dialog box for selecting an image corresponding to a different
    value.
    """
    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( SimpleEditor, self ).init( parent )
        self.control.Selected( True )
        self.control.Handler( self.popup_editor )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user clicking the ImageControl to display the pop-up dialog:
    #---------------------------------------------------------------------------

    def popup_editor ( self, control ):
        """ Handles the user clicking the ImageControl to display the pop-up
            dialog.
        """
        ImageEnumDialog( self )

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( Editor ):
    """ Custom style of image enumeration editor, which displays a grid of
    ImageControls. The user can click an image to select the corresponding
    value.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    update_handler = Any  # Callback to call when any button clicked

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._create_image_grid( parent )

    #---------------------------------------------------------------------------
    #  Populates a specified window with a grid of image buttons:
    #---------------------------------------------------------------------------

    def _create_image_grid ( self, parent ):
        """ Populates a specified window with a grid of image buttons.
        """
        # Create the panel to hold the ImageControl buttons:
        self.control = panel = TraitsUIPanel( parent, -1 )

        # Create the main sizer:
        if self.factory.cols > 1:
           sizer = wx.GridSizer( 0, self.factory.cols, 0, 0 )
        else:
           sizer = wx.BoxSizer( wx.VERTICAL )

        # Add the set of all possible choices:
        factory   = self.factory
        mapping   = factory._mapping
        cur_value = self.value
        for name in self.factory._names:
            value   = mapping[ name ]
            control = ImageControl( panel,
                          bitmap_cache( '%s%s%s' % ( factory.prefix, name,
                              factory.suffix ), False, factory._image_path ),
                          value == cur_value,
                          self.update_object )
            control.value = value
            sizer.Add( control, 0, wx.ALL, 2 )
            self.set_tooltip( control )

        # Finish setting up the control layout:
        panel.SetSizerAndFit( sizer )

    #---------------------------------------------------------------------------
    #  Handles the user clicking on an ImageControl to set an object value:
    #---------------------------------------------------------------------------

    def update_object ( self, control ):
        """ Handles the user clicking on an ImageControl to set an object value.
        """
        self.value = control.value
        if self.update_handler is not None:
            self.update_handler()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        for control in self.control.GetChildren():
            control.Selected( value == control.value )

#-------------------------------------------------------------------------------
#  'ImageEnumDialog' class:
#-------------------------------------------------------------------------------

class ImageEnumDialog ( wx.Frame ):
    """ Dialog box for selecting an ImageControl
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, editor ):
        """ Initializes the object.
        """
        wx.Frame.__init__( self, editor.control, -1, '',
                           style = wx.SIMPLE_BORDER )
        self.SetBackgroundColour( WindowColor )
        wx.EVT_ACTIVATE( self, self._on_close_dialog )
        self._closed = False

        dlg_editor = CustomEditor( self,
                                   factory        = editor.factory,
                                   ui             = editor.ui,
                                   object         = editor.object,
                                   name           = editor.name,
                                   description    = editor.description,
                                   update_handler = self._close_dialog )

        dlg_editor.init( self )

        # Wrap the dialog around the image button panel:
        sizer = wx.BoxSizer( wx.VERTICAL )
        sizer.Add( dlg_editor.control )
        sizer.Fit( self )

        # Position the dialog:
        position_window( self, parent = editor.control )
        self.Show()

    #---------------------------------------------------------------------------
    #  Closes the dialog:
    #---------------------------------------------------------------------------

    def _on_close_dialog ( self, event ):
        """ Closes the dialog.
        """
        if not event.GetActive():
            self._close_dialog()

    #---------------------------------------------------------------------------
    #  Closes the dialog:
    #---------------------------------------------------------------------------

    def _close_dialog ( self ):
        """ Closes the dialog.
        """
        if not self._closed:
            self._closed = True
            self.Destroy()

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = image_panel
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/11/2007
#
#-------------------------------------------------------------------------------

""" Defines a themed panel that wraps itself around a single child widget.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Str, Property, Instance, Bool, cached_property

from themed_window \
    import ThemedWindow

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Size of an empty text string:
ZeroTextSize = ( 0, 0, 0, 0 )

#-------------------------------------------------------------------------------
#  'ImagePanel' class:
#-------------------------------------------------------------------------------

class ImagePanel ( ThemedWindow ):

    # The optional text to display in the top or bottom of the image slice:
    text = Str( event = 'updated' )

    # Can the application change the theme contents?
    mutable_theme = Bool( False )

    # Is the image panel capable of displaying text?
    can_show_text = Property

    # The adjusted size of the panel, taking into account the size of its
    # current children and the image border:
    adjusted_size = Property

    # The best size of the panel, taking into account the best size of its
    # children and the image border:
    best_size = Property

    # The underlying wx control:
    control = Instance( wx.Window )

    #-- Private Traits ---------------------------------------------------------

    # The size of the current text:
    text_size = Property( depends_on = 'text, control' )

    #-- Public Methods ---------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the underlying wx.Panel control.
        """
        self.control = control = wx.Panel( parent, -1,
                          style = wx.TAB_TRAVERSAL | wx.FULL_REPAINT_ON_RESIZE )

        # Set up the sizer for the control:
        control.SetSizer( ImageSizer( self.theme ) )

        # Initialize the control (set-up event handlers, ...)
        self.init_control()

        # Attach the image slice to the control:
        control._image_slice = self.theme.image_slice

        # Set the panel's background colour to the image slice bg_color:
        control.SetBackgroundColour( control._image_slice.bg_color )

        return control

    def layout ( self ):
        """ Lays out the contents of the image panel.
        """
        self.control.Layout()
        self.control.Refresh()

    #-- Property Implementations -----------------------------------------------

    def _get_adjusted_size ( self ):
        """ Returns the adjusted size of the panel taking into account the
            size of its current children and the image border.
        """
        control = self.control
        dx, dy  = 0, 0
        for child in control.GetChildren():
            dx, dy = child.GetSizeTuple()

        size = self._adjusted_size_of( dx, dy )
        control.SetSize( size )

        return size

    def _get_best_size ( self ):
        """ Returns the best size of the panel taking into account the
            best size of its current children and the image border.
        """
        control = self.control
        dx, dy  = 0, 0
        for child in control.GetChildren():
            dx, dy = child.GetBestSize()

        return self._adjusted_size_of( dx, dy )

    @cached_property
    def _get_can_show_text ( self ):
        """ Returns whether or not the image panel is capable of displaying
            text.
        """
        tdx, tdy, descent, leading = self.control.GetFullTextExtent( 'Myj' )
        slice = self.theme.image_slice
        tdy  += 4
        return ((tdy <= slice.xtop) or (tdy <= slice.xbottom) or
                (slice.xleft >= 40) or (slice.xright >= 40))

    @cached_property
    def _get_text_size ( self ):
        """ Returns the text size information for the window.
        """
        if (self.text == '') or (self.control is None):
            return ZeroTextSize

        return self.control.GetFullTextExtent( self.text )

    #-- Trait Event Handlers ---------------------------------------------------

    def _updated_changed ( self ):
        """ Handles a change that requires the control to be updated.
        """
        if self.control is not None:
            self.control.Refresh()

    def _mutable_theme_changed ( self, state ):
        """ Handles a change to the 'mutable_theme' trait.
        """
        self.on_trait_change( self._theme_modified,
            'theme.[border.-,content.-,label.-,alignment,content_color,'
            'label_color]', remove = not state )

    def _theme_modified ( self ):
        if self.control is not None:
            self.layout()

    def _theme_changed ( self, theme ):
        """ Handles the 'theme' trait being changed.
        """
        super( ImagePanel, self )._theme_changed()

        control = self.control
        if (control is not None) and (theme is not None):
            # Attach the image slice to the control:
            control._image_slice = theme.image_slice

            # Set the panel's background colour to the image slice bg_color:
            control.SetBackgroundColour( control._image_slice.bg_color )

    #-- wx.Python Event Handlers -----------------------------------------------

    def _paint_fg ( self, dc ):
        """ Paints the foreground into the specified device context.
        """
        # If we have text and have room to draw it, then do so:
        text = self.text
        if (text != '') and self.can_show_text:
            theme = self.theme
            dc.SetBackgroundMode( wx.TRANSPARENT )
            dc.SetTextForeground( theme.label_color )
            dc.SetFont( self.control.GetFont() )

            alignment = theme.alignment
            label     = theme.label
            wdx, wdy  = self.control.GetClientSizeTuple()
            tdx, tdy, descent, leading = self.text_size
            tx      = None
            slice   = theme.image_slice
            xleft   = slice.xleft
            xright  = slice.xright
            xtop    = slice.xtop
            xbottom = slice.xbottom
            ltop    = label.top
            lbottom = label.bottom
            tdyp    = tdy + ltop + lbottom
            cl      = xleft + label.left
            cr      = wdx - xright - label.right
            if (tdyp <= xtop) and (xtop >= xbottom):
                ty = ((ltop + xtop - lbottom - tdy) / 2) + 1
            elif tdy <= xbottom:
                ty = wdy + ((ltop - xbottom - lbottom - tdy) / 2)
            else:
                ty = (wdy + xtop + label.top - xbottom - label.bottom - tdy) / 2
                if xleft >= xright:
                    cl = label.left
                    cr = xleft - label.right
                else:
                    cl = wdx - xright + label.left
                    cr = wdx - label.right

            # Calculate the x coordinate for the specified alignment type:
            if alignment == 'left':
                tx = cl
            elif alignment == 'right':
                tx = cr - tdx
            else:
                tx = (cl + cr - tdx) / 2

            # Draw the (clipped) text string:
            dc.SetClippingRegion( cl, ty, cr - cl, tdy )
            dc.DrawText( text, tx, ty )
            dc.DestroyClippingRegion()

    #-- Private Methods --------------------------------------------------------

    def _adjusted_size_of ( self, dx, dy ):
        """ Returns the adjusted size of its children, taking into account the
            image slice border.
        """
        slice   = self.theme.image_slice
        content = self.theme.content
        sizer   = self.control.GetSizer()
        return wx.Size( dx + min( slice.left, slice.xleft )   +
                             min( slice.right, slice.xright ) +
                             content.left + content.right,
                        dy + min( slice.top, slice.xtop )       +
                             min( slice.bottom, slice.xbottom ) +
                             content.top + content.bottom )

#-------------------------------------------------------------------------------
#  'ImageSizer' class:
#-------------------------------------------------------------------------------

class ImageSizer ( wx.PySizer ):
    """ Defines a sizer that correctly sizes a window's children to fit within
        the borders implicitly defined by a background ImageSlice object,
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, theme ):
        """ Initializes the object.
        """
        super( ImageSizer, self ).__init__()

        # Save a reference to the theme:
        self._theme = theme

        # Save the ImageSlice object which determines the inset border size:
        self._image_slice = theme.image_slice

    #---------------------------------------------------------------------------
    #  Calculates the minimum size needed by the sizer:
    #---------------------------------------------------------------------------

    def CalcMin ( self ):
        """ Calculates the minimum size of the control by adding its contents
            minimum size to the ImageSlice object's border size.
        """
        dx, dy = 0, 0
        for item in self.GetChildren():
            if item.IsSizer():
                dx, dy = item.GetSizer().CalcMin()
            else:
                dx, dy = item.GetWindow().GetBestSize()

        slice   = self._image_slice
        content = self._theme.content

        return wx.Size( max( slice.left + slice.right,
                             slice.xleft + slice.xright +
                             content.left + content.right + dx ),
                        max( slice.top + slice.bottom,
                             slice.xtop + slice.xbottom +
                             content.top + content.bottom + dy ) )

    #---------------------------------------------------------------------------
    #  Layout the contents of the sizer based on the sizer's current size and
    #  position:
    #---------------------------------------------------------------------------

    def RecalcSizes ( self ):
        """ Layout the contents of the sizer based on the sizer's current size
            and position.
        """
        x,   y  = self.GetPositionTuple()
        dx, dy  = self.GetSizeTuple()
        slice   = self._image_slice
        content = self._theme.content
        left    = slice.xleft + content.left
        top     = slice.xtop  + content.top
        ix, iy, idx, idy = ( x + left,
                             y + top,
                             dx - left - slice.xright  - content.right,
                             dy - top  - slice.xbottom - content.bottom )

        for item in self.GetChildren():
            if item.IsSizer():
                item.GetSizer().SetDimension( ix, iy, idx, idy )
            else:
                item.GetWindow().SetDimensions( ix, iy, idx, idy )


########NEW FILE########
__FILENAME__ = image_slice
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/06/2007
#
#-------------------------------------------------------------------------------

""" Class to aid in automatically computing the 'slice' points for a specified
    ImageResource and then drawing it that it can be 'stretched' to fit a larger
    region than the original image.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from colorsys \
    import rgb_to_hls

from numpy \
    import reshape, fromstring, uint8

from traits.api \
    import HasPrivateTraits, Instance, Int, List, Color, Enum, Bool

from pyface.image_resource \
    import ImageResource

from constants \
    import WindowColor

from constants import is_mac
import traitsui.wx.constants

#-------------------------------------------------------------------------------
#  Recursively paint the parent's background if they have an associated image
#  slice.
#-------------------------------------------------------------------------------

def paint_parent ( dc, window ):
    """ Recursively paint the parent's background if they have an associated
        image slice.
    """
    parent = window.GetParent()
    slice  = getattr( parent, '_image_slice', None )
    if slice is not None:
        x, y   = window.GetPositionTuple()
        dx, dy = parent.GetSizeTuple()
        slice.fill( dc, -x, -y, dx, dy )
    else:
        # Otherwise, just paint the normal window background color:
        dx, dy = window.GetClientSizeTuple()
        if is_mac and hasattr(window, '_border') and window._border:
            dc.SetBackgroundMode(wx.TRANSPARENT)
            dc.SetBrush( wx.Brush( wx.Colour(0, 0, 0, 0)))
        else:
            dc.SetBrush( wx.Brush( parent.GetBackgroundColour() ) )
        dc.SetPen( wx.TRANSPARENT_PEN )
        dc.DrawRectangle( 0, 0, dx, dy )

    return slice

#-------------------------------------------------------------------------------
#  'ImageSlice' class:
#-------------------------------------------------------------------------------

class ImageSlice ( HasPrivateTraits ):

    #-- Trait Definitions ------------------------------------------------------

    # The ImageResource to be sliced and drawn:
    image = Instance( ImageResource )

    # The minimum number of adjacent, identical rows/columns needed to identify
    # a repeatable section:
    threshold = Int( 10 )

    # The maximum number of 'stretchable' rows and columns:
    stretch_rows    = Enum( 1, 2 )
    stretch_columns = Enum( 1, 2 )

    # Width/height of the image borders:
    top    = Int
    bottom = Int
    left   = Int
    right  = Int

    # Width/height of the extended image borders:
    xtop    = Int
    xbottom = Int
    xleft   = Int
    xright  = Int

    # The color to use for content text:
    content_color = Instance( wx.Colour )

    # The color to use for label text:
    label_color = Instance( wx.Colour )

    # The background color of the image:
    bg_color = Color

    # Should debugging slice lines be drawn?
    debug = Bool( False )

    #-- Private Traits ---------------------------------------------------------

    # The current image's opaque bitmap:
    opaque_bitmap = Instance( wx.Bitmap )

    # The current image's transparent bitmap:
    transparent_bitmap = Instance( wx.Bitmap )

    # Size of the current image:
    dx = Int
    dy = Int

    # Size of the current image's slices:
    dxs = List
    dys = List

    # Fixed minimum size of current image:
    fdx = Int
    fdy = Int

    #-- Public Methods ---------------------------------------------------------

    def fill ( self, dc, x, y, dx, dy, transparent = False ):
        """ 'Stretch fill' the specified region of a device context with the
            sliced image.
        """
        # Create the source image dc:
        idc = wx.MemoryDC()
        if transparent:
            idc.SelectObject( self.transparent_bitmap )
        else:
            idc.SelectObject( self.opaque_bitmap )

        # Set up the drawing parameters:
        sdx, sdy = self.dx, self.dx
        dxs, dys = self.dxs, self.dys
        tdx, tdy = dx - self.fdx, dy - self.fdy

        # Calculate vertical slice sizes to use for source and destination:
        n = len( dxs )
        if n == 1:
            pdxs = [ ( 0, 0 ), ( 1, max( 1, tdx/2 ) ), ( sdx - 2, sdx - 2 ),
                     ( 1, max( 1, tdx - (tdx/2) ) ), ( 0, 0 ) ]
        elif n == 3:
            pdxs = [ ( dxs[0], dxs[0] ), ( dxs[1], max( 0, tdx ) ), ( 0, 0 ),
                     ( 0, 0 ), ( dxs[2], dxs[2] ) ]
        else:
            pdxs = [ ( dxs[0], dxs[0] ), ( dxs[1], max( 0, tdx/2 ) ),
                     ( dxs[2], dxs[2] ), ( dxs[3], max( 0, tdx - (tdx/2) ) ),
                     ( dxs[4], dxs[4] ) ]

        # Calculate horizontal slice sizes to use for source and destination:
        n = len( dys )
        if n == 1:
            pdys = [ ( 0, 0 ), ( 1, max( 1, tdy/2 ) ), ( sdy - 2, sdy - 2 ),
                     ( 1, max( 1, tdy - (tdy/2) ) ), ( 0, 0 ) ]
        elif n == 3:
            pdys = [ ( dys[0], dys[0] ), ( dys[1], max( 0, tdy ) ), ( 0, 0 ),
                     ( 0, 0 ), ( dys[2], dys[2] ) ]
        else:
            pdys = [ ( dys[0], dys[0] ), ( dys[1], max( 0, tdy/2 ) ),
                     ( dys[2], dys[2] ), ( dys[3], max( 0, tdy - (tdy/2) ) ),
                     ( dys[4], dys[4] ) ]

        # Iterate over each cell, performing a stretch fill from the source
        # image to the destination window:
        last_x, last_y = x + dx, y + dy
        y0, iy0 = y, 0
        for idy, wdy in pdys:
            if y0 >= last_y:
                break

            if wdy != 0:
                x0, ix0 = x, 0
                for idx, wdx in pdxs:
                    if x0 >= last_x:
                        break

                    if wdx != 0:
                        self._fill( idc, ix0, iy0, idx, idy,
                                    dc,  x0,  y0,  wdx, wdy )
                        x0 += wdx
                    ix0 += idx
                y0 += wdy
            iy0 += idy

        if self.debug:
            dc.SetPen( wx.Pen( wx.RED ) )
            dc.DrawLine( x, y + self.top, last_x, y + self.top )
            dc.DrawLine( x, last_y - self.bottom - 1,
                         last_x, last_y - self.bottom - 1 )
            dc.DrawLine( x + self.left, y, x + self.left, last_y )
            dc.DrawLine( last_x - self.right - 1, y,
                         last_x - self.right - 1, last_y )

    #-- Event Handlers ---------------------------------------------------------

    def _image_changed ( self, image ):
        """ Handles the 'image' trait being changed.
        """
        # Save the original bitmap as the transparent version:
        self.transparent_bitmap = bitmap = \
            image.create_image().ConvertToBitmap()

        # Save the bitmap size information:
        self.dx = dx = bitmap.GetWidth()
        self.dy = dy = bitmap.GetHeight()

        # Create the opaque version of the bitmap:
        self.opaque_bitmap = wx.EmptyBitmap( dx, dy )
        mdc2 = wx.MemoryDC()
        mdc2.SelectObject( self.opaque_bitmap )
        mdc2.SetBrush( wx.Brush( WindowColor ) )
        mdc2.SetPen( wx.TRANSPARENT_PEN )
        mdc2.DrawRectangle( 0, 0, dx, dy )
        mdc = wx.MemoryDC()
        mdc.SelectObject( bitmap )
        mdc2.Blit( 0, 0, dx, dy, mdc, 0, 0, useMask = True )
        mdc.SelectObject(  wx.NullBitmap )
        mdc2.SelectObject( wx.NullBitmap )

        # Finally, analyze the image to find out its characteristics:
        self._analyze_bitmap()

    #-- Private Methods --------------------------------------------------------

    def _analyze_bitmap ( self ):
        """ Analyzes the bitmap.
        """
        # Get the image data:
        threshold = self.threshold
        bitmap    = self.opaque_bitmap
        dx, dy    = self.dx, self.dy
        image     = bitmap.ConvertToImage()

        # Convert the bitmap data to a numpy array for analysis:
        data = reshape( fromstring( image.GetData(), uint8 ), ( dy, dx, 3 ) )

        # Find the horizontal slices:
        matches  = []
        y, last  = 0, dy - 1
        max_diff = 0.10 * dx
        while y < last:
            y_data = data[y]
            for y2 in xrange( y + 1, dy ):
                if abs( y_data - data[y2] ).sum() > max_diff:
                    break

            n = y2 - y
            if n >= threshold:
                matches.append( ( y, n ) )

            y = y2

        n = len( matches )
        if n == 0:
            if dy > 50:
                matches = [ ( 0, dy ) ]
            else:
                matches = [ ( dy / 2, 1 ) ]
        elif n > self.stretch_rows:
            matches.sort( lambda l, r: cmp( r[1], l[1] ) )
            matches = matches[ : self.stretch_rows ]

        # Calculate and save the horizontal slice sizes:
        self.fdy, self.dys = self._calculate_dxy( dy, matches )

        # Find the vertical slices:
        matches  = []
        x, last  = 0, dx - 1
        max_diff = 0.10 * dy
        while x < last:
            x_data = data[:,x]
            for x2 in xrange( x + 1, dx ):
                if abs( x_data - data[:,x2] ).sum() > max_diff:
                    break

            n = x2 - x
            if n >= threshold:
                matches.append( ( x, n ) )

            x = x2

        n = len( matches )
        if n == 0:
            if dx > 50:
                matches = [ ( 0, dx ) ]
            else:
                matches = [ ( dx / 2, 1 ) ]
        elif n > self.stretch_columns:
            matches.sort( lambda l, r: cmp( r[1], l[1] ) )
            matches = matches[ : self.stretch_columns ]

        # Calculate and save the vertical slice sizes:
        self.fdx, self.dxs = self._calculate_dxy( dx, matches )

        # Save the border size information:
        self.top    = min( dy / 2, self.dys[0] )
        self.bottom = min( dy / 2, self.dys[-1] )
        self.left   = min( dx / 2, self.dxs[0] )
        self.right  = min( dx / 2, self.dxs[-1] )

        # Find the optimal size for the borders (i.e. xleft, xright, ... ):
        self._find_best_borders( data )

        # Save the background color:
        x, y          = (dx / 2), (dy / 2)
        r, g, b       = data[ y, x ]
        self.bg_color = (0x10000 * r) + (0x100 * g) + b

        # Find the best contrasting text color (black or white):
        self.content_color = self._find_best_color( data, x, y )

        # Find the best contrasting label color:
        if self.xtop >= self.xbottom:
            self.label_color = self._find_best_color( data, x, self.xtop / 2 )
        else:
            self.label_color = self._find_best_color(
                                        data, x, dy - (self.xbottom / 2) - 1 )

    def _fill ( self, idc, ix, iy, idx, idy, dc, x, y, dx, dy ):
        """ Performs a stretch fill of a region of an image into a region of a
            window device context.
        """
        last_x, last_y = x + dx, y + dy
        while y < last_y:
            ddy = min( idy, last_y - y )
            x0  = x
            while x0 < last_x:
                ddx = min( idx, last_x - x0 )
                dc.Blit( x0, y, ddx, ddy, idc, ix, iy, useMask = True )
                x0 += ddx
            y += ddy

    def _calculate_dxy ( self, d, matches ):
        """ Calculate the size of all image slices for a specified set of
            matches.
        """
        if len( matches ) == 1:
            d1, d2 = matches[0]

            return ( d - d2, [ d1, d2, d - d1 - d2 ] )

        d1, d2 = matches[0]
        d3, d4 = matches[1]

        return ( d - d2 - d4, [ d1, d2, d3 - d1 - d2, d4, d - d3 - d4 ] )

    def _find_best_borders ( self, data ):
        """ Find the best set of image slice border sizes (e.g. for images with
            rounded corners, there should exist a better set of borders than
            the ones computed by the image slice algorithm.
        """
        # Make sure the image size is worth bothering about:
        dx, dy = self.dx, self.dy
        if (dx < 5) or (dy < 5):
            return

        # Calculate the starting point:
        left = right  = dx / 2
        top  = bottom = dy / 2

        # Calculate the end points:
        last_y = dy - 1
        last_x = dx - 1

        # Mark which edges as 'scanning':
        t = b = l = r = True

        # Keep looping while at last one edge is still 'scanning':
        while l or r or t or b:

            # Calculate the current core area size:
            height = bottom - top + 1
            width  = right - left + 1

            # Try to extend all edges that are still 'scanning':
            nl = (l and (left > 0) and
                  self._is_equal( data, left - 1, top, left, top, 1, height ))

            nr = (r and (right < last_x) and
                  self._is_equal( data, right + 1, top, right, top, 1, height ))

            nt = (t and (top > 0) and
                 self._is_equal( data, left, top - 1, left, top, width, 1 ))

            nb = (b and (bottom < last_y) and
                  self._is_equal( data, left, bottom + 1, left, bottom,
                                  width, 1 ))

            # Now check the corners of the edges:
            tl = ((not nl) or (not nt) or
                  self._is_equal( data, left - 1, top - 1, left, top, 1, 1 ))

            tr = ((not nr) or (not nt) or
                  self._is_equal( data, right + 1, top - 1, right, top, 1, 1 ))

            bl = ((not nl) or (not nb) or
                  self._is_equal( data, left - 1, bottom + 1, left, bottom,
                                  1, 1 ))

            br = ((not nr) or (not nb) or
                  self._is_equal( data, right + 1, bottom + 1, right, bottom,
                                  1, 1 ))

            # Calculate the new edge 'scanning' values:
            l = nl and tl and bl
            r = nr and tr and br
            t = nt and tl and tr
            b = nb and bl and br

            # Adjust the coordinate of an edge if it is still 'scanning':
            left   -= l
            right  += r
            top    -= t
            bottom += b

        # Now compute the best set of image border sizes using the current set
        # and the ones we just calculated:
        self.xleft   = min( self.left,   left )
        self.xright  = min( self.right,  dx - right - 1 )
        self.xtop    = min( self.top,    top )
        self.xbottom = min( self.bottom, dy - bottom - 1 )

    def _find_best_color ( self, data, x, y ):
        """ Find the best contrasting text color for a specified pixel
            coordinate.
        """
        r, g, b = data[ y, x ]
        h, l, s = rgb_to_hls( r / 255.0, g / 255.0, b / 255.0 )
        text_color = wx.BLACK
        if l < 0.50:
            text_color = wx.WHITE

        return text_color

    def _is_equal ( self, data, x0, y0, x1, y1, dx, dy ):
        """ Determines if two identically sized regions of an image array are
            'the same' (i.e. within some slight color variance of each other).
        """
        return (abs( data[ y0: y0 + dy, x0: x0 + dx ] -
                     data[ y1: y1 + dy, x1: x1 + dx ] ).sum() < 0.10 * dx * dy)


#-------------------------------------------------------------------------------
#  Returns a (possibly cached) ImageSlice:
#-------------------------------------------------------------------------------

image_slice_cache = {}

def image_slice_for ( image ):
    """ Returns a (possibly cached) ImageSlice.
    """
    global image_slice_cache

    result = image_slice_cache.get( image )
    if result is None:
        image_slice_cache[ image ] = result = ImageSlice( image = image )

    return result

########NEW FILE########
__FILENAME__ = image_text
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/11/2007
#
#-------------------------------------------------------------------------------

""" Defines a themed read-only text string.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from image_slice \
    import paint_parent

from helper \
    import BufferDC

#-------------------------------------------------------------------------------
#  Class 'ImageText'
#-------------------------------------------------------------------------------

class ImageText ( wx.PyWindow ):
    """ Defines a text control that displays an ImageSlice in its background.
    """

    #-- wx.PyWindow Method Overrides -------------------------------------------

    def __init__ ( self, parent, theme, text = '', border=False ):
        """ Initializes the object.
        """
        self._theme = theme
        self._border = border
        if theme is not None:
            self._image_slice = theme.image_slice

        super( ImageText, self ).__init__( parent, -1,
                                           style = wx.FULL_REPAINT_ON_RESIZE )

        self._text_size = None
        self._text      = text

        # Set up the painting event handlers:
        wx.EVT_ERASE_BACKGROUND( self, self._erase_background )
        wx.EVT_PAINT( self, self._on_paint )

        size = self.GetMinSize()
        self.SetMinSize( size )
        self.SetSize( size )

    def AcceptsFocus ( self ):
        """ Indicate that we are a static control that does not accept focus.
        """
        return False

    #-- wxPython Event Handlers ------------------------------------------------

    def _erase_background ( self, event ):
        """ Do not erase the background here (do it in the 'on_paint' handler).
        """
        pass

    def _on_paint ( self, event ):
        """ Paint the background using the associated ImageSlice object.
        """
        dc = BufferDC( self )

        paint_parent( dc, self )

        if self._theme is not None:
            wdx, wdy = self.GetClientSize()
            self._image_slice.fill( dc, 0, 0, wdx, wdy, True )
            dc.SetTextForeground( self._image_slice.content_color )

        dc.SetBackgroundMode( wx.TRANSPARENT )
        dc.SetFont( self.GetFont() )
        tx, ty, tdx, tdy = self._get_text_bounds()
        dc.DrawText( self._text, tx, ty )
        dc.copy()

    def GetMinSize ( self ):
        """ Returns the minimum size for the window.
        """
        tdx, tdy, descent, leading = self._get_text_size()
        if self._theme is None:
            return wx.Size( tdx + 8, tdy + 4 )

        content = self._theme.content
        tdx    += (content.left + content.right)
        tdy    += (content.top  + content.bottom)
        slice   = self._image_slice

        return wx.Size( max( slice.left  + slice.right,
                             slice.xleft + slice.xright  + tdx + 8 ),
                        max( slice.top   + slice.bottom,
                             slice.xtop  + slice.xbottom + tdy + 4 ) )

    def SetFont ( self, font ):
        """ Set the window font.
        """
        super( ImageText, self ).SetFont( font )

        self._refresh()

    def SetLabel ( self, label ):
        """ Set the window label.
        """
        self._text = label
        self._refresh()

    def _refresh ( self ):
        """ Refreshes the contents of the control.
        """
        if self._text_size is not None:
            self.RefreshRect( wx.Rect( *self._get_text_bounds() ), False )
            self._text_size = None

        self.SetMinSize( self.GetMinSize() )
        self.RefreshRect( wx.Rect( *self._get_text_bounds() ), False )

    def _get_text_size ( self, text = None ):
        """ Returns the text size information for the window.
        """
        if self._text_size is None:
            if text is None:
                text = self._text

            if text.strip() == '':
                text = 'M'

            self._text_size = self.GetFullTextExtent( text )

        return self._text_size

    def _get_text_bounds ( self ):
        """ Get the window bounds of where the current text should be
            displayed.
        """
        tdx, tdy, descent, leading = self._get_text_size()
        wdx, wdy  = self.GetClientSize()
        theme     = self._theme
        if theme is None:
            return ( wdx - tdx, (wdy - tdy) / 2, tdx, tdy )

        slice   = self._image_slice
        content = theme.content
        ady     = wdy - slice.xtop - slice.xbottom
        ty      = (wdy + slice.xtop + content.top - slice.xtop -
                         slice.xbottom - tdy) / 2

        alignment = theme.alignment
        if alignment == 'left':
            tx = slice.xleft + content.left
        elif alignment == 'center':
            adx = wdx - slice.xleft - slice.xright
            tx  = slice.xleft + content.left + 4 + ((adx - tdx) / 2)
        else:
            tx = wdx - tdx - slice.xright - content.right

        return ( tx + theme.label.left, ty + theme.label.top, tdx, tdy )


########NEW FILE########
__FILENAME__ = instance_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various instance editors for the wxPython user interface
toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasTraits, Property

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.instance_editor file.
from traitsui.editors.instance_editor \
    import ToolkitEditorFactory

from traitsui.ui_traits \
    import AView

from traitsui.helper \
    import user_name_for

from traitsui.handler \
    import Handler

from traitsui.instance_choice \
    import InstanceChoiceItem

from editor \
    import Editor

from constants \
    import DropColor, is_wx26

from helper \
    import TraitsUIPanel, position_window

from pyface.wx.drag_and_drop \
    import PythonDropTarget

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

OrientationMap = {
    'default':    None,
    'horizontal': wx.HORIZONTAL,
    'vertical':   wx.VERTICAL
}

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( Editor ):
    """ Custom style of editor for instances. If selection among instances is
    allowed, the editor displays a combo box listing instances that can be
    selected. If the current instance is editable, the editor displays a panel
    containing trait editors for all the instance's traits.
    """

    # Background color when an item can be dropped on the editor:
    ok_color = DropColor

    # The orientation of the instance editor relative to the instance selector:
    orientation = wx.VERTICAL

    # Class constant:
    extra = 0

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # List of InstanceChoiceItem objects used by the editor
    items = Property

    # The maximum extra padding that should be allowed around the editor:
    # (Override of the Editor base class trait)
    border_size = 0

    # The view to use for displaying the instance:
    view = AView

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if factory.name != '':
            self._object, self._name, self._value = \
                self.parse_extended_name( factory.name )

        # Create a panel to hold the object trait's view:
        if factory.editable:
            self.control = self._panel = parent = TraitsUIPanel( parent, -1 )

        # Build the instance selector if needed:
        selectable = factory.selectable
        droppable  = factory.droppable
        items      = self.items
        for item in items:
            droppable  |= item.is_droppable()
            selectable |= item.is_selectable()

        if selectable:
            self._object_cache = {}
            item = self.item_for( self.value )
            if item is not None:
                self._object_cache[ id( item ) ] = self.value

            self._choice = choice = wx.Choice( parent, -1, wx.Point( 0, 0 ),
                                        wx.Size( -1, -1 ), [] )
            wx.EVT_CHOICE( choice, choice.GetId(), self.update_object )
            if droppable:
                self._choice.SetBackgroundColour( self.ok_color )

            self.set_tooltip( self._choice )

            if factory.name != '':
                self._object.on_trait_change( self.rebuild_items,
                                              self._name, dispatch = 'ui' )
                self._object.on_trait_change( self.rebuild_items,
                                 self._name + '_items', dispatch = 'ui' )

            factory.on_trait_change( self.rebuild_items, 'values',
                                     dispatch = 'ui' )
            factory.on_trait_change( self.rebuild_items, 'values_items',
                                     dispatch = 'ui' )

            self.rebuild_items()

        elif droppable:
            self._choice = wx.TextCtrl( parent, -1, '',
                                        style = wx.TE_READONLY )
            self._choice.SetBackgroundColour( self.ok_color )
            self.set_tooltip( self._choice )

        if droppable:
            self._choice.SetDropTarget( PythonDropTarget( self ) )

        orientation = OrientationMap[ factory.orientation ]
        if orientation is None:
            orientation = self.orientation

        if (selectable or droppable) and factory.editable:
            sizer = wx.BoxSizer( orientation )
            sizer.Add( self._choice, self.extra, wx.EXPAND )
            if orientation == wx.VERTICAL:
                sizer.Add(
                    wx.StaticLine( parent, -1, style = wx.LI_HORIZONTAL ), 0,
                    wx.EXPAND | wx.TOP | wx.BOTTOM, 5 )
            self.create_editor( parent, sizer )
            parent.SetSizer( sizer )
        elif self.control is None:
            if self._choice is None:
                self._choice = choice = wx.Choice( parent, -1, wx.Point( 0, 0 ),
                                            wx.Size( -1, -1 ), [] )
                wx.EVT_CHOICE( choice, choice.GetId(), self.update_object )
            self.control = self._choice
        else:
            sizer = wx.BoxSizer( orientation )
            self.create_editor( parent, sizer )
            parent.SetSizer( sizer )

        # Synchronize the 'view' to use:
        # fixme: A normal assignment can cause a crash (for unknown reasons) in
        # some cases, so we make sure that no notifications are generated:
        self.trait_setq( view = factory.view )
        self.sync_value( factory.view_name, 'view', 'from' )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Make sure we aren't hanging on to any object refs:
        self._object_cache = None

        if self._ui is not None:
            self._ui.dispose()

        choice = self._choice
        if choice is not None:
            if isinstance( choice, wx.Choice ):
                wx.EVT_CHOICE( choice, choice.GetId(), None )

            if self._object is not None:
                self._object.on_trait_change( self.rebuild_items,
                                              self._name, remove = True )
                self._object.on_trait_change( self.rebuild_items,
                                 self._name + '_items', remove = True )

            self.factory.on_trait_change( self.rebuild_items, 'values',
                                          remove = True )
            self.factory.on_trait_change( self.rebuild_items,
                                          'values_items', remove = True )

        super( CustomEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Creates the editor control:
    #---------------------------------------------------------------------------

    def create_editor ( self, parent, sizer ):
        """ Creates the editor control.
        """
        self._panel = TraitsUIPanel( parent, -1 )
        sizer.Add( self._panel, 1, wx.EXPAND )

    #---------------------------------------------------------------------------
    #  Gets the current list of InstanceChoiceItem items:
    #---------------------------------------------------------------------------

    def _get_items ( self ):
        """ Gets the current list of InstanceChoiceItem items.
        """
        if self._items is not None:
            return self._items

        factory = self.factory
        if self._value is not None:
            values = self._value() + factory.values
        else:
            values = factory.values

        items   = []
        adapter = factory.adapter
        for value in values:
            if not isinstance( value, InstanceChoiceItem ):
                value = adapter( object = value )
            items.append( value )

        self._items = items

        return items

    #---------------------------------------------------------------------------
    #  Rebuilds the object selector list:
    #---------------------------------------------------------------------------

    def rebuild_items ( self ):
        """ Rebuilds the object selector list.
        """
        # Clear the current cached values:
        self._items = None

        # Rebuild the contents of the selector list:
        name   = None
        value  = self.value
        choice = self._choice
        choice.Clear()
        for item in self.items:
            if item.is_selectable():
                item_name = item.get_name()
                choice.Append( item_name )
                if item.is_compatible( value ):
                    name = item_name

        # Reselect the current item if possible:
        if name is not None:
            choice.SetStringSelection( name )
        else:
            # Otherwise, current value is no longer valid, try to discard it:
            try:
                self.value = None
            except:
                pass

    #---------------------------------------------------------------------------
    #  Returns the InstanceChoiceItem for a specified object:
    #---------------------------------------------------------------------------

    def item_for ( self, object ):
        """ Returns the InstanceChoiceItem for a specified object.
        """
        for item in self.items:
            if item.is_compatible( object ):
                return item

        return None

    #---------------------------------------------------------------------------
    #  Returns the view to use for a specified object:
    #---------------------------------------------------------------------------

    def view_for ( self, object, item ):
        """ Returns the view to use for a specified object.
        """
        view = ''
        if item is not None:
            view = item.get_view()

        if view == '':
            view = self.view

        return self.ui.handler.trait_view_for( self.ui.info, view, object,
                                               self.object_name, self.name )

    #---------------------------------------------------------------------------
    #  Handles the user selecting a new value from the combo box:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user selecting a new value from the combo box.
        """
        name = event.GetString()
        for item in self.items:
            if name == item.get_name():
                id_item = id( item )
                object  = self._object_cache.get( id_item )
                if object is None:
                    object = item.get_object()
                    if (not self.factory.editable) and item.is_factory:
                        view = self.view_for( object, self.item_for( object ) )
                        view.ui( object, self.control, 'modal' )

                    if self.factory.cachable:
                        self._object_cache[ id_item ] = object

                self.value = object
                self.resynch_editor()
                break

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Attach the current object value to the control (for use by
        # DockWindowFeature):

        # fixme: This code is somewhat fragile since it assumes that if a
        # DockControl is involved, the parent of this editor will be the
        # control being managed by the DockControl.
        parent         = self.control.GetParent()
        parent._object = self.value
        dock_control   = getattr( parent, '_dock_control', None )
        if dock_control is not None:
            dock_control.reset_tab()

        # Synchronize the editor contents:
        self.resynch_editor()

        # Update the selector (if any):
        choice = self._choice
        item   = self.item_for( self.value )
        if (choice is not None) and (item is not None):
            name = item.get_name( self.value )
            if self._object_cache is not None:
                if choice.FindString( name ) < 0:
                    choice.Append( name )
                choice.SetStringSelection( name )
            else:
                choice.SetValue( name )

    #---------------------------------------------------------------------------
    #  Resynchronizes the contents of the editor when the object trait changes
    #  external to the editor:
    #---------------------------------------------------------------------------

    def resynch_editor ( self ):
        """ Resynchronizes the contents of the editor when the object trait
        changes externally to the editor.
        """
        panel = self._panel
        if panel is not None:
            # Compute/update the maximum size the panel has ever been:
            dx, dy = panel.GetSizeTuple()
            mdx    = mdy = 0
            if self._panel_size is not None:
                mdx, mdy = self._panel_size
            self._panel_size = size = wx.Size( max( mdx, dx ), max( mdy, dy ) )

            # Dispose of the previous contents of the panel:
            panel.SetSizer( None )
            if self._ui is not None:
                self._ui.dispose()
                self._ui = None
            else:
                panel.DestroyChildren()

            # Create the new content for the panel:
            sizer   = wx.BoxSizer( wx.VERTICAL )
            stretch = 0
            value   = self.value
            if not isinstance( value, HasTraits ):
                str_value = ''
                if value is not None:
                    str_value = self.str_value
                control = wx.StaticText( panel, -1, str_value )
            else:
                view    = self.view_for( value, self.item_for( value ) )
                context = value.trait_context()
                handler = None
                if isinstance( value, Handler ):
                    handler = value
                context.setdefault( 'context', self.object )
                context.setdefault( 'context_handler', self.ui.handler )
                self._ui = ui = view.ui( context, panel, 'subpanel',
                                         value.trait_view_elements(), handler,
                                         self.factory.id )
                control         = ui.control
                self.scrollable = ui._scrollable
                ui.parent       = self.ui

                if view.resizable or view.scrollable or ui._scrollable:
                    stretch = 1

            # Make sure the panel and its contents are correctly sized (This
            # code is complicated by the various layout bugs present in wx.
            # Tamper with it at your own risk!):
            control.Freeze()
            if stretch and (size != ( 20, 20 )):
                control.SetSize( size )
                panel.SetSize( size )
            else:
                panel.SetSize( control.GetSize() )
            sizer.Add( control, stretch, wx.EXPAND )
            panel.SetSizer( sizer )
            control.Thaw()
            self.control.Layout()
            parent = self.control.GetParent()
            parent.Layout()

            # It is possible that this instance editor is embedded at some level
            # in a ScrolledWindow. If so, we need to inform the window that the
            # size of the editor's contents have (potentially) changed:
            # NB: There is a typo in the wxPython 2.6 code that prevents the
            # 'SendSizeEvent' from working correctly, so we just skip it.
            if not is_wx26:
                while ((parent is not None) and
                       (not isinstance( parent, wx.ScrolledWindow ))):
                    parent = parent.GetParent()

                if parent is not None:
                    parent.SendSizeEvent()

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return (self._choice or self.control)

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        ui = self._ui
        if (ui is not None) and (prefs.get( 'id' ) == ui.id):
            ui.set_prefs( prefs.get( 'prefs' ) )

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        ui = self._ui
        if (ui is not None) and (ui.id != ''):
            return { 'id':    ui.id,
                     'prefs': ui.get_prefs() }

        return None

    #-- Drag and drop event handlers -------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a Python object being dropped on the control:
    #---------------------------------------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the tree.
        """
        for item in self.items:
            if item.is_droppable() and item.is_compatible( data ):
                if self._object_cache is not None:
                    self.rebuild_items()
                self.value = data
                return drag_result

        return wx.DragNone

    #---------------------------------------------------------------------------
    #  Handles a Python object being dragged over the control:
    #---------------------------------------------------------------------------

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        for item in self.items:
            if item.is_droppable() and item.is_compatible( data ):
                return drag_result

        return wx.DragNone

    #-- Traits event handlers --------------------------------------------------

    def _view_changed ( self, view ):
        self.resynch_editor()

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( CustomEditor ):
    """ Simple style of editor for instances, which displays a button. Clicking
    the button displays a dialog box in which the instance can be edited.
    """

    # Class constants:
    orientation = wx.HORIZONTAL
    extra       = 2

    #---------------------------------------------------------------------------
    #  Creates the editor control:
    #---------------------------------------------------------------------------

    def create_editor ( self, parent, sizer ):
        """ Creates the editor control (a button).
        """
        self._button = button = wx.Button( parent, -1, '' )
        sizer.Add( button, 1, wx.EXPAND | wx.LEFT, 5 )
        wx.EVT_BUTTON( button, button.GetId(), self.edit_instance )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        button = self._button
        if button is not None:
            wx.EVT_BUTTON( button, button.GetId(), None )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Edit the contents of the object trait when the user clicks the button:
    #---------------------------------------------------------------------------

    def edit_instance ( self, event ):
        """ Edit the contents of the object trait when the user clicks the
            button.
        """
        # Create the user interface:
        factory = self.factory
        view    = self.ui.handler.trait_view_for( self.ui.info, factory.view,
                                                  self.value, self.object_name,
                                                  self.name )
        ui = self.value.edit_traits( view, self.control, factory.kind,
                                     id = factory.id )

        # Check to see if the view was 'modal', in which case it will already
        # have been closed (i.e. is None) by the time we get control back:
        if ui.control is not None:
            # Position the window on the display:
            position_window( ui.control )

            # Chain our undo history to the new user interface if it does not
            # have its own:
            if ui.history is None:
                ui.history = self.ui.history

    #---------------------------------------------------------------------------
    #  Resynchronizes the contents of the editor when the object trait changes
    #  external to the editor:
    #---------------------------------------------------------------------------

    def resynch_editor ( self ):
        """ Resynchronizes the contents of the editor when the object trait
            changes externally to the editor.
        """
        button = self._button
        if button is not None:
            label = self.factory.label
            if label == '':
                label = user_name_for( self.name )
            button.SetLabel( label )
            button.Enable( isinstance( self.value, HasTraits ) )

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = key_binding_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   05/20/2005
#
#-------------------------------------------------------------------------------

""" Defines the key binding editor for use with the KeyBinding class. This is a
    specialized editor used to associate a particular key with a control (i.e.,
    the key binding editor).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Event, false

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.key_binding_editor file.
from traitsui.editors.key_binding_editor \
    import KeyBindingEditor as ToolkitEditorFactory

from pyface.wx.dialog \
    import confirmation

from editor \
    import Editor

from key_event_to_name \
    import key_event_to_name

#-------------------------------------------------------------------------------
#  'KeyBindingEditor' class:
#-------------------------------------------------------------------------------

class KeyBindingEditor ( Editor ):
    """ An editor for modifying bindings of keys to controls.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Does the editor's control have focus currently?
    has_focus = false

    # Keyboard event
    key = Event

    # Clear field event
    clear = Event

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = KeyBindingCtrl( self, parent, size = wx.Size( 160, 19 ) )

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        try:
            self.value = value = key_event_to_name( event )
            self._binding.text = value
        except:
            pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.control.Refresh()

    #---------------------------------------------------------------------------
    #  Updates the current focus setting of the control:
    #---------------------------------------------------------------------------

    def update_focus ( self, has_focus ):
        """ Updates the current focus setting of the control.
        """
        if has_focus:
            self._binding.border_size     = 1
            self.object.owner.focus_owner = self._binding

    #---------------------------------------------------------------------------
    #  Handles a keyboard event:
    #---------------------------------------------------------------------------

    def _key_changed ( self, event ):
        """ Handles a keyboard event.
        """
        binding     = self.object
        key_name    = key_event_to_name( event )
        cur_binding = binding.owner.key_binding_for( binding, key_name )
        if cur_binding is not None:
            if confirmation( None,
                     "'%s' has already been assigned to '%s'.\n"
                     "Do you wish to continue?" % (
                     key_name, cur_binding.description ),
                     'Duplicate Key Definition' ) == 5104:
                return

        self.value = key_name

    #---------------------------------------------------------------------------
    #  Handles a clear field event:
    #---------------------------------------------------------------------------

    def _clear_changed ( self ):
        """ Handles a clear field event.
        """
        self.value = ''

#-------------------------------------------------------------------------------
#  'KeyBindingCtrl' class:
#-------------------------------------------------------------------------------

class KeyBindingCtrl ( wx.Window ):
    """ wxPython control for editing key bindings.
    """

    #---------------------------------------------------------------------------
    #  Initialize the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, editor, parent, wid = -1, pos = wx.DefaultPosition,
                   size = wx.DefaultSize ):

        super( KeyBindingCtrl, self ).__init__( parent, wid, pos, size,
                                                style = wx.CLIP_CHILDREN |
                                                        wx.WANTS_CHARS )
        # Save the reference to the controlling editor object:
        self.editor = editor

        # Indicate we don't have the focus right now:
        editor.has_focus = False

        # Set up the 'erase background' event handler:
        wx.EVT_ERASE_BACKGROUND( self, self._on_erase_background )

        # Set up the 'paint' event handler:
        wx.EVT_PAINT( self, self._paint )

        # Set up the focus change handlers:
        wx.EVT_SET_FOCUS(  self, self._get_focus )
        wx.EVT_KILL_FOCUS( self, self._lose_focus )

        # Set up mouse event handlers:
        wx.EVT_LEFT_DOWN( self, self._set_focus )
        wx.EVT_LEFT_DCLICK( self, self._clear_contents )

        # Handle key events:
        wx.EVT_CHAR( self, self._on_char )

    #---------------------------------------------------------------------------
    #  Handle keyboard keys being pressed:
    #---------------------------------------------------------------------------

    def _on_char ( self, event ):
        """ Handle keyboard keys being pressed.
        """
        self.editor.key = event

    #---------------------------------------------------------------------------
    #  Erase background event handler:
    #---------------------------------------------------------------------------

    def _on_erase_background ( self, event ):
        pass

    #---------------------------------------------------------------------------
    #  Do a GUI toolkit specific screen update:
    #---------------------------------------------------------------------------

    def _paint ( self, event ):
        """ Updates the screen.
        """
        wdc    = wx.PaintDC( self )
        dx, dy = self.GetSizeTuple()
        if self.editor.has_focus:
            wdc.SetPen( wx.Pen( wx.RED, 2 ) )
            wdc.DrawRectangle( 1, 1, dx - 1, dy - 1 )
        else:
            wdc.SetPen( wx.Pen( wx.BLACK ) )
            wdc.DrawRectangle( 0, 0, dx, dy )

        wdc.SetFont( self.GetFont() )
        wdc.DrawText( self.editor.str_value, 5, 3 )

    #---------------------------------------------------------------------------
    #  Sets the keyboard focus to this window:
    #---------------------------------------------------------------------------

    def _set_focus ( self, event ):
        """ Sets the keyboard focus to this window.
        """
        self.SetFocus()

    #---------------------------------------------------------------------------
    #  Handles getting/losing the focus:
    #---------------------------------------------------------------------------

    def _get_focus ( self, event ):
        """ Handles getting the focus.
        """
        self.editor.has_focus = True
        self.Refresh()

    def _lose_focus ( self, event ):
        """ Handles losing the focus.
        """
        self.editor.has_focus = False
        self.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the user double clicking the control to clear its contents:
    #---------------------------------------------------------------------------

    def _clear_contents ( self, event ):
        """ Handles the user double clicking the control to clear its contents.
        """
        self.editor.clear = True

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = key_event_to_name
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   09/22/2005
#
#-------------------------------------------------------------------------------

""" Converts a wx.KeyEvent to a standardized "name".
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping from wxPython special key names to Enable key names
key_map = {
    wx.WXK_BACK:      'Backspace',
    wx.WXK_TAB:       'Tab',
    wx.WXK_RETURN:    'Enter',
    wx.WXK_ESCAPE:    'Esc',
    wx.WXK_DELETE:    'Delete',
    wx.WXK_START:     'Start',
    wx.WXK_LBUTTON:   'Left Button',
    wx.WXK_RBUTTON:   'Right Button',
    wx.WXK_CANCEL:    'Cancel',
    wx.WXK_MBUTTON:   'Middle Button',
    wx.WXK_CLEAR:     'Clear',
    wx.WXK_SHIFT:     'Shift',
    wx.WXK_CONTROL:   'Control',
    wx.WXK_MENU:      'Menu',
    wx.WXK_PAUSE:     'Pause',
    wx.WXK_CAPITAL:   'Capital',
    wx.WXK_PRIOR:     'Page Up',
    wx.WXK_NEXT:      'Page Down',
    wx.WXK_END:       'End',
    wx.WXK_HOME:      'Home',
    wx.WXK_LEFT:      'Left',
    wx.WXK_UP:        'Up',
    wx.WXK_RIGHT:     'Right',
    wx.WXK_DOWN:      'Down',
    wx.WXK_SELECT:    'Select',
    wx.WXK_PRINT:     'Print',
    wx.WXK_EXECUTE:   'Execute',
    wx.WXK_SNAPSHOT:  'Snapshot',
    wx.WXK_INSERT:    'Insert',
    wx.WXK_HELP:      'Help',
    wx.WXK_NUMPAD0:   'Numpad 0',
    wx.WXK_NUMPAD1:   'Numpad 1',
    wx.WXK_NUMPAD2:   'Numpad 2',
    wx.WXK_NUMPAD3:   'Numpad 3',
    wx.WXK_NUMPAD4:   'Numpad 4',
    wx.WXK_NUMPAD5:   'Numpad 5',
    wx.WXK_NUMPAD6:   'Numpad 6',
    wx.WXK_NUMPAD7:   'Numpad 7',
    wx.WXK_NUMPAD8:   'Numpad 8',
    wx.WXK_NUMPAD9:   'Numpad 9',
    wx.WXK_MULTIPLY:  'Multiply',
    wx.WXK_ADD:       'Add',
    wx.WXK_SEPARATOR: 'Separator',
    wx.WXK_SUBTRACT:  'Subtract',
    wx.WXK_DECIMAL:   'Decimal',
    wx.WXK_DIVIDE:    'Divide',
    wx.WXK_F1:        'F1',
    wx.WXK_F2:        'F2',
    wx.WXK_F3:        'F3',
    wx.WXK_F4:        'F4',
    wx.WXK_F5:        'F5',
    wx.WXK_F6:        'F6',
    wx.WXK_F7:        'F7',
    wx.WXK_F8:        'F8',
    wx.WXK_F9:        'F9',
    wx.WXK_F10:       'F10',
    wx.WXK_F11:       'F11',
    wx.WXK_F12:       'F12',
    wx.WXK_F13:       'F13',
    wx.WXK_F14:       'F14',
    wx.WXK_F15:       'F15',
    wx.WXK_F16:       'F16',
    wx.WXK_F17:       'F17',
    wx.WXK_F18:       'F18',
    wx.WXK_F19:       'F19',
    wx.WXK_F20:       'F20',
    wx.WXK_F21:       'F21',
    wx.WXK_F22:       'F22',
    wx.WXK_F23:       'F23',
    wx.WXK_F24:       'F24',
    wx.WXK_NUMLOCK:   'Num Lock',
    wx.WXK_SCROLL:    'Scroll Lock'
}

#-------------------------------------------------------------------------------
#  Converts a keystroke event into a corresponding key name:
#-------------------------------------------------------------------------------

def key_event_to_name ( event ):
    """ Converts a keystroke event into a corresponding key name.
    """
    key_code = event.GetKeyCode()
    if event.ControlDown() and (1 <= key_code <= 26):
        key = chr( key_code + 96 )
    else:
        key = key_map.get( key_code )
        if key is None:
            try:
                key = chr( key_code )
            except:
                # Handle the case of strange keyboard codes (such as the Apple
                # keyboard 'apple' key):
                key = 'unknown'

    name = ''
    if event.AltDown():
        name = 'Alt'

    if event.ControlDown():
        name += '-Ctrl'

    if event.ShiftDown() and ((name != '') or (len( key ) > 1)):
        name += '-Shift'

    if key == ' ':
        key = 'Space'

    if len( name ) > 0:
        key = key.lower()

    name += ('-' + key)

    if name[:1] == '-':
        return name[1:]
    return name


########NEW FILE########
__FILENAME__ = list_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various list editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

import wx.lib.scrolledpanel as wxsp

from traits.api \
    import Str, Any, Instance, Property, Bool, cached_property

from traits.trait_base \
    import user_name_for, enumerate, xgetattr

from traitsui.ui_traits \
    import Image, convert_bitmap

from traitsui.editors.list_editor \
    import ListItemProxy, ToolkitEditorFactory

from traitsui.dockable_view_element \
    import DockableViewElement

from pyface.dock.api \
    import DockWindow, DockSizer, DockSection, DockRegion, DockControl

from constants \
    import scrollbar_dx

from editor \
    import Editor

from menu \
    import MakeMenu

from image_control \
    import ImageControl

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for lists, which displays a scrolling list box
    with only one item visible at a time. A icon next to the list box displays
    a menu of operations on the list.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The kind of editor to create for each list item
    kind = Str

    # Is the list of items being edited mutable?
    mutable = Bool

    # The image used by the editor:
    image = Image( 'list_editor' )

    # The bitmap used by the editor:
    bitmap = Property

    #---------------------------------------------------------------------------
    #  Class constants:
    #---------------------------------------------------------------------------

    # Whether the list is displayed in a single row
    single_row = True

    #---------------------------------------------------------------------------
    #  Normal list item menu:
    #---------------------------------------------------------------------------

    # Menu for modifying the list
    list_menu = """
       Add Before     [_menu_before]: self.add_before()
       Add After      [_menu_after]:  self.add_after()
       ---
       Delete         [_menu_delete]: self.delete_item()
       ---
       Move Up        [_menu_up]:     self.move_up()
       Move Down      [_menu_down]:   self.move_down()
       Move to Top    [_menu_top]:    self.move_top()
       Move to Bottom [_menu_bottom]: self.move_bottom()
    """

    #---------------------------------------------------------------------------
    #  Empty list item menu:
    #---------------------------------------------------------------------------

    empty_list_menu = """
       Add: self.add_empty()
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Initialize the trait handler to use:
        trait_handler = self.factory.trait_handler
        if trait_handler is None:
            trait_handler = self.object.base_trait( self.name ).handler
        self._trait_handler = trait_handler

        # Create a scrolled window to hold all of the list item controls:
        self.control = wxsp.ScrolledPanel( parent, -1 )
        self.control.SetBackgroundColour( parent.GetBackgroundColour() )
        self.control.SetAutoLayout( True )

        # Remember the editor to use for each individual list item:
        editor = self.factory.editor
        if editor is None:
            editor = trait_handler.item_trait.get_editor()
        self._editor = getattr( editor, self.kind )

        # Set up the additional 'list items changed' event handler needed for
        # a list based trait. Note that we want to fire the update_editor_item
        # only when the items in the list change and not when intermediate
        # traits change. Therefore, replace "." by ":" in the extended_name
        # when setting up the listener.
        extended_name = self.extended_name.replace('.', ':')
        self.context_object.on_trait_change( self.update_editor_item,
                               extended_name + '_items?', dispatch = 'ui' )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        extended_name = self.extended_name.replace('.', ':')
        self.context_object.on_trait_change( self.update_editor_item,
                                 extended_name + '_items?', remove = True )
        self._dispose_items()

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Disconnect the editor from any control about to be destroyed:
        self._dispose_items()

        # Get rid of any previous contents:
        list_pane = self.control
        list_pane.SetSizer( None )
        list_pane.DestroyChildren()

        # Create all of the list item trait editors:
        trait_handler = self._trait_handler
        resizable     = ((trait_handler.minlen != trait_handler.maxlen) and
                         self.mutable)
        item_trait    = trait_handler.item_trait
        factory       = self.factory
        list_sizer    = wx.FlexGridSizer(
                            len(self.value), (1 + resizable) * factory.columns, 0, 0 )
        j = resizable
        for i in range( factory.columns ):
            list_sizer.AddGrowableCol( j )
            j += (1 + resizable)

        values        = self.value
        index         = 0
        width, height = 0, 0

        is_fake = (resizable and (values is None or len( values ) == 0))
        if is_fake:
            values = [ item_trait.default_value()[1] ]

        panel_height = 0
        editor = self._editor
        for value in values:
            width1 = height = 0
            if resizable:
                control = ImageControl( list_pane, self.bitmap, -1,
                                        self.popup_menu )
                width1, height = control.GetSize()
                width1 += 4

            try:
                proxy = ListItemProxy( self.object, self.name, index,
                                       item_trait, value )
                if resizable:
                    control.proxy = proxy
                peditor = editor( self.ui, proxy, 'value', self.description,
                                  list_pane ).set( object_name = '' )
                peditor.prepare( list_pane )
                pcontrol = peditor.control
                pcontrol.proxy = proxy
            except:
                if not is_fake:
                    raise

                pcontrol = wx.Button( list_pane, -1, 'sample' )

            pcontrol.Fit()
            width2, height2 = size = pcontrol.GetSize()
            pcontrol.SetMinSize( size )
            width  = max( width, width1 + width2 )
            height = max( height, height2 )
            panel_height += height

            if resizable:
                list_sizer.Add( control, 0, wx.LEFT | wx.RIGHT, 2 )

            list_sizer.Add( pcontrol, 0, wx.EXPAND )
            index += 1

        list_pane.SetSizer( list_sizer )

        if not self.mutable:
            #list_sizer.SetDimension(0,0,width, panel_height)
            list_pane.SetInitialSize(list_sizer.GetSize())

        if is_fake:
            self._cur_control = control
            self.empty_list()
            control.Destroy()
            pcontrol.Destroy()

        rows = 1
        if not self.single_row:
            rows = self.factory.rows

        # Make sure we have valid values set for width and height (in case there
        # was no data to base them on):
        if width == 0:
            width = 100

        if panel_height == 0:
            panel_height = 20

        list_pane.SetMinSize( wx.Size(
             width + ((trait_handler.maxlen > rows) * scrollbar_dx),
             panel_height) )

        list_pane.SetupScrolling()
        list_pane.GetParent().Layout()

    #---------------------------------------------------------------------------
    #  Updates the editor when an item in the object trait changes external to
    #  the editor:
    #---------------------------------------------------------------------------

    def update_editor_item ( self, obj, name, event ):
        """ Updates the editor when an item in the object trait changes
        externally to the editor.
        """
        # If this is not a simple, single item update, rebuild entire editor:
        if (len( event.removed ) != 1) or (len( event.added ) != 1):
            self.update_editor()
            return

        # Otherwise, find the proxy for this index and update it with the
        # changed value:
        for control in self.control.GetChildren():
            proxy = control.proxy
            if proxy.index == event.index:
                proxy.value = event.added[0]
                break

    #---------------------------------------------------------------------------
    #  Creates an empty list entry (so the user can add a new item):
    #---------------------------------------------------------------------------

    def empty_list ( self ):
        """ Creates an empty list entry (so the user can add a new item).
        """
        control = ImageControl( self.control, self.bitmap, -1,
                                self.popup_empty_menu )
        control.is_empty = True
        proxy    = ListItemProxy( self.object, self.name, -1, None, None )
        pcontrol = wx.StaticText( self.control, -1, '   (Empty List)' )
        pcontrol.proxy = control.proxy = proxy
        self.reload_sizer( [ ( control, pcontrol ) ] )

    #---------------------------------------------------------------------------
    #  Reloads the layout from the specified list of ( button, proxy ) pairs:
    #---------------------------------------------------------------------------

    def reload_sizer ( self, controls, extra = 0 ):
        """ Reloads the layout from the specified list of ( button, proxy )
            pairs.
        """
        sizer = self.control.GetSizer()
        for i in xrange( 2 * len( controls ) + extra ):
            sizer.Remove( 0 )
        index = 0
        for control, pcontrol in controls:
            sizer.Add( control,  0, wx.LEFT | wx.RIGHT, 2 )
            sizer.Add( pcontrol, 1, wx.EXPAND )
            control.proxy.index = index
            index += 1
        sizer.Layout()
        self.control.SetVirtualSize( sizer.GetMinSize() )

    #---------------------------------------------------------------------------
    #  Returns the associated object list and current item index:
    #---------------------------------------------------------------------------

    def get_info ( self ):
        """ Returns the associated object list and current item index.
        """
        proxy = self._cur_control.proxy
        return ( proxy.list, proxy.index )

    #---------------------------------------------------------------------------
    #  Displays the empty list editor popup menu:
    #---------------------------------------------------------------------------

    def popup_empty_menu ( self, control ):
        """ Displays the empty list editor popup menu.
        """
        self._cur_control = control
        menu = MakeMenu( self.empty_list_menu, self, True, self.control ).menu
        self.control.PopupMenu( menu, control.GetPosition() )
        menu.Destroy()

    #---------------------------------------------------------------------------
    #  Displays the list editor popup menu:
    #---------------------------------------------------------------------------

    def popup_menu ( self, control ):
        """ Displays the list editor popup menu.
        """
        self._cur_control = control
        # Makes sure that any text that was entered get's added (Pressure #145):
        control.SetFocus()
        proxy    = control.proxy
        index    = proxy.index
        menu     = MakeMenu( self.list_menu, self, True, self.control ).menu
        len_list = len( proxy.list )
        not_full = (len_list < self._trait_handler.maxlen)
        self._menu_before.enabled( not_full )
        self._menu_after.enabled(  not_full )
        self._menu_delete.enabled( len_list > self._trait_handler.minlen )
        self._menu_up.enabled(  index > 0 )
        self._menu_top.enabled( index > 0 )
        self._menu_down.enabled(   index < (len_list - 1) )
        self._menu_bottom.enabled( index < (len_list - 1) )
        self.control.PopupMenu( menu, control.GetPosition() )
        menu.Destroy()

    #---------------------------------------------------------------------------
    #  Adds a new value at the specified list index:
    #---------------------------------------------------------------------------

    def add_item ( self, offset ):
        """ Adds a new value at the specified list index.
        """
        list, index = self.get_info()
        index      += offset
        item_trait  = self._trait_handler.item_trait
        value       = item_trait.default_value_for( self.object, self.name )
        self.value  = list[:index] + [ value ] + list[index:]
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Inserts a new item before the current item:
    #---------------------------------------------------------------------------

    def add_before ( self ):
        """ Inserts a new item before the current item.
        """
        self.add_item( 0 )

    #---------------------------------------------------------------------------
    #  Inserts a new item after the current item:
    #---------------------------------------------------------------------------

    def add_after ( self ):
        """ Inserts a new item after the current item.
        """
        self.add_item( 1 )

    #---------------------------------------------------------------------------
    #  Adds a new item when the list is empty:
    #---------------------------------------------------------------------------

    def add_empty ( self ):
        """ Adds a new item when the list is empty.
        """
        list, index = self.get_info()
        self.add_item( 0 )

    #---------------------------------------------------------------------------
    #  Delete the current item:
    #---------------------------------------------------------------------------

    def delete_item ( self ):
        """ Delete the current item.
        """
        list, index = self.get_info()
        self.value  = list[:index] + list[index+1:]
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Move the current item up one in the list:
    #---------------------------------------------------------------------------

    def move_up ( self ):
        """ Move the current item up one in the list.
        """
        list, index = self.get_info()
        self.value  = (list[:index-1] + [ list[index], list[index-1] ] +
                       list[index+1:])
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Moves the current item down one in the list:
    #---------------------------------------------------------------------------

    def move_down ( self ):
        """ Moves the current item down one in the list.
        """
        list, index = self.get_info()
        self.value  = (list[:index] + [ list[index+1], list[index] ] +
                       list[index+2:])
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Moves the current item to the top of the list:
    #---------------------------------------------------------------------------

    def move_top ( self ):
        """ Moves the current item to the top of the list.
        """
        list, index = self.get_info()
        self.value  = [ list[index] ] + list[:index] + list[index+1:]
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Moves the current item to the bottom of the list:
    #---------------------------------------------------------------------------

    def move_bottom ( self ):
        """ Moves the current item to the bottom of the list.
        """
        list, index = self.get_info()
        self.value  = list[:index] + list[index+1:] + [ list[index] ]
        self.update_editor()

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_bitmap ( self ):
        return convert_bitmap( self.image )

    #-- Private Methods --------------------------------------------------------

    def _dispose_items ( self ):
        """ Disposes of each current list item.
        """
        for control in self.control.GetChildren():
            editor = getattr( control, '_editor', None )
            if editor is not None:
                editor.dispose()
                editor.control = None

    #-- Trait initializers ----------------------------------------------------

    def _kind_default(self):
        """ Returns a default value for the 'kind' trait.
        """
        return self.factory.style + '_editor'

    def _mutable_default(self):
        """ Trait handler to set the mutable trait from the factory. """
        return self.factory.mutable

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of editor for lists, which displays the items as a series
    of text fields. If the list is editable, an icon next to each item displays
    a menu of operations on the list.
    """

    #---------------------------------------------------------------------------
    #  Class constants:
    #---------------------------------------------------------------------------

    # Whether the list is displayed in a single row. This value overrides the
    # default.
    single_row = False

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the list editor is scrollable? This values overrides the default.
    scrollable = True


#-------------------------------------------------------------------------------
#  'TextEditor' class:
#-------------------------------------------------------------------------------

class TextEditor(CustomEditor):

    # The kind of editor to create for each list item. This value overrides the
    # default.
    kind = 'text_editor'

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor(CustomEditor):

    # Is the list of items being edited mutable? This value overrides the
    # default.
    mutable = False

#-------------------------------------------------------------------------------
#  'NotebookEditor' class:
#-------------------------------------------------------------------------------

class NotebookEditor ( Editor ):
    """ An editor for lists that displays the list as a "notebook" of tabbed
        pages.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the notebook editor scrollable? This values overrides the default:
    scrollable = True

    # The currently selected notebook page object:
    selected = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._uis = []

        # Create a DockWindow to hold each separate object's view:
        theme = self.factory.dock_theme or self.item.container.dock_theme
        dw    = DockWindow( parent, theme = theme )
        self.control = dw.control
        self._sizer  = DockSizer( DockSection( dock_window = dw ) )
        self.control.SetSizer( self._sizer )

        # Set up the additional 'list items changed' event handler needed for
        # a list based trait:
        self.context_object.on_trait_change( self.update_editor_item,
                               self.extended_name + '_items?', dispatch = 'ui' )

        # Set of selection synchronization:
        self.sync_value( self.factory.selected, 'selected' )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Make sure the DockWindow is in a correct state:
        self._sizer.Reset( self. control )

        # Destroy the views on each current notebook page:
        self.close_all()

        # Create a DockControl for each object in the trait's value:
        uis           = self._uis
        dock_controls = []
        for object in self.value:
            dock_control, view_object, monitoring = self._create_page( object )
            # Remember the DockControl for later deletion processing:
            uis.append( [ dock_control, object, view_object, monitoring ] )
            dock_controls.append( dock_control )

        # Add the new items to the DockWindow:
        self.add_controls( dock_controls )

        if self.ui.info.initialized:
            self.update_layout()

    #---------------------------------------------------------------------------
    #  Handles some subset of the trait's list being updated:
    #---------------------------------------------------------------------------

    def update_editor_item ( self, event ):
        """ Handles an update to some subset of the trait's list.
        """
        # Make sure the DockWindow is in a correct state:
        self._sizer.Reset( self.control )

        index = event.index

        # Delete the page corresponding to each removed item:
        layout = ((len( event.removed ) + len( event.added )) <= 1)
        for i in range( len( event.removed ) ):
            dock_control, object, view_object, monitoring = self._uis[ index ]
            if monitoring:
                view_object.on_trait_change( self.update_page_name,
                                             self.factory.page_name[1:],
                                             remove = True )
            dock_control.close( layout = layout, force = True )
            del self._uis[ index ]

        # Add a page for each added object:
        dock_controls = []
        for object in event.added:
            dock_control, view_object, monitoring  = self._create_page( object )
            self._uis[ index: index ] = [ [ dock_control, object, view_object,
                                            monitoring ] ]
            dock_controls.append( dock_control )
            index += 1

        # Add the new items to the DockWindow:
        self.add_controls( dock_controls )

        self.update_layout()

    #---------------------------------------------------------------------------
    #  Closes all currently open notebook pages:
    #---------------------------------------------------------------------------

    def close_all ( self ):
        """ Closes all currently open notebook pages.
        """
        page_name = self.factory.page_name[1:]
        for dock_control, object, view_object, monitoring in self._uis:
            if monitoring:
                view_object.on_trait_change( self.update_page_name, page_name,
                                             remove = True )
            dock_control.close( layout = False, force = True )

        # Reset the list of ui's and dictionary of page name counts:
        self._uis   = []
        self._pages = {}

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self.context_object.on_trait_change( self.update_editor_item,
                                self.name + '_items?', remove = True )
        self.close_all()

        super( NotebookEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Adds a group of new DockControls to the view:
    #---------------------------------------------------------------------------

    def add_controls ( self, controls ):
        """ Adds a group of new DockControls to the view.
        """
        if len( controls ) > 0:
            section = self.control.GetSizer().GetContents()
            if ((len( section.contents ) == 0) or
                (not isinstance( section.contents[-1], DockRegion ))):
                section.contents.append( DockRegion( contents = controls ) )
            else:
                for control in controls:
                    section.contents[-1].add(control, activate=False)
            # Fire this event to activate the dock control corresponding
            # to the selected object, if any.
            self._selected_changed(None, self.selected)

    #---------------------------------------------------------------------------
    #  Updates the layout of the DockWindow:
    #---------------------------------------------------------------------------

    def update_layout ( self ):
        """ Updates the layout of the DockWindow.
        """
        self.control.Layout()
        self.control.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the trait defining a particular page's name being changed:
    #---------------------------------------------------------------------------

    def update_page_name ( self ):
        """ Handles the trait defining a particular page's name being changed.
        """
        changed = False
        for i, value in enumerate( self._uis ):
            dock_control, user_object, view_object, monitoring = value
            if dock_control.control is not None:
                name    = None
                handler = getattr( self.ui.handler, '%s_%s_page_name' %
                                   ( self.object_name, self.name ), None )
                if handler is not None:
                    name = handler( self.ui.info, user_object )

                if name is None:
                    name = unicode( xgetattr( view_object,
                                          self.factory.page_name[1:], u'???' ) )

                changed |= (dock_control.name != name)
                dock_control.name = name

        if changed:
            self.update_layout()

    #---------------------------------------------------------------------------
    #  Creates a DockControl for a specified object:
    #---------------------------------------------------------------------------

    def _create_page ( self, object ):
        """ Creates a DockControl for a specified object.
        """
        # Create the view for the object:
        view_object = object
        factory     = self.factory
        if factory.factory is not None:
            view_object = factory.factory( object )

        ui = view_object.edit_traits( parent = self.control,
                                      view   = factory.view,
                                      kind   = factory.ui_kind ).set(
                                      parent = self.ui )

        # Get the name of the page being added to the notebook:
        name       = ''
        monitoring = False
        prefix     = '%s_%s_page_' % ( self.object_name, self.name )
        page_name  = self.factory.page_name
        if page_name[0:1] == '.':
            name       = xgetattr( view_object, page_name[1:], None )
            monitoring = (name is not None)
            if monitoring:
                handler_name = None
                method       = getattr( self.ui.handler, prefix + 'name', None )
                if method is not None:
                    handler_name = method( self.ui.info, object )
                if handler_name is not None:
                    name = handler_name
                else:
                    name = unicode( name ) or u'???'
                view_object.on_trait_change( self.update_page_name,
                                             page_name[1:], dispatch = 'ui' )
            else:
                name = ''
        elif page_name != '':
            name = page_name

        if name == '':
            name = user_name_for( view_object.__class__.__name__ )

        # Make sure the name is not a duplicate:
        if not monitoring:
            self._pages[ name ] = count = self._pages.get( name, 0 ) + 1
            if count > 1:
                name += (' %d' % count)

        # Return a new DockControl for the ui, and whether or not its name is
        # being monitored:
        image   = None
        method  = getattr( self.ui.handler, prefix + 'image', None )
        if method is not None:
            image = method( self.ui.info, object )
        dock_control = DockControl( control   = ui.control,
                                    id        = str( id( ui.control ) ),
                                    name      = name,
                                    style     = factory.dock_style,
                                    image     = image,
                                    export    = factory.export,
                                    closeable = factory.deletable,
                                    dockable  = DockableListElement(
                                                    ui     = ui,
                                                    editor = self ) )
        return ( dock_control, view_object, monitoring )

    #---------------------------------------------------------------------------
    #  Activates the corresponding dock window when the 'selected' trait of
    #  the editor is changed.
    #---------------------------------------------------------------------------
    def _selected_changed(self, old, new):
        """ Activates the corresponding dock window when the 'selected' trait
        of the editor is changed.
        """
        for i, value in enumerate(self._uis):
            if new == value[1]:
                value[0].activate()
                break
        return

#-------------------------------------------------------------------------------
#  'DockableListElement' class:
#-------------------------------------------------------------------------------

class DockableListElement ( DockableViewElement ):

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The editor this dockable item is associated with:
    editor = Instance( NotebookEditor )

    #---------------------------------------------------------------------------
    #  Returns whether or not it is OK to close the control, and if it is OK,
    #  then it closes the DockControl itself:
    #---------------------------------------------------------------------------

    def dockable_close ( self, dock_control, force ):
        """ Returns whether it is OK to close the control.
        """
        return self.close_dock_control( dock_control, force )

    #---------------------------------------------------------------------------
    #  Closes a DockControl:
    #---------------------------------------------------------------------------

    def close_dock_control ( self, dock_control, abort ):
        """ Closes a DockControl.
        """
        if abort:
            return super( DockableListElement, self ).close_dock_control(
                                                           dock_control, False )

        view_object = self.ui.context[ 'object' ]
        for i, value in enumerate( self.editor._uis ):
            if view_object is value[2]:
                del self.editor.value[ i ]

        return False

    #---------------------------------------------------------------------------
    #  Handles a notebook tab being activated or deactivated.
    #---------------------------------------------------------------------------

    def dockable_tab_activated ( self, dock_control, activated ):
        """ Handles a notebook tab being activated or deactivated.
        Sets the value of the editor's selected trait to the activated
        dock_control's object.

        """
        for i, value in enumerate( self.editor._uis ):
            if dock_control is value[0] and activated:
                self.editor.selected = value[1]
                break

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = list_str_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007-13, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   05/08/2007
#
#-------------------------------------------------------------------------------

""" Traits UI editor for editing lists of strings.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Str, Int, List, Bool, Instance, Any, Event, TraitListEvent, \
           Property

# FIXME: ListStrEditor is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.list_editor file.
from traitsui.editors.list_str_editor \
    import ListStrEditor

from traitsui.list_str_adapter \
    import ListStrAdapter

from traitsui.wx.editor \
    import Editor

from pyface.image_resource \
    import ImageResource

from helper \
    import disconnect, disconnect_no_id

try:
    from pyface.wx.drag_and_drop \
        import PythonDropSource, PythonDropTarget
except:
    PythonDropSource = PythonDropTarget = None

#-------------------------------------------------------------------------------
#  'wxListCtrl' class:
#-------------------------------------------------------------------------------

class wxListCtrl ( wx.ListCtrl ):
    """ Subclass of wx.ListCtrl to provide correct virtual list behavior.
    """

    def OnGetItemAttr ( self, index ):
        """ Returns the display attributes to use for the specified list item.
        """
        # fixme: There appears to be a bug in wx in that they do not correctly
        # manage the reference count for the returned object, and it seems to be
        # gc'ed before they finish using it. So we store an object reference to
        # it to prevent it from going away too soon...
        self._attr = attr = wx.ListItemAttr()
        editor     = self._editor
        adapter    = editor.adapter

        if editor._is_auto_add( index ):
            bg_color = adapter.get_default_bg_color( editor.object,
                                                     editor.name )
            color = adapter.get_default_text_color( editor.object, editor.name )
        else:
            bg_color = adapter.get_bg_color( editor.object, editor.name, index )
            color  = adapter.get_text_color( editor.object, editor.name, index )

        if bg_color is not None:
            attr.SetBackgroundColour( bg_color )

        if color is not None:
            attr.SetTextColour( color )

        return attr

    def OnGetItemImage ( self, index ):
        """ Returns the image index to use for the specified list item.
        """
        editor = self._editor
        if editor._is_auto_add( index ):
            image = editor.adapter.get_default_image( editor.object,
                                                      editor.name )
        else:
            image = editor.adapter.get_image( editor.object, editor.name,
                                              index )

        image = editor._get_image( image )
        if image is not None:
            return image

        return -1

    def OnGetItemText ( self, index, column ):
        """ Returns the text to use for the specified list item.
        """
        editor = self._editor

        if editor._is_auto_add( index ):
            return editor.adapter.get_default_text( editor.object, editor.name )

        return editor.adapter.get_text( editor.object, editor.name, index )

#-------------------------------------------------------------------------------
#  '_ListStrEditor' class:
#-------------------------------------------------------------------------------

class _ListStrEditor ( Editor ):
    """ Traits UI editor for editing lists of strings.
    """

    #-- Trait Definitions ------------------------------------------------------

    # The title of the editor:
    title = Str

    # The current set of selected items (which one is used depends upon the
    # initial state of the editor factory 'multi_select' trait):
    selected       = Any
    multi_selected = List

    # The current set of selected item indices (which one is used depends upon
    # the initial state of the editor factory 'multi_select' trait):
    selected_index         = Int
    multi_selected_indices = List( Int )

    # The most recently actived item and its index:
    activated       = Any
    activated_index = Int

    # The most recently right_clicked item and its index:
    right_clicked       = Event
    right_clicked_index = Event

    # Is the list editor scrollable? This value overrides the default.
    scrollable = True

    # Index of item to select after rebuilding editor list:
    index = Any

    # Should the selected item be edited after rebuilding the editor list:
    edit = Bool( False )

    # The adapter from list items to editor values:
    adapter = Instance( ListStrAdapter )

    # Dictionaly mapping image names to wx.ImageList indices:
    images = Any( {} )

    # Dictionary mapping ImageResource objects to wx.ImageList indices:
    image_resources = Any( {} )

    # The current number of item currently in the list:
    item_count = Property

    # The current search string:
    search = Str

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        # Set up the adapter to use:
        self.adapter = factory.adapter
        self.sync_value( factory.adapter_name, 'adapter', 'from' )

        # Determine the style to use for the list control:
        style = wx.LC_REPORT | wx.LC_VIRTUAL

        if factory.editable:
            style |= wx.LC_EDIT_LABELS

        if factory.horizontal_lines:
            style |= wx.LC_HRULES

        if not factory.multi_select:
            style |= wx.LC_SINGLE_SEL

        if (factory.title == '') and (factory.title_name == ''):
            style |= wx.LC_NO_HEADER

        # Create the list control and link it back to us:
        self.control    = control = wxListCtrl( parent, -1, style = style )
        control._editor = self

        # Create the list control column:
        control.InsertColumn( 0, '' )

        # Set up the list control's event handlers:
        id = control.GetId()
        wx.EVT_LIST_BEGIN_DRAG(       parent, id, self._begin_drag )
        wx.EVT_LIST_BEGIN_LABEL_EDIT( parent, id, self._begin_label_edit )
        wx.EVT_LIST_END_LABEL_EDIT(   parent, id, self._end_label_edit )
        wx.EVT_LIST_ITEM_SELECTED(    parent, id, self._item_selected )
        wx.EVT_LIST_ITEM_DESELECTED(  parent, id, self._item_selected )
        wx.EVT_LIST_ITEM_RIGHT_CLICK( parent, id, self._right_clicked )
        wx.EVT_LIST_ITEM_ACTIVATED(   parent, id, self._item_activated )
        wx.EVT_SIZE(                  control, self._size_modified )

        # Handle key events:
        wx.EVT_CHAR( control, self._key_pressed )

        # Handle mouse events:
        if 'edit' in factory.operations:
            wx.EVT_LEFT_DOWN( control, self._left_down )

        # Set up the drag and drop target:
        if PythonDropTarget is not None:
            control.SetDropTarget( PythonDropTarget( self ) )

        # Initialize the editor title:
        self.title = factory.title
        self.sync_value( factory.title_name, 'title', 'from' )

        # Set up the selection listener (if necessary):
        if factory.multi_select:
            self.sync_value( factory.selected, 'multi_selected', 'both',
                             is_list = True )
            self.sync_value( factory.selected_index, 'multi_selected_indices',
                             'both', is_list = True )
        else:
            self.sync_value( factory.selected, 'selected', 'both' )
            self.sync_value( factory.selected_index, 'selected_index', 'both' )

        # Synchronize other interesting traits as necessary:
        self.sync_value( factory.activated, 'activated', 'to' )
        self.sync_value( factory.activated_index, 'activated_index', 'to' )

        self.sync_value( factory.right_clicked, 'right_clicked', 'to' )
        self.sync_value( factory.right_clicked_index, 'right_clicked_index',
                         'to' )

        # Make sure we listen for 'items' changes as well as complete list
        # replacements:
        self.context_object.on_trait_change( self.update_editor,
                                self.extended_name + '_items', dispatch = 'ui' )

        # Create the mapping from user supplied images to wx.ImageList indices:
        for image_resource in factory.images:
            self._add_image( image_resource )

        # Refresh the editor whenever the adapter changes:
        self.on_trait_change( self._refresh, 'adapter.+update',
                              dispatch = 'ui' )

        # Set the list control's tooltip:
        self.set_tooltip()

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        disconnect( self.control, wx.EVT_LIST_BEGIN_DRAG,
            wx.EVT_LIST_BEGIN_LABEL_EDIT, wx.EVT_LIST_END_LABEL_EDIT,
            wx.EVT_LIST_ITEM_SELECTED,    wx.EVT_LIST_ITEM_DESELECTED,
            wx.EVT_LIST_ITEM_RIGHT_CLICK, wx.EVT_LIST_ITEM_ACTIVATED )

        disconnect_no_id( self.control,
                          wx.EVT_SIZE, wx.EVT_CHAR, wx.EVT_LEFT_DOWN )

        self.context_object.on_trait_change( self.update_editor,
                                  self.extended_name + '_items', remove = True )
        self.on_trait_change( self._refresh, 'adapter.+update', remove = True )

        super( _ListStrEditor, self ).dispose()

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        control = self.control
        top     = control.GetTopItem()
        pn      = control.GetCountPerPage()
        n       = self.adapter.len( self.object, self.name )
        if self.factory.auto_add:
            n += 1

        control.DeleteAllItems()
        control.SetItemCount( n )
        if control.GetItemCount() > 0:
            control.RefreshItems( 0, control.GetItemCount()-1 )
        control.SetColumnWidth( 0, control.GetClientSizeTuple()[0]  )

        edit,  self.edit  = self.edit,  False
        index, self.index = self.index, None

        if index is not None:
            if index >= n:
                index -= 1
                if index < 0:
                    index = None

        if index is None:
            visible = top + pn - 2
            if visible >= 0 and visible < control.GetItemCount():
                control.EnsureVisible( visible )
            if self.factory.multi_select:
                for index in self.multi_selected_indices:
                    if 0 <= index < n:
                        control.SetItemState( index, wx.LIST_STATE_SELECTED,
                                                    wx.LIST_STATE_SELECTED )
            else:
                if 0 <= self.selected_index < n:
                    control.SetItemState( self.selected_index,
                        wx.LIST_STATE_SELECTED, wx.LIST_STATE_SELECTED )
            return

        if 0 <= (index - top) < pn:
            control.EnsureVisible( max(0, top + pn - 2 ) )
        elif index < top:
            control.EnsureVisible( min(n, index + pn - 1 ) )
        else:
            control.EnsureVisible( index )

        control.SetItemState( index,
            wx.LIST_STATE_SELECTED | wx.LIST_STATE_FOCUSED,
            wx.LIST_STATE_SELECTED | wx.LIST_STATE_FOCUSED  )

        if edit:
            control.EditLabel( index )

    #-- Property Implementations -----------------------------------------------

    def _get_item_count ( self ):
        return (self.control.GetItemCount() - self.factory.auto_add)

    #-- Trait Event Handlers ---------------------------------------------------

    def _title_changed ( self, title ):
        """ Handles the editor title being changed.
        """
        list_item = wx.ListItem()
        list_item.SetText( title )
        self.control.SetColumn( 0, list_item )

    def _selected_changed ( self, selected ):
        """ Handles the editor's 'selected' trait being changed.
        """
        if not self._no_update:
            try:
                self.control.SetItemState( self.value.index( selected ),
                                wx.LIST_STATE_SELECTED, wx.LIST_STATE_SELECTED )
            except Exception:
                pass

    def _selected_index_changed ( self, selected_index ):
        """ Handles the editor's 'selected_index' trait being changed.
        """
        if not self._no_update:
            try:
                self.control.SetItemState( selected_index, wx.LIST_STATE_SELECTED,
                                                       wx.LIST_STATE_SELECTED )
            except Exception:
                pass

    def _multi_selected_changed ( self, selected ):
        """ Handles the editor's 'multi_selected' trait being changed.
        """
        if not self._no_update:
            values = self.value
            try:
                self._multi_selected_indices_changed( [ values.index( item )
                                                        for item in selected ] )
            except Exception:
                pass

    def _multi_selected_items_changed ( self, event ):
        """ Handles the editor's 'multi_selected' trait being modified.
        """
        values = self.values
        try:
            self._multi_selected_indices_items_changed( TraitListEvent( 0,
                [ values.index( item ) for item in event.removed ],
                [ values.index( item ) for item in event.added   ] ) )
        except Exception:
            pass

    def _multi_selected_indices_changed ( self, selected_indices ):
        """ Handles the editor's 'multi_selected_indices' trait being changed.
        """
        if not self._no_update:
            control  = self.control
            selected = self._get_selected()

            # Select any new items that aren't already selected:
            for index in selected_indices:
                if index in selected:
                    selected.remove( index )
                else:
                    try:
                        control.SetItemState( index, wx.LIST_STATE_SELECTED,
                                                    wx.LIST_STATE_SELECTED )
                    except Exception:
                        pass

            # Unselect all remaining selected items that aren't selected now:
            for index in selected:
                control.SetItemState( index, 0, wx.LIST_STATE_SELECTED )

    def _multi_selected_indices_items_changed ( self, event ):
        """ Handles the editor's 'multi_selected_indices' trait being modified.
        """
        control = self.control

        # Remove all items that are no longer selected:
        for index in event.removed:
            control.SetItemState( index, 0, wx.LIST_STATE_SELECTED )

        # Select all newly added items:
        for index in event.added:
            control.SetItemState( index, wx.LIST_STATE_SELECTED,
                                         wx.LIST_STATE_SELECTED )

    #-- List Control Event Handlers --------------------------------------------

    def _begin_drag ( self, event ):
        """ Handles the user beginning a drag operation with the left mouse
            button.
        """
        if PythonDropSource is not None:
            adapter      = self.adapter
            object, name = self.object, self.name
            index        = event.GetIndex()
            selected     = self._get_selected()
            drag_items   = []

            # Collect all of the selected items to drag:
            for index in selected:
                drag = adapter.get_drag( object, name, index )
                if drag is None:
                    return

                drag_items.append( drag )

            # Save the drag item indices, so that we can later handle a
            # completed 'move' operation:
            self._drag_indices = selected

            try:
                # If only one item is being dragged, drag it as an item, not a
                # list:
                if len( drag_items ) == 1:
                    drag_items = drag_items[0]

                # Perform the drag and drop operation:
                ds = PythonDropSource( self.control, drag_items )

                # If moves are allowed and the result was a drag move:
                if ((ds.result == wx.DragMove) and
                    (self._drag_local or self.factory.drag_move)):
                    # Then delete all of the original items (in reverse order
                    # from highest to lowest, so the indices don't need to be
                    # adjusted):
                    indices = self._drag_indices
                    indices.reverse()
                    for index in indices:
                        adapter.delete( object, name, index )
            finally:
                self._drag_indices = None
                self._drag_local   = False

    def _begin_label_edit ( self, event ):
        """ Handles the user starting to edit an item label.
        """
        index = event.GetIndex()

        if ((not self._is_auto_add( index )) and
            (not self.adapter.get_can_edit( self.object, self.name, index ))):
            event.Veto()

    def _end_label_edit ( self, event ):
        """ Handles the user finishing editing an item label.
        """
        self._set_text_current( event.GetIndex(), event.GetText() )

    def _item_selected ( self, event ):
        """ Handles an item being selected.
        """
        self._no_update = True
        try:
            get_item         = self.adapter.get_item
            object, name     = self.object, self.name
            selected_indices = self._get_selected()
            if self.factory.multi_select:
                self.multi_selected_indices = selected_indices
                self.multi_selected = [ get_item( object, name, index )
                                        for index in selected_indices]
            elif len( selected_indices ) == 0:
                self.selected_index = -1
                self.selected       = None
            else:
                self.selected_index = selected_indices[0]
                self.selected       = get_item( object, name,
                                                selected_indices[0] )
        finally:
            self._no_update = False

    def _item_activated ( self, event ):
        """ Handles an item being activated (double-clicked or enter pressed).
        """
        self.activated_index = event.GetIndex()
        if 'edit' in self.factory.operations:
            self._edit_current()
        else:
            self.activated = self.adapter.get_item( self.object, self.name,
                                                    self.activated_index )

    def _right_clicked ( self, event ):
        """ Handles an item being right clicked.
        """
        self.right_clicked_index = index = event.GetIndex()
        self.right_clicked = self.adapter.get_item( self.object, self.name,
                                                    index )

    def _key_pressed ( self, event ):
        key     = event.GetKeyCode()
        control = event.ControlDown()

        if 32 <= key <= 126:
            self.search += chr( key ).lower()
            self._search_for_string()
        elif key in ( wx.WXK_HOME, wx.WXK_PAGEUP, wx.WXK_PAGEDOWN ):
            self.search = ''
            event.Skip()
        elif key == wx.WXK_END:
            self.search = ''
            self._append_new()
        elif (key == wx.WXK_UP) and control:
            self._search_for_string( -1 )
        elif (key == wx.WXK_DOWN) and control:
            self._search_for_string( 1 )
        elif key in ( wx.WXK_BACK, wx.WXK_DELETE ):
            self._delete_current()
        elif key == wx.WXK_INSERT:
            self._insert_current()
        elif key == wx.WXK_LEFT:
            self._move_up_current()
        elif key == wx.WXK_RIGHT:
            self._move_down_current()
        elif key == wx.WXK_RETURN:
            self._edit_current()
        elif key == 3:    # Ctrl-C
            self._copy_current()
        elif key == 22:   # Ctrl-V
            self._paste_current()
        elif key == 24:   # Ctrl-X
            self._cut_current()
        else:
            event.Skip()

    def _size_modified ( self, event ):
        """ Handles the size of the list control being changed.
        """
        dx, dy = self.control.GetClientSizeTuple()
        self.control.SetColumnWidth( 0, dx - 1 )
        event.Skip()

    def _left_down ( self, event ):
        """ Handles the user pressing the left mouse button.
        """
        index, flags = self.control.HitTest( wx.Point( event.GetX(),
                                                       event.GetY() ) )
        selected     = self._get_selected()
        if (len( selected ) == 1) and (index == selected[0]):
            self._edit_current()
        else:
            event.Skip()

    #-- Drag and Drop Event Handlers -------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the list control.
        """
        index, flags = self.control.HitTest( wx.Point( x, y ) )

        # If the user dropped it on an empty list, set the target as past the
        # end of the list:
        if ((index == -1) and
            ((flags & wx.LIST_HITTEST_NOWHERE) != 0) and
            (self.control.GetItemCount() == 0)):
            index = 0

        # If we have a valid drop target index, proceed:
        if index != -1:
            if not isinstance( data, list ):
                # Handle the case of just a single item being dropped:
                self._wx_dropped_on( index, data )
            else:
                # Handles the case of a list of items being dropped, being
                # careful to preserve the original order of the source items if
                # possible:
                data.reverse()
                for item in data:
                    self._wx_dropped_on( index, item )

            # If this was an inter-list drag, mark it as 'local':
            if self._drag_indices is not None:
                self._drag_local = True

            # Return a successful drop result:
            return drag_result

        # Indicate we could not process the drop:
        return wx.DragNone

    def _wx_dropped_on ( self, index, item ):
        """ Helper method for handling a single item dropped on the list
            control.
        """
        adapter      = self.adapter
        object, name = self.object, self.name

        # Obtain the destination of the dropped item relative to the target:
        destination = adapter.get_dropped( object, name, index, item )

        # Adjust the target index accordingly:
        if destination == 'after':
            index += 1

        # Insert the dropped item at the requested position:
        adapter.insert( object, name, index, item )

        # If the source for the drag was also this list control, we need to
        # adjust the original source indices to account for their new position
        # after the drag operation:
        indices = self._drag_indices
        if indices is not None:
            for i in range( len( indices ) - 1, -1, -1 ):
                if indices[i] < index:
                    break

                indices[i] += 1

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        if isinstance( data, list ):
            rc = wx.DragNone
            for item in data:
                rc = self.wx_drag_over( x, y, item, drag_result )
                if rc == wx.DragNone:
                    break

            return rc

        index, flags = self.control.HitTest( wx.Point( x, y ) )

        # If the user is dragging over an empty list, set the target to the end
        # of the list:
        if ((index == -1) and
            ((flags & wx.LIST_HITTEST_NOWHERE) != 0) and
            (self.control.GetItemCount() == 0)):
            index = 0

        # If the drag target index is valid and the adapter says it is OK to
        # drop the data here, then indicate the data can be dropped:
        if ((index != -1) and
            self.adapter.get_can_drop( self.object, self.name, index, data )):
            return drag_result

        # Else indicate that we will not accept the data:
        return wx.DragNone

    #-- Private Methods --------------------------------------------------------

    def _refresh ( self ):
        """ Refreshes the contents of the editor's list control.
        """
        self.control.RefreshItems( 0, len( self.value ) - 1 )

    def _add_image ( self, image_resource ):
        """ Adds a new image to the wx.ImageList and its associated mapping.
        """
        bitmap = image_resource.create_image().ConvertToBitmap()

        image_list = self._image_list
        if image_list is None:
            self._image_list = image_list = wx.ImageList( bitmap.GetWidth(),
                                                          bitmap.GetHeight() )
            self.control.AssignImageList( image_list, wx.IMAGE_LIST_SMALL )

        self.image_resources[image_resource] = \
        self.images[ image_resource.name ]   = index = image_list.Add( bitmap )

        return index

    def _get_image ( self, image ):
        """ Converts a user specified image to a wx.ListCtrl image index.
        """
        if isinstance( image, ImageResource ):
            result = self.image_resources.get( image )
            if result is not None:
                return result

            return self._add_image( image )

        return self.images.get( image )

    def _get_selected ( self ):
        """ Returns a list of the indices of all currently selected list items.
        """
        selected = []
        item     = -1
        control  = self.control
        while True:
            item = control.GetNextItem( item, wx.LIST_NEXT_ALL,
                                              wx.LIST_STATE_SELECTED )
            if item == -1:
                break;

            selected.append( item )

        return selected

    def _search_for_string ( self, increment = 0 ):
        """ Searches for the next occurrence of the current search string.
        """
        selected = self._get_selected()
        if len( selected ) > 1:
            return

        start = 0
        if len( selected ) == 1:
            start = selected[0] + increment

        get_text = self.adapter.get_text
        search   = self.search
        object   = self.object
        name     = self.name

        if increment >= 0:
            items = xrange( start, self.item_count )
        else:
            items = xrange( start, -1, -1 )

        for index in items:
            if search in get_text( object, name, index ).lower():
                self.index = index
                self.update_editor()
                break

    def _append_new ( self ):
        """ Append a new item to the end of the list control.
        """
        if 'append' in self.factory.operations:
            self.edit = True
            adapter   = self.adapter
            index     = self.control.GetItemCount()
            if self.factory.auto_add:
                self.index = index - 1
                self.update_editor()
            else:
                self.index = index
                adapter.insert( self.object, self.name, self.index,
                           adapter.get_default_value( self.object, self.name ) )

    def _copy_current ( self ):
        """ Copies the currently selected list control item to the clipboard.
        """
        selected = self._get_selected()
        if len( selected ) == 1:
            index = selected[0]
            if index < self.item_count:
                try:
                    from pyface.wx.clipboard import clipboard

                    clipboard.data = self.adapter.get_text( self.object,
                                                            self.name, index )
                except:
                    # Handle the traits.util package not being installed by
                    # just ignoring the request:
                    pass

    def _cut_current ( self ):
        """ Cuts the currently selected list control item and places its value
            in the clipboard.
        """
        ops = self.factory.operations
        if ('insert' in ops) and ('delete' in ops):
            selected = self._get_selected()
            if len( selected ) == 1:
                index = selected[0]
                if index < self.item_count:
                    try:
                        from pyface.wx.clipboard import clipboard

                        clipboard.data = self.adapter.get_text(
                                             self.object, self.name, index )
                        self.index = index
                        self.adapter.delete( self.object, self.name, index )
                    except:
                        # Handle the traits.util package not being installed
                        # by just ignoring the request:
                        pass

    def _paste_current ( self ):
        """ Pastes the clipboard contents into the currently selected list
            control item.
        """
        if 'insert' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                try:
                    from pyface.wx.clipboard import clipboard

                    self._set_text_current( selected[0], clipboard.text_data,
                                            insert = True )
                except:
                    # Handle the traits.util package not being installed by
                    # just ignoring the request:
                    pass

    def _insert_current ( self ):
        """ Inserts a new item after the currently selected list control item.
        """
        if 'insert' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                self.index = selected[0]
                self.edit  = True
                adapter    = self.adapter
                adapter.insert( self.object, self.name, selected[0],
                           adapter.get_default_value( self.object, self.name ) )

    def _delete_current ( self ):
        """ Deletes the currently selected items from the list control.
        """
        if 'delete' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 0:
                return

            n      = self.item_count
            delete = self.adapter.delete
            selected.reverse()
            self.index = selected[-1]
            for index in selected:
                if index < n:
                    delete( self.object, self.name, index )

    def _move_up_current ( self ):
        """ Moves the currently selected item up one line in the list control.
        """
        if 'move' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                index = selected[0]
                n     = self.item_count
                if 0 < index < n:
                    adapter      = self.adapter
                    object, name = self.object, self.name
                    item         = adapter.get_item( object, name, index )
                    adapter.delete( object, name, index )
                    self.index = index - 1
                    adapter.insert( object, name, index - 1, item )

    def _move_down_current ( self ):
        """ Moves the currently selected item down one line in the list control.
        """
        if 'move' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                index = selected[0]
                n     = self.item_count - 1
                if index < n:
                    adapter      = self.adapter
                    object, name = self.object, self.name
                    item         = adapter.get_item( object, name, index )
                    adapter.delete( object, name, index )
                    self.index = index + 1
                    adapter.insert( object, name, index + 1, item )

    def _edit_current ( self ):
        """ Allows the user to edit the current item in the list control.
        """
        if 'edit' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                self.control.EditLabel( selected[0] )

    def _is_auto_add ( self, index ):
        """ Returns whether or not the index is the special 'auto add' item at
            the end of the list.
        """
        return (self.factory.auto_add and
                (index >= self.adapter.len( self.object, self.name )))

    def _set_text_current ( self, index, text, insert = False ):
        """ Sets the text value of the specified list control item.
        """
        if text.strip() != '':
            object, name, adapter = self.object, self.name, self.adapter
            if insert or self._is_auto_add( index ):
                adapter.insert( object, name, index,
                                adapter.get_default_value( object, name ) )
                self.edit = (not insert)

            self.index = index + 1
            adapter.set_text( object, name, index, text )

#--EOF-------------------------------------------------------------------------


########NEW FILE########
__FILENAME__ = menu
#------------------------------------------------------------------------------
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/24/2002
#
#------------------------------------------------------------------------------

""" Dynamically construct wxPython Menus or MenuBars from a supplied string
    description of the menu.

Menu Description Syntax::

    submenu_label {help_string}
        menuitem_label | accelerator {help_string} [~/-name]: code

*submenu_label*
    Label of a sub menu
*menuitem_label*
    Label of a menu item
{*help_string*}
    Help string to display on the status line (optional)
*accelerator*
    Accelerator key (e.g., Ctrl-C) (The '|' and keyname are optional, but must
    be used together.)
[~]
    The menu item is checkable, but is not checked initially (optional)
[/]
    The menu item is checkable, and is checked initially (optional)
[-]
    The menu item disabled initially (optional)
[*name*]
    Symbolic name used to refer to menu item (optional)
*code*
    Python code invoked when menu item is selected

A line beginning with a hyphen (-) is interpreted as a menu separator.
"""

#===============================================================================
#  Imports:
#===============================================================================

import wx
import re
import string

#===============================================================================
#  Constants:
#===============================================================================

help_pat    = re.compile( r'(.*){(.*)}(.*)' )
options_pat = re.compile( r'(.*)\[(.*)\](.*)' )

# Mapping of key name strings to wxPython key codes
key_map = {
    'F1':  wx.WXK_F1,
    'F2':  wx.WXK_F2,
    'F3':  wx.WXK_F3,
    'F4':  wx.WXK_F4,
    'F5':  wx.WXK_F5,
    'F6':  wx.WXK_F6,
    'F7':  wx.WXK_F7,
    'F8':  wx.WXK_F8,
    'F9':  wx.WXK_F9,
    'F10': wx.WXK_F10,
    'F11': wx.WXK_F11,
    'F12': wx.WXK_F12
}

#-------------------------------------------------------------------------------
#  'MakeMenu' class:
#-------------------------------------------------------------------------------

class MakeMenu:
    """ Manages creation of menus.
    """
    # Initialize the globally unique menu ID:
    cur_id = 1000

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, desc, owner, popup = False, window = None ):
        """ Initializes the object.
        """
        self.owner = owner
        if window is None:
            window = owner
        self.window   = window
        self.indirect = getattr( owner, 'call_menu', None )
        self.names    = {}
        self.desc     = desc.split( '\n' )
        self.index    = 0
        self.keys     = []
        if popup:
            self.menu = menu = wx.Menu()
            self.parse( menu, -1 )
        else:
            self.menu = menu = wx.MenuBar()
            self.parse( menu, -1 )
            window.SetMenuBar( menu )
            if len( self.keys ) > 0:
                 window.SetAcceleratorTable( wx.AcceleratorTable( self.keys ) )

    #---------------------------------------------------------------------------
    #  Recursively parses menu items from the description:
    #---------------------------------------------------------------------------

    def parse ( self, menu, indent ):
        """ Recursively parses menu items from the description.
        """

        while True:

            # Make sure we have not reached the end of the menu description yet:
            if self.index >= len( self.desc ):
                return

            # Get the next menu description line and check its indentation:
            dline    = self.desc[ self.index ]
            line     = dline.lstrip()
            indented = len( dline ) - len( line )
            if indented <= indent:
                return

            # Indicate that the current line has been processed:
            self.index += 1

            # Check for a blank or comment line:
            if (line == '') or (line[0:1] == '#'):
                continue

            # Check for a menu separator:
            if line[0:1] == '-':
                menu.AppendSeparator()
                continue

            # Allocate a new menu ID:
            MakeMenu.cur_id += 1
            cur_id = MakeMenu.cur_id

            # Extract the help string (if any):
            help  = ''
            match = help_pat.search( line )
            if match:
                help = ' ' + match.group(2).strip()
                line = match.group(1) + match.group(3)

            # Check for a menu item:
            col = line.find( ':' )
            if col >= 0:
                handler = line[ col + 1: ].strip()
                if handler != '':
                    if self.indirect:
                        self.indirect( cur_id, handler )
                        handler = self.indirect
                    else:
                        try:
                            exec ('def handler(event,self=self.owner):\n %s\n' %
                                  handler)
                        except:
                           handler = null_handler
                else:
                    try:
                        exec 'def handler(event,self=self.owner):\n%s\n' % (
                            self.get_body( indented ), ) in globals()
                    except:
                        handler = null_handler
                wx.EVT_MENU( self.window, cur_id, handler )
                not_checked = checked = disabled = False
                line        = line[ : col ]
                match       = options_pat.search( line )
                if match:
                    line = match.group(1) + match.group(3)
                    not_checked, checked, disabled, name = option_check( '~/-',
                             match.group(2).strip() )
                    if name != '':
                        self.names[ name ] = cur_id
                        setattr( self.owner, name, MakeMenuItem( self, cur_id ) )
                label = line.strip()
                col   = label.find( '|' )
                if col >= 0:
                    key   = label[ col + 1: ].strip()
                    label = '%s%s%s' % ( label[ : col ].strip(), '\t', key )
                    key   = key.upper()
                    flag  = wx.ACCEL_NORMAL
                    col   = key.find( '-' )
                    if col >= 0:
                        flag = { 'CTRL':  wx.ACCEL_CTRL,
                                 'SHIFT': wx.ACCEL_SHIFT,
                                 'ALT':   wx.ACCEL_ALT
                                 }.get( key[ : col ].strip(), wx.ACCEL_CTRL )
                        key  = key[ col + 1: ].strip()
                    code = key_map.get( key, None )
                    try:
                        if code is None:
                            code = ord( key )
                        self.keys.append(
                            wx.AcceleratorEntry( flag, code, cur_id ) )
                    except:
                        pass
                menu.Append( cur_id, label, help, not_checked or checked )
                if checked:
                    menu.Check( cur_id, True )
                if disabled:
                    menu.Enable( cur_id, False )
                continue

            # Else must be the start of a sub menu:
            submenu = wx.Menu()
            label   = line.strip()

            # Recursively parse the sub-menu:
            self.parse( submenu, indented )

            # Add the menu to its parent:
            try:
                menu.AppendMenu( cur_id, label, submenu, help )
            except:
                # Handle the case where 'menu' is really a 'MenuBar' (which does
                # not understand 'MenuAppend'):
                menu.Append( submenu, label )

    #---------------------------------------------------------------------------
    #  Returns the body of an inline method:
    #---------------------------------------------------------------------------

    def get_body ( self, indent ):
        """ Returns the body of an inline method.
        """
        result = []
        while self.index < len( self.desc ):
            line = self.desc[ self.index ]
            if (len( line ) - len( line.lstrip() )) <= indent:
                break
            result.append( line )
            self.index += 1
        result = '\n'.join( result ).rstrip()
        if result != '':
            return result
        return '  pass'

    #---------------------------------------------------------------------------
    #  Returns the id associated with a specified name:
    #---------------------------------------------------------------------------

    def get_id ( self, name ):
        """ Returns the ID associated with a specified name.
        """
        if isinstance(name, basestring):
            return self.names[ name ]
        return name

    #---------------------------------------------------------------------------
    #  Checks (or unchecks) a menu item specified by name:
    #---------------------------------------------------------------------------

    def checked ( self, name, check = None ):
        """ Checks (or unchecks) a menu item specified by name.
        """
        if check is None:
            return self.menu.IsChecked( self.get_id( name ) )
        self.menu.Check( self.get_id( name ), check )

    #---------------------------------------------------------------------------
    #  Enables (or disables) a menu item specified by name:
    #---------------------------------------------------------------------------

    def enabled ( self, name, enable = None ):
        """ Enables (or disables) a menu item specified by name.
        """
        if enable is None:
            return self.menu.IsEnabled( self.get_id( name ) )
        self.menu.Enable( self.get_id( name ), enable )

    #---------------------------------------------------------------------------
    #  Gets/Sets the label for a menu item:
    #---------------------------------------------------------------------------

    def label ( self, name, label = None ):
        """ Gets or sets the label for a menu item.
        """
        if label is None:
            return self.menu.GetLabel( self.get_id( name ) )
        self.menu.SetLabel( self.get_id( name ), label )

#-------------------------------------------------------------------------------
#  'MakeMenuItem' class:
#-------------------------------------------------------------------------------

class MakeMenuItem:
    """ A menu item for a menu managed by MakeMenu.
    """
    def __init__ ( self, menu, id ):
        self.menu = menu
        self.id   = id

    def checked ( self, check = None ):
        return self.menu.checked( self.id, check )

    def toggle ( self ):
        checked = not self.checked()
        self.checked( checked )
        return checked

    def enabled ( self, enable = None ):
        return self.menu.enabled( self.id, enable )

    def label ( self, label = None ):
        return self.menu.label( self.id, label )

#-------------------------------------------------------------------------------
#  Determine whether a string contains any specified option characters, and
#  remove them if it does:
#-------------------------------------------------------------------------------

def option_check ( test, string ):
    """ Determines whether a string contains any specified option characters,
    and removes them if it does.
    """
    result = []
    for char in test:
        col = string.find( char )
        result.append( col >= 0 )
        if col >= 0:
            string = string[ : col ] + string[ col + 1: ]
    return result + [ string.strip() ]

#-------------------------------------------------------------------------------
#  Null menu option selection handler:
#-------------------------------------------------------------------------------

def null_handler ( event ):
    print 'null_handler invoked'


########NEW FILE########
__FILENAME__ = null_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/26/2006
#
#-------------------------------------------------------------------------------

""" Defines a completely empty editor, intended to be used as a spacer.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.null_editor file.
from traitsui.editors.null_editor \
    import NullEditor as ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'NullEditor' class:
#-------------------------------------------------------------------------------

class NullEditor ( Editor ):
    """ A completely empty editor.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = control = wx.Window( parent, -1,
                                            size = wx.Size( 1, 1 ) )
        control.SetBackgroundColour( parent.GetBackgroundColour() )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

########NEW FILE########
__FILENAME__ = popup_editor
#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------


# FIXME: PopupEditor is a proxy class defined here just for backward
# compatibility. The class (which represents the editor factory) has been moved
# to the traitsui.editors.list_editor file.
from traitsui.editors.popup_editor \
    import _PopupEditor as BasePopupEditor, PopupEditor

from ui_editor \
    import UIEditor

#-------------------------------------------------------------------------------
#  '_PopupEditor' class:
#-------------------------------------------------------------------------------

class _PopupEditor ( BasePopupEditor, UIEditor ):
    pass
#--EOF-------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = progress_editor
import wx

from traits.api import Instance
from traitsui.wx.editor import Editor
from pyface.ui.wx.progress_dialog import ProgressDialog

class SimpleEditor(Editor):
    """
    Show a progress bar with all the optional goodies

    """

    progress = Instance(ProgressDialog)

    #-- Editor interface ------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self.control = self.create_control( parent )
        self.set_tooltip()

    def create_control (self, parent):
        """
        Finishes initializing the editor by creating the underlying widget.
        """

        self.progress = ProgressDialog( title=self.factory.title,
                                        message=self.factory.message,
                                        min=self.factory.min,
                                        max=self.factory.max,
                                        can_cancel=self.factory.can_cancel,
                                        show_time=self.factory.show_time,
                                        show_percent=self.factory.show_percent)

        panel = wx.Panel(parent, -1)

        sizer = wx.BoxSizer(wx.VERTICAL)
        panel.SetSizer(sizer)
        panel.SetAutoLayout(True)
        panel.SetBackgroundColour(wx.NullColor)

        self.progress.dialog_size = wx.Size()

        # The 'guts' of the dialog.
        self.progress._create_message(panel, sizer)
        self.progress._create_gauge(panel, sizer)
        self.progress._create_percent(panel, sizer)
        self.progress._create_timer(panel, sizer)
        self.progress._create_buttons(panel, sizer)

        panel.SetClientSize(self.progress.dialog_size)

        panel.CentreOnParent()

        self.control = panel
        return self.control


    def update_editor ( self ):
        """
        Updates the editor when the object trait changes externally to the
        editor.
        """
        if self.value:
            self.progress.update(self.value)
        return

########NEW FILE########
__FILENAME__ = range_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various range editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import sys
import wx

from math \
    import log10

from traits.api \
     import TraitError, Str, Float, Any, Bool

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.range_editor file.
from traitsui.editors.range_editor \
    import ToolkitEditorFactory

from editor_factory \
    import TextEditor

from editor \
    import Editor

from constants \
    import OKColor, ErrorColor

from helper \
    import TraitsUIPanel, Slider

#-------------------------------------------------------------------------------
#  'BaseRangeEditor' class:
#-------------------------------------------------------------------------------

class BaseRangeEditor ( Editor ):
    """ The base class for Range editors. Using an evaluate trait, if specified,
        when assigning numbers the object trait.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function to evaluate floats/ints
    evaluate = Any

    #---------------------------------------------------------------------------
    #  Sets the associated object trait's value:
    #---------------------------------------------------------------------------

    def _set_value ( self, value ):
        if self.evaluate is not None:
            value = self.evaluate( value )
        Editor._set_value( self, value )

#-------------------------------------------------------------------------------
#  'SimpleSliderEditor' class:
#-------------------------------------------------------------------------------

class SimpleSliderEditor ( BaseRangeEditor ):
    """ Simple style of range editor that displays a slider and a text field.

    The user can set a value either by moving the slider or by typing a value
    in the text field.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Low value for the slider range
    low = Any

    # High value for the slider range
    high = Any

    # Formatting string used to format value and labels
    format = Str

    # Flag indicating that the UI is in the process of being updated
    ui_changing = Bool( False )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if not factory.low_name:
            self.low = factory.low

        if not factory.high_name:
            self.high = factory.high

        self.format = factory.format

        self.evaluate = factory.evaluate
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        size        = wx.DefaultSize
        if factory.label_width > 0:
            size = wx.Size( factory.label_width, 20 )

        self.sync_value( factory.low_name,  'low',  'from' )
        self.sync_value( factory.high_name, 'high', 'from' )
        self.control = panel = TraitsUIPanel( parent, -1 )
        sizer  = wx.BoxSizer( wx.HORIZONTAL )
        fvalue = self.value

        if not (self.low <= fvalue <= self.high):
            fvalue_text = ''
            fvalue = self.low
        else:
            try:
                fvalue_text = self.format % fvalue
            except (ValueError, TypeError), e:
                fvalue_text = ''

        ivalue = self._convert_to_slider(fvalue)

        self._label_lo = wx.StaticText( panel, -1, '999999', size = size,
                                style = wx.ALIGN_RIGHT | wx.ST_NO_AUTORESIZE )
        sizer.Add( self._label_lo, 0, wx.ALIGN_CENTER )
        panel.slider = slider = Slider( panel, -1, ivalue, 0, 10000,
                                   size   = wx.Size( 80, 20 ),
                                   style  = wx.SL_HORIZONTAL | wx.SL_AUTOTICKS )
        slider.SetTickFreq( 1000, 1 )
        slider.SetPageSize( 1000 )
        slider.SetLineSize( 100 )
        wx.EVT_SCROLL( slider, self.update_object_on_scroll )
        sizer.Add( slider, 1, wx.EXPAND )
        self._label_hi = wx.StaticText( panel, -1, '999999', size = size )
        sizer.Add( self._label_hi, 0, wx.ALIGN_CENTER )

        panel.text = text = wx.TextCtrl( panel, -1, fvalue_text,
                                         size  = wx.Size( 56, 20 ),
                                         style = wx.TE_PROCESS_ENTER )
        wx.EVT_TEXT_ENTER( panel, text.GetId(), self.update_object_on_enter )
        wx.EVT_KILL_FOCUS( text, self.update_object_on_enter )

        sizer.Add( text, 0, wx.LEFT | wx.EXPAND, 4 )

        low_label = factory.low_label
        if factory.low_name != '':
            low_label = self.format % self.low

        high_label = factory.high_label
        if factory.high_name != '':
            high_label = self.format % self.high

        self._label_lo.SetLabel( low_label )
        self._label_hi.SetLabel( high_label )
        self.set_tooltip( slider )
        self.set_tooltip( self._label_lo )
        self.set_tooltip( self._label_hi )
        self.set_tooltip( text )

        # Set-up the layout:
        panel.SetSizerAndFit( sizer )

    #---------------------------------------------------------------------------
    #  Handles the user changing the current slider value:
    #---------------------------------------------------------------------------

    def update_object_on_scroll ( self, event ):
        """ Handles the user changing the current slider value.
        """
        value = self._convert_from_slider(event.GetPosition())
        event_type = event.GetEventType()
        if ((event_type == wx.wxEVT_SCROLL_ENDSCROLL) or
            (self.factory.auto_set and
             (event_type == wx.wxEVT_SCROLL_THUMBTRACK)) or
            (self.factory.enter_set and
             (event_type == wx.wxEVT_SCROLL_THUMBRELEASE))):
            try:
                self.ui_changing = True
                self.control.text.SetValue( self.format % value )
                self.value = value
            except TraitError:
                pass
            finally:
                self.ui_changing = False

    #---------------------------------------------------------------------------
    #  Handle the user pressing the 'Enter' key in the edit control:
    #---------------------------------------------------------------------------

    def update_object_on_enter ( self, event ):
        """ Handles the user pressing the Enter key in the text field.
        """

        # There are cases where this method is called with self.control == None.
        if self.control is None:
            return

        try:
            try:
                value = self.control.text.GetValue().strip()
                if self.factory.is_float:
                    value = float(value)
                else:
                    value = int(value)
            except Exception, ex:
                # The user entered something that didn't eval as a number (e.g., 'foo').
                # Pretend it didn't happen (i.e. do not change self.value).
                value = self.value
                self.control.text.SetValue( str( value ) )

            self.value = value
            if not self.ui_changing:
                self.control.slider.SetValue(
                     self._convert_to_slider(self.value) )
            self.control.text.SetBackgroundColour(OKColor)
            self.control.text.Refresh()
            if self._error is not None:
                self._error     = None
                self.ui.errors -= 1
        except TraitError:
            pass

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        if self._error is None:
            self._error     = True
            self.ui.errors += 1
            super(SimpleSliderEditor, self).error(excp)
        self.set_error_state( True )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        try:
            text = self.format % value
            1 / (self.low <= value <= self.high)
        except:
            text  = ''
            value = self.low

        ivalue = self._convert_to_slider( value )
        self.control.text.SetValue( text )
        self.control.slider.SetValue( ivalue )

    def _convert_to_slider(self, value):
        """ Returns the slider setting corresponding to the user-supplied value.
        """
        if self.high > self.low:
            ivalue = int( (float( value - self.low ) /
                           (self.high - self.low)) * 10000.0 )
        else:
            ivalue = self.low
        return ivalue

    def _convert_from_slider(self, ivalue):
        """ Returns the float or integer value corresponding to the slider
        setting.
        """
        value = self.low + ((float( ivalue ) / 10000.0) *
                            (self.high - self.low))
        if not self.factory.is_float:
            value = int(round(value))
        return value

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.control.text

    #---------------------------------------------------------------------------
    #  Handles the 'low'/'high' traits being changed:
    #---------------------------------------------------------------------------

    def _low_changed ( self, low ):
        if self.value < low:
            if self.factory.is_float:
                self.value = float( low )
            else:
                self.value = int( low )

        if self._label_lo is not None:
            self._label_lo.SetLabel( self.format % low  )
            self.update_editor()

    def _high_changed ( self, high ):
        if self.value > high:
            if self.factory.is_float:
                self.value = float( high )
            else:
                self.value = int( high )

        if self._label_hi is not None:
            self._label_hi.SetLabel( self.format % high  )
            self.update_editor()


#-------------------------------------------------------------------------------
class LogRangeSliderEditor ( SimpleSliderEditor ):
#-------------------------------------------------------------------------------
    """ A slider editor for log-spaced values
    """

    def _convert_to_slider(self, value):
        """ Returns the slider setting corresponding to the user-supplied value.
        """
        value = max(value, self.low)
        ivalue = int( (log10(value) - log10(self.low)) /
                      (log10(self.high) - log10(self.low)) * 10000.0)
        return ivalue

    def _convert_from_slider(self, ivalue):
        """ Returns the float or integer value corresponding to the slider
        setting.
        """
        value = float( ivalue ) / 10000.0 * (log10(self.high) -log10(self.low))
        # Do this to handle floating point errors, where fvalue may exceed
        # self.high.
        fvalue = min(self.low*10**(value), self.high)
        if not self.factory.is_float:
            fvalue = int(round(fvalue))
        return fvalue

#-------------------------------------------------------------------------------
#  'LargeRangeSliderEditor' class:
#-------------------------------------------------------------------------------

class LargeRangeSliderEditor ( BaseRangeEditor ):
    """ A slider editor for large ranges.

       The editor displays a slider and a text field. A subset of the total
       range is displayed in the slider; arrow buttons at each end of the
       slider let the user move the displayed range higher or lower.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Low value for the slider range
    low = Any( 0 )

    # High value for the slider range
    high = Any( 1 )

    # Low end of displayed range
    cur_low = Float

    # High end of displayed range
    cur_high = Float

    # Flag indicating that the UI is in the process of being updated
    ui_changing = Bool( False )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        # Initialize using the factory range defaults:
        self.low = factory.low
        self.high = factory.high
        self.evaluate = factory.evaluate

        # Hook up the traits to listen to the object.
        self.sync_value( factory.low_name,  'low',  'from' )
        self.sync_value( factory.high_name, 'high', 'from' )
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        self.init_range()
        low  = self.cur_low
        high = self.cur_high

        self._set_format()
        self.control = panel = TraitsUIPanel( parent, -1 )
        sizer  = wx.BoxSizer( wx.HORIZONTAL )
        fvalue = self.value
        try:
            fvalue_text = self._format % fvalue
            1 / (low <= fvalue <= high)
        except:
            fvalue_text = ''
            fvalue      = low

        if high > low:
            ivalue = int( (float( fvalue - low ) / (high - low)) * 10000 )
        else:
            ivalue = low

        # Lower limit label:
        label_lo       = wx.StaticText( panel, -1, '999999' )
        panel.label_lo = label_lo
        sizer.Add( label_lo, 2, wx.ALIGN_CENTER )

        # Lower limit button:
        bmp       = wx.ArtProvider.GetBitmap( wx.ART_GO_BACK,
                                              size = ( 15, 15 ) )
        button_lo = wx.BitmapButton( panel, -1, bitmap = bmp, size = ( -1, 20 ),
                                     style = wx.BU_EXACTFIT | wx.NO_BORDER )
        panel.button_lo = button_lo
        button_lo.Bind( wx.EVT_BUTTON, self.reduce_range, button_lo )
        sizer.Add( button_lo, 1, wx.ALIGN_CENTER )

        # Slider:
        panel.slider = slider = Slider( panel, -1, ivalue, 0, 10000,
                                   size   = wx.Size( 80, 20 ),
                                   style  = wx.SL_HORIZONTAL | wx.SL_AUTOTICKS )
        slider.SetTickFreq( 1000, 1 )
        slider.SetPageSize( 1000 )
        slider.SetLineSize( 100 )
        wx.EVT_SCROLL( slider, self.update_object_on_scroll )
        sizer.Add( slider, 6, wx.EXPAND )

        # Upper limit button:
        bmp       = wx.ArtProvider.GetBitmap( wx.ART_GO_FORWARD,
                                              size = ( 15, 15 ) )
        button_hi = wx.BitmapButton( panel, -1, bitmap = bmp, size = ( -1, 20 ),
                                     style = wx.BU_EXACTFIT | wx.NO_BORDER )
        panel.button_hi = button_hi
        button_hi.Bind( wx.EVT_BUTTON, self.increase_range, button_hi )
        sizer.Add( button_hi, 1, wx.ALIGN_CENTER )

        # Upper limit label:
        label_hi = wx.StaticText( panel, -1, '999999' )
        panel.label_hi = label_hi
        sizer.Add( label_hi, 2, wx.ALIGN_CENTER )

        # Text entry:
        panel.text = text = wx.TextCtrl( panel, -1, fvalue_text,
                                         size  = wx.Size( 56, 20 ),
                                         style = wx.TE_PROCESS_ENTER )
        wx.EVT_TEXT_ENTER( panel, text.GetId(), self.update_object_on_enter )
        wx.EVT_KILL_FOCUS( text, self.update_object_on_enter )

        sizer.Add( text, 0, wx.LEFT | wx.EXPAND, 4 )

        # Set-up the layout:
        panel.SetSizerAndFit( sizer )
        label_lo.SetLabel( str(low)  )
        label_hi.SetLabel( str(high) )
        self.set_tooltip( slider )
        self.set_tooltip( label_lo )
        self.set_tooltip( label_hi )
        self.set_tooltip( text )

        # Update the ranges and button just in case.
        self.update_range_ui()

    #---------------------------------------------------------------------------
    #  Handles the user changing the current slider value:
    #---------------------------------------------------------------------------

    def update_object_on_scroll ( self, event ):
        """ Handles the user changing the current slider value.
        """
        low   = self.cur_low
        high  = self.cur_high
        value = low + ((float( event.GetPosition() ) / 10000.0) *
                       (high - low))
        self.control.text.SetValue( self._format % value )
        event_type = event.GetEventType()
        try:
            self.ui_changing = True
            if ((event_type == wx.wxEVT_SCROLL_ENDSCROLL) or
                (self.factory.auto_set and
                 (event_type == wx.wxEVT_SCROLL_THUMBTRACK)) or
                (self.factory.enter_set and
                 (event_type == wx.wxEVT_SCROLL_THUMBRELEASE))):
                if self.factory.is_float:
                    self.value = value
                else:
                    self.value = int( value )
        finally:
            self.ui_changing = False

    #---------------------------------------------------------------------------
    #  Handle the user pressing the 'Enter' key in the edit control:
    #---------------------------------------------------------------------------

    def update_object_on_enter ( self, event ):
        """ Handles the user pressing the Enter key in the text field.
        """
        try:
            value = self.control.text.GetValue().strip()
            try:
                if self.factory.is_float:
                    value = float(value)
                else:
                    value = int(value)
            except Exception, ex:
                # The user entered something that didn't eval as a number (e.g., 'foo').
                # Pretend it didn't happen (i.e. do not change self.value).
                value = self.value
                self.control.text.SetValue( str( value ) )

            self.value = value
            self.control.text.SetBackgroundColour(OKColor)
            self.control.text.Refresh()
            # Update the slider range.
            # Set ui_changing to True to avoid recursion:
            # the update_range_ui method will try to set the value in the text
            # box, which will again fire this method if auto_set is True.
            if not self.ui_changing:
                self.ui_changing = True
                self.init_range()
                self.update_range_ui()
                self.ui_changing = False
            if self._error is not None:
                self._error     = None
                self.ui.errors -= 1
        except TraitError, excp:
            pass

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        if self._error is None:
            self._error     = True
            self.ui.errors += 1
            super(LargeRangeSliderEditor, self).error(excp)
        self.set_error_state( True )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        value = self.value
        low   = self.low
        high  = self.high
        try:
            text = self._format % value
            1 / (low <= value <= high)
        except:
            value = low
        self.value = value

        if not self.ui_changing:
            self.init_range()
            self.update_range_ui()

    def update_range_ui ( self ):
        """ Updates the slider range controls.
        """
        low, high = self.cur_low, self.cur_high
        value = self.value
        self._set_format()
        self.control.label_lo.SetLabel( self._format % low )
        self.control.label_hi.SetLabel( self._format % high )
        if high > low:
            ivalue = int( (float( value - low ) / (high - low)) * 10000.0 )
        else:
            ivalue = low
        self.control.slider.SetValue( ivalue )
        text = self._format % self.value
        self.control.text.SetValue( text )
        factory = self.factory
        f_low, f_high = self.low, self.high

        if low == f_low:
            self.control.button_lo.Disable()
        else:
            self.control.button_lo.Enable()

        if high == f_high:
            self.control.button_hi.Disable()
        else:
            self.control.button_hi.Enable()

    def init_range ( self ):
        """ Initializes the slider range controls.
        """
        value     = self.value
        factory   = self.factory
        low, high = self.low, self.high
        if (high is None) and (low is not None):
            high = -low

        mag = abs( value )
        if mag <= 10.0:
            cur_low  = max( value - 10, low )
            cur_high = min( value + 10, high )
        else:
            d        = 0.5 * (10**int( log10( mag ) + 1 ))
            cur_low  = max( low,  value - d )
            cur_high = min( high, value + d )

        self.cur_low, self.cur_high = cur_low, cur_high

    def reduce_range ( self, event ):
        """ Reduces the extent of the displayed range.
        """
        factory   = self.factory
        low, high = self.low, self.high
        if abs( self.cur_low ) < 10:
            self.cur_low  = max( -10, low )
            self.cur_high = min( 10, high )
        elif self.cur_low > 0:
            self.cur_high = self.cur_low
            self.cur_low  = max( low, self.cur_low / 10 )
        else:
            self.cur_high = self.cur_low
            self.cur_low  = max( low, self.cur_low * 10 )

        self.ui_changing = True
        self.value       = min( max( self.value, self.cur_low ), self.cur_high )
        self.ui_changing = False
        self.update_range_ui()

    def increase_range ( self, event ):
        """ Increased the extent of the displayed range.
        """
        factory   = self.factory
        low, high = self.low, self.high
        if abs( self.cur_high ) < 10:
            self.cur_low  = max( -10, low )
            self.cur_high = min(  10, high )
        elif self.cur_high > 0:
            self.cur_low  = self.cur_high
            self.cur_high = min( high, self.cur_high * 10 )
        else:
            self.cur_low  = self.cur_high
            self.cur_high = min( high, self.cur_high / 10 )

        self.ui_changing = True
        self.value       = min( max( self.value, self.cur_low ), self.cur_high )
        self.ui_changing = False
        self.update_range_ui()

    def _set_format ( self ):
        self._format = '%d'
        factory      = self.factory
        low, high    = self.cur_low, self.cur_high
        diff         = high - low
        if factory.is_float:
            if diff > 99999:
                self._format = '%.2g'
            elif diff > 1:
                self._format = '%%.%df' % max( 0, 4 -
                                                  int( log10( high - low ) ) )
            else:
                self._format = '%.3f'

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self.control.text

    #---------------------------------------------------------------------------
    #  Handles the 'low'/'high' traits being changed:
    #---------------------------------------------------------------------------

    def _low_changed ( self, low ):
        if self.control is not None:
            if self.value < low:
                if self.factory.is_float:
                    self.value = float( low )
                else:
                    self.value = int( low )

            self.update_editor()

    def _high_changed ( self, high ):
        if self.control is not None:
            if self.value > high:
                if self.factory.is_float:
                    self.value = float( high )
                else:
                    self.value = int( high )

            self.update_editor()

#-------------------------------------------------------------------------------
#  'SimpleSpinEditor' class:
#-------------------------------------------------------------------------------

class SimpleSpinEditor ( BaseRangeEditor ):
    """ A simple style of range editor that displays a spin box control.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Low value for the slider range
    low = Any

    # High value for the slider range
    high = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if not factory.low_name:
            self.low = factory.low

        if not factory.high_name:
            self.high = factory.high

        self.sync_value( factory.low_name,  'low',  'from' )
        self.sync_value( factory.high_name, 'high', 'from' )
        low  = self.low
        high = self.high
        self.control = wx.SpinCtrl( parent, -1, self.str_value,
                                    min     = low,
                                    max     = high,
                                    initial = self.value )
        wx.EVT_SPINCTRL( parent, self.control.GetId(), self.update_object )
        wx.EVT_TEXT( parent, self.control.GetId(), self.update_object )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handle the user selecting a new value from the spin control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user selecting a new value in the spin box.
        """
        self._locked = True
        try:
            self.value = self.control.GetValue()
        finally:
            self._locked = False

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if not self._locked:
            try:
                self.control.SetValue( int( self.value ) )
            except:
                pass

    #---------------------------------------------------------------------------
    #  Handles the 'low'/'high' traits being changed:
    #---------------------------------------------------------------------------

    def _low_changed ( self, low ):
        if self.value < low:
            if self.factory.is_float:
                self.value = float( low )
            else:
                self.value = int( low )
        if self.control:
            self.control.SetRange( self.low, self.high )
            self.control.SetValue( int( self.value ) )

    def _high_changed ( self, high ):
        if self.value > high:
            if self.factory.is_float:
                self.value = float( high )
            else:
                self.value = int( high )
        if self.control:
            self.control.SetRange( self.low, self.high )
            self.control.SetValue( int( self.value ) )

#-------------------------------------------------------------------------------
#  'RangeTextEditor' class:
#-------------------------------------------------------------------------------

class RangeTextEditor ( TextEditor ):
    """ Editor for ranges that displays a text field. If the user enters a
        value that is outside the allowed range, the background of the field
        changes color to indicate an error.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function to evaluate floats/ints
    evaluate = Any

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """

        if self.factory.enter_set:
            control = wx.TextCtrl( parent, -1, self.str_value,
                                   style = wx.TE_PROCESS_ENTER )
            wx.EVT_TEXT_ENTER( parent, control.GetId(), self.update_object )
        else:
            control = wx.TextCtrl( parent, -1, self.str_value )

        wx.EVT_KILL_FOCUS( control, self.update_object )

        if self.factory.auto_set:
            wx.EVT_TEXT( parent, control.GetId(), self.update_object )

        self.evaluate = self.factory.evaluate
        self.sync_value( self.factory.evaluate_name, 'evaluate', 'from' )

        self.control = control
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """

        # There are cases where this method is called with self.control == None.
        if self.control is None:
            return

        value = self.control.GetValue()

        # Try to convert the string value entered by the user to a numerical value.
        try:
            if self.evaluate is not None:
                value = self.evaluate(value)
            else:
                if self.factory.is_float:
                    value = float(value)
                else:
                    value = int(value)
        except Exception, excp:
            # The conversion failed.
            self.error(excp)
            return

        # Try to assign the numerical value to the trait.
        # This may fail because of constraints on the trait.
        try:
            self.value = value
            self.control.SetBackgroundColour(OKColor)
            self.control.Refresh()
            if self._error is not None:
                self._error     = None
                self.ui.errors -= 1
        except TraitError, excp:
            pass

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        if self._error is None:
            self._error     = True
            self.ui.errors += 1
            super(RangeTextEditor, self).error(excp)
        self.set_error_state( True )

#-------------------------------------------------------------------------------
#  'SimpleEnumEditor' factory adaptor:
#-------------------------------------------------------------------------------

def SimpleEnumEditor ( parent, factory, ui, object, name, description ):
    return CustomEnumEditor( parent, factory, ui, object, name, description,
                             'simple' )

#-------------------------------------------------------------------------------
#  'CustomEnumEditor' factory adaptor:
#-------------------------------------------------------------------------------

def CustomEnumEditor ( parent, factory, ui, object, name, description,
                       style = 'custom' ):
    """ Factory adapter that returns a enumeration editor of the specified
        style.
    """
    if factory._enum is None:
        import traitsui.editors.enum_editor as enum_editor
        factory._enum = enum_editor.ToolkitEditorFactory(
                            values = range( factory.low, factory.high + 1 ),
                            cols   = factory.cols )

    if style == 'simple':
        return factory._enum.simple_editor( ui, object, name, description,
                                            parent )

    return factory._enum.custom_editor( ui, object, name, description, parent )

#-------------------------------------------------------------------------------
#  Defines the mapping between editor factory 'mode's and Editor classes:
#-------------------------------------------------------------------------------

# Mapping between editor factory modes and simple editor classes
SimpleEditorMap = {
    'slider':  SimpleSliderEditor,
    'xslider': LargeRangeSliderEditor,
    'spinner': SimpleSpinEditor,
    'enum':    SimpleEnumEditor,
    'text':    RangeTextEditor,
    'logslider':     LogRangeSliderEditor
}
# Mapping between editor factory modes and custom editor classes
CustomEditorMap = {
    'slider':  SimpleSliderEditor,
    'xslider': LargeRangeSliderEditor,
    'spinner': SimpleSpinEditor,
    'enum':    CustomEnumEditor,
    'text':    RangeTextEditor,
    'logslider':     LogRangeSliderEditor
}

### EOF #######################################################################


########NEW FILE########
__FILENAME__ = rgb_color_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/22/2004
#
#------------------------------------------------------------------------------

""" Defines a subclass of the base wxPython color editor factory, for colors
    that are represented as tuples of the form ( *red*, *green*, *blue* ),
    where *red*, *green* and *blue* are floats in the range from 0.0 to 1.0.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.trait_base \
    import SequenceTypes

# Note: The ToolkitEditorFactory class imported from color_editor is the
# abstract ToolkitEditorFactory class (in traitsui.api) along with
# wx-specific methods added via a category. We need to override the
# implementations of the wx-specific methods here.
from color_editor \
    import ToolkitEditorFactory as BaseColorToolkitEditorFactory

#---------------------------------------------------------------------------
#  The wxPython ToolkitEditorFactory class.
#---------------------------------------------------------------------------
class ToolkitEditorFactory(BaseColorToolkitEditorFactory):
    """ wxPython editor factory for color editors.
    """
    #---------------------------------------------------------------------------
    #  Gets the wxPython color equivalent of the object:
    #---------------------------------------------------------------------------

    def to_wx_color ( self, editor, color=None ):
        """ Gets the wxPython color equivalent of the object trait.
        """
        if color is None:
            try:
                color = getattr( editor.object, editor.name + '_' )
            except AttributeError:
                color = getattr( editor.object, editor.name )
        if isinstance(color, tuple):
            return wx.Colour( int( color[0] * 255.0 ),
                              int( color[1] * 255.0 ),
                              int( color[2] * 255.0 ) )
        return color

    #---------------------------------------------------------------------------
    #  Gets the application equivalent of a wxPython value:
    #---------------------------------------------------------------------------

    def from_wx_color ( self, color ):
        """ Gets the application equivalent of a wxPython value.
        """
        return ( color.Red()   / 255.0,
                 color.Green() / 255.0,
                 color.Blue()  / 255.0 )

    #---------------------------------------------------------------------------
    #  Returns the text representation of a specified color value:
    #---------------------------------------------------------------------------

    def str_color ( self, color ):
        """ Returns the text representation of a specified color value.
        """
        if type( color ) in SequenceTypes:
            return "(%d,%d,%d)" % ( int( color[0] * 255.0 ),
                                    int( color[1] * 255.0 ),
                                    int( color[2] * 255.0 ) )
        return super(ToolkitEditorFactory, self).str_color(color)


########NEW FILE########
__FILENAME__ = rgb_color_trait
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/22/2004
#
#------------------------------------------------------------------------------

""" Trait definition for an RGB-based color, which is a tuple of the form
    (*red*, *green*, *blue*), where *red*, *green* and *blue* are floats in the
    range from 0.0 to 1.0.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------
import wx

from traits.api \
    import Trait, TraitError

from traits.trait_base \
    import SequenceTypes

### Note: Import from the source rather than the api to avoid circular imports
# since some classes declared in the traits UI api define Color traits which
# will end up importing this file.
from traitsui.editors.rgb_color_editor \
    import RGBColorEditor

from traitsui.wx.color_trait \
    import standard_colors, w3c_color_database

#-------------------------------------------------------------------------------
#  Convert a number into an RGB tuple:
#-------------------------------------------------------------------------------

def range_check ( value ):
    """ Checks that *value* can be converted to a value in the range 0.0 to 1.0.

        If so, it returns the floating point value; otherwise, it raises a
        TraitError.
    """
    value = float( value )
    if 0.0 <= value <= 1.0:
        return value
    raise TraitError

def convert_to_color ( object, name, value ):
    """ Converts a tuple or an integer to an RGB color value, or raises a
        TraitError if that is not possible.
    """
    if (type( value ) in SequenceTypes) and (len( value ) == 3):
        return ( range_check( value[0] ),
                 range_check( value[1] ),
                 range_check( value[2] ) )
    if type( value ) is int:
        num = int( value )
        return ( (num / 0x10000)        / 255.0
                 ((num / 0x100) & 0xFF) / 255.0,
                 (num & 0xFF)           / 255.0 )
    if isinstance(value, wx.Colour):
        return (value.Red()/255.0,
                value.Green()/255.0,
                value.Blue()/255.0)
    raise TraitError

convert_to_color.info = ('a tuple of the form (r,g,b), where r, g, and b '
    'are floats in the range from 0.0 to 1.0, or an integer which in hex is of '
    'the form 0xRRGGBB, where RR is red, GG is green, and BB is blue')

#-------------------------------------------------------------------------------
#  Standard colors:
#-------------------------------------------------------------------------------

# RGB versions of standard colors:
rgb_standard_colors = {}
for name, color in standard_colors.items():
    rgb_standard_colors[ name ] = ( color.Red() / 255.0,
                                    color.Green() / 255.0,
                                    color.Blue()  / 255.0 )
# Add the W3C colors
for color_name in w3c_color_database._color_names:
    color = w3c_color_database.Find(color_name)
    rgb_standard_colors[color_name] = (color.Red() / 255.0,
                                       color.Green() / 255.0,
                                       color.Blue()  / 255.0)

#-------------------------------------------------------------------------------
#  Define wxPython specific color traits:
#-------------------------------------------------------------------------------

### Note: Declare the editor to be a function which returns the RGBColorEditor
# class from traits ui to avoid circular import issues. For backwards
# compatibility with previous Traits versions, the 'editors' folder in Traits
# project declares 'from api import *' in its __init__.py. The 'api' in turn
# can contain classes that have a RGBColor trait which lead to this file getting
# imported. This will lead to a circular import when declaring a RGBColor trait.
def get_rgb_color_editor(*args, **traits):
    from rgb_color_editor import ToolkitEditorFactory
    return ToolkitEditorFactory(*args, **traits)

# Trait whose value must be an RGB color:
RGBColor = Trait( 'white', convert_to_color, rgb_standard_colors,
                  editor = get_rgb_color_editor )


########NEW FILE########
__FILENAME__ = scrubber_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/14/2008
#
#-------------------------------------------------------------------------------

""" Traits UI simple, scrubber-based integer or float value editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from math \
   import log10, pow

from traits.api \
    import Any, BaseRange, BaseEnum, Str, Float, TraitError, \
           on_trait_change

from traitsui.api \
    import View, Item, EnumEditor

# FIXME: ScrubberEditor is a proxy class defined here just for backward
# compatibility (represents the editor factory for scrubber editors).
# The class has been moved to traitsui.editors.scrubber_editor
from traitsui.editors.scrubber_editor \
    import ScrubberEditor

from traitsui.wx.editor \
    import Editor

from pyface.timer.api \
    import do_after

from constants \
    import ErrorColor

from image_slice \
    import paint_parent

from helper \
    import disconnect, disconnect_no_id, BufferDC

#-------------------------------------------------------------------------------
#  '_ScrubberEditor' class:
#-------------------------------------------------------------------------------

class _ScrubberEditor ( Editor ):
    """ Traits UI simple, scrubber-based integer or float value editor.
    """

    # The low end of the slider range:
    low = Any

    # The high end of the slider range:
    high = Any

    # The smallest allowed increment:
    increment = Float

    # The current text being displayed:
    text = Str

    # The mapping to use (only for Enum's):
    mapping = Any

    #-- Class Variables --------------------------------------------------------

    text_styles = {
        'left':   wx.TE_LEFT,
        'center': wx.TE_CENTRE,
        'right':  wx.TE_RIGHT
    }

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        # Establish the range of the slider:
        low_name  = high_name = ''
        low, high = factory.low, factory.high
        if high <= low:
            low = high = None
            handler    = self.object.trait( self.name ).handler
            if isinstance( handler, BaseRange ):
                low_name, high_name = handler._low_name, handler._high_name

                if low_name == '':
                    low = handler._low

                if high_name == '':
                    high = handler._high

            elif isinstance( handler, BaseEnum ):
                if handler.name == '':
                    self.mapping = handler.values
                else:
                    self.sync_value( handler.name, 'mapping', 'from' )

                low, high = 0, self.high

        # Create the control:
        self.control = control = wx.Window( parent, -1,
                                            size  = wx.Size( 50, 18 ),
                                            style = wx.FULL_REPAINT_ON_RESIZE |
                                                    wx.TAB_TRAVERSAL )

        # Set up the painting event handlers:
        wx.EVT_ERASE_BACKGROUND( control, self._erase_background )
        wx.EVT_PAINT(            control, self._on_paint )
        wx.EVT_SET_FOCUS(        control, self._set_focus )

        # Set up mouse event handlers:
        wx.EVT_LEAVE_WINDOW( control, self._leave_window )
        wx.EVT_ENTER_WINDOW( control, self._enter_window )
        wx.EVT_LEFT_DOWN(    control, self._left_down )
        wx.EVT_LEFT_UP(      control, self._left_up )
        wx.EVT_MOTION(       control, self._motion )
        wx.EVT_MOUSEWHEEL(   control, self._mouse_wheel )

        # Set up the control resize handler:
        wx.EVT_SIZE( control, self._resize )

        # Set the tooltip:
        self._can_set_tooltip = (not self.set_tooltip())

        # Save the values we calculated:
        self.set( low = low, high = high )
        self.sync_value( low_name,  'low',  'from' )
        self.sync_value( high_name, 'high', 'from' )

        # Force a reset (in case low = high = None, which won't cause a
        # notification to fire):
        self._reset_scrubber()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Remove all of the wx event handlers:
        disconnect_no_id( self.control, wx.EVT_ERASE_BACKGROUND, wx.EVT_PAINT,
            wx.EVT_SET_FOCUS, wx.EVT_LEAVE_WINDOW, wx.EVT_ENTER_WINDOW,
            wx.EVT_LEFT_DOWN, wx.EVT_LEFT_UP, wx.EVT_MOTION, wx.EVT_MOUSEWHEEL,
            wx.EVT_SIZE )

        # Disconnect the pop-up text event handlers:
        self._disconnect_text()

        super( _ScrubberEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.text       = self.string_value( self.value )
        self._text_size = None
        self._refresh()

        self._enum_completed()

    #---------------------------------------------------------------------------
    #  Updates the object when the scrubber value changes:
    #---------------------------------------------------------------------------

    def update_object ( self, value ):
        """ Updates the object when the scrubber value changes.
        """
        if self.mapping is not None:
            value = self.mapping[ int( value ) ]

        if value != self.value:
            try:
                self.value = value
                self.update_editor()
            except TraitError:
                value = int( value )
                if value != self.value:
                    self.value = value
                    self.update_editor()

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #-- Trait Event Handlers ---------------------------------------------------

    def _mapping_changed ( self, mapping ):
        """ Handles the Enum mapping being changed.
        """
        self.high = len( mapping ) - 1

    #-- Private Methods --------------------------------------------------------

    @on_trait_change( 'low, high' )
    def _reset_scrubber ( self ):
        """ Sets the the current tooltip.
        """
        low, high = self.low, self.high
        if self._can_set_tooltip:
            if self.mapping is not None:
                tooltip = '[%s]' % (', '.join( self.mapping ))
                if len( tooltip ) > 80:
                    tooltip = ''
            elif high is None:
                tooltip = ''
                if low is not None:
                    tooltip = '[%g..]' % low
            elif low is None:
                tooltip = '[..%g]' % high
            else:
                tooltip = '[%g..%g]' % ( low, high )

            self.control.SetToolTipString( tooltip )

        # Establish the slider increment:
        increment = self.factory.increment
        if increment <= 0.0:
            if (low is None) or (high is None) or isinstance( low, int ):
                increment = 1.0
            else:
                increment = pow( 10, round( log10( (high - low) / 100.0 ) ) )

        self.increment = increment

        self.update_editor()

    def _get_text_bounds ( self ):
        """ Get the window bounds of where the current text should be
            displayed.
        """
        tdx, tdy, descent, leading = self._get_text_size()
        wdx, wdy  = self.control.GetClientSizeTuple()
        ty        = ((wdy - (tdy - descent)) / 2) - 1
        alignment = self.factory.alignment
        if alignment == 'left':
            tx = 0
        elif alignment == 'center':
            tx = (wdx - tdx) / 2
        else:
            tx = wdx - tdx

        return ( tx, ty, tdx, tdy )

    def _get_text_size ( self ):
        """ Returns the text size information for the window.
        """
        if self._text_size is None:
            self._text_size = self.control.GetFullTextExtent(
                                               self.text.strip() or 'M' )

        return self._text_size

    def _refresh ( self ):
        """ Refreshes the contents of the control.
        """
        if self.control is not None:
            self.control.Refresh()

    def _set_scrubber_position ( self, event, delta ):
        """ Calculates a new scrubber value for a specified mouse position
            change.
        """
        clicks    = 3
        increment = self.increment
        if event.ShiftDown():
            increment *= 10.0
            clicks     = 7
        elif event.ControlDown():
            increment /= 10.0

        value = self._value + (delta / clicks) * increment

        if self.low is not None:
            value = max( value, self.low )

        if self.high is not None:
            value = min( value, self.high )

        self.update_object( value )

    def _delayed_click ( self ):
        """ Handle a delayed click response.
        """
        self._pending = False

    def _pop_up_editor ( self ):
        """ Pop-up a text control to allow the user to enter a value using
            the keyboard.
        """
        self.control.SetCursor( wx.StockCursor( wx.CURSOR_ARROW ) )

        if self.mapping is not None:
            self._pop_up_enum()
        else:
            self._pop_up_text()

    def _pop_up_enum ( self ):
        self._ui = self.object.edit_traits(
            view = View(
                Item( self.name,
                      id         = 'drop_down',
                      show_label = False,
                      padding    = -4,
                      editor     = EnumEditor( name = 'editor.mapping' ) ),
                kind = 'subpanel' ),
            parent  = self.control,
            context = { 'object': self.object, 'editor': self } )

        dx, dy    = self.control.GetSizeTuple()
        drop_down = self._ui.info.drop_down.control
        drop_down.SetDimensions(  0, 0, dx, dy )
        drop_down.SetFocus()
        wx.EVT_KILL_FOCUS( drop_down, self._enum_completed )

    def _pop_up_text ( self ):
        control = self.control
        self._text = text = wx.TextCtrl( control, -1, str( self.value ),
                            size  = control.GetSize(),
                            style = self.text_styles[ self.factory.alignment ] |
                                    wx.TE_PROCESS_ENTER )
        text.SetSelection( -1, -1 )
        text.SetFocus()
        wx.EVT_TEXT_ENTER( control, text.GetId(), self._text_completed )
        wx.EVT_KILL_FOCUS(   text, self._text_completed )
        wx.EVT_ENTER_WINDOW( text, self._enter_text )
        wx.EVT_LEAVE_WINDOW( text, self._leave_text )
        wx.EVT_CHAR( text, self._key_entered )

    def _destroy_text ( self ):
        """ Destroys the current text control.
        """
        self._ignore_focus = self._in_text_window

        self._disconnect_text()

        self.control.DestroyChildren()

        self._text = None

    def _disconnect_text ( self ):
        """ Disconnects the event handlers for the pop up text editor.
        """
        if self._text is not None:
            disconnect( self._text, wx.EVT_TEXT_ENTER )
            disconnect_no_id( self._text, wx.EVT_KILL_FOCUS,
                wx.EVT_ENTER_WINDOW, wx.EVT_LEAVE_WINDOW, wx.EVT_CHAR )

    def _init_value ( self ):
        """ Initializes the current value when the user begins a drag or moves
            the mouse wheel.
        """
        if self.mapping is not None:
            try:
                self._value = list( self.mapping ).index( self.value )
            except:
                self._value = 0
        else:
            self._value = self.value

    #--- wxPython Event Handlers -----------------------------------------------

    def _erase_background ( self, event ):
        """ Do not erase the background here (do it in the 'on_paint' handler).
        """
        pass

    def _on_paint ( self, event ):
        """ Paint the background using the associated ImageSlice object.
        """
        control = self.control
        dc      = BufferDC( control )

        # Draw the background:
        factory  = self.factory
        color    = factory.color_
        if self._x is not None:
            if factory.active_color_ is not None:
                color = factory.active_color_
        elif self._hover:
            if factory.hover_color_ is not None:
                color = factory.hover_color_

        if color is None:
            paint_parent( dc, control )
            brush = wx.TRANSPARENT_BRUSH
        else:
            brush = wx.Brush( color )

        color = factory.border_color_
        if color is not None:
            pen = wx.Pen( color )
        else:
            pen = wx.TRANSPARENT_PEN

        if (pen != wx.TRANSPARENT_PEN) or (brush != wx.TRANSPARENT_BRUSH):
            wdx, wdy = control.GetClientSizeTuple()
            dc.SetBrush( brush )
            dc.SetPen( pen )
            dc.DrawRectangle( 0, 0, wdx, wdy )

        # Draw the current text value:
        dc.SetBackgroundMode( wx.TRANSPARENT )
        dc.SetTextForeground( factory.text_color_ )
        dc.SetFont( control.GetFont() )
        tx, ty, tdx, tdy = self._get_text_bounds()
        dc.DrawText( self.text, tx, ty )

        # Copy the buffer contents to the display:
        dc.copy()

    def _resize ( self, event ):
        """ Handles the control being resized.
        """
        if self._text is not None:
            self._text.SetSize( self.control.GetSize() )

    def _set_focus ( self, event ):
        """ Handle the control getting the keyboard focus.
        """
        if ((not self._ignore_focus) and
            (self._x is None)        and
            (self._text is None)):
            self._pop_up_editor()

        event.Skip()

    def _enter_window ( self, event ):
        """ Handles the mouse entering the window.
        """
        self._hover = True

        self.control.SetCursor( wx.StockCursor( wx.CURSOR_HAND ) )

        if not self._ignore_focus:
            self._ignore_focus = True
            self.control.SetFocus()

        self._ignore_focus = False

        if self._x is not None:
            if self.factory.active_color_ != self.factory.color_:
                self.control.Refresh()
        elif self.factory.hover_color_ != self.factory.color_:
            self.control.Refresh()

    def _leave_window ( self, event ):
        """ Handles the mouse leaving the window.
        """
        self._hover = False

        if self.factory.hover_color_ != self.factory.color_:
            self.control.Refresh()

    def _left_down ( self, event ):
        """ Handles the left mouse being pressed.
        """
        self._x, self._y = event.GetX(), event.GetY()
        self._pending    = True

        self._init_value()

        self.control.CaptureMouse()

        if self.factory.active_color_ != self.factory.hover_color_:
            self.control.Refresh()

        do_after( 200, self._delayed_click )

    def _left_up ( self, event ):
        """ Handles the left mouse button being released.
        """
        self.control.ReleaseMouse()
        if self._pending:
            self._pop_up_editor()

        self._x = self._y = self._value = self._pending = None

        if self._hover or (self.factory.active_color_ != self.factory.color_):
            self.control.Refresh()

    def _motion ( self, event ):
        """ Handles the mouse moving.
        """
        if self._x is not None:
            x, y = event.GetX(), event.GetY()
            dx   = x - self._x
            adx  = abs( dx )
            dy   = y - self._y
            ady  = abs( dy )
            if self._pending:
                if (adx + ady) < 3:
                    return
                self._pending = False

            if adx > ady:
                delta = dx
            else:
                delta = -dy

            self._set_scrubber_position( event, delta )

    def _mouse_wheel ( self, event ):
        """ Handles the mouse wheel moving.
        """
        if self._hover:
            self._init_value()
            clicks = 3
            if event.ShiftDown():
                clicks = 7
            delta = clicks * (event.GetWheelRotation() / event.GetWheelDelta())
            self._set_scrubber_position( event, delta )

    def _update_value ( self, event ):
        """ Updates the object value from the current text control value.
        """
        control = event.GetEventObject()
        try:
            self.update_object( float( control.GetValue() ) )

            return True

        except TraitError:
            control.SetBackgroundColour( ErrorColor )
            control.Refresh()

            return False

    def _enter_text ( self, event ):
        """ Handles the mouse entering the pop-up text control.
        """
        self._in_text_window = True

    def _leave_text ( self, event ):
        """ Handles the mouse leaving the pop-up text control.
        """
        self._in_text_window = False

    def _text_completed ( self, event ):
        """ Handles the user pressing the 'Enter' key in the text control.
        """
        if self._update_value( event ):
            self._destroy_text()

    def _enum_completed ( self, event = None ):
        """ Handles the Enum drop-down control losing focus.
        """
        if self._ui is not None:
            self._ignore_focus = True
            disconnect_no_id( self._ui.info.drop_down.control,
                              wx.EVT_KILL_FOCUS )
            self._ui.dispose()
            del self._ui

    def _key_entered ( self, event ):
        """ Handles individual key strokes while the text control is active.
        """
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_ESCAPE:
            self._destroy_text()
            return

        if key_code == wx.WXK_TAB:
            if self._update_value( event ):
                if event.ShiftDown():
                    self.control.Navigate( 0 )
                else:
                    self.control.Navigate()
            return

        event.Skip()


########NEW FILE########
__FILENAME__ = search_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Evan Patterson
#  Date:   06/25/09
#
#-------------------------------------------------------------------------------

# System library imports
import wx

# Local imports
from editor import Editor


class SearchEditor(Editor):

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """

        style = 0
        if self.factory.enter_set:
            style = wx.TE_PROCESS_ENTER
        self.control = wx.SearchCtrl(parent, -1, value=self.value, style=style)

        self.control.SetDescriptiveText(self.factory.text)
        self.control.ShowSearchButton(self.factory.search_button)
        self.control.ShowCancelButton(self.factory.cancel_button)

        if self.factory.auto_set:
            wx.EVT_TEXT(parent, self.control.GetId(), self.update_object)

        if self.factory.enter_set:
            wx.EVT_TEXT_ENTER(parent, self.control.GetId(), self.update_object)

        wx.EVT_SEARCHCTRL_SEARCH_BTN(parent, self.control.GetId(),
                                     self.update_object)
        wx.EVT_SEARCHCTRL_CANCEL_BTN(parent, self.control.GetId(),
                                     self.clear_text)

    def update_object(self, event):
        """ Handles the user entering input data in the edit control.
        """

        if not self._no_update:
            self.value = self.control.GetValue()
            if self.factory.search_event_trait != '':
                setattr(self.object, self.factory.search_event_trait, True)

    def clear_text(self, event):
        """ Handles the user pressing the cancel search button.
        """

        if not self._no_update:
            self.control.SetValue("")
            self.value = ""
            if self.factory.search_event_trait != '':
                setattr(self.object, self.factory.search_event_trait, True)

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """

        if self.control.GetValue() != self.value:
            self._no_update = True
            self.control.SetValue(self.str_value)
            self._no_update = False

########NEW FILE########
__FILENAME__ = set_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#  fixme: Add undo/redo support
#  fixme: Allow factory to handle a TraitListObject for the 'values' trait.
#
#------------------------------------------------------------------------------

""" Defines the set editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Property

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.set_editor file.
from traitsui.editors.set_editor \
    import ToolkitEditorFactory

from editor \
    import Editor

from helper \
    import enum_values_changed, TraitsUIPanel

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of editor for sets.

        The editor displays two list boxes, with buttons for moving the selected
        items from left to right, or vice versa. If **can_move_all** on the
        factory is True, then buttons are displayed for moving all the items to
        one box or the other. If the set is ordered, buttons are displayed for
        moving the selected item up or down in right-side list box.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Current set of enumeration names:
    names = Property

    # Current mapping from names to values:
    mapping = Property

    # Current inverse mapping from values to names:
    inverse_mapping = Property

    # Is set editor scrollable? This value overrides the default.
    scrollable = True

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        if factory.name != '':
            self._object, self._name, self._value = \
                self.parse_extended_name( factory.name )
            self.values_changed()
            self._object.on_trait_change( self._values_changed,
                                          self._name, dispatch = 'ui' )
        else:
            factory.on_trait_change( self.update_editor, 'values_modified',
                                     dispatch = 'ui' )

        self.control = panel = TraitsUIPanel( parent, -1 )
        hsizer       = wx.BoxSizer( wx.HORIZONTAL )
        vsizer       = wx.BoxSizer( wx.VERTICAL )

        self._unused = self._create_listbox( panel, hsizer, self._on_unused,
                                      self._on_use, factory.left_column_title )

        self._use_all = self._unuse_all = self._up = self._down = None
        if factory.can_move_all:
            self._use_all = self._create_button( '>>', panel, vsizer, 15,
                                                           self._on_use_all)

        self._use   = self._create_button( '>', panel, vsizer, 15,
                                                self._on_use )
        self._unuse = self._create_button( '<', panel, vsizer, 0,
                                                self._on_unuse )
        if factory.can_move_all:
            self._unuse_all = self._create_button('<<', panel, vsizer, 15,
                                                            self._on_unuse_all)

        if factory.ordered:
            self._up   = self._create_button( 'Move Up',   panel, vsizer, 30,
                                                           self._on_up )
            self._down = self._create_button( 'Move Down', panel, vsizer, 0,
                                                           self._on_down )

        hsizer.Add( vsizer, 0, wx.LEFT | wx.RIGHT, 8 )
        self._used = self._create_listbox( panel, hsizer, self._on_value,
                                    self._on_unuse, factory.right_column_title )

        panel.SetSizer( hsizer )

        self.context_object.on_trait_change( self.update_editor,
                               self.extended_name + '_items?', dispatch = 'ui' )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Gets the current set of enumeration names:
    #---------------------------------------------------------------------------

    def _get_names ( self ):
        """ Gets the current set of enumeration names.
        """
        if self._object is None:
            return self.factory._names

        return self._names

    #---------------------------------------------------------------------------
    #  Gets the current mapping:
    #---------------------------------------------------------------------------

    def _get_mapping ( self ):
        """ Gets the current mapping.
        """
        if self._object is None:
            return self.factory._mapping

        return self._mapping

    #---------------------------------------------------------------------------
    #  Gets the current inverse mapping:
    #---------------------------------------------------------------------------

    def _get_inverse_mapping ( self ):
        """ Gets the current inverse mapping.
        """
        if self._object is None:
            return self.factory._inverse_mapping

        return self._inverse_mapping

    #---------------------------------------------------------------------------
    #  Creates a list box:
    #---------------------------------------------------------------------------

    def _create_listbox ( self, parent, sizer, handler1, handler2, title ):
        """ Creates a list box.
        """
        column_sizer = wx.BoxSizer( wx.VERTICAL )

        # Add the column title in emphasized text:
        title_widget  = wx.StaticText( parent, -1, title )
        font          = title_widget.GetFont()
        emphasis_font = wx.Font( font.GetPointSize() + 1,
                                 font.GetFamily(),
                                 font.GetStyle(),
                                 wx.BOLD )
        title_widget.SetFont(emphasis_font)
        column_sizer.Add( title_widget, 0, 0)

        # Create the list box and add it to the column:
        list = wx.ListBox(parent, -1, style = wx.LB_EXTENDED | wx.LB_NEEDED_SB)
        column_sizer.Add( list, 1, wx.EXPAND )

        # Add the column to the SetEditor widget:
        sizer.Add( column_sizer, 1, wx.EXPAND )

        # Hook up the event handlers:
        wx.EVT_LISTBOX(        parent, list.GetId(), handler1 )
        wx.EVT_LISTBOX_DCLICK( parent, list.GetId(), handler2 )

        return list

    #---------------------------------------------------------------------------
    #  Creates a button:
    #---------------------------------------------------------------------------

    def _create_button ( self, label, parent, sizer, space_before, handler ):
        """ Creates a button.
        """
        button = wx.Button( parent, -1, label, style=wx.BU_EXACTFIT )
        sizer.AddSpacer( ( space_before, space_before ) )
        sizer.Add( button, 0, wx.EXPAND | wx.BOTTOM, 8 )
        wx.EVT_BUTTON( parent, button.GetId(), handler )
        return button

    #---------------------------------------------------------------------------
    #  Recomputes the cached data based on the underlying enumeration model:
    #---------------------------------------------------------------------------

    def values_changed ( self ):
        """ Recomputes the cached data based on the underlying enumeration model.
        """
        self._names, self._mapping, self._inverse_mapping = \
            enum_values_changed( self._value() )

    #---------------------------------------------------------------------------
    #  Handles the underlying object model's enumeration set being changed:
    #---------------------------------------------------------------------------

    def _values_changed ( self ):
        """ Handles the underlying object model's enumeration set being changed.
        """
        self.values_changed()
        self.update_editor()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Check for any items having been deleted from the enumeration that are
        # still present in the object value:
        mapping = self.inverse_mapping.copy()
        values  = [ v for v in self.value if v in mapping ]
        if len( values ) < len( self.value ):
            self.value = values
            return

        # Get a list of the selected items in the right box:
        used        = self._used
        used_labels = self._get_selected_strings( used )

        # Get a list of the selected items in the left box:
        unused        = self._unused
        unused_labels = self._get_selected_strings( unused )

        # Empty list boxes in preparation for rebuilding from current values:
        used.Clear()
        unused.Clear()

        # Ensure right list box is kept alphabetized unless insertion
        # order is relevant:
        if not self.factory.ordered:
            values = values[:]
            values.sort()

        # Rebuild the right listbox:
        used_selections = []
        for i, value in enumerate( values ):
            label = mapping[ value ]
            used.Append( label )
            del mapping[ value ]
            if label in used_labels:
                used_selections.append(i)

        # Rebuild the left listbox:
        unused_selections = []
        unused_items      = mapping.values()
        unused_items.sort()
        mapping            = self.mapping
        self._unused_items = [ mapping[ ui ] for ui in unused_items ]
        for i, unused_item in enumerate( unused_items ):
            unused.Append( unused_item )
            if unused_item in unused_labels:
                unused_selections.append( i )

        # If nothing is selected, default selection should be top of left box,
        # or of right box if left box is empty:
        if (len( used_selections ) == 0) and (len( unused_selections ) == 0):
            if unused.GetCount() == 0:
                used_selections.append( 0 )
            else:
                unused_selections.append( 0 )

        used_count = used.GetCount()
        for i in used_selections:
            if i < used_count:
               used.SetSelection( i )

        unused_count = unused.GetCount()
        for i in unused_selections:
            if i < unused_count:
                unused.SetSelection( i )

        self._check_up_down()
        self._check_left_right()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self._object is not None:
            self._object.on_trait_change( self._values_changed,
                                          self._name, remove = True )
        else:
            self.factory.on_trait_change( self.update_editor,
                                          'values_modified', remove = True )

        self.context_object.on_trait_change( self.update_editor,
                                 self.extended_name + '_items?', remove = True )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return [ self._unused, self._used ]

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def _on_value ( self, event ):
        if not self.factory.ordered:
            self._clear_selection( self._unused )
        self._check_left_right()
        self._check_up_down()

    def _on_unused ( self, event ):
        if not self.factory.ordered:
            self._clear_selection( self._used )
        self._check_left_right()
        self._check_up_down()

    def _on_use ( self, event ):
        self._unused_items, self.value = self._transfer_items( self._unused,
                                    self._used, self._unused_items, self.value )

    def _on_unuse ( self, event ):
        self.value, self._unused_items = self._transfer_items( self._used,
                                  self._unused, self.value, self._unused_items )

    def _on_use_all ( self, event ):
        self._unused_items, self.value = self._transfer_all( self._unused,
                                    self._used, self._unused_items, self.value )

    def _on_unuse_all (self, event):
        self.value, self._unused_items = self._transfer_all( self._used,
                                 self._unused, self.value, self._unused_items )

    def _on_up ( self, event ):
        self._move_item( -1 )

    def _on_down ( self, event ):
        self._move_item( 1 )

    #---------------------------------------------------------------------------
    #  Private methods:
    #---------------------------------------------------------------------------

    #---------------------------------------------------------------------------
    # Unselects all items in the given ListBox
    #---------------------------------------------------------------------------

    def _clear_selection( self, box ):
        """ Unselects all items in the given ListBox
        """
        for i in box.GetSelections():
            box.SetSelection( i, False )

    #---------------------------------------------------------------------------
    #  Transfers all items from one list to another:
    #---------------------------------------------------------------------------

    def _transfer_all ( self, list_from, list_to, values_from, values_to ):
        """ Transfers all items from one list to another.
        """
        values_from = values_from[:]
        values_to   = values_to[:]

        self._clear_selection( list_from )
        while list_from.GetCount() > 0:
            index_to = list_to.GetCount()
            list_from.SetSelection( 0 )
            list_to.InsertItems( self._get_selected_strings( list_from ),
                                 index_to )
            list_from.Delete( 0 )
            values_to.append( values_from[0] )
            del values_from[ 0 ]

        list_to.SetSelection( 0 )
        self._check_left_right()
        self._check_up_down()

        return ( values_from, values_to )

    #---------------------------------------------------------------------------
    #  Transfers the selected item from one list to another:
    #---------------------------------------------------------------------------

    def _transfer_items ( self, list_from, list_to, values_from, values_to ):
        """ Transfers the selected item from one list to another.
        """
        values_from  = values_from[:]
        values_to    = values_to[:]
        indices_from = list_from.GetSelections()
        index_from   = max( self._get_first_selection( list_from ), 0 )
        index_to     = max( self._get_first_selection( list_to ),   0 )

        self._clear_selection( list_to )

        # Get the list of strings in the "from" box to be moved:
        selected_list = self._get_selected_strings( list_from )

        # fixme: I don't know why I have to reverse the list to get
        # correct behavior from the ordered list box.  Investigate -- LP
        selected_list.reverse()
        list_to.InsertItems( selected_list, index_to )

        # Delete the transferred items from the left box:
        for i in range( len( indices_from ) - 1, -1, -1 ):
            list_from.Delete( indices_from[i] )

        # Delete the transferred items from the "unused" value list:
        for item_label in selected_list:
            val_index_from = values_from.index( self.mapping[ item_label ] )
            values_to.insert( index_to, values_from[ val_index_from ] )
            del values_from[ val_index_from ]

            # If right list is ordered, keep moved items selected:
            if self.factory.ordered:
                list_to.SetSelection( list_to.FindString( item_label ) )

        # Reset the selection in the left box:
        count = list_from.GetCount()
        if count > 0:
            if index_from >= count:
                index_from -= 1
            list_from.SetSelection( index_from )

        self._check_left_right()
        self._check_up_down()

        return ( values_from, values_to )

    #---------------------------------------------------------------------------
    #  Moves an item up or down with the 'used' list:
    #---------------------------------------------------------------------------

    def _move_item ( self, direction ):
        """ Moves an item up or down within the "used" list.
        """
        # Move the item up/down within the list:
        listbox    = self._used
        index_from = self._get_first_selection(listbox)
        index_to   = index_from + direction
        label      = listbox.GetString(index_from)
        listbox.Delete( index_from )
        listbox.Insert( label, index_to )
        listbox.SetSelection( index_to )

        # Enable the up/down buttons appropriately:
        self._check_up_down()

        # Move the item up/down within the editor's trait value:
        value = self.value
        if direction < 0:
            index  = index_to
            values = [ value[ index_from ], value[ index_to ] ]
        else:
            index  = index_from
            values = [ value[ index_to ], value[ index_from ] ]
        self.value = value[ : index ] + values + value[ index + 2: ]

    #---------------------------------------------------------------------------
    #  Sets the proper enable state for the up and down buttons:
    #---------------------------------------------------------------------------

    def _check_up_down ( self ):
        """ Sets the proper enabled state for the up and down buttons.
        """
        if self.factory.ordered:
            index_selected = self._used.GetSelections()
            self._up.Enable( (len( index_selected ) == 1) and
                             (index_selected[0] > 0) )
            self._down.Enable( (len( index_selected ) == 1) and
                            (index_selected[0] < (self._used.GetCount() - 1) ) )

    #---------------------------------------------------------------------------
    #  Sets the proper enable state for the left and right buttons:
    #---------------------------------------------------------------------------

    def _check_left_right ( self ):
        """ Sets the proper enabled state for the left and right buttons.
        """
        self._use.Enable(self._unused.GetCount() > 0 and
                         self._get_first_selection(self._unused) >= 0)
        self._unuse.Enable( self._used.GetCount() > 0 and
                            self._get_first_selection(self._used) >= 0)

        if self.factory.can_move_all:
            self._use_all.Enable( (self._unused.GetCount() > 0) and
                              (self._get_first_selection( self._unused ) >= 0) )
            self._unuse_all.Enable( (self._used.GetCount() > 0) and
                                (self._get_first_selection( self._used ) >= 0) )

    #---------------------------------------------------------------------------
    # Returns a list of the selected strings in the listbox
    #---------------------------------------------------------------------------

    def _get_selected_strings ( self, listbox ):
        """ Returns a list of the selected strings in the given *listbox*.
        """
        stringlist = []
        for label_index in listbox.GetSelections():
            stringlist.append( listbox.GetString( label_index ) )

        return stringlist

    #---------------------------------------------------------------------------
    # Returns the index of the first (or only) selected item.
    #---------------------------------------------------------------------------

    def _get_first_selection ( self, listbox ):
        """ Returns the index of the first (or only) selected item.
        """
        select_list = listbox.GetSelections()
        if len( select_list ) == 0:
            return -1

        return select_list[0]

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = shell_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   09/27/2005
#
#-------------------------------------------------------------------------------

""" Editor that displays an interactive Python shell.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.shell_editor file.
from traitsui.editors.shell_editor \
    import _ShellEditor as BaseShellEditor, ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'ShellEditor' class:
#-------------------------------------------------------------------------------

class _ShellEditor ( BaseShellEditor, Editor ):
    """ Editor that displays an interactive Python shell.
    """
    pass

########NEW FILE########
__FILENAME__ = table_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/01/2005
#
#------------------------------------------------------------------------------

""" Defines the table editor for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Int, List, Instance, Str, Any, Button, Tuple, \
           HasPrivateTraits, Bool, Event, Property

from traitsui.api \
    import View, Item, UI, InstanceEditor, EnumEditor, Handler, SetEditor, \
           ListUndoItem

from traitsui.editors.table_editor \
    import BaseTableEditor, customize_filter

from traitsui.menu \
    import Action, ToolBar

from traitsui.table_column \
    import TableColumn, ObjectColumn

from traitsui.table_filter \
    import TableFilter

from traitsui.ui_traits \
    import SequenceTypes

from pyface.ui.wx.grid.api \
    import Grid

from pyface.dock.api \
    import DockWindow, DockSizer, DockSection, DockRegion, DockControl

from pyface.image_resource \
    import ImageResource

from pyface.timer.api \
    import do_later

from editor \
    import Editor

from table_model \
    import TableModel, TraitGridSelection

from helper import TraitsUIPanel

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping from TableEditor selection modes to Grid selection modes:
GridModes = {
    'row':     'rows',
    'rows':    'rows',
    'column':  'cols',
    'columns': 'cols',
    'cell':    'cell',
    'cells':   'cell'
}

#-------------------------------------------------------------------------------
#  'TableEditor' class:
#-------------------------------------------------------------------------------

class TableEditor ( Editor, BaseTableEditor ):
    """ Editor that presents data in a table. Optionally, tables can have
        a set of filters that reduce the set of data displayed, according to
        their criteria.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The set of columns currently defined on the editor:
    columns = List( TableColumn )

    # Index of currently edited (i.e., selected) table item(s):
    selected_row_index      = Int( -1 )
    selected_row_indices    = List( Int )
    selected_indices        = Property

    selected_column_index   = Int( -1 )
    selected_column_indices = List( Int )

    selected_cell_index     = Tuple( Int, Int )
    selected_cell_indices   = List( Tuple( Int, Int ) )

    # The currently selected table item(s):
    selected_row     = Any
    selected_rows    = List
    selected_items   = Property

    selected_column  = Any
    selected_columns = List

    selected_cell    = Tuple( Any, Str )
    selected_cells   = List( Tuple( Any, Str ) )

    selected_values  = Property

    # The indices of the table items currently passing the table filter:
    filtered_indices = List( Int )

    # The event fired when a cell is clicked on:
    click = Event

    # The event fired when a cell is double-clicked on:
    dclick = Event

    # Is the editor in row mode (i.e. not column or cell mode)?
    in_row_mode = Property

    # Is the editor in column mode (i.e. not row or cell mode)?
    in_column_mode = Property

    # Current filter object (should be a TableFilter or callable or None):
    filter = Any

    # The grid widget associated with the editor:
    grid = Instance( Grid )

    # The table model associated with the editor:
    model = Instance( TableModel )

    # TableEditorToolbar associated with the editor:
    toolbar = Any

    # The Traits UI associated with the table editor toolbar:
    toolbar_ui = Instance( UI )

    # Is the table editor scrollable? This value overrides the default.
    scrollable = True

    # Is 'auto_add' mode in effect? (I.e., new rows are automatically added to
    # the end of the table when the user modifies current last row.)
    auto_add = Bool( False )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """

        factory       = self.factory
        self.filter   = factory.filter
        self.auto_add = (factory.auto_add and (factory.row_factory is not None))

        columns = factory.columns[:]
        if (len( columns ) == 0) and (len( self.value ) > 0):
            columns = [ ObjectColumn( name = name )
                        for name in self.value[0].editable_traits() ]
        self.columns = columns

        self.model = model = TableModel(
                                editor         = self,
                                reverse        = factory.reverse )
        model.on_trait_change( self._model_sorted, 'sorted', dispatch = 'ui' )
        mode     = factory.selection_mode
        row_mode = mode in ( 'row', 'rows' )
        selected = None
        items    = model.get_filtered_items()
        if factory.editable and (len( items ) > 0):
            selected = items[0]
        if (factory.edit_view == ' ') or (not row_mode):
            self.control = panel = TraitsUIPanel( parent, -1 )
            sizer        = wx.BoxSizer( wx.VERTICAL )
            self._create_toolbar( panel, sizer )

            # Create the table (i.e. grid) control:
            hsizer = wx.BoxSizer( wx.HORIZONTAL )
            self._create_grid( panel, hsizer )
            sizer.Add( hsizer, 1, wx.EXPAND )
        else:
            item         = self.item
            name         = item.get_label( self.ui )
            theme        = factory.dock_theme or item.container.dock_theme
            self.control = dw = DockWindow( parent, theme = theme ).control
            panel        = TraitsUIPanel( dw, -1, size = ( 300, 300 ) )
            sizer        = wx.BoxSizer( wx.VERTICAL )
            dc           = DockControl( name    = name + ' Table',
                                        id      = 'table',
                                        control = panel,
                                        style   = 'fixed' )
            contents     = [ DockRegion( contents = [ dc ] ) ]
            self._create_toolbar( panel, sizer )
            selected = None
            items    = model.get_filtered_items()
            if factory.editable and (len( items ) > 0):
                selected = items[0]

            # Create the table (i.e. grid) control:
            hsizer = wx.BoxSizer( wx.HORIZONTAL )
            self._create_grid( panel, hsizer )
            sizer.Add( hsizer, 1, wx.EXPAND )

            # Assign the initial object here, so a valid editor will be built
            # when the 'edit_traits' call is made:
            self.selected_row = selected
            self._ui = ui = self.edit_traits(
                     parent = dw,
                     kind   = 'subpanel',
                     view   = View( [ Item( 'selected_row',
                                          style  = 'custom',
                                          editor = InstanceEditor(
                                                       view = factory.edit_view,
                                                       kind = 'subpanel' ),
                                          resizable = True,
                                          width  = factory.edit_view_width,
                                          height = factory.edit_view_height ),
                                      '|<>' ],
                                    resizable = True,
                                    handler   = factory.edit_view_handler ) )

            # Set the parent UI of the new UI to our own UI:
            ui.parent = self.ui

            # Reset the object so that the sub-sub-view will pick up the
            # correct history also:
            self.selected_row = None
            self.selected_row = selected

            dc.style = item.dock
            contents.append( DockRegion( contents = [
                                 DockControl( name    = name + ' Editor',
                                              id      = 'editor',
                                              control = ui.control,
                                              style   = item.dock ) ] ) )

            # Finish setting up the DockWindow:
            dw.SetSizer( DockSizer( contents = DockSection(
                          contents = contents,
                          is_row   = (factory.orientation == 'horizontal') ) ) )

        # Set up the required externally synchronized traits (if any):
        sv      = self.sync_value
        is_list = (mode[-1] == 's')
        sv( factory.click,  'click',  'to' )
        sv( factory.dclick, 'dclick', 'to' )
        sv( factory.filter_name,  'filter',  'from' )
        sv( factory.columns_name, 'columns', is_list = True )
        sv( factory.filtered_indices, 'filtered_indices', 'to' )
        sv( factory.selected, 'selected_%s' % mode, is_list = is_list )
        if is_list:
            sv( factory.selected_indices, 'selected_%s_indices' % mode[:-1],
                is_list = True )
        else:
            sv( factory.selected_indices, 'selected_%s_index' % mode )

        # Listen for the selection changing on the grid:
        self.grid.on_trait_change(
            getattr( self, '_selection_%s_updated' % mode ),
            'selection_changed', dispatch = 'ui' )

        # Make sure the selection is initialized:
        if row_mode:
            self.set_selection( items[0:1] )
        else:
            self.set_selection()


        # Set the min height of the grid panel to 0, this will provide
        # a scrollbar if the window is resized such that only the first row
        # is visible
        panel.SetMinSize((-1, 0))

        # Finish the panel layout setup:
        panel.SetSizer( sizer )


    #---------------------------------------------------------------------------
    #  Creates the associated grid control used to implement the table:
    #---------------------------------------------------------------------------

    def _create_grid ( self, parent, sizer ):
        """ Creates the associated grid control used to implement the table.
        """
        factory        = self.factory
        selection_mode = GridModes[ factory.selection_mode ]
        if factory.selection_bg_color is None:
            selection_mode = ''

        self.grid = grid = Grid( parent,
            model                        = self.model,
            enable_lines                 = factory.show_lines,
            grid_line_color              = factory.line_color,
            show_row_headers             = factory.show_row_labels,
            show_column_headers          = factory.show_column_labels,
            default_cell_font            = factory.cell_font,
            default_cell_text_color      = factory.cell_color,
            default_cell_bg_color        = factory.cell_bg_color,
            default_cell_read_only_color = factory.cell_read_only_bg_color,
            default_label_font           = factory.label_font,
            default_label_text_color     = factory.label_color,
            default_label_bg_color       = factory.label_bg_color,
            selection_bg_color           = factory.selection_bg_color,
            selection_text_color         = factory.selection_color,
            autosize                     = factory.auto_size,
            read_only                    = not factory.editable,
            edit_on_first_click          = factory.edit_on_first_click,
            selection_mode               = selection_mode,
            allow_column_sort            = factory.sortable,
            allow_row_sort               = False,
            column_label_height          = factory.column_label_height,
            row_label_width              = factory.row_label_width
        )
        _grid = grid._grid
        _grid.SetScrollLineY( factory.scroll_dy )

        # Set the default size for each table row:
        height = factory.row_height
        if height <= 0:
            height = _grid.GetTextExtent( 'My' )[1] + 9
        _grid.SetDefaultRowSize( height )

        # Allow the table to be resizable if the user did not explicitly
        # specify a number of rows to display:
        self.scrollable = (factory.rows == 0)

        # Calculate a reasonable default size for the table:
        if len( self.model.get_filtered_items() ) > 0:
            height = _grid.GetRowSize( 0 )

        max_rows = factory.rows or 15

        min_width = max( 150, 80 * len( self.columns ) )

        if factory.show_column_labels:
            min_height = _grid.GetColLabelSize() + (max_rows * height)
        else:
            min_height = (max_rows * height)

        _grid.SetMinSize(wx.Size(min_width, min_height))

        # On Linux, there is what appears to be a bug in wx in which the
        # vertical scrollbar will not be sized properly if the TableEditor is
        # sized to be shorter than the minimum height specified above. Since
        # this height is only set to ensure that the TableEditor is sized
        # correctly during the initial UI layout, we un-set it after this takes
        # place (addresses ticket 1810)
        def clear_minimum_height ( info ):
            min_size = _grid.GetMinSize()
            min_size.height = 0
            _grid.SetMinSize ( min_size )
        self.ui.add_defined ( clear_minimum_height )

        sizer.Add( grid.control, 1, wx.EXPAND )

        return grid.control

    #---------------------------------------------------------------------------
    #  Creates the table editing tool bar:
    #---------------------------------------------------------------------------

    def _create_toolbar ( self, parent, sizer ):
        """ Creates the table editing toolbar.
        """

        factory = self.factory
        if not factory.show_toolbar:
            return

        toolbar = TableEditorToolbar( parent = parent, editor = self )
        if (toolbar.control is not None) or (len( factory.filters ) > 0):
            tb_sizer = wx.BoxSizer( wx.HORIZONTAL )

            if len( factory.filters ) > 0:
                view = View( [ Item( 'filter<250>{View}',
                                     editor = factory._filter_editor ), '_',
                               Item( 'filter_summary<100>{Results}~',
                                     object = 'model', resizable = False ), '_',
                               '-' ],
                             resizable = True )
                self.toolbar_ui = ui = view.ui(
                              context = { 'object': self, 'model': self.model },
                              parent  = parent,
                              kind    = 'subpanel' ).set(
                              parent  = self.ui )
                tb_sizer.Add( ui.control, 0 )

            if toolbar.control is not None:
                self.toolbar = toolbar
                # add padding so the toolbar is right aligned
                tb_sizer.Add( ( 1, 1 ), 1, wx.EXPAND )
                tb_sizer.Add( toolbar.control, 0 )

            sizer.Add( tb_sizer, 0, wx.ALIGN_RIGHT | wx.EXPAND )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self.toolbar_ui is not None:
            self.toolbar_ui.dispose()

        if self._ui is not None:
            self._ui.dispose()

        self.grid.on_trait_change( getattr( self,
            '_selection_%s_updated' % self.factory.selection_mode ),
            'selection_changed', remove = True )

        self.model.on_trait_change( self._model_sorted, 'sorted',
                                    remove = True )

        self.grid.dispose()
        self.model.dispose()

        # Break any links needed to allow garbage collection:
        self.grid = self.model = self.toolbar = None

        super( TableEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # fixme: Do we need to override this method?
        pass

    #---------------------------------------------------------------------------
    #  Refreshes the editor control:
    #---------------------------------------------------------------------------

    def refresh ( self ):
        """ Refreshes the editor control.
        """
        self.grid._grid.Refresh()

    #---------------------------------------------------------------------------
    #  Sets the current selection to a set of specified objects:
    #---------------------------------------------------------------------------

    def set_selection ( self, objects = [], notify = True ):
        """ Sets the current selection to a set of specified objects.
        """
        if not isinstance( objects, SequenceTypes ):
            objects = [ objects ]

        self.grid.set_selection( [ TraitGridSelection( obj = object )
                                   for object in objects ], notify = notify )

    #---------------------------------------------------------------------------
    #  Sets the current selection to a set of specified object/column pairs:
    #---------------------------------------------------------------------------

    def set_extended_selection ( self, *pairs ):
        """ Sets the current selection to a set of specified object/column
            pairs.
        """
        if (len( pairs ) == 1) and isinstance( pairs[0], list ):
            pairs = pairs[0]

        grid_selections = [TraitGridSelection(obj = object, name = name)
                           for object, name in pairs]

        self.grid.set_selection(grid_selections)

    #---------------------------------------------------------------------------
    #  Creates a new row object using the provided factory:
    #---------------------------------------------------------------------------

    def create_new_row ( self ):
        """ Creates a new row object using the provided factory.
        """
        factory = self.factory
        kw      = factory.row_factory_kw.copy()
        if '__table_editor__' in kw:
            kw[ '__table_editor__' ] = self

        return self.ui.evaluate( factory.row_factory,
                                 *factory.row_factory_args, **kw  )

    #---------------------------------------------------------------------------
    #  Adds a new object as a new row after the currently selected indices:
    #---------------------------------------------------------------------------

    def add_row ( self, object = None, index = None ):
        """ Adds a specified object as a new row after the specified index.
        """
        filtered_items = self.model.get_filtered_items

        if index is None:
            indices = self.selected_indices
            if len( indices ) == 0:
                indices = [ len( filtered_items() ) - 1 ]
            indices.reverse()
        else:
            indices = [ index ]

        if object is None:
            objects = []
            for index in indices:
                object = self.create_new_row()
                if object is None:
                    if self.in_row_mode:
                        self.set_selection()
                    return

                objects.append( object )
        else:
            objects = [ object ]

        items             = []
        insert_item_after = self.model.insert_filtered_item_after
        in_row_mode       = self.in_row_mode
        for i, index in enumerate( indices ):
            object = objects[i]
            index, extend = insert_item_after( index, object )

            if in_row_mode and (object in filtered_items()):
                items.append( object )

            self._add_undo( ListUndoItem( object = self.object,
                                          name   = self.name,
                                          index  = index,
                                          added  = [ object ] ), extend )

        if in_row_mode:
            self.set_selection( items )

    #---------------------------------------------------------------------------
    #  Moves a column from one place to another:
    #---------------------------------------------------------------------------

    def move_column ( self, from_column, to_column ):
        """ Moves the specified **from_column** from its current position to
            just preceding the specified **to_column**.
        """
        columns = self.columns
        frm     = columns.index( from_column )
        if to_column is None:
            to = len( columns )
        else:
            to = columns.index( to_column )
        del columns[ frm ]
        columns.insert( to - (frm < to), from_column )

        return True

    #-- Property Implementations -----------------------------------------------

    def _get_selected_indices ( self ):
        sm = self.factory.selection_mode
        if sm == 'rows':
            return self.selected_row_indices

        elif sm == 'row':
            index = self.selected_row_index
            if index >= 0:
                return [ index ]

        elif sm == 'cells':
            return list( set( [ row_col[0] for
                                row_col in self.selected_cell_indices ] ) )

        elif sm == 'cell':
            index = self.selected_cell_index[0]
            if index >= 0:
                return [ index ]

        return []

    def _get_selected_items ( self ):
        sm = self.factory.selection_mode
        if sm == 'rows':
            return self.selected_rows

        elif sm == 'row':
            item = self.selected_row
            if item is not None:
                return [ item ]

        elif sm == 'cells':
            return list( set( [ item_name[0]
                                for item_name in self.selected_cells ] ) )

        elif sm == 'cell':
            item = self.selected_cell[0]
            if item is not None:
                return [ item ]

        return []

    def _get_selected_values ( self ):
        if self.in_row_mode:
            return [ ( item, '' ) for item in self.selected_items ]

        if self.in_column_mode:
            if self.factory.selection_mode == 'columns':
                return [ ( None, column ) for column in self.selected_columns ]

            column = self.selected_column
            if column != '':
                return [ ( None, column ) ]

            return []

        if self.factory.selection_mode == 'cells':
            return self.selected_cells

        item = self.selected_cell
        if item[0] is not None:
            return [ item ]

        return []

    def _get_in_row_mode ( self ):
        return (self.factory.selection_mode in ( 'row', 'rows' ))

    def _get_in_column_mode ( self ):
        return (self.factory.selection_mode in ( 'column', 'columns' ))

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        factory = self.factory
        try:
            filters = prefs.get( 'filters', None )
            if filters is not None:
                factory.filters = ([ f for f in factory.filters if f.template ]
                                 + [ f for f in filters if not f.template ])

            columns = prefs.get( 'columns' )
            if columns is not None:
                new_columns = []
                all_columns = self.columns + factory.other_columns
                for column in columns:
                    for column2 in all_columns:
                        if column == column2.get_label():
                            new_columns.append( column2 )
                            break
                self.columns = new_columns

                # Restore the column sizes if possible:
                if not factory.auto_size:
                    widths = prefs.get( 'widths' )
                    if widths is not None:
                        # fixme: Talk to Jason about a better way to do this:
                        self.grid._user_col_size = True

                        set_col_size = self.grid._grid.SetColSize
                        for i, width in enumerate( widths ):
                            if width >= 0:
                                set_col_size( i, width )

            structure = prefs.get( 'structure' )
            if (structure is not None) and (factory.edit_view != ' '):
                self.control.GetSizer().SetStructure( self.control, structure )
        except:
            pass

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        get_col_size = self.grid._grid.GetColSize
        result = {
            'filters': [ f for f in self.factory.filters if not f.template ],
            'columns': [ c.get_label() for c in self.columns ],
            'widths':  [ get_col_size( i )
                         for i in range( len( self.columns ) ) ]
        }

        if self.factory.edit_view != ' ':
            result[ 'structure' ] = self.control.GetSizer().GetStructure()

        return result

    #-- Public Methods ---------------------------------------------------------

    def filter_modified ( self ):
        """ Handles updating the selection when some aspect of the current
            filter has changed.
        """
        values = self.selected_values
        if len( values ) > 0:
            if self.in_column_mode:
                self.set_extended_selection( values )
            else:
                items = self.model.get_filtered_items()
                self.set_extended_selection(
                         [ item for item in values if item[0] in items ] )

    #-- Event Handlers ---------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles the user selecting items (rows, columns, cells) in the table:
    #---------------------------------------------------------------------------

    def _selection_row_updated ( self, event ):
        """ Handles the user selecting items (rows, columns, cells) in the
            table.
        """
        gfi  = self.model.get_filtered_item
        rio  = self.model.raw_index_of
        tl   = self.grid._grid.GetSelectionBlockTopLeft()
        br   = iter( self.grid._grid.GetSelectionBlockBottomRight() )
        rows = len( self.model.get_filtered_items() )
        if self.auto_add:
            rows -= 1

        # Get the row items and indices in the selection:
        values = []
        for row0, col0 in tl:
            row1, col1 = br.next()
            for row in xrange( row0, row1 + 1 ):
                if row < rows:
                    values.append( ( rio( row ), gfi( row ) ) )

        if len( values ) > 0:
            # Sort by increasing row index:
            values.sort( lambda l, r: cmp( l[0], r[0] ) )
            index, row = values[0]
        else:
            index, row = -1, None

        # Save the new selection information:
        self.set( selected_row_index  = index,
                  trait_change_notify = False )
        self.setx( selected_row = row )

        # Update the toolbar status:
        self._update_toolbar( row is not None )

        # Invoke the user 'on_select' handler:
        self.ui.evaluate( self.factory.on_select, row )

    def _selection_rows_updated ( self, event ):
        """ Handles multiple row selection changes.
        """
        gfi  = self.model.get_filtered_item
        rio  = self.model.raw_index_of
        tl   = self.grid._grid.GetSelectionBlockTopLeft()
        br   = iter( self.grid._grid.GetSelectionBlockBottomRight() )
        rows = len( self.model.get_filtered_items() )
        if self.auto_add:
            rows -= 1

        # Get the row items and indices in the selection:
        values = []
        for row0, col0 in tl:
            row1, col1 = br.next()
            for row in xrange( row0, row1 + 1 ):
                if row < rows:
                    values.append( ( rio( row ), gfi( row ) ) )

        # Sort by increasing row index:
        values.sort( lambda l, r: cmp( l[0], r[0] ) )

        # Save the new selection information:
        self.trait_set( selected_row_indices = [ v[0] for v in values ],
                        trait_change_notify  = False )
        rows = [ v[1] for v in values ]
        self.setx( selected_rows = rows )

        # Update the toolbar status:
        self._update_toolbar( len( values ) > 0 )

        # Invoke the user 'on_select' handler:
        self.ui.evaluate( self.factory.on_select, rows )

    def _selection_column_updated ( self, event ):
        """ Handles single column selection changes.
        """
        cols = self.columns
        tl   = self.grid._grid.GetSelectionBlockTopLeft()
        br   = iter( self.grid._grid.GetSelectionBlockBottomRight() )

        # Get the column items and indices in the selection:
        values = []
        for row0, col0 in tl:
            row1, col1 = br.next()
            for col in xrange( col0, col1 + 1 ):
                values.append( ( col, cols[ col ].name ) )

        if len( values ) > 0:
            # Sort by increasing column index:
            values.sort( lambda l, r: cmp( l[0], r[0] ) )
            index, column = values[0]
        else:
            index, column = -1, ''

        # Save the new selection information:
        self.set( selected_column_index = index,
                  trait_change_notify   = False )
        self.setx( selected_column = column )

        # Invoke the user 'on_select' handler:
        self.ui.evaluate( self.factory.on_select, column )

    def _selection_columns_updated ( self, event ):
        """ Handles multiple column selection changes.
        """
        cols = self.columns
        tl   = self.grid._grid.GetSelectionBlockTopLeft()
        br   = iter( self.grid._grid.GetSelectionBlockBottomRight() )

        # Get the column items and indices in the selection:
        values = []
        for row0, col0 in tl:
            row1, col1 = br.next()
            for col in xrange( col0, col1 + 1 ):
                values.append( ( col, cols[ col ].name ) )

        # Sort by increasing row index:
        values.sort( lambda l, r: cmp( l[0], r[0] ) )

        # Save the new selection information:
        self.set( selected_column_indices = [ v[0] for v in values ],
                  trait_change_notify     = False )
        columns = [ v[1] for v in values ]
        self.setx( selected_columns = columns )

        # Invoke the user 'on_select' handler:
        self.ui.evaluate( self.factory.on_select, columns )

    def _selection_cell_updated ( self, event ):
        """ Handles single cell selection changes.
        """
        tl = self.grid._grid.GetSelectionBlockTopLeft()
        if len( tl ) == 0:
            return

        gfi  = self.model.get_filtered_item
        rio  = self.model.raw_index_of
        cols = self.columns
        br   = iter( self.grid._grid.GetSelectionBlockBottomRight() )

        # Get the column items and indices in the selection:
        values = []
        for row0, col0 in tl:
            row1, col1 = br.next()
            for row in xrange( row0, row1 + 1 ):
                item = gfi( row )
                for col in xrange( col0, col1 + 1 ):
                    values.append( ( ( rio( row ), col ),
                                     ( item, cols[ col ].name ) ) )

        if len( values ) > 0:
            # Sort by increasing row, column index:
            values.sort( lambda l, r: cmp( l[0], r[0] ) )
            index, cell = values[0]
        else:
            index, cell = ( -1, -1 ), ( None, '' )

        # Save the new selection information:
        self.set( selected_cell_index = index,
                  trait_change_notify = False )
        self.setx( selected_cell = cell )

        # Update the toolbar status:
        self._update_toolbar( len( values ) > 0 )

        # Invoke the user 'on_select' handler:
        self.ui.evaluate( self.factory.on_select, cell )

    def _selection_cells_updated ( self, event ):
        """ Handles multiple cell selection changes.
        """
        gfi  = self.model.get_filtered_item
        rio  = self.model.raw_index_of
        cols = self.columns
        tl   = self.grid._grid.GetSelectionBlockTopLeft()
        br   = iter( self.grid._grid.GetSelectionBlockBottomRight() )

        # Get the column items and indices in the selection:
        values = []
        for row0, col0 in tl:
            row1, col1 = br.next()
            for row in xrange( row0, row1 + 1 ):
                item = gfi( row )
                for col in xrange( col0, col1 + 1 ):
                    values.append( ( ( rio( row ), col ),
                                     ( item, cols[ col ].name ) ) )

        # Sort by increasing row, column index:
        values.sort( lambda l, r: cmp( l[0], r[0] ) )

        # Save the new selection information:
        self.setx( selected_cell_indices = [ v[0] for v in values ])
        cells = [ v[1] for v in values ]
        self.setx( selected_cells = cells )

        # Update the toolbar status:
        self._update_toolbar( len( cells ) > 0 )

        # Invoke the user 'on_select' handler:
        self.ui.evaluate( self.factory.on_select, cells )

    def _selected_row_changed ( self, item ):
        if not self._no_notify:
            if item is None:
                self.set_selection( notify = False )
            else:
                self.set_selection( item, notify = False )

    def _selected_row_index_changed ( self, row ):
        if not self._no_notify:
            if row < 0:
                self.set_selection( notify = False )
            else:
                self.set_selection( self.value[ row ], notify = False )

    def _selected_rows_changed ( self, items ):
        if not self._no_notify:
            self.set_selection( items, notify = False )

    def _selected_row_indices_changed ( self, indices ):
        if not self._no_notify:
            value = self.value
            self.set_selection( [ value[i] for i in indices ], notify = False )

    def _selected_column_changed ( self, name ):
        if not self._no_notify:
            self.set_extended_selection( ( None, name ) )

    def _selected_column_index_changed ( self, index ):
        if not self._no_notify:
            if index < 0:
                self.set_extended_selection()
            else:
                self.set_extended_selection(
                    ( None, self.model.get_column_name[ index ] ) )

    def _selected_columns_changed ( self, names ):
        if not self._no_notify:
            self.set_extended_selection( [ ( None, name ) for name in names ] )

    def _selected_column_indices_changed ( self, indices ):
        if not self._no_notify:
            gcn = self.model.get_column_name
            self.set_extended_selection( [ ( None, gcn(i) ) for i in indices ] )

    def _selected_cell_changed ( self, cell ):
        if not self._no_notify:
            self.set_extended_selection( [ cell ] )

    def _selected_cell_index_changed ( self, pair ):
        if not self._no_notify:
            row, column = pair
            if (row < 0) or (column < 0):
                self.set_extended_selection()
            else:
                self.set_extended_selection(
                    ( self.value[ row ],
                      self.model.get_column_name[ column ] ) )

    def _selected_cells_changed ( self, cells ):
        if not self._no_notify:
            self.set_extended_selection( cells )

    def _selected_cell_indices_changed ( self, pairs ):
        if not self._no_notify:
            value = self.value
            gcn   = self.model.get_column_name
            new_selection = [(value[row], gcn(col)) for row, col in pairs]
            self.set_extended_selection(new_selection)

    def _update_toolbar ( self, has_selection ):
        """ Updates the toolbar after a selection change.
        """
        toolbar = self.toolbar
        if toolbar is not None:
            no_filter = (self.filter is None)
            if has_selection:
                indices = self.selected_indices
                start   = indices[0]
                n       = len( self.model.get_filtered_items() ) - 1
                delete  = toolbar.delete
                if self.auto_add:
                    n -= 1
                    delete.enabled = (start <= n)
                else:
                    delete.enabled = True

                deletable = self.factory.deletable
                if delete.enabled and callable( deletable ):
                    delete.enabled = reduce( lambda l, r: l and r,
                        [ deletable( item ) for item in self.selected_items ],
                        True )

                toolbar.search.enabled    = toolbar.add.enabled = True
                toolbar.move_up.enabled   = (no_filter and (start > 0))
                toolbar.move_down.enabled = (no_filter and (indices[-1] < n))
            else:
                toolbar.add.enabled     = no_filter
                toolbar.search.enabled  = toolbar.delete.enabled    = \
                toolbar.move_up.enabled = toolbar.move_down.enabled = False

    #---------------------------------------------------------------------------
    #  Handles the contents of the model being resorted:
    #---------------------------------------------------------------------------

    def _model_sorted ( self ):
        """ Handles the contents of the model being resorted.
        """
        if self.toolbar is not None:
            self.toolbar.no_sort.enabled = True

        values = self.selected_values
        if len( values ) > 0:
            do_later( self.set_extended_selection, values )

    #---------------------------------------------------------------------------
    #  Handles the current filter being changed:
    #---------------------------------------------------------------------------

    def _filter_changed ( self, old_filter, new_filter ):
        """ Handles the current filter being changed.
        """
        if new_filter is customize_filter:
            do_later( self._customize_filters, old_filter )

        elif self.model is not None:
            if ((new_filter is not None) and
                (not isinstance( new_filter, TableFilter ))):
                new_filter = TableFilter( allowed = new_filter )
            self.model.filter = new_filter
            self.filter_modified()

    #---------------------------------------------------------------------------
    #  Refresh the list of available filters:
    #---------------------------------------------------------------------------

    def _refresh_filters ( self, filters ):
        factory = self.factory
        # hack: The following line forces the 'filters' to be changed...
        factory.filters = []
        factory.filters = filters

    #---------------------------------------------------------------------------
    #  Allows the user to customize the current set of table filters:
    #---------------------------------------------------------------------------

    def _customize_filters ( self, filter ):
        """ Allows the user to customize the current set of table filters.
        """
        factory = self.factory
        filter_editor = TableFilterEditor( editor = self, filter = filter )
        enum_editor   = EnumEditor( values = factory.filters[:], mode = 'list' )
        ui = filter_editor.edit_traits( parent = self.control, view = View(
            [ [ Item( 'filter<200>@',
                      editor    = enum_editor,
                      resizable = True ),
                '|<>' ],
              [ 'edit:edit', 'new', 'apply', 'delete:delete',
                '|<>' ],
              '-' ],
            title   = 'Customize Filters',
            kind    = 'livemodal',
            height  = .25,
            buttons = [ 'OK', 'Cancel' ] ) )

        if ui.result:
            self._refresh_filters( enum_editor.values )
            self.filter = filter_editor.filter
        else:
            self.filter = filter

    #---------------------------------------------------------------------------
    #  Handles the user requesting that columns not be sorted:
    #---------------------------------------------------------------------------

    def on_no_sort ( self ):
        """ Handles the user requesting that columns not be sorted.
        """
        self.model.no_column_sort()
        self.toolbar.no_sort.enabled = False
        values = self.selected_values
        if len( values ) > 0:
            self.set_extended_selection( values )

    #---------------------------------------------------------------------------
    #  Handles the user requesting to move the current item up one row:
    #---------------------------------------------------------------------------

    def on_move_up ( self ):
        """ Handles the user requesting to move the current item up one row.
        """
        model   = self.model
        objects = []
        for index in self.selected_indices:
            objects.append( model.get_filtered_item( index ) )
            index -= 1
            object = model.get_filtered_item( index )
            model.delete_filtered_item_at( index )
            model.insert_filtered_item_after( index, object )

        if self.in_row_mode:
            self.set_selection( objects )
        else:
            self.set_extended_selection( self.selected_values )

    #---------------------------------------------------------------------------
    #  Handles the user requesting to move the current item down one row:
    #---------------------------------------------------------------------------

    def on_move_down ( self ):
        """ Handles the user requesting to move the current item down one row.
        """
        model   = self.model
        objects = []
        indices = self.selected_indices[:]
        indices.reverse()
        for index in indices:
            object = model.get_filtered_item( index )
            objects.append( object )
            model.delete_filtered_item_at( index )
            model.insert_filtered_item_after( index, object )

        if self.in_row_mode:
            self.set_selection( objects )
        else:
            self.set_extended_selection( self.selected_values )

    #---------------------------------------------------------------------------
    #  Handles the user requesting a table search:
    #---------------------------------------------------------------------------

    def on_search ( self ):
        """ Handles the user requesting a table search.
        """
        self.factory.search.edit_traits(
            parent  = self.control,
            view    = 'searchable_view',
            handler = TableSearchHandler( editor = self )
        )

    #---------------------------------------------------------------------------
    #  Handles the user requesting to add a new row to the table:
    #---------------------------------------------------------------------------

    def on_add ( self ):
        """ Handles the user requesting to add a new row to the table.
        """
        self.add_row()

    #---------------------------------------------------------------------------
    #  Handles the user requesting to delete the currently selected items of the
    #  table:
    #---------------------------------------------------------------------------

    def on_delete ( self ):
        """ Handles the user requesting to delete the currently selected items
            of the table.
        """
        # Get the selected row indices:
        indices = self.selected_indices[:]
        values  = self.selected_values[:]
        indices.reverse()

        # Make sure that we don't delete any rows while an editor is open in it
        self.grid.stop_editing_indices(indices)

        # Delete the selected rows:
        for i in indices:
            index, object = self.model.delete_filtered_item_at( i )
            self._add_undo( ListUndoItem( object  = self.object,
                                          name    = self.name,
                                          index   = index,
                                          removed = [ object ] ) )

        # Compute the new selection and set it:
        items = self.model.get_filtered_items()
        n     = len( items ) - 1
        indices.reverse()
        for i in range( len( indices ) - 1, -1, -1 ):
            if indices[i] > n:
                indices[i] = n
                if indices[i] < 0:
                    del indices[i]
                    del values[i]

        n = len( indices )
        if n > 0:
            if self.in_row_mode:
                self.set_selection(
                    list( set( [ items[i] for i in indices ] ) ) )
            else:
                self.set_extended_selection(
                    list( set( [ ( items[ indices[i] ], values[i][1] )
                                 for i in range( n ) ] ) ) )
        else:
            self._update_toolbar( False )

    #---------------------------------------------------------------------------
    #  Handles the user requesting to set the user preference items for the
    #  table:
    #---------------------------------------------------------------------------

    def on_prefs ( self ):
        """ Handles the user requesting to set the user preference items for the
            table.
        """
        columns = self.columns[:]
        columns.extend( [ c
            for c in (self.factory.columns + self.factory.other_columns)
            if c not in columns ] )
        self.edit_traits(
            parent = self.control,
            view   = View( [ Item( 'columns',
                                resizable = True,
                                editor    = SetEditor( values       = columns,
                                                       ordered      = True,
                                                       can_move_all = False ) ),
                             '|<>' ],
                         title     = 'Select and Order Columns',
                         width     = 0.3,
                         height    = 0.3,
                         resizable = True,
                         buttons   = [ 'Undo', 'OK', 'Cancel' ],
                         kind      = 'livemodal' ) )

    #---------------------------------------------------------------------------
    #  Prepares to have a context menu action called:
    #---------------------------------------------------------------------------

    def prepare_menu ( self, row, column ):
        """ Prepares to have a context menu action called.
        """
        object    = self.model.get_filtered_item( row )
        selection = [ x.obj for x in self.grid.get_selection() ]
        if object not in selection:
            self.set_selection( object )
            selection = [ object ]
        self.set_menu_context( selection, object, column )

    #---------------------------------------------------------------------------
    #  Set one or more attributes without notifying the grid model:
    #---------------------------------------------------------------------------

    def setx ( self, **keywords ):
        """ Set one or more attributes without notifying the grid model.
        """
        self._no_notify = True

        for name, value in keywords.items():
            setattr( self, name, value )

        self._no_notify = False

#-- Private Methods: -----------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Adds an 'undo' item to the undo history (if any):
    #---------------------------------------------------------------------------

    def _add_undo ( self, undo_item, extend = False ):
        history = self.ui.history
        if history is not None:
            history.add( undo_item, extend )

#-------------------------------------------------------------------------------
#  'TableFilterEditor' class:
#-------------------------------------------------------------------------------

class TableFilterEditor ( Handler ):
    """ Editor that manages table filters.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # TableEditor this editor is associated with
    editor = Instance( TableEditor )

    # Current filter
    filter = Instance( TableFilter, allow_none = True )

    # Edit the current filter
    edit = Button

    # Create a new filter and edit it
    new = Button

    # Apply the current filter to the editor's table
    apply = Button

    # Delete the current filter
    delete = Button

    #---------------------------------------------------------------------------
    #  'Handler' interface:
    #---------------------------------------------------------------------------

    def init ( self, info ):
        """ Initializes the controls of a user interface.
        """
        # Save both the original filter object reference and its contents:
        if self.filter is None:
            self.filter = info.filter.factory.values[0]
        self._filter = self.filter
        self._filter_copy = self.filter.clone_traits()

    def closed ( self, info, is_ok ):
        """ Handles a dialog-based user interface being closed by the user.
        """
        if not is_ok:
            # Restore the contents of the original filter:
            self._filter.copy_traits( self._filter_copy )

    #---------------------------------------------------------------------------
    #  Event handlers:
    #---------------------------------------------------------------------------

    def object_filter_changed ( self, info ):
        """ Handles a new filter being selected.
        """
        filter              = info.object.filter
        info.edit.enabled   = (not filter.template)
        info.delete.enabled = ((not filter.template) and
                               (len( info.filter.factory.values ) > 1))

    def object_edit_changed ( self, info ):
        """ Handles the user clicking the **Edit** button.
        """
        if info.initialized:
            items = self.editor.model.get_filtered_items()
            if len(items) > 0:
                item = items[0]
            else:
                item = None
            # `item` is now either the first item in the table, or None if
            # the table is empty.
            ui = self.filter.edit(item)
            if ui.result:
                self._refresh_filters( info )

    def object_new_changed ( self, info ):
        """ Handles the user clicking the **New** button.
        """
        if info.initialized:
            # Get list of available filters and find the current filter in it:
            factory = info.filter.factory
            filters = factory.values
            filter  = self.filter
            index   = filters.index( filter ) + 1
            n       = len( filters )
            while (index < n) and filters[ index ].template:
                index += 1

            # Create a new filter based on the current filter:
            new_filter          = filter.clone_traits()
            new_filter.template = False
            new_filter.name     = new_filter._name = 'New filter'

            # Add it to the list of filters:
            filters.insert( index, new_filter )
            self._refresh_filters( info )

            # Set up the new filter as the current filter and edit it:
            self.filter = new_filter
            do_later( self._delayed_edit, info )

    def object_apply_changed ( self, info ):
        """ Handles the user clicking the **Apply** button.
        """
        if info.initialized:
            self.init( info )
            self.editor._refresh_filters( info.filter.factory.values )
            self.editor.filter = self.filter

    def object_delete_changed ( self, info ):
        """ Handles the user clicking the **Delete** button.
        """
        # Get the list of available filters:
        filters = info.filter.factory.values

        if info.initialized:
            # Delete the current filter:
            index = filters.index( self.filter )
            del filters[ index ]

            # Select a new filter:
            if index >= len( filters ):
                index -= 1
            self.filter = filters[ index ]
            self._refresh_filters( info )

    #---------------------------------------------------------------------------
    #  Private methods:
    #---------------------------------------------------------------------------

    def _refresh_filters ( self, info ):
        """ Refresh the filter editor's list of filters.
        """
        factory = info.filter.factory
        values, factory.values = factory.values, []
        factory.values = values

    def _delayed_edit ( self, info ):
        """ Edits the current filter, and deletes it if the user cancels the
            edit.
        """
        ui = self.filter.edit( self.editor.model.get_filtered_item( 0 ) )
        if not ui.result:
            self.object_delete_changed( info )
        else:
            self._refresh_filters( info )

        # Allow deletion as long as there is more than 1 filter:
        if (not self.filter.template) and len( info.filter.factory.values ) > 1:
            info.delete.enabled = True

#-------------------------------------------------------------------------------
#  'TableEditorToolbar' class:
#-------------------------------------------------------------------------------

class TableEditorToolbar ( HasPrivateTraits ):
    """ Toolbar displayed in table editors.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Do not sort columns:
    no_sort = Instance( Action,
                        { 'name':    'No Sorting',
                          'tooltip': 'Do not sort columns',
                          'action':  'on_no_sort',
                          'enabled': False,
                          'image':   ImageResource( 'table_no_sort.png' ) } )

    # Move current object up one row:
    move_up = Instance( Action,
                        { 'name':    'Move Up',
                          'tooltip': 'Move current item up one row',
                          'action':  'on_move_up',
                          'enabled': False,
                          'image':   ImageResource( 'table_move_up.png' ) } )

    # Move current object down one row:
    move_down = Instance( Action,
                          { 'name':    'Move Down',
                            'tooltip': 'Move current item down one row',
                            'action':  'on_move_down',
                            'enabled': False,
                            'image':   ImageResource( 'table_move_down.png' ) })

    # Search the table:
    search = Instance( Action,
                       { 'name':    'Search',
                         'tooltip': 'Search table',
                         'action':  'on_search',
                         'image':   ImageResource( 'table_search.png' ) } )

    # Add a row:
    add = Instance( Action,
                    { 'name':    'Add',
                      'tooltip': 'Insert new item',
                      'action':  'on_add',
                      'image':   ImageResource( 'table_add.png' ) } )

    # Delete selected row:
    delete = Instance( Action,
                       { 'name':    'Delete',
                         'tooltip': 'Delete current item',
                         'action':  'on_delete',
                         'enabled': False,
                         'image':   ImageResource( 'table_delete.png' ) } )

    # Edit the user preferences:
    prefs = Instance( Action,
                      { 'name':    'Preferences',
                        'tooltip': 'Set user preferences for table',
                        'action':  'on_prefs',
                        'image':   ImageResource( 'table_prefs.png' ) } )

    # The table editor that this is the toolbar for:
    editor = Instance( TableEditor )

    # The toolbar control:
    control = Any

    #---------------------------------------------------------------------------
    #  Initializes the toolbar for a specified window:
    #---------------------------------------------------------------------------

    def __init__ ( self, parent = None, **traits ):
        super( TableEditorToolbar, self ).__init__( **traits )
        editor  = self.editor
        factory = editor.factory
        actions = []

        if factory.sortable and (not factory.sort_model):
            actions.append( self.no_sort )

        if (not editor.in_column_mode) and factory.reorderable:
            actions.append( self.move_up )
            actions.append( self.move_down )

        if editor.in_row_mode and (factory.search is not None):
            actions.append( self.search )

        if factory.editable:
            if (factory.row_factory is not None) and (not factory.auto_add):
                actions.append( self.add )

            if (factory.deletable != False) and (not editor.in_column_mode):
                actions.append( self.delete )

        if factory.configurable:
            actions.append( self.prefs )

        if len( actions ) > 0:
            toolbar = ToolBar( image_size      = ( 16, 16 ),
                               show_tool_names = False,
                               show_divider    = False,
                               *actions )
            self.control = toolbar.create_tool_bar( parent, self )
            self.control.SetBackgroundColour( parent.GetBackgroundColour() )

            # fixme: Why do we have to explictly set the size of the toolbar?
            #        Is there some method that needs to be called to do the
            #        layout?
            self.control.SetSize( wx.Size( 23 * len( actions ), 16 ) )

    #---------------------------------------------------------------------------
    #  PyFace/Traits menu/toolbar controller interface:
    #---------------------------------------------------------------------------

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        pass

    def add_to_toolbar ( self, toolbar_item ):
        """ Adds a toolbar item to the too bar being constructed.
        """
        pass

    def can_add_to_menu ( self, action ):
        """ Returns whether the action should be defined in the user interface.
        """
        return True

    def can_add_to_toolbar ( self, action ):
        """ Returns whether the toolbar action should be defined in the user
            interface.
        """
        return True

    def perform ( self, action, action_event = None ):
        """ Performs the action described by a specified Action object.
        """
        getattr( self.editor, action.action )()

#-------------------------------------------------------------------------------
#  'TableSearchHandler' class:
#-------------------------------------------------------------------------------

class TableSearchHandler ( Handler ):
    """ Handler for saerching a table.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The editor that this handler is associated with
    editor = Instance( TableEditor )

    # Find next matching item
    find_next = Button( 'Find Next' )

    # Find previous matching item
    find_previous = Button( 'Find Previous' )

    # Select all matching items
    select = Button

    # The user is finished searching
    OK = Button( 'Close' )

    # Search status message:
    status = Str

    #---------------------------------------------------------------------------
    #  Handles the user clicking the 'Find next' button:
    #---------------------------------------------------------------------------

    def handler_find_next_changed ( self, info ):
        """ Handles the user clicking the **Find** button.
        """
        if info.initialized:
            editor = self.editor
            items  = editor.model.get_filtered_items()

            for i in range( editor.selected_row_index + 1, len( items ) ):
                if info.object.filter( items[i] ):
                    self.status = 'Item %d matches' % ( i + 1 )
                    editor.set_selection( items[i] )
                    editor.selected_row_index = i
                    break
            else:
                self.status = 'No more matches found'

    #---------------------------------------------------------------------------
    #  Handles the user clicking the 'Find previous' button:
    #---------------------------------------------------------------------------

    def handler_find_previous_changed ( self, info ):
        """ Handles the user clicking the **Find previous** button.
        """
        if info.initialized:
            editor = self.editor
            items  = editor.model.get_filtered_items()

            for i in range( editor.selected_row_index - 1, -1, -1 ):
                if info.object.filter( items[i] ):
                    self.status = 'Item %d matches' % ( i + 1 )
                    editor.set_selection( items[i] )
                    editor.selected_row_index = i
                    break
            else:
                self.status = 'No more matches found'

    #---------------------------------------------------------------------------
    #  Handles the user clicking the 'Select' button:
    #---------------------------------------------------------------------------

    def handler_select_changed ( self, info ):
        """ Handles the user clicking the **Select** button.
        """
        if info.initialized:
            editor = self.editor
            filter = info.object.filter
            items  = [ item for item in editor.model.get_filtered_items()
                       if filter( item ) ]
            editor.set_selection( items )

            if len( items ) == 1:
                self.status = '1 item selected'
            else:
                self.status = '%d items selected' % len( items )

    #---------------------------------------------------------------------------
    #  Handles the user clicking 'OK' button:
    #---------------------------------------------------------------------------

    def handler_OK_changed ( self, info ):
        """ Handles the user clicking the OK button.
        """
        if info.initialized:
            info.ui.dispose()

# Define the SimpleEditor class.
SimpleEditor = TableEditor

# Define the ReadonlyEditor class.
ReadonlyEditor = TableEditor

########NEW FILE########
__FILENAME__ = table_model
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/01/2005
#
#------------------------------------------------------------------------------

""" Defines the table grid model used by the table editor based on the PyFace
    grid control.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import logging

import wx

import wx.grid as wxg

from traits.api \
    import HasPrivateTraits, Any, Str, Instance, Event, Bool, \
           on_trait_change

from traitsui.api \
    import View, Item, Editor

from traitsui.editors.table_editor \
    import ReversedList

from traitsui.table_filter \
    import TableFilter

from traitsui.ui_traits \
    import SequenceTypes

from pyface.ui.wx.grid.api \
    import GridModel, GridSortEvent

from pyface.ui.wx.grid.trait_grid_cell_adapter \
    import TraitGridCellAdapter

from pyface.timer.api \
    import do_later


logger = logging.getLogger(__name__)

#-------------------------------------------------------------------------------
#  'TraitGridSelection' class:
#-------------------------------------------------------------------------------

class TraitGridSelection ( HasPrivateTraits ):
    """ Structure for holding specification information.
    """

    # The selected object
    obj = Any

    # The specific trait selected on the object
    name = Str

#-------------------------------------------------------------------------------
#  'TableModel' class:
#-------------------------------------------------------------------------------

class TableModel ( GridModel ):
    """ Model for table data.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The editor that created this model
    editor = Instance( Editor )

    # The current filter
    filter = Instance( TableFilter, allow_none = True )

    # Current filter summary message
    filter_summary = Str( 'All items' )

    # Display the table items in reverse order?
    reverse = Bool( False )

    # Event fired when the table has been sorted
    sorted = Event

    # The current 'auto_add' row
    auto_add_row = Any

    #---------------------------------------------------------------------------
    #  'object' interface:
    #---------------------------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        """ Initializes the object.
        """
        super( TableModel, self ).__init__( **traits )

        # Attach trait handlers to the list object:
        editor = self.editor
        object = editor.context_object
        name   = ' ' + editor.extended_name

        # Set up listeners for any of the model data changing:
        object.on_trait_change( self._on_data_changed, name, dispatch = 'ui' )
        object.on_trait_change( self.fire_content_changed, name + '.-',
                                dispatch = 'ui' )

        # Set up listeners for any column definitions changing:
        editor.on_trait_change( self.update_columns, 'columns',
                                dispatch = 'ui' )
        editor.on_trait_change( self.update_columns, 'columns_items',
                                dispatch = 'ui' )

        # Initialize the current filter from the editor's default filter:
        self.filter = editor.filter

        # If we are using 'auto_add' mode, create the first 'auto_add' row:
        if editor.auto_add:
            self.auto_add_row = row = editor.create_new_row()
            if row is not None:
                row.on_trait_change( self.on_auto_add_row, dispatch = 'ui' )

    #-- TableModel Interface ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Disposes of the model when it is no longer needed:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the model when it is no longer needed.
        """
        editor = self.editor
        object = editor.context_object
        name   = ' ' + editor.extended_name

        # Remove listeners for any of the model data changing:
        object.on_trait_change( self._on_data_changed, name, remove = True )
        object.on_trait_change( self.fire_content_changed, name + '.-',
                                remove = True )

        # Remove listeners for any column definitions changing:
        editor.on_trait_change( self.update_columns, 'columns', remove = True )
        editor.on_trait_change( self.update_columns, 'columns_items',
                                remove = True )

        # Make sure we have removed listeners from the current filter also:
        if self.filter is not None:
            self.filter.on_trait_change( self._filter_modified, remove = True )

        # Clean-up any links that should be broken:
        self.editor = None

    #---------------------------------------------------------------------------
    #  Returns all model items matching the current filter:
    #---------------------------------------------------------------------------

    def get_filtered_items ( self ):
        """ Returns all model items matching the current filter.
        """
        return self.__filtered_items()

    #---------------------------------------------------------------------------
    #  Returns a single specified item from those items matching the current
    #  filter:
    #---------------------------------------------------------------------------

    def get_filtered_item ( self, index = 0 ):
        """ Returns a single specified item from those items matching the
            current filter.
        """
        try:
            return self.__filtered_items()[ index ]
        except:
            logger.error( 'TableModel error: Request for invalid row %d out of '
                          '%d' % ( index, len( self.__filtered_items() ) ) )
            return None

    #---------------------------------------------------------------------------
    #  Returns the raw, unfiltered index corresponding to a specified filtered
    #  index:
    #---------------------------------------------------------------------------

    def raw_index_of ( self, row ):
        """ Returns the raw, unfiltered index corresponding to a specified
            filtered index.
        """
        if self._filtered_cache is None:
            return row

        return self.editor.filtered_indices[ row ]

    #---------------------------------------------------------------------------
    #  Inserts an object after a specified filtered index:
    #---------------------------------------------------------------------------

    def insert_filtered_item_after ( self, index, item ):
        """ Inserts an object after a specified filtered index.
        """
        mapped_index = 0
        n            = len( self.editor.filtered_indices )
        if index >= n:
            if (index != 0) or (n != 0):
                raise IndexError
        elif index >= 0:
            mapped_index = self.editor.filtered_indices[ index ] + 1
        self.__items().insert( mapped_index, item )
        sorted = self._sort_model()
        if sorted:
            mapped_index = self.__items().index( item )
        self._filtered_cache = None
        return ( mapped_index, sorted )

    #---------------------------------------------------------------------------
    #  Deletes the object at the specified filtered index:
    #---------------------------------------------------------------------------

    def delete_filtered_item_at ( self, index ):
        """ Deletes the object at the specified filtered index.
        """
        if index >= len( self.editor.filtered_indices ):
            raise IndexError

        mapped_index = self.editor.filtered_indices[ index ]
        items        = self.__items()
        object       = items[ mapped_index ]
        del items[ mapped_index ]
        self._filtered_cache = None
        return ( mapped_index, object )

    #---------------------------------------------------------------------------
    #  Updates the table view when columns have been changed:
    #---------------------------------------------------------------------------

    def update_columns ( self ):
        """ Updates the table view when columns have been changed.
        """
        self._columns = None
        self.fire_structure_changed()
        self.editor.refresh()

    #---------------------------------------------------------------------------
    #  Resets any sorting being performed on the underlying model:
    #---------------------------------------------------------------------------

    def no_column_sort ( self ):
        """ Resets any sorting being performed on the underlying model.
        """
        self._sorter = self._filtered_cache = None
        self.column_sorted = GridSortEvent(index = -1)
        #self.fire_structure_changed()

    #-- Event Handlers ---------------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles the contents of the filter being changed:
    #---------------------------------------------------------------------------

    @on_trait_change( 'filter.+' )
    def _filter_modified ( self ):
        """ Handles the contents of the filter being changed.
        """
        self._filtered_cache = None
        self.fire_structure_changed()
        self.editor.filter_modified()

    #---------------------------------------------------------------------------
    #  Handles the grid firing a 'click' event:
    #---------------------------------------------------------------------------

    def _click_changed ( self, event ):
        """ Handles the grid firing a 'click' event.
        """
        row, col = event

        # Fire the same event on the editor after mapping it to a model object
        # and column name:
        object = self.get_filtered_item( row )
        column = self.__get_column( col )
        self.editor.click = ( object, column )

        # Check to see if the column has a view to display:
        view = column.get_view( object )
        if view is not None:
            column.get_object( object ).edit_traits(
                view   = view,
                parent = self._bounds_for( row, col ) )

        # Invoke the column's click handler:
        column.on_click( object )

    #---------------------------------------------------------------------------
    #  Handles the grid firing a 'dclick' event:
    #---------------------------------------------------------------------------

    def _dclick_changed ( self, event ):
        """ Handles the grid firing a 'dclick' event.
        """
        row, col = event

        # Fire the same event on the editor after mapping it to a model object
        # and column name:
        object = self.get_filtered_item( row )
        column = self.__get_column( col )
        self.editor.dclick = ( object, column )

        # Invoke the column's double-click handler:
        column.on_dclick( object )

    #---------------------------------------------------------------------------
    #  Handles the user modifying the current 'auto_add' mode row:
    #---------------------------------------------------------------------------

    def on_auto_add_row ( self ):
        """ Handles the user modifying the current 'auto_add' mode row.
        """
        object = self.auto_add_row
        object.on_trait_change( self.on_auto_add_row, remove = True )

        self.auto_add_row = row = self.editor.create_new_row()
        if row is not None:
            row.on_trait_change( self.on_auto_add_row, dispatch = 'ui' )

        do_later( self.editor.add_row, object,
                                       len( self.get_filtered_items() ) - 2 )

    #-- GridModel Interface ----------------------------------------------------

    def get_column_count ( self ):
        """ Returns the number of columns for this table.
        """
        return len( self.__get_columns() )

    def get_column_name ( self, index ):
        """ Returns the label of the column specified by the (zero-based) index.
        """
        return self.__get_column( index ).get_label()

    def get_column_size ( self, index ):
        """ Returns the size in pixels of the column indexed by *index*.
            A value of -1 or None means to use the default.
        """
        return self.__get_column( index ).get_width()

    def get_cols_drag_value ( self, cols ):
        """ Returns the value to use when the specified columns are dragged or
            copied and pasted. The parameter *cols* is a list of column indexes.
        """
        return [ self.__get_data_column( col ) for col in cols ]

    def get_cols_selection_value ( self, cols ):
        """ Returns a list of TraitGridSelection objects containing the
            objects corresponding to the grid rows and the traits corresponding
            to the specified columns.
        """
        values = []
        for obj in self.__items( False ):
            values.extend( [ TraitGridSelection(
                                 obj  = obj,
                                 name = self.__get_column_name( col ) )
                             for col in cols ] )
        return values

    def sort_by_column ( self, col, reverse = False ):
        """ Sorts the model data by the column indexed by *col*.
        """
        # Make sure we allow sorts by column:
        factory = self.editor.factory
        if not factory.sortable:
            return

        # Flush the object cache:
        self._filtered_cache = None

        # Cache the sorting information for later:
        self._sorter  = self.__get_column( col ).cmp
        self._reverse = reverse

        # If model sorting is requested, do it now:
        self._sort_model()

        # Indicate the we have been sorted:
        self.sorted = True

        self.column_sorted = GridSortEvent( index    = col,
                                            reversed = reverse )

    def is_column_read_only ( self, index ):
        """ Returns True if the column specified by the zero-based *index* is
            read-only.
        """
        return (not self.__get_column( index ).editable)

    def get_row_count ( self ):
        """ Return the number of rows for this table.
        """
        return len( self.__filtered_items() )

    def get_row_name ( self, index ):
        """ Return the name of the row specified by the (zero-based) *index*.
        """
        return '<undefined>'

    def get_rows_drag_value ( self, rows ):
        """ Returns the value to use when the specified rows are dragged or
            copied and pasted. The parameter *rows* is a list of row indexes.
            If there is only one row listed, then return the corresponding trait
            object. If more than one row is listed, then return a list of objects.
        """
        items = self.__filtered_items()
        return [ items[ row ] for row in rows ]

    def get_rows_selection_value ( self, rows ):
        """ Returns a list of TraitGridSelection objects containing the
            object corresponding to the selected rows.
        """
        items = self.__filtered_items()
        return [ TraitGridSelection( obj = items[ row ] ) for row in rows ]

    def is_row_read_only ( self, index ):
        """ Returns True if the row specified by the zero-based *index* is
            read-only.
        """
        return False

    def get_cell_editor ( self, row, col ):
        """ Returns the editor for the specified cell.
        """

        if self.editor is None:
            return None

        column = self.__get_column( col )
        object = self.get_filtered_item( row )
        editor = column.get_editor( object )
        if editor is None:
            return None

        editor._ui = self.editor.ui

        target, name = column.target_name( object )

        return TraitGridCellAdapter( editor, target, name, '',
                   context = self.editor.ui.context,
                   style   = column.get_style( object ),
                   width   = column.get_edit_width( object ),
                   height  = column.get_edit_height( object ) )

    def get_cell_renderer ( self, row, col ):
        """ Returns the renderer for the specified cell.
        """
        return self.__get_column( col ).get_renderer(
                   self.get_filtered_item( row ) )

    def get_cell_drag_value ( self, row, col ):
        """ Returns the value to use when the specified cell is dragged or
            copied and pasted.
        """
        return self.__get_column( col ).get_drag_value(
                                            self.get_filtered_item( row ) )

    def get_cell_selection_value ( self, row, col ):
        """ Returns a TraitGridSelection object specifying the data stored
            in the table at (*row*, *col*).
        """
        return TraitGridSelection( obj  = self.get_filtered_item( row ),
                                   name = self.__get_column_name( col ) )

    def resolve_selection ( self, selection_list ):
        """ Returns a list of (row, col) grid-cell coordinates that
            correspond to the objects in *selection_list*. For each coordinate,
            if the row is -1, it indicates that the entire column is selected.
            Likewise coordinates with a column of -1 indicate an entire row
            that is selected. For the TableModel, the objects in
            *selection_list* must be TraitGridSelection objects.
        """
        items = self.__filtered_items()
        cells = []
        for selection in selection_list:
            row = -1
            if selection.obj is not None:
                try:
                    row = items.index( selection.obj )
                except ValueError:
                    continue

            column = -1
            if selection.name != '':
                column = self._get_column_index_by_trait( selection.name )
                if column is None:
                    continue

            cells.append( ( row, column ) )

        return cells

    def get_cell_context_menu ( self, row, col ):
        """ Returns a Menu object that generates the appropriate context
            menu for this cell.
        """
        column = self.__get_column( col )
        menu   = column.get_menu( self.get_filtered_item( row ) )
        editor = self.editor

        if menu is None:
            menu = editor.factory.menu

        if menu is None:
            menu_name = editor.factory.menu_name
            if menu_name :
                menu = getattr(self.editor.object, menu_name, None)

        if menu is not None:
            editor.prepare_menu( row, column )

            return ( menu, editor )

        return None

    def get_value ( self, row, col ):
        """ Returns the value stored in the table at (*row*, *col*).
        """
        object = self.get_filtered_item( row )
        if object is self.auto_add_row:
            return ''

        value   = self.__get_column( col ).get_value( object )
        formats = self.__get_column_formats( col )

        if (value is not None) and (formats is not None):
            format = formats.get( type( value ) )
            if format is not None:
                try:
                    if callable( format ):
                        value = format( value )
                    else:
                        value = format % value
                except:
                    pass

        return value

    def is_valid_cell_value ( self, row, col, value ):
        """ Tests whether *value* is valid for the cell at (*row*, *col*).
        Returns True if value is acceptable, and False otherwise. """
        return self.__get_column( col ).is_droppable(
                   self.get_filtered_item( row ), value )

    def is_cell_empty ( self, row, col ):
        """ Returns True if the cell at (*row*, *col*) has a None value, and
            False otherwise.
        """
        return (self.get_value( row, col ) is None)

    def is_cell_read_only ( self, row, col ):
        """ Returns True if the cell at (*row*, *col*) is read-only, and False
            otherwise.
        """
        return (not self.__get_column( col ).is_editable(
                   self.get_filtered_item( row ) ))

    def get_cell_bg_color ( self, row, col ):
        """ Returns a wxColour object specifying the background color
            of the specified cell.
        """
        return self.__get_column( col ).get_cell_color(
                   self.get_filtered_item( row ) )

    def get_cell_text_color ( self, row, col ):
        """ Returns a wxColour object specifying the text color of the
            specified cell.
        """
        column = self.__get_column(col)
        item = self.get_filtered_item(row)
        return column.get_text_color(item)

    def get_cell_font ( self, row, col ):
        """ Returns a wxFont object specifying the font of the specified cell.
        """
        return self.__get_column( col ).get_text_font(
                   self.get_filtered_item( row ) )

    def get_cell_halignment ( self, row, col ):
        """ Returns a string specifying the horizontal alignment of the
            specified cell.

            Returns 'left' for left alignment, 'right' for right alignment,
            or 'center' for center alignment.
        """
        return self.__get_column( col ).get_horizontal_alignment(
                   self.get_filtered_item( row ) )

    def get_cell_valignment ( self, row, col ):
        """ Returns a string specifying the vertical alignment of the
            specified cell.

            Returns 'top' for top alignment, 'bottom' for bottom alignment,
            or 'center' for center alignment.
        """
        return self.__get_column( col ).get_vertical_alignment(
                   self.get_filtered_item( row ) )

    #---------------------------------------------------------------------------
    #  Protected 'GridModel' interface:
    #---------------------------------------------------------------------------

    def _insert_rows ( self, pos, num_rows ):
        """ Inserts *num_rows* at *pos*; fires an event only if a factory
        method for new rows is defined or the model is not empty. Otherwise,
        it returns 0.
        """
        count = 0

        factory = self.editor.factory.row_factory
        if factory is None:
            items = self.__items( False )
            if len( items ) > 0:
                factory = items[0].__class__

        if factory is not None:
            new_data = [ x for x in [ factory() for i in range( num_rows ) ]
                         if x is not None ]
            if len( new_data ) > 0:
                count           = self._insert_rows_into_model( pos, new_data )
                self.rows_added = ( 'added', pos, new_data )

        return count

    def _delete_rows ( self, pos, num_rows ):
        """ Removes rows *pos* through *pos* + *num_rows* from the model.
        """
        row_count = self.get_rows_count()
        if (pos + num_rows) > row_count:
            num_rows = row_count - pos

        return self._delete_rows_from_model( pos, num_rows )

    def _set_value ( self, row, col, value ):
        """ Sets the value of the cell at (*row*, *col*) to *value*.

            Raises a ValueError if the value is vetoed or the cell at
            the specified position does not exist.
        """
        new_rows = 0
        column   = self.__get_column( col )
        obj      = None
        try:
            obj = self.get_filtered_item( row )
        except:
            # Add a new row:
            new_rows = self._insert_rows( self.get_row_count(), 1 )
            if new_rows > 0:
                # Now set the value on the new object:
                try:
                    obj = self.get_filtered_item( self.get_row_count() - 1 )
                except:
                    # fixme: what do we do in this case? veto the set somehow?
                    # raise an exception?
                    pass

        if obj is not None:
            self._set_data_on_row( obj, column, value )

        return new_rows

    def _move_column ( self, frm, to ):
        """ Moves a specified **frm** column to before the specified **to**
            column. Returns **True** if successful; **False** otherwise.
        """
        to_column = None
        if to < len( self.__get_columns() ):
            to_column = self.__get_column( to )

        return self.editor.move_column( self.__get_column( frm ), to_column )

    #---------------------------------------------------------------------------
    #  Protected interface:
    #---------------------------------------------------------------------------

    def _set_data_on_row ( self, row, column, value ):
        """ Sets the cell specified by (*row*, *col*) to *value, which
            can be either a member of the row object, or a no-argument method
            on that object.
        """
        column.set_value( row, value )

    def _insert_rows_into_model ( self, pos, new_data ):
        """ Inserts the given new rows into the model.
        """
        raw_pos = self.raw_index_of( pos )
        self.__items()[ raw_pos: raw_pos ] = new_data

    def _delete_rows_from_model ( self, pos, num_rows ):
        """ Deletes the specified rows from the model.
        """
        raw_rows = [ self.raw_index_of( i )
                     for i in range( pos, pos + num_rows ) ]
        raw_rows.sort()
        raw_rows.reverse()
        items = self.__items()
        for row in raw_rows:
            del items[ row ]

        return num_rows

    #---------------------------------------------------------------------------
    #  Trait event handlers:
    #---------------------------------------------------------------------------

    def _on_data_changed ( self ):
        """ Forces the grid to refresh when the underlying list changes.
        """
        # Invalidate the current cache (if any):
        self._filtered_cache = None

        self.fire_structure_changed()

    def _mouse_cell_changed ( self, new ):
        """ Handles the user mousing over a specified cell.
        """
        row, col = new
        column   = self.__get_column( col )
        object   = self.get_filtered_item( row )

        # Update the tooltip if necessary:
        tooltip = column.get_tooltip( object )
        if tooltip != self._tooltip:
            self._tooltip = tooltip
            self.editor.grid._grid_window.SetToolTip( wx.ToolTip( tooltip ) )

        if column.is_auto_editable( object ):
            x, y, dx, dy = self._bounds_for( row, col )
            if column.is_editable( object ):
                view = View( Item( name       = column.name,
                                   editor     = column.get_editor( object ),
                                   style      = column.get_style(  object ),
                                   show_label = False,
                                   padding    = -4 ),
                             kind   = 'info',
                             width  = dx,
                             height = dy )
            else:
                view = column.get_view( object )
                if view is None:
                    return

            column.get_object( object ).edit_traits(
                view   = view,
                parent = ( x, y, dx, dy ) )

    #---------------------------------------------------------------------------
    #  Private interface:
    #---------------------------------------------------------------------------

    def _bounds_for ( self, row, col ):
        """ Returns the coordinates and size of the specified cell in the form:
            ( x, y, dx, dy ).
        """
        grid         = self.editor.grid
        coords       = wxg.GridCellCoords( row, col )
        x, y, dx, dy = grid._grid.BlockToDeviceRect( coords, coords )
        x, y         = grid._grid_window.ClientToScreenXY( x, y )

        return ( x, y, dx, dy )

    def _sort_model ( self ):
        """ Sorts the underlying model if that is what the user requested.
        """
        editor = self.editor
        sorted = (editor.factory.sort_model and (self._sorter is not None))
        if sorted:
            items = self.__items( False )[:]
            items.sort( self._sorter )
            if self.reverse ^ self._reverse:
                items.reverse()
            editor.value = items
        return sorted

    def __items ( self, ordered = True ):
        """ Returns the raw list of model objects.
        """
        result = self.editor.value
        if not isinstance( result, SequenceTypes ):
            return [ result ]

        if ordered and self.reverse:
            return ReversedList( result )

        return result

    def __filtered_items ( self ):
        """ Returns the list of all model objects that pass the current filter.
        """
        fc = self._filtered_cache
        if fc is None:
            items  = self.__items()
            filter = self.filter
            if filter is None:
                nitems = [ nitem for nitem in enumerate( items ) ]
                self.filter_summary = 'All %s items' % len( nitems )
            else:
                if not callable( filter ):
                    filter = filter.filter
                nitems = [ nitem for nitem in enumerate( items )
                           if filter( nitem[1] ) ]
                self.filter_summary = '%s of %s items' % ( len( nitems ),
                                                           len( items ) )
            sorter = self._sorter
            if sorter is not None:
                nitems.sort( lambda l, r: sorter( l[1], r[1] ) )
                if self._reverse:
                    nitems.reverse()

            self.editor.filtered_indices = [ x[0] for x in nitems ]
            self._filtered_cache = fc    = [ x[1] for x in nitems ]
            if self.auto_add_row is not None:
                self._filtered_cache.append( self.auto_add_row )

        return fc

    def __get_data_column ( self, col ):
        """ Returns a list of model data from the column indexed by *col*.
        """
        column = self.__get_column( col )
        return [ column.get_value( item ) for item in self.__filtered_items() ]

    def __get_columns ( self ):
        columns = self._columns
        if columns is None:
            self._columns = columns = [ c for c in self.editor.columns
                                                if c.visible ]
        return columns

    def __get_column ( self, col ):
        try:
            return self.__get_columns()[ col ]
        except:
            return self.__get_columns()[0]

    def __get_column_name ( self, col ):
        return self.__get_column( col ).name

    def __get_column_formats ( self, col ):
        return None   # Not used/implemented currently

    def _get_column_index_by_trait ( self, name ):
        for i, col in enumerate( self.__get_columns() ):
            if name == col.name:
                return i

########NEW FILE########
__FILENAME__ = tabular_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   05/20/2007
#
#-------------------------------------------------------------------------------

""" A traits UI editor for editing tabular data (arrays, list of tuples, lists
    of objects, etc).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx
import wx.lib.mixins.listctrl as listmix

from traits.api \
    import HasStrictTraits, Int, \
           List, Bool, Instance, Any, Event, \
           Property, TraitListEvent

# FIXME: TabularEditor (the editor factory for tabular editors) is a proxy class
# defined here just for backward compatibility. The class has been moved to the
# traitsui.editors.tabular_editor file.
from traitsui.editors.tabular_editor \
    import TabularEditor

from traitsui.ui_traits \
    import Image

from traitsui.tabular_adapter \
    import TabularAdapter

from traitsui.wx.editor \
    import Editor

from pyface.image_resource \
    import ImageResource

from pyface.timer.api \
    import do_later

from constants \
    import is_mac, scrollbar_dx

try:
    from pyface.wx.drag_and_drop \
        import PythonDropSource, PythonDropTarget
except:
    PythonDropSource = PythonDropTarget = None

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Mapping for trait alignment values to wx alignment values:
alignment_map = {
    'left':   wx.LIST_FORMAT_LEFT,
    'center': wx.LIST_FORMAT_CENTRE,
    'right':  wx.LIST_FORMAT_RIGHT
}

class TextEditMixin(listmix.TextEditMixin):
    def __init__(self, edit_labels):
        """ edit_labels controls whether the first column is editable
        """
        self.edit_labels = edit_labels
        listmix.TextEditMixin.__init__(self)

    def OpenEditor(self, col, row):
        if col == 0 and not self.edit_labels:
            return
        else:
            return listmix.TextEditMixin.OpenEditor(self, col, row)

#-------------------------------------------------------------------------------
#  'wxListCtrl' class:
#-------------------------------------------------------------------------------

class wxListCtrl ( wx.ListCtrl, TextEditMixin ):
    """ Subclass of wx.ListCtrl to provide correct virtual list behavior.
    """

    def __init__(self, parent, ID, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, can_edit = False, edit_labels=False):

        wx.ListCtrl.__init__(self, parent, ID, pos, size, style)

        # if the selected is editable, then we have to init the mixin
        if can_edit:
            TextEditMixin.__init__(self, edit_labels)

    def SetVirtualData(self, row, col, text):
        # this method is called but the job is already done by
        # the _end_label_edit method. Commmented code is availabed
        # if needed
        pass
        #edit = self._editor
        #return editor.adapter.set_text( editor.object, editor.name,
        #                                row, col, text )


    def OnGetItemAttr ( self, row ):
        """ Returns the display attributes to use for the specified list item.
        """
        # fixme: There appears to be a bug in wx in that they do not correctly
        # manage the reference count for the returned object, and it seems to be
        # gc'ed before they finish using it. So we store an object reference to
        # it to prevent it from going away too soon...
        self._attr   = attr = wx.ListItemAttr()
        editor       = self._editor
        object, name = editor.object, editor.name

        color = editor.adapter.get_bg_color( object, name, row )
        if color is not None:
            attr.SetBackgroundColour( color )

        color = editor.adapter.get_text_color( object, name, row )
        if color is not None:
            attr.SetTextColour( color )

        font = editor.adapter.get_font( object, name, row )
        if font is not None:
            attr.SetFont( font )

        return attr

    def OnGetItemImage ( self, row ):
        """ Returns the image index to use for the specified list item.
        """
        editor = self._editor
        image  = editor._get_image( editor.adapter.get_image( editor.object,
                                                         editor.name, row, 0 ) )
        if image is not None:
            return image

        return -1

    def OnGetItemColumnImage ( self, row, column ):
        """ Returns the image index to use for the specified list item.
        """
        editor = self._editor
        image  = editor._get_image( editor.adapter.get_image( editor.object,
                                                    editor.name, row, column ) )
        if image is not None:
            return image

        return -1

    def OnGetItemText ( self, row, column ):
        """ Returns the text to use for the specified list item.
        """
        editor = self._editor
        return editor.adapter.get_text( editor.object, editor.name,
                                        row, column )

#-------------------------------------------------------------------------------
#  'TabularEditor' class:
#-------------------------------------------------------------------------------

class TabularEditor ( Editor ):
    """ A traits UI editor for editing tabular data (arrays, list of tuples,
        lists of objects, etc).
    """

    #-- Trait Definitions ------------------------------------------------------

    # The event fired when a table update is needed:
    update = Event

    # The current set of selected items (which one is used depends upon the
    # initial state of the editor factory 'multi_select' trait):
    selected       = Any
    multi_selected = List

    # The current set of selected item indices (which one is used depends upon
    # the initial state of the editor factory 'multi_select' trait):
    selected_row        = Int( -1 )
    multi_selected_rows = List( Int )

    # The most recently actived item and its index:
    activated     = Any
    activated_row = Int

    # The most recent left click data:
    clicked = Instance( 'TabularEditorEvent' )

    # The most recent left double click data:
    dclicked = Instance( 'TabularEditorEvent' )

    # The most recent right click data:
    right_clicked = Instance( 'TabularEditorEvent' )

    # The most recent right double click data:
    right_dclicked = Instance( 'TabularEditorEvent' )

    # The most recent column click data:
    column_clicked = Instance( 'TabularEditorEvent' )

    # Is the tabular editor scrollable? This value overrides the default.
    scrollable = True

    # Row index of item to select after rebuilding editor list:
    row = Any

    # Should the selected item be edited after rebuilding the editor list:
    edit = Bool( False )

    # The adapter from trait values to editor values:
    adapter = Instance( TabularAdapter )

    # Dictionary mapping image names to wx.ImageList indices:
    images = Any( {} )

    # Dictionary mapping ImageResource objects to wx.ImageList indices:
    image_resources = Any( {} )

    # An image being converted:
    image = Image

    # Flag for marking whether the update was within the visible area
    _update_visible = Bool(False)

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory

        # Set up the adapter to use:
        self.adapter = factory.adapter

        # Determine the style to use for the list control:
        style = wx.LC_REPORT | wx.LC_VIRTUAL | wx.BORDER_NONE

        if factory.editable_labels:
            style |= wx.LC_EDIT_LABELS

        if factory.horizontal_lines:
            style |= wx.LC_HRULES

        if factory.vertical_lines:
            style |= wx.LC_VRULES

        if not factory.multi_select:
            style |= wx.LC_SINGLE_SEL

        if not factory.show_titles:
            style |= wx.LC_NO_HEADER

        # Create the list control and link it back to us:
        self.control = control = wxListCtrl( parent, -1, style = style,
                                             can_edit = factory.editable,
                                             edit_labels = factory.editable_labels)
        control._editor = self

        # Create the list control column:
        #fixme: what do we do here?
        #control.InsertColumn( 0, '' )

        # Set up the list control's event handlers:
        id = control.GetId()
        wx.EVT_LIST_BEGIN_DRAG(       parent, id, self._begin_drag )
        wx.EVT_LIST_BEGIN_LABEL_EDIT( parent, id, self._begin_label_edit )
        wx.EVT_LIST_END_LABEL_EDIT(   parent, id, self._end_label_edit )
        wx.EVT_LIST_ITEM_SELECTED(    parent, id, self._item_selected )
        wx.EVT_LIST_ITEM_DESELECTED(  parent, id, self._item_selected )
        wx.EVT_LIST_KEY_DOWN(         parent, id, self._key_down )
        wx.EVT_LIST_ITEM_ACTIVATED(   parent, id, self._item_activated )
        wx.EVT_LIST_COL_END_DRAG(     parent, id, self._size_modified )
        wx.EVT_LIST_COL_RIGHT_CLICK(  parent, id, self._column_right_clicked )
        wx.EVT_LIST_COL_CLICK(        parent, id, self._column_clicked )
        wx.EVT_LEFT_DOWN(             control, self._left_down )
        wx.EVT_LEFT_DCLICK(           control, self._left_dclick )
        wx.EVT_RIGHT_DOWN(            control, self._right_down )
        wx.EVT_RIGHT_DCLICK(          control, self._right_dclick )
        wx.EVT_MOTION(                control, self._motion )
        wx.EVT_SIZE(                  control, self._size_modified )

        # Set up the drag and drop target:
        if PythonDropTarget is not None:
            control.SetDropTarget( PythonDropTarget( self ) )

        # Set up the selection listener (if necessary):
        if factory.multi_select:
            self.sync_value( factory.selected, 'multi_selected', 'both',
                             is_list = True )
            self.sync_value( factory.selected_row, 'multi_selected_rows',
                             'both', is_list = True )
        else:
            self.sync_value( factory.selected, 'selected', 'both' )
            self.sync_value( factory.selected_row, 'selected_row', 'both' )

        # Synchronize other interesting traits as necessary:
        self.sync_value( factory.update, 'update', 'from' )

        self.sync_value( factory.activated,     'activated',     'to' )
        self.sync_value( factory.activated_row, 'activated_row', 'to' )

        self.sync_value( factory.clicked,  'clicked',  'to' )
        self.sync_value( factory.dclicked, 'dclicked', 'to' )

        self.sync_value( factory.right_clicked,  'right_clicked',  'to' )
        self.sync_value( factory.right_dclicked, 'right_dclicked', 'to' )

        self.sync_value( factory.column_clicked, 'column_clicked', 'to' )

        # Make sure we listen for 'items' changes as well as complete list
        # replacements:
        try:
            self.context_object.on_trait_change( self.update_editor,
                                self.extended_name + '_items', dispatch = 'ui' )
        except:
            pass

        # If the user has requested automatic update, attempt to set up the
        # appropriate listeners:
        if factory.auto_update:
            self.context_object.on_trait_change( self.refresh_editor,
                                self.extended_name + '.-', dispatch = 'ui' )

        # Create the mapping from user supplied images to wx.ImageList indices:
        for image_resource in factory.images:
            self._add_image( image_resource )

        # Refresh the editor whenever the adapter changes:
        self.on_trait_change( self._refresh, 'adapter.+update',
                              dispatch = 'ui' )

        # Rebuild the editor columns and headers whenever the adapter's
        # 'columns' changes:
        self.on_trait_change( self._rebuild_all, 'adapter.columns',
                              dispatch = 'ui' )

        # Make sure the tabular view gets initialized:
        self._rebuild()

        # Set the list control's tooltip:
        self.set_tooltip()

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Remove all of the wx event handlers:
        control = self.control
        parent  = control.GetParent()
        id      = control.GetId()
        wx.EVT_LIST_BEGIN_DRAG(       parent, id, None )
        wx.EVT_LIST_BEGIN_LABEL_EDIT( parent, id, None )
        wx.EVT_LIST_END_LABEL_EDIT(   parent, id, None )
        wx.EVT_LIST_ITEM_SELECTED(    parent, id, None )
        wx.EVT_LIST_ITEM_DESELECTED(  parent, id, None )
        wx.EVT_LIST_KEY_DOWN(         parent, id, None )
        wx.EVT_LIST_ITEM_ACTIVATED(   parent, id, None )
        wx.EVT_LIST_COL_END_DRAG(     parent, id, None )
        wx.EVT_LIST_COL_RIGHT_CLICK(  parent, id, None )
        wx.EVT_LIST_COL_CLICK(        parent, id, None )
        wx.EVT_LEFT_DOWN(             control,    None )
        wx.EVT_LEFT_DCLICK(           control,    None )
        wx.EVT_RIGHT_DOWN(            control,    None )
        wx.EVT_RIGHT_DCLICK(          control,    None )
        wx.EVT_MOTION(                control,    None )
        wx.EVT_SIZE(                  control,    None )

        self.context_object.on_trait_change( self.update_editor,
                                  self.extended_name + '_items', remove = True )

        if self.factory.auto_update:
            self.context_object.on_trait_change( self.refresh_editor,
                                self.extended_name + '.-', remove = True )

        self.on_trait_change( self._refresh, 'adapter.+update',  remove = True )
        self.on_trait_change( self._rebuild_all, 'adapter.columns',
                              remove = True )

        super( TabularEditor, self ).dispose()

    def _update_changed ( self, event ):
        """ Handles the 'update' event being fired.
        """
        if event is True:
            self.update_editor()
        elif isinstance( event, int ):
            self._refresh_row( event )
        else:
            self._refresh_editor( event )

    def refresh_editor ( self, item, name, old, new ):
        """ Handles a table item attribute being changed.
        """
        self._refresh_editor( item )

    def _refresh_editor ( self, item ):
        """ Handles a table item being changed.
        """
        adapter      = self.adapter
        object, name = self.object, self.name
        agi          = adapter.get_item
        for row in xrange( adapter.len( object, name ) ):
            if item is agi( object, name, row ):
                self._refresh_row( row )
                return

        self.update_editor()

    def _refresh_row ( self, row ):
        """ Updates the editor control when a specified table row changes.
        """
        self.control.RefreshRect(
             self.control.GetItemRect( row, wx.LIST_RECT_BOUNDS ) )

    def _update_editor ( self, object, name, old_value, new_value ):
        """ Performs updates when the object trait changes.
            Overloads traitsui.editor.UIEditor
        """
        self._update_visible = True

        super(TabularEditor, self)._update_editor(object, name,
                                                  old_value, new_value)


    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        control = self.control
        n       = self.adapter.len( self.object, self.name )
        top     = control.GetTopItem()
        pn      = control.GetCountPerPage()
        bottom = min(top + pn - 1, n)

        control.SetItemCount( n )

        if self._update_visible:
            control.RefreshItems( 0, n-1 )
            self._update_visible = False

        if len( self.multi_selected_rows ) > 0:
            self._multi_selected_rows_changed( self.multi_selected_rows )
        if len( self.multi_selected ) > 0:
            self._multi_selected_changed( self.multi_selected )

        edit, self.edit = self.edit, False
        row,  self.row  = self.row,  None

        if row is not None:
            if row >= n:
                row -= 1
                if row < 0:
                    row = None

        if row is None:
            visible = bottom
            if visible >= 0 and visible < control.GetItemCount():
                control.EnsureVisible( visible )
            return


        if 0 <= (row - top) < pn:
            control.EnsureVisible( top + pn - 2 )
        elif row < top:
            control.EnsureVisible( row + pn - 1 )
        else:
            control.EnsureVisible( row )

        control.SetItemState( row,
            wx.LIST_STATE_SELECTED | wx.LIST_STATE_FOCUSED,
            wx.LIST_STATE_SELECTED | wx.LIST_STATE_FOCUSED  )

        if edit:
            control.EditLabel( row )

    #-- Trait Event Handlers ---------------------------------------------------

    def _selected_changed ( self, selected ):
        """ Handles the editor's 'selected' trait being changed.
        """
        if not self._no_update:
            if selected is None:
                for row in self._get_selected():
                    self.control.SetItemState( row, 0, wx.LIST_STATE_SELECTED )
            else:
                try:
                    self.control.SetItemState( self.value.index( selected ),
                                wx.LIST_STATE_SELECTED, wx.LIST_STATE_SELECTED )
                except:
                    pass

    def _selected_row_changed ( self, old, new ):
        """ Handles the editor's 'selected_index' trait being changed.
        """
        if not self._no_update:
            if new < 0:
                if old >= 0:
                    self.control.SetItemState( old, 0, wx.LIST_STATE_SELECTED )
            else:
                self.control.SetItemState( new, wx.LIST_STATE_SELECTED,
                                                wx.LIST_STATE_SELECTED )

    def _multi_selected_changed ( self, selected ):
        """ Handles the editor's 'multi_selected' trait being changed.
        """
        if not self._no_update:
            values = self.value
            try:
                self._multi_selected_rows_changed( [ values.index( item )
                                                     for item in selected ] )
            except:
                pass

    def _multi_selected_items_changed ( self, event ):
        """ Handles the editor's 'multi_selected' trait being modified.
        """
        values = self.values
        try:
            self._multi_selected_rows_items_changed( TraitListEvent( 0,
                [ values.index( item ) for item in event.removed ],
                [ values.index( item ) for item in event.added   ] ) )
        except:
            pass

    def _multi_selected_rows_changed ( self, selected_rows ):
        """ Handles the editor's 'multi_selected_rows' trait being changed.
        """
        if not self._no_update:
            control  = self.control
            selected = self._get_selected()

            # Select any new items that aren't already selected:
            for row in selected_rows:
                if row in selected:
                    selected.remove( row )
                else:
                    control.SetItemState( row, wx.LIST_STATE_SELECTED,
                                               wx.LIST_STATE_SELECTED )

            # Unselect all remaining selected items that aren't selected now:
            for row in selected:
                control.SetItemState( row, 0, wx.LIST_STATE_SELECTED )

    def _multi_selected_rows_items_changed ( self, event ):
        """ Handles the editor's 'multi_selected_rows' trait being modified.
        """
        control = self.control

        # Remove all items that are no longer selected:
        for row in event.removed:
            control.SetItemState( row, 0, wx.LIST_STATE_SELECTED )

        # Select all newly added items:
        for row in event.added:
            control.SetItemState( row, wx.LIST_STATE_SELECTED,
                                       wx.LIST_STATE_SELECTED )

    #-- List Control Event Handlers --------------------------------------------

    def _left_down ( self, event ):
        """ Handles the left mouse button being pressed.
        """
        self._mouse_click( event, 'clicked' )

    def _left_dclick ( self, event ):
        """ Handles the left mouse button being double clicked.
        """
        self._mouse_click( event, 'dclicked' )

    def _right_down ( self, event ):
        """ Handles the right mouse button being pressed.
        """
        self._mouse_click( event, 'right_clicked' )

    def _right_dclick ( self, event ):
        """ Handles the right mouse button being double clicked.
        """
        self._mouse_click( event, 'right_dclicked' )

    def _begin_drag ( self, event ):
        """ Handles the user beginning a drag operation with the left mouse
            button.
        """
        if PythonDropSource is not None:
            adapter      = self.adapter
            object, name = self.object, self.name
            selected     = self._get_selected()
            drag_items   = []

            # Collect all of the selected items to drag:
            for row in selected:
                drag = adapter.get_drag( object, name, row )
                if drag is None:
                    return

                drag_items.append( drag )

            # Save the drag item indices, so that we can later handle a
            # completed 'move' operation:
            self._drag_rows = selected

            try:
                # If only one item is being dragged, drag it as an item, not a
                # list:
                if len( drag_items ) == 1:
                    drag_items = drag_items[0]

                # Perform the drag and drop operation:
                ds = PythonDropSource( self.control, drag_items )

                # If moves are allowed and the result was a drag move:
                if ((ds.result == wx.DragMove) and
                    (self._drag_local or self.factory.drag_move)):
                    # Then delete all of the original items (in reverse order
                    # from highest to lowest, so the indices don't need to be
                    # adjusted):
                    rows = self._drag_rows
                    rows.reverse()
                    for row in rows:
                        adapter.delete( object, name, row )
            finally:
                self._drag_rows  = None
                self._drag_local = False

    def _begin_label_edit ( self, event ):
        """ Handles the user starting to edit an item label.
        """
        if not self.adapter.get_can_edit( self.object, self.name,
                                          event.GetIndex() ):
            event.Veto()

    def _end_label_edit ( self, event ):
        """ Handles the user finishing editing an item label.
        """
        self.adapter.set_text( self.object, self.name, event.GetIndex(),
                               event.GetColumn(), event.GetText() )
        self.row = event.GetIndex() + 1

    def _item_selected ( self, event ):
        """ Handles an item being selected.
        """
        self._no_update = True
        try:
            get_item      = self.adapter.get_item
            object, name  = self.object, self.name
            selected_rows = self._get_selected()
            if self.factory.multi_select:
                self.multi_selected_rows = selected_rows
                self.multi_selected = [ get_item( object, name, row )
                                        for row in selected_rows ]
            elif len( selected_rows ) == 0:
                self.selected_row = -1
                self.selected     = None
            else:
                self.selected_row = selected_rows[0]
                self.selected     = get_item( object, name, selected_rows[0] )
        finally:
            self._no_update = False

    def _item_activated ( self, event ):
        """ Handles an item being activated (double-clicked or enter pressed).
        """
        self.activated_row = event.GetIndex()
        self.activated     = self.adapter.get_item( self.object, self.name,
                                                    self.activated_row )

    def _key_down ( self, event ):
        """ Handles the user pressing a key in the list control.
        """
        key = event.GetKeyCode()
        if key == wx.WXK_NEXT:
            self._append_new()
        elif key in ( wx.WXK_BACK, wx.WXK_DELETE ):
            self._delete_current()
        elif key == wx.WXK_INSERT:
            self._insert_current()
        elif key == wx.WXK_LEFT:
            self._move_up_current()
        elif key == wx.WXK_RIGHT:
            self._move_down_current()
        elif key in ( wx.WXK_RETURN, wx.WXK_ESCAPE ):
            self._edit_current()
        else:
            event.Skip()

    def _column_right_clicked ( self, event ):
        """ Handles the user right-clicking a column header.
        """
        column = event.GetColumn()
        if ((self._cached_widths is not None) and
            (0 <= column < len( self._cached_widths ))):
            self._cached_widths[ column ] = None
            self._size_modified( event )

    def _column_clicked ( self, event ):
        """ Handles the right mouse button being double clicked.
        """
        editor_event = TabularEditorEvent(
            editor = self,
            row    = 0,
            column = event.GetColumn()
        )

        setattr( self, 'column_clicked', editor_event)
        event.Skip()

    def _size_modified ( self, event ):
        """ Handles the size of the list control being changed.
        """
        control = self.control
        n       = control.GetColumnCount()
        if n == 1:
            dx, dy = control.GetClientSizeTuple()
            control.SetColumnWidth( 0, dx - 1 )
        elif n > 1:
            do_later( self._set_column_widths )

        event.Skip()

    def _motion ( self, event ):
        """ Handles the user moving the mouse.
        """
        x          = event.GetX()
        column     = self._get_column( x )
        row, flags = self.control.HitTest( wx.Point( x, event.GetY() ) )
        if (row != self._last_row) or (column != self._last_column):
            self._last_row, self._last_column = row, column
            if (row == -1) or (column is None):
                tooltip = ''
            else:
                tooltip = self.adapter.get_tooltip( self.object, self.name,
                                                    row, column )
            if tooltip != self._last_tooltip:
                self._last_tooltip = tooltip
                wx.ToolTip.Enable( False )
                wx.ToolTip.Enable( True )
                self.control.SetToolTip( wx.ToolTip( tooltip ) )

    #-- Drag and Drop Event Handlers -------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the list control.
        """
        row, flags = self.control.HitTest( wx.Point( x, y ) )

        # If the user dropped it on an empty list, set the target as past the
        # end of the list:
        if ((row == -1) and
            ((flags & wx.LIST_HITTEST_NOWHERE) != 0) and
            (self.control.GetItemCount() == 0)):
            row = 0

        # If we have a valid drop target row, proceed:
        if row != -1:
            if not isinstance( data, list ):
                # Handle the case of just a single item being dropped:
                self._wx_dropped_on( row, data )
            else:
                # Handles the case of a list of items being dropped, being
                # careful to preserve the original order of the source items if
                # possible:
                data.reverse()
                for item in data:
                    self._wx_dropped_on( row, item )

            # If this was an inter-list drag, mark it as 'local':
            if self._drag_indices is not None:
                self._drag_local = True

            # Return a successful drop result:
            return drag_result

        # Indicate we could not process the drop:
        return wx.DragNone

    def _wx_dropped_on ( self, row, item ):
        """ Helper method for handling a single item dropped on the list
            control.
        """
        adapter      = self.adapter
        object, name = self.object, self.name

        # Obtain the destination of the dropped item relative to the target:
        destination = adapter.get_dropped( object, name, row, item )

        # Adjust the target index accordingly:
        if destination == 'after':
            row += 1

        # Insert the dropped item at the requested position:
        adapter.insert( object, name, row, item )

        # If the source for the drag was also this list control, we need to
        # adjust the original source indices to account for their new position
        # after the drag operation:
        rows = self._drag_rows
        if rows is not None:
            for i in range( len( rows ) - 1, -1, -1 ):
                if rows[i] < row:
                    break

                rows[i] += 1

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        if isinstance( data, list ):
            rc = wx.DragNone
            for item in data:
                rc = self.wx_drag_over( x, y, item, drag_result )
                if rc == wx.DragNone:
                    break

            return rc

        row, flags = self.control.HitTest( wx.Point( x, y ) )

        # If the user is dragging over an empty list, set the target to the end
        # of the list:
        if ((row == -1) and
            ((flags & wx.LIST_HITTEST_NOWHERE) != 0) and
            (self.control.GetItemCount() == 0)):
            row = 0

        # If the drag target index is valid and the adapter says it is OK to
        # drop the data here, then indicate the data can be dropped:
        if ((row != -1) and
            self.adapter.get_can_drop( self.object, self.name, row, data )):
            return drag_result

        # Else indicate that we will not accept the data:
        return wx.DragNone

    #-- UI preference save/restore interface -----------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        self._cached_widths = cws = prefs.get( 'cached_widths' )
        if cws is not None:
            set_column_width = self.control.SetColumnWidth
            for i, width in enumerate( cws ):
                if width is not None:
                    set_column_width( i, width )

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        cws = self._cached_widths
        if cws is not None:
            cws = [ ( None, cw )[ cw >= 0 ] for cw in cws ]

        return { 'cached_widths': cws }

    #-- Private Methods --------------------------------------------------------

    def _refresh ( self ):
        """ Refreshes the contents of the editor's list control.
        """
        n = self.adapter.len( self.object, self.name )
        if n > 0:
            self.control.RefreshItems( 0, n - 1)

    def _rebuild ( self ):
        """ Rebuilds the contents of the editor's list control.
        """
        control = self.control
        control.ClearAll()
        adapter, object, name  = self.adapter, self.object, self.name
        adapter.object, adapter.name = object, name
        get_alignment = adapter.get_alignment
        get_width     = adapter.get_width
        for i, label in enumerate( adapter.label_map ):
            control.InsertColumn( i, label,
                       alignment_map.get( get_alignment( object, name, i ),
                                                         wx.LIST_FORMAT_LEFT ) )
        self._set_column_widths()

    def _rebuild_all ( self ):
        """ Rebuilds the structure of the list control, then refreshes its
            contents.
        """
        self._rebuild()
        self.update_editor()

    def _set_column_widths ( self ):
        """ Set the column widths for the current set of columns.
        """
        control = self.control
        if control is None:
            return

        object, name = self.object, self.name
        dx, dy       = control.GetClientSize()
        if is_mac:
            dx -= scrollbar_dx
        n            = control.GetColumnCount()
        get_width    = self.adapter.get_width
        pdx          = 0
        wdx          = 0.0
        widths       = []
        cached       = self._cached_widths
        current      = [ control.GetColumnWidth( i ) for i in xrange( n ) ]
        if (cached is None) or (len( cached ) != n):
            self._cached_widths = cached = [ None ] * n

        for i in xrange( n ):
            cw = cached[i]
            if (cw is None) or (-cw == current[i]):
                width = float( get_width( object, name, i ) )
                if width <= 0.0:
                    width = 0.1
                if width <= 1.0:
                    wdx += width
                    cached[i] = -1
                else:
                    width = int( width )
                    pdx  += width
                    if cw is None:
                        cached[i] = width
            else:
                cached[i] = width = current[i]
                pdx += width

            widths.append( width )

        adx = max( 0, dx - pdx )

        control.Freeze()
        for i in range( n ):
            width = cached[i]
            if width < 0:
                width = widths[i]
                if width <= 1.0:
                    widths[i] = w = max( 30, int( round( (adx * width)/wdx ) ) )
                    wdx      -= width
                    width     = w
                    adx      -= width
                    cached[i] = -w

            control.SetColumnWidth( i, width )

        control.Thaw()

    def _add_image ( self, image_resource ):
        """ Adds a new image to the wx.ImageList and its associated mapping.
        """
        bitmap = image_resource.create_image().ConvertToBitmap()

        image_list = self._image_list
        if image_list is None:
            self._image_list = image_list = wx.ImageList( bitmap.GetWidth(),
                                                          bitmap.GetHeight() )
            self.control.AssignImageList( image_list, wx.IMAGE_LIST_SMALL )

        self.image_resources[image_resource] = \
        self.images[ image_resource.name ]   = row = image_list.Add( bitmap )

        return row

    def _get_image ( self, image ):
        """ Converts a user specified image to a wx.ListCtrl image index.
        """
        if isinstance( image, basestring ):
            self.image = image
            image      = self.image

        if isinstance( image, ImageResource ):
            result = self.image_resources.get( image )
            if result is not None:
                return result

            return self._add_image( image )

        return self.images.get( image )

    def _get_selected ( self ):
        """ Returns a list of the rows of all currently selected list items.
        """
        selected = []
        item     = -1
        control  = self.control

        # Handle case where the list is cleared
        if len( self.value ) == 0:
            return selected

        while True:
            item = control.GetNextItem( item, wx.LIST_NEXT_ALL,
                                              wx.LIST_STATE_SELECTED )
            if item == -1:
                break;

            selected.append( item )

        return selected

    def _append_new ( self ):
        """ Append a new item to the end of the list control.
        """
        if 'append' in self.factory.operations:
            adapter   = self.adapter
            self.row  = self.control.GetItemCount()
            self.edit = True
            adapter.insert( self.object, self.name, self.row,
                           adapter.get_default_value( self.object, self.name ) )

    def _insert_current ( self ):
        """ Inserts a new item after the currently selected list control item.
        """
        if 'insert' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                adapter = self.adapter
                adapter.insert( self.object, self.name, selected[0],
                           adapter.get_default_value( self.object, self.name ) )
                self.row  = selected[0]
                self.edit = True

    def _delete_current ( self ):
        """ Deletes the currently selected items from the list control.
        """
        if 'delete' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 0:
                return

            delete = self.adapter.delete
            selected.reverse()
            for row in selected:
                delete( self.object, self.name, row )

            n = self.adapter.len( self.object, self.name )
            if not self.factory.multi_select:
                self.selected_row = self.row = n-1 if row>=n else row
            else:
                #FIXME: What should the selection be?
                self.multi_selected = []
                self.multi_selected_rows = []

    def _move_up_current ( self ):
        """ Moves the currently selected item up one line in the list control.
        """
        if 'move' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                row = selected[0]
                if row > 0:
                    adapter      = self.adapter
                    object, name = self.object, self.name
                    item         = adapter.get_item( object, name, row )
                    adapter.delete( object, name, row )
                    adapter.insert( object, name, row - 1, item )
                    self.row = row - 1

    def _move_down_current ( self ):
        """ Moves the currently selected item down one line in the list control.
        """
        if 'move' in self.factory.operations:
            selected = self._get_selected()
            if len( selected ) == 1:
                row = selected[0]
                if row < (self.control.GetItemCount() - 1):
                    adapter      = self.adapter
                    object, name = self.object, self.name
                    item         = adapter.get_item( object, name, row )
                    adapter.delete( object, name, row )
                    adapter.insert( object, name, row + 1, item )
                    self.row = row + 1

    def _edit_current ( self ):
        """ Allows the user to edit the current item in the list control.
        """
        if 'edit' in self.factory.operations and self.factory.editable_labels:
            selected = self._get_selected()
            if len( selected ) == 1:
                self.control.EditLabel( selected[0] )

    def _get_column ( self, x, translate = False ):
        """ Returns the column index corresponding to a specified x position.
        """
        if x >= 0:
            control = self.control
            for i in range( control.GetColumnCount() ):
                x -= control.GetColumnWidth( i )
                if x < 0:
                    if translate:
                        return self.adapter.get_column(
                                   self.object, self.name, i )

                    return i

        return None

    def _mouse_click ( self, event, trait ):
        """ Generate a TabularEditorEvent event for a specified mouse event and
            editor trait name.
        """
        x          = event.GetX()
        row, flags = self.control.HitTest( wx.Point( x, event.GetY() ) )
        if row == wx.NOT_FOUND:
            if self.factory.multi_select:
                self.multi_selected = []
                self.multi_selected_rows = []
            else:
                self.selected = None
                self.selected_row = -1
        else:
            if self.factory.multi_select and event.ShiftDown():
                # Handle shift-click multi-selections because the wx.ListCtrl
                # does not (by design, apparently).
                # We must append this to the event queue because the
                # multi-selection will not be recorded until this event handler
                # finishes and lets the widget actually handle the event.
                do_later( self._item_selected, None )

            setattr( self, trait, TabularEditorEvent(
                editor = self,
                row    = row,
                column = self._get_column( x, translate = True )
            ) )

        # wx should continue with additional event handlers. Skip(False)
        # actually means to skip looking, skip(True) means to keep looking.
        # This seems backwards to me...
        event.Skip(True)

#-------------------------------------------------------------------------------
#  'TabularEditorEvent' class:
#-------------------------------------------------------------------------------

class TabularEditorEvent ( HasStrictTraits ):

    # The index of the row:
    row = Int

    # The id of the column (either a string or an integer):
    column = Any

    # The row item:
    item = Property

    #-- Private Traits ---------------------------------------------------------

    # The editor the event is associated with:
    editor = Instance( TabularEditor )

    #-- Property Implementations -----------------------------------------------

    def _get_item ( self ):
        editor = self.editor
        return editor.adapter.get_item( editor.object, editor.name, self.row )


########NEW FILE########
__FILENAME__ = text_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/21/2004
#
#------------------------------------------------------------------------------

""" Defines the various text editors for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#------------------------------------------------------------------------------

import wx

from traits.api \
    import TraitError

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.text_editor file.
from traitsui.editors.text_editor \
    import ToolkitEditorFactory, evaluate_trait

from editor \
    import Editor

from editor_factory \
    import ReadonlyEditor as BaseReadonlyEditor

from constants \
    import OKColor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Readonly text editor with view state colors:
HoverColor = wx.LIGHT_GREY
DownColor  = wx.WHITE

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style text editor, which displays a text field.
    """

    # Flag for window styles:
    base_style = 0

    # Background color when input is OK:
    ok_color = OKColor

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function used to evaluate textual user input:
    evaluate = evaluate_trait

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory       = self.factory
        style         = self.base_style
        self.evaluate = factory.evaluate
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        if (not factory.multi_line) or factory.password:
            style &= ~wx.TE_MULTILINE

        if factory.password:
            style |= wx.TE_PASSWORD

        multi_line = ((style & wx.TE_MULTILINE) != 0)
        if multi_line:
            self.scrollable = True

        if factory.enter_set and (not multi_line):
            control = wx.TextCtrl( parent, -1, self.str_value,
                                   style = style | wx.TE_PROCESS_ENTER )
            wx.EVT_TEXT_ENTER( parent, control.GetId(), self.update_object )
        else:
            control = wx.TextCtrl( parent, -1, self.str_value, style = style )

        wx.EVT_KILL_FOCUS( control, self.update_object )

        if factory.auto_set:
            wx.EVT_TEXT( parent, control.GetId(), self.update_object )

        self.control = control
        self.set_error_state( False )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        if (not self._no_update) and (self.control is not None):
            try:
                self.value = self._get_user_value()

                if self._error is not None:
                    self._error     = None
                    self.ui.errors -= 1

                self.set_error_state( False )

            except TraitError, excp:
                pass

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        user_value = self._get_user_value()
        try:
            unequal = bool( user_value != self.value )
        except ValueError:
            # This might be a numpy array.
            unequal = True

        if unequal:
            self._no_update = True
            self.control.SetValue( self.str_value )
            self._no_update = False

        if self._error is not None:
            self._error     = None
            self.ui.errors -= 1
            self.set_error_state( False )

    #---------------------------------------------------------------------------
    #  Gets the actual value corresponding to what the user typed:
    #---------------------------------------------------------------------------

    def _get_user_value ( self ):
        """ Gets the actual value corresponding to what the user typed.
        """
        value = self.control.GetValue()
        try:
            value = self.evaluate( value )
        except:
            pass

        try:
            ret = self.factory.mapping.get( value, value )
        except TypeError:
            # The value is probably not hashable:
            ret = value

        return ret

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        if self._error is None:
            self._error     = True
            self.ui.errors += 1

        self.set_error_state( True )

    #---------------------------------------------------------------------------
    #  Returns whether or not the editor is in an error state:
    #---------------------------------------------------------------------------

    def in_error_state ( self ):
        """ Returns whether or not the editor is in an error state.
        """
        return (self.invalid or self._error)

#-------------------------------------------------------------------------------
#  'CustomEditor' class:
#-------------------------------------------------------------------------------

class CustomEditor ( SimpleEditor ):
    """ Custom style of text editor, which displays a multi-line text field.
    """

    # Flag for window style. This value overrides the default.
    base_style = wx.TE_MULTILINE

#-------------------------------------------------------------------------------
#  'ReadonlyEditor' class:
#-------------------------------------------------------------------------------

class ReadonlyEditor ( BaseReadonlyEditor ):
    """ Read-only style of text editor, which displays a read-only text field.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        super( ReadonlyEditor, self ).init( parent )

        if self.factory.view is not None:
            control = self.control
            wx.EVT_ENTER_WINDOW( control, self._enter_window )
            wx.EVT_LEAVE_WINDOW( control, self._leave_window )
            wx.EVT_LEFT_DOWN(    control, self._left_down )
            wx.EVT_LEFT_UP(      control, self._left_up )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        control   = self.control
        new_value = self.str_value

        if hasattr(self.factory, 'password') and self.factory.password:
            new_value = '*' * len( new_value )

        if (self.item.resizable is True) or (self.item.height != -1.0):
            if control.GetValue() != new_value:
                control.SetValue( new_value )
                control.SetInsertionPointEnd()

        elif control.GetLabel() != new_value:
            control.SetLabel( new_value )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        if self.factory.view is not None:
            control = self.control
            wx.EVT_ENTER_WINDOW( control, None )
            wx.EVT_LEAVE_WINDOW( control, None )
            wx.EVT_LEFT_DOWN(    control, None )
            wx.EVT_LEFT_UP(      control, None )

        super( ReadonlyEditor, self ).dispose()

    #-- Private Methods --------------------------------------------------------

    def _set_color ( self ):
        control = self.control
        if not self._in_window:
            color = control.GetParent().GetBackgroundColour()
        elif self._down:
            color = DownColor
        else:
            color = HoverColor

        control.SetBackgroundColour( color )
        control.Refresh()

    #-- wxPython Event Handlers ------------------------------------------------

    def _enter_window ( self, event ):
        self._in_window = True
        self._set_color()

    def _leave_window ( self, event ):
        self._in_window = False
        self._set_color()

    def _left_down ( self, event ):
        self.control.CaptureMouse()
        self._down = True
        self._set_color()

    def _left_up ( self, event ):
        self._set_color()
        if not self._down:
            return

        self.control.ReleaseMouse()
        self._down = False

        if self._in_window:
            self.object.edit_traits( view   = self.factory.view,
                                     parent = self.control )

TextEditor = SimpleEditor

########NEW FILE########
__FILENAME__ = themed_button_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/26/2007
#
#-------------------------------------------------------------------------------

""" Traits UI themed button editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Instance, Str, on_trait_change

from traitsui.api \
    import Theme

from traitsui.ui_traits \
    import ATheme, AView, Image, Position, Spacing

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

from themed_control \
    import ThemedControl

#-------------------------------------------------------------------------------
#  '_ThemedButtonEditor' class:
#-------------------------------------------------------------------------------

class _ThemedButtonEditor ( Editor ):
    """ Traits UI themed button editor.
    """

    # The ThemedControl used for the button:
    button = Instance( ThemedControl )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Create the button and its control:
        factory = self.factory
        label   = factory.label
        if (label == '') and (factory.image is None):
            label = self.item.get_label( self.ui )
        label = self.string_value( label )

        self.button = button = ThemedControl( **factory.get(
            'theme', 'image', 'position', 'spacing' ) ).set(
            text              = label,
            controller        = self,
            default_alignment = 'center',
            min_size          = ( 80, 0 ) )
        self.control = button.create_control( parent )

        # Set the tooltip:
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        pass

    #-- Trait Event Handlers ---------------------------------------------------

    @on_trait_change( 'button.enabled' )
    def _on_enabled_changed ( self ):
        """ Handles the button 'enabled' state changing.
        """
        if self.button.enabled:
            self.button.set( state  = 'normal',
                             offset = ( 0, 0 ),
                             theme  = self.factory.theme )
        else:
            self.button.set( state  = 'disabled',
                             offset = ( 0, 0 ),
                             theme  = self.factory.disabled_theme or
                                      self.factory.theme )

    #-- ThemedControl Event Handlers -------------------------------------------

    def normal_left_down ( self, x, y, event ):
        if self.control.IsEnabled():
            self.button.set( state  = 'down',
                             offset = ( 1, 1 ),
                             theme  = self.factory.down_theme or
                                      self.factory.theme )

    def normal_motion ( self, x, y, event ):
        hover = self.factory.hover_theme
        if self.control.IsEnabled() and (hover is not None):
            self.button.set( state = 'hover', theme = hover )
            self.control.CaptureMouse()

    def hover_left_down ( self, x, y, event ):
        self.control.ReleaseMouse()
        self.normal_left_down( x, y, event )

    def hover_motion ( self, x, y, event ):
        if not self.button.in_control( x, y ):
            self.control.ReleaseMouse()
            self.button.set( state = 'normal', theme = self.factory.theme )

    def down_left_up ( self, x, y, event ):
        if self.button.in_control( x, y ):
            self.value = True

            # If there is an associated view, display it:
            if self.factory.view is not None:
                self.object.edit_traits( view   = self.factory.view,
                                         parent = self.control )

        self.button.set( state  = 'normal',
                         offset = ( 0, 0 ),
                         theme  = self.factory.theme )

    def down_motion ( self, x, y, event ):
        theme = self.factory.down_theme or self.factory.theme
        is_in = self.button.in_control( x, y )
        if not is_in:
            theme = self.factory.theme

        self.button.set( offset = ( is_in, is_in ), theme = theme )

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for themed button editors:
class ThemedButtonEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _ThemedButtonEditor

    # The button label:
    label = Str

    # The basic theme for the button (i.e. the 'up' state):
    theme = ATheme( '@std:BG5' )

    # The optional 'down' state theme for the button:
    down_theme = ATheme( '@std:BE5' )

    # The optional 'hover' state theme for the button:
    hover_theme = ATheme( '@std:BG6' )

    # The optional 'disabled' state theme for the button:
    disabled_theme = ATheme( '@std:GG3' )

    # The optional image to display in the button:
    image = Image

    # The position of the image relative to the text:
    position = Position

    # The amount of space between the image and the text:
    spacing = Spacing

    # The optional view to display when the button is clicked:
    view = AView


########NEW FILE########
__FILENAME__ = themed_cell_renderer
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/13/2004
#
#------------------------------------------------------------------------------

""" Defines the ThemedCellRenderer class used to render theme-based cells for
    the TableEditor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from wx.grid \
    import PyGridCellRenderer, GridCellStringRenderer

from traitsui.ui_traits \
    import convert_bitmap

from helper \
    import BufferDC

#-------------------------------------------------------------------------------
#  'ThemedCellRenderer' class:
#-------------------------------------------------------------------------------

class ThemedCellRenderer ( PyGridCellRenderer ):
    """ Defines the ThemedCellRenderer class used to render theme-based cells
        for the TableEditor.
    """

    def __init__( self, column ):
        """ Creates a new ThemedCellRenderer.
        """
        PyGridCellRenderer.__init__( self )

        # We are merging the pyface grid GridCellRenderer interface with the
        # wx.grid.PyGridCellRenderer interface, so we need to do this:
        self.renderer = self

        # Save the reference to the TableColumn:
        self.column = column

    #-- PyFace grid GridCellRenderer Method Overrides --------------------------

    # Invoked on left-button mouse clicks:
    def on_left_click ( self, grid, row, col ):
        return False

    # Invoked on left-button mouse double clicks:
    def on_left_dclick ( self, grid, row, col ):
        return False

    # Invoked on right-button mouse clicks:
    def on_right_click ( self, grid, row, col ):
        return False

    # Invoked on right-button mouse double clicks:
    def on_right_dclick ( self, grid, row, col ):
        return False

    # Invoked on a key press:
    def on_key ( self, grid, row, col, key_event ):
        return False

    # Clean-up:
    def dispose ( self ):
        del self.renderer
        del self.column

    #-- wx.GridCellRenderer Method Overrides -----------------------------------

    def Draw ( self, grid, attr, dc, rect, row, col, is_selected ):
        """ Draws the contents of the specified grid cell.
        """
        # Get the model object this cell is being rendered for:
        model  = grid.grid.model
        object = model.get_filtered_item( row )

        # Get the draw bounds:
        x0  = rect.x
        y0  = rect.y
        dx  = rect.width
        dy  = rect.height

        # Do all drawing into an off-screen buffer:
        bdc = BufferDC( dc, dx, dy )

        # Draw the appropriate theme background:
        column = self.column
        if is_selected:
            theme = (column.get_selected_theme( object ) or
                     column.get_cell_theme(     object ))
        else:
            theme = column.get_cell_theme( object )

        # If no column theme is specified, try to get the global theme from the
        # model:
        if theme is None:
            if row & 1:
                theme = model.alt_theme or model.cell_theme
            else:
                theme = model.cell_theme

            if is_selected:
                theme = model.selected_theme or theme

        if theme is not None:
            content = theme.content
            slice   = theme.image_slice
            slice.fill( bdc, 0, 0, dx, dy )

            # Set up the correct text color to use:
            bdc.SetTextForeground( theme.content_color )

            # Calculate the margins for the draw area:
            left   = slice.xleft   + content.left
            top    = slice.xtop    + content.top
            right  = slice.xright  + content.right
            bottom = slice.xbottom + content.bottom
            ox, oy = theme.label.left, theme.label.top
        else:
            if is_selected:
                bg_color = grid.GetSelectionBackground()
            else:
                bg_color = attr.GetBackgroundColour()

            bdc.SetBackgroundMode( wx.SOLID )
            bdc.SetBrush( wx.Brush( bg_color, wx.SOLID ) )
            bdc.SetPen( wx.TRANSPARENT_PEN )
            bdc.DrawRectangle( 0, 0, dx, dy )

            # Set up the correct text color to use:
            bdc.SetTextForeground( attr.GetTextColour() )

            # Calculate the margins for the draw area:
            left = right  = self.column.horizontal_margin
            top  = bottom = self.column.vertical_margin
            ox   = oy     = 0

        # Get the alignment information:
        halign, valign = attr.GetAlignment()

        # Draw the bar graph (if any):
        maximum = column.get_maximum( object )
        if (not is_selected) and (maximum > 0.0):
            if theme is None:
                left = right = top = bottom = 0
            try:
                ratio    = max( min( column.get_raw_value( object ) / maximum,
                                     1.0 ), -1.0 )
                avail_dx = dx - left - right
                bar_dx   = int( round( ratio * avail_dx ) )
                if halign == wx.ALIGN_CENTRE:
                    bar_dx /= 2
                    bar_x   = left + (avail_dx / 2) + min( 0, bar_dx )
                else:
                    bar_dx = abs( bar_dx )
                    if halign == wx.ALIGN_LEFT:
                        bar_x = left
                        left += self.column.horizontal_margin
                    else:
                        bar_x  = avail_dx - bar_dx
                        right += self.column.horizontal_margin

                if bar_dx > 0:
                    bdc.SetBackgroundMode( wx.SOLID )
                    bdc.SetBrush( wx.Brush( column.get_graph_color( object ),
                                            wx.SOLID ) )
                    bdc.SetPen( wx.TRANSPARENT_PEN )
                    bdc.DrawRectangle( bar_x, top, bar_dx, dy - top - bottom )
            except:
                pass

            if theme is None:
                left = right  = self.column.horizontal_margin
                top  = bottom = self.column.vertical_margin

        # Get the optional image bitmap and text:
        bitmap = convert_bitmap( column.get_image( object ) )
        text   = grid.GetCellValue( row, col )

        # If no text or bitmap to display, then we are done:
        if (bitmap is None) and (text == ''):
            bdc.copy( x0, y0 )
            return

        # Get the bitmap size:
        idx = idy = tdx = tdy = 0
        if bitmap is not None:
            idx = bitmap.GetWidth()
            idy = bitmap.GetHeight()

        # Get the text size:
        if text != '':
            bdc.SetFont( attr.GetFont() )
            tdx, tdy = bdc.GetTextExtent( text )

            # Get the spacing between text and image:
            if bitmap is not None:
                idx += self.column.horizontal_margin

        # Calculate the x-coordinate of the image/text:
        if halign == wx.ALIGN_LEFT:
            x = left
        elif halign == wx.ALIGN_CENTRE:
            x = (left + ((dx - left - right - tdx - idx) / 2))
        else:
            x = (dx - right - tdx - idx)

        # Calculate the y-coordinate of the image/text:
        max_dy = max( tdy, idy )
        if valign == wx.ALIGN_TOP:
            y = top
        elif valign == wx.ALIGN_CENTRE:
            y = (top + ((dy - top - bottom - max_dy) / 2))
        else:
            y = (dy - bottom - max_dy)

        # Set up the clipping region to prevent drawing outside the margins:
        bdc.SetClippingRegion( left, top, dx - left - right, dy - top - bottom )

        # Draw the image (if left or center aligned):
        if (bitmap is not None) and (halign != wx.ALIGN_RIGHT):
            bdc.DrawBitmap( bitmap, x, y + ((max_dy - idy) / 2),  True )
            x += idx

        # Finally, draw the text:
        if text != '':
            bdc.SetBackgroundMode( wx.TRANSPARENT )
            bdc.DrawText( text, x + ox, y + oy )
            x += tdx + self.column.horizontal_margin

        # Draw the image (if right-aligned):
        if (bitmap is not None) and (halign == wx.ALIGN_RIGHT):
            bdc.DrawBitmap( bitmap, x, y + ((max_dy - idy) / 2),  True )

        # Discard the clipping region:
        bdc.DestroyClippingRegion()

        # Copy the buffer to the display:
        bdc.copy( x0, y0 )

    def GetBestSize ( self, grid, attr, dc, row, col ):
        """ Determine best size for the cell. """
        # Get the model object this cell is being rendered for:
        object = grid.grid.model.get_filtered_item( row )

        # Get the text for this cell:
        text = grid.GetCellValue( row, col ) or 'My'

        # Now calculate and return the best size for the text and image:
        dc.SetFont( attr.GetFont() )
        tdx, tdy = dc.GetTextExtent( text )

        column = self.column
        bitmap = convert_bitmap( column.get_image( object ) )
        if bitmap is not None:
            tdx += (bitmap.GetWdth() + self.column.horizontal_margin)
            tdy  = max( tdy, bitmap.GetHeight() )

        theme = column.get_cell_theme( object )
        if theme is None:
            return wx.Size( tdx + self.column.horizontal_margin * 2, tdy + self.column.vertical_margin * 2 )

        content = theme.content
        tdx    += (content.left + content.right)
        tdy    += (content.top  + content.bottom)
        slice   = theme.image_slice

        return wx.Size( max( slice.left  + slice.right,
                             slice.xleft + slice.xright  + tdx ),
                        max( slice.top   + slice.bottom,
                             slice.xtop  + slice.xbottom + tdy ) )

    def Clone ( self ):
        return self.__class__( self.column )


########NEW FILE########
__FILENAME__ = themed_checkbox_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/04/2007
#
#-------------------------------------------------------------------------------

""" Traits UI themed checkbox editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Instance, Str

from traitsui.ui_traits \
    import ATheme, Image, Position, Spacing

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

from themed_control \
    import ThemedControl

#-------------------------------------------------------------------------------
#  '_ThemedCheckboxEditor' class:
#-------------------------------------------------------------------------------

class _ThemedCheckboxEditor ( Editor ):
    """ Traits UI themed checkbox editor.
    """

    # The ThemedControl used for the checkbox:
    checkbox = Instance( ThemedControl )

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        # Create the checkbox and its control:
        item      = self.item
        factory   = self.factory
        label     = self.string_value( factory.label or item.label )
        min_size  = ( 0, 0 )
        if factory.theme is not None:
            min_size  = ( 80, 0 )

        self.checkbox = checkbox = ThemedControl( **factory.get(
            'image', 'position', 'spacing', 'theme' ) ).set(
            text       = label,
            controller = self,
            min_size   = min_size )
        self.control = checkbox.create_control( parent )

        # Set the tooltip:
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self.checkbox.state == 'hover':
            self._set_hover_theme()
        else:
            self._set_theme()

    #-- ThemedControl Event Handlers -------------------------------------------

    def normal_motion ( self, x, y, event ):
        self._set_hover_theme( 'hover' )
        self.control.CaptureMouse()

    def hover_left_down ( self, x, y, event ):
        self.control.ReleaseMouse()
        self._set_hover_theme( 'down', not self.value )

    def hover_motion ( self, x, y, event ):
        if not self.checkbox.in_control( x, y ):
            self.control.ReleaseMouse()
            self._set_theme( 'normal' )

    def down_left_up ( self, x, y, event ):
        if self.checkbox.in_control( x, y ):
            self.value = not self.value
            self.normal_motion( x, y, event )
        else:
            self._set_theme( 'normal' )

    def down_motion ( self, x, y, event ):
        if not self.checkbox.in_control( x, y ):
            self._set_theme()
        else:
            self._set_hover_theme( value = not self.value )

    #-- Private Methods --------------------------------------------------------

    def _set_theme ( self, state = None, value = None ):
        """ Sets the theme, image, offset and optional checkbox state to use for
            a specified checkbox state value.
        """
        if value is None:
            value = self.value

        factory      = self.factory
        theme, image = factory.theme, factory.image
        if value:
            theme, image = factory.on_theme, factory.on_image

        n = (1 * value) * (theme is not None)
        self.checkbox.set( offset = ( n, n ),
                           theme  = theme or factory.theme,
                           image  = image or factory.image,
                           state  = state or self.checkbox.state )

    def _set_hover_theme ( self, state = None, value = None ):
        """ Sets the theme, image, offset and optional checkbox state to use for
            a specified checkbox state value while in hover mode.
        """
        if value is None:
            value = self.value

        factory      = self.factory
        theme, image = factory.hover_off_theme, factory.hover_off_image
        if value:
            theme = factory.hover_on_theme or factory.on_theme
            image = factory.hover_on_image or factory.on_image

        n = (1 * value) * (theme is not None)
        self.checkbox.set( offset = ( n, n ),
                           theme  = theme or factory.theme,
                           image  = image or factory.image,
                           state  = state or self.checkbox.state )

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for themed checkbox editors:
class ThemedCheckboxEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _ThemedCheckboxEditor

    # The checkbox label:
    label = Str

    # The basic theme for the checkbox (i.e. the 'off' state):
    theme = ATheme

    # The optional 'on' state theme for the checkbox:
    on_theme = ATheme

    # The optional 'hover off' state theme for the checkbox:
    hover_off_theme = ATheme

    # The optional 'hover on' state theme for the checbox:
    hover_on_theme = ATheme

    # The optional image to display in the checkbox (i.e. the 'off' state):
    image = Image( 'cb_off' )

    # The optional 'on' state image to display in the checkbox:
    on_image = Image( 'cb_on' )

    # The optional 'hover off' state image to display in the checkbox:
    hover_off_image = Image( 'cb_hover_off' )

    # The optional 'hover on' state image to display in the checkbox:
    hover_on_image = Image( 'cb_hover_on' )

    # The position of the image relative to the text:
    position = Position

    # The amount of space between the image and the text:
    spacing = Spacing

#-------------------------------------------------------------------------------
#  Helper function for creating themed checkboxes:
#-------------------------------------------------------------------------------

def themed_checkbox_editor ( style = None, show_checkbox = True, **traits ):
    """ Simplifies creation of a ThemedCheckboxEditor by setting up the
        themes and images automatically based on the value of the *style* and
        *show_checkbox* arguments.
    """
    tce = ThemedCheckboxEditor( **traits )

    if not show_checkbox:
        tce.set( image           = None,
                 on_image        = None,
                 hover_off_image = None,
                 hover_on_image  = None )

    if isinstance( style, basestring ):
        group = style[0:1].upper()
        if (len( group ) == 0) or (group not in 'BCGJTY'):
            group = 'B'

        row      = style[1:2].upper()
        all_rows = '0123456789ABCDEFGHIJKL'
        if (len( row ) == 0) or (row not in all_rows):
            row = 'H'

        column      = style[2:3].upper()
        all_columns = '12345789AB'
        if (len( column ) == 0) or (column not in all_columns):
            column = '5'

        tce.theme = '@%s%s%s' % ( group, row, column )

        if style[-1:] == '.':
            return tce

        alt_row    = '44456349A78FFFGHEFKLIJ'[ all_rows.index( row ) ]
        alt_column = '66666CCCCC'[ all_columns.index( column ) ]

        tce.set( on_theme        = '@%s%s%s' % ( group, alt_row, column ),
                 hover_on_theme  = '@%s%s%s' % ( group, alt_row, alt_column ),
                 hover_off_theme = '@%s%s%s' % ( group, row, alt_column ) )

    return tce

########NEW FILE########
__FILENAME__ = themed_control
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/03/2007
#
#-------------------------------------------------------------------------------

""" Defines 'ThemedControl, a themed control based class. A 'themed' control is
    a control (optionally) supporting a stretchable background image.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasTraits, Str, Int, Enum, Bool, Property, Event, Tuple, Instance, \
           cached_property, on_trait_change

from traitsui.api \
    import default_theme

from traitsui.ui_traits \
    import Image, Position, Alignment, Spacing

from image_slice import ImageSlice

from themed_window \
    import ThemedWindow

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# The size of an empty text string:
ZeroTextSize = ( 0, 0, 0, 0 )

# An empty position and size bounds:
EmptyBounds = ( 0, 0, 0, 0 )

# Targets for '_get_bounds_for' method:
TheText    = 0
TheBitmap  = 1
TheControl = 2

#-------------------------------------------------------------------------------
#  'ThemedControl' class:
#-------------------------------------------------------------------------------

class ThemedControl ( ThemedWindow ):

    #-- Public Traits ----------------------------------------------------------

    # An (optional) image to be drawn inside the control:
    image = Image( event = 'updated' )

    # The (optional) text to be displayed inside the control:
    text = Str( event = 'updated' )

    # The position of the image relative to the text:
    position = Position( event = 'updated' )

    # The amount of spacing between the image and the text:
    spacing = Spacing( event = 'updated' )

    # Is the text value private (like a password):
    password = Bool( False, event = 'updated' )

    # An additional, optional offset to apply to the text/image position:
    offset = Tuple( Int, Int )

    # Minimum default size for the control:
    min_size = Tuple( Int, Int )

    # Is the control enabled:
    enabled = Bool( True )

    #-- Private Traits ---------------------------------------------------------

    # An event fired when any display related value changes:
    updated = Event

    # The underlying wx.Window control:
    control = Instance( wx.Window )

    # The current text value to display:
    current_text = Property( depends_on = 'text, password' )

    # The best size for the control:
    best_size = Property

    # The size of the current text:
    text_size = Property( depends_on = 'current_text, control' )

    # The position and size of the current text within the control:
    text_bounds = Property( depends_on = 'updated' )

    # The position and size of the current bitmap within the control:
    bitmap_bounds = Property( depends_on = 'updated' )

    #-- Public Methods ---------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the underlying wx.Window object.
        """
        self.control = control = wx.Window( parent, -1,
                            size  = wx.Size( 70, 20 ),
                            style = wx.FULL_REPAINT_ON_RESIZE | wx.WANTS_CHARS )

        # Initialize the control (set-up event handlers, ...):
        self.init_control()

        # Make sure all internal state gets initialized:
        self._image_changed( self.image )

        # Make sure the control is sized correctly:
        size = self.best_size
        control.SetMinSize( size )
        control.SetSize( size )

        return control

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_current_text ( self ):
        """ Returns the current text to display.
        """
        if self.password:
            return '*' * len( self.text )

        return self.text

    def _get_best_size ( self ):
        """ Returns the 'best' size for the control.
        """
        cx, cy, cdx, cdy = self._get_bounds_for( TheControl )
        mdx, mdy         = self.min_size
        return wx.Size( max( cdx, mdx ), max( cdy, mdy ) )

    @cached_property
    def _get_text_size ( self ):
        """ Returns the text size information for the window.
        """
        text = self.current_text
        if (text == '') or (self.control is None):
            return ZeroTextSize

        return self.control.GetFullTextExtent( text )

    @cached_property
    def _get_text_bounds ( self ):
        """ Returns the position and size of the text within the window.
        """
        return self._get_bounds_for( TheText )

    @cached_property
    def _get_bitmap_bounds ( self ):
        """ Returns the size and position of the bitmap within the window.
        """
        return self._get_bounds_for( TheBitmap )

    #-- Event Handlers ---------------------------------------------------------

    @on_trait_change( 'theme.+, image' )
    def _updated_changed ( self ):
        """ Handles any update related trait being changed.
        """
        if self.control is not None:
            self.control.Refresh()

    def _image_changed ( self, image ):
        """ Handles the image being changed by updating the corresponding
            bitmap.
        """
        if image is None:
            self._bitmap = None
        else:
            self._bitmap = image.create_image().ConvertToBitmap()

    #-- wxPython Event Handlers ------------------------------------------------

    def _paint_fg ( self, dc ):
        """ Paints the foreground into the specified device context.
        """
        self.enabled = self.control.IsEnabled()

        # Get the text and image offset to use:
        theme    = self.theme or default_theme
        label    = theme.label
        ox, oy   = label.left, label.top
        ox2, oy2 = self.offset
        ox      += ox2
        oy      += oy2

        # Draw the bitmap (if any):
        ix, iy, idx, idy = self.bitmap_bounds
        if idx != 0:
            dc.DrawBitmap( self._bitmap, ix + ox, iy + oy, True )

        # Draw the text (if any):
        tx, ty, tdx, tdy = self.text_bounds
        if tdx != 0:
            dc.SetBackgroundMode( wx.TRANSPARENT )
            dc.SetTextForeground( theme.content_color )
            dc.SetFont( self.control.GetFont() )
            dc.DrawText( self.current_text, tx + ox, ty + oy )

    def _size ( self, event ):
        """ Handles the control being resized.
        """
        super( ThemedControl, self )._size( event )
        self.updated = True

    #-- Private Methods --------------------------------------------------------

    def _get_bounds_for ( self, item ):
        """ Returns all text and image related position and size information.
        """
        control = self.control
        if control is None:
            return EmptyBounds

        tdx, tdy, descent, leading = self.text_size
        bitmap = self._bitmap
        if bitmap is None:
            bdx, bdy = 0, 0
        else:
            bdx, bdy = bitmap.GetWidth(), bitmap.GetHeight()
        if (tdx + bdx) == 0:
            return EmptyBounds

        wdx, wdy  = control.GetClientSizeTuple()
        spacing   = (tdx != 0) * (bdx != 0) * self.spacing
        theme     = self.theme or default_theme
        slice     = theme.image_slice or ImageSlice()
        content   = theme.content

        position = self.position
        if position in ( 'above', 'below' ):
            cdx = max( tdx, bdx )
            cdy = tdy + spacing + bdy
        else:
            cdx = tdx + spacing + bdx
            cdy = max( tdy, bdy )

        if item == TheControl:
            cdx += content.left + content.right
            cdy += content.top  + content.bottom

            return ( 0, 0, max( slice.left  + slice.right,
                                slice.xleft + slice.xright  + cdx ),
                           max( slice.top   + slice.bottom,
                                slice.xtop  + slice.xbottom + cdy ) )

        alignment = theme.alignment
        if alignment == 'default':
            alignment = self.default_alignment
        if alignment == 'left':
            x = slice.xleft + content.left
        elif alignment == 'center':
            x = slice.xleft + content.left + ((wdx - slice.xleft - slice.xright
                            - content.left - content.right - cdx) / 2)
        else:
            x = wdx - slice.xright - content.right - cdx

        if position == 'left':
            bx = x
            tx = bx + bdx + spacing
        elif position == 'right':
            tx = x
            bx = tx + tdx + spacing
        else:
            x += (max( tdx, bdx ) / 2)
            tx = x - (tdx / 2 )
            bx = x - (bdx / 2 )

        y = slice.xtop + content.top + ((wdy - slice.xtop - slice.xbottom -
                         content.top - content.bottom - cdy) / 2)
        if position == 'above':
            by = y
            ty = by + bdy + spacing
        elif position == 'below':
            ty = y
            by = ty + tdy + spacing
        else:
            y += (max( tdy, bdy ) / 2)
            ty = y - ((tdy + 1) / 2)
            by = y - (bdy / 2)

        if item == TheText:
            return ( tx, ty, tdx, tdy )

        return ( bx, by, bdx, bdy )


########NEW FILE########
__FILENAME__ = themed_slider_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/22/2007
#
#-------------------------------------------------------------------------------

""" Traits UI simple, themed slider-based integer or float value editor.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from math \
   import log10, pow

from traits.api \
    import HasPrivateTraits, Instance, Enum, Range, Str, Float, Bool, Color, \
           TraitError

from traitsui.ui_traits \
    import Alignment

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

from pyface.timer.api \
    import do_after

from constants \
    import ErrorColor

from helper \
    import disconnect, disconnect_no_id, BufferDC

#-------------------------------------------------------------------------------
#  '_ThemedSliderEditor' class:
#-------------------------------------------------------------------------------

class _ThemedSliderEditor ( Editor ):
    """ Traits UI simple, themed slider-based integer or float value editor.
    """

    # The low end of the slider range:
    low = Float

    # The high end of the slider range:
    high = Float

    # The smallest allowed increment:
    increment = Float

    # The current text being displayed:
    text = Str

    #-- Class Variables --------------------------------------------------------

    text_styles = {
        'left':   wx.TE_LEFT,
        'center': wx.TE_CENTRE,
        'right':  wx.TE_RIGHT
    }

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        # Establish the range of the slider:
        low, high = factory.low, factory.high
        if high <= low:
            low = high = None
            range      = self.object.trait( self.name ).handler
            if isinstance( range, Range ):
                low, high = range._low, range._high
            if low is None:
                if high is None:
                    high = 1.0
                low = high - 1.0
            elif high is None:
                high = low + 1.0

        # Establish the slider increment:
        increment = factory.increment
        if increment <= 0.0:
            if isinstance( low, int ):
                increment = 1.0
            else:
                increment = pow( 10, int( log10( (high - low) / 1000.0 ) ) )

        # Save the values we calculated:
        self.set( low = low, high = high, increment = increment )

        # Create the control:
        self.control = control = wx.Window( parent, -1,
                                            size  = wx.Size( 70, 20 ),
                                            style = wx.FULL_REPAINT_ON_RESIZE |
                                                    wx.TAB_TRAVERSAL )

        # Set up the painting event handlers:
        wx.EVT_ERASE_BACKGROUND( control, self._erase_background )
        wx.EVT_PAINT( control, self._on_paint )
        wx.EVT_SET_FOCUS(  control, self._set_focus )

        # Set up mouse event handlers:
        wx.EVT_LEFT_DOWN(    control, self._left_down )
        wx.EVT_LEFT_UP(      control, self._left_up )
        wx.EVT_MOTION(       control, self._motion )
        wx.EVT_MOUSEWHEEL(   control, self._mouse_wheel )
        wx.EVT_ENTER_WINDOW( control, self._enter_window )
        wx.EVT_LEAVE_WINDOW( control, self._leave_window )

        # Set up the control resize handler:
        wx.EVT_SIZE( control, self._resize )

        # Set the tooltip:
        if not self.set_tooltip():
            control.SetToolTipString( '[%g..%g]' % ( low, high ) )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        disconnect_no_id( self.control, wx.EVT_ERASE_BACKGROUND, wx.EVT_PAINT,
            wx.EVT_SET_FOCUS, wx.EVT_LEFT_DOWN, wx.EVT_LEFT_UP, wx.EVT_MOTION,
            wx.EVT_MOUSEWHEEL, wx.EVT_ENTER_WINDOW, wx.EVT_LEAVE_WINDOW,
            wx.EVT_SIZE )

        if self._text is not None:
            disconnect( self._text, wx.EVT_TEXT_ENTER )
            disconnect_no_id( self._text, wx.EVT_KILL_FOCUS,
                wx.EVT_ENTER_WINDOW, wx.EVT_LEAVE_WINDOW, wx.EVT_CHAR )

        super( _ThemedSliderEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self.text       = '%g' % self.value
        self._text_size = None
        self._refresh()

        if self._text is not None:
            self._text.SetValue( self.text )

    #---------------------------------------------------------------------------
    #  Updates the object when the control slider value changes:
    #---------------------------------------------------------------------------

    def update_object ( self, value ):
        """ Updates the object when the control slider value changes.
        """
        try:
            self.value = value
        except TraitError:
            self.value = int( value )

        self.update_editor()

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        pass

    #-- Private Methods --------------------------------------------------------

    def _get_text_bounds ( self ):
        """ Get the window bounds of where the current text should be
            displayed.
        """
        tdx, tdy, descent, leading = self._get_text_size()
        wdx, wdy  = self.control.GetClientSizeTuple()
        ty        = ((wdy - (tdy - descent)) / 2) - 2
        alignment = self.factory.alignment
        if alignment == 'left':
            tx = 4
        elif alignment == 'center':
            tx = (wdx - tdx) / 2
        else:
            tx = wdx - tdx - 4

        return ( tx, ty, tdx, tdy )

    def _get_text_size ( self ):
        """ Returns the text size information for the window.
        """
        if self._text_size is None:
            self._text_size = self.control.GetFullTextExtent(
                                               self.text.strip() or 'M' )

        return self._text_size

    def _refresh ( self ):
        """ Refreshes the contents of the control.
        """
        if self.control is not None:
            self.control.Refresh()

    def _set_slider_position ( self, x ):
        """ Calculates a new slider value for a specified (x,y) coordinate.
        """
        wdx, wdy = self.control.GetSizeTuple()
        if 3 <= x < wdx:
            value = self.low + (((x - 3) * (self.high - self.low)) / (wdx - 4))
            increment = self.increment
            if increment > 0:
                value = round( value / increment ) * increment
            self.update_object( value )

    def _delayed_click ( self ):
        """ Handle a delayed click response.
        """
        if self._pending:
            self._pending = False
            self._set_slider_position( self._x )

    def _pop_up_text ( self ):
        """ Pop-up a text control to allow the user to enter a value using
            the keyboard.
        """
        control    = self.control
        self._text = text = wx.TextCtrl( control, -1, self.text,
                            size  = control.GetSize(),
                            style = self.text_styles[ self.factory.alignment ] |
                                    wx.TE_PROCESS_ENTER )
        text.SetSelection( -1, -1 )
        text.SetFocus()
        wx.EVT_TEXT_ENTER( control, text.GetId(), self._text_completed )
        wx.EVT_KILL_FOCUS( text, self._text_completed )
        wx.EVT_ENTER_WINDOW( text, self._enter_text )
        wx.EVT_LEAVE_WINDOW( text, self._leave_text )
        wx.EVT_CHAR( text, self._key_entered )

    def _destroy_text ( self ):
        """ Destroys the current text control.
        """
        self._ignore_focus = self._in_text_window
        disconnect( self._text, wx.EVT_TEXT_ENTER )
        disconnect_no_id( self._text, wx.EVT_KILL_FOCUS, wx.EVT_ENTER_WINDOW,
            wx.EVT_LEAVE_WINDOW, wx.EVT_CHAR )
        self.control.DestroyChildren()
        self._text = None

    #--- wxPython Event Handlers -----------------------------------------------

    def _erase_background ( self, event ):
        """ Do not erase the background here (do it in the 'on_paint' handler).
        """
        pass

    def _on_paint ( self, event ):
        """ Paint the background using the associated ImageSlice object.
        """
        control = self.control
        dc      = BufferDC( control )

        # Draw the slider bar:
        wdx, wdy = control.GetClientSize()
        dx       = max( 0, min( wdx - 2,
                        int( round( ((wdx - 3) * (self.value - self.low)) /
                                                 (self.high - self.low) ) ) ) )

        factory = self.factory
        dc.SetBrush( wx.Brush( factory.slider_color_ ) )
        dc.SetPen( wx.TRANSPARENT_PEN )
        dc.DrawRectangle( 0, 0, dx + 3, wdy )

        # Draw the rest of the background:
        dc.SetBrush( wx.Brush( factory.bg_color_ ) )
        dc.DrawRectangle( dx + 3, 0, wdx - dx - 3, wdy )

        # Draw the slider tip:
        dc.SetBrush( wx.Brush( factory.tip_color_ ) )
        dc.DrawRectangle( dx, 0, 3, wdy )

        # Draw the current text value (if requested):
        if factory.show_value:
            dc.SetBackgroundMode( wx.TRANSPARENT )
            dc.SetTextForeground( factory.text_color_ )
            dc.SetFont( control.GetFont() )
            tx, ty, tdx, tdy = self._get_text_bounds()
            dc.DrawText( self.text, tx, ty )

        # Copy the buffer to the display:
        dc.copy()

    def _resize ( self, event ):
        """ Handles the control being resized.
        """
        if self._text is not None:
            self._text.SetSize( self.control.GetSize() )

    def _set_focus ( self, event ):
        """ Handle the control getting the keyboard focus.
        """
        if ((not self._ignore_focus) and
            (self._x is None)        and
            (self._text is None)):
            self._pop_up_text()

        event.Skip()

    def _left_down ( self, event ):
        """ Handles the left mouse being pressed.
        """
        self._x, self._y = event.GetX(), event.GetY()
        self._pending    = True
        self.control.CaptureMouse()
        do_after( 150, self._delayed_click )

    def _left_up ( self, event ):
        """ Handles the left mouse button being released.
        """
        if self._x is not None:
            self.control.ReleaseMouse()

        if self._pending:
            self._pop_up_text()

        self._x = self._y = self._pending = None

    def _motion ( self, event ):
        """ Handles the mouse moving.
        """
        if self._x is not None:
            x, y = event.GetX(), event.GetY()
            if self._pending:
                if (abs( x - self._x ) + abs( y - self._y )) < 3:
                    return
                self._pending = False
            self._set_slider_position( x )

    def _mouse_wheel ( self, event ):
        """ Handles the mouse wheel rotating.
        """
        if self._in_window:
            increment = event.GetWheelRotation() / event.GetWheelDelta()
            delta     = (self.high - self.low) / 100.0
            if isinstance( self.value, int ) and (abs( delta ) < 1):
                delta = int( abs( delta ) / delta )

            self.update_object( min( max( self.value + increment * delta,
                                          self.low ), self.high ) )

    def _enter_window ( self, event ):
        """ Handles the mouse pointer entering the control.
        """
        self._in_window = True

        if not self._ignore_focus:
            self._ignore_focus = True
            self.control.SetFocus()

        self._ignore_focus = False

    def _leave_window ( self, event ):
        """ Handles the mouse pointer leaving the control.
        """
        self._in_window = False

    def _update_value ( self, event ):
        """ Updates the object value from the current text control value.
        """
        control = event.GetEventObject()
        try:
            self.update_object( float( control.GetValue() ) )

            return True

        except TraitError:
            control.SetBackgroundColour( ErrorColor )
            control.Refresh()

            return False

    def _enter_text ( self, event ):
        """ Handles the mouse entering the pop-up text control.
        """
        self._in_text_window = True

    def _leave_text ( self, event ):
        """ Handles the mouse leaving the pop-up text control.
        """
        self._in_text_window = False

    def _text_completed ( self, event ):
        """ Handles the user pressing the 'Enter' key in the text control.
        """
        if self._update_value( event ):
            self._destroy_text()

    def _key_entered ( self, event ):
        """ Handles individual key strokes while the text control is active.
        """
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_ESCAPE:
            self._destroy_text()
            return

        if key_code == wx.WXK_TAB:
            if self._update_value( event ):
                if event.ShiftDown():
                    self.control.Navigate( 0 )
                else:
                    self.control.Navigate()
            return

        event.Skip()

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for themed slider editors:
class ThemedSliderEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _ThemedSliderEditor

    # The low end of the slider range:
    low = Float

    # The high end of the slider range:
    high = Float

    # The smallest allowed increment:
    increment = Float

    # Should the current value be displayed as text?
    show_value = Bool( True )

    # The alignment of the text within the slider:
    alignment = Alignment( 'center' )

    # The color to use for the slider bar:
    slider_color = Color( 0xC0C0C0 )

    # The background color for the slider:
    bg_color = Color( 'white' )

    # The color of the slider tip:
    tip_color = Color( 0xFF7300 )

    # The color to use for the value text:
    text_color = Color( 'black' )


########NEW FILE########
__FILENAME__ = themed_text_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   06/13/2007
#
#-------------------------------------------------------------------------------

""" Traits UI simple, read-only single line text editor with a themed
    (i.e. image) background.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import Enum, Instance, Bool, Dict, Str, Any, Property, TraitError, \
           cached_property

from traitsui.ui_traits \
    import ATheme

from traitsui.wx.editor \
    import Editor

from traitsui.wx.editor_factory \
    import EditorFactory

from pyface.image_resource \
    import ImageResource

from image_slice import paint_parent, ImageSlice

from constants \
    import OKColor, ErrorColor

from helper \
    import disconnect_no_id, BufferDC

from themed_control \
    import ThemedControl


# Define a reusable, default ImageSlice object:
default_image_slice = ImageSlice()


#-------------------------------------------------------------------------------
#  Define a simple identity mapping:
#-------------------------------------------------------------------------------

class _Identity ( object ):
    """ A simple indentity mapping.
    """
    def __call__ ( self, value ):
        return value

#-------------------------------------------------------------------------------
#  'ThemedTextEditor' class:
#-------------------------------------------------------------------------------

class ThemedTextEditor ( EditorFactory ):
    """ Traits UI simple, single line text editor with a themed (i.e. image)
        background.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # The background theme image to display:
    theme = ATheme

    # Dictionary that maps user input to other values:
    mapping = Dict( Str, Any )

    # Is user input set on every keystroke?
    auto_set = Bool( True )

    # Is user input set when the Enter key is pressed?
    enter_set = Bool( False )

    # Is user input unreadable? (e.g., for a password)
    password = Bool( False )

    # Function to evaluate textual user input:
    evaluate = Any

    # The object trait containing the function used to evaluate user input:
    evaluate_name = Str

    #---------------------------------------------------------------------------
    #  'Editor' factory methods:
    #---------------------------------------------------------------------------

    def simple_editor ( self, ui, object, name, description, parent ):
        return _ThemedTextEditor( parent,
                                  factory     = self,
                                  ui          = ui,
                                  object      = object,
                                  name        = name,
                                  description = description )

    def custom_editor ( self, ui, object, name, description, parent ):
        return _ThemedTextEditor( parent,
                                  factory     = self,
                                  ui          = ui,
                                  object      = object,
                                  name        = name,
                                  description = description )

    def text_editor ( self, ui, object, name, description, parent ):
        return _ThemedTextEditor( parent,
                                  factory     = self,
                                  ui          = ui,
                                  object      = object,
                                  name        = name,
                                  description = description )

    def readonly_editor ( self, ui, object, name, description, parent ):
        return _ReadonlyTextEditor( parent,
                                  factory     = self,
                                  ui          = ui,
                                  object      = object,
                                  name        = name,
                                  description = description )

#-------------------------------------------------------------------------------
#  '_ThemedTextEditor' class:
#-------------------------------------------------------------------------------

class _ThemedTextEditor ( Editor ):
    """ Traits UI simple, single line text editor with a themed (i.e. image
        background).
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Function used to evaluate textual user input:
    evaluate = Any

    # The text alignment to use:
    alignment = Property

    # The image slice to use:
    image_slice = Property

    #-- Class Variables --------------------------------------------------------

    text_styles = {
        'default': wx.TE_LEFT,
        'left':    wx.TE_LEFT,
        'center':  wx.TE_CENTRE,
        'right':   wx.TE_RIGHT
    }

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory  = self.factory
        evaluate = factory.evaluate
        if evaluate is None:
            handler  = self.object.trait( self.name ).handler
            evaluate = getattr( handler, 'evaluate', None )
            if evaluate is None:
                evaluate = _Identity()
        self.evaluate = evaluate
        self.sync_value( factory.evaluate_name, 'evaluate', 'from' )

        padding_x = padding_y = 0
        if factory.theme is not None:
            slice     = self.image_slice
            padding_x = slice.xleft + slice.xright
            padding_y = slice.xtop  + slice.xbottom

        self.control = control = wx.Window( parent, -1,
                            size  = wx.Size( padding_x + 70, padding_y + 20 ),
                            style = wx.FULL_REPAINT_ON_RESIZE | wx.WANTS_CHARS )

        self._text_size = None

        # Set up the painting event handlers:
        wx.EVT_ERASE_BACKGROUND( control, self._erase_background )
        wx.EVT_PAINT( control, self._on_paint )
        wx.EVT_CHAR(  control, self._inactive_key_entered )

        # Handle 'focus' events:
        wx.EVT_SET_FOCUS( control, self._set_focus )
        wx.EVT_LEFT_UP(   control, self._set_focus )

        # Handle 'resize' events:
        wx.EVT_SIZE( control, self._resize )

        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        # Remove all of the wx event listeners:
        disconnect_no_id( self.control, wx.EVT_ERASE_BACKGROUND, wx.EVT_PAINT,
            wx.EVT_CHAR, wx.EVT_SET_FOCUS, wx.EVT_LEFT_UP, wx.EVT_SIZE )

        super( _ThemedTextEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self._text is None:
            self._refresh()
            return

        if self._get_user_value() != self.value:
            self._no_update = True
            self._text.SetValue( self.str_value )
            self._no_update = False

        if self._error is not None:
            self._error     = None
            self.ui.errors -= 1
            self._text.SetBackgroundColour( self.ok_color )
            self._text.Refresh()

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        if not self._no_update:
            try:
                self.value = self._get_user_value()
                self._text.SetBackgroundColour( OKColor )
                self._text.Refresh()

                if self._error is not None:
                    self._error     = None
                    self.ui.errors -= 1
                return True

            except TraitError, excp:
                return False

    #---------------------------------------------------------------------------
    #  Gets the actual value corresponding to what the user typed:
    #---------------------------------------------------------------------------

    def _get_user_value ( self ):
        """ Gets the actual value corresponding to what the user typed.
        """
        value = self._text.GetValue()
        try:
            value = self.evaluate( value )
        except:
            pass

        return self.factory.mapping.get( value, value )

    #---------------------------------------------------------------------------
    #  Handles an error that occurs while setting the object's trait value:
    #---------------------------------------------------------------------------

    def error ( self, excp ):
        """ Handles an error that occurs while setting the object's trait value.
        """
        self._text.SetBackgroundColour( ErrorColor )
        self._text.Refresh()
        wx.Bell()

        if self._error is None:
            self._error     = True
            self.ui.errors += 1

    #-- Private Methods --------------------------------------------------------

    def _pop_up_text ( self ):
        """ Pop-up a text control to allow the user to enter a value using
            the keyboard.
        """
        control = self.control
        factory = self.factory
        style   = (self.text_styles[ self.alignment ] | wx.TE_PROCESS_ENTER)
        if factory.password:
            style |= wx.TE_PASSWORD

        self._text = text = wx.TextCtrl( control, -1, self.str_value,
                                         style = style )
        slice    = self.image_slice
        wdx, wdy = control.GetClientSize()
        tdx, tdy = text.GetSize()
        text.SetPosition( wx.Point(
            slice.xleft, ((wdy + slice.xtop - slice.xbottom - tdy) / 2) + 1 ) )
        text.SetSize( wx.Size( wdx - slice.xleft - slice.xright, tdy ) )
        text.SetSelection( -1, -1 )
        text.SetFocus()

        wx.EVT_KILL_FOCUS( text, self._text_completed )
        wx.EVT_CHAR( text, self._key_entered )
        wx.EVT_TEXT_ENTER( control, text.GetId(), self.update_object )

        if factory.auto_set and (not factory.is_grid_cell):
           wx.EVT_TEXT( control, text.GetId(), self.update_object )

    def _destroy_text ( self ):
        """ Destroys the current text control.
        """
        self.control.DestroyChildren()
        self._text = None

    def _refresh ( self ):
        """ Refreshes the contents of the control.
        """
        if self._text_size is not None:
            self.control.RefreshRect( wx.Rect( *self._get_text_bounds() ),
                                      False )
            self._text_size = None

        self.control.RefreshRect( wx.Rect( *self._get_text_bounds() ), False )

    def _get_text_size ( self ):
        """ Returns the text size information for the window.
        """
        if self._text_size is None:
            self._text_size = self.control.GetFullTextExtent(
                                               self._get_text() or 'M' )

        return self._text_size

    def _get_text_bounds ( self ):
        """ Get the window bounds of where the current text should be
            displayed.
        """
        tdx, tdy, descent, leading = self._get_text_size()
        wdx, wdy  = self.control.GetClientSizeTuple()
        slice     = self.image_slice
        ady       = wdy - slice.xtop  - slice.xbottom
        ty        = slice.xtop  + ((ady - (tdy - descent)) / 2) - 1
        alignment = self.alignment
        if alignment == 'center':
            adx = wdx - slice.xleft - slice.xright
            tx  = slice.xleft + (adx - tdx) / 2
        elif alignment == 'right':
            tx = wdx - tdx - slice.xright - 4
        else:
            tx = slice.xleft + 4

        return ( tx, ty, tdx, tdy )

    def _get_text ( self ):
        """ Returns the current text to display.
        """
        if self.factory.password:
            return '*' * len( self.str_value )

        return self.str_value

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_alignment ( self ):
        theme = self.factory.theme
        if theme is not None:
            return theme.alignment

        return 'left'

    @cached_property
    def _get_image_slice ( self ):
        theme = self.factory.theme
        if theme is not None:
            return theme.image_slice or default_image_slice

        return default_image_slice

    #-- wxPython Event Handlers ------------------------------------------------

    def _erase_background ( self, event ):
        """ Do not erase the background here (do it in the 'on_paint' handler).
        """
        pass

    def _on_paint ( self, event ):
        """ Paint the background using the associated ImageSlice object.
        """
        control  = self.control
        dc       = BufferDC( control )
        slice    = paint_parent( dc, control )
        slice2   = self.image_slice
        if slice2 is not default_image_slice:
            wdx, wdy = control.GetClientSizeTuple()
            slice2.fill( dc, 0, 0, wdx, wdy, True )
            slice = slice2
        elif slice is None:
            slice = slice2
        dc.SetBackgroundMode( wx.TRANSPARENT )
        dc.SetTextForeground( slice.content_color )
        dc.SetFont( control.GetFont() )
        tx, ty, tdx, tdy = self._get_text_bounds()
        dc.DrawText( self._get_text(), tx, ty )
        dc.copy()

    def _resize ( self, event ):
        """ Handles the control being resized.
        """
        if self._text is not None:
            self._text.SetSize( self.control.GetSize() )

    def _set_focus ( self, event ):
        """ Handle the control getting the keyboard focus.
        """
        if self._text is None:
            self._pop_up_text()

        event.Skip()

    def _text_completed ( self, event ):
        """ Handles the user transferring focus out of the text control.
        """
        if self.update_object( event ):
            self._destroy_text()

    def _key_entered ( self, event ):
        """ Handles individual key strokes while the text control is active.
        """
        key_code = event.GetKeyCode()
        if key_code == wx.WXK_ESCAPE:
            self._destroy_text()
            return

        if key_code == wx.WXK_TAB:
            if self.update_object( event ):
                if event.ShiftDown():
                    self.control.Navigate( 0 )
                else:
                    self.control.Navigate()

            return

        event.Skip()

    def _inactive_key_entered ( self, event ):
        """ Handles individual key strokes while the text control is inactive.
        """
        if event.GetKeyCode() == wx.WXK_RETURN:
            if self._text is None:
                self._pop_up_text()

            return

        event.Skip()

#-------------------------------------------------------------------------------
#  '_ReadonlyTextEditor' class:
#-------------------------------------------------------------------------------

class _ReadonlyTextEditor ( Editor ):
    """ Traits UI simple, read-only single line text view with a themed (i.e.
        image background).
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._control = ThemedControl( theme = self.factory.theme )
        self.control  = self._control.create_control( parent )
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        self._control.text = self.value

        # Make sure the control is sized correctly:
        self.control.SetMinSize( self._control.best_size )


########NEW FILE########
__FILENAME__ = themed_vertical_notebook
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/05/2007
#
#-------------------------------------------------------------------------------

""" Defines a ThemedVerticalNotebook class for displaying a series of pages
    organized vertically, as opposed to horizontally like a standard notebook.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasTraits, HasPrivateTraits, Instance, List, Str, Bool, Property, \
           Event, Any, on_trait_change, cached_property

from traitsui.api \
    import UI, Theme

from traitsui.ui_traits \
    import ATheme

from traitsui.editor \
    import Editor

from constants \
    import WindowColor, screen_dy

from image_slice \
    import paint_parent

from image_panel \
    import ImagePanel

from themed_control \
    import ThemedControl

from helper \
    import TraitsUIPanel, TraitsUIScrolledPanel

#-------------------------------------------------------------------------------
#  'ThemedPage' class:
#-------------------------------------------------------------------------------

class ThemedPage ( HasPrivateTraits ):
    """ A class representing a themed page within a notebook.
    """

    #-- Public Traits ----------------------------------------------------------

    # The name of the page (displayed on its 'tab') [Set by client]:
    name = Str

    # The optional Traits UI associated with this page [Set by client]:
    ui = Instance( UI )

    # The wxPython window the page represents [Set by client]:
    control = Instance( wx.Window )

    # Optional client data associated with the page [Set/Get by client]:
    data = Any

    # The optional object defining the page name [Set by client]:
    object = Instance( HasTraits )

    # The name of the object trait that signals a page name change [Set by
    # client]:
    trait_name = Str

    # The parent window for the client page [Get by client]:
    parent = Property

    #-- Traits for use by the Notebook/Sizer -----------------------------------

    # The current open status of the notebook page:
    is_open = Bool( False )

    # The minimum size for the page:
    min_size = Property

    # The open size property for the page:
    open_size = Property

    # The closed size property for the page:
    closed_size = Property

    #-- Private Traits ---------------------------------------------------------

    # The notebook this page is associated with:
    notebook = Instance( 'ThemedVerticalNotebook' )

    # The theme used to display a closed page:
    closed_theme = ATheme

    # The theme use to display an open page:
    open_theme = ATheme

    # The control representing the closed page:
    closed_page = Property( depends_on = 'closed_theme' )

    # The control representing the open page:
    open_page = Property( depends_on = 'open_theme' )

    #-- Public Methods ---------------------------------------------------------

    def close ( self ):
        """ Closes the notebook page.
        """
        if self.object is not None:
            self.object.on_trait_change( self._name_updated, self.trait_name,
                                         remove = True )
            self.object = None

        if self.ui is not None:
            self.ui.dispose()
            self.ui = None

        if self.closed_page is not None:
            self.closed_page.control.Destroy()
            self.open_page.control.Destroy()
            self.control = None

    def set_size ( self, x, y, dx, dy ):
        """ Sets the size of the current active page.
        """
        if self.is_open:
            self.open_page.control.SetDimensions( x, y, dx, dy )
        else:
            self.closed_page.control.SetDimensions( x, y, dx, dy )

    def register_name_listener ( self, object, trait_name ):
        """ Registers a listener on the specified object trait for a page name
            change.
        """
        # Save the information, so we can unregister it later:
        self.object, self.trait_name = object, trait_name

        # Register the listener:
        object.on_trait_change( self._name_updated, trait_name )

        # Make sure the name gets initialized:
        self._name_updated()

    #-- Property Implementations -----------------------------------------------

    def _get_min_size ( self ):
        """ Returns the minimum size for the page.
        """
        dxo, dyo = self.open_page.best_size
        dxc, dyc = self.closed_page.best_size
        if self.is_open:
            return wx.Size( max( dxo, dxc ), dyo )

        return wx.Size( max( dxo, dxc ), dyc )

    def _get_open_size ( self ):
        """ Returns the open size for the page.
        """
        return self.open_page.best_size

    def _get_closed_size ( self ):
        """ Returns the closed size for the page.
        """
        return self.closed_page.best_size

    @cached_property
    def _get_closed_page ( self ):
        """ Returns the 'closed' form of the notebook page.
        """
        result = ThemedControl( theme             = self.closed_theme,
                                text              = self.name,
                                controller        = self,
                                default_alignment = 'center',
                                state             = 'closed' )
        result.create_control( self.notebook.control )

        return result

    @cached_property
    def _get_open_page ( self ):
        """ Returns the 'open' form of the notebook page.
        """
        result = ImagePanel( theme             = self.open_theme,
                             text              = self.name,
                             controller        = self,
                             default_alignment = 'center',
                             state             = 'open' )
        result.create_control( self.notebook.control )

        return result

    def _get_parent ( self ):
        """ Returns the parent window for the client's window.
        """
        return self.open_page.control

    #-- Trait Event Handlers ---------------------------------------------------

    def _ui_changed ( self, ui ):
        """ Handles the ui trait being changed.
        """
        if ui is not None:
            self.control = ui.control

    def _control_changed ( self, control ):
        """ Handles the control for the page being changed.
        """
        if control is not None:
            self.open_page.control.GetSizer().Add( control, 1, wx.EXPAND )
            self._is_open_changed( self.is_open )

    def _is_open_changed ( self, is_open ):
        """ Handles the 'is_open' state of the page being changed.
        """
        self.closed_page.control.Show( not is_open )
        self.open_page.control.Show( is_open )

        if is_open:
            self.closed_page.control.SetSize( wx.Size( 0, 0 ) )
        else:
            self.open_page.control.SetSize( wx.Size( 0, 0 ) )

    def _name_changed ( self, name ):
        """ Handles the name trait being changed.
        """
        self.closed_page.text = self.open_page.text = name

    def _name_updated ( self ):
        """ Handles a signal that the associated object's page name has changed.
        """
        nb           = self.notebook
        handler_name = None

        method = None
        editor = nb.editor
        if editor is not None:
            method = getattr( editor.ui.handler,
                 '%s_%s_page_name' % ( editor.object_name, editor.name ), None )
        if method is not None:
            handler_name = method( editor.ui.info, self.object )

        if handler_name is not None:
            self.name = handler_name
        else:
            self.name = getattr( self.object, self.trait_name ) or '???'

    #-- ThemedControl Mouse Event Handlers -------------------------------------

    def open_left_down ( self, x, y, event ):
        """ Handles the user clicking on an open notebook page to close it.
        """
        if not self.notebook.double_click:
            self.notebook.close( self )

    def open_left_dclick ( self, x, y, event ):
        """ Handles the user double clicking on an open notebook page to close
            it.
        """
        if self.notebook.double_click:
            self.notebook.close( self )

    def closed_left_down ( self, x, y, event ):
        """ Handles the user clicking on a closed notebook page to open it.
        """
        if not self.notebook.double_click:
            self.notebook.open( self )

    def closed_left_dclick ( self, x, y, event ):
        """ Handles the user double clicking on a closed notebook page to open
            it.
        """
        if self.notebook.double_click:
            self.notebook.open( self )

#-------------------------------------------------------------------------------
#  'ThemedVerticalNotebook' class:
#-------------------------------------------------------------------------------

class ThemedVerticalNotebook ( HasPrivateTraits ):
    """ Defines a ThemedVerticalNotebook class for displaying a series of pages
        organized vertically, as opposed to horizontally like a standard
        notebook.
    """

    #-- Public Traits ----------------------------------------------------------

    # The theme to use for 'closed' notebook pages:
    closed_theme = ATheme( Theme( '@std:notebook_close', content = 0 ) )

    # The theme to use for 'open' notebook pages:
    open_theme = ATheme( Theme( '@std:notebook_open', content = 0 ) )

    # Allow multiple open pages at once?
    multiple_open = Bool( False )

    # Should the notebook be scrollable?
    scrollable = Bool( False )

    # Use double clicks (True) or single clicks (False) to open/close pages:
    double_click = Bool( False )

    # The pages contained in the notebook:
    pages = List( ThemedPage )

    # The traits UI editor this notebook is associated with (if any):
    editor = Instance( Editor )

    #-- Private Traits ---------------------------------------------------------

    # The wxPython control used to represent the notebook:
    control = Instance( wx.Window )

    #-- Public Methods ---------------------------------------------------------

    def create_control ( self, parent ):
        """ Creates the underlying wxPython window used for the notebook.
        """
        # Create the correct type of window based on whether or not it should
        # be scrollable:
        if self.scrollable:
            self.control = control = TraitsUIScrolledPanel( parent )
            control.SetScrollRate( 6, 6 )
            control.SetSize( wx.Size( 0, 0 ) )
        else:
            self.control = control = TraitsUIPanel( parent, -1 )

        control._image_slice = getattr( parent, '_image_slice', None )
        control.SetSizer( ThemedVerticalNotebookSizer( self ) )

        # Set up the painting event handlers:
        wx.EVT_ERASE_BACKGROUND( control, self._erase_background )
        wx.EVT_PAINT( control, self._paint )

        return control

    def create_page ( self ):
        """ Creates a new **ThemedPage** object representing a notebook page and
            returns it as the result.
        """
        return ThemedPage( notebook     = self ).set(
                           closed_theme = self.closed_theme,
                           open_theme   = self.open_theme )

    def open ( self, page ):
        """ Handles opening a specified **ThemedPage** notebook page.
        """
        if (page is not None) and (not page.is_open):
            if not self.multiple_open:
                for a_page in self.pages:
                    a_page.is_open = False

            page.is_open = True

            self._refresh()

    def close ( self, page ):
        """ Handles closing a specified **ThemedPage** notebook page.
        """
        if (page is not None) and page.is_open:
            page.is_open = False
            self._refresh()

    #-- Trait Event Handlers ---------------------------------------------------

    def _pages_changed ( self, old, new ):
        """ Handles the notebook's pages being changed.
        """
        for page in old:
            page.close()

        self._refresh()

    def _pages_items_changed ( self, event ):
        """ Handles some of the notebook's pages being changed.
        """
        for page in event.removed:
            page.close()

        self._refresh()

    def _multiple_open_changed ( self, multiple_open ):
        """ Handles the 'multiple_open' flag being changed.
        """
        if not multiple_open:
            first = True
            for page in self.pages:
                if first and page.is_open:
                    first = False
                else:
                    page.is_open = False

        self._refresh()

    #-- wx.Python Event Handlers -----------------------------------------------

    def _erase_background ( self, event ):
        """ Do not erase the background here (do it in the 'on_paint' handler).
        """
        pass

    def _paint ( self, event ):
        """ Paint the background using the associated ImageSlice object.
        """
        paint_parent( wx.PaintDC( self.control ), self.control )

    #-- Private Methods --------------------------------------------------------

    def _refresh ( self ):
        """ Refresh the layout and contents of the notebook.
        """
        control = self.control
        if control is not None:
            # Set the virtual size of the canvas (so scroll bars work right):
            sizer = control.GetSizer()
            if control.GetSize()[0] == 0:
                control.SetSize( sizer.CalcInit() )
            control.SetVirtualSize( sizer.CalcMin() )
            control.Layout()
            control.Refresh()

#-------------------------------------------------------------------------------
#  'ThemedVerticalNotebookSizer' class:
#-------------------------------------------------------------------------------

class ThemedVerticalNotebookSizer ( wx.PySizer ):
    """ Defines a sizer that correctly sizes a themed vertical notebook's
        children to implement the vertical notebook UI model.
    """

    def __init__ ( self, notebook ):
        """ Initializes the object.
        """
        super( ThemedVerticalNotebookSizer, self ).__init__()

        # Save the notebook reference:
        self._notebook = notebook

    def CalcMin ( self ):
        """ Calculates the minimum size of the control by aggregating the
            sizes of the open and closed pages.
        """
        tdx, tdy = 0, 0
        for page in self._notebook.pages:
            dx, dy = page.min_size
            tdx    = max( tdx, dx )
            tdy   += dy

        return wx.Size( tdx, tdy )

    def CalcInit ( self ):
        """ Calculates a reasonable initial size of the control by aggregating
            the sizes of the open and closed pages.
        """
        tdx, tdy = 0, 0
        open_dy  = closed_dy = 0
        for page in self._notebook.pages:
            dxo, dyo = page.open_size
            dxc, dyc = page.closed_size
            tdx      = max( tdx, dxo, dxc )
            if dyo > open_dy:
                tdy += (dyo - open_dy + closed_dy)
                open_dy, closed_dy = dyo, dyc
            else:
                tdy += dyc

        return wx.Size( tdx, min( tdy, screen_dy / 2 ) )

    def RecalcSizes ( self ):
        """ Layout the contents of the sizer based on the sizer's current size
            and position.
        """
        x, y     = self.GetPositionTuple()
        tdx, tdy = self.GetSizeTuple()
        cdy      = ody = 0
        for page in self._notebook.pages:
            dx, dy = page.min_size
            if page.is_open:
                ody += dy
            else:
                cdy += dy

        ady = max( 0, tdy - cdy )

        for page in self._notebook.pages:
            dx, dy = page.min_size
            if page.is_open:
                ndy  = (ady * dy) / ody
                ady -= ndy
                ody -= dy
                dy   = ndy
            page.set_size( x, y, tdx, dy )
            y += dy


########NEW FILE########
__FILENAME__ = themed_vertical_notebook_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/07/2007
#
#-------------------------------------------------------------------------------

""" Traits UI vertical notebook editor for editing lists of objects with traits.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traits.api \
    import Instance, Str, Any, List, Bool, Undefined, on_trait_change

from traits.trait_base \
    import user_name_for

from traitsui.wx.editor \
    import Editor

from traitsui.basic_editor_factory \
    import BasicEditorFactory

from traitsui.ui_traits \
    import AView, ATheme

from themed_vertical_notebook \
    import ThemedVerticalNotebook

#-------------------------------------------------------------------------------
#  '_ThemedVerticalNotebookEditor' class:
#-------------------------------------------------------------------------------

class _ThemedVerticalNotebookEditor ( Editor ):
    """ Traits UI vertical notebook editor for editing lists of objects with
        traits.
    """

    #-- Trait Definitions ------------------------------------------------------

    # Is the notebook editor scrollable? This values overrides the default:
    scrollable = True

    #-- Private Traits ---------------------------------------------------------

    # The currently selected notebook page object (or objects):
    selected_item = Any
    selected_list = List

    # The ThemedVerticalNotebook we use to manager the notebook:
    notebook = Instance( ThemedVerticalNotebook )

    # Dictionary of page counts for all unique names:
    pages = Any( {} )

    #-- Editor Methods ---------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        self.notebook = ThemedVerticalNotebook( **factory.get(
            'closed_theme', 'open_theme', 'multiple_open', 'scrollable',
            'double_click' ) ).set( editor = self )
        self.control = self.notebook.create_control( parent )

        # Set up the additional 'list items changed' event handler needed for
        # a list based trait:
        self.context_object.on_trait_change( self.update_editor_item,
                               self.extended_name + '_items?', dispatch = 'ui' )

        # Synchronize the editor selection with the user selection:
        if factory.multiple_open:
            self.sync_value( factory.selected, 'selected_list', 'both',
                             is_list = True )
        else:
            self.sync_value( factory.selected, 'selected_item', 'both' )

        self.set_tooltip()

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        # Replace all of the current notebook pages:
        self.notebook.pages = [ self._create_page( object )
                                for object in self.value ]

    def update_editor_item ( self, event ):
        """ Handles an update to some subset of the trait's list.
        """
        # Replace the updated notebook pages:
        self.notebook.pages[ event.index: event.index + len( event.removed ) ] \
            = [ self._create_page( object ) for object in event.added ]

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        self.context_object.on_trait_change( self.update_editor_item,
                                self.name + '_items?', remove = True )
        del self.notebook.pages[:]

        super( _ThemedVerticalNotebookEditor, self ).dispose()

    #-- Trait Event Handlers ---------------------------------------------------

    def _selected_item_changed ( self, old, new ):
        """ Handles the selected item being changed.
        """
        if new is not None:
            self.notebook.open( self._find_page( new ) )
        elif old is not None:
            self.notebook.close( self._find_page( old ) )

    def _selected_list_changed ( self, old, new ):
        """ Handles the selected list being changed.
        """
        notebook = self.notebook
        for object in old:
            notebook.close( self._find_page( object ) )

        for object in new:
            notebook.open( self._find_page( object ) )

    def _selected_list_items_changed ( self, event ):
        self._selected_list_changed( event.removed, event.added )

    @on_trait_change( 'notebook:pages:is_open' )
    def _page_state_modified ( self, page, name, old, is_open ):
        if self.factory.multiple_open:
            object = page.data
            if is_open:
                if object not in self.selected_list:
                    self.selected_list.append( object )
            elif object in self.selected_list:
                self.selected_list.remove( object )
        elif is_open:
            self.selected_item = page.data
        else:
            self.selected_item = None

    #-- Private Methods --------------------------------------------------------

    def _create_page ( self, object ):
        """ Creates and returns a notebook page for a specified object with
            traits.
        """
        # Create a new notebook page:
        page = self.notebook.create_page().set( data = object )

        # Create the Traits UI for the object to put in the notebook page:
        ui = object.edit_traits( parent = page.parent,
                                 view   = self.factory.view,
                                 kind   = 'subpanel' ).set(
                                 parent = self.ui )

        # Get the name of the page being added to the notebook:
        name      = ''
        page_name = self.factory.page_name
        if page_name[0:1] == '.':
            if getattr( object, page_name[1:], Undefined ) is not Undefined:
                page.register_name_listener( object, page_name[1:] )
        else:
            name = page_name

        if name == '':
            name = user_name_for( object.__class__.__name__ )

        # Make sure the name is not a duplicate, then save it in the page:
        if page.name == '':
            self.pages[ name ] = count = self.pages.get( name, 0 ) + 1
            if count > 1:
                name += (' %d' % count)
            page.name = name

        # Save the Traits UI in the page so it can dispose of it later:
        page.ui = ui

        # Return the new notebook page
        return page

    def _find_page ( self, object ):
        """ Find the notebook page corresponding to a specified object. Returns
            the page if found, and **None** otherwise.
        """
        for page in self.notebook.pages:
            if object is page.data:
                return page

        return None

#-------------------------------------------------------------------------------
#  Create the editor factory object:
#-------------------------------------------------------------------------------

# wxPython editor factory for themed slider editors:
class ThemedVerticalNotebookEditor ( BasicEditorFactory ):

    # The editor class to be created:
    klass = _ThemedVerticalNotebookEditor

    # The theme to use for closed notebook pages:
    closed_theme = ATheme

    # The theme to use for open notebook pages:
    open_theme = ATheme

    # Allow multiple open pages at once?
    multiple_open = Bool( False )

    # Should the notebook be scrollable?
    scrollable = Bool( False )

    # Use double clicks (True) or single clicks (False) to open/close pages:
    double_click = Bool( True )

    # Extended name to use for each notebook page. It can be either the actual
    # name or the name of an attribute on the object in the form:
    # '.name[.name...]'
    page_name = Str

    # Name of the view to use for each page:
    view = AView

    # Name of the [object.]trait[.trait...] to synchronize notebook page
    # selection with:
    selected = Str


########NEW FILE########
__FILENAME__ = themed_window
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/09/2007
#
#-------------------------------------------------------------------------------

""" Defines a ThemedWindow base class for creating themed windows.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasPrivateTraits, HasTraits, Instance, Str, Enum, Any, Bool

from traitsui.ui_traits \
    import ATheme

from helper \
    import init_wx_handlers, BufferDC

#-------------------------------------------------------------------------------
#  'ThemedWindow' class:
#-------------------------------------------------------------------------------

class ThemedWindow ( HasPrivateTraits ):

    #-- Public Traits ----------------------------------------------------------

    # The theme associated with this window:
    theme = ATheme

    # The default alignment to use:
    default_alignment = Enum( 'left', 'center', 'right' )

    # The current mouse event state:
    state = Str( 'normal' )

    # Optional controller used for overriding event handling:
    controller = Instance( HasTraits )

    # Should debugging information be overlaid on the theme?
    debug = Bool( False )

    #-- Public Methods ---------------------------------------------------------

    def init_control ( self ):
        """ Initializes the underlying wx.Window object.
        """
        init_wx_handlers( self.control, self )

    def in_control ( self, x, y ):
        """ Returns whether a specified (x,y) coordinate is inside the control
            or not.
        """
        wdx, wdy = self.control.GetClientSize()
        return ((0 <= x < wdx) and (0 <= y < wdy))

    def refresh ( self ):
        """ Refreshes the contents of the control.
        """
        if self.control is not None:
            self.control.Refresh()

    def capture_mouse ( self ):
        """ Grab control of the mouse and indicate that we are controlling it.
        """
        if not self._has_capture:
            self._has_capture = True
            self.control.CaptureMouse()

    def release_mouse ( self ):
        """ Grab control of the mouse and indicate that we are controlling it.
        """
        if self._has_capture:
            self._has_capture = False
            self.control.ReleaseMouse()

    #-- Trait Event Handlers ---------------------------------------------------

    def _theme_changed ( self ):
        """ Handles the 'theme' trait being changed.
        """
        self.refresh()

    #-- wxPython Event Handlers ------------------------------------------------

    def _erase_background ( self, event ):
        """ Do not erase the background here (do it in the 'on_paint' handler).
        """
        pass

    def _paint ( self, event ):
        """ Paint the background using the associated ImageSlice object.
        """
        dc = BufferDC( self.control )
        self._paint_bg( dc )
        self._paint_fg( dc )
        dc.copy()

    def _paint_bg ( self, dc ):
        """ Paints the background into the supplied device context using the
            associated ImageSlice object and returns the image slice used (if
            any).
        """
        from image_slice import paint_parent

        # Repaint the parent's theme (if necessary):
        paint_parent( dc, self.control )

        # Draw the background theme (if any):
        if self.theme is not None:
            slice = self.theme.image_slice
            if slice is not None:
                wdx, wdy = self.control.GetClientSize()
                slice.fill( dc, 0, 0, wdx, wdy, True )

                if self.debug:
                    dc.SetPen( wx.Pen( wx.RED ) )
                    dc.SetBrush( wx.TRANSPARENT_BRUSH )
                    theme  = self.theme
                    border = theme.border
                    dc.DrawRectangle( border.left, border.top,
                                      wdx - border.right  - border.left,
                                      wdy - border.bottom - border.top )
                    dc.DrawRectangle( border.left + 3, border.top + 3,
                                      wdx - border.right  - border.left - 6,
                                      wdy - border.bottom - border.top  - 6 )
                    content = theme.content
                    x = slice.xleft + content.left
                    y = slice.xtop  + content.top
                    dc.DrawRectangle( x - 1, y - 1,
                           wdx - slice.xright  - content.right  - x + 2,
                           wdy - slice.xbottom - content.bottom - y + 2 )

                    label = theme.label
                    if slice.xtop >= slice.xbottom:
                        y, dy = 0, slice.xtop
                    else:
                        y, dy = wdy - slice.xbottom, slice.xbottom

                    if dy >= 13:
                        x  = slice.xleft + label.left
                        y += label.top
                        dc.DrawRectangle( x - 1, y - 1,
                            wdx - slice.xright - label.right - x + 2,
                            dy - label.bottom - label.top + 2 )

    def _paint_fg ( self, dc ):
        """ Paints the foreground of the window into the supplied device
            context.
        """
        pass

    def _size ( self, event ):
        """ Handles the control being resized.
        """
        control = self.control
        if control is not None:
            control.Layout()
            control.Refresh()

    def _left_down ( self, event ):
        """ Handles a left mouse button down event.
        """
        self.control.SetFocus()
        self.capture_mouse()
        self._mouse_event( 'left_down', event )

    def _left_up ( self, event ):
        """ Handles a left mouse button up event.
        """
        if self._has_capture:
            self._has_capture = False
            self.control.ReleaseMouse()
            self._mouse_event( 'left_up', event )

    def _left_dclick ( self, event ):
        """ Handles a left mouse button double click event.
        """
        self.capture_mouse()
        self._mouse_event( 'left_dclick', event )

    def _middle_down ( self, event ):
        """ Handles a middle mouse button down event.
        """
        self.capture_mouse()
        self._mouse_event( 'middle_down', event )

    def _middle_up ( self, event ):
        """ Handles a middle mouse button up event.
        """
        self.release_mouse()
        self._mouse_event( 'middle_up', event )

    def _middle_dclick ( self, event ):
        """ Handles a middle mouse button double click event.
        """
        self.capture_mouse()
        self._mouse_event( 'middle_dclick', event )

    def _right_down ( self, event ):
        """ Handles a right mouse button down event.
        """
        self.capture_mouse()
        self._mouse_event( 'right_down', event )

    def _right_up ( self, event ):
        """ Handles a right mouse button up event.
        """
        self.release_mouse()
        self._mouse_event( 'right_up', event )

    def _right_dclick ( self, event ):
        """ Handles a right mouse button double click event.
        """
        self.capture_mouse()
        self._mouse_event( 'right_dclick', event )

    def _motion ( self, event ):
        """ Handles a mouse move event.
        """
        self._mouse_event( 'motion', event )

    def _enter ( self, event ):
        """ Handles the mouse entering the window event.
        """
        self._mouse_event( 'enter', event )

    def _leave ( self, event ):
        """ Handles the mouse leaving the window event.
        """
        self._mouse_event( 'leave', event )

    def _wheel ( self, event ):
        """ Handles a mouse wheel event.
        """
        self._mouse_event( 'wheel', event )

    #-- Private Methods --------------------------------------------------------

    def _mouse_event ( self, name, event ):
        """ Routes a mouse event to the proper handler (if any).
        """
        method_name = '%s_%s' % ( self.state, name )
        method      = None

        if self.controller is not None:
            method = getattr( self.controller, method_name, None )

        if method is None:
            method = getattr( self, method_name, None )

        if method is not None:
            method( event.GetX(), event.GetY(), event )


########NEW FILE########
__FILENAME__ = time_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Judah De Paula
#  Date:   10/7/2008
#
#------------------------------------------------------------------------------
"""
A Traits UI editor that wraps a WX timer control.

Future Work
-----------
The only editor provided is an editable and constrained "XX:XX:XX XM" field.
At the minimum, a spinner should be provided so the time can be changed
without the need for a keyboard.  In addition we need to extend to provide
all four of the basic editor types, Simple, Custom, Text, and Readonly.
"""
import datetime

import wx.lib.masked as masked

from traitsui.wx.editor import Editor
from traitsui.wx.text_editor \
    import ReadonlyEditor as TextReadonlyEditor


class SimpleEditor (Editor):
    """
    Traits UI time editor.
    """

    def init ( self, parent ):
        """
        Finishes initializing the editor by creating the underlying toolkit
        widget.
        """
        tctl = masked.TimeCtrl( parent, -1, name="12 hour control" )
        self.control = tctl
        self.control.Bind(masked.EVT_TIMEUPDATE, self.time_updated)
        return


    def time_updated(self, event):
        """
        Event for when the wx time control is updated.
        """
        time = self.control.GetValue(as_wxDateTime=True)
        hour = time.GetHour()
        minute = time.GetMinute()
        second = time.GetSecond()
        self.value = datetime.time(hour, minute, second)
        return


    def update_editor ( self ):
        """
        Updates the editor when the object trait changes externally to the
        editor.
        """
        if self.value:
            time = self.control.GetValue(as_wxDateTime=True)
            time.SetHour(self.value.hour)
            time.SetMinute(self.value.minute)
            time.SetSecond(self.value.second)
            self.control.SetValue(time)
        return
#-- end SimpleEditor definition ------------------------------------------------


#------------------------------------------------------------------------------
#--  Text Editor
#------------------------------------------------------------------------------
# TODO: Write me.  Possibly use TextEditor as a model to show a string
# representation of the time, and have enter-set do a time evaluation.
class TextEditor (SimpleEditor):
    pass
#-- end TextEditor definition -------------------------------------------------


#------------------------------------------------------------------------------
#--  Custom Editor
#------------------------------------------------------------------------------
# TODO: Write me.
class CustomEditor (SimpleEditor):
    pass
#-- end TextEditor definition -------------------------------------------------


#------------------------------------------------------------------------------
#--  Readonly Editor
#------------------------------------------------------------------------------

class ReadonlyEditor (TextReadonlyEditor):
    """ Use a TextEditor for the view. """

    def _get_str_value(self):
        """ Replace the default string value with our own time version. """
        if self.value is None:
            return self.factory.message
        else:
            return self.value.strftime(self.factory.strftime)

#-- end ReadonlyEditor definition ---------------------------------------------


#-- eof -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = title_editor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   07/06/2006
#
#-------------------------------------------------------------------------------

""" Define an editor that displays a string value as a title.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from editor \
    import Editor

from pyface.heading_text \
    import HeadingText

# FIXME: TitleEditor (the editor factory for title editors) is a proxy class
# defined here just for backward compatibility. The class has been moved to
# traitsui.editors.title_editor.
from traitsui.editors.title_editor \
    import TitleEditor


#-------------------------------------------------------------------------------
#  '_TitleEditor' class:
#-------------------------------------------------------------------------------

class _TitleEditor ( Editor ):

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        self._control = HeadingText( parent )
        self.control  = self._control.control
        self.set_tooltip()

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes external to the
            editor.
        """
        self._control.text = self.str_value


SimpleEditor = _TitleEditor
CustomEditor = _TitleEditor
ReadonlyEditor = _TitleEditor
TextEditor = _TitleEditor

########NEW FILE########
__FILENAME__ = toolkit
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   10/13/2004
#
#------------------------------------------------------------------------------

""" Defines the concrete implementations of the traits Toolkit interface for
    the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# Make sure that importimg from this backend is OK:
from traitsui.toolkit import assert_toolkit_import
assert_toolkit_import('wx')

import wx

# Make sure a wx.App object is created early:
_app = wx.GetApp()
if _app is None:
    _app = wx.App(redirect=False)

from traits.api \
    import HasPrivateTraits, Instance, Property, Category, cached_property

from traits.trait_notifiers \
    import set_ui_handler

from traitsui.ui \
    import UI

from traitsui.theme \
    import Theme

from traitsui.dock_window_theme \
    import DockWindowTheme

from traitsui.toolkit \
    import Toolkit

from pyface.wx.drag_and_drop \
    import PythonDropTarget

from constants \
    import WindowColor, screen_dx, screen_dy

from helper \
    import position_window

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

EventSuffix = {
    wx.wxEVT_LEFT_DOWN:     'left_down',
    wx.wxEVT_LEFT_DCLICK:   'left_dclick',
    wx.wxEVT_LEFT_UP:       'left_up',
    wx.wxEVT_MIDDLE_DOWN:   'middle_down',
    wx.wxEVT_MIDDLE_DCLICK: 'middle_dclick',
    wx.wxEVT_MIDDLE_UP:     'middle_up',
    wx.wxEVT_RIGHT_DOWN:    'right_down',
    wx.wxEVT_RIGHT_DCLICK:  'right_dclick',
    wx.wxEVT_RIGHT_UP:      'right_up',
    wx.wxEVT_MOTION:        'mouse_move',
    wx.wxEVT_ENTER_WINDOW:  'enter',
    wx.wxEVT_LEAVE_WINDOW:  'leave',
    wx.wxEVT_MOUSEWHEEL:    'mouse_wheel',
    wx.wxEVT_PAINT:         'paint',
}

# Types of popup views:
Popups = set( ( 'popup', 'popover', 'info' ) )

#-------------------------------------------------------------------------------
#  Handles UI notification handler requests that occur on a thread other than
#  the UI thread:
#-------------------------------------------------------------------------------

def ui_handler ( handler, *args ):
    """ Handles UI notification handler requests that occur on a thread other
        than the UI thread.
    """
    wx.CallAfter( handler, *args )

# Tell the traits notification handlers to use this UI handler
set_ui_handler( ui_handler )

#-------------------------------------------------------------------------------
#  'GUIToolkit' class:
#-------------------------------------------------------------------------------

class GUIToolkit ( Toolkit ):
    """ Implementation class for wxPython toolkit.
    """
    #---------------------------------------------------------------------------
    #  Create wxPython specific user interfaces using information from the
    #  specified UI object:
    #---------------------------------------------------------------------------

    def ui_panel ( self, ui, parent ):
        """ Creates a wxPython panel-based user interface using information
            from the specified UI object.
        """
        import ui_panel
        ui_panel.ui_panel( ui, parent )

    def ui_subpanel ( self, ui, parent ):
        """ Creates a wxPython subpanel-based user interface using information
            from the specified UI object.
        """
        import ui_panel
        ui_panel.ui_subpanel( ui, parent )

    def ui_livemodal ( self, ui, parent ):
        """ Creates a wxPython modal "live update" dialog user interface using
            information from the specified UI object.
        """
        import ui_live
        ui_live.ui_livemodal( ui, parent )

    def ui_live ( self, ui, parent ):
        """ Creates a wxPython non-modal "live update" window user interface
            using information from the specified UI object.
        """
        import ui_live
        ui_live.ui_live( ui, parent )

    def ui_modal ( self, ui, parent ):
        """ Creates a wxPython modal dialog user interface using information
            from the specified UI object.
        """
        import ui_modal
        ui_modal.ui_modal( ui, parent )

    def ui_nonmodal ( self, ui, parent ):
        """ Creates a wxPython non-modal dialog user interface using
            information from the specified UI object.
        """
        import ui_modal
        ui_modal.ui_nonmodal( ui, parent )

    def ui_popup ( self, ui, parent ):
        """ Creates a wxPython temporary "live update" popup dialog user
            interface using information from the specified UI object.
        """
        import ui_live
        ui_live.ui_popup( ui, parent )

    def ui_popover ( self, ui, parent ):
        """ Creates a wxPython temporary "live update" popup dialog user
            interface using information from the specified UI object.
        """
        import ui_live
        ui_live.ui_popover( ui, parent )

    def ui_info ( self, ui, parent ):
        """ Creates a wxPython temporary "live update" popup dialog user
            interface using information from the specified UI object.
        """
        import ui_live
        ui_live.ui_info( ui, parent )

    def ui_wizard ( self, ui, parent ):
        """ Creates a wxPython wizard dialog user interface using information
            from the specified UI object.
        """
        import ui_wizard
        ui_wizard.ui_wizard( ui, parent )

    def view_application ( self, context, view, kind = None, handler = None,
                                     id = '', scrollable = None, args = None ):
        """ Creates a wxPython modal dialog user interface that
            runs as a complete application, using information from the
            specified View object.

        Parameters
        ----------
        context : object or dictionary
            A single object or a dictionary of string/object pairs, whose trait
            attributes are to be edited. If not specified, the current object is
            used.
        view : view or string
            A View object that defines a user interface for editing trait
            attribute values.
        kind : string
            The type of user interface window to create. See the
            **traitsui.view.kind_trait** trait for values and
            their meanings. If *kind* is unspecified or None, the **kind**
            attribute of the View object is used.
        handler : Handler object
            A handler object used for event handling in the dialog box. If
            None, the default handler for Traits UI is used.
        id : string
            A unique ID for persisting preferences about this user interface,
            such as size and position. If not specified, no user preferences
            are saved.
        scrollable : Boolean
            Indicates whether the dialog box should be scrollable. When set to
            True, scroll bars appear on the dialog box if it is not large enough
            to display all of the items in the view at one time.

        """
        import view_application
        return view_application.view_application( context, view, kind, handler,
                                                  id, scrollable, args )

    #---------------------------------------------------------------------------
    #  Positions the associated dialog window on the display:
    #---------------------------------------------------------------------------

    def position ( self, ui ):
        """ Positions the associated dialog window on the display.
        """
        view   = ui.view
        window = ui.control

        # Set up the default position of the window:
        parent = window.GetParent()
        if parent is None:
           px,  py  = 0, 0
           pdx, pdy = screen_dx, screen_dy
        else:
           px,  py  = parent.GetPositionTuple()
           pdx, pdy = parent.GetSizeTuple()

        # Calculate the correct width and height for the window:
        cur_width, cur_height = window.GetSizeTuple()
        width  = view.width
        height = view.height

        if width < 0.0:
            width = cur_width
        elif width <= 1.0:
            width = int( width * screen_dx )
        else:
            width = int( width )

        if height < 0.0:
            height = cur_height
        elif height <= 1.0:
            height = int( height * screen_dy )
        else:
            height = int( height )

        if view.kind in Popups:
            position_window( window, width, height )
            return

        # Calculate the correct position for the window:
        x = view.x
        y = view.y

        if x < -99999.0:
            # BH- I think this is the case when there is a parent
            # so this logic tries to place it in the middle of the parent
            # if possible, otherwise tries an offset from the parent
            x = px + (pdx - width)/2
            if x < 0:
                 x = px + 20
        elif x <= -1.0:
            x = px + pdx - width + int( x ) + 1
        elif x < 0.0:
            x = px + pdx - width + int( x * pdx )
        elif x <= 1.0:
            x = px + int( x * pdx )
        else:
            x = int( x )

        if y < -99999.0:
            # BH- I think this is the case when there is a parent
            # so this logic tries to place it in the middle of the parent
            # if possible, otherwise tries an offset from the parent
            y = py + (pdy - height)/2
            if y < 0:
                y = py + 20
        elif y <= -1.0:
            y = py + pdy - height + int( y ) + 1
        elif x < 0.0:
            y = py + pdy - height + int( y * pdy )
        elif y <= 1.0:
            y = py + int( y * pdy )
        else:
            y = int( y )

        # make sure the position is on the visible screen, maybe
        # the desktop had been resized?
        x = min(x, wx.DisplaySize()[0])
        y = min(y, wx.DisplaySize()[1])

        # Position and size the window as requested:
        window.SetDimensions( max( 0, x ), max( 0, y ), width, height )

    #---------------------------------------------------------------------------
    #  Shows a 'Help' window for a specified UI and control:
    #---------------------------------------------------------------------------

    def show_help ( self, ui, control ):
        """ Shows a help window for a specified UI and control.
        """
        import ui_panel
        ui_panel.show_help( ui, control )

    #---------------------------------------------------------------------------
    #  Saves user preference information associated with a UI window:
    #---------------------------------------------------------------------------

    def save_window ( self, ui ):
        """ Saves user preference information associated with a UI window.
        """
        import helper

        helper.save_window( ui )

    #---------------------------------------------------------------------------
    #  Rebuilds a UI after a change to the content of the UI:
    #---------------------------------------------------------------------------

    def rebuild_ui ( self, ui ):
        """ Rebuilds a UI after a change to the content of the UI.
        """
        parent = size = None

        if ui.control is not None:
            size   = ui.control.GetSize()
            parent = ui.control._parent
            info = ui.info
            ui.recycle()
            ui.info= info
            info.ui = ui

        ui.rebuild( ui, parent )

        if parent is not None:
            ui.control.SetSize( size )
            sizer = parent.GetSizer()
            if sizer is not None:
                sizer.Add( ui.control, 1, wx.EXPAND )

    #---------------------------------------------------------------------------
    #  Sets the title for the UI window:
    #---------------------------------------------------------------------------

    def set_title ( self, ui ):
        """ Sets the title for the UI window.
        """
        ui.control.SetTitle( ui.title )

    #---------------------------------------------------------------------------
    #  Sets the icon for the UI window:
    #---------------------------------------------------------------------------

    def set_icon ( self, ui ):
        """ Sets the icon for the UI window.
        """
        from pyface.image_resource import ImageResource

        if isinstance( ui.icon, ImageResource ):
            ui.control.SetIcon( ui.icon.create_icon() )

    #---------------------------------------------------------------------------
    #  Converts a keystroke event into a corresponding key name:
    #---------------------------------------------------------------------------

    def key_event_to_name ( self, event ):
        """ Converts a keystroke event into a corresponding key name.
        """
        import key_event_to_name

        return key_event_to_name.key_event_to_name( event )

    #---------------------------------------------------------------------------
    #  Hooks all specified events for all controls in a ui so that they can be
    #  routed to the correct event handler:
    #---------------------------------------------------------------------------

    def hook_events ( self, ui, control, events = None, handler = None,
                      drop_target = None ):
        """ Hooks all specified events for all controls in a UI so that they
            can be routed to the correct event handler.
        """
        if events is None:
            events = (
               wx.wxEVT_LEFT_DOWN, wx.wxEVT_LEFT_DCLICK, wx.wxEVT_LEFT_UP,
               wx.wxEVT_MIDDLE_DOWN, wx.wxEVT_MIDDLE_DCLICK, wx.wxEVT_MIDDLE_UP,
               wx.wxEVT_RIGHT_DOWN, wx.wxEVT_RIGHT_DCLICK, wx.wxEVT_RIGHT_UP,
               wx.wxEVT_MOTION, wx.wxEVT_ENTER_WINDOW, wx.wxEVT_LEAVE_WINDOW,
               wx.wxEVT_MOUSEWHEEL, wx.wxEVT_PAINT
            )
            control.SetDropTarget( PythonDropTarget(
                                   DragHandler( ui = ui, control = control ) ) )
        elif events == 'keys':
            events = ( wx.wxEVT_CHAR, )

        if handler is None:
            handler = ui.route_event

        id            = control.GetId()
        event_handler = wx.EvtHandler()
        connect       = event_handler.Connect

        for event in events:
            connect( id, id, event, handler )

        control.PushEventHandler( event_handler )

        for child in control.GetChildren():
            self.hook_events( ui, child, events, handler, drop_target )

    #---------------------------------------------------------------------------
    #  Routes a 'hooked' event to the correct handler method:
    #---------------------------------------------------------------------------

    def route_event ( self, ui, event ):
        """ Routes a hooked event to the correct handler method.
        """
        suffix  = EventSuffix[ event.GetEventType() ]
        control = event.GetEventObject()
        handler = ui.handler
        method  = None

        owner   = getattr( control, '_owner', None )
        if owner is not None:
            method = getattr( handler, 'on_%s_%s' % ( owner.get_id(), suffix ),
                              None )

        if method is None:
            method = (getattr( handler, 'on_%s' % suffix, None ) or
                      getattr( handler, 'on_any_event',   None ))

        if (method is None) or (method( ui.info, owner, event ) is False):
            event.Skip()

    #---------------------------------------------------------------------------
    #  Indicates that an event should continue to be processed by the toolkit
    #---------------------------------------------------------------------------

    def skip_event ( self, event ):
        """ Indicates that an event should continue to be processed by the
            toolkit.
        """
        event.Skip()

    #---------------------------------------------------------------------------
    #  Destroys a specified GUI toolkit control:
    #---------------------------------------------------------------------------

    def destroy_control ( self, control ):
        """ Destroys a specified GUI toolkit control.
        """
        _popEventHandlers(control)
        control.Destroy()

    #---------------------------------------------------------------------------
    #  Destroys all of the child controls of a specified GUI toolkit control:
    #---------------------------------------------------------------------------

    def destroy_children ( self, control ):
        """ Destroys all of the child controls of a specified GUI toolkit
            control.
        """
        for child in control.GetChildren():
            _popEventHandlers(child)
        control.DestroyChildren()

    #---------------------------------------------------------------------------
    #  Returns a ( width, height ) tuple containing the size of a specified
    #  toolkit image:
    #---------------------------------------------------------------------------

    def image_size ( self, image ):
        """ Returns a ( width, height ) tuple containing the size of a
            specified toolkit image.
        """
        return ( image.GetWidth(), image.GetHeight() )

    #---------------------------------------------------------------------------
    #  Returns a dictionary of useful constants:
    #---------------------------------------------------------------------------

    def constants ( self ):
        """ Returns a dictionary of useful constants.

            Currently, the dictionary should have the following key/value pairs:

            - WindowColor': the standard window background color in the toolkit
              specific color format.
        """
        return {
            'WindowColor': WindowColor
        }

    #---------------------------------------------------------------------------
    #  Returns a renderer used to render 'themed' table cells for a specified
    #  TableColumn object:
    #---------------------------------------------------------------------------

    def themed_cell_renderer ( self, column ):
        """ Returns a renderer used to render 'themed' table cells for a
            specified TableColum object.
        """
        from themed_cell_renderer import ThemedCellRenderer
        return ThemedCellRenderer( column )

    #---------------------------------------------------------------------------
    #  GUI toolkit dependent trait definitions:
    #---------------------------------------------------------------------------

    def color_trait ( self, *args, **traits ):
        import color_trait as ct
        return ct.WxColor( *args, **traits )

    def rgb_color_trait ( self, *args, **traits ):
        import rgb_color_trait as rgbct
        return rgbct.RGBColor( *args, **traits )

    def font_trait ( self, *args, **traits ):
        import font_trait as ft
        return ft.WxFont( *args, **traits )

    #---------------------------------------------------------------------------
    #  'Editor' class methods:
    #---------------------------------------------------------------------------

    # Generic UI-base editor:
    def ui_editor ( self ):
        import ui_editor
        return ui_editor.UIEditor
#
#    # Drag and drop:
#    def dnd_editor ( self, *args, **traits ):
#        import dnd_editor as dnd
#        return dnd.ToolkitEditorFactory( *args, **traits)
#
#    # Key Binding:
#    def key_binding_editor ( self, *args, **traits ):
#        import key_binding_editor as kbe
#        return kbe.ToolkitEditorFactory( *args, **traits )
#
#    # History:
#    def history_editor ( self, *args, **traits ):
#        import history_editor as he
#        return he.HistoryEditor( *args, **traits )
#
#    # HTML:
#    def html_editor ( self, *args, **traits ):
#        import html_editor as he
#        return he.ToolkitEditorFactory( *args, **traits )
#
#    # Image:
#    def image_editor ( self, *args, **traits ):
#        import image_editor as ie
#        return ie.ImageEditor( *args, **traits )
#
#    # ListStr:
#    def list_str_editor ( self, *args, **traits ):
#        import list_str_editor as lse
#        return lse.ListStrEditor( *args, **traits )
#
#    # Ordered set:
#    def ordered_set_editor ( self, *args, **traits ):
#        import ordered_set_editor as ose
#        return ose.ToolkitEditorFactory( *args, **traits )
#
#    # Plot:
#    def plot_editor ( self, *args, **traits ):
#        import plot_editor as pe
#        return pe.ToolkitEditorFactory( *args, **traits )
#
#    # Popup:
#    def popup_editor ( self, *args, **traits ):
#        import popup_editor as pe
#        return pe.PopupEditor( *args, **traits )
#
#    # RGB Color:
#    def rgb_color_editor ( self, *args, **traits ):
#        import rgb_color_editor as rgbce
#        return rgbce.ToolkitEditorFactory( *args, **traits )
#
#    # Scrubber:
#    def scrubber_editor ( self, *args, **traits ):
#        import scrubber_editor as se
#        return se.ScrubberEditor( *args, **traits )
#
#    # Shell:
    def shell_editor ( self, *args, **traits ):
        import shell_editor as se
        return se.ToolkitEditorFactory( *args, **traits )
#
#    # Tabular:
#    def tabular_editor ( self, *args, **traits ):
#        import tabular_editor as te
#        return te.TabularEditor( *args, **traits )
#
#    # Value:
#    def value_editor ( self, *args, **traits ):
#        import value_editor as ve
#        return ve.ToolkitEditorFactory( *args, **traits )

#-------------------------------------------------------------------------------
#  'DragHandler' class:
#-------------------------------------------------------------------------------

class DragHandler ( HasPrivateTraits ):
    """ Handler for drag events.
    """
    #---------------------------------------------------------------------------
    #  Traits definitions:
    #---------------------------------------------------------------------------

    # The UI associated with the drag handler
    ui = Instance( UI )

    # The wx control associated with the drag handler
    control = Instance( wx.Window )

#-- Drag and drop event handlers: ----------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a Python object being dropped on the control:
    #---------------------------------------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the window.
        """
        return self._drag_event( 'dropped_on', x, y, data, drag_result )

    #---------------------------------------------------------------------------
    #  Handles a Python object being dragged over the control:
    #---------------------------------------------------------------------------

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        return self._drag_event( 'drag_over', x, y, data, drag_result )

    #---------------------------------------------------------------------------
    #  Handles a dragged Python object leaving the window:
    #---------------------------------------------------------------------------

    def wx_drag_leave ( self, data ):
        """ Handles a dragged Python object leaving the window.
        """
        return self._drag_event( 'drag_leave' )

    #---------------------------------------------------------------------------
    #  Handles routing a drag event to the appropriate handler:
    #---------------------------------------------------------------------------

    def _drag_event ( self, suffix, x = None, y = None, data = None,
                                    drag_result = None ):
        """ Handles routing a drag event to the appropriate handler.
        """
        control = self.control
        handler = self.ui.handler
        method  = None

        owner   = getattr( control, '_owner', None )
        if owner is not None:
            method = getattr( handler, 'on_%s_%s' % ( owner.get_id(), suffix ),
                              None )

        if method is None:
            method = getattr( handler, 'on_%s' % suffix, None )

        if method is None:
            return wx.DragNone

        if x is None:
            result = method( self.ui.info, owner )
        else:
            result = method( self.ui.info, owner, x, y, data, drag_result )
        if result is None:
            result = drag_result
        return result

#-------------------------------------------------------------------------------
#  Defines the extensions needed to make the generic Theme class specific to
#  wxPython:
#-------------------------------------------------------------------------------

class WXTheme ( Category, Theme ):
    """ Defines the extensions needed to make the generic Theme class specific
        to wxPython.
    """

    # The color to use for content text:
    content_color = Property

    # The color to use for label text:
    label_color = Property

    # The image slice used to draw the theme:
    image_slice = Property( depends_on = 'image' )

    #-- Property Implementations -----------------------------------------------

    def _get_content_color ( self ):
        if self._content_color is None:
            color  = wx.BLACK
            islice = self.image_slice
            if islice is not None:
                color = islice.content_color

            self._content_color = color

        return self._content_color

    def _set_content_color ( self, color ):
        self._content_color = color

    def _get_label_color ( self ):
        if self._label_color is None:
            color  = wx.BLACK
            islice = self.image_slice
            if islice is not None:
                color = islice.label_color

            self._label_color = color

        return self._label_color

    def _set_label_color ( self, color ):
        self._label_color = color

    @cached_property
    def _get_image_slice ( self ):
        from image_slice import image_slice_for

        if self.image is None:
            return None

        return image_slice_for( self.image )

#-------------------------------------------------------------------------------
#  Defines the extensions needed to make the generic DockWindowTheme class
#  specific to wxPython:
#-------------------------------------------------------------------------------

class WXDockWindowTheme ( Category, DockWindowTheme ):
    """ Defines the extensions needed to make the generic DockWindowTheme class
        specific to wxPython.
    """

    # The bitmap for the 'tab_inactive_edge' image:
    tab_inactive_edge_bitmap = Property( depends_on = 'tab_inactive_edge' )

    # The bitmap for the 'tab_hover_edge' image:
    tab_hover_edge_bitmap = Property( depends_on = 'tab_hover_edge' )

    #-- Property Implementations -----------------------------------------------

    @cached_property
    def _get_tab_inactive_edge_bitmap ( self ):
        image = self.tab_inactive_edge
        if image is None:
            return None

        return image.create_image().ConvertToBitmap()

    @cached_property
    def _get_tab_hover_edge_bitmap ( self ):
        image = self.tab_hover_edge
        if image is None:
            return self.tab_inactive_edge_bitmap

        return image.create_image().ConvertToBitmap()


#-------------------------------------------------------------------------------
def _popEventHandlers(ctrl):
    """ Pop any event handlers that have been pushed on to a window and its
        children.
    """
    while ctrl is not ctrl.GetEventHandler():
        ctrl.PopEventHandler(True)
    for child in ctrl.GetChildren():
        _popEventHandlers(child)

########NEW FILE########
__FILENAME__ = tree_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/03/2004
#
#------------------------------------------------------------------------------

""" Defines the tree editor for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import os
import wx
import copy

try:
    from pyface.wx.drag_and_drop import PythonDropSource, \
                                                PythonDropTarget
except:
    PythonDropSource = PythonDropTarget = None

from pyface.resource_manager \
    import resource_manager

from pyface.image_list \
    import ImageList

from traits.api \
    import HasStrictTraits, Any, Str, Event, TraitError

from traits.trait_base \
    import enumerate

from traitsui.api \
    import View, TreeNode, ObjectTreeNode, MultiTreeNode, Image

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.tree_editor file.
from traitsui.editors.tree_editor \
    import ToolkitEditorFactory

from traitsui.undo \
    import ListUndoItem

from traitsui.tree_node \
    import ITreeNodeAdapterBridge

from traitsui.tree_node \
    import ITreeNodeAdapterBridge

from traitsui.menu \
    import Menu, Action, Separator

from pyface.api \
    import ImageResource

from pyface.dock.api \
    import DockWindow, DockSizer, DockSection, DockRegion, DockControl

from constants \
    import OKColor

from editor \
    import Editor

from helper \
    import open_fbi, TraitsUIPanel, TraitsUIScrolledPanel

#-------------------------------------------------------------------------------
#  Global data:
#-------------------------------------------------------------------------------

# Paste buffer for copy/cut/paste operations
paste_buffer = None

#-------------------------------------------------------------------------------
#  The core tree node menu actions:
#-------------------------------------------------------------------------------

NewAction    = 'NewAction'
CopyAction   = Action( name         = 'Copy',
                       action       = 'editor._menu_copy_node',
                       enabled_when = 'editor._is_copyable(object)' )
CutAction    = Action( name         = 'Cut',
                       action       = 'editor._menu_cut_node',
                       enabled_when = 'editor._is_cutable(object)' )
PasteAction  = Action( name         = 'Paste',
                       action       = 'editor._menu_paste_node',
                       enabled_when = 'editor._is_pasteable(object)' )
DeleteAction = Action( name         = 'Delete',
                       action       = 'editor._menu_delete_node',
                       enabled_when = 'editor._is_deletable(object)' )
RenameAction = Action( name         = 'Rename',
                       action       = 'editor._menu_rename_node',
                       enabled_when = 'editor._is_renameable(object)' )

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( Editor ):
    """ Simple style of tree editor.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Is the tree editor is scrollable? This value overrides the default.
    scrollable = True

    # Allows an external agent to set the tree selection
    selection = Event

    # The currently selected object
    selected = Any

    # The event fired when a tree node is activated by double clicking or
    # pressing the enter key on a node.
    activated = Event

    # The event fired when a tree node is clicked on:
    click = Event

    # The event fired when a tree node is double-clicked on:
    dclick = Event

    # The event fired when the application wants to veto an operation:
    veto = Event

    #-- Private Traits ---------------------------------------------------------

    # An icon used by a TreeNode:
    _icon = Image

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        style = self._get_style()

        if factory.editable:

            # Check to see if the tree view is based on a shared trait editor:
            if factory.shared_editor:
                factory_editor = factory.editor

                # If this is the editor that defines the trait editor panel:
                if factory_editor is None:

                    # Remember which editor has the trait editor in the factory:
                    factory._editor = self

                    # Create the trait editor panel:
                    self.control = TraitsUIPanel( parent, -1 )
                    self.control._node_ui = self.control._editor_nid = None

                    # Check to see if there are any existing editors that are
                    # waiting to be bound to the trait editor panel:
                    editors = factory._shared_editors
                    if editors is not None:
                        for editor in factory._shared_editors:

                            # If the editor is part of this UI:
                            if editor.ui is self.ui:

                                # Then bind it to the trait editor panel:
                                editor._editor = self.control

                        # Indicate all pending editors have been processed:
                        factory._shared_editors = None

                    # We only needed to build the trait editor panel, so exit:
                    return

                # Check to see if the matching trait editor panel has been
                # created yet:
                editor = factory_editor._editor
                if (editor is None) or (editor.ui is not self.ui):
                    # If not, add ourselves to the list of pending editors:
                    shared_editors = factory_editor._shared_editors
                    if shared_editors is None:
                        factory_editor._shared_editors = shared_editors = []
                    shared_editors.append( self )
                else:
                    # Otherwise, bind our trait editor panel to the shared one:
                    self._editor = editor.control

                # Finally, create only the tree control:
                self.control = self._tree = tree = wx.TreeCtrl( parent, -1,
                                                                style = style )
            else:
                # If editable, create a tree control and an editor panel:
                self._is_dock_window = True
                theme = factory.dock_theme or self.item.container.dock_theme
                self.control = splitter = DockWindow( parent,
                                                      theme = theme ).control
                self._tree   = tree     = wx.TreeCtrl( splitter, -1,
                                                       style = style )
                self._editor = editor   = TraitsUIScrolledPanel( splitter )
                editor.SetSizer( wx.BoxSizer( wx.VERTICAL ) )
                editor.SetScrollRate( 16, 16 )
                editor.SetMinSize( wx.Size( 100, 100 ) )

                self._editor._node_ui = self._editor._editor_nid = None
                item = self.item
                hierarchy_name = editor_name = ''
                style = 'fixed'
                name  = item.label
                if name != '':
                    hierarchy_name = name + ' Hierarchy'
                    editor_name    = name + ' Editor'
                    style          = item.dock

                splitter.SetSizer( DockSizer( contents =
                    DockSection( contents = [
                        DockRegion( contents = [
                            DockControl( name    = hierarchy_name,
                                         id      = 'tree',
                                         control = tree,
                                         style   = style ) ] ),
                        DockRegion( contents = [
                            DockControl( name    = editor_name,
                                         id      = 'editor',
                                         control = self._editor,
                                         style   = style ) ] ) ],
                        is_row = (factory.orientation == 'horizontal') ) ) )
        else:
            # Otherwise, just create the tree control:
            self.control = self._tree = tree = wx.TreeCtrl( parent, -1,
                                                            style = style )

        # Set up to show tree node icon (if requested):
        if factory.show_icons:
            self._image_list = ImageList( *factory.icon_size )
            tree.AssignImageList( self._image_list )

        # Set up the mapping between objects and tree id's:
        self._map = {}

        # Initialize the 'undo state' stack:
        self._undoable = []

        # Get the tree control id:
        tid = tree.GetId()

        # Set up the mouse event handlers:
        wx.EVT_LEFT_DOWN(  tree, self._on_left_down )
        wx.EVT_RIGHT_DOWN( tree, self._on_right_down )
        wx.EVT_LEFT_DCLICK(tree, self._on_left_dclick )

        # Set up the tree event handlers:
        wx.EVT_TREE_ITEM_EXPANDING(   tree, tid, self._on_tree_item_expanding )
        wx.EVT_TREE_ITEM_EXPANDED(    tree, tid, self._on_tree_item_expanded )
        wx.EVT_TREE_ITEM_COLLAPSING(  tree, tid, self._on_tree_item_collapsing )
        wx.EVT_TREE_ITEM_COLLAPSED(   tree, tid, self._on_tree_item_collapsed )
        wx.EVT_TREE_ITEM_ACTIVATED(   tree, tid, self._on_tree_item_activated )
        wx.EVT_TREE_SEL_CHANGED(      tree, tid, self._on_tree_sel_changed )
        wx.EVT_TREE_BEGIN_DRAG(       tree, tid, self._on_tree_begin_drag )
        wx.EVT_TREE_BEGIN_LABEL_EDIT( tree, tid, self._on_tree_begin_label_edit)
        wx.EVT_TREE_END_LABEL_EDIT(   tree, tid, self._on_tree_end_label_edit )
        wx.EVT_TREE_ITEM_GETTOOLTIP(  tree, tid, self._on_tree_item_gettooltip )

        # Set up general mouse events
        wx.EVT_MOTION(tree, self._on_hover)

        # Synchronize external object traits with the editor:
        self.sync_value( factory.selected, 'selected' )
        self.sync_value( factory.activated,'activated', 'to' )
        self.sync_value( factory.click,    'click',  'to' )
        self.sync_value( factory.dclick,   'dclick', 'to' )
        self.sync_value( factory.veto,     'veto',   'from' )

        # Set up the drag and drop target:
        if PythonDropTarget is not None:
            tree.SetDropTarget( PythonDropTarget( self ) )

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose ( self ):
        """ Disposes of the contents of an editor.
        """
        tree = self._tree
        if tree is not None:
            id = tree.GetId()
            wx.EVT_LEFT_DOWN(             tree,     None )
            wx.EVT_RIGHT_DOWN(            tree,     None )
            wx.EVT_TREE_ITEM_EXPANDING(   tree, id, None )
            wx.EVT_TREE_ITEM_EXPANDED(    tree, id, None )
            wx.EVT_TREE_ITEM_COLLAPSING(  tree, id, None )
            wx.EVT_TREE_ITEM_COLLAPSED(   tree, id, None )
            wx.EVT_TREE_ITEM_ACTIVATED(   tree, id, None )
            wx.EVT_TREE_SEL_CHANGED(      tree, id, None )
            wx.EVT_TREE_BEGIN_DRAG(       tree, id, None )
            wx.EVT_TREE_BEGIN_LABEL_EDIT( tree, id, None )
            wx.EVT_TREE_END_LABEL_EDIT(   tree, id, None )
            wx.EVT_TREE_ITEM_GETTOOLTIP(  tree, id, None )

            nid = self._tree.GetRootItem()
            if nid.IsOk():
                self._delete_node( nid )

        super( SimpleEditor, self ).dispose()

    #---------------------------------------------------------------------------
    #  Handles the 'selection' trait being changed:
    #---------------------------------------------------------------------------

    def _selection_changed ( self, selection ):
        """ Handles the **selection** event.
        """
        try:
            self._tree.SelectItem( self._object_info( selection )[2] )
        except:
            pass

    #---------------------------------------------------------------------------
    #  Handles the 'selected' trait being changed:
    #---------------------------------------------------------------------------

    def _selected_changed ( self, selected ):
        """ Handles the **selected** trait being changed.
        """
        if not self._no_update_selected:
            self._selection_changed( selected )

    #---------------------------------------------------------------------------
    #  Handles the 'veto' event being fired:
    #---------------------------------------------------------------------------

    def _veto_changed ( self ):
        """ Handles the 'veto' event being fired.
        """
        self._veto = True

    #---------------------------------------------------------------------------
    #  Returns the style settings used for displaying the wx tree:
    #---------------------------------------------------------------------------

    def _get_style ( self ):
        """ Returns the style settings used for displaying the wx tree.
        """
        factory = self.factory
        style   = wx.TR_EDIT_LABELS | wx.TR_HAS_BUTTONS | wx.CLIP_CHILDREN

        # Turn lines off if explicit or for appearance on *nix:
        if ((factory.lines_mode == 'off') or
            ((factory.lines_mode == 'appearance') and (os.name == 'posix'))):
            style |= wx.TR_NO_LINES

        if factory.hide_root:
            style |= (wx.TR_HIDE_ROOT | wx.TR_LINES_AT_ROOT)

        if factory.selection_mode != 'single':
            style |= wx.TR_MULTIPLE | wx.TR_EXTENDED


        return style

    #---------------------------------------------------------------------------
    #  Handles the user entering input data in the edit control:
    #---------------------------------------------------------------------------

    def update_object ( self, event ):
        """ Handles the user entering input data in the edit control.
        """
        try:
            self.value = self._get_value()
            self.control.SetBackgroundColour( OKColor )
            self.control.Refresh()
        except TraitError, excp:
            pass

    #---------------------------------------------------------------------------
    #  Saves the current 'expanded' state of all tree nodes:
    #---------------------------------------------------------------------------

    def _save_state ( self ):
        tree  = self._tree
        nid   = tree.GetRootItem()
        state = {}
        if nid.IsOk():
            nodes_to_do = [ nid ]
            while nodes_to_do:
                node = nodes_to_do.pop()
                data = self._get_node_data( node )
                try:
                    is_expanded = tree.IsExpanded( node )
                except:
                    is_expanded = True
                state[ hash( data[-1] ) ] = ( data[0], is_expanded )
                for cnid in self._nodes( node ):
                    nodes_to_do.append( cnid )
        return state

    #---------------------------------------------------------------------------
    #  Restores the 'expanded' state of all tree nodes:
    #---------------------------------------------------------------------------

    def _restore_state ( self, state ):
        if not state:
            return
        tree = self._tree
        nid  = tree.GetRootItem()
        if nid.IsOk():
            nodes_to_do = [ nid ]
            while nodes_to_do:
                node = nodes_to_do.pop()
                for cnid in self._nodes( node ):
                    data = self._get_node_data( cnid )
                    key  = hash( data[-1] )
                    if key in state:
                        was_expanded, current_state = state[ key ]
                        if was_expanded:
                            self._expand_node( cnid )
                            if current_state:
                                tree.Expand( cnid )
                            nodes_to_do.append( cnid )

    #---------------------------------------------------------------------------
    #  Expands all nodes starting from the current selection:
    #---------------------------------------------------------------------------

    def expand_all ( self ):
        """ Expands all nodes, starting from the selected node.
        """
        tree = self._tree

        def _do_expand ( nid ):
            expanded, node, object = self._get_node_data( nid )
            if self._has_children( node, object ):
                tree.SetItemHasChildren( nid, True )
                self._expand_node( nid )
                tree.Expand( nid )

        nid = tree.GetSelection()
        if nid.IsOk():
            nodes_to_do = [ nid ]
            while nodes_to_do:
                node = nodes_to_do.pop()
                _do_expand( node )
                for n in self._nodes( node ):
                    _do_expand( n )
                    nodes_to_do.append( n )

    #---------------------------------------------------------------------------
    #  Expands from the specified node the specified number of sub-levels:
    #---------------------------------------------------------------------------

    def expand_levels ( self, nid, levels, expand = True ):
        """ Expands from the specified node the specified number of sub-levels.
        """
        if levels > 0:
            expanded, node, object = self._get_node_data( nid )
            if self._has_children( node, object ):
                self._tree.SetItemHasChildren( nid, True )
                self._expand_node( nid )
                if expand:
                    self._tree.Expand( nid )
                for cnid in self._nodes( nid ):
                    self.expand_levels( cnid, levels - 1 )

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes external to the editor:
    #---------------------------------------------------------------------------

    def update_editor ( self ):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        tree        = self._tree
        saved_state = {}
        if tree is not None:
            nid = tree.GetRootItem()
            if nid.IsOk():
                self._delete_node( nid )
            object, node = self._node_for( self.value )
            if node is not None:
                icon = self._get_icon( node, object )
                self._root_nid = nid = tree.AddRoot( node.get_label( object ),
                                                     icon, icon )
                self._map[ id( object ) ] = [ ( node.get_children_id( object ),
                                                nid ) ]
                self._add_listeners( node, object )
                self._set_node_data( nid, ( False, node, object) )
                if self.factory.hide_root or self._has_children( node, object ):
                    tree.SetItemHasChildren( nid, True )
                    self._expand_node( nid )
                    if not self.factory.hide_root:
                        tree.Expand( nid )
                        tree.SelectItem( nid )
                        self._on_tree_sel_changed()

                self.expand_levels( nid, self.factory.auto_open, False )

                # It seems like in some cases, an explicit Refresh is needed to
                # trigger a screen update:
                tree.Refresh()

            # fixme: Clear the current editor (if any)...

    #---------------------------------------------------------------------------
    #  Returns the editor's control for indicating error status:
    #---------------------------------------------------------------------------

    def get_error_control ( self ):
        """ Returns the editor's control for indicating error status.
        """
        return self._tree

    #---------------------------------------------------------------------------
    #  Appends a new node to the specified node:
    #---------------------------------------------------------------------------

    def _append_node ( self, nid, node, object ):
        """ Appends a new node to the specified node.
        """
        return self._insert_node( nid, None, node, object )

    #---------------------------------------------------------------------------
    #  Inserts a new node before a specified index into the children of the
    #  specified node:
    #---------------------------------------------------------------------------

    def _insert_node ( self, nid, index, node, object ):
        """ Inserts a new node before a specified index into the children of the
            specified node.
        """
        tree  = self._tree
        icon  = self._get_icon( node, object )
        label = node.get_label( object )
        if index is None:
            cnid = tree.AppendItem( nid, label, icon, icon )
        else:
            cnid = tree.InsertItemBefore( nid, index, label, icon, icon )
        has_children = self._has_children( node, object )
        tree.SetItemHasChildren( cnid, has_children )
        self._set_node_data( cnid, ( False, node, object ) )
        self._map.setdefault( id( object ), [] ).append(
            ( node.get_children_id( object ), cnid ) )
        self._add_listeners( node, object )

        # Automatically expand the new node (if requested):
        if has_children and node.can_auto_open( object ):
            tree.Expand( cnid )

        # Return the newly created node:
        return cnid

    #---------------------------------------------------------------------------
    #  Deletes a specified tree node and all its children:
    #---------------------------------------------------------------------------

    def _delete_node ( self, nid ):
        """ Deletes a specified tree node and all of its children.
        """
        for cnid in self._nodes_for( nid ):
            self._delete_node( cnid )

        expanded, node, object = self._get_node_data( nid )
        id_object   = id( object )
        object_info = self._map[ id_object ]
        for i, info in enumerate( object_info ):
            if nid == info[1]:
                del object_info[i]
                break

        if len( object_info ) == 0:
            self._remove_listeners( node, object )
            del self._map[ id_object ]

        # We set the '_locked' flag here because wx seems to generate a
        # 'node selected' event when the node is deleted. This can lead to
        # some bad side effects. So the 'node selected' event handler exits
        # immediately if the '_locked' flag is set:
        self._locked = True
        self._tree.Delete( nid )
        self._locked = False

        # If the deleted node had an active editor panel showing, remove it:
        if (self._editor is not None) and (nid == self._editor._editor_nid):
            self._clear_editor()

    #---------------------------------------------------------------------------
    #  Expands the contents of a specified node (if required):
    #---------------------------------------------------------------------------

    def _expand_node ( self, nid ):
        """ Expands the contents of a specified node (if required).
        """
        expanded, node, object = self._get_node_data( nid )

        # Lazily populate the item's children:
        if not expanded:
            for child in node.get_children( object ):
                child, child_node = self._node_for( child )
                if child_node is not None:
                    self._append_node( nid, child_node, child )

            # Indicate the item is now populated:
            self._set_node_data( nid, ( True, node, object) )

    #---------------------------------------------------------------------------
    #  Returns each of the child nodes of a specified node id:
    #---------------------------------------------------------------------------

    def _nodes ( self, nid ):
        """ Returns each of the child nodes of a specified node.
        """
        tree         = self._tree
        cnid, cookie = tree.GetFirstChild( nid )
        while cnid.IsOk():
            yield cnid
            cnid, cookie = tree.GetNextChild( nid, cookie )

    def _nodes_for ( self, nid ):
        """ Returns all child node ids of a specified node id.
        """
        return [ cnid for cnid in self._nodes( nid ) ]

    #---------------------------------------------------------------------------
    #  Return the index of a specified node id within its parent:
    #---------------------------------------------------------------------------

    def _node_index ( self, nid ):
        pnid = self._tree.GetItemParent( nid )
        if not pnid.IsOk():
            return ( None, None, None )

        for i, cnid in enumerate( self._nodes( pnid ) ):
            if cnid == nid:
                ignore, pnode, pobject = self._get_node_data( pnid )

                return ( pnode, pobject, i )

    #---------------------------------------------------------------------------
    #  Returns whether a specified object has any children:
    #---------------------------------------------------------------------------

    def _has_children ( self, node, object ):
        """ Returns whether a specified object has any children.
        """
        return (node.allows_children( object ) and node.has_children( object ))

    #---------------------------------------------------------------------------
    #  Returns whether a given object is droppable on the node:
    #---------------------------------------------------------------------------

    def _is_droppable ( self, node, object, add_object, for_insert ):
        """ Returns whether a given object is droppable on the node.
        """
        if for_insert and (not node.can_insert( object )):
            return False

        return node.can_add( object, add_object )

    #---------------------------------------------------------------------------
    #  Returns a droppable version of a specified object:
    #---------------------------------------------------------------------------

    def _drop_object ( self, node, object, dropped_object, make_copy = True ):
        """ Returns a droppable version of a specified object.
        """
        new_object = node.drop_object( object, dropped_object )
        if (new_object is not dropped_object) or (not make_copy):
            return new_object

        return copy.deepcopy( new_object )

    #---------------------------------------------------------------------------
    #  Returns the icon index for the specified object:
    #---------------------------------------------------------------------------

    def _get_icon ( self, node, object, is_expanded = False ):
        """ Returns the index of the specified object icon.
        """
        if self._image_list is None:
            return -1

        icon_name = node.get_icon( object, is_expanded )
        if isinstance( icon_name, basestring ):
            if icon_name[:1] == '@':
                self._icon = icon_name
                icon_name  = self._icon
            else:
                if icon_name[:1] == '<':
                    icon_name = icon_name[1:-1]
                    path      = self
                else:
                    path = node.get_icon_path( object )
                    if isinstance( path, basestring ):
                        path = [ path, node ]
                    else:
                        path.append( node )

                reference = resource_manager.locate_image( icon_name, path )
                if reference is None:
                    return -1

                file_name = reference.filename

        # If it is an ImageResource, get its file name directly:
        if isinstance( icon_name, ImageResource ):
            file_name = icon_name

        return self._image_list.GetIndex( file_name )

    #---------------------------------------------------------------------------
    #  Adds the event listeners for a specified object:
    #---------------------------------------------------------------------------

    def _add_listeners ( self, node, object ):
        """ Adds the event listeners for a specified object.
        """
        if node.allows_children( object ):
            node.when_children_replaced( object, self._children_replaced, False)
            node.when_children_changed(  object, self._children_updated,  False)

        node.when_label_changed( object, self._label_updated, False )

    #---------------------------------------------------------------------------
    #  Removes any event listeners from a specified object:
    #---------------------------------------------------------------------------

    def _remove_listeners ( self, node, object ):
        """ Removes any event listeners from a specified object.
        """
        if node.allows_children( object ):
            node.when_children_replaced( object, self._children_replaced, True )
            node.when_children_changed(  object, self._children_updated,  True )

        node.when_label_changed( object, self._label_updated, True )

    #---------------------------------------------------------------------------
    #  Returns the tree node data for a specified object in the form
    #  ( expanded, node, nid ):
    #---------------------------------------------------------------------------

    def _object_info ( self, object, name = '' ):
        """ Returns the tree node data for a specified object in the form
            ( expanded, node, nid ).
        """
        info = self._map[ id( object ) ]
        for name2, nid in info:
            if name == name2:
                break
        else:
            nid = info[0][1]

        expanded, node, ignore = self._get_node_data( nid )

        return ( expanded, node, nid )

    def _object_info_for ( self, object, name = '' ):
        """ Returns the tree node data for a specified object as a list of the
            form: [ ( expanded, node, nid ), ... ].
        """
        result = []
        for name2, nid in self._map[ id( object ) ]:
            if name == name2:
                expanded, node, ignore = self._get_node_data( nid )
                result.append( ( expanded, node, nid ) )

        return result

    #---------------------------------------------------------------------------
    #  Returns the TreeNode associated with a specified object:
    #---------------------------------------------------------------------------

    def _node_for ( self, object ):
        """ Returns the TreeNode associated with a specified object.
        """
        if ((type( object ) is tuple) and (len( object ) == 2) and
            isinstance( object[1], TreeNode )):
            return object

        # Select all nodes which understand this object:
        factory = self.factory
        nodes   = [ node for node in factory.nodes
                    if object is not None and node.is_node_for( object ) ]

        # If only one found, we're done, return it:
        if len( nodes ) == 1:
            return ( object, nodes[0] )

        # If none found, try to create an adapted node for the object:
        if len( nodes ) == 0:
           return ( object, ITreeNodeAdapterBridge( adapter = object ) )

        # Use all selected nodes that have the same 'node_for' list as the
        # first selected node:
        base  = nodes[0].node_for
        nodes = [ node for node in nodes if base == node.node_for ]

        # If only one left, then return that node:
        if len( nodes ) == 1:
            return ( object, nodes[0] )

        # Otherwise, return a MultiTreeNode based on all selected nodes...

        # Use the node with no specified children as the root node. If not
        # found, just use the first selected node as the 'root node':
        root_node = None
        for i, node in enumerate( nodes ):
            if node.get_children_id( object ) == '':
                root_node = node
                del nodes[i]
                break
        else:
            root_node = nodes[0]

        # If we have a matching MultiTreeNode already cached, return it:
        key = ( root_node, ) + tuple( nodes )
        if key in factory.multi_nodes:
            return ( object, factory.multi_nodes[ key ] )

        # Otherwise create one, cache it, and return it:
        factory.multi_nodes[ key ] = multi_node = MultiTreeNode(
                                                       root_node = root_node,
                                                       nodes     = nodes )

        return ( object, multi_node )

    #---------------------------------------------------------------------------
    #  Returns the TreeNode associated with a specified class:
    #---------------------------------------------------------------------------

    def _node_for_class ( self, klass ):
        """ Returns the TreeNode associated with a specified class.
        """
        for node in self.factory.nodes:
            if issubclass( klass, tuple( node.node_for ) ):
                return node
        return None

    #---------------------------------------------------------------------------
    #  Returns the node and class associated with a specified class name:
    #---------------------------------------------------------------------------

    def _node_for_class_name ( self, class_name ):
        """ Returns the node and class associated with a specified class name.
        """
        for node in self.factory.nodes:
            for klass in node.node_for:
                if class_name == klass.__name__:
                    return ( node, klass )
        return ( None, None )

    #---------------------------------------------------------------------------
    #  Updates the icon for a specified node:
    #---------------------------------------------------------------------------

    def _update_icon ( self, event, is_expanded ):
        """ Updates the icon for a specified node.
        """
        self._update_icon_for_nid( event.GetItem() )

    #---------------------------------------------------------------------------
    #  Updates the icon for a specified node id:
    #---------------------------------------------------------------------------

    def _update_icon_for_nid ( self, nid ):
        """ Updates the icon for a specified node ID.
        """
        if self._image_list is not None:
            expanded, node, object = self._get_node_data( nid )
            icon = self._get_icon( node, object, expanded )
            self._tree.SetItemImage( nid, icon, wx.TreeItemIcon_Normal )
            self._tree.SetItemImage( nid, icon, wx.TreeItemIcon_Selected )

    #---------------------------------------------------------------------------
    #  Unpacks an event to see whether a tree item was involved:
    #---------------------------------------------------------------------------

    def _unpack_event ( self, event ):
        """ Unpacks an event to see whether a tree item was involved.
        """
        try:
            point = event.GetPosition()
        except:
            point = event.GetPoint()

        nid = None
        if hasattr( event, 'GetItem' ):
            nid = event.GetItem()

        if (nid is None) or (not nid.IsOk()):
            nid, flags = self._tree.HitTest( point )

        if nid.IsOk():
            return self._get_node_data( nid ) + ( nid, point )

        return ( None, None, None, nid, point )

    #---------------------------------------------------------------------------
    #  Returns information about the node at a specified point:
    #---------------------------------------------------------------------------

    def _hit_test ( self, point ):
        """ Returns information about the node at a specified point.
        """
        nid, flags = self._tree.HitTest( point )
        if nid.IsOk():
            return self._get_node_data( nid ) + ( nid, point )
        return ( None, None, None, nid, point )

    #---------------------------------------------------------------------------
    #  Begins an 'undoable' transaction:
    #---------------------------------------------------------------------------

    def _begin_undo ( self ):
        """ Begins an "undoable" transaction.
        """
        ui = self.ui
        self._undoable.append( ui._undoable )
        if (ui._undoable == -1) and (ui.history is not None):
            ui._undoable = ui.history.now

    #---------------------------------------------------------------------------
    #  Ends an 'undoable' transaction:
    #---------------------------------------------------------------------------

    def _end_undo ( self ):
        if self._undoable.pop() == -1:
            self.ui._undoable = -1

    #---------------------------------------------------------------------------
    #  Gets an 'undo' item for a change made to a node's children:
    #---------------------------------------------------------------------------

    def _get_undo_item ( self, object, name, event ):
        return ListUndoItem( object  = object,
                             name    = name,
                             index   = event.index,
                             added   = event.added,
                             removed = event.removed )

    #---------------------------------------------------------------------------
    #  Performs an undoable 'append' operation:
    #---------------------------------------------------------------------------

    def _undoable_append ( self, node, object, data, make_copy = True ):
        """ Performs an undoable append operation.
        """
        try:
            self._begin_undo()
            if make_copy:
                data = copy.deepcopy( data )
            node.append_child( object, data )
        finally:
            self._end_undo()

    #---------------------------------------------------------------------------
    #  Performs an undoable 'insert' operation:
    #---------------------------------------------------------------------------

    def _undoable_insert ( self, node, object, index, data, make_copy = True ):
        """ Performs an undoable insert operation.
        """
        try:
            self._begin_undo()
            if make_copy:
                data = copy.deepcopy( data )
            node.insert_child( object, index, data )
        finally:
            self._end_undo()

    #---------------------------------------------------------------------------
    #  Performs an undoable 'delete' operation:
    #---------------------------------------------------------------------------

    def _undoable_delete ( self, node, object, index ):
        """ Performs an undoable delete operation.
        """
        try:
            self._begin_undo()
            node.delete_child( object, index )
        finally:
            self._end_undo()

    #---------------------------------------------------------------------------
    #  Gets the id associated with a specified object (if any):
    #---------------------------------------------------------------------------

    def _get_object_nid ( self, object, name = '' ):
        """ Gets the ID associated with a specified object (if any).
        """
        info = self._map.get( id( object ) )
        if info is None:
            return None

        for name2, nid in info:
            if name == name2:
                return nid
        else:
            return info[0][1]

    #---------------------------------------------------------------------------
    #  Clears the current editor pane (if any):
    #---------------------------------------------------------------------------

    def _clear_editor ( self ):
        """ Clears the current editor pane (if any).
        """
        editor = self._editor
        if editor._node_ui is not None:
            editor.SetSizer( None )
            editor._node_ui.dispose()
            editor._node_ui = editor._editor_nid = None

    #---------------------------------------------------------------------------
    #  Gets/Sets the node specific data:
    #---------------------------------------------------------------------------

    def _get_node_data ( self, nid ):
        """ Gets the node specific data.
        """
        if nid == self._root_nid:
            return self._root_nid_data

        return self._tree.GetPyData( nid )

    def _set_node_data ( self, nid, data ):
        """ Sets the node specific data.
        """
        if nid == self._root_nid:
            self._root_nid_data = data
        else:
            self._tree.SetPyData( nid, data )

#----- User callable methods: --------------------------------------------------

    #---------------------------------------------------------------------------
    #  Gets the object associated with a specified node:
    #---------------------------------------------------------------------------

    def get_object ( self, nid ):
        """ Gets the object associated with a specified node.
        """
        return self._get_node_data( nid )[2]

    #---------------------------------------------------------------------------
    #  Returns the object which is the immmediate parent of a specified object
    #  in the tree:
    #---------------------------------------------------------------------------

    def get_parent ( self, object, name = '' ):
        """ Returns the object that is the immmediate parent of a specified
            object in the tree.
        """
        nid = self._get_object_nid( object, name )
        if nid is not None:
            pnid = self._tree.GetItemParent( nid )
            if pnid.IsOk():
                return self.get_object( pnid )

        return None

    #---------------------------------------------------------------------------
    #  Returns the node associated with a specified object:
    #---------------------------------------------------------------------------

    def get_node ( self, object, name = '' ):
        """ Returns the node associated with a specified object.
        """
        nid = self._get_object_nid( object, name )
        if nid is not None:
            return self._get_node_data( nid )[1]

        return None

    #-- Tree Event Handlers: ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a tree node expanding:
    #---------------------------------------------------------------------------

    def _on_tree_item_expanding ( self, event ):
        """ Handles a tree node expanding.
        """
        if self._veto:
            self._veto = False
            event.Veto()
            return

        nid  = event.GetItem()
        tree = self._tree
        expanded, node, object = self._get_node_data( nid )

        # If 'auto_close' requested for this node type, close all of the node's
        # siblings:
        if node.can_auto_close( object ):
            snid = nid
            while True:
                snid = tree.GetPrevSibling( snid )
                if not snid.IsOk():
                    break
                tree.Collapse( snid )
            snid = nid
            while True:
                snid = tree.GetNextSibling( snid )
                if not snid.IsOk():
                    break
                tree.Collapse( snid )

        # Expand the node (i.e. populate its children if they are not there
        # yet):
        self._expand_node( nid )

    #---------------------------------------------------------------------------
    #  Handles a tree node being expanded:
    #---------------------------------------------------------------------------

    def _on_tree_item_expanded ( self, event ):
        """ Handles a tree node being expanded.
        """
        self._update_icon( event, True )

    #---------------------------------------------------------------------------
    #  Handles a tree node collapsing:
    #---------------------------------------------------------------------------

    def _on_tree_item_collapsing ( self, event ):
        """ Handles a tree node collapsing.
        """
        if self._veto:
            self._veto = False
            event.Veto()

    #---------------------------------------------------------------------------
    #  Handles a tree node being collapsed:
    #---------------------------------------------------------------------------

    def _on_tree_item_collapsed ( self, event ):
        """ Handles a tree node being collapsed.
        """
        self._update_icon( event, False )

    #---------------------------------------------------------------------------
    #  Handles a tree node being selected:
    #---------------------------------------------------------------------------

    def _on_tree_sel_changed ( self, event = None ):
        """ Handles a tree node being selected.
        """
        if self._locked:
            return

        # Get the new selection:
        object      = None
        not_handled = True
        nids        = self._tree.GetSelections()

        selected = []
        for nid in nids:
            if not nid.IsOk():
                continue

            # If there is a real selection, get the associated object:
            expanded, node, sel_object = self._get_node_data( nid )
            selected.append(sel_object)

            # Try to inform the node specific handler of the selection,
            # if there are multiple selections, we only care about the
            # first (or maybe the last makes more sense?)
            if nid == nids[0]:
                object = sel_object
                not_handled = node.select( object )

        # Set the value of the new selection:
        if self.factory.selection_mode == 'single':
            self._no_update_selected = True
            self.selected = object
            self._no_update_selected = False
        else:
            self._no_update_selected = True
            self.selected = selected
            self._no_update_selected = False

        # If no one has been notified of the selection yet, inform the editor's
        # select handler (if any) of the new selection:
        if not_handled is True:
            self.ui.evaluate( self.factory.on_select, object )

        # Check to see if there is an associated node editor pane:
        editor = self._editor
        if editor is not None:
            # If we already had a node editor, destroy it:
            editor.Freeze()
            self._clear_editor()

            # If there is a selected object, create a new editor for it:
            if object is not None:
                # Try to chain the undo history to the main undo history:
                view = node.get_view( object )

                if view is None or isinstance(view, str) :
                    view = object.trait_view(view)

                if (self.ui.history is not None) or (view.kind == 'subpanel'):
                    ui = object.edit_traits( parent = editor,
                                             view   = view,
                                             kind   = 'subpanel' )
                else:
                    # Otherwise, just set up our own new one:
                    ui = object.edit_traits( parent = editor,
                                             view   = view,
                                             kind   = 'panel' )

                # Make our UI the parent of the new UI:
                ui.parent = self.ui

                # Remember the new editor's UI and node info:
                editor._node_ui    = ui
                editor._editor_nid = nid

                # Finish setting up the editor:
                sizer = wx.BoxSizer( wx.VERTICAL )
                sizer.Add( ui.control, 1, wx.EXPAND )
                editor.SetSizer( sizer )
                editor.Layout()

            # fixme: The following is a hack needed to make the editor window
            # (which is a wx.ScrolledWindow) recognize that its contents have
            # been changed:
            dx, dy = editor.GetSize()
            editor.SetSize( wx.Size( dx, dy + 1 ) )
            editor.SetSize( wx.Size( dx, dy ) )

            # Allow the editor view to show any changes that have occurred:
            editor.Thaw()

    def _on_hover(self, event):
        """ Handles the mouse moving over a tree node
        """
        id, flags = self._tree.HitTest(event.GetPosition())
        if flags & wx.TREE_HITTEST_ONITEMLABEL:
            expanded, node, object = self._get_node_data( id )
            if self.factory.on_hover is not None:
                self.ui.evaluate( self.factory.on_hover, object )
                self._veto = True
        elif self.factory and self.factory.on_hover is not None:
            self.ui.evaluate( self.factory.on_hover, None )

        # allow other events to be processed
        event.Skip(True)


    #---------------------------------------------------------------------------
    #  Handles a tree item being activated:
    #---------------------------------------------------------------------------

    def _on_tree_item_activated ( self, event ):
        """ Handles a tree item being activated.
        """
        expanded, node, object = self._get_node_data( event.GetItem() )

        if node.activated( object ) is True:
            if self.factory.on_activated is not None:
                self.ui.evaluate( self.factory.on_activated, object )
                self._veto = True
        else:
            self._veto = True

        # Fire the 'activated' event with the clicked on object as value:
        self.activated = object

        # FIXME: Firing the dclick event also for backward compatibility on wx.
        # Change it occur on mouse double click only.
        self.dclick = object

    #---------------------------------------------------------------------------
    #  Handles the user starting to edit a tree node label:
    #---------------------------------------------------------------------------

    def _on_tree_begin_label_edit ( self, event ):
        """ Handles the user starting to edit a tree node label.
        """
        item       = event.GetItem()
        parent     = self._tree.GetItemParent( item )
        can_rename = True
        if parent.IsOk():
            expanded, node, object = self._get_node_data( parent )
            can_rename = node.can_rename( object )

        if can_rename:
            expanded, node, object = self._get_node_data( item )
            if node.can_rename_me( object ):
                return

        event.Veto()

    #---------------------------------------------------------------------------
    #  Handles the user completing tree node label editing:
    #---------------------------------------------------------------------------

    def _on_tree_end_label_edit ( self, event ):
        """ Handles the user completing tree node label editing.
        """
        label = event.GetLabel()
        if len( label ) > 0:
            expanded, node, object = self._get_node_data( event.GetItem() )
            # Tell the node to change the label. If it raises an exception,
            # that means it didn't like the label, so veto the tree node change:
            try:
                node.set_label( object, label )
                return
            except:
                pass
        event.Veto()

    #---------------------------------------------------------------------------
    #  Handles a drag operation starting on a tree node:
    #---------------------------------------------------------------------------

    def _on_tree_begin_drag ( self, event ):
        """ Handles a drag operation starting on a tree node.
        """
        if PythonDropSource is not None:
            expanded, node, object, nid, point = self._unpack_event( event )
            if node is not None:
                try:
                    self._dragging = nid
                    PythonDropSource( self._tree,
                                      node.get_drag_object( object ) )
                finally:
                    self._dragging = None

    #---------------------------------------------------------------------------
    #  Handles a tooltip request on a tree node:
    #---------------------------------------------------------------------------

    def _on_tree_item_gettooltip ( self, event ):
        """ Handles a tooltip request on a tree node.
        """
        nid = event.GetItem()
        if nid.IsOk():
            node_data = self._get_node_data( nid )
            if node_data is not None:
                expanded, node, object = node_data
                tooltip = node.get_tooltip( object )
                if tooltip != '':
                    event.SetToolTip( tooltip )

        event.Skip()

    #---------------------------------------------------------------------------
    #  Handles a tree item being double-clicked:
    #---------------------------------------------------------------------------

    def _on_left_dclick ( self, event ):
        """ Handle left mouse dclick to emit dclick event for associated node.
        """
        # Determine what node (if any) was clicked on:
        expanded, node, object, nid, point = self._unpack_event( event )

        # If the mouse is over a node, then process the click:
        if node is not None:
            if node.dclick( object ) is True:
                if self.factory.on_dclick is not None:
                    self.ui.evaluate( self.factory.on_dclick, object )
                    self._veto = True
            else:
                self._veto = True

            # Fire the 'dclick' event with the object as its value:
            # FIXME: This is instead done in _on_item_activated for backward
            # compatibility only on wx toolkit.
            #self.dclick = object

        # Allow normal mouse event processing to occur:
        event.Skip()

    #---------------------------------------------------------------------------
    #  Handles the user left clicking on a tree node:
    #---------------------------------------------------------------------------

    def _on_left_down ( self, event ):
        """ Handles the user right clicking on a tree node.
        """
        # Determine what node (if any) was clicked on:
        expanded, node, object, nid, point = self._unpack_event( event )

        # If the mouse is over a node, then process the click:
        if node is not None:
            if ((node.click( object ) is True) and
                (self.factory.on_click is not None)):
                self.ui.evaluate( self.factory.on_click, object )

            # Fire the 'click' event with the object as its value:
            self.click = object

        # Allow normal mouse event processing to occur:
        event.Skip()

    #---------------------------------------------------------------------------
    #  Handles the user right clicking on a tree node:
    #---------------------------------------------------------------------------

    def _on_right_down ( self, event ):
        """ Handles the user right clicking on a tree node.
        """
        expanded, node, object, nid, point = self._unpack_event( event )

        if node is not None:
            self._data    = ( node, object, nid )
            self._context = { 'object':  object,
                              'editor':  self,
                              'node':    node,
                              'info':    self.ui.info,
                              'handler': self.ui.handler }

            # Try to get the parent node of the node clicked on:
            pnid = self._tree.GetItemParent( nid )
            if pnid.IsOk():
                ignore, parent_node, parent_object = self._get_node_data( pnid )
            else:
                parent_node = parent_object = None

            self._menu_node          = node
            self._menu_parent_node   = parent_node
            self._menu_parent_object = parent_object

            menu = node.get_menu( object )

            if menu is None:
                # Use the standard, default menu:
                menu = self._standard_menu( node, object )

            elif isinstance( menu, Menu ):
                # Use the menu specified by the node:
                group = menu.find_group( NewAction )
                if group is not None:
                    # Only set it the first time:
                    group.id = ''
                    actions  = self._new_actions( node, object )
                    if len( actions ) > 0:
                        group.insert( 0, Menu( name = 'New', *actions ) )

            else:
                # All other values mean no menu should be displayed:
                menu = None

            # Only display the menu if a valid menu is defined:
            if menu is not None:
                wxmenu = menu.create_menu( self._tree, self )
                self._tree.PopupMenuXY( wxmenu,
                                        point[0] - 10, point[1] - 10 )
                wxmenu.Destroy()

            # Reset all menu related cached values:
            self._data = self._context = self._menu_node = \
            self._menu_parent_node = self._menu_parent_object = None

    #---------------------------------------------------------------------------
    #  Returns the standard contextual pop-up menu:
    #---------------------------------------------------------------------------

    def _standard_menu ( self, node, object ):
        """ Returns the standard contextual pop-up menu.
        """
        actions = [ CutAction, CopyAction, PasteAction, Separator(),
                    DeleteAction, Separator(), RenameAction ]

        # See if the 'New' menu section should be added:
        items = self._new_actions( node, object )
        if len( items ) > 0:
            actions[0:0] = [ Menu( name = 'New', *items ), Separator() ]

        return Menu( *actions )

    #---------------------------------------------------------------------------
    #  Returns a list of Actions that will create 'new' objects:
    #---------------------------------------------------------------------------

    def _new_actions ( self, node, object ):
        """ Returns a list of Actions that will create new objects.
        """
        object = self._data[1]
        items  = []
        add    = node.get_add( object )
        if len( add ) > 0:
            for klass in add:
                prompt = False
                if isinstance( klass, tuple ):
                    klass, prompt = klass
                add_node = self._node_for_class( klass )
                if add_node is not None:
                    class_name = klass.__name__
                    name       = add_node.get_name( object )
                    if name == '':
                        name = class_name
                    items.append(
                        Action( name   = name,
                                action = "editor._menu_new_node('%s',%s)" %
                                         ( class_name, prompt ) ) )
        return items

    #---------------------------------------------------------------------------
    #  Menu action helper methods:
    #---------------------------------------------------------------------------

    def _is_copyable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            return parent.can_copy( self._menu_parent_object )
        return ((parent is not None) and parent.can_copy( object ))

    def _is_cutable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            can_cut = (parent.can_copy( self._menu_parent_object ) and
                       parent.can_delete( self._menu_parent_object ))
        else:
            can_cut = ((parent is not None) and
                       parent.can_copy( object ) and
                       parent.can_delete( object ))
        return (can_cut and self._menu_node.can_delete_me( object ))

    def _is_pasteable ( self, object ):
        from pyface.wx.clipboard import clipboard

        return self._menu_node.can_add( object, clipboard.object_type )

    def _is_deletable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            can_delete = parent.can_delete( self._menu_parent_object )
        else:
            can_delete = ((parent is not None) and parent.can_delete( object ))
        return (can_delete and self._menu_node.can_delete_me( object ))

    def _is_renameable ( self, object ):
        parent = self._menu_parent_node
        if isinstance( parent, ObjectTreeNode ):
            can_rename = parent.can_rename( self._menu_parent_object )
        elif parent is not None:
            can_rename = parent.can_rename( object )
        else:
            can_rename = True
        return (can_rename and self._menu_node.can_rename_me( object ))

#----- Drag and drop event handlers: -------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles a Python object being dropped on the tree:
    #---------------------------------------------------------------------------

    def wx_dropped_on ( self, x, y, data, drag_result ):
        """ Handles a Python object being dropped on the tree.
        """
        if isinstance( data, list ):
            rc = wx.DragNone
            for item in data:
                rc = self.wx_dropped_on( x, y, item, drag_result )
            return rc

        expanded, node, object, nid, point = self._hit_test( wx.Point( x, y ) )
        if node is not None:
            if drag_result == wx.DragMove:
                if not self._is_droppable( node, object, data, False ):
                    return wx.DragNone

                if self._dragging is not None:
                    data = self._drop_object( node, object, data, False )
                    if data is not None:
                        try:
                            self._begin_undo()
                            self._undoable_delete(
                                     *self._node_index( self._dragging ) )
                            self._undoable_append( node, object, data, False )
                        finally:
                            self._end_undo()
                else:
                    data = self._drop_object( node, object, data )
                    if data is not None:
                        self._undoable_append( node, object, data, False )

                return drag_result

            to_node, to_object, to_index = self._node_index( nid )
            if to_node is not None:
                if self._dragging is not None:
                    data = self._drop_object( node, to_object, data, False )
                    if data is not None:
                        from_node, from_object, from_index = \
                            self._node_index( self._dragging )
                        if ((to_object is from_object) and
                            (to_index > from_index)):
                            to_index -= 1
                        try:
                            self._begin_undo()
                            self._undoable_delete( from_node, from_object,
                                                   from_index )
                            self._undoable_insert( to_node, to_object, to_index,
                                                   data, False )
                        finally:
                            self._end_undo()
                else:
                    data = self._drop_object( to_node, to_object, data )
                    if data is not None:
                        self._undoable_insert( to_node, to_object, to_index,
                                               data, False )

                return drag_result

        return wx.DragNone

    #---------------------------------------------------------------------------
    #  Handles a Python object being dragged over the tree:
    #---------------------------------------------------------------------------

    def wx_drag_over ( self, x, y, data, drag_result ):
        """ Handles a Python object being dragged over the tree.
        """
        expanded, node, object, nid, point = self._hit_test( wx.Point( x, y ) )
        insert = False

        if (node is not None) and (drag_result == wx.DragCopy):
            node, object, index = self._node_index( nid )
            insert = True

        if ((self._dragging is not None) and
            (not self._is_drag_ok( self._dragging, data, object ))):
            return wx.DragNone

        if ((node is not None) and
            self._is_droppable( node, object, data, insert )):
            return drag_result

        return wx.DragNone

    #---------------------------------------------------------------------------
    #  Makes sure that the target is not the same as or a child of the source
    #  object:
    #---------------------------------------------------------------------------

    def _is_drag_ok ( self, snid, source, target ):
        if (snid is None) or (target is source):
            return False

        for cnid in self._nodes( snid ):
            if not self._is_drag_ok( cnid, self._get_node_data( cnid )[2],
                                     target ):
                return False

        return True

#----- pyface.action 'controller' interface implementation: --------------------

    #---------------------------------------------------------------------------
    #  Adds a menu item to the menu being constructed:
    #---------------------------------------------------------------------------

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        action = menu_item.item.action
        self.eval_when( action.enabled_when, menu_item, 'enabled' )
        self.eval_when( action.checked_when, menu_item, 'checked' )

    #---------------------------------------------------------------------------
    #  Adds a tool bar item to the tool bar being constructed:
    #---------------------------------------------------------------------------

    def add_to_toolbar ( self, toolbar_item ):
        """ Adds a toolbar item to the toolbar being constructed.
        """
        self.add_to_menu( toolbar_item )

    #---------------------------------------------------------------------------
    #  Returns whether the menu action should be defined in the user interface:
    #---------------------------------------------------------------------------

    def can_add_to_menu ( self, action ):
        """ Returns whether the action should be defined in the user interface.
        """
        if action.defined_when != '':
            try:
                if not eval( action.defined_when, globals(), self._context ):
                    return False
            except:
                open_fbi()

        if action.visible_when != '':
            try:
                if not eval( action.visible_when, globals(), self._context ):
                    return False
            except:
                open_fbi()

        return True

    #---------------------------------------------------------------------------
    #  Returns whether the toolbar action should be defined in the user
    #  interface:
    #---------------------------------------------------------------------------

    def can_add_to_toolbar ( self, action ):
        """ Returns whether the toolbar action should be defined in the user
            interface.
        """
        return self.can_add_to_menu( action )

    #---------------------------------------------------------------------------
    #  Performs the action described by a specified Action object:
    #---------------------------------------------------------------------------

    def perform ( self, action, action_event = None ):
        """ Performs the action described by a specified Action object.
        """
        self.ui.do_undoable( self._perform, action )

    def _perform ( self, action ):
        node, object, nid = self._data
        method_name       = action.action
        info              = self.ui.info
        handler           = self.ui.handler

        if method_name.find( '.' ) >= 0:
            if method_name.find( '(' ) < 0:
                method_name += '()'
            try:
                eval( method_name, globals(),
                      { 'object':  object,
                        'editor':  self,
                        'node':    node,
                        'info':    info,
                        'handler': handler } )
            except:
                from traitsui.api import raise_to_debug
                raise_to_debug()

            return

        method = getattr( handler, method_name, None )
        if method is not None:
            method( info, object )
            return

        if action.on_perform is not None:
            action.on_perform( object )

#----- Menu support methods: ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Evaluates a condition within a defined context and sets a specified
    #  object trait based on the (assumed) boolean result:
    #---------------------------------------------------------------------------

    def eval_when ( self, condition, object, trait ):
        """ Evaluates a condition within a defined context, and sets a
        specified object trait based on the result, which is assumed to be a
        Boolean.
        """
        if condition != '':
            value = True
            try:
                if not eval( condition, globals(), self._context ):
                    value = False
            except:
                open_fbi()
            setattr( object, trait, value )

#----- Menu event handlers: ----------------------------------------------------

    #---------------------------------------------------------------------------
    #  Copies the current tree node object to the paste buffer:
    #---------------------------------------------------------------------------

    def _menu_copy_node ( self ):
        """ Copies the current tree node object to the paste buffer.
        """
        from pyface.wx.clipboard import clipboard

        clipboard.data = self._data[1]
        self._data     = None

    #---------------------------------------------------------------------------
    #   Cuts the current tree node object into the paste buffer:
    #---------------------------------------------------------------------------

    def _menu_cut_node ( self ):
        """  Cuts the current tree node object into the paste buffer.
        """
        from pyface.wx.clipboard import clipboard

        node, object, nid = self._data
        clipboard.data    = object
        self._data        = None
        self._undoable_delete( *self._node_index( nid ) )

    #---------------------------------------------------------------------------
    #  Pastes the current contents of the paste buffer into the current node:
    #---------------------------------------------------------------------------

    def _menu_paste_node ( self ):
        """ Pastes the current contents of the paste buffer into the current
            node.
        """
        from pyface.wx.clipboard import clipboard

        node, object, nid = self._data
        self._data        = None
        self._undoable_append( node, object, clipboard.object_data, False )

    #---------------------------------------------------------------------------
    #  Deletes the current node from the tree:
    #---------------------------------------------------------------------------

    def _menu_delete_node ( self ):
        """ Deletes the current node from the tree.
        """
        node, object, nid = self._data
        self._data        = None
        rc = node.confirm_delete( object )
        if rc is not False:
            if rc is not True:
                if self.ui.history is None:
                    # If no undo history, ask user to confirm the delete:
                    dlg = wx.MessageDialog(
                              self._tree,
                              'Are you sure you want to delete %s?' %
                                  node.get_label( object ),
                              'Confirm Deletion',
                              style = wx.OK | wx.CANCEL | wx.ICON_EXCLAMATION )
                    if dlg.ShowModal() != wx.ID_OK:
                        return

            self._undoable_delete( *self._node_index( nid ) )

    #---------------------------------------------------------------------------
    #  Renames the current tree node:
    #---------------------------------------------------------------------------

    def _menu_rename_node ( self ):
        """ Renames the current tree node.
        """
        node, object, nid = self._data
        self._data        = None
        object_label      = ObjectLabel( label = node.get_label( object ) )
        if object_label.edit_traits().result:
            label = object_label.label.strip()
            if label != '':
                node.set_label( object, label )

    #---------------------------------------------------------------------------
    #  Adds a new object to the current node:
    #---------------------------------------------------------------------------

    def _menu_new_node ( self, class_name, prompt = False ):
        """ Adds a new object to the current node.
        """
        node, object, nid   = self._data
        self._data          = None
        new_node, new_class = self._node_for_class_name( class_name )
        new_object          = new_class()
        if (not prompt) or new_object.edit_traits(
                            parent = self.control, kind = 'livemodal' ).result:
            self._undoable_append( node, object, new_object, False )

            # Automatically select the new object if editing is being performed:
            if self.factory.editable:
                self._tree.SelectItem( self._tree.GetLastChild( nid ) )

    #-- Model event handlers ---------------------------------------------------

    #---------------------------------------------------------------------------
    #  Handles the children of a node being completely replaced:
    #---------------------------------------------------------------------------

    def _children_replaced ( self, object, name = '', new = None ):
        """ Handles the children of a node being completely replaced.
        """
        tree = self._tree
        for expanded, node, nid in self._object_info_for( object, name ):
            children = node.get_children( object )

            # Only add/remove the changes if the node has already been expanded:
            if expanded:
                # Delete all current child nodes:
                for cnid in self._nodes_for( nid ):
                    self._delete_node( cnid )

                # Add all of the children back in as new nodes:
                for child in children:
                    child, child_node = self._node_for( child )
                    if child_node is not None:
                        self._append_node( nid, child_node, child )

            # Indicate whether the node has any children now:
            tree.SetItemHasChildren( nid, len( children ) > 0 )

            # Try to expand the node (if requested):
            if node.can_auto_open( object ):
                tree.Expand( nid )

    #---------------------------------------------------------------------------
    #  Handles the children of a node being changed:
    #---------------------------------------------------------------------------

    def _children_updated ( self, object, name, event ):
        """ Handles the children of a node being changed.
        """
        # Log the change that was made (removing '_items' from the end of the
        # name):
        name = name[:-6]
        self.log_change( self._get_undo_item, object, name, event )

        start = event.index
        end   = start + len( event.removed )
        tree  = self._tree

        for expanded, node, nid in self._object_info_for( object, name ):
            n = len( node.get_children( object ) )

            # Only add/remove the changes if the node has already been expanded:
            if expanded:
                # Remove all of the children that were deleted:
                for cnid in self._nodes_for( nid )[ start: end ]:
                    self._delete_node( cnid )

                # Add all of the children that were added:
                remaining = n - len( event.removed )
                child_index = 0
                for child in event.added:
                    child, child_node = self._node_for( child )
                    if child_node is not None:
                        insert_index = (start + child_index) if \
                                        (start < remaining) else None
                        self._insert_node( nid, insert_index, child_node,
                                           child )
                        child_index += 1


            # Indicate whether the node has any children now:
            tree.SetItemHasChildren( nid, n > 0 )

            # Try to expand the node (if requested):
            root = tree.GetRootItem()
            if node.can_auto_open( object ):
                if ( nid != root ) or not self.factory.hide_root:
                    tree.Expand( nid )

    #---------------------------------------------------------------------------
    #   Handles the label of an object being changed:
    #---------------------------------------------------------------------------

    def _label_updated ( self, object, name, label ):
        """  Handles the label of an object being changed.
        """
        nids = {}
        for name2, nid in self._map[ id( object ) ]:
            if nid not in nids:
                nids[ nid ] = None
                node = self._get_node_data( nid )[1]
                self._tree.SetItemText( nid, node.get_label( object ) )
                self._update_icon_for_nid ( nid )

#-- UI preference save/restore interface ---------------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if self._is_dock_window:
            if isinstance( prefs, dict ):
                structure = prefs.get( 'structure' )
            else:
                structure = prefs
            self.control.GetSizer().SetStructure( self.control, structure )

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        if self._is_dock_window:
            return { 'structure': self.control.GetSizer().GetStructure() }

        return None

#-- End UI preference save/restore interface -----------------------------------

#-------------------------------------------------------------------------------
#  'ObjectLabel' class:
#-------------------------------------------------------------------------------

class ObjectLabel ( HasStrictTraits ):
    """ An editable label for an object.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Label to be edited
    label = Str

    #---------------------------------------------------------------------------
    #  Traits view definition:
    #---------------------------------------------------------------------------

    traits_view = View( 'label',
                        title   = 'Edit Label',
                        kind    = 'modal',
                        buttons = [ 'OK', 'Cancel' ] )

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = tuple_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/13/2004
#
#------------------------------------------------------------------------------

""" Defines the tuple editor for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------


# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.tuple_editor file.
from traitsui.editors.tuple_editor \
    import SimpleEditor as BaseSimpleEditor, ToolkitEditorFactory

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'SimpleEditor' class:
#-------------------------------------------------------------------------------

class SimpleEditor ( BaseSimpleEditor, Editor ):
    """ Simple style of editor for tuples.

        The editor displays an editor for each of the fields in the tuple,
        based on the type of each field.
    """
    pass

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = ui_base
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   12/18/2004
#
#------------------------------------------------------------------------------

""" Defines the base class for the wxPython-based Traits UI modal and non-modal
    dialogs.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasStrictTraits, HasPrivateTraits, Instance, List, Event

from traitsui.api \
    import UI

from traitsui.menu \
    import Action

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# List of all predefined system button names:
SystemButtons = [ 'Undo', 'Redo', 'Apply', 'Revert', 'OK', 'Cancel', 'Help' ]

# List of alternative context items that might handle an Action 'perform':
PerformHandlers = ( 'object', 'model' )

#-------------------------------------------------------------------------------
#  'RadioGroup' class:
#-------------------------------------------------------------------------------

class RadioGroup ( HasStrictTraits ):
    """ A group of mutually-exclusive menu or toolbar actions.
    """
    # List of menu or tool bar items
    items = List

    #---------------------------------------------------------------------------
    #  Handles a menu item in the group being checked:
    #---------------------------------------------------------------------------

    def menu_checked ( self, menu_item ):
        """ Handles a menu item in the group being checked.
        """
        for item in self.items:
            if item is not menu_item:
                item.control.Check( False )
                item.item.action.checked = False

    #---------------------------------------------------------------------------
    #  Handles a tool bar item in the group being checked:
    #---------------------------------------------------------------------------

    def toolbar_checked ( self, toolbar_item ):
        """ Handles a tool bar item in the group being checked.
        """
        for item in self.items:
            if item is not toolbar_item:
                item.tool_bar.ToggleTool( item.control_id, False )
                item.item.action.checked = False

#-------------------------------------------------------------------------------
#  'ButtonEditor' class:
#-------------------------------------------------------------------------------

class ButtonEditor ( Editor ):
    """ Editor for buttons.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Action associated with the button
    action = Instance( Action )

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, **traits ):
        self.set( **traits )

    #---------------------------------------------------------------------------
    #  Handles the associated button being clicked:
    #---------------------------------------------------------------------------

    def perform ( self, event ):
        """ Handles the associated button being clicked.
        """
        self.ui.do_undoable( self._perform, event )

    def _perform ( self, event ):
        method_name = self.action.action
        if method_name == '':
            method_name = '_%s_clicked' % (self.action.name.lower())
        method = getattr( self.ui.handler, method_name, None )
        if method is not None:
            method( self.ui.info )
        else:
            self.action.perform( event )

#-------------------------------------------------------------------------------
#  'BaseDialog' class:
#-------------------------------------------------------------------------------

class BaseDialog ( object ):
    """ Base class for Traits UI dialog boxes.
    """
    #---------------------------------------------------------------------------
    #  Sets the frame's icon:
    #---------------------------------------------------------------------------

    def set_icon ( self, icon = None ):
        """ Sets the frame's icon.
        """
        from pyface.image_resource import ImageResource

        if not isinstance( icon, ImageResource ):
            icon = ImageResource( 'frame.ico' )
        self.control.SetIcon( icon.create_icon() )

    #---------------------------------------------------------------------------
    #  Adds a status bar to the dialog:
    #---------------------------------------------------------------------------

    def add_statusbar ( self ):
        """ Adds a status bar to the dialog.
        """
        ui        = self.ui
        statusbar = ui.view.statusbar
        context   = ui.context
        if statusbar is not None:
            widths    = []
            listeners = []
            control   = wx.StatusBar( self.control )
            control.SetFieldsCount( len( statusbar ) )
            for i, item in enumerate( statusbar ):
                width = abs( item.width )
                if width <= 1.0:
                    widths.append( -max( 1, int( 1000 * width ) ) )
                else:
                    widths.append( int( width ) )

                set_text = self._set_status_text( control, i )
                name     = item.name
                set_text( ui.get_extended_value( name ) )
                col    = name.find( '.' )
                object = 'object'
                if col >= 0:
                    object = name[ : col ]
                    name   = name[ col + 1: ]
                object = context[ object ]
                object.on_trait_change( set_text, name, dispatch = 'ui' )
                listeners.append( ( object, set_text, name ) )

            control.SetStatusWidths( widths )
            self.control.SetStatusBar( control )
            ui._statusbar = listeners

    def _set_status_text ( self, control, i ):
        def set_status_text ( text ):
            control.SetStatusText( text, i )

        return set_status_text

    #---------------------------------------------------------------------------
    #  Adds a menu bar to the dialog:
    #---------------------------------------------------------------------------

    def add_menubar ( self ):
        """ Adds a menu bar to the dialog.
        """
        menubar = self.ui.view.menubar
        if menubar is not None:
            self._last_group = self._last_parent = None
            self.control.SetMenuBar(
                menubar.create_menu_bar( self.control, self ) )
            self._last_group = self._last_parent = None

    #---------------------------------------------------------------------------
    #  Adds a tool bar to the dialog:
    #---------------------------------------------------------------------------

    def add_toolbar ( self ):
        """ Adds a toolbar to the dialog.
        """
        toolbar = self.ui.view.toolbar
        if toolbar is not None:
            self._last_group = self._last_parent = None
            self.control.SetToolBar(
                toolbar.create_tool_bar( self.control, self ) )
            self._last_group = self._last_parent = None

    #---------------------------------------------------------------------------
    #  Adds a menu item to the menu bar being constructed:
    #---------------------------------------------------------------------------

    def add_to_menu ( self, menu_item ):
        """ Adds a menu item to the menu bar being constructed.
        """
        item   = menu_item.item
        action = item.action

        if action.id != '':
            self.ui.info.bind( action.id, menu_item )

        if action.style == 'radio':
            if ((self._last_group is None) or
                (self._last_parent is not item.parent)):
                self._last_group = RadioGroup()
                self._last_parent = item.parent
            self._last_group.items.append( menu_item )
            menu_item.group = self._last_group

        if action.enabled_when != '':
            self.ui.add_enabled( action.enabled_when, menu_item )

        if action.checked_when != '':
            self.ui.add_checked( action.checked_when, menu_item )

    #---------------------------------------------------------------------------
    #  Adds a tool bar item to the tool bar being constructed:
    #---------------------------------------------------------------------------

    def add_to_toolbar ( self, toolbar_item ):
        """ Adds a toolbar item to the toolbar being constructed.
        """
        self.add_to_menu( toolbar_item )

    #---------------------------------------------------------------------------
    #  Returns whether the menu action should be defined in the user interface:
    #---------------------------------------------------------------------------

    def can_add_to_menu ( self, action, action_event = None ):
        """ Returns whether the action should be defined in the user interface.
        """
        if action.defined_when == '':
            return True

        return self.ui.eval_when( action.defined_when )

    #---------------------------------------------------------------------------
    #  Returns whether the toolbar action should be defined in the user
    #  interface:
    #---------------------------------------------------------------------------

    def can_add_to_toolbar ( self, action ):
        """ Returns whether the toolbar action should be defined in the user
            interface.
        """
        return self.can_add_to_menu( action )

    #---------------------------------------------------------------------------
    #  Performs the action described by a specified Action object:
    #---------------------------------------------------------------------------

    def perform ( self, action ):
        """ Performs the action described by a specified Action object.
        """
        self.ui.do_undoable( self._perform, action )

    def _perform ( self, action ):
        method = getattr( self.ui.handler, action.action, None )
        if method is not None:
            method( self.ui.info )
        else:
            context = self.ui.context
            for item in PerformHandlers:
                handler = context.get( item, None )
                if handler is not None:
                    method = getattr( handler, action.action, None )
                    if method is not None:
                        method()
                        break
            else:
                action.perform()

    #---------------------------------------------------------------------------
    #  Check to see if a specified 'system' button is in the buttons list, and
    # add it if it is not:
    #---------------------------------------------------------------------------

    def check_button ( self, buttons, action ):
        """ Adds *action* to the system buttons list for this dialog, if it is
        not already in the list.
        """
        name = action.name
        for button in buttons:
            if self.is_button( button, name ):
                return
        buttons.append( action )

    #---------------------------------------------------------------------------
    #  Check to see if a specified Action button is a 'system' button:
    #---------------------------------------------------------------------------

    def is_button ( self, action, name ):
        """ Returns whether a specified action button is a system button.
        """
        if isinstance(action, basestring):
            return (action == name)
        return (action.name == name)

    #---------------------------------------------------------------------------
    #  Coerces a string to an Action if necessary:
    #---------------------------------------------------------------------------

    def coerce_button ( self, action ):
        """ Coerces a string to an Action if necessary.
        """
        if isinstance(action, basestring):
            return Action( name   = action,
                           action = '?'[ (not action in SystemButtons): ] )
        return action

    #---------------------------------------------------------------------------
    #  Creates a user specified button:
    #---------------------------------------------------------------------------

    def add_button ( self, action, sizer, method  = None, enabled = True,
                     name = None, default = False ):
        """ Creates a button.
        """
        ui = self.ui
        if ((action.defined_when != '') and
            (not ui.eval_when( action.defined_when ))):
            return None

        if name is None:
            name = action.name
        id     = action.id
        button = wx.Button( self.control, -1, name )
        button.Enable( enabled )
        if default:
            button.SetDefault()
        if (method is None) or (action.enabled_when != '') or (id != ''):
            editor = ButtonEditor( ui      = ui,
                                   action  = action,
                                   control = button )
            if id != '':
                ui.info.bind( id, editor )
            if action.visible_when != '':
                ui.add_visible( action.visible_when, editor )
            if action.enabled_when != '':
                ui.add_enabled( action.enabled_when, editor )
            if method is None:
                method = editor.perform
        wx.EVT_BUTTON( self.control, button.GetId(), method )
        sizer.Add( button, 0, wx.LEFT, 5 )
        if action.tooltip != '':
            button.SetToolTipString( action.tooltip )
        return button


########NEW FILE########
__FILENAME__ = ui_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   03/03/2006
#
#------------------------------------------------------------------------------

""" Defines the BasicUIEditor class, which allows creating editors that define
    their function by creating an embedded Traits UI.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

from traitsui.ui_editor \
    import UIEditor as BaseUIEditor

from editor \
    import Editor

#-------------------------------------------------------------------------------
#  'UIEditor' base class:
#-------------------------------------------------------------------------------

class UIEditor ( BaseUIEditor, Editor ):
    """ An editor that creates an embedded Traits UI.
    """
    pass

#-- End UI preference save/restore interface -----------------------------------


########NEW FILE########
__FILENAME__ = ui_live
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/01/2004
#
#------------------------------------------------------------------------------

""" Creates a wxPython user interface for a specified UI object, where the UI
    is "live", meaning that it immediately updates its underlying object(s).
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from helper \
    import restore_window, save_window, TraitsUIScrolledPanel

from ui_base \
    import BaseDialog

from ui_panel \
    import panel, show_help

from constants \
    import DefaultTitle, WindowColor, screen_dy, \
                                     scrollbar_dx
from traitsui.undo \
    import UndoHistory

from traitsui.menu \
    import UndoButton, RevertButton, OKButton, CancelButton, HelpButton

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Types of supported windows:
NONMODAL = 0
MODAL    = 1
POPUP    = 2
POPOVER  = 3
INFO     = 4

# Types of 'popup' dialogs:
Popups = set( ( POPUP, POPOVER, INFO ) )

#-------------------------------------------------------------------------------
#  Creates a 'live update' wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_live ( ui, parent ):
    """ Creates a live, non-modal wxPython user interface for a specified UI
    object.
    """
    ui_dialog( ui, parent, NONMODAL )

def ui_livemodal ( ui, parent ):
    """ Creates a live, modal wxPython user interface for a specified UI object.
    """
    ui_dialog( ui, parent, MODAL )

def ui_popup ( ui, parent ):
    """ Creates a live, temporary popup wxPython user interface for a specified
        UI object.
    """
    ui_dialog( ui, parent, POPUP )

def ui_popover ( ui, parent ):
    """ Creates a live, temporary popup wxPython user interface for a specified
        UI object.
    """
    ui_dialog( ui, parent, POPOVER )

def ui_info ( ui, parent ):
    """ Creates a live, temporary popup wxPython user interface for a specified
        UI object.
    """
    ui_dialog( ui, parent, INFO )

def ui_dialog ( ui, parent, style ):
    """ Creates a live wxPython user interface for a specified UI object.
    """
    if ui.owner is None:
        ui.owner = LiveWindow()

    ui.owner.init( ui, parent, style )
    ui.control = ui.owner.control
    ui.control._parent = parent

    try:
        ui.prepare_ui()
    except:
        ui.control.Destroy()
        ui.control.ui = None
        ui.control    = None
        ui.owner      = None
        ui.result     = False
        raise

    ui.handler.position( ui.info )
    restore_window( ui, is_popup = (style in Popups) )

    ui.control.Layout()
    # Check if the control is already being displayed modally. This would be
    # the case if after the window was displayed, some event caused the ui to
    # get rebuilt (typically when the user fires the 'updated' event on the ui
    # ). In this case, calling ShowModal again leads to the parent window
    # hanging even after the control has been closed by clicking OK or Cancel
    # (maybe the modal mode isn't ending?)
    if style == MODAL and not ui.control.IsModal():
        ui.control.ShowModal()
    else:
        ui.control.Show()

#-------------------------------------------------------------------------------
#  'LiveWindow' class:
#-------------------------------------------------------------------------------

class LiveWindow ( BaseDialog ):
    """ User interface window that immediately updates its underlying object(s).
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def init ( self, ui, parent, style ):
        self.is_modal = (style == MODAL)
        window_style  = 0
        view          = ui.view
        if view.resizable:
            window_style |= wx.RESIZE_BORDER

        title = view.title
        if title == '':
            title = DefaultTitle

        history = ui.history
        window  = ui.control
        if window is not None:
            if history is not None:
                history.on_trait_change( self._on_undoable, 'undoable',
                                         remove = True )
                history.on_trait_change( self._on_redoable, 'redoable',
                                         remove = True )
                history.on_trait_change( self._on_revertable, 'undoable',
                                         remove = True )
            window.SetSizer( None )
            ui.reset()
        else:
            self.ui = ui
            if style == MODAL:
                if view.resizable:
                    window_style |= (wx.MAXIMIZE_BOX | wx.MINIMIZE_BOX)
                window = wx.Dialog( parent, -1, title,
                                style = window_style | wx.DEFAULT_DIALOG_STYLE )
            elif style == NONMODAL:
                if parent is not None:
                    window_style |= (wx.FRAME_FLOAT_ON_PARENT |
                                     wx.FRAME_NO_TASKBAR)
                window = wx.Frame( parent, -1, title, style = window_style |
                               (wx.DEFAULT_FRAME_STYLE & (~wx.RESIZE_BORDER)) )
            else:
                if window_style == 0:
                    window_style = wx.SIMPLE_BORDER
                if parent is not None:
                    window_style |= (wx.FRAME_FLOAT_ON_PARENT |
                                     wx.FRAME_NO_TASKBAR)

                window = wx.Frame( parent, -1, '', style = window_style )
                window._kind  = ui.view.kind
                self._monitor = MouseMonitor( ui )

            # Set the correct default window background color:
            window.SetBackgroundColour( WindowColor )

            self.control = window
            wx.EVT_CLOSE( window, self._on_close_page )
            wx.EVT_CHAR(  window, self._on_key )

        self.set_icon( view.icon )
        buttons     = [ self.coerce_button( button )
                        for button in view.buttons ]
        nbuttons    = len( buttons )
        no_buttons  = ((nbuttons == 1) and self.is_button( buttons[0], '' ))
        has_buttons = ((not no_buttons) and ((nbuttons > 0) or view.undo or
                                         view.revert or view.ok or view.cancel))
        if has_buttons or (view.menubar is not None):
            if history is None:
                history = UndoHistory()
        else:
            history = None
        ui.history = history

        # Create the actual trait sheet panel and imbed it in a scrollable
        # window (if requested):
        sw_sizer = wx.BoxSizer( wx.VERTICAL )
        if ui.scrollable:
            sizer       = wx.BoxSizer( wx.VERTICAL )
            sw          = TraitsUIScrolledPanel( window )
            trait_sheet = panel( ui, sw )
            sizer.Add( trait_sheet, 1, wx.EXPAND )
            tsdx, tsdy = trait_sheet.GetSize()
            sw.SetScrollRate( 16, 16 )
            max_dy = (2 * screen_dy) / 3
            sw.SetSizer( sizer )
            sw.SetSize( wx.Size( tsdx + ((tsdy > max_dy) * scrollbar_dx),
                                 min( tsdy, max_dy ) ) )
        else:
            sw = panel( ui, window )

        sw_sizer.Add( sw, 1, wx.EXPAND )
        sw_sizer.SetMinSize(sw.GetSize())

        # Check to see if we need to add any of the special function buttons:
        if (not no_buttons) and (has_buttons or view.help):
            sw_sizer.Add( wx.StaticLine( window, -1 ), 0, wx.EXPAND )
            b_sizer = wx.BoxSizer( wx.HORIZONTAL )

            # Convert all button flags to actual button actions if no buttons
            # were specified in the 'buttons' trait:
            if nbuttons == 0:
                if view.undo:
                    self.check_button( buttons, UndoButton )

                if view.revert:
                    self.check_button( buttons, RevertButton )

                if view.ok:
                    self.check_button( buttons, OKButton )

                if view.cancel:
                    self.check_button( buttons, CancelButton )

                if view.help:
                    self.check_button( buttons, HelpButton )

            # Create a button for each button action:
            for raw_button, button in zip( view.buttons, buttons ):
                button = self.coerce_button( button )
                default = raw_button == view.default_button
                
                if self.is_button( button, 'Undo' ):
                    self.undo = self.add_button( button, b_sizer,
                            self._on_undo, False, default = default )
                    self.redo = self.add_button( button, b_sizer,
                                                 self._on_redo, False, 'Redo' )
                    history.on_trait_change( self._on_undoable, 'undoable',
                                             dispatch = 'ui' )
                    history.on_trait_change( self._on_redoable, 'redoable',
                                             dispatch = 'ui' )
                    if history.can_undo:
                        self._on_undoable( True )

                    if history.can_redo:
                        self._on_redoable( True )

                elif self.is_button( button, 'Revert' ):
                    self.revert = self.add_button( button, b_sizer,
                            self._on_revert, False, default = default )
                    history.on_trait_change( self._on_revertable, 'undoable',
                                             dispatch = 'ui' )
                    if history.can_undo:
                        self._on_revertable( True )

                elif self.is_button( button, 'OK' ):
                    self.ok = self.add_button( button, b_sizer, self._on_ok,
                                               default = default)
                    ui.on_trait_change( self._on_error, 'errors',
                                        dispatch = 'ui' )

                elif self.is_button( button, 'Cancel' ):
                    self.add_button( button, b_sizer, self._on_cancel,
                                     default = default )

                elif self.is_button( button, 'Help' ):
                    self.add_button( button, b_sizer, self._on_help,
                                     default = default )

                elif not self.is_button( button, '' ):
                    self.add_button( button, b_sizer, default = default )

            sw_sizer.Add( b_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5 )

        # Add the menu bar, tool bar and status bar (if any):
        self.add_menubar()
        self.add_toolbar()
        self.add_statusbar()

        # Lay all of the dialog contents out:
        window.SetSizer( sw_sizer )
        window.Fit()

    #---------------------------------------------------------------------------
    #  Closes the dialog window:
    #---------------------------------------------------------------------------

    def close ( self, rc = wx.ID_OK ):
        """ Closes the dialog window.
        """
        ui = self.ui
        ui.result = (rc == wx.ID_OK)
        save_window( ui )
        if self.is_modal:
            self.control.EndModal( rc )

        ui.finish()
        self.ui = self.undo = self.redo = self.revert = self.control = None

    #---------------------------------------------------------------------------
    #  Handles the user clicking the window/dialog 'close' button/icon:
    #---------------------------------------------------------------------------

    def _on_close_page ( self, event ):
        """ Handles the user clicking the window/dialog "close" button/icon.
        """
        if self.ui.view.close_result == False:
            self._on_cancel( event )
        else:
            self._on_ok( event )

    #---------------------------------------------------------------------------
    #  Handles the user giving focus to another window for a 'popup' view:
    #---------------------------------------------------------------------------

    def _on_close_popup ( self, event ):
        """ Handles the user giving focus to another window for a 'popup' view.
        """
        if not event.GetActive():
            self.close_popup()

    def close_popup ( self ):
        # Close the window if it has not already been closed:
        if self.ui.info is not None and self.ui.info.ui is not None:
            if self._on_ok():
                self._monitor.Stop()

    #---------------------------------------------------------------------------
    #  Handles the user clicking the 'OK' button:
    #---------------------------------------------------------------------------

    def _on_ok ( self, event = None ):
        """ Handles the user clicking the **OK** button.
        """
        if self.ui.handler.close( self.ui.info, True ):
            wx.EVT_ACTIVATE( self.control, None )
            self.close( wx.ID_OK )
            return True

        return False

    #---------------------------------------------------------------------------
    #  Handles the user hitting the 'Esc'ape key:
    #---------------------------------------------------------------------------

    def _on_key ( self, event ):
        """ Handles the user pressing the Escape key.
        """
        if event.GetKeyCode() == 0x1B:
           self._on_close_page( event )

    #---------------------------------------------------------------------------
    #  Handles an 'Undo' change request:
    #---------------------------------------------------------------------------

    def _on_undo ( self, event ):
        """ Handles an "Undo" change request.
        """
        self.ui.history.undo()

    #---------------------------------------------------------------------------
    #  Handles a 'Redo' change request:
    #---------------------------------------------------------------------------

    def _on_redo ( self, event ):
        """ Handles a "Redo" change request.
        """
        self.ui.history.redo()

    #---------------------------------------------------------------------------
    #  Handles a 'Revert' all changes request:
    #---------------------------------------------------------------------------

    def _on_revert ( self, event ):
        """ Handles a request to revert all changes.
        """
        ui = self.ui
        if ui.history is not None:
            ui.history.revert()
        ui.handler.revert( ui.info )

    #---------------------------------------------------------------------------
    #  Handles a 'Cancel' all changes request:
    #---------------------------------------------------------------------------

    def _on_cancel ( self, event ):
        """ Handles a request to cancel all changes.
        """
        if self.ui.handler.close( self.ui.info, False ):
            self._on_revert( event )
            self.close( wx.ID_CANCEL )

    #---------------------------------------------------------------------------
    #  Handles editing errors:
    #---------------------------------------------------------------------------

    def _on_error ( self, errors ):
        """ Handles editing errors.
        """
        self.ok.Enable( errors == 0 )

    #---------------------------------------------------------------------------
    #  Handles the 'Help' button being clicked:
    #---------------------------------------------------------------------------

    def _on_help ( self, event ):
        """ Handles the 'user clicking the Help button.
        """
        self.ui.handler.show_help( self.ui.info, event.GetEventObject() )

    #---------------------------------------------------------------------------
    #  Handles the undo history 'undoable' state changing:
    #---------------------------------------------------------------------------

    def _on_undoable ( self, state ):
        """ Handles a change to the "undoable" state of the undo history
        """
        self.undo.Enable( state )

    #---------------------------------------------------------------------------
    #  Handles the undo history 'redoable' state changing:
    #---------------------------------------------------------------------------

    def _on_redoable ( self, state ):
        """ Handles a change to the "redoable state of the undo history.
        """
        self.redo.Enable( state )

    #---------------------------------------------------------------------------
    #  Handles the 'revert' state changing:
    #---------------------------------------------------------------------------

    def _on_revertable ( self, state ):
        """ Handles a change to the "revert" state.
        """
        self.revert.Enable( state )

#-------------------------------------------------------------------------------
#  'MouseMonitor' class:
#-------------------------------------------------------------------------------

class MouseMonitor ( wx.Timer ):
    """ Monitors a specified window and closes it the first time the mouse
        pointer leaves the window.
    """

    def __init__ ( self, ui ):
        super( MouseMonitor, self ).__init__()
        self.ui           = ui
        kind              = ui.view.kind
        self.is_activated = self.is_info = (kind == 'info')
        self.border = 3
        if kind == 'popup':
            self.border = 10
        self.Start( 100 )

    def Notify ( self ):
        ui      = self.ui
        control = ui.control
        if ui.control is None:
            # Looks like someone forgot to tell us that the ui has been closed:
            self.Stop()
            return

        mx, my   = wx.GetMousePosition()
        cx, cy   = control.ClientToScreenXY( 0, 0 )
        cdx, cdy = control.GetSizeTuple()

        if self.is_activated:
            # Don't close the popup if any mouse buttons are currently pressed:
            ms = wx.GetMouseState()
            if ms.LeftDown() or ms.MiddleDown() or ms.RightDown():
                return

            # Check for the special case of the mouse pointer having to be
            # within the original bounds of the object the popup was created
            # for:
            if self.is_info:
                parent = control._parent
                if isinstance( parent, wx.Window ):
                    px, py, pdx, pdy = parent.GetScreenRect()
                else:
                    px, py, pdx, pdy = parent
                if ((mx < px) or (mx >= (px + pdx)) or
                    (my < py) or (my >= (py + pdy))):
                    ui.owner.close_popup()
                    self.is_activated = False

            else:
                # Allow for a 'dead zone' border around the window to allow for
                # small motor control problems:
                border = self.border
                if ((mx < (cx - border)) or (mx >= (cx + cdx + border)) or
                    (my < (cy - border)) or (my >= (cy + cdy + border))):
                    ui.owner.close_popup()
                    self.is_activated = False
        elif (cx <= mx < (cx + cdx)) and (cy <= my < (cy + cdy)):
            self.is_activated = True


########NEW FILE########
__FILENAME__ = ui_modal
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/01/2004
#
#------------------------------------------------------------------------------

""" Creates a wxPython user interface for a specified UI object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from helper \
    import restore_window, save_window, TraitsUIScrolledPanel

from ui_base \
    import BaseDialog

from ui_panel \
    import panel, show_help

from constants \
    import DefaultTitle, WindowColor, screen_dy, scrollbar_dx

from traitsui.menu \
    import ApplyButton, RevertButton, OKButton, CancelButton, HelpButton

#-------------------------------------------------------------------------------
#  Creates a modal wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_modal ( ui, parent ):
    """ Creates a modal wxPython user interface for a specified UI object.
    """
    ui_dialog( ui, parent, True )

#-------------------------------------------------------------------------------
#  Creates a non-modal wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_nonmodal ( ui, parent ):
    """ Creates a non-modal wxPython user interface for a specified UI object.
    """
    ui_dialog( ui, parent, False )

#-------------------------------------------------------------------------------
#  Creates a wxPython dialog-based user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_dialog ( ui, parent, is_modal ):
    """ Creates a wxPython dialog box for a specified UI object.

    Changes are not immediately applied to the underlying object. The user must
    click **Apply** or **OK** to apply changes. The user can revert changes by
    clicking **Revert** or **Cancel**.
    """
    if ui.owner is None:
        ui.owner = ModalDialog()

    ui.owner.init( ui, parent, is_modal )
    ui.control = ui.owner.control
    ui.control._parent = parent
    try:
        ui.prepare_ui()
    except:
        ui.control.Destroy()
        ui.control.ui = None
        ui.control    = None
        ui.owner      = None
        ui.result     = False
        raise

    ui.handler.position( ui.info )
    restore_window( ui )

    if is_modal:
        ui.control.ShowModal()
    else:
        ui.control.Show()

#-------------------------------------------------------------------------------
#  'ModalDialog' class:
#-------------------------------------------------------------------------------

class ModalDialog ( BaseDialog ):
    """ Modal dialog box for Traits-based user interfaces.
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def init ( self, ui, parent, is_modal ):
        self.is_modal = is_modal
        style         = 0
        view          = ui.view
        if view.resizable:
            style |= wx.RESIZE_BORDER

        title = view.title
        if title == '':
            title = DefaultTitle

        revert = apply = False
        window = ui.control
        if window is not None:
            window.SetSizer( None )
            ui.reset()
            if hasattr( self, 'revert' ):
                revert = self.revert.IsEnabled()
            if hasattr( self, 'apply' ):
                apply = self.apply.IsEnabled()
        else:
            self.ui = ui
            if is_modal:
                window = wx.Dialog( parent, -1, title,
                                    style = style | wx.DEFAULT_DIALOG_STYLE )
            else:
                window = wx.Frame(  parent, -1, title, style = style |
                            (wx.DEFAULT_FRAME_STYLE & (~wx.RESIZE_BORDER) ) )

            window.SetBackgroundColour( WindowColor )
            self.control = window
            self.set_icon( view.icon )
            wx.EVT_CLOSE( window, self._on_close_page )
            wx.EVT_CHAR(  window, self._on_key )

            # Create the 'context' copies we will need while editing:
            context     = ui.context
            ui._context = context
            ui.context  = self._copy_context( context )
            ui._revert  = self._copy_context( context )

        # Create the actual trait sheet panel and imbed it in a scrollable
        # window (if requested):
        sw_sizer = wx.BoxSizer( wx.VERTICAL )
        if ui.scrollable:
            sizer       = wx.BoxSizer( wx.VERTICAL )
            sw          = TraitsUIScrolledPanel( window )
            trait_sheet = panel( ui, sw )
            sizer.Add( trait_sheet, 1, wx.EXPAND | wx.ALL, 4 )
            tsdx, tsdy = trait_sheet.GetSizeTuple()
            tsdx += 8
            tsdy += 8
            sw.SetScrollRate( 16, 16 )
            max_dy = (2 * screen_dy) / 3
            sw.SetSizer( sizer )
            sw.SetSize( wx.Size( tsdx + ((tsdy > max_dy) * scrollbar_dx),
                                 min( tsdy, max_dy ) ) )
        else:
            sw = panel( ui, window )

        sw_sizer.Add( sw, 1, wx.EXPAND )

        buttons  = [ self.coerce_button( button ) for button in view.buttons ]
        nbuttons = len( buttons )
        if (nbuttons != 1) or (not self.is_button( buttons[0], '' )):

            # Create the necessary special function buttons:
            sw_sizer.Add( wx.StaticLine( window, -1 ), 0, wx.EXPAND )
            b_sizer = wx.BoxSizer( wx.HORIZONTAL )

            if nbuttons == 0:
                if view.apply:
                    self.check_button( buttons, ApplyButton )
                    if view.revert:
                        self.check_button( buttons, RevertButton )

                if view.ok:
                    self.check_button( buttons, OKButton )

                if view.cancel:
                    self.check_button( buttons, CancelButton )

                if view.help:
                    self.check_button( buttons, HelpButton )

            for raw_button, button in zip( view.buttons, buttons ):
                default = raw_button == view.default_button
                
                if self.is_button( button, 'Apply' ):
                    self.apply = self.add_button( button, b_sizer,
                            self._on_apply, apply, default = default )
                    ui.on_trait_change( self._on_applyable, 'modified',
                                        dispatch = 'ui' )

                elif self.is_button( button, 'Revert' ):
                    self.revert = self.add_button( button, b_sizer,
                            self._on_revert, revert, default = default )

                elif self.is_button( button, 'OK' ):
                    self.ok = self.add_button( button, b_sizer, self._on_ok,
                                               default = default )
                    ui.on_trait_change( self._on_error, 'errors',
                                        dispatch = 'ui' )

                elif self.is_button( button, 'Cancel' ):
                    self.add_button( button, b_sizer, self._on_cancel,
                                     default = default)

                elif self.is_button( button, 'Help' ):
                    self.add_button( button, b_sizer, self._on_help,
                                     default = default)

                elif not self.is_button( button, '' ):
                    self.add_button( button, b_sizer, default = default )

            sw_sizer.Add( b_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5 )

        # Add the menu bar, tool bar and status bar (if any):
        self.add_menubar()
        self.add_toolbar()
        self.add_statusbar()

        # Lay all of the dialog contents out:
        window.SetSizerAndFit( sw_sizer )

    #---------------------------------------------------------------------------
    #  Closes the dialog window:
    #---------------------------------------------------------------------------

    def close ( self, rc = wx.ID_OK ):
        """ Closes the dialog window.
        """
        ui = self.ui
        ui.result = (rc == wx.ID_OK)
        save_window( ui )
        if self.is_modal:
            self.control.EndModal( rc )

        ui.finish()
        self.ui = self.apply = self.revert = self.help = self.control = None

    #---------------------------------------------------------------------------
    #  Creates a copy of a 'context' dictionary:
    #---------------------------------------------------------------------------

    def _copy_context ( self, context ):
        """ Creates a copy of a *context* dictionary.
        """
        result = {}
        for name, value in context.items():
            if value is not None:
                result[ name ] = value.clone_traits()
            else:
                result[ name ] = None

        return result

    #---------------------------------------------------------------------------
    #  Applies the traits in the 'from' context to the 'to' context:
    #---------------------------------------------------------------------------

    def _apply_context ( self, from_context, to_context ):
        """ Applies the traits in the *from_context* to the *to_context*.
        """
        for name, value in from_context.items():
            if value is not None:
                to_context[ name ].copy_traits( value )
            else:
                to_context[ name ] = None

        if to_context is self.ui._context:
            on_apply = self.ui.view.on_apply
            if on_apply is not None:
                on_apply()

    #---------------------------------------------------------------------------
    #  Handles the user clicking the window/dialog 'close' button/icon:
    #---------------------------------------------------------------------------

    def _on_close_page ( self, event ):
        """ Handles the user clicking the window/dialog "close" button/icon.
        """
        if self.ui.view.close_result == True:
            self._on_ok( event )
        else:
            self._on_cancel( event )

    #---------------------------------------------------------------------------
    #  Closes the window and saves changes (if allowed by the handler):
    #---------------------------------------------------------------------------

    def _on_ok ( self, event = None ):
        """ Closes the window and saves changes (if allowed by the handler).
        """
        if self.ui.handler.close( self.ui.info, True ):
            self._apply_context( self.ui.context, self.ui._context )
            self.close( wx.ID_OK )

    #---------------------------------------------------------------------------
    #  Closes the window and discards changes (if allowed by the handler):
    #---------------------------------------------------------------------------

    def _on_cancel ( self, event = None ):
        """ Closes the window and discards changes (if allowed by the handler).
        """
        if self.ui.handler.close( self.ui.info, False ):
            self._apply_context( self.ui._revert, self.ui._context )
            self.close( wx.ID_CANCEL )

    #---------------------------------------------------------------------------
    #  Handles the 'Help' button being clicked:
    #---------------------------------------------------------------------------

    def _on_help ( self, event ):
        """ Handles the **Help** button being clicked.
        """
        self.ui.handler.show_help( self.ui.info, event.GetEventObject() )

    #---------------------------------------------------------------------------
    #  Handles the user hitting the 'Esc'ape key:
    #---------------------------------------------------------------------------

    def _on_key ( self, event ):
        """ Handles the user pressing the Escape key.
        """
        if event.GetKeyCode() == 0x1B:
            self._on_close_page( event )

    #---------------------------------------------------------------------------
    #  Handles an 'Apply' all changes request:
    #---------------------------------------------------------------------------

    def _on_apply ( self, event ):
        """ Handles a request to apply changes.
        """
        ui = self.ui
        self._apply_context( ui.context, ui._context )
        if hasattr(self, 'revert'):
            self.revert.Enable( True )
        ui.handler.apply( ui.info )
        ui.modified = False

    #---------------------------------------------------------------------------
    #  Handles a 'Revert' all changes request:
    #---------------------------------------------------------------------------

    def _on_revert ( self, event ):
        """ Handles a request to revert changes.
        """
        ui = self.ui
        self._apply_context( ui._revert, ui.context )
        self._apply_context( ui._revert, ui._context )
        self.revert.Enable( False )
        ui.handler.revert( ui.info )
        ui.modified = False

    #---------------------------------------------------------------------------
    #  Handles the user interface 'modified' state changing:
    #---------------------------------------------------------------------------

    def _on_applyable ( self, state ):
        """ Handles a change to the "modified" state of the user interface .
        """
        self.apply.Enable( state )

    #---------------------------------------------------------------------------
    #  Handles editing errors:
    #---------------------------------------------------------------------------

    def _on_error ( self, errors ):
        """ Handles editing errors.
        """
        self.ok.Enable( errors == 0 )


########NEW FILE########
__FILENAME__ = ui_panel
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/01/2004
#
#------------------------------------------------------------------------------

""" Creates a panel-based wxPython user interface for a specified UI object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx
import wx.html as wh
import re

from cgi \
    import escape

from traits.api \
    import Instance, Undefined

from traitsui.api \
    import Group

from traits.trait_base \
    import enumerate

from traitsui.undo \
    import UndoHistory

from traitsui.dockable_view_element \
    import DockableViewElement

from traitsui.help_template \
    import help_template

from traitsui.menu \
    import UndoButton, RevertButton, HelpButton

from pyface.dock.api \
    import DockWindow, DockSizer, DockSection, DockRegion, DockControl

from pyface.sizers.flow \
    import FlowSizer

from helper \
    import position_window, TraitsUIPanel, TraitsUIScrolledPanel, GroupEditor

from constants \
    import screen_dx, screen_dy, WindowColor

from ui_base \
    import BaseDialog
from constants import is_mac

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# Pattern of all digits
all_digits = re.compile( r'\d+' )

# Global font used for emphasis
emphasis_font = None

# Global color used for emphasis
emphasis_color = wx.Colour( 0, 0, 127 )

#-------------------------------------------------------------------------------
#  Creates a panel-based wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_panel ( ui, parent ):
    """ Creates a panel-based wxPython user interface for a specified UI object.
    """
    ui_panel_for( ui, parent, True )

#-------------------------------------------------------------------------------
#  Creates a subpanel-based wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_subpanel ( ui, parent ):
    """ Creates a subpanel-based wxPython user interface for a specified UI
        object. A subpanel does not allow control buttons (other than those
        specified in the UI object).
    """
    ui_panel_for( ui, parent, False )

#-------------------------------------------------------------------------------
#  Creates a panel-based wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_panel_for ( ui, parent, buttons ):
    """ Creates a panel-based wxPython user interface for a specified UI object.
    """
    # Disable screen updates on the parent control while we build the view:
    parent.Freeze()

    # Build the view:
    ui.control = control = Panel( ui, parent, buttons ).control

    # Allow screen updates to occur again:
    parent.Thaw()

    control._parent = parent
    control._object = ui.context.get( 'object' )
    control._ui     = ui
    try:
        ui.prepare_ui()
    except:
        control.Destroy()
        ui.control = None
        ui.result  = False
        raise
    ui.restore_prefs()
    ui.result = True

#-------------------------------------------------------------------------------
#  'Panel' class:
#-------------------------------------------------------------------------------

class Panel ( BaseDialog ):
    """ wxPython user interface panel for Traits-based user interfaces.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, ui, parent, allow_buttons ):
        """ Initializes the object.
        """
        self.ui = ui
        history = None
        view    = ui.view
        title   = view.title

        # Reset any existing history listeners:
        history = ui.history
        if history is not None:
            history.on_trait_change( self._on_undoable,
                                     'undoable', remove = True )
            history.on_trait_change( self._on_redoable,
                                     'redoable', remove = True )
            history.on_trait_change( self._on_revertable,
                                     'undoable', remove = True )

        # Determine if we need any buttons or an 'undo' history:
        buttons  = [ self.coerce_button( button ) for button in view.buttons ]
        nbuttons = len( buttons )
        if nbuttons == 0:
            if view.undo:
                self.check_button( buttons, UndoButton )
            if view.revert:
                self.check_button( buttons, RevertButton )
            if view.help:
                self.check_button( buttons, HelpButton )

        if allow_buttons and (history is None):
            for button in buttons:
                if (self.is_button( button, 'Undo' ) or
                    self.is_button( button, 'Revert' )):
                    history = UndoHistory()
                    break
        ui.history = history

        # Create a container panel to put everything in:
        cpanel = getattr( self, 'control', None )
        if cpanel is not None:
            cpanel.SetSizer( None )
            cpanel.DestroyChildren()
        else:
            if is_mac:
                # Groups with borders have a two-tone background, and the
                # getter is picking the wrong color.  Set to transparent
                # and hope that the parent has been painted.
                bg_color = wx.Colour(224, 224, 224, 0)
                self.control = cpanel = TraitsUIPanel( parent, -1,
                                                       bg_color=bg_color )
            else:
                self.control = cpanel = TraitsUIPanel( parent, -1 )

        # Create the actual trait sheet panel and embed it in a scrollable
        # window (if requested):
        sw_sizer = wx.BoxSizer( wx.VERTICAL )
        if ui.scrollable:
            sizer = wx.BoxSizer( wx.VERTICAL )
            sw    = TraitsUIScrolledPanel( cpanel )
            sizer.Add( panel( ui, sw ), 1, wx.EXPAND )

            sw.SetSizerAndFit( sizer )
            sw.SetScrollRate( 16, 16 )
        else:
            sw = panel( ui, cpanel )

        if ((title != '') and
            (not isinstance( getattr( parent, 'owner', None ), DockWindow ))):
            sw_sizer.Add( heading_text( cpanel, text = title ).control, 0,
                          wx.EXPAND )

        self.add_toolbar( sw_sizer )

        sw_sizer.Add( sw, 1, wx.EXPAND )

        if (allow_buttons and
            ((nbuttons != 1) or (not self.is_button( buttons[0], '' )))):
            # Add the special function buttons:
            sw_sizer.Add( wx.StaticLine( cpanel, -1 ), 0, wx.EXPAND )
            b_sizer = wx.BoxSizer( wx.HORIZONTAL )
            for button in buttons:
                if self.is_button( button, 'Undo' ):
                    self.undo = self.add_button( button, b_sizer,
                                                 self._on_undo, False )
                    self.redo = self.add_button( button, b_sizer,
                                                 self._on_redo, False, 'Redo' )
                    history.on_trait_change( self._on_undoable, 'undoable',
                                             dispatch = 'ui' )
                    history.on_trait_change( self._on_redoable, 'redoable',
                                             dispatch = 'ui' )
                elif self.is_button( button, 'Revert' ):
                    self.revert = self.add_button( button, b_sizer,
                                                   self._on_revert, False )
                    history.on_trait_change( self._on_revertable, 'undoable',
                                             dispatch = 'ui' )
                elif self.is_button( button, 'Help' ):
                    self.add_button( button, b_sizer, self._on_help )
                elif not self.is_button( button, '' ):
                    self.add_button( button, b_sizer )

            sw_sizer.Add( b_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5 )

        cpanel.SetSizerAndFit( sw_sizer )

    #---------------------------------------------------------------------------
    #  Handles an 'Undo' change request:
    #---------------------------------------------------------------------------

    def _on_undo ( self, event ):
        """ Handles a request to undo a change.
        """
        self.ui.history.undo()

    #---------------------------------------------------------------------------
    #  Handles a 'Redo' change request:
    #---------------------------------------------------------------------------

    def _on_redo ( self, event ):
        """ Handles a request to redo a change.
        """
        self.ui.history.redo()

    #---------------------------------------------------------------------------
    #  Handles a 'Revert' all changes request:
    #---------------------------------------------------------------------------

    def _on_revert ( self, event ):
        """ Handles a request to revert all changes.
        """
        ui = self.ui
        ui.history.revert()
        ui.handler.revert( ui.info )

    #---------------------------------------------------------------------------
    #  Handles the 'Help' button being clicked:
    #---------------------------------------------------------------------------

    def _on_help ( self, event ):
        """ Handles the **Help** button being clicked.
        """
        self.ui.handler.show_help( self.ui.info, event.GetEventObject() )

    #-----------------------------------------------------------------------
    #  Handles the undo history 'undoable' state changing:
    #-----------------------------------------------------------------------

    def _on_undoable ( self, state ):
        """ Handles a change to the "undoable" state of the undo history.
        """
        self.undo.Enable( state )

    #---------------------------------------------------------------------------
    #  Handles the undo history 'redoable' state changing:
    #---------------------------------------------------------------------------

    def _on_redoable ( self, state ):
        """ Handles a change to the "redoable" state of the undo history.
        """
        self.redo.Enable( state )

    #---------------------------------------------------------------------------
    #  Handles the 'revert' state changing:
    #---------------------------------------------------------------------------

    def _on_revertable ( self, state ):
        """ Handles a change to the "revert" state.
        """
        self.revert.Enable( state )

    #---------------------------------------------------------------------------
    #  Adds an optional tool bar to the dialog (base class override):
    #---------------------------------------------------------------------------

    def add_toolbar ( self, sizer ):
        """ Adds an optional toolbar to the dialog.
        """
        toolbar = self.ui.view.toolbar
        if toolbar is not None:
            self._last_group = self._last_parent = None
            sizer.Add( toolbar.create_tool_bar( self.control, self ),
                       0, wx.EXPAND )
            self._last_group = self._last_parent = None

#-------------------------------------------------------------------------------
#  Creates a panel-based wxPython user interface for a specified UI object:
#
#  Note: This version does not modify the UI object passed to it.
#-------------------------------------------------------------------------------

def panel ( ui, parent ):
    """ Creates a panel-based wxPython user interface for a specified UI object.

        This function does not modify the UI object passed to it
    """
    # Bind the context values to the 'info' object:
    ui.info.bind_context()

    # Get the content that will be displayed in the user interface:
    content = ui._groups

    # If there is 0 or 1 Groups in the content, create a single panel for it:
    if len( content ) <= 1:
        panel = TraitsUIPanel( parent, -1 )
        if len( content ) == 1:
            # Fill the panel with the Group's content:
            sg_sizer, resizable, contents = fill_panel_for_group( panel,
                                                                content[0], ui )
            sizer = panel.GetSizer()
            if sizer is not sg_sizer:
                sizer.Add( sg_sizer, 1, wx.EXPAND )

            # Make sure the panel and its contents have been laid out properly:
            sizer.Fit( panel )

        # Return the panel that was created:
        return panel

    # Create a notebook which will contain a page for each group in the content:
    nb    = create_notebook_for_items( content, ui, parent, None )
    nb.ui = ui

    # Notice when the notebook page changes (to display correct help)
    ###wx.EVT_NOTEBOOK_PAGE_CHANGED( parent, nb.GetId(), _page_changed )

    # Return the notebook as the result:
    return nb

#-------------------------------------------------------------------------------
#  Creates a notebook and adds a list of groups or items to it as separate
#  pages:
#-------------------------------------------------------------------------------

def create_notebook_for_items ( content, ui, parent, group,
                                item_handler = None, is_dock_window = False ):
    """ Creates a notebook and adds a list of groups or items to it as separate
        pages.
    """
    if is_dock_window:
        nb = parent
    else:
        dw = DockWindow( parent, handler      = ui.handler,
                                 handler_args = ( ui.info, ),
                                 id           = ui.id )
        if group is not None:
            dw.theme = group.dock_theme
        nb = dw.control
    pages     = []
    count     = 0
    has_theme = ((group is not None) and (group.group_theme is not None))

    # Create a notebook page for each group or item in the content:
    active = 0
    for index, item in enumerate( content ):
        if isinstance( item, Group ):
            # Create the group as a nested DockWindow item:
            if item.selected:
                active = index
            sg_sizer, resizable, contents = \
                fill_panel_for_group( nb, item, ui, suppress_label = True,
                                                    is_dock_window = True )

            # If the result is a region (i.e. notebook) with only one page,
            # collapse it down into just the contents of the region:
            if (isinstance( contents, DockRegion ) and
               (len( contents.contents ) == 1)):
                contents = contents.contents[0]

            # Add the content to the notebook as a new page:
            pages.append( contents )
        else:
            # Create the new page as a simple DockControl containing the
            # specified set of controls:
            page_name = item.get_label( ui )
            count    += 1
            if page_name == '':
               page_name = 'Page %d' % count

            sizer = wx.BoxSizer( wx.VERTICAL )
            if has_theme:
                image_panel, image_sizer = add_image_panel( nb, group )
                panel = image_panel.control
                image_sizer.Add( sizer, 1, wx.EXPAND )
            else:
                panel = TraitsUIPanel( nb, -1 )
                panel.SetSizer( sizer )

            pages.append( DockControl( name     = page_name,
                                       image    = item.image,
                                       id       = item.get_id(),
                                       style    = item.dock,
                                       dockable = DockableViewElement(
                                                      ui = ui, element = item ),
                                       export   = item.export,
                                       control  = panel ) )
            item_handler( item, panel, sizer )
            panel.GetSizer().Fit( panel )

    region = DockRegion( contents = pages, active = active )

    # If the caller is a DockWindow, return the region as the result:
    if is_dock_window:
        return region

    nb.SetSizer( DockSizer( contents = DockSection( contents = [ region ] ) ) )

    # Return the notebook as the result:
    return nb

#-------------------------------------------------------------------------------
#  Creates a themed ImagePanel for the specified group and parent window:
#-------------------------------------------------------------------------------

def add_image_panel ( window, group ):
    """ Creates a themed ImagePanel for the specified group and parent window.
    """
    from image_panel import ImagePanel

    image_panel = ImagePanel( theme = group.group_theme, text = group.label )
    panel       = image_panel.create_control( window )

    return ( image_panel, panel.GetSizer() )

#-------------------------------------------------------------------------------
#  Handles a notebook page being 'turned':
#-------------------------------------------------------------------------------

def _page_changed ( event ):
    nb = event.GetEventObject()
    nb.ui._active_group = event.GetSelection()

#-------------------------------------------------------------------------------
#  Displays a help window for the specified UI's active Group:
#-------------------------------------------------------------------------------

def show_help ( ui, button ):
    """ Displays a help window for the specified UI's active Group.
    """
    group    = ui._groups[ ui._active_group ]
    template = help_template()
    if group.help != '':
        header = template.group_help % escape( group.help )
    else:
        header = template.no_group_help
    fields = []
    for item in group.get_content( False ):
        if not item.is_spacer():
            fields.append( template.item_help % (
                           escape( item.get_label( ui ) ),
                           escape( item.get_help( ui ) ) ) )
    html = template.group_html % ( header, '\n'.join( fields ) )
    HTMLHelpWindow( button, html, .25, .33 )

#-------------------------------------------------------------------------------
#  Displays a pop-up help window for a single trait:
#-------------------------------------------------------------------------------

def show_help_popup ( event ):
    """ Displays a pop-up help window for a single trait.
    """
    control  = event.GetEventObject()
    template = help_template()

    # Note: The following check is necessary because under Linux, we get back
    # a control which does not have the 'help' trait defined (it is the parent
    # of the object with the 'help' trait):
    help = getattr( control, 'help', None )
    if help is not None:
        html = template.item_html % ( control.GetLabel(), help )
        HTMLHelpWindow( control, html, .25, .13 )

#-------------------------------------------------------------------------------
#  Builds the user interface for a specified Group within a specified Panel:
#-------------------------------------------------------------------------------

def fill_panel_for_group ( panel, group, ui, suppress_label = False,
                           is_dock_window = False, create_panel = False ):
    """ Builds the user interface for a specified Group within a specified
        Panel.
    """
    fp = FillPanel( panel, group, ui, suppress_label, is_dock_window,
                    create_panel )
    return ( fp.control or fp.sizer, fp.resizable, fp.dock_contents )

#-------------------------------------------------------------------------------
#  'FillPanel' class:
#-------------------------------------------------------------------------------

class FillPanel ( object ):
    """ A subpanel for a single group of items.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, panel, group, ui, suppress_label, is_dock_window,
                   create_panel ):
        """ Initializes the object.
        """
        # Get the contents of the group:
        content = group.get_content()

        # Create a group editor object if one is needed:
        self.control       = self.sizer = editor = None
        self.ui            = ui
        self.group         = group
        self.is_horizontal = (group.orientation == 'horizontal')
        layout             = group.layout
        is_scrolled_panel  = group.scrollable
        is_splitter        = (layout == 'split')
        is_tabbed          = (layout == 'tabbed')
        id                 = group.id

        # Assume our contents are not resizable:
        self.resizable = False

        if is_dock_window and (is_splitter or is_tabbed):
            if is_splitter:
                self.dock_contents = self.add_dock_window_splitter_items(
                                              panel, content, group )
            else:
                self.resizable     = group.springy
                self.dock_contents = create_notebook_for_items( content, ui,
                                    panel, group, self.add_notebook_item, True )
            return

        theme = group.group_theme
        if (is_dock_window             or
            create_panel               or
            is_scrolled_panel          or
            (id != '')                 or
            (theme is not None)        or
            (group.visible_when != '') or
            (group.enabled_when != '')):
            if theme is not None:
                image_panel, image_sizer = add_image_panel( panel, group )
                new_panel       = image_panel.control
                suppress_label |= image_panel.can_show_text
            elif is_scrolled_panel:
                new_panel = TraitsUIScrolledPanel( panel )
                new_panel.SetMinSize( panel.GetMinSize() )
                self.resizable = True
            else:
                new_panel = TraitsUIPanel( panel, -1 )

            sizer = panel.GetSizer()
            if sizer is None:
                sizer = wx.BoxSizer( wx.VERTICAL )
                panel.SetSizer( sizer )
            self.control = panel = new_panel
            if is_splitter or is_tabbed:
                editor = DockWindowGroupEditor( control = panel, ui = ui )
            else:
                editor = GroupEditor( control = panel )
            if id != '':
                ui.info.bind( group.id, editor )
            if group.visible_when != '':
                ui.add_visible( group.visible_when, editor )
            if group.enabled_when != '':
                ui.add_enabled( group.enabled_when, editor )

        self.panel         = panel
        self.dock_contents = None

        # Determine the horizontal/vertical orientation of the group:
        if self.is_horizontal:
            orientation = wx.HORIZONTAL
        else:
            orientation = wx.VERTICAL

        # Set up a group with or without a border around its contents:
        label = ''
        if not suppress_label:
            label = group.label

        if group.show_border:
            box = wx.StaticBox( panel, -1, label )
            self._set_owner( box, group )
            self.sizer = wx.StaticBoxSizer( box, orientation )
        else:
            if layout == 'flow':
                self.sizer = FlowSizer( orientation )
            else:
                self.sizer = wx.BoxSizer( orientation )
            if label != '':
                self.sizer.Add( heading_text( panel, text = label ).control,
                                0, wx.EXPAND | wx.LEFT | wx.TOP | wx.RIGHT, 4 )

        # If no sizer has been specified for the panel yet, make the new sizer
        # the layout sizer for the panel:
        if panel.GetSizer() is None:
            panel.SetSizer( self.sizer )

        # Set up scrolling now that the sizer has been set:
        if is_scrolled_panel:
            if self.is_horizontal:
                panel.SetupScrolling( scroll_y = False )
            else:
                panel.SetupScrolling( scroll_x = False )

        if is_splitter:
            dw = DockWindow( panel, handler      = ui.handler,
                                    handler_args = ( ui.info, ),
                                    id           = ui.id,
                                    theme        = group.dock_theme ).control
            if editor is not None:
                editor.dock_window = dw

            dw.SetSizer( DockSizer( contents =
                   self.add_dock_window_splitter_items( dw, content, group ) ) )
            self.sizer.Add( dw, 1, wx.EXPAND )
        elif len( content ) > 0:
            if is_tabbed:
                self.resizable = group.springy
                dw = create_notebook_for_items( content, ui, panel, group,
                                                self.add_notebook_item )
                if editor is not None:
                    editor.dock_window = dw

                self.sizer.Add( dw, self.resizable, wx.EXPAND )
            # Check if content is all Group objects:
            elif layout == 'fold':
                self.resizable = True
                self.sizer.Add( self.create_fold_for_items( panel, content ),
                                1, wx.EXPAND )
            elif isinstance( content[0], Group ):
                # If so, add them to the panel and exit:
                self.add_groups( content, panel )
            else:
                self.add_items(content, panel, self.sizer)

        # If the caller is a DockWindow, we need to define the content we are
        # adding to it:
        if is_dock_window:
            self.dock_contents = DockRegion( contents = [
                        DockControl( name     = group.get_label( self.ui ),
                                     image    = group.image,
                                     id       = group.get_id(),
                                     style    = group.dock,
                                     dockable = DockableViewElement(
                                                    ui = ui, element = group ),
                                     export   = group.export,
                                     control  = panel ) ] )

        # If we are using an background image, add the sizer to the image sizer:
        if theme is not None:
            image_sizer.Add( self.sizer, 1, wx.EXPAND )

    #---------------------------------------------------------------------------
    #  Adds a set of groups or items separated by splitter bars to a DockWindow:
    #---------------------------------------------------------------------------

    def add_dock_window_splitter_items ( self, window, content, group ):
        """ Adds a set of groups or items separated by splitter bars to a
            DockWindow.
        """
        contents = [ self.add_dock_window_splitter_item( window, item, group )
                     for item in content ]

        # Create a splitter group to hold the contents:
        result = DockSection( contents = contents, is_row = self.is_horizontal )

        # If nothing is resizable, then mark each DockControl as such:
        if not self.resizable:
            for item in result.get_controls():
                item.resizable = False

        # Return the DockSection we created:
        return result

    #---------------------------------------------------------------------------
    #  Adds a single group or item to a DockWindow:
    #---------------------------------------------------------------------------

    def add_dock_window_splitter_item ( self, window, item, group ):
        """ Adds a single group or item to a DockWindow.
        """
        if isinstance( item, Group ):
            sizer, resizable, contents = fill_panel_for_group( window,
                item, self.ui, suppress_label = True, is_dock_window = True )
            self.resizable |= resizable

            return contents

        orientation = wx.VERTICAL
        if self.is_horizontal:
            orientation = wx.HORIZONTAL
        sizer = wx.BoxSizer( orientation )

        if group.group_theme is not None:
            image_panel, image_sizer = add_image_panel( window, group )
            panel = image_panel.control
            image_sizer.Add( sizer, 1, wx.EXPAND )
        else:
            panel = TraitsUIPanel( window, -1 )
            panel.SetSizer( sizer )

        self.add_items( [ item ], panel, sizer )

        return DockRegion( contents = [
                 DockControl( name     = item.get_label( self.ui ),
                              image    = item.image,
                              id       = item.get_id(),
                              style    = item.dock,
                              dockable = DockableViewElement(
                                             ui = self.ui, element = item ),
                              export   = item.export,
                              control  = panel ) ] )

    #---------------------------------------------------------------------------
    #  Adds a set of groups or items as vertical notebook pages to a vertical
    #  notebook:
    #---------------------------------------------------------------------------

    def create_fold_for_items ( self, window, content ):
        """ Adds a set of groups or items as vertical notebook pages to a
            vertical notebook.
        """
        from themed_vertical_notebook import ThemedVerticalNotebook

        # Create the vertical notebook:
        nb     = ThemedVerticalNotebook( scrollable = True )
        result = nb.create_control( window )

        # Create the notebook pages:
        nb.pages = [ self.create_fold_for_item( nb, item ) for item in content ]

        # Return the notebook we created:
        return result

    #---------------------------------------------------------------------------
    #  Adds a single group or item to a vertical notebook:
    #---------------------------------------------------------------------------

    def create_fold_for_item ( self, notebook, item ):
        """ Adds a single group or item to a vertical notebook.
        """
        # Create a new notebook page:
        page = notebook.create_page()

        # Create the page contents:
        if isinstance( item, Group ):
            panel, resizable, contents = fill_panel_for_group( page.parent,
                item, self.ui, suppress_label = True, create_panel = True )
        else:
            panel = TraitsUIPanel( page.parent, -1 )
            sizer = wx.BoxSizer( wx.VERTICAL )
            panel.SetSizer( sizer )
            self.add_items( [ item ], panel, sizer )

        # Set the page name and control:
        page.name    = item.get_label( self.ui )
        page.control = panel

        # Return the new notebook page:
        return page

    #---------------------------------------------------------------------------
    #  Adds a single Item to a notebook:
    #---------------------------------------------------------------------------

    def add_notebook_item ( self, item, parent, sizer ):
        """ Adds a single Item to a notebook.
        """
        self.add_items( [ item ], parent, sizer )

    #---------------------------------------------------------------------------
    #  Adds a list of Group objects to the panel:
    #---------------------------------------------------------------------------

    def add_groups ( self, content, panel ):
        """ Adds a list of Group objects to the panel.
        """
        sizer = self.sizer

        # Process each group:
        for subgroup in content:
            # Add the sub-group to the panel:
            sg_sizer, sg_resizable, contents = \
                fill_panel_for_group( panel, subgroup, self.ui )

            # If the sub-group is resizable:
            if sg_resizable:

                # Then so are we:
                self.resizable = True

                # Add the sub-group so that it can be resized by the layout:
                sizer.Add( sg_sizer, 1, wx.EXPAND | wx.ALL, 2 )

            else:
                style    = wx.EXPAND | wx.ALL
                growable = 0
                if self.is_horizontal:
                    if subgroup.springy:
                        growable = 1
                    if subgroup.orientation == 'horizontal':
                        style |= wx.ALIGN_CENTER_VERTICAL
                sizer.Add( sg_sizer, growable, style, 2 )

    #---------------------------------------------------------------------------
    #  Adds a list of Item objects to the panel:
    #---------------------------------------------------------------------------

    def add_items ( self, content, panel, sizer ):
        """ Adds a list of Item objects to the panel.
        """
        # Get local references to various objects we need:
        ui      = self.ui
        info    = ui.info
        handler = ui.handler

        group            = self.group
        show_left        = group.show_left
        padding          = group.padding
        col              = -1
        col_incr         = 1
        self.label_flags = 0
        show_labels      = False
        for item in content:
            show_labels |= item.show_label
        if (not self.is_horizontal) and (show_labels or (group.columns > 1)):
            # For a vertical list of Items with labels or multiple columns, use
            # a 'FlexGridSizer':
            self.label_pad = 0
            cols           = group.columns
            if show_labels:
                cols    *= 2
                col_incr = 2
            flags       = wx.TOP | wx.BOTTOM
            border_size = 1
            item_sizer  = wx.FlexGridSizer( 0, cols, 0, 5 )
            if show_left:
                self.label_flags = wx.ALIGN_RIGHT
                if show_labels:
                    for i in range( 1, cols, 2 ):
                        item_sizer.AddGrowableCol( i )
        else:
            # Otherwise, the current sizer will work as is:
            self.label_pad = 4
            cols           = 1
            flags          = wx.ALL
            border_size    = 1
            item_sizer     = sizer

        # Process each Item in the list:
        for item in content:

            # Get the item theme (if any):
            theme = item.item_theme

            # Get the name in order to determine its type:
            name = item.name

            # Check if is a label:
            if name == '':
                label = item.label
                if label != '':
                    # Update the column counter:
                    col += col_incr

                    # If we are building a multi-column layout with labels,
                    # just add space in the next column:
                    if (cols > 1) and show_labels:
                        item_sizer.Add( ( 1, 1 ) )

                    if theme is not None:
                        from image_text import ImageText

                        label = ImageText( panel, theme, label )
                        item_sizer.Add( label, 0, wx.EXPAND )
                    elif item.style == 'simple':
                        # Add a simple text label:
                        label = wx.StaticText( panel, -1, label,
                                               style = wx.ALIGN_LEFT )
                        item_sizer.Add( label, 0, wx.EXPAND )
                    else:
                        # Add the label to the sizer:
                        label = heading_text( panel, text = label ).control
                        item_sizer.Add( label, 0,
                                        wx.TOP | wx.BOTTOM | wx.EXPAND, 3 )

                    if item.emphasized:
                        self._add_emphasis( label )

                # Continue on to the next Item in the list:
                continue

            # Update the column counter:
            col += col_incr

            # Check if it is a separator:
            if name == '_':
                for i in range( cols ):
                    if self.is_horizontal:
                        # Add a vertical separator:
                        line = wx.StaticLine( panel, -1,
                                              style = wx.LI_VERTICAL )
                        item_sizer.Add( line, 0,
                                        wx.LEFT | wx.RIGHT | wx.EXPAND, 2 )
                    else:
                        # Add a horizontal separator:
                        line = wx.StaticLine( panel, -1,
                                              style = wx.LI_HORIZONTAL )
                        item_sizer.Add( line, 0,
                                        wx.TOP | wx.BOTTOM | wx.EXPAND, 2 )
                    self._set_owner( line, item )
                # Continue on to the next Item in the list:
                continue

            # Convert a blank to a 5 pixel spacer:
            if name == ' ':
                name = '5'

            # Check if it is a spacer:
            if all_digits.match( name ):

                # If so, add the appropriate amount of space to the sizer:
                n = int( name )
                if self.is_horizontal:
                    item_sizer.Add( ( n, 1 ) )
                else:
                    spacer = ( 1, n )
                    item_sizer.Add( spacer )
                    if show_labels:
                        item_sizer.Add( spacer )

                # Continue on to the next Item in the list:
                continue

            # Otherwise, it must be a trait Item:
            object = eval( item.object_, globals(), ui.context )
            trait  = object.base_trait( name )
            desc   = trait.desc or ''
            label  = None

            # If we are displaying labels on the left, add the label to the
            # user interface:
            if show_left:
                if item.show_label:
                    label = self.create_label( item, ui, desc, panel,
                                               item_sizer,
                                               border=group.show_border )
                elif (cols > 1) and show_labels:
                    label = self.dummy_label( panel, item_sizer )

            # Get the editor factory associated with the Item:
            editor_factory = item.editor
            if editor_factory is None:
                editor_factory = trait.get_editor()

                # If still no editor factory found, use a default text editor:
                if editor_factory is None:
                    from text_editor import ToolkitEditorFactory
                    editor_factory = ToolkitEditorFactory()

                # If the item has formatting traits set them in the editor
                # factory:
                if item.format_func is not None:
                    editor_factory.format_func = item.format_func

                if item.format_str != '':
                    editor_factory.format_str = item.format_str

                # If the item has an invalid state extended trait name, set it
                # in the editor factory:
                if item.invalid != '':
                    editor_factory.invalid = item.invalid

            # Set up the background image (if used):
            item_panel = panel
            if theme is not None:
                from image_panel import ImagePanel

                text = ''
                if item.show_label:
                    text = item.get_label( ui )
                image_panel = ImagePanel( theme = theme, text = text )
                item_panel  = image_panel.create_control( panel )

            # Create the requested type of editor from the editor factory:
            factory_method = getattr( editor_factory, item.style + '_editor' )
            editor         = factory_method( ui, object, name, item.tooltip,
                                        item_panel ).set(
                                 item        = item,
                                 object_name = item.object )

            # Tell editor to actually build the editing widget:
            editor.prepare( item_panel )

            # Set the initial 'enabled' state of the editor from the factory:
            editor.enabled = editor_factory.enabled

            # Add emphasis to the editor control if requested:
            if item.emphasized:
                self._add_emphasis( editor.control )

            # Give the editor focus if it requested it:
            if item.has_focus:
                editor.control.SetFocus()

            # Adjust the maximum border size based on the editor's settings:
            border_size = min( border_size, editor.border_size )

            # Set up the reference to the correct 'control' to use in the
            # following section, depending upon whether we have wrapped an
            # ImagePanel around the editor control or not:
            control = editor.control
            if theme is None:
                width, height = control.GetSizeTuple()
            else:
                item_panel.GetSizer().Add( control, 1, wx.EXPAND )
                control       = item_panel
                width, height = image_panel.adjusted_size

            # Set the correct size on the control, as specified by the user:
            scrollable  = editor.scrollable
            item_width  = item.width
            item_height = item.height
            growable    = 0
            if (item_width != -1.0) or (item_height != -1.0):
                if (0.0 < item_width <= 1.0) and self.is_horizontal:
                    growable   = int( 1000.0 * item_width )
                    item_width = -1

                item_width = int( item_width )
                if item_width < -1:
                    item_width = -item_width
                elif item_width != -1:
                    item_width = max( item_width, width )

                if (0.0 < item_height <= 1.0) and (not self.is_horizontal):
                    growable    = int( 1000.0 * item_height )
                    item_height = -1

                item_height = int( item_height )
                if item_height < -1:
                    item_height = -item_height
                elif item_height != -1:
                    item_height = max( item_height, height )

                control.SetMinSize( wx.Size( item_width, item_height ) )

            # Bind the item to the control and all of its children:
            self._set_owner( control, item )

            # Bind the editor into the UIInfo object name space so it can be
            # referred to by a Handler while the user interface is active:
            id = item.id or name
            info.bind( id, editor, item.id )

            # Also, add the editors to the list of editors used to construct
            # the user interface:
            ui._editors.append( editor )

            # If the handler wants to be notified when the editor is created,
            # add it to the list of methods to be called when the UI is
            # complete:
            defined = getattr( handler, id + '_defined', None )
            if defined is not None:
                ui.add_defined( defined )

            # If the editor is conditionally visible, add the visibility
            # 'expression' and the editor to the UI object's list of monitored
            # objects:
            if item.visible_when != '':
                ui.add_visible( item.visible_when, editor )

            # If the editor is conditionally enabled, add the enabling
            # 'expression' and the editor to the UI object's list of monitored
            # objects:
            if item.enabled_when != '':
                ui.add_enabled( item.enabled_when, editor )

            # Add the created editor control to the sizer with the appropriate
            # layout flags and values:
            ui._scrollable |= scrollable
            item_resizable  = ((item.resizable is True) or
                               ((item.resizable is Undefined) and scrollable))
            if item_resizable:
                growable = growable or 500
                self.resizable = True
            elif item.springy:
                growable = growable or 500

            # The following is a hack to allow 'readonly' text fields to
            # work correctly (wx has a bug that setting wx.EXPAND on a
            # StaticText control seems to cause the text to be aligned higher
            # than it would be otherwise, causing it to misalign with its
            # label).
            layout_style = editor.layout_style
            if not show_labels:
                layout_style |= wx.EXPAND

            item_sizer.Add( control, growable,
                            flags | layout_style | wx.ALIGN_CENTER_VERTICAL,
                            max( 0, border_size + padding + item.padding ) )

            # If we are displaying labels on the right, add the label to the
            # user interface:
            if not show_left:
                if item.show_label:
                    label = self.create_label( item, ui, desc, panel,
                                               item_sizer, '', wx.RIGHT )
                elif (cols > 1) and show_labels:
                    label = self.dummy_label( panel, item_sizer )

            # If the Item is resizable, and we are using a multi-column grid:
            if item_resizable and (cols > 1):
                # Mark the entire row as growable:
                item_sizer.AddGrowableRow( col / cols )

            # Save the reference to the label control (if any) in the editor:
            editor.label_control = label

        # If we created a grid sizer, add it to the original sizer:
        if item_sizer is not sizer:
            growable = 0
            if self.resizable:
                growable = 1

            sizer.Add( item_sizer, growable, wx.EXPAND | wx.ALL, 2 )

    #---------------------------------------------------------------------------
    #  Creates an item label:
    #---------------------------------------------------------------------------

    def create_label ( self, item, ui, desc, parent, sizer, suffix = ':',
                       pad_side = wx.LEFT, border=False ):
        """ Creates an item label.
        """
        from image_text import ImageText

        label = item.get_label( ui )
        if (label == '') or (label[-1:] in '?=:;,.<>/\\"\'-+#|'):
            suffix = ''

        control = ImageText( parent, item.label_theme, label + suffix,
                             border=border )

        self._set_owner( control, item )

        if item.emphasized:
            self._add_emphasis( control )

        # XXX: Turning off help popups for now
        #wx.EVT_LEFT_UP( control, show_help_popup )

        control.help = item.get_help( ui )
        sizer.Add( control, 0, self.label_flags | wx.ALIGN_CENTER_VERTICAL |
                               pad_side, self.label_pad )

        if desc != '':
            control.SetToolTipString( 'Specifies ' + desc )

        return control

    #---------------------------------------------------------------------------
    #  Creates a dummy item label:
    #---------------------------------------------------------------------------

    def dummy_label ( self, parent, sizer ):
        """ Creates an item label.
        """
        control = wx.StaticText( parent, -1, '', style = wx.ALIGN_RIGHT )
        sizer.Add( control, 0 )
        return control

    #---------------------------------------------------------------------------
    #  Adds 'emphasis' to a specified control:
    #---------------------------------------------------------------------------

    def _add_emphasis ( self, control ):
        """ Adds emphasis to a specified control's font.
        """
        global emphasis_font

        control.SetForegroundColour( emphasis_color )
        if emphasis_font is None:
            font          = control.GetFont()
            emphasis_font = wx.Font( font.GetPointSize() + 1,
                                     font.GetFamily(),
                                     font.GetStyle(),
                                     wx.BOLD )
        control.SetFont( emphasis_font )

    #---------------------------------------------------------------------------
    #  Sets the owner of a specified control and all of its children:
    #---------------------------------------------------------------------------

    def _set_owner ( self, control, owner ):
        control._owner = owner
        for child in control.GetChildren():
            self._set_owner( child, owner )

#-------------------------------------------------------------------------------
#  'DockWindowGroupEditor' class:
#-------------------------------------------------------------------------------

class DockWindowGroupEditor ( GroupEditor ):
    """ Editor for a group which displays a DockWindow.
    """

    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # DockWindow for the group
    dock_window = Instance( wx.Window )

    #-- UI preference save/restore interface -----------------------------------

    #---------------------------------------------------------------------------
    #  Restores any saved user preference information associated with the
    #  editor:
    #---------------------------------------------------------------------------

    def restore_prefs ( self, prefs ):
        """ Restores any saved user preference information associated with the
            editor.
        """
        if isinstance( prefs, dict ):
            structure = prefs.get( 'structure' )
        else:
            structure = prefs
        self.dock_window.GetSizer().SetStructure( self.dock_window, structure )
        self.dock_window.Layout()

    #---------------------------------------------------------------------------
    #  Returns any user preference information associated with the editor:
    #---------------------------------------------------------------------------

    def save_prefs ( self ):
        """ Returns any user preference information associated with the editor.
        """
        return { 'structure': self.dock_window.GetSizer().GetStructure() }

    #-- End UI preference save/restore interface -------------------------------

#-------------------------------------------------------------------------------
#  'HTMLHelpWindow' class:
#-------------------------------------------------------------------------------

class HTMLHelpWindow ( wx.Frame ):
    """ Window for displaying Traits-based help text with HTML formatting.
    """

    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, parent, html, scale_dx, scale_dy ):
        """ Initializes the object.
        """
        wx.Frame.__init__( self, parent, -1, 'Help', style = wx.SIMPLE_BORDER )
        self.SetBackgroundColour( WindowColor )

        # Wrap the dialog around the image button panel:
        sizer        = wx.BoxSizer( wx.VERTICAL )
        html_control = wh.HtmlWindow( self )
        html_control.SetBorders( 2 )
        html_control.SetPage( html )
        sizer.Add( html_control, 1, wx.EXPAND )
        sizer.Add( wx.StaticLine( self, -1 ), 0, wx.EXPAND )
        b_sizer = wx.BoxSizer( wx.HORIZONTAL )
        button  = wx.Button( self, -1, 'OK' )
        wx.EVT_BUTTON( self, button.GetId(), self._on_ok )
        b_sizer.Add( button, 0 )
        sizer.Add( b_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 5 )
        self.SetSizer( sizer )
        self.SetSize( wx.Size( int( scale_dx * screen_dx ),
                               int( scale_dy * screen_dy ) ) )

        # Position and show the dialog:
        position_window( self, parent = parent )
        self.Show()

    #---------------------------------------------------------------------------
    #  Handles the window being closed:
    #---------------------------------------------------------------------------

    def _on_ok ( self, event ):
        """ Handles the window being closed.
        """
        self.Destroy()

#-------------------------------------------------------------------------------
#  Creates a PyFace HeadingText control:
#-------------------------------------------------------------------------------

HeadingText = None

def heading_text ( *args, **kw ):
    """ Creates a PyFace HeadingText control.
    """
    global HeadingText

    if HeadingText is None:
        from pyface.heading_text import HeadingText

    return HeadingText( *args, **kw )


########NEW FILE########
__FILENAME__ = ui_window
#------------------------------------------------------------------------------
#
#  Copyright (c) 2008, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   08/23/2008
#
#------------------------------------------------------------------------------

""" A base class for creating custom Traits UI windows.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx

from traits.api \
    import HasPrivateTraits, Instance, Property

from helper \
    import init_wx_handlers, BufferDC

#-------------------------------------------------------------------------------
#  'UIWindow' class:
#-------------------------------------------------------------------------------

class UIWindow ( HasPrivateTraits ):
    """ A base class for creating custom Traits UI windows.
    """

    # The wx.Window associated with this custom window:
    control = Instance( wx.Window )

    # The initial size of the window:
    size = Instance( wx.Size, ( -1, -1 ) )

    # The current width of the window:
    width = Property

    # The current height of the window:
    height = Property

    #-- Public Methods ---------------------------------------------------------

    def __init__ ( self, parent, **traits ):
        """ Creates and initializes the window.
        """
        super( UIWindow, self ).__init__( **traits )
        self.control = wx.Window( parent, -1,
                                  size  = self.size,
                                  style = wx.FULL_REPAINT_ON_RESIZE )
        init_wx_handlers( self.control, self )

    def refresh ( self, x = None, y = None, dx = None, dy = None ):
        """ Refreshes the contents of the window.
        """
        if self.control is not None:
            if x is None:
                self.control.Refresh()
            else:
                self.control.Refresh( x, y, dx, dy )

    def capture ( self ):
        """ Capture the mouse.
        """
        self.control.CaptureMouse()

    def release ( self ):
        """ Release the mouse.
        """
        self.control.ReleaseMouse()

    #-- wxPython Event Handlers ------------------------------------------------

    def _erase_background ( self, event ):
        """ Never, ever, do anything in this handler.
        """
        pass

    def _paint ( self, event ):
        """ Paints the contents of the window.
        """
        dc = BufferDC( self.control )
        self._paint_dc( dc )
        dc.copy()

    def _paint_dc ( self, dc ):
        """ This method should be overridden by sub-classes to do the actual
            window painting.
        """
        pass

    #-- Property Implementations -----------------------------------------------

    def _get_width ( self ):
        return self.control.GetClientSize()[0]

    def _set_width ( self, width ):
        self.control.SetSize( width, self.height )

    def _get_height ( self ):
        return self.control.GetClientSize()[1]

    def _set_height ( self, height ):
        self.control.SetSize( self.width, height )


########NEW FILE########
__FILENAME__ = ui_wizard
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/01/2004
#
#------------------------------------------------------------------------------

""" Creates a wizard-based wxPython user interface for a specified UI object.

    A wizard is a dialog box that displays a series of pages, which the user
    can navigate with forward and back buttons.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

import wx
import wx.wizard as wz

from constants \
    import DefaultTitle

from helper \
    import restore_window, save_window, GroupEditor

from ui_panel \
    import fill_panel_for_group

from traits.api \
    import Trait, Str

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Trait that allows only None or a string value
none_str_trait = Trait( '', None, str )

#-------------------------------------------------------------------------------
#  Creates a wizard-based wxPython user interface for a specified UI object:
#-------------------------------------------------------------------------------

def ui_wizard ( ui, parent ):
    """ Creates a wizard-based wxPython user interface for a specified UI
    object.
    """
    # Create the copy of the 'context' we will need while editing:
    context     = ui.context
    ui._context = context
    new_context = {}
    for name, value in context.items():
        if value is not None:
            new_context[ name ] = value.clone_traits()
        else:
            new_context[ name ] = None

    ui.context = new_context

    # Now bind the context values to the 'info' object:
    ui.info.bind_context()

    # Create the wxPython wizard window:
    title = ui.view.title
    if title == '':
        title = DefaultTitle
    ui.control = wizard = wz.Wizard( parent, -1, title )

    # Create all of the wizard pages:
    pages        = []
    editor_pages = []
    info         = ui.info
    shadow_group = ui.view.content.get_shadow( ui )
    min_dx = min_dy = 0
    # Create a dictionary mapping each contained group in shadow_group to
    # its id and enabled_when fields.
    group_fields_mapping = {}
    for group in shadow_group.get_content():
        # FIXME: When the group's id or enabled_when or visible_when is
        # set, the "fill_panel_for_group" will create a new Panel to hold the
        # contents of the group (instead of adding them to the page itself).
        # This leads to an incorrect sizing of the panel(not sure why
        # actually): example would be 'test_ui2.py' in
        # Traits/integrationtests/ui. In addition,
        # it leads to incorrect bindings (of the id) on the UIInfo object:
        # the id is bound to the GroupEditor created in "fill_panel.."
        # instead of the PageGroupEditor created here.
        # A simple solution is to clear out these fields before calling
        # "fill_panel_for_group", and then reset these traits.
        group_fields_mapping[group] = (group.id, group.enabled_when)
        (group.id, group.enabled_when) = ('', '')
        page = UIWizardPage( wizard, editor_pages )
        pages.append( page )
        fill_panel_for_group( page, group, ui )

        # Size the page correctly, then calculate cumulative minimum size:
        sizer = page.GetSizer()
        sizer.Fit( page )
        size   = sizer.CalcMin()
        min_dx = max( min_dx, size.GetWidth() )
        min_dy = max( min_dy, size.GetHeight() )

        # If necessary, create a PageGroupEditor and attach it to the right
        # places:
        (group.id, group.enabled_when) = group_fields_mapping[group]
        if group.id or group.enabled_when:
            page.editor = editor = PageGroupEditor( control = page )
            if group.id:
                page.id = group.id
                editor_pages.append( page )
                info.bind( page.id, editor )
            if group.enabled_when:
                ui.add_enabled( group.enabled_when, editor )

    # Size the wizard correctly:
    wizard.SetPageSize( wx.Size( min_dx, min_dy ) )

    # Set up the wizard 'page changing' event handler:
    wz.EVT_WIZARD_PAGE_CHANGING( wizard, wizard.GetId(), page_changing )

    # Size the wizard and the individual pages appropriately:
    prev_page = pages[0]
    wizard.FitToPage( prev_page )

    # Link the pages together:
    for page in pages[1:]:
        page.SetPrev( prev_page )
        prev_page.SetNext( page )
        prev_page = page

    # Finalize the display of the wizard:
    try:
        ui.prepare_ui()
    except:
        ui.control.Destroy()
        ui.control.ui = None
        ui.control    = None
        ui.result     = False
        raise

    # Position the wizard on the display:
    ui.handler.position( ui.info )

    # Restore the user_preference items for the user interface:
    restore_window( ui )

    # Run the wizard:
    if wizard.RunWizard( pages[0] ):
        # If successful, apply the modified context to the original context:
        original = ui._context
        for name, value in ui.context.items():
            if value is not None:
                original[ name ].copy_traits( value )
            else:
                original[ name ] = None
        ui.result = True
    else:
        ui.result = False

    # Clean up loose ends, like restoring the original context:
    save_window( ui )
    ui.finish()
    ui.context  = ui._context
    ui._context = {}

#-------------------------------------------------------------------------------
#  Handles the user attempting to change the current wizard page:
#-------------------------------------------------------------------------------

def page_changing ( event ):
    """ Handles the user attempting to change the current wizard page.
    """
    # Get the page the user is trying to go to:
    page = event.GetPage()
    if event.GetDirection():
       new_page = page.GetNext()
    else:
       new_page = page.GetPrev()

    # If the page has a disabled PageGroupEditor object, veto the page change:
    if ((new_page is not None) and
        (new_page.editor is not None) and
        (not new_page.editor.enabled)):
        event.Veto()

        # If their is a message associated with the editor, display it:
        msg = new_page.editor.msg
        if msg != '':
            wx.MessageBox( msg )

#-------------------------------------------------------------------------------
#  'UIWizardPage' class:
#-------------------------------------------------------------------------------

class UIWizardPage ( wz.PyWizardPage ):
    """ A page within a wizard interface.
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, wizard, pages ):
        wz.PyWizardPage.__init__ ( self, wizard )
        self.next  = self.previous = self.editor = None
        self.pages = pages

    #---------------------------------------------------------------------------
    #  Sets the next page after this one:
    #---------------------------------------------------------------------------

    def SetNext ( self, page ):
        """ Sets the next page after this one.
        """
        self.next = page

    #---------------------------------------------------------------------------
    #  Sets the previous page before this one:
    #---------------------------------------------------------------------------

    def SetPrev ( self, page ):
        """ Sets the previous page to this one.
        """
        self.previous = page

    #---------------------------------------------------------------------------
    #  Returns the next page after this one:
    #---------------------------------------------------------------------------

    def GetNext ( self ):
        """ Returns the next page after this one.
        """
        editor = self.editor
        if (editor is not None) and (editor.next != ''):
            next = editor.next
            if next == None:
                return None
            for page in self.pages:
                if page.id == next:
                    return page
        return self.next

    #---------------------------------------------------------------------------
    #  Returns the previous page before this one:
    #---------------------------------------------------------------------------

    def GetPrev ( self ):
        """ Returns the previous page to this one.
        """
        editor = self.editor
        if (editor is not None) and (editor.previous != ''):
            previous = editor.previous
            if previous is None:
                return None
            for page in self.pages:
                if page.id == previous:
                    return page
        return self.previous

#-------------------------------------------------------------------------------
#  'PageGroupEditor' class:
#-------------------------------------------------------------------------------

class PageGroupEditor ( GroupEditor ):
    """ Editor for a group, which displays a page.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # ID of next page to display
    next     = none_str_trait
    # ID of previous page to display
    previous = none_str_trait
    # Message to display if user can't link to page
    msg      = Str


########NEW FILE########
__FILENAME__ = value_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   01/05/2006
#
#------------------------------------------------------------------------------

""" Defines the tree-based Python value editor and the value editor factory,
    for the wxPython user interface toolkit.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# FIXME: ToolkitEditorFactory is a proxy class defined here just for backward
# compatibility. The class has been moved to the
# traitsui.editors.value_editor file.
from traitsui.editors.value_editor \
    import _ValueEditor, ToolkitEditorFactory

from editor import Editor

class SimpleEditor( _ValueEditor, Editor):
    """ Returns the editor to use for simple style views.
    """

    # Override the value of the readonly trait.
    readonly = False

class ReadonlyEditor( _ValueEditor, Editor):
    """ Returns the editor to use for readonly style views.
    """

    # Override the value of the readonly trait.
    readonly = True

### EOF #######################################################################

########NEW FILE########
__FILENAME__ = view_application
#------------------------------------------------------------------------------
#
#  Copyright (c) 2005, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: David C. Morrill
#  Date:   11/10/2004
#
#------------------------------------------------------------------------------

""" Creates a wxPython specific modal dialog user interface that runs as a
    complete application, using information from the specified UI object.
"""

#-------------------------------------------------------------------------------
#  Imports:
#-------------------------------------------------------------------------------

# Standard library imports.
import os
import sys

# System library imports.
import wx

# ETS imports.
from pyface.util.guisupport import is_event_loop_running_wx, \
    start_event_loop_wx

#-------------------------------------------------------------------------------
#  Constants:
#-------------------------------------------------------------------------------

# File to redirect output to. If '', output goes to stdout.
redirect_filename = ''

KEEP_ALIVE_UIS = set()


def on_ui_destroyed(object, name, old, destroyed):
    """ Remove the UI object from KEEP_ALIVE_UIS.
    """
    assert name == 'destroyed'
    if destroyed:
        assert object in KEEP_ALIVE_UIS
        KEEP_ALIVE_UIS.remove(object)
        object.on_trait_change(on_ui_destroyed, 'destroyed', remove=True)


#-------------------------------------------------------------------------------
#  Creates a 'stand-alone' wx Application to display a specified traits UI View:
#-------------------------------------------------------------------------------

def view_application ( context, view, kind, handler, id, scrollable, args ):
    """ Creates a stand-alone wx Application to display a specified traits UI
        View.

    Parameters
    ----------
    context : object or dictionary
        A single object or a dictionary of string/object pairs, whose trait
        attributes are to be edited. If not specified, the current object is
        used.
    view : view object
        A View object that defines a user interface for editing trait attribute
        values.
    kind : string
        The type of user interface window to create. See the
        **traitsui.view.kind_trait** trait for values and
        their meanings. If *kind* is unspecified or None, the **kind**
        attribute of the View object is used.
    handler : Handler object
        A handler object used for event handling in the dialog box. If
        None, the default handler for Traits UI is used.
    scrollable : Boolean
        Indicates whether the dialog box should be scrollable. When set to
        True, scroll bars appear on the dialog box if it is not large enough
        to display all of the items in the view at one time.
    """
    if (kind == 'panel') or ((kind is None) and (view.kind == 'panel')):
        kind = 'modal'

    app = wx.GetApp()
    if app is None or not is_event_loop_running_wx(app):
        return ViewApplication( context, view, kind, handler, id,
                                scrollable, args ).ui.result

    ui = view.ui( context,
                  kind       = kind,
                  handler    = handler,
                  id         = id,
                  scrollable = scrollable,
                  args       = args )

    # If the UI has not been closed yet, we need to keep a reference to
    # it until it does close.
    if not ui.destroyed:
        KEEP_ALIVE_UIS.add(ui)
        ui.on_trait_change(on_ui_destroyed, 'destroyed')
    return ui.result

#-------------------------------------------------------------------------------
#  'ViewApplication' class:
#-------------------------------------------------------------------------------

class ViewApplication ( wx.App ):
    """ Modal window that contains a stand-alone application.
    """
    #---------------------------------------------------------------------------
    #  Initializes the object:
    #---------------------------------------------------------------------------

    def __init__ ( self, context, view, kind, handler, id, scrollable, args ):
        """ Initializes the object.
        """
        self.context    = context
        self.view       = view
        self.kind       = kind
        self.handler    = handler
        self.id         = id
        self.scrollable = scrollable
        self.args       = args

        if os.environ.get( 'ENABLE_FBI' ) is not None:
            try:
                from etsdevtools.developer.helper.fbi import enable_fbi
                enable_fbi()
            except:
                pass

        if redirect_filename.strip() != '':
            super( ViewApplication, self ).__init__( 1, redirect_filename )
        else:
            super( ViewApplication, self ).__init__(0)

        # Start the event loop in an IPython-conforming manner.
        start_event_loop_wx(self)

    #---------------------------------------------------------------------------
    #  Handles application initialization:
    #---------------------------------------------------------------------------

    def OnInit ( self ):
        """ Handles application initialization.
        """
        self.ui = self.view.ui( self.context,
                                kind       = self.kind,
                                handler    = self.handler,
                                id         = self.id,
                                scrollable = self.scrollable,
                                args       = self.args )
        return True


########NEW FILE########
