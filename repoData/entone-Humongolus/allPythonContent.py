__FILENAME__ = benchmark
"""
python insert 0.205296039581
bare 0.101219892502

python read 0.10541009903
bare 0.0112569332123

pypy insert 0.626013040543
bare 0.136276006699

pypy read 0.326532125473
bare 0.0427839756012
"""


from pymongo.connection import Connection
import logging
import humongolus as orm
import datetime
import time
import humongolus.field as field

conn = Connection()
FORMAT = '%(asctime)-15s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger("humongolus")

orm.settings(logger=logger, db_connection=conn)

class Job(orm.EmbeddedDocument):
	title = field.Char()

class Human(orm.Document):
    _db = "test"
    _collection = "humans"
    name = field.Char(required=True, min=2, max=25)
    age = field.Integer(min=0, max=3000)
    height = field.Float(min=1, max=100000)
    weight = field.Float(min=1, max=30000)
    jobs = orm.List(type=Job)
    genitalia = field.Char()

Human.__remove__()

start = time.time()
for i in xrange(100):
	human = {
		"name":"Chris",
		"age": 31,
		"height":120,
		"weight":180,
		"jobs":[],
		"genitalia":"outy"
	}
	conn['test']['humans'].insert(human, safe=True)
bare = time.time()-start
print bare

Human.__remove__()

orm_start = time.time()
for c in xrange(100):
	human = Human()
	human.name = "Chris"
	human.age = 31
	human.height = 120
	human.weight = 180
	human.genitalia = "outy"
	human.save()
orm_time = time.time()-orm_start
print orm_time

bare_get = time.time()
for c in conn["test"]["humans"].find():
	print "BARE: %s" % c.get("name", None)
bare_finish = time.time()-bare_get
print bare_finish

print "NEXT"

orm_get = time.time()
for c in Human.find():
	print "ORM: %s" % c.name
orm_finish = time.time()-orm_get
print orm_finish

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Humongolus documentation build configuration file, created by
# sphinx-quickstart on Fri Feb 24 18:23:31 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, "../")

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Humongolus'
copyright = u'2012, Christopher Coté'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1'
# The full version, including alpha/beta/rc tags.
release = '0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'humongolusdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'humongolus.tex', u'Humongolus Documentation',
   u'Christopher Coté', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'humongolus', u'Humongolus Documentation',
     [u'Christopher Coté'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'humongolus', u'Humongolus Documentation',
   u'Christopher Coté', 'humongolus', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Humongolus'
epub_author = u'Christopher Coté'
epub_publisher = u'Christopher Coté'
epub_copyright = u'2012, Christopher Coté'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

#epub_tocdup = True
# Allow duplicate toc entries.

########NEW FILE########
__FILENAME__ = app
import sys
sys.path.insert(0, "../")

import os
import humongolus as orm
import tornado.web
import tornado.template
import tornado.httpserver
import json
import objects
import logging
from pymongo.objectid import ObjectId
from pymongo.connection import Connection

class AppHandler(tornado.web.RequestHandler):

    def __init__(self, *args, **kwargs):
        super(AppHandler, self).__init__(*args, **kwargs)

    def get(self, *args, **kwargs):
        
        form = objects.SimpleForm(action="/", id="test")

        form2 = objects.HumanForm(action="/")
        
        return self.render("index.html", form=form, form2=form2)
       
    def post(self, *args, **kwargs):
        context = {"success":False, "data":None, "html":None}
        try:
            submit = json.loads(self.get_argument("form", "{}"))
            print submit
        except Exception as e:
            print e
        else:
            obj = objects.BadHuman()
            form = objects.SimpleForm(object=obj, action="/", id="test", data=submit)
            try:
                form.validate()
                id = obj.save()
                context['data'] = str(id)
                context['success'] = True
            except orm.DocumentException as e:
                context['success'] = False
                obj = {}
                for k,v in e.errors.iteritems():
                    obj[k] = v.message
                context['data'] = obj
            finally:
                context['html'] = self.render_string("form.html", form=form)
                print context
                self.finish(json.dumps(context))

ROOT = os.path.abspath(os.path.dirname(__file__))+"/"

SERVER_SETTINGS = {
    "static_path": ROOT,
}

ROUTES = [
    tornado.web.URLSpec(r"/?", AppHandler, name="App"),
]


TORNADO_APP = tornado.web.Application(ROUTES, **SERVER_SETTINGS)

FORMAT = '%(asctime)-15s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger("humongolus")

orm.settings(logger=logger, db_connection=Connection())

class Server(object):
    def __init__(self, port):
        server = tornado.httpserver.HTTPServer(TORNADO_APP)
        server.bind(port)
        server.start()
        tornado.ioloop.IOLoop.instance().start()

server = Server(port=8888)
########NEW FILE########
__FILENAME__ = objects
import humongolus as orm
import datetime
import humongolus.field as field
import humongolus.widget as widget
from pymongo.connection import Connection

def car_disp(car):
    return {"value":car._id, "display":"%s %s %s" % (car.make, car.model, car.year)}

class Location(orm.EmbeddedDocument):
    city = field.Char(required=True)
    state = field.Char()

class LocationGeo(Location):
    geo = field.Geo()
    active = field.Boolean()

class Job(orm.EmbeddedDocument):
    employer = field.Char()
    title = field.Char(required=True)
    locations = orm.List(type=Location)

class Human(orm.Document):
    _db = "test"
    _collection = "humans"
    _indexes = [
        orm.Index("name", key=[("name", orm.Index.DESCENDING)]), 
        orm.Index("human_id", key=[("human_id", orm.Index.ASCENDING)]),
        orm.Index("geo_location", key=[("jobs.locations.geo", orm.Index.GEO2D)])
    ]
    human_id = field.AutoIncrement(collection="human")
    name = field.Char(required=True, min=2, max=25)
    age = field.Integer(min=0, max=3000)
    height = field.Float(min=1, max=100000)
    weight = field.Float(min=1)
    jobs = orm.List(type=Job, length=3)
    genitalia = field.Char()

class Female(Human):
    genitalia = field.Char(default='inny')

class Male(Human):
    genitalia = field.Char(default='outy')

class Car(orm.Document):
    _db = "test"
    _collection = "cars"
    owner = field.DocumentId(type=Human)
    make = field.Char()
    model = field.Char()
    year = field.Date()

class CarDisplay(orm.Widget):
    #ideally you're using some sort of templating engine, I prefer Mako.
    def render(self, *args, **kwargs):
        return """
                <ul class='%s'>
                    <li>Make: %s</li>
                    <li>Model: %s</li>
                    <li>Year: %s</li>
                </ul>
        """ % (kwargs.get("cls", ""), self.object.make, self.object.model, self.object.year)


class Scion(Car):
    any_owner = field.DynamicDocument()
    color = field.Choice(choices=["Red", "Blue", "Green"])
    make = field.Char(default="Scion")
    model = field.Char(default="xA")
    year = field.Date(default=datetime.datetime(2007, 1, 1))
    silly_date = field.TimeStamp()

class Rodeo(Car):
    tires = orm.List(type=int)


class StateValidator(orm.FieldValidator):

    def validate(self, val, doc=None):
        print "Test!"
        print self.obj._base.__class__.__name__
        if val and not self.obj._parent.country is "USA": raise field.FieldException("Country must be USA to have a state")
        return val

class Address(orm.EmbeddedDocument):
    street = field.Char(required=True)
    zip = field.Char()

class Loca(orm.EmbeddedDocument):
    city = field.Char(required=True)
    address = Address()

class BadHuman(Human):
    unique = field.Integer()
    phone = field.Phone()
    email = field.Email(dbkey="em")
    car = field.ModelChoice(type=Car)
    active = field.Boolean()
    location = Loca()
    avatar = field.File(database=Connection().avatars)

Human.cars = orm.Lazy(type=Car, key='owner')


class AddressForm(widget.FieldSet):
    _fields = ["street", "zip"]

    street = widget.Input(label="Street")
    zip = widget.Input(label="Zip")

class LocationForm(widget.FieldSet):
    _fields = ["city", "address"]

    city = widget.Input(label="City")
    address = AddressForm(label="Address")

class HumanForm(widget.Form):
    #if anyone knows a better way to maintain the order of the fields, please let me know!
    _fields = ["name", "age", "weight", "location"]

    name = widget.Input(label="Name")
    age = widget.Input(label="Age", description="This is today minus the date you were born in seconds.")
    weight = widget.Input(label="Weight")
    location = LocationForm(label="Location")

class SimpleForm(widget.Form):
    _fields = ["name", "age", "phone"]
    name = widget.Input(label="Name")
    age = widget.Input(label="Age", description="This is today minus the date you were born in seconds.")
    phone = widget.Input(label="Phone")



########NEW FILE########
__FILENAME__ = field
import datetime
import re
from humongolus import Field, FieldException, Document, import_class
from bson.objectid import ObjectId
from gridfs import GridFS

class MinException(FieldException): pass
class MaxException(FieldException): pass

def parse_phone(number):
    try:
        phonePattern = re.compile(r'''
                        # don't match beginning of string, number can start anywhere
            (\d{3})     # area code is 3 digits (e.g. '800')
            \D*         # optional separator is any number of non-digits
            (\d{3})     # trunk is 3 digits (e.g. '555')
            \D*         # optional separator
            (\d{4})     # rest of number is 4 digits (e.g. '1212')
            \D*         # optional separator
            (\d*)       # extension is optional and can be any number of digits
            $           # end of string
            ''', re.VERBOSE)
        res = phonePattern.search(number).groups()
        st = "".join(res)
        if st.startswith("1"): return "+%s" % st
        else: return "+1%s" % st
    except Exception as e:
        raise e

class Char(Field):
    _max=None
    _min=None
    _type = unicode
    _exception_display = "string"

    def clean(self, val, doc=None):
        try:            
            val = self._type(val)
            if self._max != None and len(val) > self._max: raise MaxException("must be less than %s" % self._max)
            if self._min != None and len(val) < self._min: raise MinException("must be greater than %s" % self._min)
            return val
        except FieldException as e: raise e
        except: raise FieldException("%s is not a valid %s" % (val, self._exception_display))

class Integer(Char):
    _type=int
    _exception_display ="integer"

    def clean(self, val, doc=None):
        try:
            if val not in [None, False]:
                val = self._type(val)
                if self._max != None and val > self._max: raise MaxException("must be less than %s" % self._max)
                if self._min != None and val < self._min: raise MinException("must be greater than %s" % self._min)
            return val
        except FieldException as e: raise e
        except: raise FieldException("%s is not a valid %s" % (val, self._exception_display))

class Float(Integer):
    _type=float
    _exception_display ="float"

class Date(Field):

    def clean(self, val, doc=None):
        try:
            if isinstance(val, datetime.datetime): return val
            return datetime.datetime(val)
        except: raise FieldException("%s: invalid datetime" % val)


class Boolean(Field):
    _default = False
    def clean(self, val, doc=None):
        try:
            if isinstance(val, bool): return val
            v = bool(val)
            return bool(val)
        except: raise FieldException("%s invalid boolean" % val)

class Geo(Field):
    def clean(self, val, doc=None):
        try:
            if isinstance(val, list):
                if len(val) == 2:
                    return val
                else: raise FieldException("to many values: %s" % val)
            else: raise FieldException("must be type array")
        except: raise FieldException("%s must be array" % val)

class TimeStamp(Date):

    def _save(self, namespace):
        if self._value == None:
            self._value = datetime.datetime.utcnow()
        
        return super(TimeStamp, self)._save(namespace)

class DocumentId(Field):
    _type = None

    def clean(self, val, doc=None):
        v = val._id if hasattr(val, '_id') else val
        if hasattr(val, '_id') and not val._id:
            raise FieldException("Object has not been saved yet")
        if v:
            try:
                v = ObjectId(v)
            except Exception as e:
                raise FieldException("Invalid ObjectId")
        return v
    
    def __call__(self):
        if not self._value is None and self._type:
            return self._type(id=self._value)
        else: raise FieldException("Cannot instantiate %s with id %s" % (self._type, self._value))


class AutoIncrement(Integer):
    _collection = None

    def _save(self, namespace):
        if self._value == None:
            col = self._collection if self._collection else "sequence"
            res = self._conn["auto_increment"][col].find_and_modify({"field":self._name}, {"$inc":{"val":1}}, upsert=True, new=True, fields={"val":True})
            self._value = res['val']
        
        return super(AutoIncrement, self)._save(namespace)

class DynamicDocument(Field):

    def clean(self, val, doc=None):
        if isinstance(val, Document):
            if val._id != None:
                cls = "%s.%s" % (val.__module__, val.__class__.__name__)
                return {"cls":cls, "id":val._id}
            else: raise FieldException("Document does not have an id. Be sure to save first.")
        elif isinstance(val, dict): 
            return val
        else: raise FieldException("%s is not a valid document type" % val.__class__.__name__)
    
    def __call__(self):
        if isinstance(self._value, dict):
            cls = import_class(self._value['cls'])
            return cls(id=self._value['id'])
        else: raise Exception("Bad Value: %s" % self._value)


class Choice(Char):
    _choices = []

    def clean(self, val, doc=None):
        val = super(Choice, self).clean(val, doc=doc)
        vals = [opt['value'] if isinstance(opt, dict) else opt for opt in self._choices]
        if not val in vals: raise FieldException("%s is not a valid option")
        return val

    def get_choices(self, render=None):
        return self._choices

class ModelChoice(DocumentId):
    _type = None
    _render = None
    _fields = None
    _query = {}
    _sort = {}

    def get_choices(self, render=None):
        if render:
            cur = self._type.find(self._query, fields=self._fields)
            cur = cur.sort(self._sort) if self._sort else cur
            return [render(i) for i in cur]
        else: raise FieldException("no render method available")

class CollectionChoice(Choice):
    _db = None
    _collection = None
    _render = None
    _fields = None
    _query = {}
    _sort = {}

    def get_choices(self, render=None):
        if render:
            cur = self._conn[self._db][self._collection].find(self._query, fields=self._fields)
            cur = cur.sort(self._sort) if self._sort else cur
            return [render(i) for i in cur]
        else: raise FieldException("no render method available")
        
class Regex(Char):
    _reg = None
    _disp_error = None

    def clean(self, val, doc=None):
        val = super(Regex, self).clean(val, doc)
        if not self._reg.search(val): raise FieldException("%s: pattern not found" % val if not self._disp_error else self._disp_error)
        return val

class Email(Regex):
    _disp_error = "Invalid Email Address"
    _reg = re.compile(
    r"(^[-!#$%&'*/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*/=?^_`{}|~0-9A-Z]+)*"  # dot-atom
    r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-011\013\014\016-\177])*"' # quoted-string
    r')@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}$', re.IGNORECASE)  # domain

class Phone(Char):

    def clean(self, val, doc=None):
        val = super(Phone, self).clean(val, doc)
        try:
            return parse_phone(val)
        except: raise FieldException("%s is not a valid format" % val)

class File(DocumentId):
    _database = None
    _collection = "fs"
    _args = {}

    def clean(self, val, doc=None):
        if not self._database: raise FieldException("database is required")
        if isinstance(val, ObjectId): return val
        try:
            f = GridFS(self._database, collection=self._collection)
            self._args["filename"] = self._args.get("filename", self._name)
            return f.put(val, **self._args)
        except Exception as e:
            raise FieldException(e.message)

    def exists(self):
        f = GridFS(self._database, collection=self._collection)
        return f.exists(self._value)

    def delete(self):
        f = GridFS(self._database, collection=self._collection)
        return f.delete(self._value)

    def __call__(self):
        if isinstance(self._value, ObjectId):
            f = GridFS(self._database, collection=self._collection)
            return f.get(self._value)
        else:
            raise FieldException("No file associated")

    def __getattr__(self, key):
        f = GridFS(self._database, collection=self._collection)
        return getattr(f, key)






########NEW FILE########
__FILENAME__ = mongo
from pymongo import collection
from pymongo import cursor


class Cursor(cursor.Cursor):    

    def __init__(self, *args, **kwargs):
        self._class = kwargs.pop("my_class")
        self._as_dict = kwargs.pop("as_dict", None)
        super(Cursor, self).__init__(*args, **kwargs)

    def __getitem__(self, *args, **kwargs):
        obj = super(Cursor, self).__getitem__(*args, **kwargs)
        if isinstance(obj, dict): return self._class(data=obj)
        return obj

    def next(self, *args, **kwargs):
        obj = super(Cursor, self).next(*args, **kwargs)
        if self._as_dict: return obj
        return self._class(data=obj)

class Collection(collection.Collection):

    def __init__(self, my_class, *args, **kwargs):
        self._class = my_class        
        super(Collection, self).__init__(*args, **kwargs)

    def find(self, *args, **kwargs):
        self._as_dict = kwargs.pop("as_dict", None)
        if not 'slave_okay' in kwargs:
            kwargs['slave_okay'] = self.slave_okay
        if not 'read_preference' in kwargs:
            kwargs['read_preference'] = self.read_preference
        if not 'tag_sets' in kwargs:
            kwargs['tag_sets'] = self.tag_sets
        if not 'secondary_acceptable_latency_ms' in kwargs:
            kwargs['secondary_acceptable_latency_ms'] = (
                self.secondary_acceptable_latency_ms)
        return Cursor(self, my_class=self._class, as_dict=self._as_dict, *args, **kwargs)

########NEW FILE########
__FILENAME__ = settings
LOGGER=None
DB_CONNECTION=None
########NEW FILE########
__FILENAME__ = widget
import copy
from humongolus import Widget, Field, Document, EmbeddedDocument, Lazy, List, DocumentException, EMPTY

def escape(s):
    orig = copy.copy(s)
    try:
        s = unicode(s)
        return s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&#39;')
    except: return orig

class HTMLElement(Widget):
    _type = "text"
    _tag = "input"
    _fields = []


    def render_fields(self, namespace=None, **kwargs):
        parts = []
        for fi in self._fields:
            try:
                i = self.__dict__[fi]
                ns = "-".join([namespace, i.attributes._name]) if namespace else i.attributes._name
                if kwargs.get("render_labels", None):
                    label = "%s_%s" % (self.attributes.prepend, ns) if self.attributes.prepend else ns 
                    if i.attributes.label: parts.append(self.render_label(label, i.attributes.label))
                a = i.render(namespace=ns, **kwargs)
                if isinstance(a, list): parts.extend(a)
                else: parts.append(a)
            except Exception as e:
                print e
                pass
        
        return parts

    def render_label(self, name, label):
        return "<label for='%s'>%s</label>" % (name, label)

    def label_tag(self):
        return self.render_label(self.attributes.name, self.attributes.label)

    def compile_tag(self, obj, close=True):
        atts = ["<%s" % obj.pop("tag", "input")]
        obj.update(obj.pop("extra", {}))
        for k,v in obj.iteritems():
            if v in EMPTY: continue
            v = v if isinstance(v, list) else [v]
            atts.append(u"%s='%s'" % (k, u" ".join([escape(val) for val in v])))
        
        atts.append("/>" if close else ">")
        return u" ".join(atts)

    def __iter__(self):
        for fi in self._fields:
            v = self.__dict__[fi]
            yield v

class Input(HTMLElement):
    
    def render(self, *args, **kwargs):
        self._type = kwargs.get("type", self._type)
        self.attributes._name = kwargs.get("namespace", self.attributes._name)
        self.attributes._id = kwargs.get("id", "id_%s"%self.attributes._name)
        self.attributes.value = kwargs.get("value", self.object.__repr__())
        self.attributes.description = kwargs.get("description", self.attributes.description)
        self.attributes.cls = kwargs.get("cls", self.attributes.cls)
        self.attributes.label = kwargs.get("label", self.attributes.label)
        self.attributes.extra = kwargs.get("extra", self.attributes.extra)
        obj = {
            "tag":self._tag,
            "type":self._type,
            "id":self.attributes.id,
            "name":self.attributes.name,
            "value":self.attributes.value,
            "class":self.attributes.cls,
            "extra":self.attributes.extra
        }
        return self.compile_tag(obj)

class Password(Input):
    _type = "password"

class CheckBox(Input):
    _type = "checkbox"

    def render(self, *args, **kwargs):
        extra = {"checked":'CHECKED'} if self.object._value else {}
        kwargs["extra"] = extra
        kwargs["value"] = self.attributes._name
        return super(CheckBox, self).render(*args, **kwargs)

class Select(Input):

    def render(self, *args, **kwargs):
        val = super(Select, self).render(*args, **kwargs)
        obj = {
            "tag":"select",
            "id":self.attributes.id,
            "name":self.attributes.name,
            "class":self.attributes.cls,
            "extra":self.attributes.extra
        }
        st = self.compile_tag(obj, close=False)
        ch = []
        for i in self.object.get_choices(render=self.attributes.item_render):
            val = i['value'] if isinstance(i, dict) else i
            display = i['display'] if isinstance(i, dict) else i
            sel = "selected='SELECTED'" if val == self.object._value else ""
            ch.append("<option value='%s' %s>%s</option>" % (val, sel, display))
        
        return "%s%s</select>" % (st, "".join(ch))

class MultipleSelect(Input):

    def render(self, *args, **kwargs):
        val = super(MultipleSelect, self).render(*args, **kwargs)
        obj = {
            "tag":"select",
            "id":self.attributes.id,
            "name":self.attributes.name,
            "class":self.attributes.cls,
            "extra":self.attributes.extra
        }
        st = self.compile_tag(obj, close=False)
        ch = []
        for i in self.object.get_choices(render=self.attributes.item_render):
            val = i['value'] if isinstance(i, dict) else i
            display = i['display'] if isinstance(i, dict) else i
            sel = "selected='SELECTED'" if val in self.object else ""
            ch.append("<option value='%s' %s>%s</option>" % (val, sel, display))
        
        return "%s%s</select>" % (st, "".join(ch))


class TextArea(Input):

    def render(self, *args, **kwargs):
        val = super(TextArea, self).render(*args, **kwargs)
        obj = {
            "tag":"textarea",
            "id":self.attributes.id,
            "name":self.attributes.name,
            "class":self.attributes.cls,
            "cols":self.attributes.cols,
            "rows":self.attributes.rows,
            "extra":self.attributes.extra
        }
        st = self.compile_tag(obj, close=False)
        return "%s%s</textarea>" % (st, self.attributes.value if self.attributes.value else "")

    
class FieldSet(HTMLElement):

    def render(self, *args, **kwargs):
        val = super(FieldSet, self).render(*args, **kwargs)
        parts = []
        obj = {
            "tag":"fieldset",
            "id":self.attributes.id,
            "name":self.attributes.name,
            "cls":self.attributes.cls,
            "extra":self.attributes.extra
        }
        st = self.compile_tag(obj, close=False)
        ns = kwargs.pop('namespace', None)
        parts.append(st)
        parts.extend(self.render_fields(namespace=ns, **kwargs))
        parts.append("</fieldset>")
        return parts

class Form(HTMLElement):
    #Attributes
    errors = {}
        
    def render(self, *args, **kwargs):
        val = super(Form, self).render(*args, **kwargs)
        parts = []
        obj = {
            "tag":"form",
            "id":self.attributes.id,
            "name":self.attributes.name,
            "class":self.attributes.cls,
            "action":self.attributes.action,
            "method":self.attributes.method,
            "type":self.attributes.type,
            "extra":self.attributes.extra
        }
        st = self.compile_tag(obj, close=False)
        parts.append(st)
        parts.extend(self.render_fields(**kwargs))
        parts.append(self.submit())
        parts.append("</form>")
        return "".join(parts)

    def parse_data(self, data):
        obj = {}
        for k,v in data.iteritems():
            key = k[len(self._prepend)+1:] if self._prepend else k
            parts = key.split('-')
            branch = obj
            for part in parts[0:-1]:
                branch = branch.setdefault(part, {})
        
            branch[parts[-1]] = v
        
        return obj

    def validate(self):
        if self._data: 
            obj = self.parse_data(self._data)
            print obj
            self.object._map(obj)
            errors = self.object._errors()
            if len(errors.keys()):
                for k,v in errors.iteritems():
                    try:
                        self.__dict__[k].errors.append(v)
                    except: pass
                self.errors = errors
                raise DocumentException(errors=errors)

    def submit(self):
        return "<input type='submit' value='submit' />"
########NEW FILE########
__FILENAME__ = run_tests
import unittest
import tests

unittest.TextTestRunner(verbosity=2).run(tests.suite())
########NEW FILE########
__FILENAME__ = test
from pymongo.connection import Connection
import logging
import humongolus as orm
import datetime
import humongolus.field as field
import humongolus.widget as widget
from tests.states import states

conn = Connection()
FORMAT = '%(asctime)-15s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger("humongolus")

orm.settings(logger=logger, db_connection=conn)

class Car(orm.Document):
    _db = "test"
    _collection = "cars"
    owner = field.DynamicDocument()
    make = field.Char()
    model = field.Char()
    year = field.Date()
    silly_date = field.TimeStamp()

Car.__remove__()

class Address(orm.EmbeddedDocument):
    street = field.Char()
    street2 = field.Char()
    zip = field.Char()


class Location(orm.EmbeddedDocument):
    city = field.Char(required=True)
    state = field.Char()
    address = Address()

class Job(orm.EmbeddedDocument):
    employer = field.Char()
    title = field.Char(required=True)
    locations = orm.List(type=Location)


class Human(orm.Document):
    _db = "test"
    _collection = "humans"
    human_id = field.AutoIncrement(collection="human")
    name = field.Char(required=True, min=2, max=25)
    age = field.Integer(required=True, min=0, max=3000)
    height = field.Float(min=1, max=100000)
    weight = field.Float(min=1, max=30000)
    jobs = orm.List(type=Job)
    genitalia = field.Char()
    location = Location()
    car = field.ModelChoice(type=Car)
    color = field.Choice(choices=[{'value':'red', 'display':'Red'},{'value':'blue', 'display':'Blue'},{'value':'green', 'display':'Green'}])
    state = field.CollectionChoice(db='test', collection='states', sort=[('fullname',1)])
    email = field.Email()

class Female(Human):
    genitalia = field.Char(default='inny')

class Male(Human):
    genitalia = field.Char(default='outy')
    
class CarDisplay(orm.Widget):
    #ideally you're using some sort of templating engine, I prefer Mako.
    def render(self, *args, **kwargs):
        return """
                <ul class='%s'>
                    <li>Make: %s</li>
                    <li>Model: %s</li>
                    <li>Year: %s</li>
                </ul>
        """ % (kwargs.get("cls", ""), self._object.make, self._object.model, self._object.year)

Human.cars = orm.Lazy(type=Car, key='owner._id')

chris = Male()
chris.name = "Chris"
chris.age = 31
chris.height = 100
chris.weight = 180
chris.location.city = "Chicago"
chris.location.state = "IL"
chris.location.address.zip = 60626

job = Job()
job.employer = "Entropealabs"
job.title = "President"

loc = Location()
loc.city = "Chicago"
loc.state = "IL"

job.locations.append(loc)
chris.jobs.append(job)

print chris._json()

_id = chris.save()

print _id

car = Car()
car.owner = chris
car.make = "Isuzu"
car.model = "Rodeo"
car.year = datetime.datetime(1998, 1, 1)
print car
c_id = car.save()

car2 = Car()
car2.owner = chris
car2.make = "Mercedes"
car2.model = "Baby C"
car2.year = datetime.datetime(1965, 1, 1)
print car2
c_id = car2.save()

print car._get("owner")().name


def car_disp(car):
    return {"value":car._id, "display":"%s %s %s" % (car.make, car.model, car.year)}

def coll_display(doc):
    return {'value':doc.get('abbrv'), 'display':doc.get('fullname', None)}

def job_list(obj):
    ar = []
    for i in obj:
        ar.append({"value":i.title, "display":"%s: %s" % (i.employer, i.title)})
    return ar

class AddressForm(widget.FieldSet):
    _fields = ["street", "street2", "zip"]

    street = widget.Input(cls="woot")
    street2 = widget.TextArea(cls='test', rows=100, cols=30)
    zip = widget.Input()

class LocationForm(widget.FieldSet):
    _fields = ["city", "state", "address"]
    cls = "location"

    city = widget.Input()
    state = widget.Input()
    address = AddressForm()

class PersonForm(widget.Form):
    action = '/save_person'
    id = "person_%s" % chris._id
    _prepend = "test"
    #if anyone knows a better way to maintain the order of the fields, please let me know!
    _fields = ["human_id", "name", "age", "car", "location", "jobs", "email"]

    human_id = widget.Input(label="ID")
    name = widget.Input(label="Name")
    age = widget.Input(label="Age", description="This is today minus the date you were born in seconds.")
    car = widget.Select(label="Car", item_render=car_disp)
    location = LocationForm(label="Location")
    jobs = widget.MultipleSelect(label="Jobs", item_render=job_list)
    email = widget.Input(label="Email")

submit = {
    "test_name":"None",
    "test_human_id":"32226",
    "test_age":None,
    "test_weight":"175",
    "test_car":"ffed81a42000002",
    "test_location-city":"Chicago",
    "test_location-state":"IL",
    "test_location-address-street":"549 Randolph",
    "test_location-address-street2":"450",
    #"location-address-zip":"60626"
}

print states
conn['test']['states'].remove()
for k,v in states.iteritems():
    conn['test']['states'].insert({"abbrv":k, 'fullname':v})
    

class SelectorForm(widget.Form):
    _fields = ['car', 'color', 'state']
    car = widget.Select(label="Car", item_render=car_disp)
    color = widget.Select(label="Color")
    state = widget.Select(label="State", item_render=coll_display)

print "SELECTS:"

a = SelectorForm(object=chris)
print a.render()

form = PersonForm(object=chris, data=submit)

print form.car.render(cls="try-this")

print form.render()

try:
    form.validate()
    print "Validated"
except orm.DocumentException as e:
    print e
    for f in form:
        if f.errors:
            print f.attributes.name
            if f.attributes.description: print f.attributes.description
            print f.errors
    
    print form.errors
    print e.errors
except Exception as e:
    print e

form2 = PersonForm(object=Human(), prepend=None)

print form2.render()
########NEW FILE########
__FILENAME__ = objects
import humongolus as orm
import datetime
import humongolus.field as field
import humongolus.widget as widget
from pymongo.connection import Connection

def car_disp(car):
    return {"value":car._id, "display":"%s %s %s" % (car.make, car.model, car.year)}

class Location(orm.EmbeddedDocument):
    city = field.Char(required=True)
    state = field.Char()

class LocationGeo(Location):
    geo = field.Geo()
    active = field.Boolean()

class Job(orm.EmbeddedDocument):
    employer = field.Char()
    title = field.Char(required=True)
    locations = orm.List(type=Location)

class Human(orm.Document):
    _db = "test"
    _collection = "humans"
    _indexes = [
        orm.Index("name", key=[("name", orm.Index.DESCENDING)]), 
        orm.Index("human_id", key=[("human_id", orm.Index.ASCENDING)]),
        orm.Index("geo_location", key=[("jobs.locations.geo", orm.Index.GEO2D)])
    ]
    human_id = field.AutoIncrement(collection="human")
    name = field.Char(required=True, min=2, max=25)
    age = field.Integer(min=0, max=3000)
    height = field.Float(min=1, max=100000)
    weight = field.Float(min=1)
    jobs = orm.List(type=Job, length=3)
    genitalia = field.Char()

class Female(Human):
    genitalia = field.Char(default='inny')

class Male(Human):
    genitalia = field.Char(default='outy')

class Property(orm.EmbeddedDocument):
    name = field.Char()
    value = field.Char()

class Car(orm.Document):
    _db = "test"
    _collection = "cars"
    owner = field.DocumentId(type=Human)
    make = field.Char()
    model = field.Char()
    year = field.Date()
    features = orm.List(type=unicode)
    properties = orm.List(type=Property)


class CarDisplay(orm.Widget):
    #ideally you're using some sort of templating engine, I prefer Mako.
    def render(self, *args, **kwargs):
        return """
                <ul class='%s'>
                    <li>Make: %s</li>
                    <li>Model: %s</li>
                    <li>Year: %s</li>
                </ul>
        """ % (kwargs.get("cls", ""), self.object.make, self.object.model, self.object.year)


class Scion(Car):
    any_owner = field.DynamicDocument()
    color = field.Choice(choices=["Red", "Blue", "Green"])
    make = field.Char(default="Scion")
    model = field.Char(default="xA")
    year = field.Date(default=datetime.datetime(2007, 1, 1))
    silly_date = field.TimeStamp()

class Rodeo(Car):
    tires = orm.List(type=int)


class StateValidator(orm.FieldValidator):

    def validate(self, val, doc=None):
        print "Test!"
        print self.obj._base.__class__.__name__
        if val and not self.obj._parent.country is "USA": raise field.FieldException("Country must be USA to have a state")
        return val

class Loca(orm.EmbeddedDocument):
    city = field.Char()


class BadHuman(Human):
    unique = field.Integer()
    phone = field.Phone()
    email = field.Email(dbkey="em")
    car = field.ModelChoice(type=Car)
    active = field.Boolean()
    state = field.Char(validate=StateValidator)
    country = field.Char(validate=orm.FieldValidator)
    location = Loca()
    avatar = field.File(database=Connection().avatars)

Human.cars = orm.Lazy(type=Car, key='owner')


class AddressForm(widget.FieldSet):
    _fields = ["street", "street2", "zip"]

    street = widget.Input()
    street2 = widget.TextArea(cls="Woot", rows=10, cols=30)
    zip = widget.Input()

class LocationForm(widget.FieldSet):
    _fields = ["city"]
    _cls = "location"

    city = widget.Input()

class PersonForm(widget.Form):
    _action = '/save_person'
    _id = "person_woot"
    #if anyone knows a better way to maintain the order of the fields, please let me know!
    _fields = ["human_id", "name", "age", "location"]

    human_id = widget.Input(label="ID")
    name = widget.Input(label="Name")
    age = widget.Input(label="Age", description="This is today minus the date you were born in seconds.")
    location = LocationForm(label="Location")

########NEW FILE########
__FILENAME__ = states
states = {
        'AK': 'Alaska',
        'AL': 'Alabama',
        'AR': 'Arkansas',
        'AS': 'American Samoa',
        'AZ': 'Arizona',
        'CA': 'California',
        'CO': 'Colorado',
        'CT': 'Connecticut',
        'DC': 'District of Columbia',
        'DE': 'Delaware',
        'FL': 'Florida',
        'GA': 'Georgia',
        'GU': 'Guam',
        'HI': 'Hawaii',
        'IA': 'Iowa',
        'ID': 'Idaho',
        'IL': 'Illinois',
        'IN': 'Indiana',
        'KS': 'Kansas',
        'KY': 'Kentucky',
        'LA': 'Louisiana',
        'MA': 'Massachusetts',
        'MD': 'Maryland',
        'ME': 'Maine',
        'MI': 'Michigan',
        'MN': 'Minnesota',
        'MO': 'Missouri',
        'MP': 'Northern Mariana Islands',
        'MS': 'Mississippi',
        'MT': 'Montana',
        'NA': 'National',
        'NC': 'North Carolina',
        'ND': 'North Dakota',
        'NE': 'Nebraska',
        'NH': 'New Hampshire',
        'NJ': 'New Jersey',
        'NM': 'New Mexico',
        'NV': 'Nevada',
        'NY': 'New York',
        'OH': 'Ohio',
        'OK': 'Oklahoma',
        'OR': 'Oregon',
        'PA': 'Pennsylvania',
        'PR': 'Puerto Rico',
        'RI': 'Rhode Island',
        'SC': 'South Carolina',
        'SD': 'South Dakota',
        'TN': 'Tennessee',
        'TX': 'Texas',
        'UT': 'Utah',
        'VA': 'Virginia',
        'VI': 'Virgin Islands',
        'VT': 'Vermont',
        'WA': 'Washington',
        'WI': 'Wisconsin',
        'WV': 'West Virginia',
        'WY': 'Wyoming'
}
########NEW FILE########
__FILENAME__ = test_field
import sys
if sys.version_info < (2,7):
    import unittest2 as unittest
else:
    import unittest
import datetime
import objects
import os
from pymongo.connection import Connection
import logging
import humongolus as orm
import humongolus.widget as widget
from humongolus.field import FieldException

conn = Connection()
FORMAT = '%(asctime)-15s %(message)s'
logging.basicConfig(format=FORMAT, level=logging.DEBUG)
logger = logging.getLogger("humongolus")

orm.settings(logger=logger, db_connection=conn)

class Field(unittest.TestCase):

    def setUp(self):
        self.name = "Anne"
        self.genitalia = "inny"
        self.obj = objects.Female()
        self.job = objects.Job()
        self.loca = objects.LocationGeo()
        self.location = objects.Location()
    
    def test_validation(self):
        obj = objects.BadHuman()
        obj.state = "Illinois"
        with self.assertRaises(orm.DocumentException) as cm:
            obj.save()
        
        obj.country = "USA"
        obj.state = "Illinois"

    def test_default(self):
        self.assertEqual(self.obj.genitalia, self.genitalia)

    def test_field_set(self):
        self.obj.name = self.name
        self.assertEqual(self.obj.name, self.name)
    
    def test_required(self):
        self.obj.name = None
        with self.assertRaises(orm.DocumentException) as cm:
            self.obj.save()
    
    def test_embedded_required(self):
        self.obj.name = ""
        job = self.job
        job.title = ""
        location = self.location
        location.city = ""
        job.locations.append(location)
        self.obj.jobs.append(job)
        self.obj.name = self.name
        with self.assertRaises(orm.DocumentException) as cm:
            self.obj.save()
    
    def test_char(self):
        self.obj.name = "Anne"
        self.assertEqual(self.obj.name, "Anne")

        self.obj.name = "A"
        self.assertEqual(self.obj._get("name")._error.__class__.__name__, "MinException")

        self.obj.name = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        self.assertEqual(self.obj._get("name")._error.__class__.__name__, "MaxException")        

    def test_integer(self):

        self.obj.age = 27
        self.assertEqual(self.obj.age, 27)

        self.obj.age = -10
        self.assertEqual(self.obj._get("age")._error.__class__.__name__, "MinException")

        self.obj.age = 3001
        self.assertEqual(self.obj._get("age")._error.__class__.__name__, "MaxException")
    
    def test_float(self):

        self.obj.height = 100
        self.assertEqual(self.obj.height, 100.0)

        self.obj.height = -10
        self.assertEqual(self.obj._get("height")._error.__class__.__name__, "MinException")

        self.obj.height = 99999999
        self.assertEqual(self.obj._get("height")._error.__class__.__name__, "MaxException")

    def test_autoincrement(self):
        last_val = conn["auto_increment"]["human"].find_one({"field":"human_id"}, fields={"val":True})
        last_val = last_val["val"] if last_val else 0
        self.obj.name = self.name
        _id = self.obj.save()
        obj = objects.Female(id=_id)
        new_val = last_val+1
        self.assertEqual(obj.human_id, new_val)
        n = "%s%s" % (self.name, new_val)
        obj.name = n
        try:
            obj.save()
        except Exception as e:
            print e
        n_obj = objects.Female(id=_id)
        self.assertEqual(n_obj.human_id, new_val)
        self.assertEqual(n_obj.name, n)
    
    def test_dynamic_document(self):
        self.obj.name = self.name
        _id = self.obj.save()
        scion = objects.Scion()
        scion.any_owner = self.obj
        s_id = scion.save()
        n_scion = objects.Scion(id=s_id)
        p = n_scion._get("any_owner")()
        self.assertEqual(p._id, _id)
        car3 = objects.Scion()
        car3.any_owner = objects.Female()
        with self.assertRaises(orm.DocumentException) as cm:
            car3.save()
            print cm.exception.errors
        
        with self.assertRaises(Exception) as cm:
            car3._get("any_owner")()

    
    def compare_date(self, date1, date2):
        #mongo doesn't support the same date precision as python, gotta chop off a few microseconds
        diff = date1-date2
        self.assertLess(diff.microseconds, 1000)

    def test_timestamp(self): 
        obj = objects.Scion()
        _id = obj.save()
        timestamp = obj.silly_date
        obj2 = objects.Scion(id=_id)
        self.compare_date(timestamp, obj2.silly_date)

    def test_date(self):
        now = datetime.datetime.utcnow()
        obj = objects.Scion()
        obj.year = now
        _id = obj.save()
        obj2 = objects.Scion(id=_id)
        self.compare_date(now, obj2.year)
    
    def test_choice(self):
        car = objects.Scion()
        car.color = "Red"

    def test_bad_choice(self):
        car = objects.Scion()
        car.color = "Invalid"
        with self.assertRaises(orm.DocumentException) as cm:
            car.save()

    def test_document_id(self):
        self.obj.name = self.name
        car = objects.Scion()
        car.owner = self.obj
        with self.assertRaises(FieldException) as cm:
            car._get("owner")().name

        h_id = self.obj.save()
        car = objects.Scion()
        car.owner = self.obj
        _id = car.save()
        car2 = objects.Scion(id=_id)
        human = car2._get("owner")()
        self.assertEqual(human._id, h_id)
        car3 = objects.Scion()
        car3.owner = objects.Female()
        with self.assertRaises(orm.DocumentException) as cm:
            car3.save()
            print cm.exception.errors

    def test_geo(self):
        loc = objects.LocationGeo()
        loc.city = "Chicago"
        loc.state = "IL"
        loc.geo = "sdjfhskljdfhskdhf"
        self.assertEqual(loc._get("geo")._error.__class__.__name__, 'FieldException')

        loc.geo = [545454, 654654, 654654]
        self.assertEqual(loc._get("geo")._error.__class__.__name__, 'FieldException')

        loc.geo = [48.326, -81.656565]
        self.assertEqual(loc.geo, [48.326, -81.656565])

    def test_boolean(self):
        loc = objects.LocationGeo()
        print loc.__class__
        loc.city = "Chicago"
        loc.state = "IL"
        loc.geo = [48.326, -81.656565]
        loc.active = "kjsdhfksjhdflksjhdflksjhdf"
        self.assertEqual(loc.active, True)

        loc.active = 0
        self.assertEqual(loc.active, False)

        loc.active = True
        self.assertEqual(loc.active, True)
        
        loc.active = False
        self.assertEqual(loc.active, False)        
    
    def test_phone(self):
        obj = objects.BadHuman()
        print obj._get("phone")
        obj.name = "Anne"
        obj.phone = "sjkdhfkjshdfksjhdf"
        print obj._get("phone")
        self.assertEqual(obj._get("phone")._error.__class__.__name__, "FieldException")

        obj.phone = "810-542.0141"
        self.assertEqual(obj.phone, u"+18105420141")

        obj.phone = "1-810-542.0141"
        self.assertEqual(obj.phone, u"+18105420141")

    def test_email(self):
        obj = objects.BadHuman()
        obj.name = "Anne"
        obj.email = "sdsdff"
        self.assertEqual(obj._get("email")._error.__class__.__name__, "FieldException")

        obj.email = "test@trest"
        self.assertEqual(obj._get("email")._error.__class__.__name__, "FieldException")

        obj.email = "test@test.com"
        self.assertEqual(obj.email, "test@test.com")

    def test_file(self):
        obj = objects.BadHuman()
        obj.name = "Anne"
        path = os.path.dirname(__file__)
        print path
        obj.avatar = file("%s/%s" % (path, "penguin.jpg"))
        f_id = obj.avatar
        self.assertEqual(obj._get("avatar").exists(), True)
        _id = obj.save()
        o = objects.BadHuman(id=_id)
        self.assertEqual(o.avatar, f_id)
        print o._get("avatar")()
        print o._get("avatar").list()
        print o._get("avatar").delete()
        self.assertEqual(obj._get("avatar").exists(), False)
        obj2 = objects.BadHuman()
        with self.assertRaises(FieldException) as cm:
            obj2._get("avatar")()

        obj2.name = "Anne"
        obj2.avatar = objects.BadHuman()
        with self.assertRaises(orm.DocumentException) as cm:
            obj2.save()
            print cm.exception.errors


    def tearDown(self):
        self.obj.__class__.__remove__()

class Find(unittest.TestCase):

    def setUp(self):
        self.ids = []
        self.genitalia = "inny"
        for i in xrange(5):
            obj = objects.Female()
            obj.name = "Anne%s" % i
            j = objects.Job()
            j.title = "President"
            obj.jobs.append(j)
            obj.save()
            self.ids.append(obj._id)
    
    def test_find(self):
        ids = []
        print self.ids
        for obj in objects.Female.find().sort('_id'):
            print obj.jobs[0]
            print obj.created
            print obj.json()
            ids.append(obj._id)
                
        self.assertEqual(ids, self.ids)
    
    def test_fields(self):
        for obj in objects.Female.find(as_dict=True, fields={"genitalia":True}):
            self.assertEqual(obj.get('name', None), None)
            self.assertEqual(obj.get('genitalia', None), self.genitalia)

        obj = objects.Female.find_one({"_id":self.ids[0]}, as_dict=True, fields={"genitalia":True})
        self.assertEqual(obj.get("genitalia", None), self.genitalia)
    
    def test_update(self):
        obj = objects.Female(id=self.ids[0])
        obj.update({"$set":{"name":"Woop"}})
        obj2 = objects.Female(id=self.ids[0])
        self.assertEqual(obj2.name, "Woop")
    
    def test_remove(self):
        obj = objects.Female(id=self.ids[0])
        obj.remove()
        obj2 = objects.Female.find_one({"_id":self.ids[0]})
        self.assertEqual(obj2, None)

    def tearDown(self):
        objects.Female.__remove__()


class Document(unittest.TestCase):

    def setUp(self):
        self.job = objects.Job()
        self.job.employer = "Nike"
        self.job.title = "Designer"
        self.loc = objects.Location()
        self.loc.city = "Portland"
        self.loc.state = "OR"
        
        self.obj = objects.Female()
        self.obj.name = "Anne"
        self.obj.age = 27
        self.obj.height = 65
        self.obj.weight = 120

        self.person = {
            "name":u"Anne", 
            "age":27, 
            "height":65.0, 
            "weight":120.0,
            "genitalia":u"inny", 
            "jobs":[
                {
                    "employer":u"Nike", 
                    "title":u"Designer", 
                    "locations":[
                        {
                            "city":u"Portland", 
                            "state":u"OR"
                        }
                    ]
                }
            ]
        }
    

        
    def test_dbkey(self):
        obj = objects.BadHuman()
        obj.name = "Anne"
        obj.email = "test@test.com"
        _id = obj.save()
        dic = obj.find_one({"_id":_id}, as_dict=True)
        dic.get("em")

    def test_empty(self):
        obj = objects.BadHuman()
        with self.assertRaises(orm.DocumentException) as cm:
            obj.save()

    def test_repr(self):
        print unicode(self.obj)
        print self.obj
        print self.obj.jobs
        print unicode(self.obj.jobs)
        print self.obj.name
        print unicode(self.obj.name)
        print unicode(self.obj._get("name"))
        print orm.Widget(object=self.obj._get("name"), name="name").render()
        print unicode(self.obj.cars)

    def test_json(self):
        self.job.locations.append(self.loc)
        self.obj.jobs.append(self.job)
        j = self.obj._json()
        del j["human_id"]
        self.assertEqual(j, self.person)
        _id = self.obj.save()
        o = self.obj.json()
        self.assertEqual(_id, o['_id'])
    
    def test_map(self):
        anne = objects.Female()
        anne._map(self.person)
        j = anne._json()
        del j["human_id"]
        self.assertEqual(j, self.person)

    def test_save(self):
        self.job.locations.append(self.loc)
        self.obj.jobs.append(self.job)
        _id = self.obj.save()
        obj = self.obj.__class__(id=_id)
        j = self.obj._json()
        del j["human_id"]
        self.assertEqual(j, self.person)

    def test_empty_relationship(self):
        _id = self.obj.save()
        obj2 = self.obj.__class__(id=_id)
        obj2.jobs.append(self.job)
        self.job.locations.append(self.loc)
        obj2.save()
        obj3 = self.obj.__class__(id=_id)
        j = obj3._json()
        del j["human_id"]
        self.assertEqual(j, self.person)
    
    def test_bad_rel_type(self):
        with self.assertRaises(Exception) as cm:
            self.obj.jobs.append(objects.Location())

        print cm.exception
    
    def test_list_length(self):
        with self.assertRaises(Exception) as cm:
            for i in xrange(5):
                job = objects.Job()
                job.title = "Engineer %s" % i
                self.obj.jobs.append(job)

    def test_list_delete(self):
        person = self.obj
        self.job.locations.append(self.loc)
        person.jobs.append(self.job)
        person.save()
        id = person._id
        p2 = objects.Female(id=id)
        self.assertEqual(p2.jobs[0]._json(), self.person.get('jobs')[0])
        p2.jobs.delete('jobs', 0)
        p3 = objects.Female(id=id)
        self.assertEqual(len(p3.jobs), 0)
    
    def test_bad_get(self):
        with self.assertRaises(AttributeError):
            self.obj._get("hoohaa")
    
    def test_bad_attr(self):
        with self.assertRaises(AttributeError):
            self.obj.hoohaa


    def test_non_doc_relationship(self):
        car = objects.Rodeo()
        car.tires.append(1)
        car.tires.append(2)
        car.tires.append(3)
        car.tires.append(4)
        _id = car.save()
        car2 = objects.Rodeo(id=_id)
        self.assertEqual(car2.tires, [1,2,3,4])
    
    def test_mongo_exception(self):
        obj = objects.BadHuman()
        obj._coll.ensure_index("name", unique=True)
        obj.name = "Test"
        obj.save()
        
        obj2 = objects.BadHuman()
        obj2.name = "Test"
        with self.assertRaises(Exception) as cm:
            _id = obj2.save()
        
        obj.__class__.__remove__()
        obj3 = objects.BadHuman()
        obj3.name = "Test"
        obj3.save()

        obj4 = objects.BadHuman()
        obj4.name = "Tester"
        obj4.save()
        obj4.name = "Test"
        with self.assertRaises(Exception) as cm:
            _id2 = obj4.save()
        
        obj._coll.drop_indexes()
        

    def test_created(self):
        self.obj.save()
        print self.obj.created
        self.assertEqual(self.obj.created.__class__, datetime.datetime) 

    def test_modified(self):
        self.obj.save()
        print self.obj.modified
        self.assertEqual(self.obj.modified.__class__, datetime.datetime)

    def test_active(self):
        self.obj.save()
        self.assertEqual(self.obj.active, True)

    def tearDown(self):
        self.obj.__class__.__remove__()

class Lazy(unittest.TestCase):

    def setUp(self):
        self.obj = objects.Female()
        self.obj.name = "Anne"
        self.obj.age = 27
        self.obj.height = 65
        self.obj.weight = 120
        self.human_id = self.obj.save()
        self.car_ids = []
        for i in xrange(3):
            car = objects.Car()
            car.owner = self.human_id
            car.make = "Toyota"
            car.model = "Camry"
            car.year = datetime.datetime(2010+i, 1, 1)
            self.car_ids.append(car.save())

    def test_lazy(self):
        human = objects.Female(id=self.human_id)
        ids = []
        for c in human.cars().sort('_id'):
            ids.append(c._id)
        
        self.assertEqual(self.car_ids, ids)

    def tearDown(self):
        self.obj.__class__.__remove__()
        objects.Car.__remove__()

class SavingLoading(unittest.TestCase):

    def setUp(self):
        self.car = objects.Car()
        self.car.make = "Saab"
        self.car.model = "900"
        self.car.year = datetime.datetime(2007, 1, 1)

    def test_list_strings_0(self):
        self.car.features._map([u'CD-Player', u'Power Windows', u'Remote Start'])        
        self.car.features.append(u"Test")
        try:
            self.car.save()
        except Exception as e:
            print e

        car = objects.Car(id=self.car._id)
        self.assertEqual(len(car.features), len(self.car.features))

    def test_list_strings_1(self):
        self.car.features.append(u'Test')
        self.car.features.append(u'AnotherTest')
        self.car.save()

        car = objects.Car(id=self.car._id)
        self.assertEqual(len(car.features), len(self.car.features))

        self.car.features.append(u'Yet again another')
        self.car.save()

        car = objects.Car(id=self.car._id)
        self.assertEqual(len(car.features), len(self.car.features))

        self.car.features.delete('features', 1)
        self.car.save()

        car = objects.Car(id=self.car._id)
        self.assertEqual(len(car.features), len(self.car.features))

    def test_lists_of_type(self):
        p0 = objects.Property()
        p0.name = "Type"
        p0.value = "Lumber"

        p1= objects.Property()
        p1.name = "Type"
        p1.value = "Camping gear"

        p2= objects.Property()
        p2.name = "Type"
        p2.value = "Sledgehammer"

        self.car.properties.append(p0)
        self.car.save()

        car = objects.Car.find_one(id=self.car._id)
        self.assertEqual(len(car.properties), len(self.car.properties))

        self.car.properties.append(p1)
        self.car.save()
        car = objects.Car.find_one(id=self.car._id)
        self.assertEqual(len(car.properties), len(self.car.properties))

        self.car.properties.delete('properties', 1)
        self.car.save()
        car = objects.Car(id=self.car._id)
        self.assertEqual(len(car.properties), len(self.car.properties))

    def test_add_new_field(self):
        self.car.save()

        class Hybrid(objects.Car):
            fuels = orm.List(type=objects.Property)

        hybrid_car = Hybrid(id=self.car._id)
        # This test will work if you call save upon loading (if new field was added)
        # Otherwise it will write the object as {'0': {'name': 'Ethanol', value: 'E85'}, '1': {.......}}
        #hybrid_car.save()

        p0 = objects.Property()
        p0.name = "Ethanol"
        p0.value = "E85"
        hybrid_car.fuels.append(p0)

        p1 = objects.Property()
        p1.name = "Battery"
        p1.value = "240 Volts"
        hybrid_car.fuels.append(p1)

        hybrid_car.save()

        loaded_hybrid = Hybrid(id=self.car._id)
        self.assertEqual(loaded_hybrid.fuels[0].name, hybrid_car.fuels[0].name)
        self.assertEqual(loaded_hybrid.fuels[0].value, hybrid_car.fuels[0].value)

    def tearDown(self):
        self.car.__class__.__remove__()


class Widget(unittest.TestCase):

    def setUp(self):
        self.car = objects.Car()
        self.car.make = "Isuzu"
        self.car.model = "Rodeo"
        self.car.year = datetime.datetime(2007, 1, 1)
        self.text_html= "<input name='make' value='Isuzu' id='id_make' type='text' class='red checked' />"
        self.choice_html = "<select class='Woot' id='id_car' name='car' ><option value='%s' >Isuzu Rodeo 2007-01-01 00:00:00</option></select>"
        self.object_html = """<ul class='test'>
                    <li>Make: Isuzu</li>
                    <li>Model: Rodeo</li>
                    <li>Year: 2007-01-01 00:00:00</li>
                </ul>"""
    


    def test_render(self):
        anne = objects.Female()
        anne.name = "Anne"
        print anne._get("name").render()

    def test_multiple_select(self):
        anne = objects.Female()
        anne.name = "Anne"
        anne.jobs.append(objects.Job())
        anne.jobs.append(objects.Job())
        def yo(obj):
            for i in obj:
                return {"value":i.title, "display":i.employer}
        print widget.MultipleSelect(object=anne.jobs, item_render=yo).render()

    def test_input_render(self):
        text = widget.Input(object=self.car._get("make"), name="make").render(cls="red checked")
        self.assertEqual(text.strip(), self.text_html.strip())
    
    def test_choice_render(self):
        _id = self.car.save()
        select = self.choice_html % str(_id)
        obj = objects.BadHuman()
        text = widget.Select(object=obj._get("car"), item_render=objects.car_disp, name='car').render(cls="Woot")
        self.assertEqual(text.strip(), select.strip())

    def test_object_render(self):
        text = objects.CarDisplay(object=self.car).render(cls='test')
        self.assertEqual(text.strip(), self.object_html.strip())

    def test_checkbox(self):
        obj = objects.BadHuman()
        text = widget.CheckBox(object=obj._get("active")).render()
        print text
        with self.assertRaises(Exception) as cm:
            correct = text.index("CHECKED")
        obj.active = True
        checked = widget.CheckBox(object=obj._get("active")).render()
        print checked
        correct = checked.index("CHECKED")
        self.assertGreater(correct, -1)

class Form(unittest.TestCase):

    def setUp(self):
        self.obj = objects.BadHuman()
        self.obj.name = "Anne"
        self.obj.age = 27
        self.obj.height = 65
        self.obj.weight = 120
        self.submit = {
            "name":"",
            "human_id":"32226",
            "age":None,
            "weight":"175",
            "location-city":"Chicago",
            "location-state":"IL"
        }
    
    def test_form(self):
        form = objects.PersonForm(object=self.obj, data=self.submit)
        form.render()
        with self.assertRaises(orm.DocumentException) as e:
            form.validate()
    
    def test_iterator(self):
        form = objects.PersonForm(obj=self.obj, data=self.submit)
        for f in form:
            print f.label_tag()
            print f.render(cls="popup")

########NEW FILE########
