__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Mantrid'
copyright = u'2011 Epio Limited'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ["_theme"]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = "_static/logo.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'mantriddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'mantrid.tex', u'Mantrid Documentation',
   u'Epio Limited', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = actions
"""
Contains Mantrid's built-in actions.
"""

import errno
import os
import random
import eventlet
from eventlet.green import socket
from httplib import responses
from .socketmeld import SocketMelder


class Action(object):
    "Base action. Doesn't do anything."

    def __init__(self, balancer, host, matched_host):
        self.host = host
        self.balancer = balancer
        self.matched_host = matched_host

    def handle(self, sock, read_data, path, headers):
        raise NotImplementedError("You must use an Action subclass")


class Empty(Action):
    "Sends a code-only HTTP response"

    code = None

    def __init__(self, balancer, host, matched_host, code):
        super(Empty, self).__init__(balancer, host, matched_host)
        self.code = code

    def handle(self, sock, read_data, path, headers):
        "Sends back a static error page."
        try:
            sock.sendall("HTTP/1.0 %s %s\r\nConnection: close\r\nContent-length: 0\r\n\r\n" % (self.code, responses.get(self.code, "Unknown")))
        except socket.error, e:
            if e.errno != errno.EPIPE:
                raise


class Static(Action):
    "Sends a static HTTP response"

    type = None

    def __init__(self, balancer, host, matched_host, type=None):
        super(Static, self).__init__(balancer, host, matched_host)
        if type is not None:
            self.type = type

    # Try to get sendfile() using ctypes; otherwise, fall back
    try:
        import ctypes
        _sendfile = ctypes.CDLL("libc.so.6").sendfile
        _sendfile.argtypes = [ctypes.c_int, ctypes.c_int, ctypes.c_long, ctypes.c_size_t]
        _sendfile.restype = ctypes.c_ssize_t
    except Exception:
        _sendfile = None

    def handle(self, sock, read_data, path, headers):
        "Sends back a static error page."
        assert self.type is not None
        try:
            # Get the correct file
            try:
                fh = open(os.path.join(self.balancer.static_dir, "%s.http" % self.type))
            except IOError:
                fh = open(os.path.join(os.path.dirname(__file__), "static", "%s.http" % self.type))
            # Send it, using sendfile if poss. (no fileno() means we're probably using mock sockets)
            try:
                self._sendfile(sock.fileno(), fh.fileno(), 0, os.fstat(fh.fileno()).st_size)
            except (TypeError, AttributeError):
                sock.sendall(fh.read())
            # Close the file and socket
            fh.close()
            sock.close()
        except socket.error, e:
            if e.errno != errno.EPIPE:
                raise


class Unknown(Static):
    "Standard class for 'nothing matched'"

    type = "unknown"


class NoHosts(Static):
    "Standard class for 'there are no host entries at all'"

    type = "no-hosts"


class Redirect(Action):
    "Sends a redirect"

    type = None

    def __init__(self, balancer, host, matched_host, redirect_to):
        super(Redirect, self).__init__(balancer, host, matched_host)
        self.redirect_to = redirect_to

    def handle(self, sock, read_data, path, headers):
        "Sends back a static error page."
        if "://" not in self.redirect_to:
            destination = "http%s://%s" % (
                "s" if headers.get('X-Forwarded-Protocol', headers.get('X-Forwarded-Proto', "")).lower() in ("https", "ssl") else "",
                self.redirect_to
            )
        else:
            destination = self.redirect_to
        try:
            sock.sendall("HTTP/1.0 302 Found\r\nLocation: %s/%s\r\n\r\n" % (
                destination.rstrip("/"),
                path.lstrip("/"),
            ))
        except socket.error, e:
            if e.errno != errno.EPIPE:
                raise


class Proxy(Action):
    "Proxies them through to a server. What loadbalancers do."

    attempts = 1
    delay = 1

    def __init__(self, balancer, host, matched_host, backends, attempts=None, delay=None):
        super(Proxy, self).__init__(balancer, host, matched_host)
        self.backends = backends
        assert self.backends
        if attempts is not None:
            self.attempts = int(attempts)
        if delay is not None:
            self.delay = float(delay)

    def handle(self, sock, read_data, path, headers):
        "Sends back a static error page."
        for i in range(self.attempts):
            try:
                server_sock = eventlet.connect(
                    tuple(random.choice(self.backends)),
                )
            except socket.error:
                eventlet.sleep(self.delay)
                continue
            # Function to help track data usage
            def send_onwards(data):
                server_sock.sendall(data)
                return len(data)
            try:
                size = send_onwards(read_data)
                size += SocketMelder(sock, server_sock).run()
            except socket.error, e:
                if e.errno != errno.EPIPE:
                    raise


class Spin(Action):
    """
    Just holds the request open until either the timeout expires, or
    another action becomes available.
    """

    timeout = 120
    check_interval = 1

    def __init__(self, balancer, host, matched_host, timeout=None, check_interval=None):
        super(Spin, self).__init__(balancer, host, matched_host)
        if timeout is not None:
            self.timeout = int(timeout)
        if check_interval is not None:
            self.check_interval = int(check_interval)

    def handle(self, sock, read_data, path, headers):
        "Just waits, and checks for other actions to replace us"
        for i in range(self.timeout // self.check_interval):
            # Sleep first
            eventlet.sleep(self.check_interval)
            # Check for another action
            action = self.balancer.resolve_host(self.host)
            if not isinstance(action, Spin):
                return action.handle(sock, read_data, path, headers)
        # OK, nothing happened, so give up.
        action = Static(self.balancer, self.host, self.matched_host, type="timeout")
        return action.handle(sock, read_data, path, headers)

########NEW FILE########
__FILENAME__ = cli
import sys
from .client import MantridClient


class MantridCli(object):
    """Command line interface to Mantrid"""

    def __init__(self, base_url):
        self.client = MantridClient(base_url)

    @classmethod
    def main(cls):
        cli = cls("http://localhost:8042")
        cli.run(sys.argv)

    @property
    def action_names(self):
        for method_name in dir(self):
            if method_name.startswith("action_") \
               and method_name != "action_names":
                yield method_name[7:]
        
    def run(self, argv):
        # Work out what action we're doing
        try:
            action = argv[1]
        except IndexError:
            sys.stderr.write(
                "Please provide an action (%s).\n" % (
                    ", ".join(self.action_names),
                )
            )
            sys.exit(1)
        if action not in list(self.action_names):
            sys.stderr.write(
                "Action %s does not exist.\n" % (
                    action,
                )
            )
            sys.exit(1)
        # Run it
        getattr(self, "action_%s" % action)(*argv[2:])
    
    def action_list(self):
        "Lists all hosts on the LB"
        format = "%-35s %-25s %-8s"
        print format % ("HOST", "ACTION", "SUBDOMS")
        for host, details in sorted(self.client.get_all().items()):
            if details[0] in ("proxy", "mirror"):
                action = "%s<%s>" % (
                    details[0],
                    ",".join(
                        "%s:%s" % (host, port)
                        for host, port in details[1]['backends']
                    )
                )
            elif details[0] == "static":
                action = "%s<%s>" % (
                    details[0],
                    details[1]['type'],
                )
            elif details[0] == "redirect":
                action = "%s<%s>" % (
                    details[0],
                    details[1]['redirect_to'],
                )
            elif details[0] == "empty":
                action = "%s<%s>" % (
                    details[0],
                    details[1]['code'],
                )
            else:
                action = details[0]
            print format % (host, action, details[2])
    
    def action_set(self, hostname=None, action=None, subdoms=None, *args):
        "Adds a hostname to the LB, or alters an existing one"
        usage = "set <hostname> <action> <subdoms> [option=value, ...]"
        if hostname is None:
            sys.stderr.write("You must supply a hostname.\n")
            sys.stderr.write("Usage: %s\n" % usage)
            sys.exit(1)
        if action is None:
            sys.stderr.write("You must supply an action.\n")
            sys.stderr.write("Usage: %s\n" % usage)
            sys.exit(1)
        if subdoms is None or subdoms.lower() not in ("true", "false"):
            sys.stderr.write("You must supply True or False for the subdomains flag.\n")
            sys.stderr.write("Usage: %s\n" % usage)
            sys.exit(1)
        # Grab options
        options = {}
        for arg in args:
            if "=" not in arg:
                sys.stderr.write("%s is not a valid option (no =)\n" % (
                    arg
                ))
                sys.exit(1)
            key, value = arg.split("=", 1)
            options[key] = value
        # Sanity-check options
        if action in ("proxy, mirror") and "backends" not in options:
            sys.stderr.write("The %s action requires a backends option.\n" % action)
            sys.exit(1)
        if action == "static" and "type" not in options:
            sys.stderr.write("The %s action requires a type option.\n" % action)
            sys.exit(1)
        if action == "redirect" and "redirect_to" not in options:
            sys.stderr.write("The %s action requires a redirect_to option.\n" % action)
            sys.exit(1)
        if action == "empty" and "code" not in options:
            sys.stderr.write("The %s action requires a code option.\n" % action)
            sys.exit(1)
        # Expand some options from text to datastructure
        if "backends" in options:
            options['backends'] = [
                (lambda x: (x[0], int(x[1])))(bit.split(":", 1))
                for bit in options['backends'].split(",")
            ]
        # Set!
        self.client.set(
            hostname,
            [action, options, subdoms.lower() == "true"]
        )
    
    def action_delete(self, hostname):
        "Deletes the hostname from the LB."
        self.client.delete(
            hostname,
        )
    
    def action_stats(self, hostname=None):
        "Shows stats (possibly limited by hostname)"
        format = "%-35s %-11s %-11s %-11s %-11s"
        print format % ("HOST", "OPEN", "COMPLETED", "BYTES IN", "BYTES OUT")
        for host, details in sorted(self.client.stats(hostname).items()):
            print format % (
                host,
                details.get("open_requests", 0),
                details.get("completed_requests", 0),
                details.get("bytes_received", 0),
                details.get("bytes_sent", 0),
            )

########NEW FILE########
__FILENAME__ = client
try:
    import eventlet
    httplib2 = eventlet.import_patched("httplib2")
except ImportError:
    import httplib2
import json


class MantridClient(object):
    """
    Class encapsulating Mantrid client operations.
    """

    def __init__(self, base_url):
        self.base_url = base_url.rstrip("/")

    def _request(self, path, method, body=None):
        "Base request function"
        h = httplib2.Http()
        resp, content = h.request(
            self.base_url + path,
            method,
            body = json.dumps(body),
        )
        if resp['status'] == "200":
            return json.loads(content)
        else:
            raise IOError(
                "Got %s reponse from server (%s)" % (
                    resp['status'],
                    content,
                )
            )
    
    def get_all(self):
        "Returns all endpoints"
        return self._request("/hostname/", "GET")
    
    def set_all(self, data):
        "Sets all endpoints"
        return self._request("/hostname/", "PUT", data)
    
    def set(self, hostname, entry):
        "Sets endpoint for a single hostname"
        return self._request("/hostname/%s/" % hostname, "PUT", entry)
    
    def delete(self, hostname):
        "Deletes a single hostname"
        return self._request("/hostname/%s/" % hostname, "DELETE")

    def stats(self, hostname=None):
        if hostname:
            return self._request("/stats/%s/" % hostname, "GET")
        else:
            return self._request("/stats/", "GET")

########NEW FILE########
__FILENAME__ = config
import socket


class SimpleConfig(object):
    "Simple configuration file parser"

    def __init__(self, filename):
        self.filename = filename
        self.load()
    
    def load(self):
        items = {}
        with open(self.filename) as fh:
            for line in fh:
                # Clean up line, remove comments
                line = line.strip()
                if "#" in line:
                    line = line[:line.index("#")].strip()
                # Get the values
                if line:
                    try:
                        variable, value = line.split("=", 1)
                    except ValueError:
                        raise ValueError("Bad config line (no = and not a comment): %s" % line)
                    items.setdefault(variable.strip().lower(), set()).add(value.strip())
        # Save to ourselves
        self.items = items
    
    def __getitem__(self, item):
        values = self.items[item]
        if len(values) > 1:
            raise ValueError("More than one value specified for %s" % item)
        return list(values)[0]
    
    def get(self, item, default=None):
        values = self.items.get(item, set())
        if len(values) == 0:
            return default
        if len(values) > 1:
            raise ValueError("More than one value specified for %s" % item)
        return list(values)[0]
    
    def get_int(self, item, default):
        return int(self.get(item, default))
    
    def get_all(self, item):
        return self.items.get(item, set())
    
    def get_all_addresses(self, item, default=None):
        addresses = set()
        for value in self.get_all(item):
            try:
                address, port = value.rsplit(":", 1)
                family = socket.AF_INET
            except ValueError:
                raise ValueError("Invalid address (no port found): %s" % value)
            if address[0] == "[":
                address = address.strip("[]")
                family = socket.AF_INET6
            if address == "*":
                address = "::"
                family = socket.AF_INET6
            addresses.add(((address, int(port)), family))
        if not addresses:
            addresses = default or set()
        return addresses

########NEW FILE########
__FILENAME__ = greenbody
from eventlet.greenpool import GreenPool
from eventlet.event import Event


class GreenBody(GreenPool):
    """
    Special subclass of GreenPool which has a wait() method,
    that will return when any greenthread inside the pool exits.
    """

    def __init__(self, *args, **kwargs):
        super(GreenBody, self).__init__(*args, **kwargs)
        self.one_exited = Event()

    def wait(self):
        return self.one_exited.wait()
    
    def _spawn_done(self, coro):
        super(GreenBody, self)._spawn_done(coro)
        if not self.one_exited.ready():
            self.one_exited.send(coro.wait())

########NEW FILE########
__FILENAME__ = loadbalancer
import eventlet
import errno
import logging
import traceback
import mimetools
import resource
import json
import os
import sys
import argparse
from eventlet import wsgi
from eventlet.green import socket
from .actions import Unknown, Proxy, Empty, Static, Redirect, NoHosts, Spin
from .config import SimpleConfig
from .management import ManagementApp
from .stats_socket import StatsSocket
from .greenbody import GreenBody


class Balancer(object):
    """
    Main loadbalancer class.
    """

    nofile = 102400
    save_interval = 10
    action_mapping = {
        "proxy": Proxy,
        "empty": Empty,
        "static": Static,
        "redirect": Redirect,
        "unknown": Unknown,
        "spin": Spin,
        "no_hosts": NoHosts,
    }

    def __init__(self, external_addresses, internal_addresses, management_addresses, state_file, uid=None, gid=65535, static_dir="/etc/mantrid/static/"):
        """
        Constructor.

        Takes one parameter, the dict of ports to listen on.
        The key in this dict is the port number, and the value
        is if it's an internal endpoint or not.
        Internal endpoints do not have X-Forwarded-* stripped;
        other ones do, and have X-Forwarded-For added.
        """
        self.external_addresses = external_addresses
        self.internal_addresses = internal_addresses
        self.management_addresses = management_addresses
        self.state_file = state_file
        self.uid = uid
        self.gid = gid
        self.static_dir = static_dir

    @classmethod
    def main(cls):
        # Parse command-line args
        parser = argparse.ArgumentParser(description='The Mantrid load balancer')
        parser.add_argument('--debug', dest='debug', action='store_const', const=True, help='Enable debug logging')
        parser.add_argument('-c', '--config', dest='config', default=None, metavar="PATH", help='Path to the configuration file')
        args = parser.parse_args()
        # Set up logging
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG if args.debug else logging.INFO)
        # Output to stderr, always
        sh = logging.StreamHandler()
        sh.setFormatter(logging.Formatter(
            fmt = "%(asctime)s - %(levelname)8s: %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S",
        ))
        sh.setLevel(logging.DEBUG)
        logger.addHandler(sh)
        # Check they have root access
        try:
            resource.setrlimit(resource.RLIMIT_NOFILE, (cls.nofile, cls.nofile))
        except (ValueError, resource.error):
            logging.warning("Cannot raise resource limits (run as root/change ulimits)")
        # Load settings from the config file
        if args.config is None:
            if os.path.exists("/etc/mantrid/mantrid.conf"):
                args.config = "/etc/mantrid/mantrid.conf"
                logging.info("Using configuration file %s" % args.config)
            else:
                args.config = "/dev/null"
                logging.info("No configuration file found - using defaults.")
        else:
            logging.info("Using configuration file %s" % args.config)
        config = SimpleConfig(args.config)
        balancer = cls(
            config.get_all_addresses("bind", set([(("::", 80), socket.AF_INET6)])),
            config.get_all_addresses("bind_internal"),
            config.get_all_addresses("bind_management", set([(("127.0.0.1", 8042), socket.AF_INET), (("::1", 8042), socket.AF_INET6)])),
            config.get("state_file", "/var/lib/mantrid/state.json"),
            config.get_int("uid", 4321),
            config.get_int("gid", 4321),
            config.get("static_dir", "/etc/mantrid/static/"),
        )
        balancer.run()

    def load(self):
        "Loads the state from the state file"
        try:
            if os.path.getsize(self.state_file) <= 1:
                raise IOError("File is empty.")
            with open(self.state_file) as fh:
                state = json.load(fh)
                assert isinstance(state, dict)
                self.hosts = state['hosts']
                self.stats = state['stats']
            for key in self.stats:
                self.stats[key]['open_requests'] = 0
        except (IOError, OSError):
            # There is no state file; start empty.
            self.hosts = {}
            self.stats = {}

    def save(self):
        "Saves the state to the state file"
        with open(self.state_file, "w") as fh:
            json.dump({
                "hosts": self.hosts,
                "stats": self.stats,
            }, fh)

    def run(self):
        # First, initialise the process
        self.load()
        self.running = True
        # Try to ensure the state file is readable
        state_dir = os.path.dirname(self.state_file)
        if not os.path.isdir(state_dir):
            os.makedirs(state_dir)
        if self.uid is not None:
            try:
                os.chown(state_dir, self.uid, -1)
            except OSError:
                pass
            try:
                os.chown(self.state_file, self.uid, -1)
            except OSError:
                pass
        # Then, launch the socket loops
        pool = GreenBody(
            len(self.external_addresses) +
            len(self.internal_addresses) +
            len(self.management_addresses) +
            1
        )
        pool.spawn(self.save_loop)
        for address, family in self.external_addresses:
            pool.spawn(self.listen_loop, address, family, internal=False)
        for address, family in self.internal_addresses:
            pool.spawn(self.listen_loop, address, family, internal=True)
        for address, family in self.management_addresses:
            pool.spawn(self.management_loop, address, family)
        # Give the other threads a chance to open their listening sockets
        eventlet.sleep(0.5)
        # Drop to the lesser UID/GIDs, if supplied
        if self.gid:
            try:
                os.setegid(self.gid)
                os.setgid(self.gid)
            except OSError:
                logging.error("Cannot change to GID %i (probably not running as root)" % self.gid)
            else:
                logging.info("Dropped to GID %i" % self.gid)
        if self.uid:
            try:
                os.seteuid(0)
                os.setuid(self.uid)
                os.seteuid(self.uid)
            except OSError:
                logging.error("Cannot change to UID %i (probably not running as root)" % self.uid)
            else:
                logging.info("Dropped to UID %i" % self.uid)
        # Ensure we can save to the state file, or die hard.
        try:
            open(self.state_file, "a").close()
        except (OSError, IOError):
            logging.critical("Cannot write to state file %s" % self.state_file)
            sys.exit(1)
        # Wait for one to exit, or for a clean/forced shutdown
        try:
            pool.wait()
        except (KeyboardInterrupt, StopIteration, SystemExit):
            pass
        except:
            logging.error(traceback.format_exc())
        # We're done
        self.running = False
        logging.info("Exiting")

    ### Management ###

    def save_loop(self):
        """
        Saves the state if it has changed.
        """
        last_hash = hash(repr(self.hosts))
        while self.running:
            eventlet.sleep(self.save_interval)
            next_hash = hash(repr(self.hosts))
            if next_hash != last_hash:
                self.save()
                last_hash = next_hash

    def management_loop(self, address, family):
        """
        Accepts management requests.
        """
        try:
            sock = eventlet.listen(address, family)
        except socket.error, e:
            logging.critical("Cannot listen on (%s, %s): %s" % (address, family, e))
            return
        # Sleep to ensure we've dropped privileges by the time we start serving
        eventlet.sleep(0.5)
        # Actually serve management
        logging.info("Listening for management on %s" % (address, ))
        management_app = ManagementApp(self)
        try:
            with open("/dev/null", "w") as log_dest:
                wsgi.server(
                    sock,
                    management_app.handle,
                    log = log_dest,
                )
        finally:
            sock.close()

    ### Client handling ###

    def listen_loop(self, address, family, internal=False):
        """
        Accepts incoming connections.
        """
        try:
            sock = eventlet.listen(address, family)
        except socket.error, e:
            if e.errno == errno.EADDRINUSE:
                logging.critical("Cannot listen on (%s, %s): already in use" % (address, family))
                raise
            elif e.errno == errno.EACCES and address[1] <= 1024:
                logging.critical("Cannot listen on (%s, %s) (you might need to launch as root)" % (address, family))
                return
            logging.critical("Cannot listen on (%s, %s): %s" % (address, family, e))
            return
        # Sleep to ensure we've dropped privileges by the time we start serving
        eventlet.sleep(0.5)
        # Start serving
        logging.info("Listening for requests on %s" % (address, ))
        try:
            eventlet.serve(
                sock,
                lambda sock, addr: self.handle(sock, addr, internal),
                concurrency = 10000,
            )
        finally:
            sock.close()

    def resolve_host(self, host, protocol="http"):
        # Special case for empty hosts dict
        if not self.hosts:
            return NoHosts(self, host, "unknown")
        # Check for an exact or any subdomain matches
        bits = host.split(".")
        for i in range(len(bits)):
            for prefix in ["%s://" % protocol, ""]:
                subhost = prefix + (".".join(bits[i:]))
                if subhost in self.hosts:
                    action, kwargs, allow_subs = self.hosts[subhost]
                    if allow_subs or i == 0:
                        action_class = self.action_mapping[action]
                        return action_class(
                            balancer = self,
                            host = host,
                            matched_host = subhost,
                            **kwargs
                        )
        return Unknown(self, host, "unknown")

    def handle(self, sock, address, internal=False):
        """
        Handles an incoming HTTP connection.
        """
        try:
            sock = StatsSocket(sock)
            rfile = sock.makefile('rb', 4096)
            # Read the first line
            first = rfile.readline().strip("\r\n")
            words = first.split()
            # Ensure it looks kind of like HTTP
            if not (2 <= len(words) <= 3):
                sock.sendall("HTTP/1.0 400 Bad Request\r\nConnection: close\r\nContent-length: 0\r\n\r\n")
                return
            path = words[1]
            # Read the headers
            headers = mimetools.Message(rfile, 0)
            # Work out the host
            try:
                host = headers['Host']
            except KeyError:
                host = "unknown"
            headers['Connection'] = "close"
            if not internal:
                headers['X-Forwarded-For'] = address[0]
                headers['X-Forwarded-Protocol'] = ""
                headers['X-Forwarded-Proto'] = ""
            # Make sure they're not using odd encodings
            if "Transfer-Encoding" in headers:
                sock.sendall("HTTP/1.0 411 Length Required\r\nConnection: close\r\nContent-length: 0\r\n\r\n")
                return
            # Match the host to an action
            protocol = "http"
            if headers.get('X-Forwarded-Protocol', headers.get('X-Forwarded-Proto', "")).lower() in ("ssl", "https"):
                protocol = "https"
            action = self.resolve_host(host, protocol)
            # Record us as an open connection
            stats_dict = self.stats.setdefault(action.matched_host, {})
            stats_dict['open_requests'] = stats_dict.get('open_requests', 0) + 1
            # Run the action
            try:
                rfile._rbuf.seek(0)
                action.handle(
                    sock = sock,
                    read_data = first + "\r\n" + str(headers) + "\r\n" + rfile._rbuf.read(),
                    path = path,
                    headers = headers,
                )
            finally:
                stats_dict['open_requests'] -= 1
                stats_dict['completed_requests'] = stats_dict.get('completed_requests', 0) + 1
                stats_dict['bytes_sent'] = stats_dict.get('bytes_sent', 0) + sock.bytes_sent
                stats_dict['bytes_received'] = stats_dict.get('bytes_received', 0) + sock.bytes_received
        except socket.error, e:
            if e.errno not in (errno.EPIPE, errno.ETIMEDOUT, errno.ECONNRESET):
                logging.error(traceback.format_exc())
        except:
            logging.error(traceback.format_exc())
            try:
                sock.sendall("HTTP/1.0 500 Internal Server Error\r\n\r\nThere has been an internal error in the load balancer.")
            except socket.error, e:
                if e.errno != errno.EPIPE:
                    raise
        finally:
            try:
                sock.close()
                rfile.close()
            except:
                logging.error(traceback.format_exc())

if __name__ == "__main__":
    Balancer.main()

########NEW FILE########
__FILENAME__ = management
import json
import re


class HttpNotFound(Exception):
    "Exception raised to pass on a 404 error."
    pass


class HttpMethodNotAllowed(Exception):
    "Exception raised for a valid path but invalid method."
    pass


class HttpBadRequest(Exception):
    "Exception raised for an invalidly formed host entry."
    pass


class ManagementApp(object):
    """
    Management WSGI app for the Mantrid loadbalancer.
    Allows endpoints to be changed via HTTP requests to
    the management port.
    """

    host_regex = re.compile(r"^/hostname/([^/]+)/?$")
    stats_host_regex = re.compile(r"^/stats/([^/]+)/?$")

    def __init__(self, balancer):
        self.balancer = balancer

    def handle(self, environ, start_response):
        "Main entry point"
        # Pass off to the router
        try:
            handler = self.route(
                environ['PATH_INFO'].lower(),
                environ['REQUEST_METHOD'].lower(),
            )
            if handler is None:
                raise HttpNotFound()
        # Handle errors
        except HttpNotFound:
            start_response('404 Not Found', [('Content-Type', 'application/json')])
            return [json.dumps({"error": "not_found"})]
        except HttpMethodNotAllowed:
            start_response('405 Method Not Allowed', [('Content-Type', 'application/json')])
            return [json.dumps({"error": "method_not_allowed"})]
        # Dispatch to the named method
        body = environ['wsgi.input'].read()
        if body:
            body = json.loads(body)
        response = handler(
            environ['PATH_INFO'].lower(),
            body,
        )
        # Send the response
        start_response('200 OK', [('Content-Type', 'application/json')])
        return [json.dumps(response)]

    def route(self, path, method):
        # Simple routing for paths
        if path == "/":
            raise HttpMethodNotAllowed()
        elif path == "/stats/":
            if method == "get":
                return self.get_all_stats
            else:
                raise HttpMethodNotAllowed()
        elif self.stats_host_regex.match(path):
            if method == "get":
                return self.get_single_stats
            else:
                raise HttpMethodNotAllowed()
        elif path == "/hostname/":
            if method == "get":
                return self.get_all
            elif method == "put":
                return self.set_all
            else:
                raise HttpMethodNotAllowed()
        elif self.host_regex.match(path):
            if method == "get":
                return self.get_single
            elif method == "put":
                return self.set_single
            elif method == "delete":
                return self.delete_single
            else:
                raise HttpMethodNotAllowed()
        else:
            raise HttpNotFound()

    ### Handling methods ###

    def host_errors(self, hostname, details):
        """
        Validates the format of a host entry
        Returns an error string, or None if it is valid.
        """
        if not hostname or not isinstance(hostname, basestring):
            return "hostname_invalid"
        if not isinstance(details, list):
            return "host_details_not_list"
        if len(details) != 3:
            return "host_details_wrong_length"
        if details[0] not in self.balancer.action_mapping:
            return "host_action_invalid:%s" % details[0]
        if not isinstance(details[1], dict):
            return "host_kwargs_not_dict"
        if not isinstance(details[2], bool):
            return "host_match_subdomains_not_bool"
        return None

    def get_all(self, path, body):
        return self.balancer.hosts

    def set_all(self, path, body):
        "Replaces the hosts list with the provided input"
        # Do some error checking
        if not isinstance(body, dict):
            raise HttpBadRequest("body_not_a_dict")
        for hostname, details in body.items():
            error = self.host_errors(hostname, details)
            if error:
                raise HttpBadRequest("%s:%s" % (hostname, error))
        # Replace
        old_hostnames = set(self.balancer.hosts.keys())
        new_hostnames = set(body.keys())
        self.balancer.hosts = body
        # Clean up stats dict
        for hostname in new_hostnames - old_hostnames:
            self.balancer.stats[hostname] = {}
        for hostname in old_hostnames - new_hostnames:
            try:
                del self.balancer.stats[hostname]
            except KeyError:
                pass
        return {"ok": True}

    def get_single(self, path, body):
        host = self.host_regex.match(path).group(1)
        if host in self.balancer.hosts:
            return self.balancer.hosts[host]
        else:
            return None

    def set_single(self, path, body):
        host = self.host_regex.match(path).group(1)
        error = self.host_errors(host, body)
        if error:
            raise HttpBadRequest("%s:%s" % (host, error))
        self.balancer.hosts[host] = body
        self.balancer.stats[host] = {}
        return {"ok": True}

    def delete_single(self, path, body):
        host = self.host_regex.match(path).group(1)
        try:
            del self.balancer.hosts[host]
        except KeyError:
            pass
        try:
            del self.balancer.stats[host]
        except KeyError:
            pass
        return {"ok": True}

    def get_all_stats(self, path, body):
        return self.balancer.stats

    def get_single_stats(self, path, body):
        host = self.stats_host_regex.match(path).group(1)
        return self.balancer.stats.get(host, {})

########NEW FILE########
__FILENAME__ = socketmeld
import eventlet
import greenlet
from eventlet.green import socket


class SocketMelder(object):
    """
    Takes two sockets and directly connects them together.
    """

    def __init__(self, client, server):
        self.client = client
        self.server = server
        self.data_handled = 0

    def piper(self, in_sock, out_sock, out_addr, onkill):
        "Worker thread for data reading"
        try:
            while True:
                written = in_sock.recv(32768)
                if not written:
                    try:
                        out_sock.shutdown(socket.SHUT_WR)
                    except socket.error:
                        self.threads[onkill].kill()
                    break
                try:
                    out_sock.sendall(written)
                except socket.error:
                    pass
                self.data_handled += len(written)
        except greenlet.GreenletExit:
            return

    def run(self):
        self.threads = {
            "ctos": eventlet.spawn(self.piper, self.server, self.client, "client", "stoc"),
            "stoc": eventlet.spawn(self.piper, self.client, self.server, "server", "ctos"),
        }
        try:
            self.threads['stoc'].wait()
        except (greenlet.GreenletExit, socket.error):
            pass
        try:
            self.threads['ctos'].wait()
        except (greenlet.GreenletExit, socket.error):
            pass
        self.server.close()
        self.client.close()
        return self.data_handled

########NEW FILE########
__FILENAME__ = stats_socket
class StatsSocket(object):
    """
    Wrapper around a socket that measures how many bytes
    have been sent and received.
    """

    def __init__(self, sock):
        self.sock = sock
        self.bytes_sent = 0
        self.bytes_received = 0

    def __getattr__(self, attr):
        return getattr(self.sock, attr)
    
    def sendall(self, data):
        self.bytes_sent += len(data)
        self.sock.sendall(data)
    
    def send(self, data):
        sent = self.sock.send(data)
        self.bytes_sent += sent
        return sent
    
    def recv(self, length):
        recvd = self.sock.recv(length)
        self.bytes_received += len(recvd)
        return recvd

    def makefile(self, *args, **kwargs):
        fh = self.sock.makefile(*args, **kwargs)
        fh._sock = self
        return fh

########NEW FILE########
__FILENAME__ = actions
import os
import errno
import socket
import time
import eventlet
import unittest
httplib2 = eventlet.import_patched("httplib2")
from eventlet.timeout import Timeout
from ..loadbalancer import Balancer
from ..actions import Empty, Static, Unknown, NoHosts, Redirect, Proxy, Spin


class MockBalancer(object):
    "Fake Balancer class for testing."

    def __init__(self, fixed_action=None):
        self.fixed_action = None
        self.static_dir = "/tmp/"

    def resolve_host(self, host):
        return self.fixed_action


class MockSocket(object):
    "Fake Socket class that remembers what was sent. Doesn't implement sendfile."

    def __init__(self):
        self.data = ""

    def send(self, data):
        self.data += data
        return len(data)

    def sendall(self, data):
        self.data += data

    def close(self):
        pass


class MockErrorSocket(object):
    "Fake Socket class that raises a specific error message on use."

    def __init__(self, error_code):
        self.error_code = error_code

    def _error(self, *args, **kwargs):
        raise socket.error(self.error_code, os.strerror(self.error_code))
    sendall = _error


class ActionTests(unittest.TestCase):
    "Tests the various actions"

    def test_empty(self):
        "Tests the Empty action"
        action = Empty(MockBalancer(), "zomg-lol.com", "zomg-lol.com", code=500)
        sock = MockSocket()
        action.handle(sock, "", "/", {})
        self.assertEqual(
            "HTTP/1.0 500 Internal Server Error\r\nConnection: close\r\nContent-length: 0\r\n\r\n",
            sock.data,
        )

    def test_handle(self):
        "Tests the Static action"
        action = Static(MockBalancer(), "kittens.net", "kittens.net", type="timeout")
        sock = MockSocket()
        action.handle(sock, "", "/", {})
        self.assertEqual(
            open(os.path.join(os.path.dirname(__file__), "..", "static", "timeout.http")).read(),
            sock.data,
        )

    def test_unknown(self):
        "Tests the Unknown action"
        action = Unknown(MockBalancer(), "firefly.org", "firefly.org")
        sock = MockSocket()
        action.handle(sock, "", "/", {})
        self.assertEqual(
            open(os.path.join(os.path.dirname(__file__), "..", "static", "unknown.http")).read(),
            sock.data,
        )

    def test_nohosts(self):
        "Tests the NoHosts action"
        action = NoHosts(MockBalancer(), "thevoid.local", "thevoid.local")
        sock = MockSocket()
        action.handle(sock, "", "/", {})
        self.assertEqual(
            open(os.path.join(os.path.dirname(__file__), "..", "static", "no-hosts.http")).read(),
            sock.data,
        )

    def test_redirect(self):
        "Tests the Redirect action"
        action = Redirect(MockBalancer(), "lions.net", "lions.net", redirect_to="http://tigers.net")
        # Test with root path
        sock = MockSocket()
        action.handle(sock, "", "/", {})
        self.assertEqual(
            "HTTP/1.0 302 Found\r\nLocation: http://tigers.net/\r\n\r\n",
            sock.data,
        )
        # Test with non-root path
        sock = MockSocket()
        action.handle(sock, "", "/bears/", {})
        self.assertEqual(
            "HTTP/1.0 302 Found\r\nLocation: http://tigers.net/bears/\r\n\r\n",
            sock.data,
        )
        # Test with https
        action = Redirect(MockBalancer(), "oh-my.com", "oh-my.com", redirect_to="https://meme-overload.com")
        sock = MockSocket()
        action.handle(sock, "", "/bears2/", {})
        self.assertEqual(
            "HTTP/1.0 302 Found\r\nLocation: https://meme-overload.com/bears2/\r\n\r\n",
            sock.data,
        )
        # Test with same-protocol
        action = Redirect(MockBalancer(), "example.com", "example.com", redirect_to="example.net")
        sock = MockSocket()
        action.handle(sock, "", "/test/", {})
        self.assertEqual(
            "HTTP/1.0 302 Found\r\nLocation: http://example.net/test/\r\n\r\n",
            sock.data,
        )
        sock = MockSocket()
        action.handle(sock, "", "/test/", {"X-Forwarded-Protocol": "SSL"})
        self.assertEqual(
            "HTTP/1.0 302 Found\r\nLocation: https://example.net/test/\r\n\r\n",
            sock.data,
        )

    def test_proxy(self):
        "Tests the Proxy action"
        # Check failure with no backends
        self.assertRaises(
            AssertionError,
            lambda: Proxy(MockBalancer(), "khaaaaaaaaaaaaan.xxx", "khaaaaaaaaaaaaan.xxx", backends=[]),
        )
        # TODO: launch local server, proxy to that

    def test_spin(self):
        "Tests the Spin action"
        # Set the balancer up to return a Spin
        balancer = MockBalancer()
        action = Spin(balancer, "aeracode.org", "aeracode.org", timeout=2, check_interval=1)
        balancer.fixed_action = action
        # Ensure it times out
        sock = MockSocket()
        try:
            with Timeout(2.2):
                start = time.time()
                action.handle(sock, "", "/", {})
                duration = time.time() - start
        except Timeout:
            self.fail("Spin lasted for too long")
        self.assert_(
            duration >= 1,
            "Spin did not last for long enough"
        )
        self.assertEqual(
            open(os.path.join(os.path.dirname(__file__), "..", "static", "timeout.http")).read(),
            sock.data,
        )
        # Now, ensure it picks up a change
        sock = MockSocket()
        try:
            with Timeout(2):
                def host_changer():
                    eventlet.sleep(0.7)
                    balancer.fixed_action = Empty(balancer, "aeracode.org", "aeracode.org", code=402)
                eventlet.spawn(host_changer)
                action.handle(sock, "", "/", {})
        except Timeout:
            self.fail("Spin lasted for too long")
        self.assertEqual(
            "HTTP/1.0 402 Payment Required\r\nConnection: close\r\nContent-length: 0\r\n\r\n",
            sock.data,
        )

    def test_socket_errors(self):
        for action in [
            Empty(MockBalancer(), "", "", code=500),
            Unknown(MockBalancer(), "", ""),
            Redirect(MockBalancer(), "", "", redirect_to="http://pypy.org/"),
        ]:
            sock = MockErrorSocket(errno.EPIPE)
            # Doesn't error
            action.handle(sock, "", "/", {})
            sock = MockErrorSocket(errno.EBADF)
            with self.assertRaises(socket.error) as cm:
                action.handle(sock, "", "/", {})
            self.assertEqual(cm.exception.errno, errno.EBADF)


class LiveActionTests(unittest.TestCase):
    """
    Tests that the client/API work correctly.
    """

    next_port = 30300

    def setUp(self):
        self.__class__.next_port += 3
        self.balancer = Balancer(
            [(("0.0.0.0", self.next_port), socket.AF_INET)],
            [(("0.0.0.0", self.next_port + 1), socket.AF_INET)],
            [(("0.0.0.0", self.next_port + 2), socket.AF_INET)],
            "/tmp/mantrid-test-state-2",
        )
        self.balancer_thread = eventlet.spawn(self.balancer.run)
        eventlet.sleep(0.1)
        self.balancer.hosts = {
            "test-host.com": ["static", {"type": "test"}, True],
        }
    
    def tearDown(self):
        self.balancer.running = False
        self.balancer_thread.kill()
        eventlet.sleep(0.1)

    def test_unknown(self):
        # Send a HTTP request to the balancer, ensure the response
        # is the same as the "unknown" template
        h = httplib2.Http()
        resp, content = h.request(
            "http://127.0.0.1:%i" % self.next_port,
            "GET",
        )
        self.assertEqual(
            '503',
            resp['status'],
        )
        expected_content = open(os.path.join(os.path.dirname(__file__), "..", "static", "unknown.http")).read()
        expected_content = expected_content[expected_content.index("\r\n\r\n") + 4:]
        self.assertEqual(
            expected_content,
            content,
        )

########NEW FILE########
__FILENAME__ = client
import unittest
import eventlet
import socket
from ..loadbalancer import Balancer
from ..client import MantridClient


class MockSocket(object):
    "Fake Socket class that remembers what was sent"

    def __init__(self):
        self.data = ""

    def send(self, data):
        self.data += data
        return len(data)
    
    def sendall(self, data):
        self.data += data


class ClientTests(unittest.TestCase):
    """
    Tests that the client/API work correctly.
    """

    next_port = 30200

    def setUp(self):
        self.__class__.next_port += 3
        self.balancer = Balancer(
            [(("0.0.0.0", self.next_port), socket.AF_INET)],
            [(("0.0.0.0", self.next_port + 1), socket.AF_INET)],
            [(("0.0.0.0", self.next_port + 2), socket.AF_INET)],
            "/tmp/mantrid-test-state",
        )
        self.balancer_thread = eventlet.spawn(self.balancer.run)
        eventlet.sleep(0.1)
        self.client = MantridClient("http://127.0.0.1:%i" % (self.next_port + 2))
    
    def tearDown(self):
        self.balancer.running = False
        eventlet.sleep(0.1)

    def test_set_single(self):
        "Sets a single host"
        # Check we start empty
        self.assertEqual(
            {},
            self.balancer.hosts,
        )
        self.assertEqual(
            {},
            self.balancer.stats,
        )
        # Add a single host
        self.client.set("test-host.com", ["spin", {}, False])
        # See if we got it
        self.assertEqual(
            {"test-host.com": ["spin", {}, False]},
            self.balancer.hosts,
        )
        self.assertEqual(
            {"test-host.com": {}},
            self.balancer.stats,
        )
        # Override with new settings
        self.client.set("test-host.com", ["unknown", {}, True])
        self.assertEqual(
            {"test-host.com": ["unknown", {}, True]},
            self.balancer.hosts,
        )
        self.assertEqual(
            {"test-host.com": {}},
            self.balancer.stats,
        )
        # Try a wrong setting
        self.assertRaises(
            IOError,
            self.client.set, "test-host.com", ["do-da-be-dee", {}, "bruce"],
        )
        # Delete it
        self.client.delete("test-host.com")
        self.assertEqual(
            {},
            self.balancer.hosts,
        )
        self.assertEqual(
            {},
            self.balancer.stats,
        )

    def test_set_multiple(self):
        "Sets a single host"
        # Check we start empty
        self.assertEqual(
            {},
            self.balancer.hosts,
        )
        self.assertEqual(
            {},
            self.balancer.stats,
        )
        # Add multiple hosts
        hosts = {
            "kittens.com": ["spin", {}, False],
            "khaaaaaaaaaan.com": ["unknown", {}, True],
        }
        self.client.set_all(hosts)
        self.assertEqual(
            hosts,
            self.balancer.hosts,
        )
        self.assertEqual(
            {"kittens.com": {}, "khaaaaaaaaaan.com": {}},
            self.balancer.stats,
        )
        # Change to a different set of hosts
        hosts = {
            "ceilingcat.net": ["spin", {}, False],
            "khaaaaaaaaaan.com": ["unknown", {}, True],
        }
        self.client.set_all(hosts)
        self.assertEqual(
            hosts,
            self.balancer.hosts,
        )
        self.assertEqual(
            {"ceilingcat.net": {}, "khaaaaaaaaaan.com": {}},
            self.balancer.stats,
        )

########NEW FILE########
__FILENAME__ = loadbalancer
from unittest import TestCase
from ..loadbalancer import Balancer
from ..actions import Empty, Unknown, Redirect, Spin, Proxy


class BalancerTests(TestCase):
    "Tests the main load balancer class itself"

    def test_resolution(self):
        "Tests name resolution"
        balancer = Balancer(None, None, None, None)
        balancer.hosts = {
            "localhost": [
                "empty",
                {"code": 402},
                False,
            ],
            "local.ep.io": [
                "spin",
                {},
                True,
            ],
            "http://ep.io": [
                "redirect",
                {"redirect_to": "https://www.ep.io"},
                True,
            ],
            "ep.io": [
                "proxy",
                {"backends": ["0.0.0.0:0"]},
                True,
            ],
        }
        # Test direct name resolution
        self.assertEqual(
            balancer.resolve_host("localhost").__class__,
            Empty,
        )
        self.assertEqual(
            balancer.resolve_host("local.ep.io").__class__,
            Spin,
        )
        self.assertEqual(
            balancer.resolve_host("ep.io").__class__,
            Redirect,
        )
        self.assertEqual(
            balancer.resolve_host("ep.io", "https").__class__,
            Proxy,
        )
        # Test subdomain resolution
        self.assertEqual(
            balancer.resolve_host("subdomain.localhost").__class__,
            Unknown,
        )
        self.assertEqual(
            balancer.resolve_host("subdomain.local.ep.io").__class__,
            Spin,
        )
        self.assertEqual(
            balancer.resolve_host("subdomain.ep.io").__class__,
            Redirect,
        )
        self.assertEqual(
            balancer.resolve_host("multi.level.subdomain.local.ep.io").__class__,
            Spin,
        )
        # Test nonexistent base name
        self.assertEqual(
            balancer.resolve_host("i-love-bees.com").__class__,
            Unknown,
        )

########NEW FILE########
