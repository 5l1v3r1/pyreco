__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django Kong documentation build configuration file, created by
# sphinx-quickstart on Wed Nov 18 09:17:59 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Kong'
copyright = u'2009, Eric Holscher'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.9'
# The full version, including alpha/beta/rc tags.
release = '0.9'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoKongdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoKong.tex', u'Django Kong Documentation',
   u'Eric Holscher', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}
language = 'en'

RTD_NEW_THEME = True

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG
PROJECT_DIR = os.path.dirname(__file__)

ADMINS = (
    ('Test', 'test@example.com'),
)

MANAGERS = ADMINS
DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = os.path.join(PROJECT_DIR, 'kong_db')

TIME_ZONE = 'America/Chicago'
LANGUAGE_CODE = 'en-us'
SITE_ID = 1
USE_I18N = True
MEDIA_ROOT = os.path.join(PROJECT_DIR, 'media')
MEDIA_URL = '/media/'
ADMIN_MEDIA_PREFIX = '/media/'
SECRET_KEY = 'BZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'kong.urls'

TEMPLATE_DIRS = (
    os.path.join(PROJECT_DIR, 'templates')
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.admindocs',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.humanize',
    'kong',
)


KONG_RUN_ONLINE_TESTS = True
KONG_MAIL_ADMINS = True
KONG_MAIL_ON_EVERY_FAILURE = True

#Have local changes?
try:
    from local_settings import *
except:
    pass

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.conf import settings

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    (r'^admin/doc/', include('django.contrib.admindocs.urls')),
    (r'^admin/', include(admin.site.urls)),
    (r'', include('kong.urls')),
    (r'kong/', include('kong.urls')),

)

if settings.DEBUG:
    urlpatterns += patterns('',
        (r'^%s/(?P<path>.*)$' % settings.MEDIA_URL.strip('/'), 'django.views.static.serve',
        {'document_root': settings.MEDIA_ROOT})
    )


########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from kong.models import Test, TestResult, Site, Type

class TestResultAdmin(admin.ModelAdmin):
    search_fields = ('content', 'site__slug')
    list_filter = ('succeeded',)
    list_display = ('test', 'site', 'run_date', 'succeeded')

class SiteInline(admin.TabularInline):
    fields = ('slug', 'is_live', 'servername')
    list_filter = ('is_live',)
    extra = 0
    model = Site

class TestAdmin(admin.ModelAdmin):
    search_fields = ('site', 'test')
    prepopulated_fields = {"slug": ("name",)}
    save_as = True

class SiteAdmin(admin.ModelAdmin):
    search_fields = ('servername',)
    list_display = ('servername', 'slug', 'type')
    prepopulated_fields = {"slug": ("name",)}

class TypeAdmin(admin.ModelAdmin):
    search_fields = ('slug', 'name')
    prepopulated_fields = {"slug": ("name",)}
    inlines = [
        SiteInline,
    ]

admin.site.register(Site, SiteAdmin)
admin.site.register(Type, TypeAdmin)
admin.site.register(Test, TestAdmin)
admin.site.register(TestResult, TestResultAdmin)

########NEW FILE########
__FILENAME__ = check_sites
from django.core.management.base import BaseCommand
from kong.models import Test
from kong.models import Site, Type
from optparse import OptionParser, make_option



class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option("-t", "--test", dest="test"),
        make_option("-s", "--site", dest="site"),
        make_option("-T", "--type", dest="type"),
        make_option("-l", "--list", dest="list",
                    action="store_true", default=False),
    )

    def handle(self, *args, **options):
        TEST = options.get('test')
        SITE = options.get('site')
        TYPE = options.get('type')
        LIST = options.get('list')
        passed =  True

        if TEST:
            print "Running test: %s" % TEST
            test = Test.objects.get(slug=TEST)
            passed = test.run_tests()
        elif TYPE:
            print "Running tests for type : %s" % TYPE
            type = Type.objects.get(slug=TYPE)
            passed = type.run_tests()
        elif SITE:
            print "Running tests for site : %s" % SITE
            site = Site.objects.get(slug=SITE)
            passed = site.run_tests()
        elif LIST:
            print "All Sites:"
            for site in Site.objects.all():
                print site.slug
            print "All Tests:"
            for test in Test.objects.all():
                print test.slug
        else:
            print "Running tests for all sites"
            for site in Site.objects.all():
                passed = site.run_tests()

        #This is mainly for Nagios reporting.
        if passed:
            return 0
        else:
            return 2

########NEW FILE########
__FILENAME__ = import_settings
from django.core.management.base import BaseCommand
from kong.models import HostedSite, Site, Type, Server

class Command(BaseCommand):
    "A basic command to create a site from your current DJANGO_SETTINGS_MODULE"

    def handle(self, *args, **options):
        from django.conf import settings
        HostedSite.objects.create(
            name = name,
            slug = slugify(name),
           
        )

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.db import models
from django.template import Template, Context
from django.db.models import permalink
from django.contrib.localflavor.us import models as USmodels

from kong.utils import execute_test

import datetime
import urlparse


class Site(models.Model):
    name = models.CharField(max_length=80, blank=True)
    slug = models.SlugField()
    type = models.ForeignKey('Type', related_name='sites',
                             null=True, blank=True)
    servername = models.CharField(max_length=100, default='example.com',
                                  help_text='This is the address of your actual site')
    is_live = models.BooleanField(default=True)

    def __unicode__(self):
        return "%s: %s" % (self.slug, self.servername)

    @permalink
    def get_absolute_url(self):
        return ('kong_site_detail', [self.slug])

    @property
    def url(self):
        curr_site = self.servername
        if urlparse.urlsplit(curr_site).scheme == '':
            curr_site = "http://%s" % curr_site
        return curr_site

    @property
    def all_tests(self):
        if self.type:
            return Test.objects.filter(sites=self) | Test.objects.filter(types=self.type)
        else:
            return Test.objects.filter(sites=self)

    def latest_results(self):
        """
        This returns a list of the latest testresult for each test
        defined for a site.
        """
        ret_val = []
        for test in self.all_tests.all():
            try:
                latest_result = test.test_results.filter(site=self)[0]
                ret_val.append(latest_result)
            except IndexError:
                #No result for test
                pass
        return ret_val

    def run_tests(self):
        all_passed = True
        for test in self.all_tests.all():
            passed = execute_test(self, test)
            all_passed = passed and all_passed
        return all_passed


class Type(models.Model):
    name = models.CharField(max_length=40)
    slug = models.SlugField(blank=True)

    def __unicode__(self):
        return self.name

    def all_sites(self):
        return self.sites.all()

    def run_tests(self):
        all_passed = True
        for site in self.all_sites():
            passed = site.run_tests()
            all_passed = passed and all_passed
        return all_passed


class Test(models.Model):
    name = models.CharField(max_length=250)
    slug = models.SlugField(blank=True)
    sites = models.ManyToManyField(Site, blank=True, null=True, related_name='tests')
    types = models.ManyToManyField(Type, blank=True, null=True, related_name='tests')
    body = models.TextField()

    def __unicode__(self):
        return self.name

    def render(self, site):
        return Template(self.body).render(Context({'site': site, 'test': self})).encode('utf8')

    @permalink
    def get_absolute_url(self):
        return ('kong_testresults_detail', [self.slug])

    @property
    def all_sites(self):
        return self.sites.all() | Site.objects.filter(type__in=self.types.all())

    def run_tests(self):
        all_passed = True
        for site in self.all_sites.all():
            passed = execute_test(site, self)
            all_passed = passed and all_passed
        return all_passed


class TestResult(models.Model):
    test = models.ForeignKey(Test, related_name='test_results')
    site = models.ForeignKey(Site, related_name='test_results')
    run_date = models.DateTimeField(default=datetime.datetime.now, db_index=True)
    duration = models.IntegerField(null=True)
    succeeded = models.BooleanField()
    content = models.TextField()

    class Meta:
        ordering = ('-run_date',)

    def __unicode__(self):
        return "%s for %s" % (self.test, self.site)

    @permalink
    def get_absolute_url(self):
        return ('kong_testresults_detail', [self.slug])

    def get_previous_results(self, num_results=1):
        """
        Returns X number of earlier test results for the same combination of test and site
        """
        return TestResult.objects.filter(
            test=self.test,
            site=self.site,
            pk__lt=self.pk)[:num_results]

    @property
    def failed(self):
        return not self.succeeded

    @property
    def notification_needed(self):
        """
        Checks whether result needs to be mailed to admins.
        The procedure is as follows
        (taking into account min number of consecutive failures):
        1. Find out whether current test failed
        2. Find out whether previous test failed
        3. If MAIL_ON_EVERY_FAILURE is set to False don't send new notification
           if previous test also failed
        4. If test succeeds and MAIL_ON_RECOVERY is set,
           send recovery notification if previous test failed
        """

        MAIL_ON_EVERY_FAILURE = getattr(settings, 'KONG_MAIL_ON_EVERY_FAILURE', False)
        MAIL_ON_RECOVERY = getattr(settings, 'KONG_MAIL_ON_RECOVERY', True)
        CONSECUTIVE_FAILURES = getattr(settings, 'KONG_MAIL_ON_CONSECUTIVE_FAILURES', 1)

        results = self.get_previous_results(CONSECUTIVE_FAILURES)
        results = [self.succeeded] + [result.succeeded for result in results]

        result_list = results[:CONSECUTIVE_FAILURES]

        if True in result_list or len(result_list) < CONSECUTIVE_FAILURES:
            result_failed = False
        elif len:
            result_failed = True

        prev_results = results[1:]
        if True in prev_results or len(prev_results) < CONSECUTIVE_FAILURES:
            prev_result_failed = False
        else:
            prev_result_failed = True

        if result_failed:
            if not MAIL_ON_EVERY_FAILURE and prev_result_failed:
                return False
            return True
        else:
            if MAIL_ON_RECOVERY:
                if prev_result_failed:
                    return True
        return False

########NEW FILE########
__FILENAME__ = kong_munin
from kong.models import TestResult, Test
import munin

def slugify(string):
    return string.replace('-','_')

class KongDuration(munin.Plugin):
    tests = Test.objects.all()

    def fetch(self):
        limit = len(self.tests) - 1
        results = TestResult.objects.filter(site__pk=2)[:limit]
        for result in results:
            yield ('%s.value' % slugify(result.test.slug), result.duration)
    
    def config(self):
        yield ('graph_title', 'LJWorld')
        yield ('graph_args', '-l 0 --base 1000')
        yield ('graph_vlabel', 'Duration')
        yield ('graph_scale', 'no')
        yield ('graph_category', 'kong')
        yield ('graph_info', 'Shows the duration of Kong tests.')
        for test in  self.tests:
            yield ("%s.label" % slugify(test.slug), test.name)
            yield ("%s.info" % slugify(test.slug), test.name)
            yield ("%s.draw" % slugify(test.slug), "LINE1")
 
if __name__ == '__main__':
    munin.run(KongDuration)

########NEW FILE########
__FILENAME__ = munin
"""
Originally from: http://github.com/jacobian/munin-plugins/blob/master/munin.py

Microframework for writing Munin plugins with Python.

Howto:

    * Subclass ``Plugin``.
    
    * Define at least ``fetch`` and ``config``, and possibly others (see
      below).
    
    * Add a main invocation to your script.

A simple example::

    import munin
    
    class Load(munin.Plugin):
        
        def fetch(self):
            load1, load5, load15 = open("/proc/loadavg").split(' ')[:3]
            return [
                ("load1.value", load1),
                ("load5.value", load5),
                ("load15.value", load15)
            ]
            
        def config(self):
            return [
                ("graph_title", "Load"),
                ("graph_args", "-l 0 --base 1000"),
                ("graph_vlabel", "Load"),
                ("load1.label", "1 min"),
                ("load5.label", "5 min"),
                ("load15.label", "15 min")
            ]

    if __name__ == '__main__':
        munin.run(Load)

For more complex uses, read the code. It's short.
"""

import os
import sys

class Plugin(object):
    
    def __init__(self):
        self.env = {}
        for var, default in self.__get_dynamic_attr("env_vars", None, {}).items():
            self.env[var] = os.environ.get(var, default)
        
    def __get_dynamic_attr(self, attname, arg, default=None):
        """
        Gets "something" from self, which could be an attribute or
        a callable with either 0 or 1 arguments (besides self).
        
        Stolen from django.contrib.syntication.feeds.Feed.
        """
        try:
            attr = getattr(self, attname)
        except AttributeError:
            return default
        if callable(attr):
            # Check func_code.co_argcount rather than try/excepting the
            # function and catching the TypeError, because something inside
            # the function may raise the TypeError. This technique is more
            # accurate.
            if hasattr(attr, 'func_code'):
                argcount = attr.func_code.co_argcount
            else:
                argcount = attr.__call__.func_code.co_argcount
            if argcount == 2: # one argument is 'self'
                return attr(arg)
            else:
                return attr()
        return attr
    
    def main(self, argv):
        if "_" in argv[0]: 
            _, arg = argv[0].rsplit("_", 1)
        else:
            arg = None
        args = argv[1:]
        
        if "suggest" in args and hasattr(self, "suggest"):
            for suggested in self.__get_dynamic_attr("suggest", arg):
                print suggested
            return 0
                
        if "autoconf" in args:
            if self.__get_dynamic_attr("autoconf", arg, True):
                print "yes"
                return 0
            else:
                print "no"
                return 1
                
        if "config" in args:
            for field, value in self.__get_dynamic_attr("config", arg, []):
                print "%s %s" % (field, value)
            return 0
        
        for field, value in self.__get_dynamic_attr("fetch", arg, []):
            print "%s %s" % (field, value)
        return 0
            
def run(plugin):
    if callable(plugin):
        plugin = plugin()
    sys.exit(plugin.main(sys.argv))

########NEW FILE########
__FILENAME__ = kong_tags
from django import template

register = template.Library()

@register.filter
def micro_to_milli(value):
    return value/1000

@register.filter
def render_twill(result):
    return result.test.render(result.site)

########NEW FILE########
__FILENAME__ = model_tests
from django.test import TestCase
from django.conf import settings
from django.core import mail
from django.core.management import call_command

from kong.models import Test, Site, TestResult
from kong.utils import execute_test, _send_error

class BasicTests(TestCase):

    fixtures = ['test_data.json']

    def setUp(self):
        self.test_slug = 'front-page'
        self.test = Test.objects.get(slug=self.test_slug)
        self.site = self.test.sites.all()[0]

    def test_results(self):
        self.assertEqual(str(self.site.latest_results()), '[<TestResult: Front Page for ljworld: www2.ljworld.com>]')

    def test_sites(self):
        self.assertEqual(str(self.test.all_sites), '[<Site: ljworld: www2.ljworld.com>]')

    def test_sending_errors(self):
        settings.KONG_MAIL_MANAGERS = True
        _send_error(self.site, self.test, 'Awesome stuffs')
        self.assertEqual(len(mail.outbox), 1)
        self.assertTrue('example.com' in mail.outbox[0].body)

    def test_execution(self):
        if getattr(settings, 'KONG_RUN_ONLINE_TESTS', False):
            result = execute_test(self.site, self.test)
            #If this fails because our sites are down, I'm sorry :D
            self.assertTrue(result)
            #TODO: Fix Django so you can check return values here
            #For now we can just manually inspect it.
            call_command('check_sites')
        else:
            print "WARNING: Skipping online tests. Set KONG_RUN_ONLINE_TESTS to True in your settings to run them"

class NotificationTests(TestCase):

    fixtures = ['test_data.json']

    def setUp(self):
        self.test = Test.objects.get(slug='front-page')
        self.site = self.test.sites.all()[0]

        settings.KONG_MAIL_ON_EVERY_FAILURE = False
        settings.KONG_MAIL_ON_RECOVERY = True
        settings.KONG_MAIL_ON_CONSECUTIVE_FAILURES = 1

    def test_mail_on_every_failure(self):

        result = TestResult.objects.create(
            site=self.site,
            test=self.test,
            succeeded=False,
            duration=1,
            content='test'
        )
        self.assertEqual(result.notification_needed, True)

        result = TestResult.objects.create(
            site=self.site,
            test=self.test,
            succeeded=False,
            duration=1,
            content='test'
        )
        self.assertEqual(result.notification_needed, False)

        settings.KONG_MAIL_ON_EVERY_FAILURE = True
        self.assertEqual(result.notification_needed, True)


    def test_mail_on_recovery(self):

        result = TestResult.objects.create(
            site=self.site,
            test=self.test,
            succeeded=False,
            duration=1,
            content='test'
        )
        result = TestResult.objects.create(
            site=self.site,
            test=self.test,
            succeeded=True,
            duration=1,
            content='test'
        )
        self.assertEqual(result.notification_needed, True)

        settings.KONG_MAIL_ON_RECOVERY = False
        self.assertEqual(result.notification_needed, False)


    def test_consecutive_failures(self):

        result = TestResult.objects.create(
            site=self.site,
            test=self.test,
            succeeded=False,
            duration=1,
            content='test'
        )
        self.assertEqual(result.notification_needed, True)

        settings.KONG_MAIL_ON_CONSECUTIVE_FAILURES = 2
        self.assertEqual(result.notification_needed, False)

        result = TestResult.objects.create(
            site=self.site,
            test=self.test,
            succeeded=False,
            duration=1,
            content='test'
        )
        self.assertEqual(result.notification_needed, True)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
     (r'^admin/doc/', include('django.contrib.admindocs.urls')),
     (r'^admin/', include(admin.site.urls)),
     url(r'^$', 'kong.views.index', name='kong_index'),
     url(r'index/$', 'kong.views.index', name='kong_index'),
     url(r'failed/$', 'kong.views.failed', name='kong_failed'),
     url(r'dashboard/$', 'kong.views.dashboard', name='kong_dashboard'),

     url(r'^sites/(?P<site_slug>.*?)/(?P<test_slug>.*?)/run/$',
         'kong.views.run_test_on_site',
         name='kong_run_test_on_site'
         ),
     url(r'^sites/(?P<site_slug>.*?)/(?P<test_slug>.*?)/',
         'kong.views.test_detail_for_site',
         name='kong_testresult_for_site'
         ),
     url(r'^sites/(?P<site_slug>.*?)/',
         'kong.views.site_detail',
         name='kong_site_detail'
         ),
     url(r'^tests/(?P<test_slug>.*?)/(?P<num_total>\d+)/(?P<div_by>\d+)/',
         'kong.views.graph_test',
         name='kong_graph_test'
         ),
     url(r'^tests/(?P<test_slug>.*?)/(?P<pk>\d+)/',
         'kong.views.test_detail',
         name='kong_test_detail'
         ),
)

########NEW FILE########
__FILENAME__ = utils
import datetime
import StringIO
import sys

from django.conf import settings
from django.core.mail import mail_managers, mail_admins
from django.template.loader import render_to_string
from django.contrib.sites.models import Site

from twill.parse import execute_string
from twill.errors import TwillAssertionError

def _send_error(kong_site, test, content):
    real_site = Site.objects.get_current()
    message = render_to_string('kong/failed_email.txt', {'kong_site': kong_site,
                                                         'test': test,
                                                         'error': content,
                                                         'real_site': real_site})
    if getattr(settings, 'KONG_MAIL_MANAGERS', False):
        mail_managers('Kong Test Failed: %s (%s)' % (test, kong_site), message)
    if getattr(settings, 'KONG_MAIL_ADMINS', False):
        mail_admins('Kong Test Failed: %s (%s)' % (test, kong_site), message)

def _send_recovery(kong_site, test, content):
    real_site = Site.objects.get_current()
    message = render_to_string(
        'kong/recovered_email.txt', {
            'kong_site': kong_site,
            'test': test,
            'content': content,
            'real_site': real_site
        }
    )
    if getattr(settings, 'KONG_MAIL_MANAGERS', False):
        mail_managers('Kong Test Recovered: %s (%s)' % (test, kong_site), message)
    if getattr(settings, 'KONG_MAIL_ADMINS', False):
        mail_admins('Kong Test Recovered: %s (%s)' % (test, kong_site), message)

def execute_test(site, test):
    import twill.commands as commands
    #Avoid circular import
    from kong.models import TestResult
    twill_script = test.render(site)
    content = ''
    old_err = sys.stderr
    new_err = StringIO.StringIO()
    commands.ERR = new_err

    now = datetime.datetime.now()
    try:
        if getattr(settings, 'KONG_RESET_BROWSER', False):
            execute_string(twill_script, no_reset = False)
        else:
            execute_string(twill_script)
        succeeded = True
        content = new_err.getvalue().strip()
    except Exception, e:
        succeeded = False
        content = new_err.getvalue().strip() + "\n\nException:\n\n" + str(e)

    end = datetime.datetime.now()
    duration = end - now
    duration = duration.microseconds
    commands.ERR = old_err
    result = TestResult.objects.create(site=site,
                                       test=test,
                                       succeeded=succeeded,
                                       duration=duration,
                                       content=content)

    if result.notification_needed and result.failed:
        _send_error(site, test, content)
    if result.notification_needed and result.succeeded:
        _send_recovery(site, test, content)

    return succeeded


########NEW FILE########
__FILENAME__ = views
import calendar
from collections import defaultdict
import itertools

from django.shortcuts import render_to_response
from django.template.context import RequestContext
from django.views.generic import list_detail

from kong.models import TestResult, Test
from kong.utils import execute_test
from kong.models import Site, Type

def _render_to_result_list(request, sites, template_name='kong/index.html'):
    ret_val = defaultdict(list)
    flot_val = {}
    for site in sites:
        results = site.latest_results()
        ret_val[site.slug].extend(results)
        for result in results:
            flot_val["%s-%s" % (result.site.slug, result.test.slug)] = flotify(result)
    return render_to_response(template_name,
                       {'results': ret_val.items(),
                        'flot_list': flot_val},
                       context_instance=RequestContext(request))

def split_seq(iterable, size):
    it = iter(iterable)
    item = list(itertools.islice(it, size))
    while item:
        yield item
        item = list(itertools.islice(it, size))


def get_timestamp(time):
    #Need this for flot timestamps..
    return float(calendar.timegm(time.timetuple()) * 1000)

def flotify(result, num=50):
    """
    Return a list of (timestamp, duration) sets for test result.
    """
    results = list(TestResult.objects.filter(test=result.test, site=result.site)[:num])
    results.reverse()
    return [[get_timestamp(result.run_date), result.duration/1000] for result in results]

def graphify(sites, test, num_total, div_by):
    num_split = int(num_total)/int(div_by)
    flot_val = defaultdict(list)
    for site in sites:
        tests = list(TestResult.objects.filter(test=test, site=site)[:num_total])
        tests.reverse()
        for result_list in split_seq(tests, num_split):
            time = sum([result.duration/1000 for result in result_list])/len(result_list)
            flot_val[site.slug].append([get_timestamp(result_list[0].run_date), time])
    return flot_val


def index(request):
    sites = Site.objects.all()
    return _render_to_result_list(request, sites)

def site_detail(request, site_slug):
    sites = Site.objects.filter(slug=site_slug)
    return _render_to_result_list(request, sites)

def test_detail(request, test_slug, pk):
    result = TestResult.objects.get(pk=pk)
    return render_to_response('kong/test_detail.html',
                       {'result': result},
                       context_instance=RequestContext(request))

def test_detail_for_site(request, site_slug, test_slug):
    test = Test.objects.get(slug=test_slug)
    site = Site.objects.get(slug=site_slug)
    result = TestResult.objects.filter(test=test, site=site)[0]
    flot_list = flotify(result)
    return render_to_response('kong/test_list_for_site.html',
                       {'result': result,
                        'flot_list': flot_list
                        },
                       context_instance=RequestContext(request))

def run_test_on_site(request, site_slug, test_slug):
    test = Test.objects.get(slug=test_slug)
    site = Site.objects.get(slug=site_slug)
    execute_test(site, test)
    return test_detail_for_site(request, site_slug, test_slug)


def graph_test(request, test_slug, num_total=5000, div_by=50):
    test = Test.objects.get(slug=test_slug)
    sites = test.all_sites.all()
    flot_val = graphify(sites, test, num_total, div_by)
    return render_to_response('kong/graph_test.html',
                              {'sites': list(sites),
                               'flot_list': flot_val.items(),
                                'test': test,
                              },
                              context_instance=RequestContext(request))



def dashboard(request):
    ret_val = {}
    for site in Site.objects.all():
        results = site.latest_results()
        succ = True
        for result in results:
            if not result.succeeded:
                succ = False
                fail = result
        ret_val[site.slug] = succ
    return render_to_response('kong/dashboard.html',
                       {'results': ret_val},
                       context_instance=RequestContext(request))

def failed(request):
    results = TestResult.objects.filter(succeeded=False)[:20]
    return render_to_response('kong/failed.html',
                       {'results': results},
                       context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = migrate
from django.db import connection

cursor = connection.cursor()
cursor.execute('alter table kong_site add column "servername" varchar(100)')
cursor.execute('alter table kong_site drop column client_id')
cursor.execute('alter table kong_site drop column settings')
cursor.execute('alter table kong_site drop column pythonpath')
cursor.execute('select site_ptr_id, servername from kong_hostedsite')
rows = cursor.fetchall()
names = dict([(row[0], row[1]) for row in rows])

from kong.models import Site
for site in Site.objects.all():
    site.servername = names[site.pk]
    site.save()

"""
cursor.execute('delete table kong_alias')
cursor.execute('delete table kong_client')
cursor.execute('delete table kong_deploytarget')
cursor.execute('delete table kong_deploytarget_servers')
cursor.execute('delete table kong_hostedsite')
cursor.execute('delete table kong_hostedsite_on_servers')
cursor.execute('delete table kong_server')
cursor.execute('delete table kong_test_sites')
"""

########NEW FILE########
