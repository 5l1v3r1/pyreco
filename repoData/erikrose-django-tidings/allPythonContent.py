__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-tidings documentation build configuration file, created by
# sphinx-quickstart on Thu Mar 31 13:40:27 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-tidings'
copyright = u'2011, The Mozilla Foundation'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-tidingsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-tidings.tex', u'django-tidings Documentation',
   u'Erik Rose, Paul Craciunoiu, and the support.mozilla.com team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-tidings', u'django-tidings Documentation',
     [u'Erik Rose, Paul Craciunoiu, and the support.mozilla.com team'], 1)
]

########NEW FILE########
__FILENAME__ = fabfile
"""Creating standalone Django apps is a PITA because you're not in a project,
so you don't have a settings.py file. I can never remember to define
DJANGO_SETTINGS_MODULE, so I run these commands which get the right env
automatically.

"""
import functools
import os

from fabric.api import local, cd


local = functools.partial(local, capture=False)

ROOT = os.path.abspath(os.path.dirname(__file__))

os.environ['DJANGO_SETTINGS_MODULE'] = 'test_app.settings'
os.environ['PYTHONPATH'] = (((os.environ['PYTHONPATH'] + ':') if
    os.environ.get('PYTHONPATH') else '') + ROOT)


def doc(kind='html'):
    """Build Sphinx docs.

    Requires Sphinx to be installed.

    """
    with cd('docs'):
        local('make clean %s' % kind)

def shell():
    local('django-admin.py shell')

def test():
    # Just calling nosetests results in SUPPORTS_TRANSACTIONS KeyErrors.
    local('test_app/manage.py test tidings')

def updoc():
    """Build Sphinx docs and upload them to packages.python.org.

    Requires Sphinx-PyPI-upload to be installed.

    """
    doc('html')
    local('python setup.py upload_sphinx --upload-dir=docs/_build/html')

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_app.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = settings
import djcelery
import os

# Make filepaths relative to settings.
ROOT = os.path.dirname(os.path.abspath(__file__))
path = lambda *a: os.path.join(ROOT, *a)

# Django
DATABASES = {
    'default': {
        'NAME': 'test.db',
        'ENGINE': 'django.db.backends.sqlite3',
    }
}
DEBUG = True
INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sites',
    'djcelery',
    'tidings',
    'south',
    'test_app',
    'tidings.tests.mockapp',
]
ROOT_URLCONF = 'test_app.urls'
SITE_ID = 1
TEMPLATE_DEBUG = True
TEST_RUNNER = 'django_nose.runner.NoseTestSuiteRunner'

# Jinja
TEMPLATE_DIRS = [
    # Put strings here, like "/home/html/django_templates"
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    path('templates')
]
TEMPLATE_LOADERS = (
    'jingo.Loader',
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
    # 'django.template.loaders.eggs.Loader',
)
JINGO_INCLUDE_PATTERN = r'\.html'

# Celery
djcelery.setup_loader()
CELERY_ALWAYS_EAGER = True
CELERY_EAGER_PROPAGATES_EXCEPTIONS = True  # Explode loudly during tests.

# Tidings
TIDINGS_FROM_ADDRESS = 'nobody@example.com'
TIDINGS_CONFIRM_ANONYMOUS_WATCHES = True

SECRET_KEY = 'yada-yada'

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import include, patterns


urlpatterns = patterns('',
    (r'^', include('tidings.urls')))


handler404 = 'django.views.defaults.page_not_found'
handler500 = 'django.views.defaults.server_error'

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from tidings.models import Watch, WatchFilter


class FilterInline(admin.TabularInline):
    model = WatchFilter


class WatchAdmin(admin.ModelAdmin):
    list_filter = ['content_type', 'event_type']
    raw_id_fields = ['user']
    inlines = [FilterInline]


class WatchFilterAdmin(admin.ModelAdmin):
    list_filter = ['name']
    raw_id_fields = ['watch']


admin.site.register(Watch, WatchAdmin)
admin.site.register(WatchFilter, WatchFilterAdmin)

########NEW FILE########
__FILENAME__ = events
from collections import Sequence
import random
from smtplib import SMTPException

from django.conf import settings
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.core import mail
from django.db.models import Q

from celery.task import task

from tidings.models import Watch, WatchFilter, EmailUser, multi_raw
from tidings.utils import collate, hash_to_unsigned


class ActivationRequestFailed(Exception):
    """Raised when activation request fails, e.g. if email could not be sent"""
    def __init__(self, msgs):
        self.msgs = msgs


def _unique_by_email(users_and_watches):
    """Given a sequence of (User/EmailUser, [Watch, ...]) pairs
    clustered by email address (which is never ''), yield from each
    cluster a single pair like this::

      (User/EmailUser, [Watch, Watch, ...]).

    The User/Email is that of...
    (1) the first incoming pair where the User has an email and is not
        anonymous, or, if there isn't such a user...
    (2) the first pair.

    The list of Watches consists of all those found in the cluster.

    Compares email addresses case-insensitively.

    """
    def ensure_user_has_email(user, cluster_email):
        """Make sure the user in the user-watch pair has an email address.

        The caller guarantees us an email from either the user or the watch. If
        the passed-in user has no email, we return an EmailUser instead having
        the email address from the watch.

        """
        # Some of these cases shouldn't happen, but we're tolerant.
        if not getattr(user, 'email', ''):
            user = EmailUser(cluster_email)
        return user

    # TODO: Do this instead with clever SQL that somehow returns just the
    # best row for each email.

    cluster_email = ''  # email of current cluster
    favorite_user = None  # best user in cluster so far
    watches = []  # all watches in cluster
    for u, w in users_and_watches:
        # w always has at least 1 Watch. All the emails are the same.
        row_email = u.email or w[0].email
        if cluster_email.lower() != row_email.lower():
            # Starting a new cluster.
            if cluster_email != '':
                # Ship the favorites from the previous cluster:
                yield ensure_user_has_email(favorite_user, cluster_email), watches
            favorite_user, watches = u, []
            cluster_email = row_email
        elif ((not favorite_user.email or u.is_anonymous()) and
              u.email and not u.is_anonymous()):
            favorite_user = u
        watches.extend(w)
    if favorite_user is not None:
        yield ensure_user_has_email(favorite_user, cluster_email), watches


class Event(object):
    """Abstract base class for events

    An :class:`Event` represents, simply, something that occurs. A
    :class:`~tidings.models.Watch` is a record of someone's interest in a
    certain type of :class:`Event`, distinguished by ``Event.event_type``.

    Fire an Event (``SomeEvent.fire()``) from the code that causes the
    interesting event to occur. Fire it any time the event *might* have
    occurred. The Event will determine whether conditions are right to actually
    send notifications; don't succumb to the temptation to do these tests
    outside the Event, because you'll end up repeating yourself if the event is
    ever fired from more than one place.

    :class:`Event` subclasses can optionally represent a more limited scope of
    interest by populating the ``Watch.content_type`` field and/or adding
    related :class:`~tidings.models.WatchFilter` rows holding name/value pairs,
    the meaning of which is up to each individual subclass. NULL values are
    considered wildcards.

    :class:`Event` subclass instances must be pickleable so they can be
    shuttled off to celery tasks.

    """
    # event_type = 'hamster modified'  # key for the event_type column
    content_type = None  # or, for example, Hamster

    #: Possible filter keys, for validation only. For example:
    #: ``set(['color', 'flavor'])``
    filters = set()

    def fire(self, exclude=None):
        """Asynchronously notify everyone watching the event.

        We are explicit about sending notifications; we don't just key off
        creation signals, because the receiver of a post_save signal has no
        idea what just changed, so it doesn't know which notifications to send.
        Also, we could easily send mail accidentally: for instance, during
        tests. If we want implicit event firing, we can always register a
        signal handler that calls :meth:`fire()`.

        :arg exclude: If a saved user is passed in, that user will not be
          notified, though anonymous notifications having the same email
          address may still be sent. A sequence of users may also be passed in.

        """
        # Tasks don't receive the `self` arg implicitly.
        self._fire_task.delay(self, exclude=exclude)

    @task
    def _fire_task(self, exclude=None):
        """Build and send the emails as a celery task."""
        connection = mail.get_connection(fail_silently=True)
        # Warning: fail_silently swallows errors thrown by the generators, too.
        connection.open()
        for m in self._mails(self._users_watching(exclude=exclude)):
            connection.send_messages([m])

    @classmethod
    def _validate_filters(cls, filters):
        """Raise a TypeError if ``filters`` contains any keys inappropriate to
        this event class."""
        for k in filters.iterkeys():
            if k not in cls.filters:
                # Mirror "unexpected keyword argument" message:
                raise TypeError("%s got an unsupported filter type '%s'" %
                                (cls.__name__, k))

    def _users_watching_by_filter(self, object_id=None, exclude=None,
                                  **filters):
        """Return an iterable of (``User``/:class:`~tidings.models.EmailUser`,
        [:class:`~tidings.models.Watch` objects]) tuples watching the event.

        Of multiple Users/EmailUsers having the same email address, only one is
        returned. Users are favored over EmailUsers so we are sure to be able
        to, for example, include a link to a user profile in the mail.

        The list of :class:`~tidings.models.Watch` objects includes both
        those tied to the given User (if there is a registered user)
        and to any anonymous Watch having the same email address. This
        allows you to include all relevant unsubscribe URLs in a mail,
        for example. It also lets you make decisions in the
        :meth:`~tidings.events.EventUnion._mails()` method of
        :class:`~tidings.events.EventUnion` based on the kinds of
        watches found.

        "Watching the event" means having a Watch whose ``event_type`` is
        ``self.event_type``, whose ``content_type`` is ``self.content_type`` or
        ``NULL``, whose ``object_id`` is ``object_id`` or ``NULL``, and whose
        WatchFilter rows match as follows: each name/value pair given in
        ``filters`` must be matched by a related WatchFilter, or there must be
        no related WatchFilter having that name. If you find yourself wanting
        the lack of a particularly named WatchFilter to scuttle the match, use
        a different event_type instead.

        :arg exclude: If a saved user is passed in as this argument, that user
            will never be returned, though anonymous watches having the same
            email address may. A sequence of users may also be passed in.

        """
        # I don't think we can use the ORM here, as there's no way to get a
        # second condition (name=whatever) into a left join. However, if we
        # were willing to have 2 subqueries run for every watch row--select
        # {are there any filters with name=x?} and select {is there a filter
        # with name=x and value=y?}--we could do it with extra(). Then we could
        # have EventUnion simply | the QuerySets together, which would avoid
        # having to merge in Python.

        if exclude is None:
            exclude = []
        elif not isinstance(exclude, Sequence):
            exclude = [exclude]

        def filter_conditions():
            """Return joins, WHERE conditions, and params to bind to them in
            order to check a notification against all the given filters."""
            # Not a one-liner. You're welcome. :-)
            self._validate_filters(filters)
            joins, wheres, join_params, where_params = [], [], [], []
            for n, (k, v) in enumerate(filters.iteritems()):
                joins.append(
                    'LEFT JOIN tidings_watchfilter f{n} '
                    'ON f{n}.watch_id=w.id '
                        'AND f{n}.name=%s'.format(n=n))
                join_params.append(k)
                wheres.append('(f{n}.value=%s '
                              'OR f{n}.value IS NULL)'.format(n=n))
                where_params.append(hash_to_unsigned(v))
            return joins, wheres, join_params + where_params

        # Apply watchfilter constraints:
        joins, wheres, params = filter_conditions()

        # Start off with event_type, which is always a constraint. These go in
        # the `wheres` list to guarantee that the AND after the {wheres}
        # substitution in the query is okay.
        wheres.append('w.event_type=%s')
        params.append(self.event_type)

        # Constrain on other 1-to-1 attributes:
        if self.content_type:
            wheres.append('(w.content_type_id IS NULL '
                          'OR w.content_type_id=%s)')
            params.append(ContentType.objects.get_for_model(
                          self.content_type).id)
        if object_id:
            wheres.append('(w.object_id IS NULL OR w.object_id=%s)')
            params.append(object_id)
        if exclude:
            # Don't try excluding unsaved Users:1
            if not all(e.id for e in exclude):
                raise ValueError("Can't exclude an unsaved User.")

            wheres.append('(u.id IS NULL OR u.id NOT IN (%s))' %
                          ', '.join('%s' for e in exclude))
            params.extend(e.id for e in exclude)

        def get_fields(model):
            if hasattr(model._meta, '_fields'):
                # For django versions < 1.6
                return model._meta._fields()
            else:
                # For django versions >= 1.6
                return model._meta.fields

        model_to_fields = dict((m, [f.get_attname() for f in get_fields(m)])
                               for m in [User, Watch])
        query_fields = [
            'u.{0}'.format(field) for field in model_to_fields[User]]
        query_fields.extend([
            'w.{0}'.format(field) for field in model_to_fields[Watch]])

        query = (
            'SELECT {fields} '
            'FROM tidings_watch w '
            'LEFT JOIN auth_user u ON u.id=w.user_id {joins} '
            'WHERE {wheres} '
            'AND (length(w.email)>0 OR length(u.email)>0) '
            'AND w.is_active '
            'ORDER BY u.email DESC, w.email DESC').format(
            fields=', '.join(query_fields),
            joins=' '.join(joins),
            wheres=' AND '.join(wheres))
        # IIRC, the DESC ordering was something to do with the placement of
        # NULLs. Track this down and explain it.

        # Put watch in a list just for consistency. Once the pairs go through
        # _unique_by_email, watches will be in a list, and EventUnion uses the
        # same function to union already-list-enclosed pairs from individual
        # events.
        return _unique_by_email((u, [w]) for u, w in
                                multi_raw(query, params, [User, Watch], model_to_fields))

    @classmethod
    def _watches_belonging_to_user(cls, user_or_email, object_id=None,
                                   **filters):
        """Return a QuerySet of watches having the given user or email, having
        (only) the given filters, and having the event_type and content_type
        attrs of the class.

        Matched Watches may be either confirmed and unconfirmed. They may
        include duplicates if the get-then-create race condition in
        :meth:`notify()` allowed them to be created.

        If you pass an email, it will be matched against only the email
        addresses of anonymous watches. At the moment, the only integration
        point planned between anonymous and registered watches is the claiming
        of anonymous watches of the same email address on user registration
        confirmation.

        If you pass the AnonymousUser, this will return an empty QuerySet.

        """
        # If we have trouble distinguishing subsets and such, we could store a
        # number_of_filters on the Watch.
        cls._validate_filters(filters)

        if isinstance(user_or_email, basestring):
            user_condition = Q(email=user_or_email)
        elif not user_or_email.is_anonymous():
            user_condition = Q(user=user_or_email)
        else:
            return Watch.objects.none()

        # Filter by stuff in the Watch row:
        watches = getattr(Watch, 'uncached', Watch.objects).filter(
            user_condition,
            Q(content_type=ContentType.objects.get_for_model(cls.content_type))
                if cls.content_type
                else Q(),
            Q(object_id=object_id)
                if object_id
                else Q(),
            event_type=cls.event_type).extra(
                where=['(SELECT count(*) FROM tidings_watchfilter WHERE '
                       'tidings_watchfilter.watch_id='
                       'tidings_watch.id)=%s'],
                params=[len(filters)])
        # Optimization: If the subselect ends up being slow, store the number
        # of filters in each Watch row or try a GROUP BY.

        # Apply 1-to-many filters:
        for k, v in filters.iteritems():
            watches = watches.filter(filters__name=k,
                                     filters__value=hash_to_unsigned(v))

        return watches

    @classmethod
    # Funny arg name to reserve use of nice ones for filters
    def is_notifying(cls, user_or_email_, object_id=None, **filters):
        """Return whether the user/email is watching this event (either
        active or inactive watches), conditional on meeting the criteria in
        ``filters``.

        Count only watches that match the given filters exactly--not ones which
        match merely a superset of them. This lets callers distinguish between
        watches which overlap in scope. Equivalently, this lets callers check
        whether :meth:`notify()` has been called with these arguments.

        Implementations in subclasses may take different arguments--for
        example, to assume certain filters--though most will probably just use
        this. However, subclasses should clearly document what filters they
        supports and the meaning of each.

        Passing this an ``AnonymousUser`` always returns ``False``. This means
        you can always pass it ``request.user`` in a view and get a sensible
        response.

        """
        return cls._watches_belonging_to_user(user_or_email_,
                                              object_id=object_id,
                                              **filters).exists()

    @classmethod
    def notify(cls, user_or_email_, object_id=None, **filters):
        """Start notifying the given user or email address when this event
        occurs and meets the criteria given in ``filters``.

        Return the created (or the existing matching) Watch so you can call
        :meth:`~tidings.models.Watch.activate()` on it if you're so inclined.

        Implementations in subclasses may take different arguments; see the
        docstring of :meth:`is_notifying()`.

        Send an activation email if an anonymous watch is created and
        :data:`~django.conf.settings.TIDINGS_CONFIRM_ANONYMOUS_WATCHES` is
        ``True``. If the activation request fails, raise a
        ActivationRequestFailed exception.

        Calling :meth:`notify()` twice for an anonymous user will send the
        email each time.

        """
        # A test-for-existence-then-create race condition exists here, but it
        # doesn't matter: de-duplication on fire() and deletion of all matches
        # on stop_notifying() nullify its effects.
        try:
            # Pick 1 if >1 are returned:
            watch = cls._watches_belonging_to_user(
                user_or_email_,
                object_id=object_id,
                **filters)[0:1].get()
        except Watch.DoesNotExist:
            create_kwargs = {}
            if cls.content_type:
                create_kwargs['content_type'] = \
                    ContentType.objects.get_for_model(cls.content_type)
            create_kwargs['email' if isinstance(user_or_email_, basestring)
                          else 'user'] = user_or_email_
            # Letters that can't be mistaken for other letters or numbers in
            # most fonts, in case people try to type these:
            distinguishable_letters = \
                'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRTUVWXYZ'
            secret = ''.join(random.choice(distinguishable_letters)
                             for x in xrange(10))
            # Registered users don't need to confirm, but anonymous users do.
            is_active = ('user' in create_kwargs or
                          not settings.TIDINGS_CONFIRM_ANONYMOUS_WATCHES)
            if object_id:
                create_kwargs['object_id'] = object_id
            watch = Watch.objects.create(
                secret=secret,
                is_active=is_active,
                event_type=cls.event_type,
                **create_kwargs)
            for k, v in filters.iteritems():
                WatchFilter.objects.create(watch=watch, name=k,
                                           value=hash_to_unsigned(v))
        # Send email for inactive watches.
        if not watch.is_active:
            email = watch.user.email if watch.user else watch.email
            message = cls._activation_email(watch, email)
            try:
                message.send()
            except SMTPException, e:
                watch.delete()
                raise ActivationRequestFailed(e.recipients)
        return watch

    @classmethod
    def stop_notifying(cls, user_or_email_, **filters):
        """Delete all watches matching the exact user/email and filters.

        Delete both active and inactive watches. If duplicate watches
        exist due to the get-then-create race condition, delete them all.

        Implementations in subclasses may take different arguments; see the
        docstring of :meth:`is_notifying()`.

        """
        cls._watches_belonging_to_user(user_or_email_, **filters).delete()

    # TODO: If GenericForeignKeys don't give us cascading deletes, make a
    # stop_notifying_all(**filters) or something. It should delete any watch of
    # the class's event_type and content_type and having filters matching each
    # of **filters. Even if there are additional filters on a watch, that watch
    # should still be deleted so we can delete, for example, any watch that
    # references a certain Question instance. To do that, factor such that you
    # can effectively call _watches_belonging_to_user() without it calling
    # extra().

    # Subclasses should implement the following:

    def _mails(self, users_and_watches):
        """Return an iterable yielding an EmailMessage to send to each user.

        :arg users_and_watches: an iterable of (User or EmailUser, [Watches])
            pairs where the first element is the user to send to and the second
            is a list of watches (usually just one) that indicated the
            user's interest in this event

        :meth:`~tidings.utils.emails_with_users_and_watches()` can come in
        handy for generating mails from Django templates.

        """
        # Did this instead of mail() because a common case might be sending the
        # same mail to many users. mail() would make it difficult to avoid
        # redoing the templating every time.
        raise NotImplementedError

    def _users_watching(self, **kwargs):
        """Return an iterable of Users and EmailUsers watching this event
        and the Watches that map them to it.

        Each yielded item is a tuple: (User or EmailUser, [list of Watches]).

        Default implementation returns users watching this object's event_type
        and, if defined, content_type.

        """
        return self._users_watching_by_filter(**kwargs)

    @classmethod
    def _activation_email(cls, watch, email):
        """Return an EmailMessage to send to anonymous watchers.

        They are expected to follow the activation URL sent in the email to
        activate their watch, so you should include at least that.

        """
        # TODO: basic implementation.
        return mail.EmailMessage('TODO', 'Activate!',
                                 settings.TIDINGS_FROM_ADDRESS,
                                 [email])

    @classmethod
    def _activation_url(cls, watch):
        """Return a URL pointing to a view which :meth:`activates
        <tidings.models.Watch.activate()>` a watch.

        TODO: provide generic implementation of this before liberating.
        Generic implementation could involve a setting to the default
        ``reverse()`` path, e.g. ``'tidings.activate_watch'``.

        """
        raise NotImplementedError

    @classmethod
    def description_of_watch(cls, watch):
        """Return a description of the Watch which can be used in emails.

        For example, "changes to English articles"

        """
        raise NotImplementedError


class EventUnion(Event):
    """Fireable conglomeration of multiple events

    Use this when you want to send a single mail to each person watching any of
    several events. For example, this sends only 1 mail to a given user, even
    if he was being notified of all 3 events::

        EventUnion(SomeEvent(), OtherEvent(), ThirdEvent()).fire()

    """
    # Calls some private methods on events, but this and Event are good
    # friends.

    def __init__(self, *events):
        """:arg events: the events of which to take the union"""
        super(EventUnion, self).__init__()
        self.events = events

    def _mails(self, users_and_watches):
        """Default implementation calls the
        :meth:`~tidings.events.Event._mails()` of my first event but may
        pass it any of my events as ``self``.

        Use this default implementation when the content of each event's mail
        template is essentially the same, e.g. "This new post was made.
        Enjoy.". When the receipt of a second mail from the second event would
        add no value, this is a fine choice. If the second event's email would
        add value, you should probably fire both events independently and let
        both mails be delivered. Or, if you would like to send a single mail
        with a custom template for a batch of events, just subclass
        :class:`EventUnion` and override this method.

        """
        return self.events[0]._mails(users_and_watches)

    def _users_watching(self, **kwargs):
        # Get a sorted iterable of user-watches pairs:
        users_and_watches = collate(
            *[e._users_watching(**kwargs) for e in self.events],
            key=lambda (user, watch): user.email.lower(),
            reverse=True)

        # Pick the best User out of each cluster of identical email addresses:
        return _unique_by_email(users_and_watches)


class InstanceEvent(Event):
    """Abstract superclass for watching a specific instance of a Model.

    Subclasses must specify an ``event_type`` and should specify a
    ``content_type``.

    """
    def __init__(self, instance, *args, **kwargs):
        """:arg instance: the instance someone would have to be watching in order to be notified when this event is fired"""
        super(InstanceEvent, self).__init__(*args, **kwargs)
        self.instance = instance

    @classmethod
    def notify(cls, user_or_email, instance):
        """Create, save, and return a watch which fires when something
        happens to ``instance``."""
        return super(InstanceEvent, cls).notify(user_or_email,
                                                object_id=instance.pk)

    @classmethod
    def stop_notifying(cls, user_or_email, instance):
        """Delete the watch created by notify."""
        super(InstanceEvent, cls).stop_notifying(user_or_email,
                                                 object_id=instance.pk)

    @classmethod
    def is_notifying(cls, user_or_email, instance):
        """Check if the watch created by notify exists."""
        return super(InstanceEvent, cls).is_notifying(user_or_email,
                                                      object_id=instance.pk)

    def _users_watching(self, **kwargs):
        """Return users watching this instance."""
        return self._users_watching_by_filter(object_id=self.instance.pk,
                                              **kwargs)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
from south.db import db
from south.v2 import SchemaMigration


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Watch'
        db.create_table('tidings_watch', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('event_type', self.gf('django.db.models.fields.CharField')(max_length=30, db_index=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'], null=True, blank=True)),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, db_index=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'], null=True, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(db_index=True, max_length=75, null=True, blank=True)),
            ('secret', self.gf('django.db.models.fields.CharField')(max_length=10, null=True, blank=True)),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
        ))
        db.send_create_signal('tidings', ['Watch'])

        # Adding model 'WatchFilter'
        db.create_table('tidings_watchfilter', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('watch', self.gf('django.db.models.fields.related.ForeignKey')(related_name='filters', to=orm['tidings.Watch'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=20)),
            ('value', self.gf('django.db.models.fields.PositiveIntegerField')()),
        ))
        db.send_create_signal('tidings', ['WatchFilter'])

        # Adding unique constraint on 'WatchFilter', fields ['name', 'watch']
        db.create_unique('tidings_watchfilter', ['name', 'watch_id'])

    def backwards(self, orm):
        # Removing unique constraint on 'WatchFilter', fields ['name', 'watch']
        db.delete_unique('tidings_watchfilter', ['name', 'watch_id'])

        # Deleting model 'Watch'
        db.delete_table('tidings_watch')

        # Deleting model 'WatchFilter'
        db.delete_table('tidings_watchfilter')

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'tidings.watch': {
            'Meta': {'object_name': 'Watch'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'max_length': '75', 'null': 'True', 'blank': 'True'}),
            'event_type': ('django.db.models.fields.CharField', [], {'max_length': '30', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'db_index': 'True'}),
            'secret': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'null': 'True', 'blank': 'True'})
        },
        'tidings.watchfilter': {
            'Meta': {'unique_together': "(('name', 'watch'),)", 'object_name': 'WatchFilter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '20'}),
            'value': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'watch': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'filters'", 'to': "orm['tidings.Watch']"})
        }
    }

    complete_apps = ['tidings']

########NEW FILE########
__FILENAME__ = models
from django.contrib.auth.models import User, AnonymousUser
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.models import Site
from django.db import models, connections, router

from tidings.utils import import_from_setting, reverse


ModelBase = import_from_setting('TIDINGS_MODEL_BASE',
                                'django.db.models.Model')


def multi_raw(query, params, models, model_to_fields):
    """Scoop multiple model instances out of the DB at once, given a query that
    returns all fields of each.

    Return an iterable of sequences of model instances parallel to the
    ``models`` sequence of classes. For example::

        [(<User such-and-such>, <Watch such-and-such>), ...]

    """
    cursor = connections[router.db_for_read(models[0])].cursor()
    cursor.execute(query, params)
    rows = cursor.fetchall()

    for row in rows:
        next_value = iter(row).next
        yield [model_class(**dict((a, next_value())
                           for a in model_to_fields[model_class]))
               for model_class in models]


class Watch(ModelBase):
    """The registration of a user's interest in a certain event

    At minimum, specifies an event_type and thereby an
    :class:`~tidings.events.Event` subclass. May also specify a content type
    and/or object ID and, indirectly, any number of
    :class:`WatchFilters <WatchFilter>`.

    """
    #: Key used by an Event to find watches it manages:
    event_type = models.CharField(max_length=30, db_index=True)

    #: Optional reference to a content type:
    content_type = models.ForeignKey(ContentType, null=True, blank=True)
    object_id = models.PositiveIntegerField(db_index=True, null=True)
    content_object = generic.GenericForeignKey('content_type', 'object_id')

    user = models.ForeignKey(User, null=True, blank=True)

    #: Email stored only in the case of anonymous users:
    email = models.EmailField(db_index=True, null=True, blank=True)

    #: Secret for activating anonymous watch email addresses.
    secret = models.CharField(max_length=10, null=True, blank=True)
    #: Active watches receive notifications, inactive watches don't.
    is_active = models.BooleanField(default=False, db_index=True)

    def __unicode__(self):
        # TODO: Trace event_type back to find the Event subclass, and ask it
        # how to describe me in English.
        rest = self.content_object or self.content_type or self.object_id
        return u'id=%s, type=%s, content_object=%s' % (self.pk, self.event_type,
                                                       unicode(rest))

    def activate(self):
        """Enable this watch so it actually fires.

        Return ``self`` to support method chaining.

        """
        self.is_active = True
        return self

    def unsubscribe_url(self):
        """Return the absolute URL to visit to delete me."""
        server_relative = ('%s?s=%s' % (reverse('tidings.unsubscribe',
                                                args=[self.pk]),
                                        self.secret))
        return 'https://%s%s' % (Site.objects.get_current().domain,
                                 server_relative)


class WatchFilter(ModelBase):
    """Additional key/value pairs that pare down the scope of a watch"""

    watch = models.ForeignKey(Watch, related_name='filters')
    name = models.CharField(max_length=20)

    #: Either an int or the hash of an item in a reasonably small set, which is
    #: indicated by the name field. See comments by
    #: :func:`~tidings.utils.hash_to_unsigned()` for more on what is reasonably
    #: small.
    value = models.PositiveIntegerField()

    class Meta(object):
        # There's no particular reason we couldn't allow multiple values for
        # one name to be ORed together, but the API needs a little work
        # (accepting lists passed to notify()) to support that.
        #
        # This ordering makes the index usable for lookups by name.
        unique_together = ('name', 'watch')

    def __unicode__(self):
        return u'WatchFilter %s: %s=%s' % (self.pk, self.name, self.value)


class NotificationsMixin(models.Model):
    """Mixin for notifications models that adds watches as a generic relation.

    So we get cascading deletes for free, yay!

    """
    watches = generic.GenericRelation(
        Watch, related_name='%(app_label)s_%(class)s_watches')

    class Meta(object):
        abstract = True


class EmailUser(AnonymousUser):
    """An anonymous user identified only by email address

    To test whether a returned user is an anonymous user, call
    ``is_anonymous()``.

    """
    def __init__(self, email=''):
        self.email = email

    def __unicode__(self):
        return 'Anonymous user <%s>' % self.email

    __repr__ = AnonymousUser.__str__

    def __eq__(self, other):
        return self.email == other.email

    def __ne__(self, other):
        return self.email != other.email

    def __hash__(self):
        return hash(self.email)

########NEW FILE########
__FILENAME__ = tasks
from celery.task import task

from tidings.models import Watch


@task(rate_limit='1/m')
def claim_watches(user):
    """Attach any anonymous watches having a user's email to that user.

    Call this from your user registration process if you like.

    """
    Watch.objects.filter(email=user.email).update(email=None, user=user)

########NEW FILE########
__FILENAME__ = unsubscribe_instructions
from django import template


register = template.Library()


@register.inclusion_tag('tidings/email/unsubscribe.ltxt')
def unsubscribe_instructions(watch):
    """Return instructions and link for unsubscribing from the given watch."""
    return {'watch': watch}

########NEW FILE########
__FILENAME__ = models
from django.db import models

from tidings.models import NotificationsMixin


# TODO: figure out why placing the mixin *after* models.Model fails
# See also http://code.djangoproject.com/ticket/10249
class MockModel(NotificationsMixin, models.Model):
    pass

########NEW FILE########
__FILENAME__ = test_events
# -*- coding: utf-8 -*-
import mock
from nose.tools import eq_

from django.conf import settings
from django.contrib.auth.models import AnonymousUser
from django.contrib.contenttypes.models import ContentType
from django.core import mail
from django.core.mail import EmailMessage

from tidings.events import Event, _unique_by_email, EventUnion, InstanceEvent
from tidings.models import Watch, EmailUser
from tidings.tests import watch, watch_filter, TestCase, user
from tidings.tests.mockapp.models import MockModel


TYPE = 'some event'
ANOTHER_TYPE = 'another type'


class SimpleEvent(Event):
    event_type = TYPE

    def _mails(self, users_and_watches):
        """People watch the event in general; there are no parameters."""
        return (EmailMessage('Subject!', 'Body!', to=[u.email]) for u, w in
                users_and_watches)


class AnotherEvent(Event):
    event_type = ANOTHER_TYPE


class ContentTypeEvent(SimpleEvent):
    content_type = ContentType  # saves mocking a model


class FilteredEvent(SimpleEvent):
    filters = set(['color', 'flavor'])


class FilteredContentTypeEvent(ContentTypeEvent):
    filters = set(['color', 'flavor'])


class UsersWatchingTests(TestCase):
    """Unit tests for Event._users_watching_by_filter()"""

    @staticmethod
    def _emails_eq(addresses, event, **filters):
        """Assert that the given emails are the ones watching `event`, given
        the scoping in `filters`."""
        eq_(sorted(addresses),
            sorted([u.email for u, w in
                    event._users_watching_by_filter(**filters)]))

    def test_simple(self):
        """Test whether a watch scoped only by event type fires for both
        anonymous and registered users."""
        registered_user = user(email='regist@ered.com', save=True)
        watch(event_type=TYPE, user=registered_user).save()
        watch(event_type=TYPE, email='anon@ymous.com').save()
        watch(event_type='something else', email='never@fires.com').save()
        self._emails_eq(['regist@ered.com', 'anon@ymous.com'], SimpleEvent())

    def test_inactive(self):
        """Make sure inactive watches don't fire."""
        watch(event_type=TYPE, email='anon@ymous.com', is_active=False).save()
        watch(event_type=TYPE, email='active@one.com').save()
        self._emails_eq(['active@one.com'], SimpleEvent())

    def test_content_type(self):
        """Make sure watches filter properly by content type."""
        watch_type = ContentType.objects.get_for_model(Watch)
        content_type_type = ContentType.objects.get_for_model(ContentType)
        registered_user = user(email='regist@ered.com', save=True)
        watch(event_type=TYPE, content_type=content_type_type,
              user=registered_user).save()
        watch(event_type=TYPE, content_type=content_type_type,
              email='anon@ymous.com').save()
        watch(event_type=TYPE, content_type=watch_type,
              email='never@fires.com').save()
        self._emails_eq(['regist@ered.com', 'anon@ymous.com'],
                        ContentTypeEvent())

    def test_filtered(self):
        """Make sure watches cull properly by additional filters."""
        # A watch with just the filter we're searching for:
        registered_user = user(email='ex@act.com', save=True)
        exact_watch = watch(event_type=TYPE, user=registered_user, save=True)
        watch_filter(watch=exact_watch, name='color', value=1).save()

        # A watch with extra filters:
        extra_watch = watch(event_type=TYPE, email='extra@one.com', save=True)
        watch_filter(watch=extra_watch, name='color', value=1).save()
        watch_filter(watch=extra_watch, name='flavor', value=2).save()

        # A watch with no row for the filter we're searching on:
        watch(event_type=TYPE, email='wild@card.com').save()

        # A watch with a mismatching filter--shouldn't be found
        mismatch_watch = watch(event_type=TYPE, email='mis@match.com',
                               save=True)
        watch_filter(watch=mismatch_watch, name='color', value=3).save()

        self._emails_eq(['ex@act.com', 'extra@one.com', 'wild@card.com'],
                        FilteredEvent(), color=1)

        # Search on multiple filters to test joining the filters table twice.
        # We provide values that match for both filters, as mis@match.com
        # suffices to test exclusion.
        self._emails_eq(['ex@act.com', 'extra@one.com', 'wild@card.com'],
                        FilteredEvent(), color=1, flavor=2)

    def test_bad_filters(self):
        """Bad filter types passed in should throw TypeError."""
        self.assertRaises(TypeError, SimpleEvent()._users_watching_by_filter,
                          smoo=3)

    def test_duplicates(self):
        """Don't return duplicate email addresses."""
        watch(event_type=TYPE, user=user(email='hi@there.com', save=True),
              save=True)
        watch(event_type=TYPE, email='hi@there.com').save()
        watch(event_type=TYPE, email='hi@there.com').save()
        eq_(3, Watch.objects.all().count())  # We created what we meant to.

        self._emails_eq(['hi@there.com'], SimpleEvent())

    def test_duplicates_case_insensitive(self):
        """De-duping should compare case-insensitively."""
        watch(event_type=TYPE, user=user(email='HI@example.com', save=True),
              save=True)
        watch(event_type=TYPE, email='hi@EXAMPLE.com').save()
        watch(event_type=TYPE, email='hi@EXAMPLE.com').save()
        eq_(3, Watch.objects.all().count())  # We created what we meant to.

        addresses = [u.email
                     for u, w in SimpleEvent()._users_watching_by_filter()]
        eq_(1, len(addresses))
        eq_('hi@example.com', addresses[0].lower())

    def test_registered_users_favored(self):
        """When removing duplicates, make sure registered users are kept in
        favor of anonymous ones having the same email address."""
        def make_anonymous_watches():
            for x in xrange(3):
                watch(event_type=TYPE, email='hi@there.com').save()

        # Throw some anonymous watches in there in the hope that they would
        # come out on top if we didn't purposely favor registered users.
        # Suggestions on how to make this test more reliable are welcome.
        make_anonymous_watches()

        # File the registered watch:
        watch(event_type=TYPE,
              user=user(first_name='Jed', email='hi@there.com',
                        save=True)).save()

        # A few more anonymous watches in case the BTrees flop in the other
        # direction:
        make_anonymous_watches()

        users_and_watches = list(SimpleEvent()._users_watching_by_filter())
        u, w = users_and_watches[0]
        eq_('Jed', u.first_name)

    def test_unique_by_email_user_selection(self):
        """Test the routine that sorts through users and watches having the
        same email addresses."""
        # Test the best in a cluster coming first, in the middle, and last.
        # We mark the correct choices with first_name='a'.
        users_and_watches = [
            (user(first_name='a', email='hi'), [watch()]),
            (user(email='hi'), [watch()]),
            (user(), [watch(email='hi')]),

            (user(), [watch(email='mid')]),
            (user(first_name='a', email='mid'), [watch()]),
            (user(), [watch(email='mid')]),

            (user(), [watch(email='lo')]),
            (user(), [watch(email='lo')]),
            (user(first_name='a', email='lo'), [watch()]),

            (user(), [watch(email='none', secret='a')]),
            (user(), [watch(email='none')])]

        favorites = list(_unique_by_email(users_and_watches))
        eq_(4, len(favorites))

        # Test that we chose the correct users, where there are distinguishable
        # (registered) users to choose from:
        eq_(['a'] * 3, [u.first_name for u, w in favorites[:3]])

    def test_unique_by_email_watch_collection(self):
        """Make sure _unique_by_email() collects all watches in each cluster."""
        w1, w2, w3 = watch(), watch(), watch(email='hi')
        w4, w5, w6 = watch(), watch(), watch(email='lo')
        users_and_watches = [
            (user(email='hi'), [w1]),
            (user(email='hi'), [w2]),
            (user(), [w3]),

            (user(email='lo'), [w4]),
            (user(email='lo'), [w5]),
            (user(), [w6])]
        result = list(_unique_by_email(users_and_watches))

        _, watches = result[0]
        eq_(set([w1, w2, w3]), set(watches))

        # Make sure the watches accumulator gets cleared between clusters:
        _, watches = result[1]
        eq_(set([w4, w5, w6]), set(watches))

    def test_unsaved_exclude(self):
        """Excluding an unsaved user should throw a ValueError."""
        self.assertRaises(ValueError,
                          SimpleEvent()._users_watching_by_filter,
                          exclude=user())


class EventUnionTests(TestCase):
    """Tests for EventUnion"""

    @staticmethod
    def _emails_eq(addresses, event):
        """Assert that the given emails are the ones watching `event`."""
        eq_(sorted(addresses),
            sorted([u.email for u, w in
                    event._users_watching()]))

    def test_merging(self):
        """Test that duplicate emails across multiple events get merged."""
        watch(event_type=TYPE, email='he@llo.com').save()
        watch(event_type=TYPE, email='ick@abod.com').save()
        registered_user = user(email='he@llo.com', save=True)
        watch(event_type=ANOTHER_TYPE, user=registered_user).save()

        self._emails_eq(['he@llo.com', 'ick@abod.com'],
                        EventUnion(SimpleEvent(), AnotherEvent()))

    def test_duplicates_case_insensitive(self):
        """Test that duplicate merging is case insensitive."""
        # These mocks return their users in descending order like the SQL
        # query.
        class OneEvent(object):
            def _users_watching(self):
                return [(user(email='HE@LLO.COM'), [watch()])]

        class AnotherEvent(object):
            def _users_watching(self):
                return [(user(email='he@llo.com'), [watch()]),
                        (user(email='br@illo.com'), [watch()])]

        addresses = [u.email for u, w in
                     EventUnion(OneEvent(),
                                AnotherEvent())._users_watching()]

        eq_(2, len(addresses))
        eq_('he@llo.com', addresses[0].lower())

    @mock.patch.object(SimpleEvent, '_mails')
    def test_fire(self, _mails):
        """Assert firing the union gets the mails from the first event."""
        _mails.return_value = []
        watch(event_type=TYPE, email='he@llo.com').save()
        EventUnion(SimpleEvent(), AnotherEvent()).fire()
        assert _mails.called

    def test_watch_lists(self):
        """Ensure the Union returns every watch a user has."""
        w1 = watch(event_type=TYPE, email='jeff@here.com', save=True)
        w2 = watch(event_type=TYPE, email='jeff@here.com', save=True)
        u, w = list(EventUnion(SimpleEvent())._users_watching())[0]
        eq_([w1, w2], sorted(w, key=lambda x: x.id))


class NotificationTests(TestCase):
    """Tests for Event methods that create, examine, and destroy watches."""

    def test_lifecycle(self):
        """Vet the creation, testing, and deletion of watches.

        Test registered users and anonymous email addresses. Test content_types
        and general filters.

        """
        EMAIL = 'fred@example.com'
        FilteredContentTypeEvent.notify(EMAIL, color=1)
        assert FilteredContentTypeEvent.is_notifying(EMAIL, color=1)

        FilteredContentTypeEvent.stop_notifying(EMAIL, color=1)
        assert not FilteredContentTypeEvent.is_notifying(EMAIL, color=1)

    def test_notify_idempotence(self):
        """Assure notify() returns an existing watch when possible."""
        u = user(save=True)
        w = FilteredContentTypeEvent.notify(u, color=3, flavor=4)
        eq_(w.pk, FilteredContentTypeEvent.notify(u, color=3, flavor=4).pk)
        eq_(1, Watch.objects.all().count())

    def test_duplicate_tolerance(self):
        """Assure notify() returns an existing watch if there is a matching
        one.

        Also make sure it returns only 1 watch even if there are duplicate
        matches.

        """
        w1 = watch(event_type=TYPE, email='hi@there.com', save=True)
        w2 = watch(event_type=TYPE, email='hi@there.com', save=True)
        assert SimpleEvent.notify('hi@there.com').pk in [w1.pk, w2.pk]

    def test_exact_matching(self):
        """Assert is_notifying() doesn't match watches having a superset of
        the given filters."""
        FilteredContentTypeEvent.notify('hi@there.com', color=3, flavor=4)
        assert not FilteredContentTypeEvent.is_notifying('hi@there.com',
                                                         color=3)

    def test_anonymous(self):
        """Anonymous users with no emails can't be watching anything.

        Mostly, this is just to make sure it doesn't crash.

        """
        assert not SimpleEvent.is_notifying(AnonymousUser())

    def test_hashing(self):
        """Strings should be hashed to ints, but ints should be left alone.

        Unicode strings should also work.

        """
        FilteredEvent.notify('red@x.com', color='red', flavor=6)
        FilteredEvent.notify('blue@x.com', color=u'blüe', flavor=7)
        assert FilteredEvent.is_notifying('red@x.com', color='red', flavor=6)
        assert FilteredEvent.is_notifying('blue@x.com', color=u'blüe',
                                          flavor=7)
        assert not FilteredEvent.is_notifying('blue@x.com', color='red',
                                              flavor=7)


class CascadingDeleteTests(TestCase):
    """Cascading deletes on object_id + content_type."""
    def test_mock_model(self):
        """Deleting an instance of MockModel should delete watches.

        Create instance of MockModel from
        tidings.tests.mockapp.models, then delete it and watch the
        cascade go.

        """
        mock_m = MockModel.objects.create()
        watch(event_type=TYPE, email='hi@there.com', content_object=mock_m,
              save=True)
        MockModel.objects.all().delete()
        assert not Watch.objects.count(), 'Cascade delete failed.'


class MailTests(TestCase):
    """Tests for mail-sending and templating"""

    @mock.patch.object(settings._wrapped, 'TIDINGS_CONFIRM_ANONYMOUS_WATCHES', False)
    def test_fire(self):
        """Assert that fire() runs and that generated mails get sent."""
        SimpleEvent.notify('hi@there.com').activate().save()
        SimpleEvent().fire()

        eq_(1, len(mail.outbox))
        first_mail = mail.outbox[0]
        eq_(['hi@there.com'], first_mail.to)
        eq_('Subject!', first_mail.subject)
        eq_('Body!', first_mail.body)

    def test_anonymous_notify_and_fire(self):
        """Calling notify() sends confirmation email, and calling fire() sends
        notification email."""
        w = SimpleEvent.notify('hi@there.com')

        eq_(1, len(mail.outbox))
        first_mail = mail.outbox[0]
        eq_(['hi@there.com'], first_mail.to)
        eq_('TODO', first_mail.subject)
        eq_('Activate!', first_mail.body)

        w.activate().save()
        SimpleEvent().fire()

        second_mail = mail.outbox[1]
        eq_(['hi@there.com'], second_mail.to)
        eq_('Subject!', second_mail.subject)
        eq_('Body!', second_mail.body)

    @mock.patch.object(settings._wrapped, 'TIDINGS_CONFIRM_ANONYMOUS_WATCHES', False)
    def test_exclude(self):
        """Assert the `exclude` arg to fire() excludes the given user."""
        SimpleEvent.notify('du@de.com').activate().save()
        registered_user = user(email='ex@clude.com', save=True)
        SimpleEvent.notify(registered_user).activate().save()

        SimpleEvent().fire(exclude=registered_user)

        eq_(1, len(mail.outbox))
        first_mail = mail.outbox[0]
        eq_(['du@de.com'], first_mail.to)
        eq_('Subject!', first_mail.subject)

    @mock.patch.object(settings._wrapped, 'TIDINGS_CONFIRM_ANONYMOUS_WATCHES', False)
    def test_exclude_multiple(self):
        """Show that passing a sequence to exclude excludes them all."""
        SimpleEvent.notify('du@de.com').activate().save()
        user1 = user(email='ex1@clude.com', save=True)
        SimpleEvent.notify(user1).activate().save()
        user2 = user(email='ex2@clude.com', save=True)
        SimpleEvent.notify(user2).activate().save()

        SimpleEvent().fire(exclude=[user1, user2])

        eq_(1, len(mail.outbox))
        eq_(['du@de.com'], mail.outbox[0].to)


def test_anonymous_user_compares():
    """Make sure anonymous users with different emails compare different."""
    # Test __ne__:
    assert EmailUser('frank') != EmailUser('george')
    assert not EmailUser('frank') != EmailUser('frank')

    # Test __eq__:
    assert not EmailUser('frank') == EmailUser('george')
    assert EmailUser('frank') == EmailUser('frank')

    # Test __hash__:
    assert hash(EmailUser('frank')) == hash(EmailUser('frank'))
    assert hash(EmailUser('frank')) != hash(EmailUser('george'))


class MockModelEvent(InstanceEvent):
    event_type = 'mock model event'
    content_type = MockModel


class InstanceEventTests(TestCase):
    def _test_user_or_email(self, user_or_email):
        """Test all states of the truth table for 2 instances being watched.

        E.g. watch m, assert watching m but not m2; watch m2, assert watching
        both, etc.

        """
        mock_m = MockModel.objects.create()
        mock_m2 = MockModel.objects.create()
        MockModelEvent.notify(user_or_email, mock_m)
        # We're watching instance #1...
        assert MockModelEvent.is_notifying(user_or_email, mock_m)
        # ... but not instance #2
        assert not MockModelEvent.is_notifying(user_or_email, mock_m2)
        # Now also watch instance #2.
        MockModelEvent.notify(user_or_email, mock_m2)
        assert MockModelEvent.is_notifying(user_or_email, mock_m)
        assert MockModelEvent.is_notifying(user_or_email, mock_m2)
        # Stop watching instance #1...
        MockModelEvent.stop_notifying(user_or_email, mock_m)
        assert not MockModelEvent.is_notifying(user_or_email, mock_m)
        assert MockModelEvent.is_notifying(user_or_email, mock_m2)
        # ... and instance #2
        MockModelEvent.stop_notifying(user_or_email, mock_m2)
        assert not MockModelEvent.is_notifying(user_or_email, mock_m2)
        # No watch objects are left over.
        assert not Watch.objects.count()

    def test_instance_anonymous(self):
        """Watch with an anonymous user."""
        self._test_user_or_email('fred@example.com')

    def test_instance_registered(self):
        """Watch with a registered user."""
        registered_user = user(email='regist@ered.com', save=True)
        self._test_user_or_email(registered_user)

########NEW FILE########
__FILENAME__ = test_models
from nose.tools import eq_

from tidings.models import WatchFilter, EmailUser
from tidings.tests import watch, watch_filter, TestCase


# TODO: write a test to ensure that event types don't collide
# case-insensitive-ly
# E.g. No duplicates in this list: [et.lower() for et in EVENT_TYPES]


class WatchTests(TestCase):
    """Tests for Watch model"""

    def test_unsubscribe_url(self):
        """Make sure unsubscribe_url() returns something URL-ish."""
        w = watch()
        url = w.unsubscribe_url()
        assert url.startswith('http')
        assert url.endswith('?s=%s' % w.secret)


class WatchFilterTests(TestCase):
    """Tests for WatchFilter"""

    def test_value_range(self):
        """Assert 0 and 2**32-1 both fit in the value field.

        That's the range of our hash function.

        """
        MAX_INT = 2 ** 32 - 1
        watch_filter(name='maxint', value=MAX_INT).save()
        eq_(MAX_INT, WatchFilter.objects.get(name='maxint').value)


class EmailUserTests(TestCase):
    """Tests for EmailUser class"""

    def test_blank_username(self):
        """Assert EmailUsers' username is ''.

        This isn't covered by the tests in django.contrib.auth, and we need to
        hear about it if it changes, as some implementations of _mails() depend
        on it.

        """
        eq_('', EmailUser().username)

########NEW FILE########
__FILENAME__ = test_tasks
from nose.tools import eq_

from tidings.models import Watch
from tidings.tasks import claim_watches
from tidings.tests import watch, TestCase, user


class ClaimWatchesTests(TestCase):
    def test_none(self):
        """No anonymous watches to claim."""
        u = user(email='some@bo.dy', save=True)
        claim_watches(u)
        # Nothing happens, but no error is raised either.

    def test_anonymous_only(self):
        """Make sure having mixed watches claims right ones."""
        # Watch some before registering.
        watch(email='some@bo.dy', save=True)
        watch(email='some@bo.dy', save=True)
        watch(email='no@bo.dy', save=True)

        # Register.
        u = user(email='some@bo.dy', save=True)

        claim_watches(u)

        # Original anonymous watch is claimed.
        assert not Watch.objects.filter(email='some@bo.dy').exists()
        eq_(2, Watch.objects.filter(email=None).count())
        eq_(2, Watch.objects.filter(user=u).count())

        # No other watches are affected.
        assert Watch.objects.filter(email='no@bo.dy').exists()

    def test_mixed(self):
        """Make sure having mixed watches claims right ones."""
        # Watch before registering.
        watch(email='some@bo.dy', save=True)
        watch(email='no@bo.dy', save=True)

        # Register nobody.
        user(email='no@bo.dy', save=True)

        # Then register somebody and watch something after registering.
        u = user(email='some@bo.dy', save=True)
        watch(user=u, save=True)

        claim_watches(u)

        # Original anonymous watch is claimed.
        assert not Watch.objects.filter(email='some@bo.dy').exists()
        eq_(2, Watch.objects.filter(email=None).count())

        # No other watches are affected.
        assert Watch.objects.filter(email='no@bo.dy').exists()

########NEW FILE########
__FILENAME__ = test_templates
from nose.tools import eq_

from tidings.models import Watch
from tidings.tests import watch, TestCase
from tidings.utils import reverse


FAILURE_STRING = 'We could not find your subscription'


class UnsubscribeTests(TestCase):
    """Integration tests for unsubscribe view"""

    def test_confirmation(self):
        """Ensure the confirmation page renders if you feed it valid data."""
        w = watch(save=True)
        response = self.client.get(
            reverse('tidings.unsubscribe', args=[w.pk]) + '?s=' + w.secret)
        self.assertContains(response, 'Are you sure you want to unsubscribe?')

    def test_no_such_watch(self):
        """Assert it complains when asked for a nonexistent Watch."""
        for method in [self.client.get, self.client.post]:
            response = method(reverse('tidings.unsubscribe', args=[33]))
            self.assertContains(response, FAILURE_STRING)

    def test_no_secret(self):
        """Assert it complains when no secret is given."""
        w = watch(save=True)
        for method in [self.client.get, self.client.post]:
            response = method(reverse('tidings.unsubscribe',
                                      args=[w.pk]))
            self.assertContains(response, FAILURE_STRING)

    def test_wrong_secret(self):
        """Assert it complains when an incorrect secret is given."""
        w = watch(save=True)
        for method in [self.client.get, self.client.post]:
            response = method(
                reverse('tidings.unsubscribe', args=[w.pk]) + '?s=WRONGwrong')
            self.assertContains(response, FAILURE_STRING)

    def test_success(self):
        """Ensure the watch deletes and view says "yay" when all goes well."""
        w = watch(save=True)
        response = self.client.post(
            reverse('tidings.unsubscribe', args=[w.pk]) + '?s=' + w.secret)
        self.assertContains(response, '<h1>Unsubscribed</h1>')
        eq_(0, Watch.objects.count())

########NEW FILE########
__FILENAME__ = test_templatetags
from django.template import Context, Template

from tidings.tests import watch, TestCase


class Tests(TestCase):
    """Tests for our lone template tag"""

    def test_unsubscribe_instructions(self):
        """Make sure unsubscribe_instructions renders and contains the
        unsubscribe URL."""
        w = watch(save=True)
        template = Template('{% load unsubscribe_instructions %}'
                            '{% unsubscribe_instructions watch %}')
        assert w.unsubscribe_url() in template.render(Context({'watch': w}))

########NEW FILE########
__FILENAME__ = test__utils
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from mock import patch
from nose.tools import eq_, raises

from tidings.tests import TestCase
from tidings.utils import collate, import_from_setting


class MergeTests(TestCase):
    """Unit tests for collate()"""
    # Also accidentally tests peekable, though that could use its own tests

    def test_default(self):
        """Test with the default `key` function."""
        iterables = [xrange(4), xrange(7), xrange(3, 6)]
        eq_(sorted(reduce(list.__add__, [list(it) for it in iterables])),
            list(collate(*iterables)))

    def test_key(self):
        """Test using a custom `key` function."""
        iterables = [xrange(5, 0, -1), xrange(4, 0, -1)]
        eq_(list(sorted(reduce(list.__add__,
                                        [list(it) for it in iterables]),
                        reverse=True)),
            list(collate(*iterables, key=lambda x: -x)))

    def test_empty(self):
        """Be nice if passed an empty list of iterables."""
        eq_([], list(collate()))

    def test_one(self):
        """Work when only 1 iterable is passed."""
        eq_([0, 1], list(collate(xrange(2))))

    def test_reverse(self):
        """Test the `reverse` kwarg."""
        iterables = [xrange(4, 0, -1), xrange(7, 0, -1), xrange(3, 6, -1)]
        eq_(sorted(reduce(list.__add__, [list(it) for it in iterables]),
                   reverse=True),
            list(collate(*iterables, reverse=True)))


class ImportedFromSettingTests(TestCase):
    """Tests for import_from_setting() and _imported_symbol()"""

    @patch.object(settings._wrapped,
                  'TIDINGS_MODEL_BASE',
                  'django.db.models.Model',
                  create=True)
    def test_success(self):
        from django.db.models import Model
        assert import_from_setting('TIDINGS_MODEL_BASE', 'blah') == Model

    @raises(ImproperlyConfigured)
    @patch.object(settings._wrapped,
                  'TIDINGS_MODEL_BASE',
                  'hummahummanookanookanonexistent.thing',
                  create=True)
    def test_module_missing(self):
        import_from_setting('TIDINGS_MODEL_BASE', 'blah')

    @raises(ImproperlyConfigured)
    @patch.object(settings._wrapped,
                  'TIDINGS_MODEL_BASE',
                  'django.hummahummanookanookanonexistent',
                  create=True)
    def test_symbol_missing(self):
        import_from_setting('TIDINGS_MODEL_BASE', 'blah')

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('tidings.views',
    url(r'^unsubscribe/(?P<watch_id>\d+)$',
        'unsubscribe',
        name='tidings.unsubscribe')
)

########NEW FILE########
__FILENAME__ = utils
from zlib import crc32

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.mail import EmailMessage
from django.template import Context, loader
from django.utils.importlib import import_module


class peekable(object):
    """Wrapper for an iterator to allow 1-item lookahead"""
    # Lowercase to blend in with itertools. The fact that it's a class is an
    # implementation detail.

    # TODO: Liberate into itertools.

    def __init__(self, iterable):
        self._it = iter(iterable)

    def __iter__(self):
        return self

    def __nonzero__(self):
        try:
            self.peek()
        except StopIteration:
            return False
        return True

    def peek(self):
        """Return the item that will be next returned from ``next()``.

        Raise ``StopIteration`` if there are no items left.

        """
        # TODO: Give peek a default arg. Raise StopIteration only when it isn't
        # provided. If it is, return the arg. Just like get('key', object())
        if not hasattr(self, '_peek'):
            self._peek = self._it.next()
        return self._peek

    def next(self):
        ret = self.peek()
        del self._peek
        return ret


def collate(*iterables, **kwargs):
    """Return an iterable ordered collation of the already-sorted items
    from each of ``iterables``, compared by kwarg ``key``.

    If ``reverse=True`` is passed, iterables must return their results in
    descending order rather than ascending.

    """
    # TODO: Liberate into the stdlib.
    key = kwargs.pop('key', lambda a: a)
    reverse = kwargs.pop('reverse', False)

    min_or_max = max if reverse else min
    peekables = [peekable(it) for it in iterables]
    peekables = [p for p in peekables if p]  # Kill empties.
    while peekables:
        _, p = min_or_max((key(p.peek()), p) for p in peekables)
        yield p.next()
        peekables = [p for p in peekables if p]


def hash_to_unsigned(data):
    """If ``data`` is a string or unicode string, return an unsigned 4-byte int
    hash of it. If ``data`` is already an int that fits those parameters,
    return it verbatim.

    If ``data`` is an int outside that range, behavior is undefined at the
    moment. We rely on the ``PositiveIntegerField`` on
    :class:`~tidings.models.WatchFilter` to scream if the int is too long for
    the field.

    We use CRC32 to do the hashing. Though CRC32 is not a good general-purpose
    hash function, it has no collisions on a dictionary of 38,470 English
    words, which should be fine for the small sets that :class:`WatchFilters
    <tidings.models.WatchFilter>` are designed to enumerate. As a bonus, it is
    fast and available as a built-in function in some DBs. If your set of
    filter values is very large or has different CRC32 distribution properties
    than English words, you might want to do your own hashing in your
    :class:`~tidings.events.Event` subclass and pass ints when specifying
    filter values.

    """
    if isinstance(data, basestring):
        # Return a CRC32 value identical across Python versions and platforms
        # by stripping the sign bit as on
        # http://docs.python.org/library/zlib.html.
        return crc32(data.encode('utf-8')) & 0xffffffff
    else:
        return int(data)


def emails_with_users_and_watches(subject, template_path, vars,
    users_and_watches, from_email=settings.TIDINGS_FROM_ADDRESS,
    **extra_kwargs):
    """Return iterable of EmailMessages with user and watch values substituted.

    A convenience function for generating emails by repeatedly rendering a
    Django template with the given ``vars`` plus a ``user`` and ``watches`` key
    for each pair in ``users_and_watches``

    :arg template_path: path to template file
    :arg vars: a map which becomes the Context passed in to the template
    :arg extra_kwargs: additional kwargs to pass into EmailMessage constructor

    """
    template = loader.get_template(template_path)
    context = Context(vars)
    for u, w in users_and_watches:
        context['user'] = u
        context['watch'] = w[0]  # Arbitrary single watch for compatibility
                                 # with 0.1. TODO: remove.
        context['watches'] = w
        yield EmailMessage(subject,
                           template.render(context),
                           from_email,
                           [u.email],
                           **extra_kwargs)


def _imported_symbol(import_path):
    """Resolve a dotted path into a symbol, and return that.

    For example...

    >>> _imported_symbol('django.db.models.Model')
    <class 'django.db.models.base.Model'>

    Raise ImportError is there's no such module, AttributeError if no such
    symbol.

    """
    module_name, symbol_name = import_path.rsplit('.', 1)
    module = import_module(module_name)
    return getattr(module, symbol_name)


def import_from_setting(setting_name, fallback):
    """Return the resolution of an import path stored in a Django setting.

    :arg setting_name: The name of the setting holding the import path
    :arg fallback: An import path to use if the given setting doesn't exist

    Raise ImproperlyConfigured if a path is given that can't be resolved.

    """
    path = getattr(settings, setting_name, fallback)
    try:
        return _imported_symbol(path)
    except (ImportError, AttributeError):
        raise ImproperlyConfigured('No such module or attribute: %s' % path)


# Here to be imported by others:
reverse = import_from_setting('TIDINGS_REVERSE',
                              'django.core.urlresolvers.reverse')

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render

from tidings.models import Watch


def unsubscribe(request, watch_id):
    """Unsubscribe from (i.e. delete) the watch of ID ``watch_id``.

    Expects an ``s`` querystring parameter matching the watch's secret.

    GET will result in a confirmation page (or a failure page if the secret is
    wrong). POST will actually delete the watch (again, if the secret is
    correct).

    The templates assume use of the Jinja templating engine via jingo.Loader
    and the presence of a ``base.html`` template containing a ``content``
    block.

    If you aren't using Jinja via jingo.Loader, you can replace the templates
    with your own django templates.

    """
    # Grab the watch and secret; complain if either is wrong:
    try:
        watch = Watch.objects.get(pk=watch_id)
        secret = request.GET.get('s')  # 's' is for 'secret' but saves wrapping
                                       # in mails
        if secret != watch.secret:
            raise Watch.DoesNotExist
    except Watch.DoesNotExist:
        return render(request, 'tidings/unsubscribe_error.html')

    if request.method == 'POST':
        watch.delete()
        return render(request, 'tidings/unsubscribe_success.html')

    return render(request, 'tidings/unsubscribe.html')

########NEW FILE########
