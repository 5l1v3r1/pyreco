__FILENAME__ = barter
"""
Barter system

Evennia contribution - Griatch 2012


This implements a full barter system - a way for players to safely
trade items between each other using code rather than simple free-form
talking.  The advantage of this is increased buy/sell safety but it
also streamlines the process and makes it faster when doing many
transactions (since goods are automatically exchanged once both
agree).

This system is primarily intended for a barter economy, but can easily
be used in a monetary economy as well -- just let the "goods" on one
side be coin objects (this is more flexible than a simple "buy"
command since you can mix coins and goods in your trade).

In this module, a "barter" is generally referred to as a "trade".


- Trade example

A trade (barter) action works like this: A and B are the parties.

1) opening a trade

A: trade B: Hi, I have a nice extra sword. You wanna trade?
B sees: A says: "Hi, I have a nice extra sword. You wanna trade?"
   A wants to trade with you. Enter 'trade A <emote>' to accept.
B: trade A: Hm, I could use a good sword ...
A sees: B says: "Hm, I could use a good sword ...
   B accepts the trade. Use 'trade help' for aid.
B sees: You are now trading with A. Use 'trade help' for aid.

2) negotiating

A: offer sword: This is a nice sword. I would need some rations in trade.
B sees: A says: "This is a nice sword. I would need some rations in trade."
   [A offers Sword of might.]
B evalute sword
B sees: <Sword's description and possibly stats>
B: offer ration: This is a prime ration.
A sees: B says: "These is a prime ration."
  [B offers iron ration]
A: say Hey, this is a nice sword, I need something more for it.
B sees: A says: "Hey this is a nice sword, I need something more for it."
B: offer sword,apple: Alright. I will also include a magic apple. That's my last offer.
A sees: B says: "Alright, I will also include a magic apple. That's my last offer."
  [B offers iron ration and magic apple]
A accept: You are killing me here, but alright.
B sees: A says: "You are killing me here, but alright."
  [A accepts your offer. You must now also accept.]
B accept: Good, nice making business with you.
  You accept the deal. Deal is made and goods changed hands.
A sees: B says: "Good, nice making business with you."
  B accepts the deal. Deal is made and goods changed hands.

At this point the trading system is exited and the negotiated items
are automatically exchanged between the parties. In this example B was
the only one changing their offer, but also A could have changed their
offer until the two parties found something they could agree on. The
emotes are optional but useful for RP-heavy worlds.

- Technical info

The trade is implemented by use of a TradeHandler. This object is a
common place for storing the current status of negotiations. It is
created on the object initiating the trade, and also stored on the
other party once that party agrees to trade. The trade request times
out after a certain time - this is handled by a Script. Once trade
starts, the CmdsetTrade cmdset is initiated on both parties along with
the commands relevant for the trading.

- Ideas for NPC bartering:

This module is primarily intended for trade between two players. But
it can also in principle be used for a player negotiating with an
AI-controlled NPC. If the NPC uses normal commands they can use it
directly -- but more efficient is to have the NPC object send its
replies directly through the tradehandler to the player. One may want
to add some functionality to the decline command, so players can
decline specific objects in the NPC offer (decline <object>) and allow
the AI to maybe offer something else and make it into a proper
barter.  Along with an AI that "needs" things or has some sort of
personality in the trading, this can make bartering with NPCs at least
moderately more interesting than just plain 'buy'.

- Installation:

Just import the CmdTrade command into (for example) the default
cmdset. This will make the trade (or barter) command available
in-game.

"""

from ev import Command, Script, CmdSet

TRADE_TIMEOUT = 60  # timeout for B to accept trade


class TradeTimeout(Script):
    """
    This times out the trade request, in case player B did not reply in time.
    """
    def at_script_creation(self):
        "called when script is first created"
        self.key = "trade_request_timeout"
        self.desc = "times out trade requests"
        self.interval = TRADE_TIMEOUT
        self.start_delay = True
        self.repeats = 1
        self.persistent = False

    def at_repeat(self):
        "called once"
        if self.ndb.tradeevent:
            self.obj.ndb.tradeevent.finish(force=True)
        self.obj.msg("Trade request timed out.")

    def is_valid(self):
        "Only valid if the trade has not yet started"
        return self.obj.ndb.tradeevent and not self.obj.ndb.tradeevent.trade_started


class TradeHandler(object):
    """
    Objects of this class handles the ongoing trade, notably storing the current
    offers from each side and wether both have accepted or not.
    """
    def __init__(self, partA, partB):
        """
        Initializes the trade. This is called when part A tries to initiate
        a trade with part B. The trade will not start until part B repeats
        this command (B will then call the self.join() command)

        We also store the back-reference from the respective party to
        this object.
        """
        # parties
        self.partA = partA
        self.partB = partB

        self.partA.cmdset.add(CmdsetTrade())
        self.trade_started = False
        self.partA.ndb.tradehandler = self
        # trade variables
        self.partA_offers = []
        self.partB_offers = []
        self.partA_accepted = False
        self.partB_accepted = False

    def msg(self, party, string):
        """
        Relay a message to the other party. This allows
        the calling command to not have to worry about
        which party they are in the handler.
        """
        if self.partA == party:
            self.partB.msg(string)
        elif self.partB == party:
            self.partA.msg(string)
        else:
            # no match, relay to oneself
            self.party.msg(string)

    def get_other(self, party):
        "Returns the other party of the trade"
        if self.partA == party:
            return self.partB
        if self.partB == party:
            return self.partA
        return None

    def join(self, partB):
        """
        This is used once B decides to join the trade
        """
        print "join:", self.partB, partB, self.partB == partB, type(self.partB), type(partB)
        if self.partB == partB:
            self.partB.ndb.tradehandler = self
            self.partB.cmdset.add(CmdsetTrade())
            self.trade_started = True
            return True
        return False

    def unjoin(self, partB):
        """
        This is used if B decides not to join the trade
        """
        if self.partB == partB:
            self.finish()
            return True
        return False

    def offer(self, party, *args):
        """
        Change the current standing offer. We leave it up to the
        command to do the actual checks that the offer consists
        of real, valid, objects.
        """
        if self.trade_started:
            # reset accept statements whenever an offer changes
            self.partA_accepted = False
            self.partB_accepted = False
            if party == self.partA:
                self.partA_offers = list(args)
            elif party == self.partB:
                self.partB_offers = list(args)
            else:
                raise ValueError

    def list(self):
        """
        Returns two lists of objects on offer, separated by partA/B.
        """
        return self.partA_offers, self.partB_offers

    def search(self, offername):
        """
        Returns an object on offer, based on a search criterion.
        If the search criterion is an integer, treat it as an
        index to return in the list of offered items
        """
        all_offers = self.partA_offers + self.partB_offers
        if isinstance(offername, int):
            # an index to return
            if 0 <= offername < len(all_offers):
                return all_offers[offername]

        all_keys = [offer.key for offer in all_offers]
        try:
            imatch = all_keys.index(offername)
            return all_offers[imatch]
        except ValueError:
            for offer in all_offers:
                if offername in offer.aliases:
                    return offer
        return None

    def accept(self, party):
        """
        Accept the current offer.

        Returns True if this closes the deal, False otherwise
        """
        if self.trade_started:
            if party == self.partA:
                self.partA_accepted = True
            elif party == self.partB:
                self.partB_accepted = True
            else:
                raise ValueError
            return self.finish()  # try to close the deal

    def decline(self, party):
        """
        Remove an previously accepted status (changing ones mind)

        returns True if there was really a status to change, False otherwise.
        """
        if self.trade_started:
            if party == self.partA:
                if self.partA_accepted:
                    self.partA_accepted = False
                    return True
                return False
            elif party == self.partB:
                if self.partB_accepted:
                    self.partB_accepted = False
                    return True
                return False
            else:
                raise ValueError

    def finish(self, force=False):
        """
        Conclude trade - move all offers and clean up
        """
        fin = False
        if self.trade_started and self.partA_accepted and self.partB_accepted:
            # both accepted - move objects before cleanup
            for obj in self.partA_offers:
                obj.location = self.partB
            for obj in self.partB_offers:
                obj.location = self.partA
            fin = True
        if fin or force:
            # cleanup
            self.partA.cmdset.delete("cmdset_trade")
            self.partB.cmdset.delete("cmdset_trade")
            self.partA_offers = None
            self.partB_offers = None
            # this will kill it also from partB
            del self.partA.ndb.tradehandler
            if self.partB.ndb.tradehandler:
                del self.partB.ndb.tradehandler
            return True


# trading commands (will go into CmdsetTrade, initialized by the
# CmdTrade command further down).

class CmdTradeBase(Command):
    """
    Base command for Trade commands to inherit from. Implements
    the custom parsing.
    """
    def parse(self):
        """
        Parse the relevant parts and make it easily
        available to the command
        """
        self.args = self.args.strip()
        self.tradehandler = self.caller.ndb.tradehandler
        self.partA = self.tradehandler.partA
        self.partB = self.tradehandler.partB

        self.other = self.tradehandler.get_other(self.caller)
        self.msg_other = self.tradehandler.msg

        self.trade_started = self.tradehandler.trade_started
        self.emote = ""
        self.str_caller = "Your trade action: %s"
        self.str_other = "%s:s trade action: " % self.caller.key + "%s"
        if ':' in self.args:
            self.args, self.emote = [part.strip() for part in self.args.rsplit(":", 1)]
            self.str_caller = 'You say, "' + self.emote + '"\n  [%s]'
            if self.caller.has_player:
                self.str_other = '{c%s{n says, "' % self.caller.key + self.emote + '"\n  [%s]'
            else:
                self.str_other = '%s says, "' % self.caller.key + self.emote + '"\n  [%s]'


# trade help

class CmdTradeHelp(CmdTradeBase):
    """
    help command for the trade system.

    Usage:
        trade help

    Displays help for the trade commands.
    """
    key = "trade help"
    #aliases = ["trade help"]
    locks = "cmd:all()"
    help_category = "Trade"

    def func(self):
        "Show the help"
        string = """
        Trading commands

        {woffer <objects> [:emote]{n
            offer one or more objects for trade. The emote can be used for
            RP/arguments. A new offer will require both parties to re-accept
            it again.
        {waccept [:emote]{n
            accept the currently standing offer from both sides. Also 'agree'
            works. Once both have accepted, the deal is finished and goods
            will change hands.
        {wdecline [:emote]{n
            change your mind and remove a previous accept (until other
            has also accepted)
        {wstatus{n
            show the current offers on each side of the deal. Also 'offers'
            and 'deal' works.
        {wevaluate <nr> or <offer>{n
            examine any offer in the deal. List them with the 'status' command.
        {wend trade{n
            end the negotiations prematurely. No trade will take place.

        You can also use {wemote{n, {wsay{n etc to discuss
        without making a decision or offer.
        """
        self.caller.msg(string)


# offer

class CmdOffer(CmdTradeBase):
    """
    offer one or more items in trade.

    Usage:
      offer <object> [, object2, ...][:emote]

    Offer objects in trade. This will replace the currently
    standing offer.
    """
    key = "offer"
    locks = "cmd:all()"
    help_category = "Trading"

    def func(self):
        "implement the offer"

        caller = self.caller
        if not self.args:
            caller.msg("Usage: offer <object> [, object2, ...] [:emote]")
            return
        if not self.trade_started:
            caller.msg("Wait until the other party has accepted to trade with you.")
            return

        # gather all offers
        offers = [part.strip() for part in self.args.split(',')]
        offerobjs = []
        for offername in offers:
            obj = caller.search(offername)
            if not obj:
                return
            offerobjs.append(obj)
        self.tradehandler.offer(self.caller, *offerobjs)

        # output
        if len(offerobjs) > 1:
            objnames = ", ".join("{w%s{n" % obj.key for obj in offerobjs[:-1]) + " and {w%s{n" % offerobjs[-1].key
        else:
            objnames = "{w%s{n" % offerobjs[0].key

        caller.msg(self.str_caller % ("You offer %s" % objnames))
        self.msg_other(caller, self.str_other % ("They offer %s" % objnames))


# accept

class CmdAccept(CmdTradeBase):
    """
    accept the standing offer

    Usage:
      accept [:emote]
      agreee [:emote]

    This will accept the current offer. The other party must also accept
    for the deal to go through. You can use the 'decline' command to change
    your mind as long as the other party has not yet accepted. You can inspect
    the current offer using the 'offers' command.
    """
    key = "accept"
    aliases = ["agree"]
    locks = "cmd:all()"
    help_category = "Trading"

    def func(self):
        "accept the offer"
        caller = self.caller
        if not self.trade_started:
            caller.msg("Wait until the other party has accepted to trade with you.")
            return
        if self.tradehandler.accept(self.caller):
            # deal finished. Trade ended and cleaned.
            caller.msg(self.str_caller % "You {gaccept{n the deal. {gDeal is made and goods changed hands.{n")
            self.msg_other(caller, self.str_other % "%s {gaccepts{n the deal. {gDeal is made and goods changed hands.{n" % caller.key)
        else:
            # a one-sided accept.
            caller.msg(self.str_caller % "You {Gaccept{n the offer. %s must now also accept." % self.other.key)
            self.msg_other(caller, self.str_other % "%s {Gaccepts{n the offer. You must now also accept." % caller.key)


# decline

class CmdDecline(CmdTradeBase):
    """
    decline the standing offer

    Usage:
      decline [:emote]

    This will decline a previously 'accept'ed offer (so this allows you to
    change your mind). You can only use this as long as the other party
    has not yet accepted the deal. Also, changing the offer will automatically
    decline the old offer.
    """
    key = "decline"
    locks = "cmd:all()"
    help_category = "Trading"

    def func(self):
        "decline the offer"
        caller = self.caller
        if not self.trade_started:
            caller.msg("Wait until the other party has accepted to trade with you.")
            return
        offerA, offerB = self.tradehandler.list()
        if not offerA or not offerB:
            caller.msg("Noone has offered anything (yet) so there is nothing to decline.")
            return
        if self.tradehandler.decline(self.caller):
            # changed a previous accept
            caller.msg(self.str_caller % "You change your mind, {Rdeclining{n the current offer.")
            self.msg_other(caller, self.str_other % "%s changes their mind, {Rdeclining{n the current offer." % caller.key)
        else:
            # no acceptance to change
            caller.msg(self.str_caller % "You {Rdecline{n the current offer.")
            self.msg_other(caller, self.str_other % "%s declines the current offer." % caller.key)


# evaluate

# Note: This version only shows the description. If your particular game
# lists other important properties of objects (such as weapon damage, weight,
# magical properties, ammo requirements or whatnot), then you need to add this
# here.

class CmdEvaluate(CmdTradeBase):
    """
    evaluate objects on offer

    Usage:
      evaluate <offered object>

    This allows you to examine any object currently on offer, to
    determine if it's worth your while.
    """
    key = "evaluate"
    aliases = ["eval"]
    locks = "cmd:all()"
    help_category = "Trading"

    def func(self):
        "evaluate an object"
        caller = self.caller
        if not self.args:
            caller.msg("Usage: evaluate <offered object>")
            return
        # we also accept indices
        try:
            ind = int(self.args)
            self.args = ind - 1
        except Exception:
            pass

        offer = self.tradehandler.search(self.args)
        if not offer:
            caller.msg("No offer matching '%s' was found." % self.args)
            return
        # show the description
        caller.msg(offer.db.desc)


# status

class CmdStatus(CmdTradeBase):
    """
    show a list of the current deal

    Usage:
      status
      deal
      offers

    Shows the currently suggested offers on each sides of the deal. To
    accept the current deal, use the 'accept' command. Use 'offer' to
    change your deal. You might also want to use 'say', 'emote' etc to
    try to influence the other part in the deal.
    """
    key = "status"
    aliases = ["offers", "deal"]
    locks = "cmd:all()"
    help_category = "Trading"

    def func(self):
        "Show the current deal"
        caller = self.caller
        partA_offers, partB_offers = self.tradehandler.list()
        count = 1
        partA_offerlist = ""
        for offer in partA_offers:
            partA_offerlist += "\n {w%i{n %s" % (count, offer.key)
            count += 1
        if not partA_offerlist:
            partA_offerlist = "\n <nothing>"
        partB_offerlist = ""
        for offer in partB_offers:
            partB_offerlist += "\n {w%i{n %s" % (count, offer.key)
            count += 1
        if not partB_offerlist:
            partB_offerlist = "\n <nothing>"

        string = "{gOffered by %s:{n%s\n{yOffered by %s:{n%s" % (self.partA.key,
                                                                 partA_offerlist,
                                                                 self.partB.key,
                                                                 partB_offerlist)
        acceptA = self.tradehandler.partA_accepted and "{gYes{n" or "{rNo{n"
        acceptB = self.tradehandler.partB_accepted and "{gYes{n" or "{rNo{n"
        string += "\n\n%s agreed: %s, %s agreed: %s" % \
                                          (self.partA.key, acceptA, self.partB.key, acceptB)
        string += "\n Use 'offer', 'eval' and 'accept'/'decline' to trade. See also 'trade help'."
        caller.msg(string)


# finish

class CmdFinish(CmdTradeBase):
    """
    end the trade prematurely

    Usage:
      end trade [:say]
      finish trade [:say]

    This ends the trade prematurely. No trade will take place.

    """
    key = "end trade"
    aliases = "finish trade"
    locks = "cmd:all()"
    help_category = "Trading"

    def func(self):
        "end trade"
        caller = self.caller
        self.tradehandler.finish(force=True)
        caller.msg(self.str_caller % "You {raborted{n trade. No deal was made.")
        self.msg_other(caller, self.str_other % "%s {raborted{n trade. No deal was made." % caller.key)


# custom Trading cmdset

class CmdsetTrade(CmdSet):
    """
    This cmdset is added when trade is initated. It is handled by the
    trade event handler.
    """
    key = "cmdset_trade"

    def at_cmdset_creation(self):
        "Called when cmdset is created"
        self.add(CmdTradeHelp())
        self.add(CmdOffer())
        self.add(CmdAccept())
        self.add(CmdDecline())
        self.add(CmdEvaluate())
        self.add(CmdStatus())
        self.add(CmdFinish())


# access command - once both have given this, this will create the
# trading cmdset to start trade.

class CmdTrade(Command):
    """
    Initiate trade with another party

    Usage:
      trade <other party> [:say]
      trade <other party> accept [:say]
      trade <other party> decline [:say]

    Initiate trade with another party. The other party needs to repeat
    this command with trade accept/decline within a minute in order to
    properly initiate the trade action. You can use the decline option
    yourself if you want to retract an already suggested trade. The
    optional say part works like the say command and allows you to add
    info to your choice.
    """
    key = "trade"
    aliases = ["barter"]
    locks = "cmd:all()"
    help_category = "General"

    def func(self):
        "Initiate trade"

        if not self.args:
            if self.caller.ndb.tradehandler and self.caller.ndb.tradeevent.trade_started:
                self.caller.msg("You are already in a trade. Use 'end trade' to abort it.")
            else:
                self.caller.msg("Usage: trade <other party> [accept|decline] [:emote]")
            return
        self.args = self.args.strip()

        # handle the emote manually here
        selfemote = ""
        theiremote = ""
        if ':' in self.args:
            self.args, emote = [part.strip() for part in self.args.rsplit(":", 1)]
            selfemote = 'You say, "%s"\n  ' % emote
            if self.caller.has_player:
                theiremote = '{c%s{n says, "%s"\n  ' % (self.caller.key, emote)
            else:
                theiremote = '%s says, "%s"\n  ' % (self.caller.key, emote)

        # for the sake of this command, the caller is always partA; this
        # might not match the actual name in tradehandler (in the case of
        # using this command to accept/decline a trade invitation).
        partA = self.caller
        accept = 'accept' in self.args
        decline = 'decline' in self.args
        if accept:
            partB = self.args.rstrip('accept').strip()
        elif decline:
            partB = self.args.rstrip('decline').strip()
        else:
            partB = self.args
        partB = self.caller.search(partB)
        if not partB:
            return
        if partA == partB:
            partA.msg("You play trader with yourself.")
            return

        # messages
        str_initA = "You ask to trade with %s. They need to accept within %s secs."
        str_initB = "%s wants to trade with you. Use {wtrade %s accept/decline [:emote]{n to answer (within %s secs)."
        str_noinitA = "%s declines the trade"
        str_noinitB = "You decline trade with %s."
        str_startA = "%s starts to trade with you. See {wtrade help{n for aid."
        str_startB = "You start to trade with %s. See {wtrade help{n for aid."

        if not (accept or decline):
            # initialization of trade
            if self.caller.ndb.tradehandler:
                # trying to start trade without stopping a previous one
                if self.caller.ndb.tradehandler.trade_started:
                    string = "You are already in trade with %s. You need to end trade first."
                else:
                    string = "You are already trying to initiate trade with %s. You need to decline that trade first."
                self.caller.msg(string % partB.key)
            elif partB.ndb.tradehandler and partB.ndb.tradehandler.partB == partA:
                # this is equivalent to partA accepting a trade from partB (so roles are reversed)
                partB.ndb.tradehandler.join(partA)
                partB.msg(theiremote + str_startA % partA.key)
                partA.msg(selfemote + str_startB % (partB.key))
            else:
                # initiate a new trade
                TradeHandler(partA, partB)
                partA.msg(selfemote + str_initA % (partB.key, TRADE_TIMEOUT))
                partB.msg(theiremote + str_initB % (partA.key, partA.key, TRADE_TIMEOUT))
                partA.scripts.add(TradeTimeout)
            return
        elif accept:
            # accept a trade proposal from partB (so roles are reversed)
            if partA.ndb.tradehandler:
                # already in a trade
                partA.msg("You are already in trade with %s. You need to end that first." % partB.key)
                return
            if partB.ndb.tradehandler.join(partA):
                partB.msg(theiremote + str_startA % partA.key)
                partA.msg(selfemote + str_startB % partB.key)
            else:
                partA.msg("No trade proposal to accept.")
            return
        else:
            # decline trade proposal from partB (so roles are reversed)
            if partA.ndb.tradehandler and partA.ndb.tradehandler.partB == partA:
                # stopping an invite
                partA.ndb.tradehandler.finish(force=True)
                partB.msg(theiremote + "%s aborted trade attempt with you." % partA)
                partA.msg(selfemote + "You aborted the trade attempt with %s." % partB)
            elif partB.ndb.tradehandler and partB.ndb.tradehandler.unjoin(partA):
                partB.msg(theiremote + str_noinitA % partA.key)
                partA.msg(selfemote + str_noinitB % partB.key)
            else:
                partA.msg("No trade proposal to decline.")
            return


########NEW FILE########
__FILENAME__ = chargen
"""

Contribution - Griatch 2011

[Note - with the advent of MULTISESSION_MODE=2, this is not really
as necessary anymore - the ooclook and @charcreate commands in that
mode replaces this module with better functionality.]

This is a simple character creation commandset. A suggestion is to
test this together with menu_login, which doesn't create a Character
on its own. This shows some more info and gives the Player the option
to create a character without any more customizations than their name
(further options are unique for each game anyway).

Since this extends the OOC cmdset, logging in from the menu will
automatically drop the Player into this cmdset unless they logged off
while puppeting a Character already before.

Installation:

Read the instructions in game/gamesrc/commands/examples/cmdset.py in
order to create a new default cmdset module for Evennia to use (copy
the template up one level, and change the settings file's relevant
variables to point to the cmdsets inside). If you already have such
a module you should of course use that.

Next import this module in your custom cmdset module and add the
following line to the end of OOCCmdSet's at_cmdset_creation():

   self.add(chargen.OOCCmdSetCharGen)

"""

from django.conf import settings
from ev import Command, create_object, utils
from ev import default_cmds, managers

CHARACTER_TYPECLASS = settings.BASE_CHARACTER_TYPECLASS

class CmdOOCLook(default_cmds.CmdLook):
    """
    ooc look

    Usage:
      look
      look <character>

    This is an OOC version of the look command. Since a Player doesn't
    have an in-game existence, there is no concept of location or
    "self".

    If any characters are available for you to control, you may look
    at them with this command.
    """

    key = "look"
    aliases = ["l", "ls"]
    locks = "cmd:all()"
    help_cateogory = "General"

    def func(self):
        """
        Implements the ooc look command

        We use an attribute _character_dbrefs on the player in order
        to figure out which characters are "theirs". A drawback of this
        is that only the CmdCharacterCreate command adds this attribute,
        and thus e.g. player #1 will not be listed (although it will work).
        Existence in this list does not depend on puppeting rights though,
        that is checked by the @ic command directly.
        """

        # making sure caller is really a player
        self.character = None
        if utils.inherits_from(self.caller, "src.objects.objects.Object"):
            # An object of some type is calling. Convert to player.
            #print self.caller, self.caller.__class__
            self.character = self.caller
            if hasattr(self.caller, "player"):
                self.caller = self.caller.player

        if not self.character:
            # ooc mode, we are players

            avail_chars = self.caller.db._character_dbrefs
            if self.args:
                # Maybe the caller wants to look at a character
                if not avail_chars:
                    self.caller.msg("You have no characters to look at. Why not create one?")
                    return
                objs = managers.objects.get_objs_with_key_and_typeclass(self.args.strip(), CHARACTER_TYPECLASS)
                objs = [obj for obj in objs if obj.id in avail_chars]
                if not objs:
                    self.caller.msg("You cannot see this Character.")
                    return
                self.caller.msg(objs[0].return_appearance(self.caller))
                return

            # not inspecting a character. Show the OOC info.
            charobjs = []
            charnames = []
            if self.caller.db._character_dbrefs:
                dbrefs = self.caller.db._character_dbrefs
                charobjs = [managers.objects.get_id(dbref) for dbref in dbrefs]
                charnames = [charobj.key for charobj in charobjs if charobj]
            if charnames:
                charlist = "The following Character(s) are available:\n\n"
                charlist += "\n\r".join(["{w    %s{n" % charname for charname in charnames])
                charlist += "\n\n   Use {w@ic <character name>{n to switch to that Character."
            else:
                charlist = "You have no Characters."
            string = \
"""   You, %s, are an {wOOC ghost{n without form. The world is hidden
   from you and besides chatting on channels your options are limited.
   You need to have a Character in order to interact with the world.

   %s

   Use {wcreate <name>{n to create a new character and {whelp{n for a
   list of available commands.""" % (self.caller.key, charlist)
            self.caller.msg(string)

        else:
            # not ooc mode - leave back to normal look
            # we have to put this back for normal look to work.
            self.caller = self.character
            super(CmdOOCLook, self).func()


class CmdOOCCharacterCreate(Command):
    """
    creates a character

    Usage:
      create <character name>

    This will create a new character, assuming
    the given character name does not already exist.
    """

    key = "create"
    locks = "cmd:all()"

    def func(self):
        """
        Tries to create the Character object. We also put an
        attribute on ourselves to remember it.
        """

        # making sure caller is really a player
        self.character = None
        if utils.inherits_from(self.caller, "src.objects.objects.Object"):
            # An object of some type is calling. Convert to player.
            #print self.caller, self.caller.__class__
            self.character = self.caller
            if hasattr(self.caller, "player"):
                self.caller = self.caller.player

        if not self.args:
            self.caller.msg("Usage: create <character name>")
            return
        charname = self.args.strip()
        old_char = managers.objects.get_objs_with_key_and_typeclass(charname, CHARACTER_TYPECLASS)
        if old_char:
            self.caller.msg("Character {c%s{n already exists." % charname)
            return
        # create the character

        new_character = create_object(CHARACTER_TYPECLASS, key=charname)
        if not new_character:
            self.caller.msg("{rThe Character couldn't be created. This is a bug. Please contact an admin.")
            return
        # make sure to lock the character to only be puppeted by this player
        new_character.locks.add("puppet:id(%i) or pid(%i) or perm(Immortals) or pperm(Immortals)" %
                                (new_character.id, self.caller.id))

        # save dbref
        avail_chars = self.caller.db._character_dbrefs
        if avail_chars:
            avail_chars.append(new_character.id)
        else:
            avail_chars = [new_character.id]
        self.caller.db._character_dbrefs = avail_chars
        self.caller.msg("{gThe Character {c%s{g was successfully created!" % charname)


class OOCCmdSetCharGen(default_cmds.OOCCmdSet):
    """
    Extends the default OOC cmdset.
    """
    def at_cmdset_creation(self):
        "Install everything from the default set, then overload"
        #super(OOCCmdSetCharGen, self).at_cmdset_creation()
        self.add(CmdOOCLook())
        self.add(CmdOOCCharacterCreate())

########NEW FILE########
__FILENAME__ = dice
"""
Dice - rolls dice for roleplaying, in-game gambling or GM:ing

Evennia contribution - Griatch 2012


This module implements a full-fledged dice-roller and a 'dice' command to
go with it. It uses standard RPG 'd'-syntax (e.g. 2d6 to roll two
six-sided die) and also supports modifiers such as 3d6 + 5.

One can also specify a standard Python operator in order to specify
eventual target numbers and get results in a fair and guaranteed
unbiased way.  For example a GM could (using the dice command) from
the start define the roll as 2d6 < 8 to show that a roll below 8 is
required to succeed. The command will normally echo this result to all
parties (although it also has options for hidden and secret rolls).


Installation:

To use in your code, just import the roll_dice function from this module.

To use  the dice/roll command, just import this module in your custom
cmdset module and add the following line to the end of DefaultCmdSet's
at_cmdset_creation():

   self.add(dice.CmdDice())

After a reload the dice (or roll) command will be available in-game.

"""

import re
from random import randint
from ev import default_cmds, CmdSet


def roll_dice(dicenum, dicetype, modifier=None, conditional=None, return_tuple=False):
    """
    This is a standard dice roller.

    Input:
     dicenum - number of dice to roll (the result to be added)
     dicetype - number of sides of the dice to be rolled
     modifier - tuple (operator, value), where operator is a character string
                with one of +,-,/ or *. The entire result of the dice rolls will
                be modified by this value.
     conditional - tuple (conditional, value), where conditional is a character
                   string with one of ==,<,>,>=,<= or !=.
     return_tuple - return result as a tuple containing all relevant info
     return_tuple - (default False) - return a tuple with all individual roll
                    results
    All input numbers are converted to integers.

    Returns:
         normally returns the result
         if return_tuple=True, returns a tuple (result, outcome, diff, rolls)
                In this tuple, outcome and diff will be None if conditional is
                not set. rolls is itself a tuple holding all the individual
                rolls in the case of multiple die-rolls.

    Raises:
        TypeError if non-supported modifiers or conditionals are given.

    """
    dicelimit = 0 # This is the maximum number of dice that can be used in a single roll.
    dicenum = int(dicenum)
    dicetype = int(dicetype)

    # roll all dice, remembering each roll
    rolls = tuple([randint(1, dicetype) for roll in range(dicenum)])
    result = sum(rolls)

    if modifier:
        # make sure to check types well before eval
        mod, modvalue = modifier
        if not mod in ('+', '-', '*', '/'):
            raise TypeError("Non-supported dice modifier: %s" % mod)
        modvalue = int(modvalue)  # for safety
        result = eval("%s %s %s" % (result, mod, modvalue))
    outcome, diff = None, None
    if conditional:
        # make sure to check types well before eval
        cond, condvalue = conditional
        if not cond in ('>', '<', '>=', '<=', '!=', '=='):
            raise TypeError("Non-supported dice result conditional: %s" % conditional)
        condvalue = int(condvalue)  # for safety
        outcome = eval("%s %s %s" % (result, cond, condvalue))  # True/False
        diff = abs(result - condvalue)
    if return_tuple:
        return (result, outcome, diff, rolls)
    else:
        return result

RE_PARTS = re.compile(r"(d|\+|-|/|\*|<|>|<=|>=|!=|==)")
RE_MOD = re.compile(r"(\+|-|/|\*)")
RE_COND = re.compile(r"(<|>|<=|>=|!=|==)")


class CmdDice(default_cmds.MuxCommand):
    """
    roll dice

    Usage:
      dice[/switch] <nr>d<sides> [modifier] [success condition]

    Switch:
      hidden - tell the room the roll is being done, but don't show the result
      secret - don't inform the room about neither roll nor result

    Examples:
      dice 3d6 + 4
      dice 1d100 - 2 < 50

    This will roll the given number of dice with given sides and modifiers.
    So e.g. 2d6 + 3 means to 'roll a 6-sided die 2 times and add the result,
    then add 3 to the total'.
    Accepted modifiers are +, -, * and /.
    A success condition is given as normal Python conditionals
    (<,>,<=,>=,==,!=). So e.g. 2d6 + 3 > 10 means that the roll will succeed
    only if the final result is above 8. If a success condition is given, the
    outcome (pass/fail) will be echoed along with how much it succeeded/failed
    with. The hidden/secret switches will hide all or parts of the roll from
    everyone but the person rolling.
    """

    key = "dice"
    aliases = ["roll", "@dice"]
    locks = "cmd:all()"

    def func(self):
        "Mostly parsing for calling the dice roller function"

        if not self.args:
            self.caller.msg("Usage: @dice <nr>d<sides> [modifier] [conditional]")
            return
        argstring = "".join(str(arg) for arg in self.args)

        parts = RE_PARTS.split(self.args)
        lparts = len(parts)

        ndice = 0
        nsides = 0
        modifier = None
        conditional = None

        if lparts < 3 or parts[1] != 'd':
            self.caller.msg("You must specify the die roll(s) as <nr>d<sides>. So 2d6 means rolling a 6-sided die 2 times.")
            return

        # Limit the number of dice and sides a character can roll to prevent server slow down and crashes
        ndicelimit = 10000 # Maximum number of dice
        nsidelimit = 10000 # Maximum number of sides
        if int(parts[0]) > ndicelimit or int(parts[2]) > nsidelimit:
            self.caller.msg("The maximum roll allowed is %sd%s." % (ndicelimit, nsidelimit))
            return

        ndice, nsides = parts[0], parts[2]
        if lparts == 3:
            # just something like 1d6
            pass
        elif lparts == 5:
            # either e.g. 1d6 + 3  or something like 1d6 > 3
            if parts[3] in ('+', '-', '*', '/'):
                modifier = (parts[3], parts[4])
            else:  # assume it is a conditional
                conditional = (parts[3], parts[4])
        elif lparts == 7:
            # the whole sequence, e.g. 1d6 + 3 > 5
            modifier = (parts[3], parts[4])
            conditional = (parts[5], parts[6])
        else:
            # error
            self.caller.msg("You must specify a valid die roll")
            return
        # do the roll
        try:
            result, outcome, diff, rolls = roll_dice(ndice,
                                                     nsides,
                                                     modifier=modifier,
                                                     conditional=conditional,
                                                     return_tuple=True)
        except ValueError:
            self.caller.msg("You need to enter valid integer numbers, modifiers and operators. {w%s{n was not understood." % self.args)
            return
        # format output
        if len(rolls) > 1:
            rolls = ", ".join(str(roll) for roll in rolls[:-1]) + " and " + str(rolls[-1])
        else:
            rolls = rolls[0]
        if outcome is None:
            outcomestring = ""
        elif outcome:
            outcomestring = " This is a {gsuccess{n (by %s)." % diff
        else:
            outcomestring = " This is a {rfailure{n (by %s)." % diff
        yourollstring = "You roll %s%s."
        roomrollstring = "%s rolls %s%s."
        resultstring = " Roll(s): %s. Total result is {w%s{n."

        if 'secret' in self.switches:
            # don't echo to the room at all
            string = yourollstring % (argstring, " (secret, not echoed)")
            string += "\n" + resultstring % (rolls, result)
            string += outcomestring + " (not echoed)"
            self.caller.msg(string)
        elif 'hidden' in self.switches:
            # announce the roll to the room, result only to caller
            string = yourollstring % (argstring, " (hidden)")
            self.caller.msg(string)
            string = roomrollstring % (self.caller.key, argstring, " (hidden)")
            self.caller.location.msg_contents(string, exclude=self.caller)
            # handle result
            string = resultstring % (rolls, result)
            string += outcomestring + " (not echoed)"
            self.caller.msg(string)
        else:
            # normal roll
            string = yourollstring % (argstring, "")
            self.caller.msg(string)
            string = roomrollstring % (self.caller.key, argstring, "")
            self.caller.location.msg_contents(string, exclude=self.caller)
            string = resultstring % (rolls, result)
            string += outcomestring
            self.caller.location.msg_contents(string)

class DiceCmdSet(CmdSet):
    """
    a small cmdset for testing purposes.
    Add with @py self.cmdset.add("contrib.dice.DiceCmdSet")
    """
    def at_cmdset_creation(self):
        "Called when set is created"
        self.add(CmdDice())

########NEW FILE########
__FILENAME__ = email-login
"""
Email-based login system

Evennia contrib - Griatch 2012


This is a variant of the login system that requires a email-adress
instead of a username to login.

This used to be the default Evennia login before replacing it with a
more standard username + password system (having to supply an email
for some reason caused a lot of confusion when people wanted to expand
on it. The email is not strictly needed internally, nor is any
confirmation email sent out anyway).


Install is simple:

To your settings file, add/edit the line:

CMDSET_UNLOGGEDIN = "contrib.email-login.UnloggedinCmdSet"

That's it. Reload the server and try to log in to see it.

The initial login "graphic" will still not mention email addresses
after this change. The login splash screen is taken from strings in
the module given by settings.CONNECTION_SCREEN_MODULE. You will want
to copy the template file in game/gamesrc/conf/examples up one level
and re-point the settings file to this custom module. The "MUX_SCREEN"
example in that file is the recommended one to use with this module.

"""
import re
import traceback
from django.conf import settings
from src.players.models import PlayerDB
from src.objects.models import ObjectDB
from src.server.models import ServerConfig
from src.comms.models import ChannelDB

from src.commands.cmdset import CmdSet
from src.utils import create, logger, utils, ansi
from src.commands.default.muxcommand import MuxCommand
from src.commands.cmdhandler import CMD_LOGINSTART

# limit symbol import for API
__all__ = ("CmdUnconnectedConnect", "CmdUnconnectedCreate",
           "CmdUnconnectedQuit", "CmdUnconnectedLook", "CmdUnconnectedHelp")

MULTISESSION_MODE = settings.MULTISESSION_MODE
CONNECTION_SCREEN_MODULE = settings.CONNECTION_SCREEN_MODULE
CONNECTION_SCREEN = ""
try:
    CONNECTION_SCREEN = ansi.parse_ansi(utils.random_string_from_module(CONNECTION_SCREEN_MODULE))
except Exception:
    pass
if not CONNECTION_SCREEN:
    CONNECTION_SCREEN = "\nEvennia: Error in CONNECTION_SCREEN MODULE (randomly picked connection screen variable is not a string). \nEnter 'help' for aid."


class CmdUnconnectedConnect(MuxCommand):
    """
    Connect to the game.

    Usage (at login screen):
      connect <email> <password>

    Use the create command to first create an account before logging in.
    """
    key = "connect"
    aliases = ["conn", "con", "co"]
    locks = "cmd:all()"  # not really needed

    def func(self):
        """
        Uses the Django admin api. Note that unlogged-in commands
        have a unique position in that their func() receives
        a session object instead of a source_object like all
        other types of logged-in commands (this is because
        there is no object yet before the player has logged in)
        """

        session = self.caller
        arglist = self.arglist

        if not arglist or len(arglist) < 2:
            session.msg("\n\r Usage (without <>): connect <email> <password>")
            return
        email = arglist[0]
        password = arglist[1]

        # Match an email address to an account.
        player = PlayerDB.objects.get_player_from_email(email)
        # No playername match
        if not player:
            string = "The email '%s' does not match any accounts." % email
            string += "\n\r\n\rIf you are new you should first create a new account "
            string += "using the 'create' command."
            session.msg(string)
            return
        # We have at least one result, so we can check the password.
        if not player.check_password(password):
            session.msg("Incorrect password.")
            return

        # Check IP and/or name bans
        bans = ServerConfig.objects.conf("server_bans")
        if bans and (any(tup[0] == player.name for tup in bans)
                     or
                     any(tup[2].match(session.address[0]) for tup in bans if tup[2])):
            # this is a banned IP or name!
            string = "{rYou have been banned and cannot continue from here."
            string += "\nIf you feel this ban is in error, please email an admin.{x"
            session.msg(string)
            session.execute_cmd("quit")
            return

        # actually do the login. This will call all hooks.
        session.sessionhandler.login(session, player)

class CmdUnconnectedCreate(MuxCommand):
    """
    Create a new account.

    Usage (at login screen):
      create \"playername\" <email> <password>

    This creates a new player account.

    """
    key = "create"
    aliases = ["cre", "cr"]
    locks = "cmd:all()"

    def parse(self):
        """
        The parser must handle the multiple-word player
        name enclosed in quotes:
        connect "Long name with many words" my@myserv.com mypassw
        """
        super(CmdUnconnectedCreate, self).parse()

        self.playerinfo = []
        if len(self.arglist) < 3:
            return
        if len(self.arglist) > 3:
            # this means we have a multi_word playername. pop from the back.
            password = self.arglist.pop()
            email = self.arglist.pop()
            # what remains is the playername.
            playername = " ".join(self.arglist)
        else:
            playername, email, password = self.arglist

        playername = playername.replace('"', '')  # remove "
        playername = playername.replace("'", "")
        self.playerinfo = (playername, email, password)

    def func(self):
        "Do checks and create account"

        session = self.caller

        try:
            playername, email, password = self.playerinfo
        except ValueError:
            string = "\n\r Usage (without <>): create \"<playername>\" <email> <password>"
            session.msg(string)
            return
        if not re.findall('^[\w. @+-]+$', playername) or not (0 < len(playername) <= 30):
            session.msg("\n\r Playername can max be 30 characters or fewer. Letters, spaces, dig\
its and @/./+/-/_ only.") # this echoes the restrictions made by django's auth module.
            return
        if not email or not password:
            session.msg("\n\r You have to supply an e-mail address followed by a password." )
            return

        if not utils.validate_email_address(email):
            # check so the email at least looks ok.
            session.msg("'%s' is not a valid e-mail address." % email)
            return

        # Run sanity and security checks

        if PlayerDB.objects.filter(username=playername):
            # player already exists
            session.msg("Sorry, there is already a player with the name '%s'." % playername)
            return
        if PlayerDB.objects.get_player_from_email(email):
            # email already set on a player
            session.msg("Sorry, there is already a player with that email address.")
            return
        if len(password) < 3:
            # too short password
            string = "Your password must be at least 3 characters or longer."
            string += "\n\rFor best security, make it at least 8 characters long, "
            string += "avoid making it a real word and mix numbers into it."
            session.msg(string)
            return

        # everything's ok. Create the new player account.
        try:
            default_home = ObjectDB.objects.get_id(settings.DEFAULT_HOME)

            typeclass = settings.BASE_CHARACTER_TYPECLASS
            permissions = settings.PERMISSION_PLAYER_DEFAULT

            try:
                new_player = create.create_player(playername, email, password,
                                                     permissions=permissions)

            except Exception, e:
                session.msg("There was an error creating the default Player/Character:\n%s\n If this problem persists, contact an admin." % e)
                logger.log_trace()
                return

            # This needs to be called so the engine knows this player is
            # logging in for the first time. (so it knows to call the right
            # hooks during login later)
            utils.init_new_player(new_player)

            # join the new player to the public channel
            pchanneldef = settings.CHANNEL_PUBLIC
            if pchanneldef:
                pchannel = ChannelDB.objects.get_channel(pchanneldef[0])
                if not pchannel.connect(new_player):
                    string = "New player '%s' could not connect to public channel!" % new_player.key
                    logger.log_errmsg(string)

            if MULTISESSION_MODE < 2:
                # if we only allow one character, create one with the same name as Player
                # (in mode 2, the character must be created manually once logging in)
                new_character = create.create_object(typeclass, key=playername,
                                          location=default_home, home=default_home,
                                          permissions=permissions)
                # set playable character list
                new_player.db._playable_characters.append(new_character)

                # allow only the character itself and the player to puppet this character (and Immortals).
                new_character.locks.add("puppet:id(%i) or pid(%i) or perm(Immortals) or pperm(Immortals)" %
                                        (new_character.id, new_player.id))

                # If no description is set, set a default description
                if not new_character.db.desc:
                    new_character.db.desc = "This is a Player."
                # We need to set this to have @ic auto-connect to this character
                new_player.db._last_puppet = new_character

            # tell the caller everything went well.
            string = "A new account '%s' was created. Welcome!"
            if " " in playername:
                string += "\n\nYou can now log in with the command 'connect %s <your password>'."
            else:
                string += "\n\nYou can now log with the command 'connect %s <your password>'."
            session.msg(string % (playername, email))

        except Exception:
            # We are in the middle between logged in and -not, so we have
            # to handle tracebacks ourselves at this point. If we don't,
            # we won't see any errors at all.
            string = "%s\nThis is a bug. Please e-mail an admin if the problem persists."
            session.msg(string % (traceback.format_exc()))
            logger.log_errmsg(traceback.format_exc())

class CmdUnconnectedQuit(MuxCommand):
    """
    We maintain a different version of the quit command
    here for unconnected players for the sake of simplicity. The logged in
    version is a bit more complicated.
    """
    key = "quit"
    aliases = ["q", "qu"]
    locks = "cmd:all()"

    def func(self):
        "Simply close the connection."
        session = self.caller
        session.msg("Good bye! Disconnecting ...")
        session.session_disconnect()


class CmdUnconnectedLook(MuxCommand):
    """
    This is an unconnected version of the look command for simplicity.

    This is called by the server and kicks everything in gear.
    All it does is display the connect screen.
    """
    key = CMD_LOGINSTART
    aliases = ["look", "l"]
    locks = "cmd:all()"

    def func(self):
        "Show the connect screen."
        self.caller.msg(CONNECTION_SCREEN)


class CmdUnconnectedHelp(MuxCommand):
    """
    This is an unconnected version of the help command,
    for simplicity. It shows a pane of info.
    """
    key = "help"
    aliases = ["h", "?"]
    locks = "cmd:all()"

    def func(self):
        "Shows help"

        string = \
            """
You are not yet logged into the game. Commands available at this point:
  {wcreate, connect, look, help, quit{n

To login to the system, you need to do one of the following:

{w1){n If you have no previous account, you need to use the 'create'
   command like this:

     {wcreate "Anna the Barbarian" anna@myemail.com c67jHL8p{n

   It's always a good idea (not only here, but everywhere on the net)
   to not use a regular word for your password. Make it longer than
   3 characters (ideally 6 or more) and mix numbers and capitalization
   into it.

{w2){n If you have an account already, either because you just created
   one in {w1){n above or you are returning, use the 'connect' command:

     {wconnect anna@myemail.com c67jHL8p{n

   This should log you in. Run {whelp{n again once you're logged in
   to get more aid. Hope you enjoy your stay!

You can use the {wlook{n command if you want to see the connect screen again.
"""
        self.caller.msg(string)


# command set for the mux-like login

class UnloggedinCmdSet(CmdSet):
    """
    Sets up the unlogged cmdset.
    """
    key = "Unloggedin"
    priority = 0

    def at_cmdset_creation(self):
        "Populate the cmdset"
        self.add(CmdUnconnectedConnect())
        self.add(CmdUnconnectedCreate())
        self.add(CmdUnconnectedQuit())
        self.add(CmdUnconnectedLook())
        self.add(CmdUnconnectedHelp())

########NEW FILE########
__FILENAME__ = extended_room
"""
Extended Room

Evennia Contribution - Griatch 2012

This is an extended Room typeclass for Evennia. It is supported
by an extended Look command and an extended @desc command, also
in this module.


Features:

1) Time-changing description slots

This allows to change the full description text the room shows
depending on larger time variations. Four seasons - spring, summer,
autumn and winter are used by default). The season is calculated
on-demand (no Script or timer needed) and updates the full text block.

There is also a general description which is used as fallback if
one or more of the seasonal descriptions are not set when their
time comes.

An updated @desc command allows for setting seasonal descriptions.

The room uses the src.utils.gametime.GameTime global script. This is
started by default, but if you have deactivated it, you need to
supply your own time keeping mechanism.


2) In-description changing tags

Within each seasonal (or general) description text, you can also embed
time-of-day dependent sections. Text inside such a tag will only show
during that particular time of day. The tags looks like <timeslot> ...
</timeslot>. By default there are four timeslots per day - morning,
afternoon, evening and night.


3) Details

The Extended Room can be "detailed" with special keywords. This makes
use of a special Look command. Details are "virtual" targets to look
at, without there having to be a database object created for it. The
Details are simply stored in a dictionary on the room and if the look
command cannot find an object match for a "look <target>" command it
will also look through the available details at the current location
if applicable. An extended @desc command is used to set details.


4) Extra commands

  CmdExtendedLook - look command supporting room details
  CmdExtendedDesc - @desc command allowing to add seasonal descs and details,
                    as well as listing them
  CmdGameTime     - A simple "time" command, displaying the current
                    time and season.


Installation/testing:

1) Add CmdExtendedLook, CmdExtendedDesc and CmdGameTime to the default cmdset
   (see wiki how to do this).
2) @dig a room of type contrib.extended_room.ExtendedRoom (or make it the
   default room type)
3) Use @desc and @detail to customize the room, then play around!

"""

import re
from django.conf import settings
from ev import Room
from ev import gametime
from ev import default_cmds
from ev import utils

# error return function, needed by Extended Look command
_AT_SEARCH_RESULT = utils.variable_from_module(*settings.SEARCH_AT_RESULT.rsplit('.', 1))

# regexes for in-desc replacements
RE_MORNING = re.compile(r"<morning>(.*?)</morning>", re.IGNORECASE)
RE_AFTERNOON = re.compile(r"<afternoon>(.*?)</afternoon>", re.IGNORECASE)
RE_EVENING = re.compile(r"<evening>(.*?)</evening>", re.IGNORECASE)
RE_NIGHT = re.compile(r"<night>(.*?)</night>", re.IGNORECASE)
# this map is just a faster way to select the right regexes (the first
# regex in each tuple will be parsed, the following will always be weeded out)
REGEXMAP = {"morning": (RE_MORNING, RE_AFTERNOON, RE_EVENING, RE_NIGHT),
            "afternoon": (RE_AFTERNOON, RE_MORNING, RE_EVENING, RE_NIGHT),
            "evening": (RE_EVENING, RE_MORNING, RE_AFTERNOON, RE_NIGHT),
            "night": (RE_NIGHT, RE_MORNING, RE_AFTERNOON, RE_EVENING)}

# set up the seasons and time slots. This assumes gametime started at the
# beginning of the year (so month 1 is equivalent to January), and that
# one CAN divive the game's year into four seasons in the first place ...
MONTHS_PER_YEAR = settings.TIME_MONTH_PER_YEAR
SEASONAL_BOUNDARIES = (3 / 12.0, 6 / 12.0, 9 / 12.0)
HOURS_PER_DAY = settings.TIME_HOUR_PER_DAY
DAY_BOUNDARIES = (0, 6 / 24.0, 12 / 24.0, 18 / 24.0)


# implements the Extended Room

class ExtendedRoom(Room):
    """
    This room implements a more advanced look functionality depending on
    time. It also allows for "details", together with a slightly modified
    look command.
    """
    def at_object_creation(self):
        "Called when room is first created only."
        self.db.spring_desc = ""
        self.db.summer_desc = ""
        self.db.autumn_desc = ""
        self.db.winter_desc = ""
        # the general desc is used as a fallback if a seasonal one is not set
        self.db.general_desc = ""
        # will be set dynamically. Can contain raw timeslot codes
        self.db.raw_desc = ""
        # this will be set dynamically at first look. Parsed for timeslot codes
        self.db.desc = ""
        # these will be filled later
        self.ndb.last_season = None
        self.ndb.last_timeslot = None
        # detail storage
        self.db.details = {}

    def get_time_and_season(self):
        """
        Calculate the current time and season ids
        """
        # get the current time as parts of year and parts of day
        # returns a tuple (years,months,weeks,days,hours,minutes,sec)
        time = gametime.gametime(format=True)
        month, hour = time[1], time[4]
        season = float(month) / MONTHS_PER_YEAR
        timeslot = float(hour) / HOURS_PER_DAY

        # figure out which slots these represent
        if SEASONAL_BOUNDARIES[0] <= season < SEASONAL_BOUNDARIES[1]:
            curr_season = "spring"
        elif SEASONAL_BOUNDARIES[1] <= season < SEASONAL_BOUNDARIES[2]:
            curr_season = "summer"
        elif SEASONAL_BOUNDARIES[2] <= season < 1.0 + SEASONAL_BOUNDARIES[0]:
            curr_season = "autumn"
        else:
            curr_season = "winter"

        if DAY_BOUNDARIES[0] <= timeslot < DAY_BOUNDARIES[1]:
            curr_timeslot = "night"
        elif DAY_BOUNDARIES[1] <= timeslot < DAY_BOUNDARIES[2]:
            curr_timeslot = "morning"
        elif DAY_BOUNDARIES[2] <= timeslot < DAY_BOUNDARIES[3]:
            curr_timeslot = "afternoon"
        else:
            curr_timeslot = "evening"

        return curr_season, curr_timeslot

    def replace_timeslots(self, raw_desc, curr_time):
        """
        Filter so that only time markers <timeslot>...</timeslot> of the
        correct timeslot remains in the description.
        """
        if raw_desc:
            regextuple = REGEXMAP[curr_time]
            raw_desc = regextuple[0].sub(r"\1", raw_desc)
            raw_desc = regextuple[1].sub("", raw_desc)
            raw_desc = regextuple[2].sub("", raw_desc)
            return regextuple[3].sub("", raw_desc)
        return raw_desc

    def return_detail(self, key):
        """
        This will attempt to match a "detail" to look for in the room. A detail
        is a way to offer more things to look at in a room without having to
        add new objects. For this to work, we require a custom look command that
        allows for "look <detail>" - the look command should defer to this
        method on the current location (if it exists) before giving up on
        finding the target.

        Details are not season-sensitive, but are parsed for timeslot markers.
        """
        try:
            detail = self.db.details.get(key.lower(), None)
        except AttributeError:
            # this happens if no attribute details is set at all
            return None
        if detail:
            season, timeslot = self.get_time_and_season()
            detail = self.replace_timeslots(detail, timeslot)
            return detail
        return None

    def return_appearance(self, looker):
        "This is called when e.g. the look command wants to retrieve the description of this object."
        raw_desc = self.db.raw_desc or ""
        update = False

        # get current time and season
        curr_season, curr_timeslot = self.get_time_and_season()

        # compare with previously stored slots
        last_season = self.ndb.last_season
        last_timeslot = self.ndb.last_timeslot

        if curr_season != last_season:
            # season changed. Load new desc, or a fallback.
            if curr_season == 'spring':
                new_raw_desc = self.db.spring_desc
            elif curr_season == 'summer':
                new_raw_desc = self.db.summer_desc
            elif curr_season == 'autumn':
                new_raw_desc = self.db.autumn_desc
            else:
                new_raw_desc = self.db.winter_desc
            if new_raw_desc:
                raw_desc = new_raw_desc
            else:
                # no seasonal desc set. Use fallback
                raw_desc = self.db.general_desc or self.db.desc
            self.db.raw_desc = raw_desc
            self.ndb.last_season = curr_season
            update = True

        if curr_timeslot != last_timeslot:
            # timeslot changed. Set update flag.
            self.ndb.last_timeslot = curr_timeslot
            update = True

        if update:
            # if anything changed we have to re-parse
            # the raw_desc for time markers
            # and re-save the description again.
            self.db.desc = self.replace_timeslots(self.db.raw_desc, curr_timeslot)
        # run the normal return_appearance method, now that desc is updated.
        return super(ExtendedRoom, self).return_appearance(looker)


# Custom Look command supporting Room details. Add this to
# the Default cmdset to use.

class CmdExtendedLook(default_cmds.CmdLook):
    """
    look

    Usage:
      look
      look <obj>
      look <room detail>
      look *<player>

    Observes your location, details at your location or objects in your vicinity.
    """
    def func(self):
        """
        Handle the looking - add fallback to details.
        """
        caller = self.caller
        args = self.args
        if args:
            looking_at_obj = caller.search(args, use_nicks=True, quiet=True)
            if not looking_at_obj:
                # no object found. Check if there is a matching
                # detail at location.
                location = caller.location
                if location and hasattr(location, "return_detail") and callable(location.return_detail):
                    detail = location.return_detail(args)
                    if detail:
                        # we found a detail instead. Show that.
                        caller.msg(detail)
                        return
                # no detail found. Trigger delayed error messages
                _AT_SEARCH_RESULT(caller, args, looking_at_obj, False)
                return
            else:
                # we need to extract the match manually.
                looking_at_obj = utils.make_iter(looking_at_obj)[0]
        else:
            looking_at_obj = caller.location
            if not looking_at_obj:
                caller.msg("You have no location to look at!")
                return

        if not hasattr(looking_at_obj, 'return_appearance'):
            # this is likely due to us having a player instead
            looking_at_obj = looking_at_obj.character
        if not looking_at_obj.access(caller, "view"):
            caller.msg("Could not find '%s'." % args)
            return
        # get object's appearance
        caller.msg(looking_at_obj.return_appearance(caller))
        # the object's at_desc() method.
        looking_at_obj.at_desc(looker=caller)


# Custom build commands for setting seasonal descriptions
# and detailing extended rooms.

class CmdExtendedDesc(default_cmds.CmdDesc):
    """
    @desc - describe an object or room

    Usage:
      @desc[/switch] [<obj> =] <description>
      @detail[/del] [<key> = <description>]


    Switches for @desc:
      spring  - set description for <season> in current room
      summer
      autumn
      winter

    Switch for @detail:
      del   - delete a named detail

    Sets the "desc" attribute on an object. If an object is not given,
    describe the current room.

    The alias @detail allows to assign a "detail" (a non-object
    target for the look command) to the current room (only).

    You can also embed special time markers in your room description, like this:
      <night>In the darkness, the forest looks foreboding.</night>. Text
    marked this way will only display when the server is truly at the given
    time slot. The available times
    are night, morning, afternoon and evening.

    Note that @detail, seasons and time-of-day slots only works on rooms in this
    version of the @desc command.

    """
    aliases = ["@describe", "@detail"]

    def reset_times(self, obj):
        "By deleteting the caches we force a re-load."
        obj.ndb.last_season = None
        obj.ndb.last_timeslot = None

    def func(self):
        "Define extended command"
        caller = self.caller
        location = caller.location
        if self.cmdstring == '@detail':
            # switch to detailing mode. This operates only on current location
            if not location:
                caller.msg("No location to detail!")
                return
            if not self.rhs:
                # no '=' used - list content of given detail
                if self.args in location.db.details:
                    string = "{wDetail '%s' on %s:\n{n" % (self.args, location)
                    string += location.db.details[self.args]
                    caller.msg(string)
                    return
            if not self.args:
                # No args given. Return all details on location
                string = "{wDetails on %s{n:\n" % location
                string += "\n".join(" {w%s{n: %s" % (key, utils.crop(text)) for key, text in location.db.details.items())
                caller.msg(string)
                return
            if self.switches and self.switches[0] in 'del':
                # removing a detail.
                if self.lhs in location.db.details:
                    del location.db.detail
                caller.msg("Detail %s deleted, if it existed." % self.lhs)
                self.reset_times(location)
                return
            # setting a detail
            location.db.details[self.lhs] = self.rhs
            caller.msg("Set Detail %s to '%s'." % (self.lhs, self.rhs))
            self.reset_times(location)
            return
        else:
            # we are doing a @desc call
            if not self.args:
                if location:
                    string = "{wDescriptions on %s{n:\n" % location.key
                    string += " {wspring:{n %s\n" % location.db.spring_desc
                    string += " {wsummer:{n %s\n" % location.db.summer_desc
                    string += " {wautumn:{n %s\n" % location.db.autumn_desc
                    string += " {wwinter:{n %s\n" % location.db.winter_desc
                    string += " {wgeneral:{n %s" % location.db.general_desc
                    caller.msg(string)
                    return
            if self.switches and self.switches[0] in ("spring",
                                                      "summer",
                                                      "autumn",
                                                      "winter"):
                # a seasonal switch was given
                if self.rhs:
                    caller.msg("Seasonal descs only works with rooms, not objects.")
                    return
                switch = self.switches[0]
                if not location:
                    caller.msg("No location was found!")
                    return
                if switch == 'spring':
                    location.db.spring_desc = self.args
                elif switch == 'summer':
                    location.db.summer_desc = self.args
                elif switch == 'autumn':
                    location.db.autumn_desc = self.args
                elif switch == 'winter':
                    location.db.winter_desc = self.args
                # clear flag to force an update
                self.reset_times(location)
                caller.msg("Seasonal description was set on %s." % location.key)
            else:
                # Not seasonal desc set, maybe this is not an extended room
                if self.rhs:
                    text = self.rhs
                    obj = caller.search(self.lhs)
                    if not obj:
                        return
                else:
                    text = self.args
                    obj = location
                obj.db.desc = self.rhs # a compatability fallback
                if utils.inherits_from(obj, ExtendedRoom):
                    # this is an extendedroom, we need to reset
                    # times and set general_desc
                    obj.db.general_desc = text
                    self.reset_times(obj)
                    caller.msg("General description was set on %s." % obj.key)
                else:
                    caller.msg("The description was set on %s." % obj.key)


# Simple command to view the current time and season

class CmdGameTime(default_cmds.MuxCommand):
    """
    Check the game time

    Usage:
      time

    Shows the current in-game time and season.
    """
    key = "time"
    locks = "cmd:all()"
    help_category = "General"

    def func(self):
        "Reads time info from current room"
        location = self.caller.location
        if not location or not hasattr(location, "get_time_and_season"):
            self.caller.msg("No location available - you are outside time.")
        else:
            season, timeslot = location.get_time_and_season()
            prep = "a"
            if season == "autumn":
                prep = "an"
            self.caller.msg("It's %s %s day, in the %s." % (prep, season, timeslot))

########NEW FILE########
__FILENAME__ = lineeditor
"""

Evennia Line Editor

Contribution - Griatch 2011

This implements an advanced line editor for editing longer texts
in-game. The editor mimics the command mechanisms of the VI editor as
far as possible.

Features of the editor:
 undo/redo
 edit/replace on any line of the buffer
 search&replace text anywhere in buffer
 formatting of buffer, or selection, to certain width + indentations
 allow to echo the input or not depending on your client.
"""

import re
from ev import Command, CmdSet, utils
from ev import syscmdkeys
from contrib.menusystem import prompt_yesno

CMD_NOMATCH = syscmdkeys.CMD_NOMATCH
CMD_NOINPUT = syscmdkeys.CMD_NOINPUT

RE_GROUP = re.compile(r"\".*?\"|\'.*?\'|\S*")


class CmdEditorBase(Command):
    """
    Base parent for editor commands
    """
    locks = "cmd:all()"
    help_entry = "LineEditor"

    code = None
    editor = None

    def parse(self):
        """
        Handles pre-parsing

        Editor commands are on the form
         :cmd [li] [w] [txt]

        Where all arguments are optional.
          li  - line number (int), starting from 1. This could also
                be a range given as <l>:<l>
          w   - word(s) (string), could be encased in quotes.
          txt - extra text (string), could be encased in quotes
        """

        linebuffer = []
        if self.editor:
            linebuffer = self.editor.buffer.split("\n")
        nlines = len(linebuffer)

        # The regular expression will split the line by whitespaces,
        # stripping extra whitespaces, except if the text is
        # surrounded by single- or double quotes, in which case they
        # will be kept together and extra whitespace preserved. You
        # can input quotes on the line by alternating single and
        # double quotes.
        arglist = [part for part in RE_GROUP.findall(self.args) if part]
        temp = []
        for arg in arglist:
            # we want to clean the quotes, but only one type,
            # in case we are nesting.
            if arg.startswith('"'):
                arg.strip('"')
            elif arg.startswith("'"):
                arg.strip("'")
            temp.append(arg)
        arglist = temp

        # A dumb split, without grouping quotes
        words = self.args.split()

        # current line number
        cline = nlines - 1

        # the first argument could also be a range of line numbers, on the
        # form <lstart>:<lend>. Either of the ends could be missing, to
        # mean start/end of buffer respectively.

        lstart, lend = cline, cline + 1
        linerange = False
        if arglist and ':' in arglist[0]:
            part1, part2 = arglist[0].split(':')
            if part1 and part1.isdigit():
                lstart = min(max(0, int(part1)) - 1, nlines)
                linerange = True
            if part2 and part2.isdigit():
                lend = min(lstart + 1, int(part2)) + 1
                linerange = True
        elif arglist and arglist[0].isdigit():
            lstart = min(max(0, int(arglist[0]) - 1), nlines)
            lend = lstart + 1
            linerange = True
        if linerange:
            arglist = arglist[1:]

        # nicer output formatting of the line range.
        lstr = ""
        if not linerange or lstart + 1 == lend:
            lstr = "line %i" % (lstart + 1)
        else:
            lstr = "lines %i-%i" % (lstart + 1, lend)

        # arg1 and arg2 is whatever arguments. Line numbers or -ranges are
        # never included here.
        args = " ".join(arglist)
        arg1, arg2 = "", ""
        if len(arglist) > 1:
            arg1, arg2 = arglist[0], " ".join(arglist[1:])
        else:
            arg1 = " ".join(arglist)

        # store for use in func()

        self.linebuffer = linebuffer
        self.nlines = nlines
        self.arglist = arglist
        self.cline = cline
        self.lstart = lstart
        self.lend = lend
        self.linerange = linerange
        self.lstr = lstr
        self.words = words
        self.args = args
        self.arg1 = arg1
        self.arg2 = arg2

    def func(self):
        "Implements the Editor commands"
        pass


class CmdLineInput(CmdEditorBase):
    """
    No command match - Inputs line of text into buffer.
    """
    key = CMD_NOMATCH
    aliases = [CMD_NOINPUT]

    def func(self):
        "Adds the line without any formatting changes."
        # add a line of text
        if not self.editor.buffer:
            buf = self.args
        else:
            buf = self.editor.buffer + "\n%s" % self.args
        self.editor.update_buffer(buf)
        if self.editor.echo_mode:
            # need to do it here or we will be off one line
            cline = len(self.editor.buffer.split('\n'))
            self.caller.msg("{b%02i|{n %s" % (cline, self.args))


class CmdEditorGroup(CmdEditorBase):
    """
    Commands for the editor
    """
    key = ":editor_command_group"
    aliases = [":","::", ":::", ":h", ":w", ":wq", ":q", ":q!", ":u", ":uu", ":UU",
               ":dd", ":dw", ":DD", ":y", ":x", ":p", ":i",
               ":r", ":I", ":A", ":s", ":S", ":f", ":fi", ":fd", ":echo"]
    arg_regex = r"\s.*?|$"

    def func(self):
        """
        This command handles all the in-editor :-style commands. Since
        each command is small and very limited, this makes for a more
        efficient presentation.
        """
        caller = self.caller
        editor = self.editor
        linebuffer = self.linebuffer
        lstart, lend = self.lstart, self.lend
        cmd = self.cmdstring
        echo_mode = self.editor.echo_mode
        string = ""

        if cmd == ":":
            # Echo buffer
            if self.linerange:
                buf = linebuffer[lstart:lend]
                string = editor.display_buffer(buf=buf, offset=lstart)
            else:
                string = editor.display_buffer()
        elif cmd == "::":
            # Echo buffer without the line numbers and syntax parsing
            if self.linerange:
                buf = linebuffer[lstart:lend]
                string = editor.display_buffer(buf=buf,
                                               offset=lstart,
                                               linenums=False)
            else:
                string = editor.display_buffer(linenums=False)
            self.caller.msg(string, raw=True)
            return
        elif cmd == ":::":
            # Insert single colon alone on a line
            editor.update_buffer(editor.buffer + "\n:")
            if echo_mode:
                string = "Single ':' added to buffer."
        elif cmd == ":h":
            # help entry
            string = editor.display_help()
        elif cmd == ":w":
            # save without quitting
            string = editor.save_buffer()
        elif cmd == ":wq":
            # save and quit
            string = editor.save_buffer()
            string += " " + editor.quit()
        elif cmd == ":q":
            # quit. If not saved, will ask
            if self.editor.unsaved:
                prompt_yesno(caller, "Save before quitting?",
                             yescode = "self.caller.ndb._lineeditor.save_buffer(quitting=True)\nself.caller.ndb._lineeditor.quit()",
                             nocode = "self.caller.msg(self.caller.ndb._lineeditor.quit())", default="Y")
            else:
                string = editor.quit()
        elif cmd == ":q!":
            # force quit, not checking saving
            string = editor.quit()
        elif cmd == ":u":
            # undo
            string = editor.update_undo(-1)
        elif cmd == ":uu":
            # redo
            string = editor.update_undo(1)
        elif cmd == ":UU":
            # reset buffer
            editor.update_buffer(editor.pristine_buffer)
            string = "Reverted all changes to the buffer back to original state."
        elif cmd == ":dd":
            # :dd <l> - delete line <l>
            buf = linebuffer[:lstart] + linebuffer[lend:]
            editor.update_buffer(buf)
            string = "Deleted %s." % (self.lstr)
        elif cmd == ":dw":
            # :dw <w> - delete word in entire buffer
            # :dw <l> <w> delete word only on line(s) <l>
            if not self.arg1:
                string = "You must give a search word to delete."
            else:
                if not self.linerange:
                    lstart = 0
                    lend = self.cline + 1
                    string = "Removed %s for lines %i-%i." % (self.arg1, lstart + 1, lend + 1)
                else:
                    string = "Removed %s for %s." % (self.arg1, self.lstr)
                sarea = "\n".join(linebuffer[lstart:lend])
                sarea = re.sub(r"%s" % self.arg1.strip("\'").strip('\"'), "", sarea, re.MULTILINE)
                buf = linebuffer[:lstart] + sarea.split("\n") + linebuffer[lend:]
                editor.update_buffer(buf)
        elif cmd == ":DD":
            # clear buffer
            editor.update_buffer("")
            string = "Cleared %i lines from buffer." % self.nlines
        elif cmd == ":y":
            # :y <l> - yank line(s) to copy buffer
            cbuf = linebuffer[lstart:lend]
            editor.copy_buffer = cbuf
            string = "%s, %s yanked." % (self.lstr.capitalize(), cbuf)
        elif cmd == ":x":
            # :x <l> - cut line to copy buffer
            cbuf = linebuffer[lstart:lend]
            editor.copy_buffer = cbuf
            buf = linebuffer[:lstart] + linebuffer[lend:]
            editor.update_buffer(buf)
            string = "%s, %s cut." % (self.lstr.capitalize(), cbuf)
        elif cmd == ":p":
            # :p <l> paste line(s) from copy buffer
            if not editor.copy_buffer:
                string = "Copy buffer is empty."
            else:
                buf = linebuffer[:lstart] + editor.copy_buffer + linebuffer[lstart:]
                editor.update_buffer(buf)
                string = "Copied buffer %s to %s." % (editor.copy_buffer, self.lstr)
        elif cmd == ":i":
            # :i <l> <txt> - insert new line
            new_lines = self.args.split('\n')
            if not new_lines:
                string = "You need to enter a new line and where to insert it."
            else:
                buf = linebuffer[:lstart] + new_lines + linebuffer[lstart:]
                editor.update_buffer(buf)
                string = "Inserted %i new line(s) at %s." % (len(new_lines), self.lstr)
        elif cmd == ":r":
            # :r <l> <txt> - replace lines
            new_lines = self.args.split('\n')
            if not new_lines:
                string = "You need to enter a replacement string."
            else:
                buf = linebuffer[:lstart] + new_lines + linebuffer[lend:]
                editor.update_buffer(buf)
                string = "Replaced %i line(s) at %s." % (len(new_lines), self.lstr)
        elif cmd == ":I":
            # :I <l> <txt> - insert text at beginning of line(s) <l>
            if not self.args:
                string = "You need to enter text to insert."
            else:
                buf = linebuffer[:lstart] + ["%s%s" % (self.args, line) for line in linebuffer[lstart:lend]] + linebuffer[lend:]
                editor.update_buffer(buf)
                string = "Inserted text at beginning of %s." % self.lstr
        elif cmd == ":A":
            # :A <l> <txt> - append text after end of line(s)
            if not self.args:
                string = "You need to enter text to append."
            else:
                buf = linebuffer[:lstart] + ["%s%s" % (line, self.args) for line in linebuffer[lstart:lend]] + linebuffer[lend:]
                editor.update_buffer(buf)
                string = "Appended text to end of %s." % self.lstr
        elif cmd == ":s":
            # :s <li> <w> <txt> - search and replace words
            # in entire buffer or on certain lines
            if not self.arg1 or not self.arg2:
                string = "You must give a search word and something to replace it with."
            else:
                if not self.linerange:
                    lstart = 0
                    lend = self.cline + 1
                    string = "Search-replaced %s -> %s for lines %i-%i." % (self.arg1, self.arg2, lstart + 1 , lend)
                else:
                    string = "Search-replaced %s -> %s for %s." % (self.arg1, self.arg2, self.lstr)
                sarea = "\n".join(linebuffer[lstart:lend])

                regex = r"%s|^%s(?=\s)|(?<=\s)%s(?=\s)|^%s$|(?<=\s)%s$"
                regarg = self.arg1.strip("\'").strip('\"')
                if " " in regarg:
                    regarg = regarg.replace(" ", " +")
                sarea = re.sub(regex % (regarg, regarg, regarg, regarg, regarg), self.arg2.strip("\'").strip('\"'), sarea, re.MULTILINE)
                buf = linebuffer[:lstart] + sarea.split("\n") + linebuffer[lend:]
                editor.update_buffer(buf)
        elif cmd == ":f":
            # :f <l> flood-fill buffer or <l> lines of buffer.
            width = 78
            if not self.linerange:
                lstart = 0
                lend = self.cline + 1
                string = "Flood filled lines %i-%i." % (lstart + 1 , lend)
            else:
                string = "Flood filled %s." % self.lstr
            fbuf = "\n".join(linebuffer[lstart:lend])
            fbuf = utils.fill(fbuf, width=width)
            buf = linebuffer[:lstart] + fbuf.split("\n") + linebuffer[lend:]
            editor.update_buffer(buf)
        elif cmd == ":fi":
            # :fi <l> indent buffer or lines <l> of buffer.
            indent = " " * 4
            if not self.linerange:
                lstart = 0
                lend = self.cline + 1
                string = "Indented lines %i-%i." % (lstart + 1 , lend)
            else:
                string = "Indented %s." % self.lstr
            fbuf = [indent + line for line in linebuffer[lstart:lend]]
            buf = linebuffer[:lstart] + fbuf + linebuffer[lend:]
            editor.update_buffer(buf)
        elif cmd == ":fd":
            # :fi <l> indent buffer or lines <l> of buffer.
            if not self.linerange:
                lstart = 0
                lend = self.cline + 1
                string = "Removed left margin (dedented) lines %i-%i." % (lstart + 1 , lend)
            else:
                string = "Removed left margin (dedented) %s." % self.lstr
            fbuf = "\n".join(linebuffer[lstart:lend])
            fbuf = utils.dedent(fbuf)
            buf = linebuffer[:lstart] + fbuf.split("\n") + linebuffer[lend:]
            editor.update_buffer(buf)
        elif cmd == ":echo":
            # set echoing on/off
            editor.echo_mode = not editor.echo_mode
            string = "Echo mode set to %s" % editor.echo_mode
        caller.msg(string)


class EditorCmdSet(CmdSet):
    "CmdSet for the editor commands"
    key = "editorcmdset"
    mergetype = "Replace"


class LineEditor(object):
    """
    This defines a line editor object. It creates all relevant commands
    and tracks the current state of the buffer. It also cleans up after
    itself.
    """

    def __init__(self, caller,
                 loadfunc=None, loadfunc_args=None,
                 savefunc=None, savefunc_args=None,
                 quitfunc=None, quitfunc_args=None,
                 key=""):
        """
        caller - who is using the editor

        loadfunc - this will be called as func(*loadfunc_args) when the
                   editor is first started, e.g. for pre-loading text into it.
        loadfunc_args - optional tuple of arguments to supply to loadfunc.
        savefunc - this will be called as func(*savefunc_args) when the
                   save-command is given and is used to actually determine
                   where/how result is saved. It should return True if save
                   was successful and also handle any feedback to the user.
        savefunc_args - optional tuple of arguments to supply to savefunc.
        quitfunc - this will optionally e called as func(*quitfunc_args) when
                   the editor is exited. If defined, it should handle all
                   wanted feedback to the user.
        quitfunc_args - optional tuple of arguments to supply to quitfunc.

        key = an optional key for naming this session (such as which attribute
              is being edited)
        """
        self.key = key
        self.caller = caller
        self.caller.ndb._lineeditor = self
        self.buffer = ""
        self.unsaved = False

        if loadfunc:
            # execute command for loading initial data
            try:
                args = loadfunc_args or ()
                self.buffer = loadfunc(*args)
            except Exception, e:
                caller.msg("%s\n{rBuffer load function error. Could not load initial data.{n" % e)
        if not savefunc:
            # If no save function is defined, save an error-reporting function
            err = "{rNo save function defined. Buffer cannot be saved.{n"
            caller.msg(err)
            savefunc = lambda: self.caller.msg(err)
        self.savefunc = savefunc
        self.savefunc_args = savefunc_args or ()
        self.quitfunc = quitfunc
        self.quitfunc_args = quitfunc_args or ()

        # Create the commands we need
        cmd1 = CmdLineInput()
        cmd1.editor = self
        cmd1.obj = self
        cmd2 = CmdEditorGroup()
        cmd2.obj = self
        cmd2.editor = self
        # Populate cmdset and add it to caller
        editor_cmdset = EditorCmdSet()
        editor_cmdset.add(cmd1)
        editor_cmdset.add(cmd2)
        self.caller.cmdset.add(editor_cmdset)

        # store the original version
        self.pristine_buffer = self.buffer
        self.sep = "-"

        # undo operation buffer
        self.undo_buffer = [self.buffer]
        self.undo_pos = 0
        self.undo_max = 20

        # copy buffer
        self.copy_buffer = []

        # echo inserted text back to caller
        self.echo_mode = False

        # show the buffer ui
        self.caller.msg(self.display_buffer())

    def update_buffer(self, buf):
        """
        This should be called when the buffer has been changed somehow.
        It will handle unsaved flag and undo updating.
        """
        if utils.is_iter(buf):
            buf = "\n".join(buf)

        if buf != self.buffer:
            self.buffer = buf
            self.update_undo()
            self.unsaved = True

    def quit(self):
        "Cleanly exit the editor."
        if self.quitfunc:
            # call quit function hook if available
            try:
                self.quitfunc(*self.quitfunc_args)
            except Exception, e:
                self.caller.msg("%s\n{Quit function gave an error. Skipping.{n" % e)
        del self.caller.ndb._lineeditor
        self.caller.cmdset.delete(EditorCmdSet)
        if self.quitfunc:
            # if quitfunc is defined, it should manage exit messages.
            return ""
        return "Exited editor."

    def save_buffer(self):
        """
            Saves the content of the buffer. The 'quitting' argument is a bool
        indicating whether or not the editor intends to exit after saving.
        """
        if self.unsaved:
            try:
                if self.savefunc(*self.savefunc_args):
                    # Save codes should return a true value to indicate
                    # save worked. The saving function is responsible for
                    # any status messages.
                    self.unsaved = False
                return ""
            except Exception, e:
                return "%s\n{rSave function gave an error. Buffer not saved." % e
        else:
            return "No changes need saving."

    def update_undo(self, step=None):
        """
        This updates the undo position.

        """
        if step and step < 0:
            if self.undo_pos <= 0:
                return "Nothing to undo."
            self.undo_pos = max(0, self.undo_pos + step)
            self.buffer = self.undo_buffer[self.undo_pos]
            return "Undo."
        elif step and step > 0:
            if self.undo_pos >= len(self.undo_buffer) - 1 or self.undo_pos + 1 >= self.undo_max:
                return "Nothing to redo."
            self.undo_pos = min(self.undo_pos + step, min(len(self.undo_buffer), self.undo_max) - 1)
            self.buffer = self.undo_buffer[self.undo_pos]
            return "Redo."
        if not self.undo_buffer or (self.undo_buffer and self.buffer != self.undo_buffer[self.undo_pos]):
            self.undo_buffer = self.undo_buffer[:self.undo_pos + 1] + [self.buffer]
            self.undo_pos = len(self.undo_buffer) - 1

    def display_buffer(self, buf=None, offset=0, linenums=True):
        """
        This displays the line editor buffer, or selected parts of it.

        If buf is set and is not the full buffer, offset should define
        the starting line number, to get the linenum display right.
        """
        if buf == None:
            buf = self.buffer
        if utils.is_iter(buf):
            buf = "\n".join(buf)

        lines = buf.split('\n')
        nlines = len(lines)
        nwords = len(buf.split())
        nchars = len(buf)

        sep = self.sep
        header = "{n" + sep * 10 + "Line Editor [%s]" % self.key + sep * (78-25-len(self.key))
        footer = "{n" + sep * 10 + "[l:%02i w:%03i c:%04i]" % (nlines, nwords, nchars) + sep * 12 + "(:h for help)" + sep * 23
        if linenums:
            main = "\n".join("{b%02i|{n %s" % (iline + 1 + offset, line) for iline, line in enumerate(lines))
        else:
            main = "\n".join(lines)
        string = "%s\n%s\n%s" % (header, main, footer)
        return string

    def display_help(self):
        """
        Shows the help entry for the editor.
        """
        string = self.sep * 78 + """
<txt>  - any non-command is appended to the end of the buffer.
:  <l> - view buffer or only line <l>
:: <l> - view buffer without line numbers or other parsing
:::    - print a ':' as the only character on the line...
:h     - this help.

:w     - saves the buffer (don't quit)
:wq    - save buffer and quit
:q     - quits (will be asked to save if buffer was changed)
:q!    - quit without saving, no questions asked

:u     - (undo) step backwards in undo history
:uu    - (redo) step forward in undo history
:UU    - reset all changes back to initial

:dd <l>     - delete line <n>
:dw <l> <w> - delete word or regex <w> in entire buffer or on line <l>
:DD         - clear buffer

:y  <l>        - yank (copy) line <l> to the copy buffer
:x  <l>        - cut line <l> and store it in the copy buffer
:p  <l>        - put (paste) previously copied line directly after <l>
:i  <l> <txt>  - insert new text <txt> at line <l>. Old line will move down
:r  <l> <txt>  - replace line <l> with text <txt>
:I  <l> <txt>  - insert text at the beginning of line <l>
:A  <l> <txt>  - append text after the end of line <l>

:s <l> <w> <txt> - search/replace word or regex <w> in buffer or on line <l>

:f <l>    - flood-fill entire buffer or line <l>
:fi <l>   - indent entire buffer or line <l>
:fd <l>   - de-indent entire buffer or line <l>

:echo - turn echoing of the input on/off (helpful for some clients)

   Legend:
   <l> - line numbers, or range lstart:lend, e.g. '3:7'.
   <w> - one word or several enclosed in quotes.
   <txt> - longer string, usually not needed to be enclosed in quotes.
""" + self.sep * 78
        return string


#
# Editor access command for editing a given attribute on an object.
#

class CmdEditor(Command):
    """
    start editor

    Usage:
      @editor <obj>/<attr>

    This will start Evennia's powerful line editor, which
    has a host of commands on its own. Use :h for a list
    of commands.

    """

    key = "@editor"
    aliases = ["@edit"]
    locks = "cmd:perm(editor) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "setup and start the editor"

        if not self.args or not '/' in self.args:
            self.caller.msg("Usage: @editor <obj>/<attrname>")
            return
        self.objname, self.attrname = [part.strip()
                                            for part in self.args.split("/", 1)]
        self.obj = self.caller.search(self.objname)
        if not self.obj:
            return

        # hook save/load functions
        def load_attr():
            "inital loading of buffer data from given attribute."
            target = self.obj.attributes.get(self.attrname)
            if target is not None and not isinstance(target, basestring):
                typ = type(target).__name__
                self.caller.msg("{RWARNING! Saving this buffer will overwrite the current attribute (of type %s) with a string!{n" % typ)
            return target and str(target) or ""

        def save_attr():
            """
            Save line buffer to given attribute name. This should
            return True if successful and also report its status.
            """
            self.obj.attributes.add(self.attrname, self.editor.buffer)
            self.caller.msg("Saved.")
            return True

        def quit_hook():
            "Example quit hook. Since it's given, it's responsible for giving feedback messages."
            self.caller.msg("Exited Editor.")

        editor_key = "%s/%s" % (self.objname, self.attrname)
        # start editor, it will handle things from here.
        self.editor = LineEditor(self.caller,
                                 loadfunc=load_attr,
                                 savefunc=save_attr,
                                 quitfunc=quit_hook,
                                 key=editor_key)
########NEW FILE########
__FILENAME__ = menusystem
"""
Evennia menu system.

Contribution - Griatch 2011

This module offers the ability for admins to let their game be fully
or partly menu-driven. Menu choices can be numbered or use arbitrary
keys. There are also some formatting options, such a putting options
in one or more collumns.

The menu system consists of a MenuTree object populated by MenuNode
objects. Nodes are linked together with automatically created commands
so the player may select and traverse the menu. Each node can display
text and show options, but also execute arbitrary code to act on the
system and the calling object when they are selected.

There is also a simple Yes/No function supplied. This will create a
one-off Yes/No question and executes a given code depending on which
choice was made.

To test, make sure to follow the instructions in
game/gamesrc/commands/examples/cmdset.py (copy the template up one level
and change settings to point to the relevant cmdsets within). If you
already have such a module, you can of course use that. Next you
import and add the CmdTestMenu command to the end of the default cmdset in
this custom module.
The test command is also a good example of how to use this module in code.

"""
from ev import syscmdkeys

from ev import Command, CmdSet, utils
from ev import default_cmds

# imported only to make it available during execution of code blocks
import ev

CMD_NOMATCH = syscmdkeys.CMD_NOMATCH
CMD_NOINPUT = syscmdkeys.CMD_NOINPUT


#
# Commands used by the Menu system
#

class CmdMenuNode(Command):
    """
    Parent for menu selection commands.
    """
    key = "selection"
    aliases = []
    locks = "cmd:all()"
    help_category = "Menu"

    menutree = None
    code = None

    def func(self):
        "Execute a selection"
        if self.code:
            try:
                exec(self.code)
            except Exception, e:
                self.caller.msg("%s\n{rThere was an error with this selection.{n" % e)
        else:
            self.caller.msg("{rThis option is not available.{n")


class CmdMenuLook(default_cmds.CmdLook):
    """
    ooc look

    Usage:
      look

    This is a Menu version of the look command. It will normally show
    the options available, otherwise works like the normal look
    command..
    """
    key = "look"
    aliases = ["l", "ls"]
    locks = "cmd:all()"
    help_cateogory = "General"

    def func(self):
        "implement the menu look command"
        if self.caller.db._menu_data:
            # if we have menu data, try to use that.
            lookstring = self.caller.db._menu_data.get("look", None)
            if lookstring:
                self.caller.msg(lookstring)
                return
        # otherwise we use normal look
        super(CmdMenuLook, self).func()


class CmdMenuHelp(default_cmds.CmdHelp):
    """
    help

    Usage:
      help

    Get help specific to the menu, if available. If not,
    works like the normal help command.
    """
    key = "help"
    aliases = "h"
    locks = "cmd:all()"
    help_category = "Menu"

    def func(self):
        "implement the menu help command"
        if self.caller.db._menu_data:
            # if we have menu data, try to use that.
            lookstring = self.caller.db._menu_data.get("help", None)
            if lookstring:
                self.caller.msg(lookstring)
                return
        # otherwise we use normal help
        super(CmdMenuHelp, self).func()


class MenuCmdSet(CmdSet):
    """
    Cmdset for the menu. Will replace all other commands.
    This always has a few basic commands available.

    Note that you must always supply a way to exit the
    cmdset manually!
    """
    key = "menucmdset"
    priority = 1
    mergetype = "Replace"

    def at_cmdset_creation(self):
        "populate cmdset"
        pass


#
# Menu Node system
#

class MenuTree(object):
    """
    The menu tree object holds the full menu structure consisting of
    MenuNodes. Each node is identified by a unique key.  The tree
    allows for traversal of nodes as well as entering and exiting the
    tree as needed. For safety, being in a menu will not survive a
    server reboot.

    A menutree have two special node keys given by 'startnode' and
    'endnode' arguments. The startnode is where the user will start
    upon first entering the menu.  The endnode need not actually
    exist, the moment it is linked to and that link is used, the menu
    will be exited and cleanups run. The default keys for these are
    'START' and 'END' respectively.

    """
    def __init__(self, caller, nodes=None,
                 startnode="START", endnode="END", exec_end="look"):
        """
        We specify startnode/endnode so that the system knows where to
        enter and where to exit the menu tree. If nodes is given, it
        shuld be a list of valid node objects to add to the tree.

        exec_end - if not None, will execute the given command string
                   directly after the menu system has been exited.
        """
        self.tree = {}
        self.startnode = startnode
        self.endnode = endnode
        self.exec_end = exec_end
        self.caller = caller
        if nodes and utils.is_iter(nodes):
            for node in nodes:
                self.add(node)

    def start(self):
        """
        Initialize the menu
        """
        self.goto(self.startnode)

    def add(self, menunode):
        """
        Add a menu node object to the tree. Each node itself keeps
        track of which nodes it is connected to.
        """
        menunode.init(self)
        self.tree[menunode.key] = menunode

    def goto(self, key):
        """
        Go to a key in the tree. This sets up the cmdsets on the
        caller so that they match the choices in that node.
        """
        if key == self.endnode:
            # if we was given the END node key, we clean up immediately.
            self.caller.cmdset.delete("menucmdset")
            del self.caller.db._menu_data
            if self.exec_end is not None:
                self.caller.execute_cmd(self.exec_end)
            return
        # not exiting, look for a valid code.
        node = self.tree.get(key, None)
        if node:
            if node.code:
                # Execute eventual code active on this
                # node. self.caller is available at this point.
                try:
                    exec(node.code)
                except Exception:
                    self.caller.msg("{rCode could not be executed for node %s. Continuing anyway.{n" % key)
            # clean old menu cmdset and replace with the new one
            self.caller.cmdset.delete("menucmdset")
            self.caller.cmdset.add(node.cmdset)
            # set the menu flag data for the default commands
            self.caller.db._menu_data = {"help": node.helptext,
                                         "look": str(node.text)}
            # display the node
            self.caller.msg(node.text)
        else:
            self.caller.msg("{rMenu node '%s' does not exist - maybe it's not created yet..{n" % key)


class MenuNode(object):
    """
    This represents a node in a menu tree. The node will display its
    textual content and offer menu links to other nodes (the relevant
    commands are created automatically)

    """
    def __init__(self, key, text="", links=None, linktexts=None,
                 keywords=None, cols=1, helptext=None,
                 selectcmds=None, code="", nodefaultcmds=False, separator=""):
        """
        key       - the unique identifier of this node.
        text      - is the text that will be displayed at top when viewing this
                    node.
        links     - a list of keys for unique menunodes this is connected to.
                    The actual keys will not printed - keywords will be used
                    (or a number)
        linktexts - an optional list of texts to describe the links. Must
                    match link list if defined. Entries can be None to not
                    generate any extra text for a particular link.
        keywords  - an optional list of unique keys for choosing links. Must
                    match links list. If not given, index numbers will be used.
                    Also individual list entries can be None and will be replaed
                    by indices. If CMD_NOMATCH or CMD_NOENTRY, no text will be
                    generated to indicate the option exists.
        cols      - how many columns to use for displaying options.
        helptext  - if defined, this is shown when using the help command
                    instead of the normal help index.
        selectcmds- a list of custom cmdclasses for handling each option.
                    Must match links list, but some entries may be set to None
                    to use default menu cmds. The given command's key will be
                    used for the menu list entry unless it's CMD_NOMATCH or
                    CMD_NOENTRY, in which case no text will be generated. These
                    commands have access to self.menutree and so can be used to
                    select nodes.
        code      - functional code. This will be executed just before this
                    node is loaded (i.e. as soon after it's been selected from
                    another node). self.caller is available to call from this
                    code block, as well as ev.
        nodefaultcmds - if true, don't offer the default help and look commands
                    in the node
        separator - this string will be put on the line between menu nodes5B.
        """
        self.key = key
        self.cmdset = None
        self.links = links
        self.linktexts = linktexts
        self.keywords = keywords
        self.cols = cols
        self.selectcmds = selectcmds
        self.code = code
        self.nodefaultcmds = nodefaultcmds
        self.separator = separator
        Nlinks = len(self.links)

        # validate the input
        if not self.links:
            self.links = []
        if not self.linktexts or (len(self.linktexts) != Nlinks):
            self.linktexts = [None for i in range(Nlinks)]
        if not self.keywords or (len(self.keywords) != Nlinks):
            self.keywords = [None for i in range(Nlinks)]
        if not selectcmds or (len(self.selectcmds) != Nlinks):
            self.selectcmds = [None for i in range(Nlinks)]

        # Format default text for the menu-help command
        if not helptext:
            helptext = "Select one of the valid options ("
            for i in range(Nlinks):
                if self.keywords[i]:
                    if self.keywords[i] not in (CMD_NOMATCH, CMD_NOINPUT):
                        helptext += "%s, " % self.keywords[i]
                else:
                    helptext += "%s, " % (i + 1)
            helptext = helptext.rstrip(", ") + ")"
        self.helptext = helptext

        # Format text display
        string = ""
        if text:
            string += "%s\n" % text

        # format the choices into as many collumns as specified
        choices = []
        for ilink, link in enumerate(self.links):
            choice = ""
            if self.keywords[ilink]:
                if self.keywords[ilink] not in (CMD_NOMATCH, CMD_NOINPUT):
                    choice += "{g%s{n" % self.keywords[ilink]
            else:
                choice += "{g %i{n" % (ilink + 1)
            if self.linktexts[ilink]:
                choice += " - %s" % self.linktexts[ilink]
            choices.append(choice)
        cols = [[] for i in range(min(len(choices), cols))]
        while True:
            for i in range(len(cols)):
                if not choices:
                    cols[i].append("")
                else:
                    cols[i].append(choices.pop(0))
            if not choices:
                break
        ftable = utils.format_table(cols)
        for row in ftable:
            string += "\n" + "".join(row)
        # store text
        self.text = self.separator + "\n" + string.rstrip()

    def init(self, menutree):
        """
        Called by menu tree. Initializes the commands needed by
        the menutree structure.
        """
        # Create the relevant cmdset
        self.cmdset = MenuCmdSet()
        if not self.nodefaultcmds:
            # add default menu commands
            self.cmdset.add(CmdMenuLook())
            self.cmdset.add(CmdMenuHelp())

        for i, link in enumerate(self.links):
            if self.selectcmds[i]:
                cmd = self.selectcmds[i]()
            else:
                cmd = CmdMenuNode()
                cmd.key = str(i + 1)
                # this is the operable command, it moves us to the next node.
                cmd.code = "self.menutree.goto('%s')" % link
            # also custom commands get access to the menutree.
            cmd.menutree = menutree
            if self.keywords[i] and cmd.key not in (CMD_NOMATCH, CMD_NOINPUT):
                cmd.aliases = [self.keywords[i]]
            self.cmdset.add(cmd)

    def __str__(self):
        "Returns the string representation."
        return self.text


#
# A simple yes/no question. Call this from a command to give object
# a cmdset where they may say yes or no to a question. Does not
# make use the node system since there is only one level of choice.
#

def prompt_yesno(caller, question="", yescode="", nocode="", default="N"):
    """
    This sets up a simple yes/no questionnaire. Question will
    be asked, followed by a Y/[N] prompt where the [x] signifies
    the default selection.
    """

    # creating and defining commands
    cmdyes = CmdMenuNode()
    cmdyes.key = "yes"
    cmdyes.aliases = ["y"]
    # this will be executed in the context of the yes command (so
    # self.caller will be available)
    cmdyes.code = yescode + "\nself.caller.cmdset.delete('menucmdset')\ndel self.caller.db._menu_data"

    cmdno = CmdMenuNode()
    cmdno.key = "no"
    cmdno.aliases = ["n"]
    # this will be executed in the context of the no command
    cmdno.code = nocode + "\nself.caller.cmdset.delete('menucmdset')\ndel self.caller.db._menu_data"

    errorcmd = CmdMenuNode()
    errorcmd.key = CMD_NOMATCH
    errorcmd.code = "self.caller.msg('Please choose either Yes or No.')"

    defaultcmd = CmdMenuNode()
    defaultcmd.key = CMD_NOINPUT
    defaultcmd.code = "self.caller.execute_cmd('%s')" % default

    # creating cmdset (this will already have look/help commands)
    yesnocmdset = MenuCmdSet()
    yesnocmdset.add(cmdyes)
    yesnocmdset.add(cmdno)
    yesnocmdset.add(errorcmd)
    yesnocmdset.add(defaultcmd)

    # assinging menu data flags to caller.
    caller.db._menu_data = {"help": "Please select Yes or No.",
                            "look": "Please select Yes or No."}
    # assign cmdset and ask question
    caller.cmdset.add(yesnocmdset)
    if default == "Y":
        prompt = "[Y]/N"
    else:
        prompt = "Y/[N]"
    prompt = "%s %s: " % (question, prompt)
    caller.msg(prompt)


#
# Menu command test
#

class CmdMenuTest(Command):
    """
    testing menu module

    Usage:
      menu
      menu yesno

    This will test the menu system. The normal operation will produce
    a small menu tree you can move around in. The 'yesno' option will
    instead show a one-time yes/no question.

    """

    key = "menu"
    locks = "cmd:all()"
    help_category = "Menu"

    def func(self):
        "Testing the menu system"

        if not self.args or self.args != "yesno":
            # testing the full menu-tree system

            node0 = MenuNode("START", text="Start node. Select one of the links below. Here the links are ordered in one column.",
                             links=["node1", "node2", "END"], linktexts=["Goto first node", "Goto second node", "Quit"])
            node1 = MenuNode("node1", text="First node. This node shows letters instead of numbers for the choices.",
                             links=["END", "START"], linktexts=["Quit", "Back to start"], keywords=["q","b"])
            node2 = MenuNode("node2", text="Second node. This node lists choices in two columns.",
                             links=["node3", "START"], linktexts=["Set an attribute", "Back to start"], cols=2)
            node3 = MenuNode("node3", text="Attribute 'menutest' set on you. You can examine it (only works if you are allowed to use the examine command) or remove it. You can also quit and examine it manually.",
                             links=["node4", "node5", "node2", "END"], linktexts=["Remove attribute", "Examine attribute",
                                                                                  "Back to second node", "Quit menu"], cols=2,
                             code="self.caller.db.menutest='Testing!'")
            node4 = MenuNode("node4", text="Attribute 'menutest' removed again.",
                             links=["node2"], linktexts=["Back to second node."], cols=2,
                             code="del self.caller.db.menutest")
            node5 = MenuNode("node5", links=["node4", "node2"], linktexts=["Remove attribute", "Back to second node."], cols=2,
                             code="self.caller.msg('%s/%s = %s' % (self.caller.key, 'menutest', self.caller.db.menutest))")

            menu = MenuTree(self.caller, nodes=(node0, node1, node2, node3, node4, node5))
            menu.start()
        else:
            "Testing the yesno question"
            prompt_yesno(self.caller, question="Please answer yes or no - Are you the master of this mud or not?",
                         yescode="self.caller.msg('{gGood for you!{n')",
                         nocode="self.caller.msg('{GNow you are just being modest ...{n')",
                         default="N")

########NEW FILE########
__FILENAME__ = menu_login
"""
Menu-driven login system

Contribution - Griatch 2011


This is an alternative login system for Evennia, using the
contrib.menusystem module. As opposed to the default system it doesn't
use emails for authentication and also don't auto-creates a Character
with the same name as the Player (instead assuming some sort of
character-creation to come next).


Install is simple:

To your settings file, add/edit the line:

CMDSET_UNLOGGEDIN = "contrib.menu_login.UnloggedInCmdSet"

That's it. Reload the server and try to log in to see it.

The initial login "graphic" is taken from strings in the module given
by settings.CONNECTION_SCREEN_MODULE. You will want to copy the
template file in game/gamesrc/conf/examples up one level and re-point
the settings file to this custom module. you can then edit the string
in that module (at least comment out the default string that mentions
commands that are not available) and add something more suitable for
the initial splash screen.

"""

import re
import traceback
from django.conf import settings
from ev import managers
from ev import utils, logger, create_player
from ev import Command, CmdSet
from ev import syscmdkeys
from src.server.models import ServerConfig

from contrib.menusystem import MenuNode, MenuTree

CMD_LOGINSTART = syscmdkeys.CMD_LOGINSTART
CMD_NOINPUT = syscmdkeys.CMD_NOINPUT
CMD_NOMATCH = syscmdkeys.CMD_NOMATCH

CONNECTION_SCREEN_MODULE = settings.CONNECTION_SCREEN_MODULE


# Commands run on the unloggedin screen. Note that this is not using
# settings.UNLOGGEDIN_CMDSET but the menu system, which is why some are
# named for the numbers in the menu.
#
# Also note that the menu system will automatically assign all
# commands used in its structure a property "menutree" holding a reference
# back to the menutree. This allows the commands to do direct manipulation
# for example by triggering a conditional jump to another node.
#

# Menu entry 1a - Entering a Username

class CmdBackToStart(Command):
    """
    Step back to node0
    """
    key = CMD_NOINPUT
    locks = "cmd:all()"

    def func(self):
        "Execute the command"
        self.menutree.goto("START")


class CmdUsernameSelect(Command):
    """
    Handles the entering of a username and
    checks if it exists.
    """
    key = CMD_NOMATCH
    locks = "cmd:all()"

    def func(self):
        "Execute the command"
        player = managers.players.get_player_from_name(self.args)
        if not player:
            self.caller.msg("{rThis account name couldn't be found. Did you create it? If you did, make sure you spelled it right (case doesn't matter).{n")
            self.menutree.goto("node1a")
        else:
            # store the player so next step can find it
            self.menutree.player = player
            self.menutree.goto("node1b")


# Menu entry 1b - Entering a Password

class CmdPasswordSelectBack(Command):
    """
    Steps back from the Password selection
    """
    key = CMD_NOINPUT
    locks = "cmd:all()"

    def func(self):
        "Execute the command"
        self.menutree.goto("node1a")


class CmdPasswordSelect(Command):
    """
    Handles the entering of a password and logs into the game.
    """
    key = CMD_NOMATCH
    locks = "cmd:all()"

    def func(self):
        "Execute the command"
        if not hasattr(self.menutree, "player"):
            self.caller.msg("{rSomething went wrong! The player was not remembered from last step!{n")
            self.menutree.goto("node1a")
            return
        player = self.menutree.player
        if not player.check_password(self.args):
            self.caller.msg("{rIncorrect password.{n")
            self.menutree.goto("node1b")
            return

        # before going on, check eventual bans
        bans = ServerConfig.objects.conf("server_bans")
        if bans and (any(tup[0]==player.name.lower() for tup in bans)
                     or
                     any(tup[2].match(self.caller.address) for tup in bans if tup[2])):
            # this is a banned IP or name!
            string = "{rYou have been banned and cannot continue from here."
            string += "\nIf you feel this ban is in error, please email an admin.{x"
            self.caller.msg(string)
            self.caller.sessionhandler.disconnect(self.caller, "Good bye! Disconnecting...")
            return

        # we are ok, log us in.
        self.caller.msg("{gWelcome %s! Logging in ...{n" % player.key)
        #self.caller.session_login(player)
        self.caller.sessionhandler.login(self.caller, player)

        # abort menu, do cleanup.
        self.menutree.goto("END")

        # we are logged in. Look around.
        character = player.character
        if character:
            character.execute_cmd("look")
        else:
            # we have no character yet; use player's look, if it exists
            player.execute_cmd("look")


# Menu entry 2a - Creating a Username

class CmdUsernameCreate(Command):
    """
    Handle the creation of a valid username
    """
    key = CMD_NOMATCH
    locks = "cmd:all()"

    def func(self):
        "Execute the command"
        playername = self.args

        # sanity check on the name
        if not re.findall('^[\w. @+-]+$', playername) or not (3 <= len(playername) <= 30):
            self.caller.msg("\n\r {rAccount name should be between 3 and 30 characters. Letters, spaces, dig\
its and @/./+/-/_ only.{n") # this echoes the restrictions made by django's auth module.
            self.menutree.goto("node2a")
            return
        if managers.players.get_player_from_name(playername):
            self.caller.msg("\n\r {rAccount name %s already exists.{n" % playername)
            self.menutree.goto("node2a")
            return
        # store the name for the next step
        self.menutree.playername = playername
        self.menutree.goto("node2b")


# Menu entry 2b - Creating a Password

class CmdPasswordCreateBack(Command):
    "Step back from the password creation"
    key = CMD_NOINPUT
    locks = "cmd:all()"

    def func(self):
        "Execute the command"
        self.menutree.goto("node2a")


class CmdPasswordCreate(Command):
    "Handle the creation of a password. This also creates the actual Player/User object."
    key = CMD_NOMATCH
    locks = "cmd:all()"

    def func(self):
        "Execute  the command"
        password = self.args
        if not hasattr(self.menutree, 'playername'):
            self.caller.msg("{rSomething went wrong! Playername not remembered from previous step!{n")
            self.menutree.goto("node2a")
            return
        playername = self.menutree.playername
        if len(password) < 3:
            # too short password
            string = "{rYour password must be at least 3 characters or longer."
            string += "\n\rFor best security, make it at least 8 characters "
            string += "long, avoid making it a real word and mix numbers "
            string += "into it.{n"
            self.caller.msg(string)
            self.menutree.goto("node2b")
            return
        # everything's ok. Create the new player account. Don't create
        # a Character here.
        try:
            permissions = settings.PERMISSION_PLAYER_DEFAULT
            typeclass = settings.BASE_PLAYER_TYPECLASS
            new_player = create_player(playername, None, password,
                                       typeclass=typeclass,
                                       permissions=permissions)
            if not new_player:
                self.msg("There was an error creating the Player. This error was logged. Contact an admin.")
                self.menutree.goto("START")
                return
            utils.init_new_player(new_player)

            # join the new player to the public channel
            pchanneldef = settings.CHANNEL_PUBLIC
            if pchanneldef:
                pchannel = managers.channels.get_channel(pchanneldef[0])
                if not pchannel.connect(new_player):
                    string = "New player '%s' could not connect to public channel!" % new_player.key
                    logger.log_errmsg(string)

            # tell the caller everything went well.
            string = "{gA new account '%s' was created. Now go log in from the menu!{n"
            self.caller.msg(string % (playername))
            self.menutree.goto("START")
        except Exception:
            # We are in the middle between logged in and -not, so we have
            # to handle tracebacks ourselves at this point. If we don't, we
            # won't see any errors at all.
            string = "%s\nThis is a bug. Please e-mail an admin if the problem persists."
            self.caller.msg(string % (traceback.format_exc()))
            logger.log_errmsg(traceback.format_exc())


# Menu entry 3 - help screen

LOGIN_SCREEN_HELP = \
    """
    Welcome to %s!

    To login you need to first create an account. This is easy and
    free to do: Choose option {w(1){n in the menu and enter an account
    name and password when prompted.  Obs- the account name is {wnot{n
    the name of the Character you will play in the game!

    It's always a good idea (not only here, but everywhere on the net)
    to not use a regular word for your password. Make it longer than 3
    characters (ideally 6 or more) and mix numbers and capitalization
    into it. The password also handles whitespace, so why not make it
    a small sentence - easy to remember, hard for a computer to crack.

    Once you have an account, use option {w(2){n to log in using the
    account name and password you specified.

    Use the {whelp{n command once you're logged in to get more
    aid. Hope you enjoy your stay!


    (return to go back)""" % settings.SERVERNAME


# Menu entry 4

class CmdUnloggedinQuit(Command):
    """
    We maintain a different version of the quit command
    here for unconnected players for the sake of simplicity. The logged in
    version is a bit more complicated.
    """
    key = "4"
    aliases = ["quit", "qu", "q"]
    locks = "cmd:all()"

    def func(self):
        "Simply close the connection."
        self.menutree.goto("END")
        self.caller.sessionhandler.disconnect(self.caller, "Good bye! Disconnecting...")


# The login menu tree, using the commands above

START = MenuNode("START", text=utils.string_from_module(CONNECTION_SCREEN_MODULE),
                 links=["node1a", "node2a", "node3", "END"],
                 linktexts=["Log in with an existing account",
                            "Create a new account",
                            "Help",
                            "Quit"],
                 selectcmds=[None, None, None, CmdUnloggedinQuit])

node1a = MenuNode("node1a", text="Please enter your account name (empty to abort).",
                  links=["START", "node1b"],
                  helptext=["Enter the account name you previously registered with."],
                  keywords=[CMD_NOINPUT, CMD_NOMATCH],
                  selectcmds=[CmdBackToStart, CmdUsernameSelect],
                  nodefaultcmds=True) # if we don't, default help/look will be triggered by names starting with l/h ...
node1b = MenuNode("node1b", text="Please enter your password (empty to go back).",
                  links=["node1a", "END"],
                  keywords=[CMD_NOINPUT, CMD_NOMATCH],
                  selectcmds=[CmdPasswordSelectBack, CmdPasswordSelect],
                  nodefaultcmds=True)

node2a = MenuNode("node2a", text="Please enter your desired account name (empty to abort).",
                  links=["START", "node2b"],
                  helptext="Account name can max be 30 characters or fewer. Letters, spaces, digits and @/./+/-/_ only.",
                  keywords=[CMD_NOINPUT, CMD_NOMATCH],
                  selectcmds=[CmdBackToStart, CmdUsernameCreate],
                  nodefaultcmds=True)
node2b = MenuNode("node2b", text="Please enter your password (empty to go back).",
                  links=["node2a", "START"],
                  helptext="Your password cannot contain any characters.",
                  keywords=[CMD_NOINPUT, CMD_NOMATCH],
                  selectcmds=[CmdPasswordCreateBack, CmdPasswordCreate],
                  nodefaultcmds=True)
node3 = MenuNode("node3", text=LOGIN_SCREEN_HELP,
                 links=["START"],
                 helptext="",
                 keywords=[CMD_NOINPUT],
                 selectcmds=[CmdBackToStart])


# access commands

class UnloggedInCmdSet(CmdSet):
    "Cmdset for the unloggedin state"
    key = "UnloggedinState"
    priority = 0

    def at_cmdset_creation(self):
        "Called when cmdset is first  created"
        self.add(CmdUnloggedinLook())


class CmdUnloggedinLook(Command):
    """
    An unloggedin version of the look command. This is called by the server
    when the player first connects. It sets up the menu before handing off
    to the menu's own look command..
    """
    key = CMD_LOGINSTART
    locks = "cmd:all()"

    def func(self):
        "Execute the menu"
        menu = MenuTree(self.caller, nodes=(START, node1a, node1b,
                                            node2a, node2b, node3),
                                            exec_end=None)
        menu.start()

########NEW FILE########
__FILENAME__ = child
"""
This defines the the parent for all subprocess children.

Inherit from this to define a new type of subprocess.

"""

from twisted.python import log
from twisted.internet import error
from twisted.protocols import amp
from contrib.procpools.ampoule.commands import Echo, Shutdown, Ping

class AMPChild(amp.AMP):
    def __init__(self):
        super(AMPChild, self).__init__(self)
        self.shutdown = False

    def connectionLost(self, reason):
        amp.AMP.connectionLost(self, reason)
        from twisted.internet import reactor
        try:
            reactor.stop()
        except error.ReactorNotRunning:
            # woa, this means that something bad happened,
            # most probably we received a SIGINT. Now this is only
            # a problem when you use Ctrl+C to stop the main process
            # because it would send the SIGINT to child processes too.
            # In all other cases receiving a SIGINT here would be an
            # error condition and correctly restarted. maybe we should
            # use sigprocmask?
            pass
        if not self.shutdown:
            # if the shutdown wasn't explicit we presume that it's an
            # error condition and thus we return a -1 error returncode.
            import os
            os._exit(-1)

    def shutdown(self):
        """
        This method is needed to shutdown the child gently without
        generating an exception.
        """
        #log.msg("Shutdown message received, goodbye.")
        self.shutdown = True
        return {}
    Shutdown.responder(shutdown)

    def ping(self):
        """
        Ping the child and return an answer
        """
        return {'response': "pong"}
    Ping.responder(ping)

    def echo(self, data):
        """
        Echo some data through the child.
        """
        return {'response': data}
    Echo.responder(echo)

########NEW FILE########
__FILENAME__ = commands
from twisted.protocols import amp

class Shutdown(amp.Command):
    responseType = amp.QuitBox

class Ping(amp.Command):
    response = [('response', amp.String())]

class Echo(amp.Command):
    arguments = [('data', amp.String())]
    response = [('response', amp.String())]

########NEW FILE########
__FILENAME__ = iampoule
from zope.interface import Interface

class IStarter(Interface):
    def startAMPProcess(ampChild, ampParent=None):
        """
        @param ampChild: The AMP protocol spoken by the created child.
        @type ampChild: L{twisted.protocols.amp.AMP}

        @param ampParent: The AMP protocol spoken by the parent.
        @type ampParent: L{twisted.protocols.amp.AMP}
        """

    def startPythonProcess(prot, *args):
        """
        @param prot: a L{protocol.ProcessProtocol} subclass
        @type prot: L{protocol.ProcessProtocol}

        @param args: a tuple of arguments that will be passed to the
                    child process.

        @return: a tuple of the child process and the deferred finished.
                 finished triggers when the subprocess dies for any reason.
        """


########NEW FILE########
__FILENAME__ = main
import os
import sys
import imp
import itertools

from zope.interface import implements

from twisted.internet import reactor, protocol, defer, error
from twisted.python import log, util, reflect
from twisted.protocols import amp
from twisted.python import runtime
from twisted.python.compat import set

from contrib.procpools.ampoule import iampoule

gen = itertools.count()

if runtime.platform.isWindows():
    IS_WINDOWS = True
    TO_CHILD = 0
    FROM_CHILD = 1
else:
    IS_WINDOWS = False
    TO_CHILD = 3
    FROM_CHILD = 4

class AMPConnector(protocol.ProcessProtocol):
    """
    A L{ProcessProtocol} subclass that can understand and speak AMP.

    @ivar amp: the children AMP process
    @type amp: L{amp.AMP}

    @ivar finished: a deferred triggered when the process dies.
    @type finished: L{defer.Deferred}

    @ivar name: Unique name for the connector, much like a pid.
    @type name: int
    """

    def __init__(self, proto, name=None):
        """
        @param proto: An instance or subclass of L{amp.AMP}
        @type proto: L{amp.AMP}

        @param name: optional name of the subprocess.
        @type name: int
        """
        self.finished = defer.Deferred()
        self.amp = proto
        self.name = name
        if name is None:
            self.name = gen.next()

    def signalProcess(self, signalID):
        """
        Send the signal signalID to the child process

        @param signalID: The signal ID that you want to send to the
                        corresponding child
        @type signalID: C{str} or C{int}
        """
        return self.transport.signalProcess(signalID)

    def connectionMade(self):
        #log.msg("Subprocess %s started." % (self.name,))
        self.amp.makeConnection(self)

    # Transport
    disconnecting = False

    def write(self, data):
        if IS_WINDOWS:
            self.transport.write(data)
        else:
            self.transport.writeToChild(TO_CHILD, data)

    def loseConnection(self):
        self.transport.closeChildFD(TO_CHILD)
        self.transport.closeChildFD(FROM_CHILD)
        self.transport.loseConnection()

    def getPeer(self):
        return ('subprocess %i' % self.name,)

    def getHost(self):
        return ('Evennia Server',)

    def childDataReceived(self, childFD, data):
        if childFD == FROM_CHILD:
            self.amp.dataReceived(data)
            return
        self.errReceived(data)

    def errReceived(self, data):
        for line in data.strip().splitlines():
            log.msg("FROM %s: %s" % (self.name, line))

    def processEnded(self, status):
        #log.msg("Process: %s ended" % (self.name,))
        self.amp.connectionLost(status)
        if status.check(error.ProcessDone):
            self.finished.callback('')
            return
        self.finished.errback(status)

BOOTSTRAP = """\
import sys

def main(reactor, ampChildPath):
    from twisted.application import reactors
    reactors.installReactor(reactor)

    from twisted.python import log
    %s

    from twisted.internet import reactor, stdio
    from twisted.python import reflect, runtime

    ampChild = reflect.namedAny(ampChildPath)
    ampChildInstance = ampChild(*sys.argv[1:-2])
    if runtime.platform.isWindows():
        stdio.StandardIO(ampChildInstance)
    else:
        stdio.StandardIO(ampChildInstance, %s, %s)
    enter = getattr(ampChildInstance, '__enter__', None)
    if enter is not None:
        enter()
    try:
        reactor.run()
    except:
        if enter is not None:
            info = sys.exc_info()
            if not ampChildInstance.__exit__(*info):
                raise
        else:
            raise
    else:
        if enter is not None:
            ampChildInstance.__exit__(None, None, None)

main(sys.argv[-2], sys.argv[-1])
""" % ('%s', TO_CHILD, FROM_CHILD)

# in the first spot above, either insert an empty string or
# 'log.startLogging(sys.stderr)'
# to start logging

class ProcessStarter(object):

    implements(iampoule.IStarter)

    connectorFactory = AMPConnector
    def __init__(self, bootstrap=BOOTSTRAP, args=(), env={},
                 path=None, uid=None, gid=None, usePTY=0,
                 packages=(), childReactor="select"):
        """
        @param bootstrap: Startup code for the child process
        @type  bootstrap: C{str}

        @param args: Arguments that should be supplied to every child
                     created.
        @type args: C{tuple} of C{str}

        @param env: Environment variables that should be present in the
                    child environment
        @type env: C{dict}

        @param path: Path in which to run the child
        @type path: C{str}

        @param uid: if defined, the uid used to run the new process.
        @type uid: C{int}

        @param gid: if defined, the gid used to run the new process.
        @type gid: C{int}

        @param usePTY: Should the child processes use PTY processes
        @type usePTY: 0 or 1

        @param packages: A tuple of packages that should be guaranteed
                         to be importable in the child processes
        @type packages: C{tuple} of C{str}

        @param childReactor: a string that sets the reactor for child
                             processes
        @type childReactor: C{str}
        """
        self.bootstrap = bootstrap
        self.args = args
        self.env = env
        self.path = path
        self.uid = uid
        self.gid = gid
        self.usePTY = usePTY
        self.packages = ("ampoule",) + packages
        self.packages = packages
        self.childReactor = childReactor

    def __repr__(self):
        """
        Represent the ProcessStarter with a string.
        """
        return """ProcessStarter(bootstrap=%r,
                                 args=%r,
                                 env=%r,
                                 path=%r,
                                 uid=%r,
                                 gid=%r,
                                 usePTY=%r,
                                 packages=%r,
                                 childReactor=%r)""" % (self.bootstrap,
                                                        self.args,
                                                        self.env,
                                                        self.path,
                                                        self.uid,
                                                        self.gid,
                                                        self.usePTY,
                                                        self.packages,
                                                        self.childReactor)

    def _checkRoundTrip(self, obj):
        """
        Make sure that an object will properly round-trip through 'qual' and
        'namedAny'.

        Raise a L{RuntimeError} if they aren't.
        """
        tripped = reflect.namedAny(reflect.qual(obj))
        if tripped is not obj:
            raise RuntimeError("importing %r is not the same as %r" %
                               (reflect.qual(obj), obj))

    def startAMPProcess(self, ampChild, ampParent=None, ampChildArgs=()):
        """
        @param ampChild: a L{ampoule.child.AMPChild} subclass.
        @type ampChild: L{ampoule.child.AMPChild}

        @param ampParent: an L{amp.AMP} subclass that implements the parent
                          protocol for this process pool
        @type ampParent: L{amp.AMP}
        """
        self._checkRoundTrip(ampChild)
        fullPath = reflect.qual(ampChild)
        if ampParent is None:
            ampParent = amp.AMP
        prot = self.connectorFactory(ampParent())
        args = ampChildArgs + (self.childReactor, fullPath)
        return self.startPythonProcess(prot, *args)


    def startPythonProcess(self, prot, *args):
        """
        @param prot: a L{protocol.ProcessProtocol} subclass
        @type prot: L{protocol.ProcessProtocol}

        @param args: a tuple of arguments that will be added after the
                     ones in L{self.args} to start the child process.

        @return: a tuple of the child process and the deferred finished.
                 finished triggers when the subprocess dies for any reason.
        """
        spawnProcess(prot, self.bootstrap, self.args+args, env=self.env,
                     path=self.path, uid=self.uid, gid=self.gid,
                     usePTY=self.usePTY, packages=self.packages)

        # XXX: we could wait for startup here, but ... is there really any
        # reason to?  the pipe should be ready for writing.  The subprocess
        # might not start up properly, but then, a subprocess might shut down
        # at any point too. So we just return amp and have this piece to be
        # synchronous.
        return prot.amp, prot.finished

def spawnProcess(processProtocol, bootstrap, args=(), env={},
                 path=None, uid=None, gid=None, usePTY=0,
                 packages=()):
    env = env.copy()

    pythonpath = []
    for pkg in packages:
        pkg_path, name = os.path.split(pkg)
        p = os.path.split(imp.find_module(name, [pkg_path] if pkg_path else None)[1])[0]
        if p.startswith(os.path.join(sys.prefix, 'lib')):
            continue
        pythonpath.append(p)
    pythonpath = list(set(pythonpath))
    pythonpath.extend(env.get('PYTHONPATH', '').split(os.pathsep))
    env['PYTHONPATH'] = os.pathsep.join(pythonpath)
    args = (sys.executable, '-c', bootstrap) + args
    # childFDs variable is needed because sometimes child processes
    # misbehave and use stdout to output stuff that should really go
    # to stderr. Of course child process might even use the wrong FDs
    # that I'm using here, 3 and 4, so we are going to fix all these
    # issues when I add support for the configuration object that can
    # fix this stuff in a more configurable way.
    if IS_WINDOWS:
        return reactor.spawnProcess(processProtocol, sys.executable, args,
                                    env, path, uid, gid, usePTY)
    else:
        return reactor.spawnProcess(processProtocol, sys.executable, args,
                                    env, path, uid, gid, usePTY,
                                    childFDs={0:"w", 1:"r", 2:"r", 3:"w", 4:"r"})

########NEW FILE########
__FILENAME__ = pool
import time
import random
import heapq
import itertools
import signal
choice = random.choice
now = time.time
count = itertools.count().next
pop = heapq.heappop

from twisted.internet import defer, task, error
from twisted.python import log, failure

from contrib.procpools.ampoule import commands, main

try:
    DIE = signal.SIGKILL
except AttributeError:
    # Windows doesn't have SIGKILL, let's just use SIGTERM then
    DIE = signal.SIGTERM

class ProcessPool(object):
    """
    This class generalizes the functionality of a pool of
    processes to which work can be dispatched.

    @ivar finished: Boolean flag, L{True} when the pool is finished.

    @ivar started: Boolean flag, L{True} when the pool is started.

    @ivar name: Optional name for the process pool

    @ivar min: Minimum number of subprocesses to set up

    @ivar max: Maximum number of subprocesses to set up

    @ivar maxIdle: Maximum number of seconds of indleness in a child

    @ivar starter: A process starter instance that provides
                    L{iampoule.IStarter}.

    @ivar recycleAfter: Maximum number of calls before restarting a
                        subprocess, 0 to not recycle.

    @ivar ampChild: The child AMP protocol subclass with the commands
                    that the child should implement.

    @ivar ampParent: The parent AMP protocol subclass with the commands
                    that the parent should implement.

    @ivar timeout: The general timeout (in seconds) for every child
                    process call.
    """

    finished = False
    started = False
    name = None

    def __init__(self, ampChild=None, ampParent=None, min=5, max=20,
                 name=None, maxIdle=20, recycleAfter=500, starter=None,
                 timeout=None, timeout_signal=DIE, ampChildArgs=()):
        self.starter = starter
        self.ampChildArgs = tuple(ampChildArgs)
        if starter is None:
            self.starter = main.ProcessStarter(packages=("twisted", "ampoule"))
        self.ampParent = ampParent
        self.ampChild = ampChild
        if ampChild is None:
            from contrib.procpools.ampoule.child import AMPChild
            self.ampChild = AMPChild
        self.min = min
        self.max = max
        self.name = name
        self.maxIdle = maxIdle
        self.recycleAfter = recycleAfter
        self.timeout = timeout
        self.timeout_signal = timeout_signal
        self._queue = []

        self.processes = set()
        self.ready = set()
        self.busy = set()
        self._finishCallbacks = {}
        self._lastUsage = {}
        self._calls = {}
        self.looping = task.LoopingCall(self._pruneProcesses)
        self.looping.start(maxIdle, now=False)

    def start(self, ampChild=None):
        """
        Starts the ProcessPool with a given child protocol.

        @param ampChild: a L{ampoule.child.AMPChild} subclass.
        @type ampChild: L{ampoule.child.AMPChild} subclass
        """
        if ampChild is not None and not self.started:
            self.ampChild = ampChild
        self.finished = False
        self.started = True
        return self.adjustPoolSize()

    def _pruneProcesses(self):
        """
        Remove idle processes from the pool.
        """
        n = now()
        d = []
        for child, lastUse in self._lastUsage.iteritems():
            if len(self.processes) > self.min and (n - lastUse) > self.maxIdle:
                # we are setting lastUse when processing finishes, it
                # might be processing right now
                if child not in self.busy:
                    # we need to remove this child from the ready set
                    # and the processes set because otherwise it might
                    # get calls from doWork
                    self.ready.discard(child)
                    self.processes.discard(child)
                    d.append(self.stopAWorker(child))
        return defer.DeferredList(d)

    def _pruneProcess(self, child):
        """
        Remove every trace of the process from this instance.
        """
        self.processes.discard(child)
        self.ready.discard(child)
        self.busy.discard(child)
        self._lastUsage.pop(child, None)
        self._calls.pop(child, None)
        self._finishCallbacks.pop(child, None)

    def _addProcess(self, child, finished):
        """
        Adds the newly created child process to the pool.
        """
        def restart(child, reason):
            #log.msg("FATAL: Restarting after %s" % (reason,))
            self._pruneProcess(child)
            return self.startAWorker()

        def dieGently(data, child):
            #log.msg("STOPPING: '%s'" % (data,))
            self._pruneProcess(child)

        self.processes.add(child)
        self.ready.add(child)
        finished.addCallback(dieGently, child
               ).addErrback(lambda reason: restart(child, reason))
        self._finishCallbacks[child] = finished
        self._lastUsage[child] = now()
        self._calls[child] = 0
        self._catchUp()

    def _catchUp(self):
        """
        If there are queued items in the list then run them.
        """
        if self._queue:
            _, (d, command, kwargs) = pop(self._queue)
            self._cb_doWork(command, **kwargs).chainDeferred(d)

    def _handleTimeout(self, child):
        """
        One of the children went timeout, we need to deal with it

        @param child: The child process
        @type child: L{child.AMPChild}
        """
        try:
            child.transport.signalProcess(self.timeout_signal)
        except error.ProcessExitedAlready:
            # don't do anything then... we are too late
            # or we were too early to call
            pass

    def startAWorker(self):
        """
        Start a worker and set it up in the system.
        """
        if self.finished:
            # this is a race condition: basically if we call self.stop()
            # while a process is being recycled what happens is that the
            # process will be created anyway. By putting a check for
            # self.finished here we make sure that in no way we are creating
            # processes when the pool is stopped.
            # The race condition comes from the fact that:
            # stopAWorker() is asynchronous while stop() is synchronous.
            # so if you call:
            # pp.stopAWorker(child).addCallback(lambda _: pp.startAWorker())
            # pp.stop()
            # You might end up with a dirty reactor due to the stop()
            # returning before the new process is created.
            return
        startAMPProcess = self.starter.startAMPProcess
        child, finished = startAMPProcess(self.ampChild,
                                          ampParent=self.ampParent,
                                          ampChildArgs=self.ampChildArgs)
        return self._addProcess(child, finished)

    def _cb_doWork(self, command, _timeout=None, _deadline=None,
                   **kwargs):
        """
        Go and call the command.

        @param command: The L{amp.Command} to be executed in the child
        @type command: L{amp.Command}

        @param _d: The deferred for the calling code.
        @type _d: L{defer.Deferred}

        @param _timeout: The timeout for this call only
        @type _timeout: C{int}
        @param _deadline: The deadline for this call only
        @type _deadline: C{int}
        """
        timeoutCall = None
        deadlineCall = None

        def _returned(result, child, is_error=False):
            def cancelCall(call):
                if call is not None and call.active():
                    call.cancel()
            cancelCall(timeoutCall)
            cancelCall(deadlineCall)
            self.busy.discard(child)
            if not die:
                # we are not marked to be removed, so add us back to
                # the ready set and let's see if there's some catching
                # up to do
                self.ready.add(child)
                self._catchUp()
            else:
                # We should die and we do, then we start a new worker
                # to pick up stuff from the queue otherwise we end up
                # without workers and the queue will remain there.
                self.stopAWorker(child).addCallback(lambda _: self.startAWorker())
            self._lastUsage[child] = now()
            # we can't do recycling here because it's too late and
            # the process might have received tons of calls already
            # which would make it run more calls than what is
            # configured to do.
            return result

        die = False
        child = self.ready.pop()
        self.busy.add(child)
        self._calls[child] += 1

        # Let's see if this call goes over the recycling barrier
        if self.recycleAfter and self._calls[child] >= self.recycleAfter:
            # it does so mark this child, using a closure, to be
            # removed at the end of the call.
            die = True

        # If the command doesn't require a response then callRemote
        # returns nothing, so we prepare for that too.
        # We also need to guard against timeout errors for child
        # and local timeout parameter overrides the global one
        if _timeout == 0:
            timeout = _timeout
        else:
            timeout = _timeout or self.timeout

        if timeout is not None:
            from twisted.internet import reactor
            timeoutCall = reactor.callLater(timeout, self._handleTimeout, child)

        if _deadline is not None:
            from twisted.internet import reactor
            delay = max(0, _deadline - reactor.seconds())
            deadlineCall = reactor.callLater(delay, self._handleTimeout,
                                             child)

        return defer.maybeDeferred(child.callRemote, command, **kwargs
            ).addCallback(_returned, child
            ).addErrback(_returned, child, is_error=True)

    def callRemote(self, *args, **kwargs):
        """
        Proxy call to keep the API homogeneous across twisted's RPCs
        """
        return self.doWork(*args, **kwargs)

    def doWork(self, command, **kwargs):
        """
        Sends the command to one child.

        @param command: an L{amp.Command} type object.
        @type command: L{amp.Command}

        @param kwargs: dictionary containing the arguments for the command.
        """
        if self.ready: # there are unused processes, let's use them
            return self._cb_doWork(command, **kwargs)
        else:
            if len(self.processes) < self.max:
                # no unused but we can start some new ones
                # since startAWorker is synchronous we won't have a
                # race condition here in case of multiple calls to
                # doWork, so we will end up in the else clause in case
                # of such calls:
                # Process pool with min=1, max=1, recycle_after=1
                # [call(Command) for x in xrange(BIG_NUMBER)]
                self.startAWorker()
                return self._cb_doWork(command, **kwargs)
            else:
                # No one is free... just queue up and wait for a process
                # to start and pick up the first item in the queue.
                d = defer.Deferred()
                self._queue.append((count(), (d, command, kwargs)))
                return d

    def stopAWorker(self, child=None):
        """
        Gently stop a child so that it's not restarted anymore

        @param command: an L{ampoule.child.AmpChild} type object.
        @type command: L{ampoule.child.AmpChild} or None

        """
        if child is None:
            if self.ready:
                child = self.ready.pop()
            else:
                child = choice(list(self.processes))
        child.callRemote(commands.Shutdown
            # This is needed for timeout handling, the reason is pretty hard
            # to explain but I'll try to:
            # There's another small race condition in the system. If the
            # child process is shut down by a signal and you try to stop
            # the process pool immediately afterwards, like tests would do,
            # the child AMP object would still be in the system and trying
            # to call the command Shutdown on it would result in the same
            # errback that we got originally, for this reason we need to
            # trap it now so that it doesn't raise by not being handled.
            # Does this even make sense to you?
            ).addErrback(lambda reason: reason.trap(error.ProcessTerminated))
        return self._finishCallbacks[child]

    def _startSomeWorkers(self):
        """
        Start a bunch of workers until we reach the max number of them.
        """
        if len(self.processes) < self.max:
            self.startAWorker()

    def adjustPoolSize(self, min=None, max=None):
        """
        Change the pool size to be at least min and less than max,
        useful when you change the values of max and min in the instance
        and you want the pool to adapt to them.
        """
        if min is None:
            min = self.min
        if max is None:
            max = self.max

        assert min >= 0, 'minimum is negative'
        assert min <= max, 'minimum is greater than maximum'

        self.min = min
        self.max = max

        l = []
        if self.started:

            for i in xrange(len(self.processes)-self.max):
                l.append(self.stopAWorker())
            while len(self.processes) < self.min:
                self.startAWorker()

        return defer.DeferredList(l)#.addCallback(lambda _: self.dumpStats())

    def stop(self):
        """
        Stops the process protocol.
        """
        self.finished = True
        l = [self.stopAWorker(process) for process in self.processes]
        def _cb(_):
            if self.looping.running:
                self.looping.stop()

        return defer.DeferredList(l).addCallback(_cb)

    def dumpStats(self):
        log.msg("ProcessPool stats:")
        log.msg('\tworkers: %s' % len(self.processes))
        log.msg('\ttimeout: %s' % (self.timeout))
        log.msg('\tparent: %r' % (self.ampParent,))
        log.msg('\tchild: %r' % (self.ampChild,))
        log.msg('\tmax idle: %r' % (self.maxIdle,))
        log.msg('\trecycle after: %r' % (self.recycleAfter,))
        log.msg('\tProcessStarter:')
        log.msg('\t\t%r' % (self.starter,))

pp = None

def deferToAMPProcess(command, **kwargs):
    """
    Helper function that sends a command to the default process pool
    and returns a deferred that fires when the result of the
    subprocess computation is ready.

    @param command: an L{amp.Command} subclass
    @param kwargs: dictionary containing the arguments for the command.

    @return: a L{defer.Deferred} with the data from the subprocess.
    """
    global pp
    if pp is None:
        pp = ProcessPool()
        return pp.start().addCallback(lambda _: pp.doWork(command, **kwargs))
    return pp.doWork(command, **kwargs)

########NEW FILE########
__FILENAME__ = rpool
"""
This module implements a remote pool to use with AMP.
"""

from twisted.protocols import amp

class AMPProxy(amp.AMP):
    """
    A Proxy AMP protocol that forwards calls to a wrapped
    callRemote-like callable.
    """
    def __init__(self, wrapped, child):
        """
        @param wrapped: A callRemote-like callable that takes an
                        L{amp.Command} as first argument and other
                        optional keyword arguments afterwards.
        @type wrapped: L{callable}.

        @param child: The protocol class of the process pool children.
                      Used to forward only the methods that are actually
                      understood correctly by them.
        @type child: L{amp.AMP}
        """
        amp.AMP.__init__(self)
        self.wrapped = wrapped
        self.child = child

        localCd = set(self._commandDispatch.keys())
        childCd = set(self.child._commandDispatch.keys())
        assert localCd.intersection(childCd) == set(["StartTLS"]), \
                    "Illegal method overriding in Proxy"

    def locateResponder(self, name):
        """
        This is a custom locator to forward calls to the children
        processes while keeping the ProcessPool a transparent MITM.

        This way of working has a few limitations, the first of which
        is the fact that children won't be able to take advantage of
        any dynamic locator except for the default L{CommandLocator}
        that is based on the _commandDispatch attribute added by the
        metaclass. This limitation might be lifted in the future.
        """
        if name == "StartTLS":
            # This is a special case where the proxy takes precedence
            return amp.AMP.locateResponder(self, "StartTLS")

        # Get the dict of commands from the child AMP implementation.
        cd = self.child._commandDispatch
        if name in cd:
            # If the command is there, then we forward stuff to it.
            commandClass, _responderFunc = cd[name]
            # We need to wrap the doWork function because the wrapping
            # call doesn't pass the command as first argument since it
            # thinks that we are the actual receivers and callable is
            # already the responder while it isn't.
            doWork = lambda **kw: self.wrapped(commandClass, **kw)
            # Now let's call the right function and wrap the result
            # dictionary.
            return self._wrapWithSerialization(doWork, commandClass)
        # of course if the name of the command is not in the child it
        # means that it might be in this class, so fallback to the
        # default behavior of this module.
        return amp.AMP.locateResponder(self, name)


########NEW FILE########
__FILENAME__ = service
import os

from twisted.application import service
from twisted.internet.protocol import ServerFactory

def makeService(options):
    """
    Create the service for the application
    """
    ms = service.MultiService()

    from contrib.procpools.ampoule.pool import ProcessPool
    from contrib.procpools.ampoule.main import ProcessStarter
    name = options['name']
    ampport = options['ampport']
    ampinterface = options['ampinterface']
    child = options['child']
    parent = options['parent']
    min = options['min']
    max = options['max']
    maxIdle = options['max_idle']
    recycle = options['recycle']
    childReactor = options['reactor']
    timeout = options['timeout']

    starter = ProcessStarter(packages=("twisted", "ampoule"), childReactor=childReactor)
    pp = ProcessPool(child, parent, min, max, name, maxIdle, recycle, starter, timeout)
    svc = AMPouleService(pp, child, ampport, ampinterface)
    svc.setServiceParent(ms)

    return ms

class AMPouleService(service.Service):
    def __init__(self, pool, child, port, interface):
        self.pool = pool
        self.port = port
        self.child = child
        self.interface = interface
        self.server = None

    def startService(self):
        """
        Before reactor.run() is called we setup the system.
        """
        service.Service.startService(self)
        from contrib.procpools.ampoule import rpool
        from twisted.internet import reactor

        try:
            factory = ServerFactory()
            factory.protocol = lambda: rpool.AMPProxy(wrapped=self.pool.doWork,
                                                      child=self.child)
            self.server = reactor.listenTCP(self.port,
                                            factory,
                                            interface=self.interface)
            # this is synchronous when it's the startup, even though
            # it returns a deferred. But we need to run it after the
            # first cycle in order to wait for signal handlers to be
            # installed.
            reactor.callLater(0, self.pool.start)
        except:
            import traceback
            print traceback.format_exc()

    def stopService(self):
        service.Service.stopService(self)
        if self.server is not None:
            self.server.stopListening()
        return self.pool.stop()

########NEW FILE########
__FILENAME__ = test_process

from signal import SIGHUP
import math
import os
import os.path
from cStringIO import StringIO as sio
import tempfile

from twisted.internet import error, defer, reactor
from twisted.python import failure, reflect
from twisted.trial import unittest
from twisted.protocols import amp
from contrib.procpools.ampoule import main, child, commands, pool

class ShouldntHaveBeenCalled(Exception):
    pass

def _raise(_):
    raise ShouldntHaveBeenCalled(_)

class _FakeT(object):
    closeStdinCalled = False
    def __init__(self, s):
        self.s = s

    def closeStdin(self):
        self.closeStdinCalled = True

    def write(self, data):
        self.s.write(data)

class FakeAMP(object):
    connector = None
    reason = None
    def __init__(self, s):
        self.s = s

    def makeConnection(self, connector):
        if self.connector is not None:
            raise Exception("makeConnection called twice")
        self.connector = connector

    def connectionLost(self, reason):
        if self.reason is not None:
            raise Exception("connectionLost called twice")
        self.reason = reason

    def dataReceived(self, data):
        self.s.write(data)

class Ping(amp.Command):
    arguments = [('data', amp.String())]
    response = [('response', amp.String())]

class Pong(amp.Command):
    arguments = [('data', amp.String())]
    response = [('response', amp.String())]

class Pid(amp.Command):
    response = [('pid', amp.Integer())]

class Reactor(amp.Command):
    response = [('classname', amp.String())]

class NoResponse(amp.Command):
    arguments = [('arg', amp.String())]
    requiresAnswer = False

class GetResponse(amp.Command):
    response = [("response", amp.String())]

class Child(child.AMPChild):
    def ping(self, data):
        return self.callRemote(Pong, data=data)
    Ping.responder(ping)

class PidChild(child.AMPChild):
    def pid(self):
        import os
        return {'pid': os.getpid()}
    Pid.responder(pid)

class NoResponseChild(child.AMPChild):
    _set = False
    def noresponse(self, arg):
        self._set = arg
        return {}
    NoResponse.responder(noresponse)

    def getresponse(self):
        return {"response": self._set}
    GetResponse.responder(getresponse)

class ReactorChild(child.AMPChild):
    def reactor(self):
        from twisted.internet import reactor
        return {'classname': reactor.__class__.__name__}
    Reactor.responder(reactor)

class First(amp.Command):
    arguments = [('data', amp.String())]
    response = [('response', amp.String())]

class Second(amp.Command):
    pass

class WaitingChild(child.AMPChild):
    deferred = None
    def first(self, data):
        self.deferred = defer.Deferred()
        return self.deferred.addCallback(lambda _: {'response': data})
    First.responder(first)
    def second(self):
        self.deferred.callback('')
        return {}
    Second.responder(second)

class Die(amp.Command):
    pass

class BadChild(child.AMPChild):
    def die(self):
        self.shutdown = False
        self.transport.loseConnection()
        return {}
    Die.responder(die)


class Write(amp.Command):
    response = [("response", amp.String())]
    pass


class Writer(child.AMPChild):

    def __init__(self, data='hello'):
        child.AMPChild.__init__(self)
        self.data = data

    def write(self):
        return {'response': self.data}
    Write.responder(write)


class GetCWD(amp.Command):

    response = [("cwd", amp.String())]


class TempDirChild(child.AMPChild):

    def __init__(self, directory=None):
        child.AMPChild.__init__(self)
        self.directory = directory

    def __enter__(self):
        directory = tempfile.mkdtemp()
        os.chdir(directory)
        if self.directory is not None:
            os.mkdir(self.directory)
            os.chdir(self.directory)

    def __exit__(self, exc_type, exc_val, exc_tb):
        cwd = os.getcwd()
        os.chdir('..')
        os.rmdir(cwd)

    def getcwd(self):
        return {'cwd': os.getcwd()}
    GetCWD.responder(getcwd)


class TestAMPConnector(unittest.TestCase):
    def setUp(self):
        """
        The only reason why this method exists is to let 'trial ampoule'
        to install the signal handlers (#3178 for reference).
        """
        super(TestAMPConnector, self).setUp()
        d = defer.Deferred()
        reactor.callLater(0, d.callback, None)
        return d

    def _makeConnector(self, s, sa):
        a = FakeAMP(sa)
        ac = main.AMPConnector(a)
        assert ac.name is not None
        ac.transport = _FakeT(s)
        return ac

    def test_protocol(self):
        """
        Test that outReceived writes to AMP and that it triggers the
        finished deferred once the process ended.
        """
        s = sio()
        sa = sio()
        ac = self._makeConnector(s, sa)

        for x in xrange(99):
            ac.childDataReceived(4, str(x))

        ac.processEnded(failure.Failure(error.ProcessDone(0)))
        return ac.finished.addCallback(
            lambda _: self.assertEqual(sa.getvalue(), ''.join(str(x) for x in xrange(99)))
        )

    def test_protocol_failing(self):
        """
        Test that a failure in the process termination is correctly
        propagated to the finished deferred.
        """
        s = sio()
        sa = sio()
        ac = self._makeConnector(s, sa)

        ac.finished.addCallback(_raise)
        fail = failure.Failure(error.ProcessTerminated())
        self.assertFailure(ac.finished, error.ProcessTerminated)
        ac.processEnded(fail)

    def test_startProcess(self):
        """
        Test that startProcess actually starts a subprocess and that
        it receives data back from the process through AMP.
        """
        s = sio()
        a = FakeAMP(s)
        STRING = "ciao"
        BOOT = """\
import sys, os
def main(arg):
    os.write(4, arg)
main(sys.argv[1])
"""
        starter = main.ProcessStarter(bootstrap=BOOT,
                                      args=(STRING,),
                                      packages=("twisted", "ampoule"))

        amp, finished = starter.startPythonProcess(main.AMPConnector(a))
        def _eb(reason):
            print reason
        finished.addErrback(_eb)
        return finished.addCallback(lambda _: self.assertEquals(s.getvalue(), STRING))

    def test_failing_deferToProcess(self):
        """
        Test failing subprocesses and the way they terminate and preserve
        failing information.
        """
        s = sio()
        a = FakeAMP(s)
        STRING = "ciao"
        BOOT = """\
import sys
def main(arg):
    raise Exception(arg)
main(sys.argv[1])
"""
        starter = main.ProcessStarter(bootstrap=BOOT, args=(STRING,), packages=("twisted", "ampoule"))
        ready, finished = starter.startPythonProcess(main.AMPConnector(a), "I'll be ignored")

        self.assertFailure(finished, error.ProcessTerminated)
        finished.addErrback(lambda reason: self.assertEquals(reason.getMessage(), STRING))
        return finished

    def test_env_setting(self):
        """
        Test that and environment variable passed to the process starter
        is correctly passed to the child process.
        """
        s = sio()
        a = FakeAMP(s)
        STRING = "ciao"
        BOOT = """\
import sys, os
def main():
    os.write(4, os.getenv("FOOBAR"))
main()
"""
        starter = main.ProcessStarter(bootstrap=BOOT,
                                      packages=("twisted", "ampoule"),
                                      env={"FOOBAR": STRING})
        amp, finished = starter.startPythonProcess(main.AMPConnector(a), "I'll be ignored")
        def _eb(reason):
            print reason
        finished.addErrback(_eb)
        return finished.addCallback(lambda _: self.assertEquals(s.getvalue(), STRING))

    def test_startAMPProcess(self):
        """
        Test that you can start an AMP subprocess and that it correctly
        accepts commands and correctly answers them.
        """
        STRING = "ciao"

        starter = main.ProcessStarter(packages=("twisted", "ampoule"))
        c, finished = starter.startAMPProcess(child.AMPChild)
        c.callRemote(commands.Echo, data=STRING
           ).addCallback(lambda response:
                self.assertEquals(response['response'], STRING)
           ).addCallback(lambda _: c.callRemote(commands.Shutdown))
        return finished

    def test_BootstrapContext(self):
        starter = main.ProcessStarter(packages=('twisted', 'ampoule'))
        c, finished = starter.startAMPProcess(TempDirChild)
        cwd = []
        def checkBootstrap(response):
            cwd.append(response['cwd'])
            self.assertNotEquals(cwd, os.getcwd())
        d = c.callRemote(GetCWD)
        d.addCallback(checkBootstrap)
        d.addCallback(lambda _: c.callRemote(commands.Shutdown))
        finished.addCallback(lambda _: self.assertFalse(os.path.exists(cwd[0])))
        return finished

    def test_BootstrapContextInstance(self):
        starter = main.ProcessStarter(packages=('twisted', 'ampoule'))
        c, finished = starter.startAMPProcess(TempDirChild,
                                              ampChildArgs=('foo',))
        cwd = []
        def checkBootstrap(response):
            cwd.append(response['cwd'])
            self.assertTrue(cwd[0].endswith('/foo'))
        d = c.callRemote(GetCWD)
        d.addCallback(checkBootstrap)
        d.addCallback(lambda _: c.callRemote(commands.Shutdown))
        finished.addCallback(lambda _: self.assertFalse(os.path.exists(cwd[0])))
        return finished

    def test_startAMPAndParentProtocol(self):
        """
        Test that you can start an AMP subprocess and the children can
        call methods on their parent.
        """
        DATA = "CIAO"
        APPEND = "123"

        class Parent(amp.AMP):
            def pong(self, data):
                return {'response': DATA+APPEND}
            Pong.responder(pong)

        starter = main.ProcessStarter(packages=("twisted", "ampoule"))

        subp, finished = starter.startAMPProcess(ampChild=Child, ampParent=Parent)
        subp.callRemote(Ping, data=DATA
           ).addCallback(lambda response:
                self.assertEquals(response['response'], DATA+APPEND)
           ).addCallback(lambda _: subp.callRemote(commands.Shutdown))
        return finished

    def test_roundtripError(self):
        """
        Test that invoking a child using an unreachable class raises
        a L{RunTimeError} .
        """
        class Child(child.AMPChild):
            pass

        starter = main.ProcessStarter(packages=("twisted", "ampoule"))

        self.assertRaises(RuntimeError, starter.startAMPProcess, ampChild=Child)

class TestProcessPool(unittest.TestCase):

    def test_startStopWorker(self):
        """
        Test that starting and stopping a worker keeps the state of
        the process pool consistent.
        """
        pp = pool.ProcessPool()
        self.assertEquals(pp.started, False)
        self.assertEquals(pp.finished, False)
        self.assertEquals(pp.processes, set())
        self.assertEquals(pp._finishCallbacks, {})

        def _checks():
            self.assertEquals(pp.started, False)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), 1)
            self.assertEquals(len(pp._finishCallbacks), 1)
            return pp.stopAWorker()

        def _closingUp(_):
            self.assertEquals(pp.started, False)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), 0)
            self.assertEquals(pp._finishCallbacks, {})
        pp.startAWorker()
        return _checks().addCallback(_closingUp).addCallback(lambda _: pp.stop())

    def test_startAndStop(self):
        """
        Test that a process pool's start and stop method create the
        expected number of workers and keep state consistent in the
        process pool.
        """
        pp = pool.ProcessPool()
        self.assertEquals(pp.started, False)
        self.assertEquals(pp.finished, False)
        self.assertEquals(pp.processes, set())
        self.assertEquals(pp._finishCallbacks, {})

        def _checks(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)
            return pp.stop()

        def _closingUp(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, True)
            self.assertEquals(len(pp.processes), 0)
            self.assertEquals(pp._finishCallbacks, {})
        return pp.start().addCallback(_checks).addCallback(_closingUp)

    def test_adjustPoolSize(self):
        """
        Test that calls to pool.adjustPoolSize are correctly handled.
        """
        pp = pool.ProcessPool(min=10)
        self.assertEquals(pp.started, False)
        self.assertEquals(pp.finished, False)
        self.assertEquals(pp.processes, set())
        self.assertEquals(pp._finishCallbacks, {})

        def _resize1(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)
            return pp.adjustPoolSize(min=2, max=3)

        def _resize2(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(pp.max, 3)
            self.assertEquals(pp.min, 2)
            self.assertEquals(len(pp.processes), pp.max)
            self.assertEquals(len(pp._finishCallbacks), pp.max)

        def _resize3(_):
            self.assertRaises(AssertionError, pp.adjustPoolSize, min=-1, max=5)
            self.assertRaises(AssertionError, pp.adjustPoolSize, min=5, max=1)
            return pp.stop()

        return pp.start(
            ).addCallback(_resize1
            ).addCallback(_resize2
            ).addCallback(_resize3)

    def test_childRestart(self):
        """
        Test that a failing child process is immediately restarted.
        """
        pp = pool.ProcessPool(ampChild=BadChild, min=1)
        STRING = "DATA"

        def _checks(_):
            d = pp._finishCallbacks.values()[0]
            pp.doWork(Die).addErrback(lambda _: None)
            return d.addBoth(_checksAgain)

        def _checksAgain(_):
            return pp.doWork(commands.Echo, data=STRING
                    ).addCallback(lambda result: self.assertEquals(result['response'], STRING))

        return pp.start(
            ).addCallback(_checks
            ).addCallback(lambda _: pp.stop())

    def test_parentProtocolChange(self):
        """
        Test that the father can use an AMP protocol too.
        """
        DATA = "CIAO"
        APPEND = "123"

        class Parent(amp.AMP):
            def pong(self, data):
                return {'response': DATA+APPEND}
            Pong.responder(pong)

        pp = pool.ProcessPool(ampChild=Child, ampParent=Parent)
        def _checks(_):
            return pp.doWork(Ping, data=DATA
                       ).addCallback(lambda response:
                            self.assertEquals(response['response'], DATA+APPEND)
                       )

        return pp.start().addCallback(_checks).addCallback(lambda _: pp.stop())


    def test_deferToAMPProcess(self):
        """
        Test that deferToAMPProcess works as expected.
        """
        def cleanupGlobalPool():
            d = pool.pp.stop()
            pool.pp = None
            return d
        self.addCleanup(cleanupGlobalPool)

        STRING = "CIAOOOO"
        d = pool.deferToAMPProcess(commands.Echo, data=STRING)
        d.addCallback(self.assertEquals, {"response": STRING})
        return d

    def test_checkStateInPool(self):
        """
        Test that busy and ready lists are correctly maintained.
        """
        pp = pool.ProcessPool(ampChild=WaitingChild)

        DATA = "foobar"

        def _checks(_):
            d = pp.callRemote(First, data=DATA)
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)
            self.assertEquals(len(pp.ready), pp.min-1)
            self.assertEquals(len(pp.busy), 1)
            child = pp.busy.pop()
            pp.busy.add(child)
            child.callRemote(Second)
            return d

        return pp.start(
            ).addCallback(_checks
            ).addCallback(lambda _: pp.stop())

    def test_growingToMax(self):
        """
        Test that the pool grows over time until it reaches max processes.
        """
        MAX = 5
        pp = pool.ProcessPool(ampChild=WaitingChild, min=1, max=MAX)

        def _checks(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)

            D = "DATA"
            d = [pp.doWork(First, data=D) for x in xrange(MAX)]

            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.max)
            self.assertEquals(len(pp._finishCallbacks), pp.max)

            [child.callRemote(Second) for child in pp.processes]
            return defer.DeferredList(d)

        return pp.start(
            ).addCallback(_checks
            ).addCallback(lambda _: pp.stop())

    def test_growingToMaxAndShrinking(self):
        """
        Test that the pool grows but after 'idle' time the number of
        processes goes back to the minimum.
        """

        MAX = 5
        MIN = 1
        IDLE = 1
        pp = pool.ProcessPool(ampChild=WaitingChild, min=MIN, max=MAX, maxIdle=IDLE)

        def _checks(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)

            D = "DATA"
            d = [pp.doWork(First, data=D) for x in xrange(MAX)]

            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.max)
            self.assertEquals(len(pp._finishCallbacks), pp.max)

            [child.callRemote(Second) for child in pp.processes]
            return defer.DeferredList(d).addCallback(_realChecks)

        def _realChecks(_):
            from twisted.internet import reactor
            d = defer.Deferred()
            def _cb():
                def __(_):
                    try:
                        self.assertEquals(pp.started, True)
                        self.assertEquals(pp.finished, False)
                        self.assertEquals(len(pp.processes), pp.min)
                        self.assertEquals(len(pp._finishCallbacks), pp.min)
                        d.callback(None)
                    except Exception, e:
                        d.errback(e)
                return pp._pruneProcesses().addCallback(__)
            # just to be shure we are called after the pruner
            pp.looping.stop() # stop the looping, we don't want it to
                              # this right here
            reactor.callLater(IDLE, _cb)
            return d

        return pp.start(
            ).addCallback(_checks
            ).addCallback(lambda _: pp.stop())

    def test_recycling(self):
        """
        Test that after a given number of calls subprocesses are
        recycled.
        """
        MAX = 1
        MIN = 1
        RECYCLE_AFTER = 1
        pp = pool.ProcessPool(ampChild=PidChild, min=MIN, max=MAX, recycleAfter=RECYCLE_AFTER)
        self.addCleanup(pp.stop)

        def _checks(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)
            return pp.doWork(Pid
                ).addCallback(lambda response: response['pid'])

        def _checks2(pid):
            return pp.doWork(Pid
                ).addCallback(lambda response: response['pid']
                ).addCallback(self.assertNotEquals, pid)


        d = pp.start()
        d.addCallback(_checks)
        d.addCallback(_checks2)
        return d

    def test_recyclingWithQueueOverload(self):
        """
        Test that we get the correct number of different results when
        we overload the pool of calls.
        """
        MAX = 5
        MIN = 1
        RECYCLE_AFTER = 10
        CALLS = 60
        pp = pool.ProcessPool(ampChild=PidChild, min=MIN, max=MAX, recycleAfter=RECYCLE_AFTER)
        self.addCleanup(pp.stop)

        def _check(results):
            s = set()
            for succeed, response in results:
                s.add(response['pid'])

            # For the first C{MAX} calls, each is basically guaranteed to go to
            # a different child.  After that, though, there are no guarantees.
            # All the rest might go to a single child, since the child to
            # perform a job is selected arbitrarily from the "ready" set.  Fair
            # distribution of jobs needs to be implemented; right now it's "set
            # ordering" distribution of jobs.
            self.assertTrue(len(s) > MAX)

        def _work(_):
            l = [pp.doWork(Pid) for x in xrange(CALLS)]
            d = defer.DeferredList(l)
            return d.addCallback(_check)
        d = pp.start()
        d.addCallback(_work)
        return d


    def test_disableProcessRecycling(self):
        """
        Test that by setting 0 to recycleAfter we actually disable process recycling.
        """
        MAX = 1
        MIN = 1
        RECYCLE_AFTER = 0
        pp = pool.ProcessPool(ampChild=PidChild, min=MIN, max=MAX, recycleAfter=RECYCLE_AFTER)

        def _checks(_):
            self.assertEquals(pp.started, True)
            self.assertEquals(pp.finished, False)
            self.assertEquals(len(pp.processes), pp.min)
            self.assertEquals(len(pp._finishCallbacks), pp.min)
            return pp.doWork(Pid
                ).addCallback(lambda response: response['pid'])

        def _checks2(pid):
            return pp.doWork(Pid
                ).addCallback(lambda response: response['pid']
                ).addCallback(self.assertEquals, pid
                ).addCallback(lambda _: pid)

        def finish(reason):
            return pp.stop().addCallback(lambda _: reason)

        return pp.start(
            ).addCallback(_checks
            ).addCallback(_checks2
            ).addCallback(_checks2
            ).addCallback(finish)

    def test_changeChildrenReactor(self):
        """
        Test that by passing the correct argument children change their
        reactor type.
        """
        MAX = 1
        MIN = 1
        FIRST = "select"
        SECOND = "poll"

        def checkDefault():
            pp = pool.ProcessPool(
                starter=main.ProcessStarter(
                    childReactor=FIRST,
                    packages=("twisted", "ampoule")),
                ampChild=ReactorChild, min=MIN, max=MAX)
            pp.start()
            return pp.doWork(Reactor
                ).addCallback(self.assertEquals, {'classname': "SelectReactor"}
                ).addCallback(lambda _: pp.stop())

        def checkPool(_):
            pp = pool.ProcessPool(
                starter=main.ProcessStarter(
                    childReactor=SECOND,
                    packages=("twisted", "ampoule")),
                ampChild=ReactorChild, min=MIN, max=MAX)
            pp.start()
            return pp.doWork(Reactor
                ).addCallback(self.assertEquals, {'classname': "PollReactor"}
                ).addCallback(lambda _: pp.stop())

        return checkDefault(
            ).addCallback(checkPool)
    try:
        from select import poll
    except ImportError:
        test_changeChildrenReactor.skip = "This architecture doesn't support select.poll, I can't run this test"

    def test_commandsWithoutResponse(self):
        """
        Test that if we send a command without a required answer we
        actually don't have any problems.
        """
        DATA = "hello"
        pp = pool.ProcessPool(ampChild=NoResponseChild, min=1, max=1)

        def _check(_):
            return pp.doWork(GetResponse
                ).addCallback(self.assertEquals, {"response": DATA})

        def _work(_):
            return pp.doWork(NoResponse, arg=DATA)

        return pp.start(
            ).addCallback(_work
            ).addCallback(_check
            ).addCallback(lambda _: pp.stop())

    def test_SupplyChildArgs(self):
        """Ensure that arguments for the child constructor are passed in."""
        pp = pool.ProcessPool(Writer, ampChildArgs=['body'], min=0)
        def _check(result):
            return pp.doWork(Write).addCallback(
            self.assertEquals, {'response': 'body'})

        return pp.start(
            ).addCallback(_check
            ).addCallback(lambda _: pp.stop())

    def processTimeoutTest(self, timeout):
        pp = pool.ProcessPool(WaitingChild, min=1, max=1)

        def _work(_):
            d = pp.callRemote(First, data="ciao", _timeout=timeout)
            self.assertFailure(d, error.ProcessTerminated)
            return d

        return pp.start(
            ).addCallback(_work
            ).addCallback(lambda _: pp.stop())

    def test_processTimeout(self):
        """
        Test that a call that doesn't finish within the given timeout
        time is correctly handled.
        """
        return self.processTimeoutTest(1)

    def test_processTimeoutZero(self):
        """
        Test that the process is correctly handled when the timeout is zero.
        """
        return self.processTimeoutTest(0)

    def test_processDeadline(self):
        pp = pool.ProcessPool(WaitingChild, min=1, max=1)

        def _work(_):
            d = pp.callRemote(First, data="ciao", _deadline=reactor.seconds())
            self.assertFailure(d, error.ProcessTerminated)
            return d

        return pp.start(
            ).addCallback(_work
            ).addCallback(lambda _: pp.stop())

    def test_processBeforeDeadline(self):
        pp = pool.ProcessPool(PidChild, min=1, max=1)

        def _work(_):
            d = pp.callRemote(Pid, _deadline=reactor.seconds() + 10)
            d.addCallback(lambda result: self.assertNotEqual(result['pid'], 0))
            return d

        return pp.start(
            ).addCallback(_work
            ).addCallback(lambda _: pp.stop())

    def test_processTimeoutSignal(self):
        """
        Test that a call that doesn't finish within the given timeout
        time is correctly handled.
        """
        pp = pool.ProcessPool(WaitingChild, min=1, max=1,
                              timeout_signal=SIGHUP)

        def _work(_):
            d = pp.callRemote(First, data="ciao", _timeout=1)
            d.addCallback(lambda d: self.fail())
            text = 'signal %d' % SIGHUP
            d.addErrback(
                lambda f: self.assertTrue(text in f.value[0],
                '"%s" not in "%s"' % (text, f.value[0])))
            return d

        return pp.start(
            ).addCallback(_work
            ).addCallback(lambda _: pp.stop())

    def test_processGlobalTimeout(self):
        """
        Test that a call that doesn't finish within the given global
        timeout time is correctly handled.
        """
        pp = pool.ProcessPool(WaitingChild, min=1, max=1, timeout=1)

        def _work(_):
            d = pp.callRemote(First, data="ciao")
            self.assertFailure(d, error.ProcessTerminated)
            return d

        return pp.start(
            ).addCallback(_work
            ).addCallback(lambda _: pp.stop())

########NEW FILE########
__FILENAME__ = test_proxy
from twisted.internet import defer, reactor
from twisted.internet.protocol import ClientFactory
from twisted.trial import unittest
from twisted.protocols import amp

from contrib.procpools.ampoule import service, child, pool, main
from contrib.procpools.ampoule.commands import Echo

class ClientAMP(amp.AMP):
    factory = None
    def connectionMade(self):
        if self.factory is not None:
            self.factory.theProto = self
            if hasattr(self.factory, 'onMade'):
                self.factory.onMade.callback(None)

class TestAMPProxy(unittest.TestCase):
    def setUp(self):
        """
        Setup the proxy service and the client connection to the proxy
        service in order to run call through them.

        Inspiration comes from twisted.test.test_amp
        """
        self.pp = pool.ProcessPool()
        self.svc = service.AMPouleService(self.pp, child.AMPChild, 0, "")
        self.svc.startService()
        self.proxy_port = self.svc.server.getHost().port
        self.clientFactory = ClientFactory()
        self.clientFactory.protocol = ClientAMP
        d = self.clientFactory.onMade = defer.Deferred()
        self.clientConn = reactor.connectTCP("127.0.0.1",
                                self.proxy_port,
                                self.clientFactory)
        self.addCleanup(self.clientConn.disconnect)
        self.addCleanup(self.svc.stopService)
        def setClient(_):
            self.client = self.clientFactory.theProto
        return d.addCallback(setClient)

    def test_forwardCall(self):
        """
        Test that a call made from a client is correctly forwarded to
        the process pool and the result is correctly reported.
        """
        DATA = "hello"
        return self.client.callRemote(Echo, data=DATA).addCallback(
            self.assertEquals, {'response': DATA}
        )

########NEW FILE########
__FILENAME__ = util
"""
some utilities
"""
import os
import sys
import __main__

from twisted.python.filepath import FilePath
from twisted.python.reflect import namedAny
# from twisted.python.modules import theSystemPath

def findPackagePath(modulePath):
    """
    Try to find the sys.path entry from a modulePath object, simultaneously
    computing the module name of the targetted file.
    """
    p = modulePath
    l = [p.basename().split(".")[0]]
    while p.parent() != p:
        for extension in ['py', 'pyc', 'pyo', 'pyd', 'dll']:
            sib = p.sibling("__init__."+extension)
            if sib.exists():
                p = p.parent()
                l.insert(0, p.basename())
                break
        else:
            return p.parent(), '.'.join(l)


def mainpoint(function):
    """
    Decorator which declares a function to be an object's mainpoint.
    """
    if function.__module__ == '__main__':
        # OK time to run a function
        p = FilePath(__main__.__file__)
        p, mn = findPackagePath(p)
        pname = p.path
        if pname not in map(os.path.abspath, sys.path):
            sys.path.insert(0, pname)
            # Maybe remove the module's path?
        exitcode = namedAny(mn+'.'+function.__name__)(sys.argv)
        if exitcode is None:
            exitcode = 0
        sys.exit(exitcode)
    return function

########NEW FILE########
__FILENAME__ = python_procpool
"""
Python ProcPool

Evennia Contribution - Griatch 2012

The ProcPool is used to execute code on a separate process. This allows for
true asynchronous operation. Process communication happens over AMP and is
thus fully asynchronous as far as Evennia is concerned.

The process pool is implemented using a slightly modified version of
the Ampoule package (included).

The python_process pool is a service activated with the instructions
in python_procpool_plugin.py.

To use, import run_async from this module and use instead of the
in-process version found in src.utils.utils. Note that this is a much
more complex function than the default run_async, so make sure to read
the header carefully.

To test it works, make sure to activate the process pool, then try the
following as superuser:

@py from contrib.procpools.python_procpool import run_async;run_async("_return('Wohoo!')", at_return=self.msg, at_err=self.msg)

You can also try to import time and do time.sleep(5) before the
_return statement, to test it really is asynchronous.

"""

from twisted.protocols import amp
from twisted.internet import threads
from contrib.procpools.ampoule.child import AMPChild
from src.utils.dbserialize import to_pickle, from_pickle, do_pickle, do_unpickle
from src.utils.utils import clean_object_caches, to_str
from src.utils import logger
from src import PROC_MODIFIED_OBJS


#
# Multiprocess command for communication Server<->Client, relaying
# data for remote Python execution
#

class ExecuteCode(amp.Command):
    """
    Executes python code in the python process,
    returning result when ready.

    source - a compileable Python source code string
    environment - a pickled dictionary of Python
                  data. Each key will become the name
                  of a variable available to the source
                  code. Database objects are stored on
                  the form ((app, modelname), id) allowing
                  the receiver to easily rebuild them on
                  this side.
    errors - an all-encompassing error handler
    response - a string or a pickled string

    """
    arguments = [('source', amp.String()),
                 ('environment', amp.String())]
    errors = [(Exception, 'EXCEPTION')]
    response = [('response', amp.String()),
                ('recached', amp.String())]


#
# Multiprocess AMP client-side factory, for executing remote Python code
#

class PythonProcPoolChild(AMPChild):
    """
    This is describing what happens on the subprocess side.

    This already supports Echo, Shutdown and Ping.

    Methods:
    executecode - a remote code execution environment

    """
    def executecode(self, source, environment):
        """
        Remote code execution

        source - Python code snippet
        environment - pickled dictionary of environment
                      variables. They are stored in
                      two keys "normal" and "objs" where
                      normal holds a dictionary of
                      normally pickled python objects
                      wheras objs points to a dictionary
                      of database represenations ((app,key),id).

        The environment's entries will be made available as
        local variables during the execution. Normal eval
        results will be returned as-is. For more complex
        code snippets (run by exec), the _return function
        is available: All data sent to _return(retval) will
        be returned from this system whenever the system
        finishes. Multiple calls to _return will result in
        a list being return. The return value is pickled
        and thus allows for returning any pickleable data.

        """

        class Ret(object):
            "Helper class for holding returns from exec"
            def __init__(self):
                self.returns = []
            def __call__(self, *args, **kwargs):
                self.returns.extend(list(args))
            def get_returns(self):
                lr = len(self.returns)
                val = lr and (lr == 1 and self.returns[0] or self.returns) or None
                if val not in (None, [], ()):
                    return do_pickle(to_pickle(val))
                else:
                    return ""
        _return = Ret()

        available_vars = {'_return': _return}
        if environment:
            # load environment
            try:
                environment = from_pickle(do_unpickle(environment))
                available_vars.update(environment)
            except Exception:
                logger.log_trace()
        # try to execute with eval first
        try:
            ret = eval(source, {}, available_vars)
            if ret not in (None, [], ()):
                ret = _return.get_returns() or do_pickle(to_pickle(ret))
            else:
                ret = ""
        except Exception:
            # use exec instead
            exec source in available_vars
            ret = _return.get_returns()
        # get the list of affected objects to recache
        objs = list(set(PROC_MODIFIED_OBJS))
        # we need to include the locations too, to update their content caches
        objs = objs + list(set([o.location for o in objs
                                if hasattr(o, "location") and o.location]))
        #print "objs:", objs
        #print "to_pickle", to_pickle(objs, emptypickle=False, do_pickle=False)
        if objs not in (None, [], ()):
            to_recache = do_pickle(to_pickle(objs))
        else:
            to_recache = ""
        # empty the list without loosing memory reference
        PROC_MODIFIED_OBJS[:] = []
        return {'response': ret,
                'recached': to_recache}
    ExecuteCode.responder(executecode)


#
# Procpool run_async - Server-side access function for executing
# code in another process
#

_PPOOL = None
_SESSIONS = None
_PROC_ERR = "A process has ended with a probable error condition: process ended by signal 9."


def run_async(to_execute, *args, **kwargs):
    """
    Runs a function or executes a code snippet asynchronously.

    Inputs:
    to_execute (callable) - if this is a callable, it will
            be executed with *args and non-reserver *kwargs as
            arguments.
            The callable will be executed using ProcPool, or in
            a thread if ProcPool is not available.
    to_execute (string) - this is only available is ProcPool is
            running. If a string, to_execute this will be treated as a code
            snippet to execute asynchronously. *args are then not used
            and non-reserverd *kwargs are used to define the execution
            environment made available to the code.

    reserved kwargs:
        'use_thread' (bool) - this only works with callables (not code).
                     It forces the code to run in a thread instead
                     of using the Process Pool, even if the latter
                     is available. This could be useful if you want
                     to make sure to not get out of sync with the
                     main process (such as accessing in-memory global
                     properties)
        'proc_timeout' (int) - only used if ProcPool is available. Sets a
                     max time for execution. This alters the value set
                     by settings.PROCPOOL_TIMEOUT
        'at_return' -should point to a callable with one argument.
                    It will be called with the return value from
                    to_execute.
        'at_return_kwargs' - this dictionary which be used as keyword
                             arguments to the at_return callback.
        'at_err' - this will be called with a Failure instance if
                       there is an error in to_execute.
        'at_err_kwargs' - this dictionary will be used as keyword
                          arguments to the at_err errback.
        'procpool_name' - the Service name of the procpool to use.
                          Default is PythonProcPool.

    *args   - if to_execute is a callable, these args will be used
              as arguments for that function. If to_execute is a string
              *args are not used.
    *kwargs - if to_execute is a callable, these kwargs will be used
              as keyword arguments in that function. If a string, they
              instead are used to define the executable environment
              that should be available to execute the code in to_execute.

    run_async will either relay the code to a thread or to a processPool
    depending on input and what is available in the system. To activate
    Process pooling, settings.PROCPOOL_ENABLE must be set.

    to_execute in string form should handle all imports needed. kwargs
    can be used to send objects and properties. Such properties will
    be pickled, except Database Objects which will be sent across
    on a special format and re-loaded on the other side.

    To get a return value from your code snippet, Use the _return()
    function: Every call to this function from your snippet will
    append the argument to an internal list of returns. This return value
    (or a list) will be the first argument to the at_return callback.

    Use this function with restrain and only for features/commands
    that you know has no influence on the cause-and-effect order of your
    game (commands given after the async function might be executed before
    it has finished). Accessing the same property from different
    threads/processes can lead to unpredicted behaviour if you are not
    careful (this is called a "race condition").

    Also note that some databases, notably sqlite3, don't support access from
    multiple threads simultaneously, so if you do heavy database access from
    your to_execute under sqlite3 you will probably run very slow or even get
    tracebacks.

    """
    # handle all global imports.
    global _PPOOL, _SESSIONS

    # get the procpool name, if set in kwargs
    procpool_name = kwargs.get("procpool_name", "PythonProcPool")

    if _PPOOL is None:
        # Try to load process Pool
        from src.server.sessionhandler import SESSIONS as _SESSIONS
        try:
            _PPOOL = _SESSIONS.server.services.namedServices.get(procpool_name).pool
        except AttributeError:
            _PPOOL = False

    use_timeout = kwargs.pop("proc_timeout", _PPOOL.timeout)

    # helper converters for callbacks/errbacks
    def convert_return(f):
        def func(ret, *args, **kwargs):
            rval = ret["response"] and from_pickle(do_unpickle(ret["response"]))
            reca = ret["recached"] and from_pickle(do_unpickle(ret["recached"]))
            # recache all indicated objects
            [clean_object_caches(obj) for obj in reca]
            if f:
                return f(rval, *args, **kwargs)
            else:
                return rval
        return func
    def convert_err(f):
        def func(err, *args, **kwargs):
            err.trap(Exception)
            err = err.getErrorMessage()
            if use_timeout and err == _PROC_ERR:
                err = "Process took longer than %ss and timed out." % use_timeout
            if f:
                return f(err, *args, **kwargs)
            else:
                err = "Error reported from subprocess: '%s'" % err
                logger.log_errmsg(err)
        return func

    # handle special reserved input kwargs
    use_thread = kwargs.pop("use_thread", False)
    callback = convert_return(kwargs.pop("at_return", None))
    errback = convert_err(kwargs.pop("at_err", None))
    callback_kwargs = kwargs.pop("at_return_kwargs", {})
    errback_kwargs = kwargs.pop("at_err_kwargs", {})

    if _PPOOL and not use_thread:
        # process pool is running
        if isinstance(to_execute, basestring):
            # run source code in process pool
            cmdargs = {"_timeout": use_timeout}
            cmdargs["source"] = to_str(to_execute)
            if kwargs:
                cmdargs["environment"] = do_pickle(to_pickle(kwargs))
            else:
                cmdargs["environment"] = ""
            # defer to process pool
            deferred = _PPOOL.doWork(ExecuteCode, **cmdargs)
        elif callable(to_execute):
            # execute callable in process
            callname = to_execute.__name__
            cmdargs = {"_timeout": use_timeout}
            cmdargs["source"] = "_return(%s(*args,**kwargs))" % callname
            cmdargs["environment"] = do_pickle(to_pickle({callname: to_execute,
                                                         "args": args,
                                                         "kwargs": kwargs}))
            deferred = _PPOOL.doWork(ExecuteCode, **cmdargs)
        else:
            raise RuntimeError("'%s' could not be handled by the process pool" % to_execute)
    elif callable(to_execute):
        # no process pool available, fall back to old deferToThread mechanism.
        deferred = threads.deferToThread(to_execute, *args, **kwargs)
    else:
        # no appropriate input for this server setup
        raise RuntimeError("'%s' could not be handled by run_async - no valid input or no process pool." % to_execute)

    # attach callbacks
    if callback:
        deferred.addCallback(callback, **callback_kwargs)
    deferred.addErrback(errback, **errback_kwargs)

########NEW FILE########
__FILENAME__ = python_procpool_plugin
"""
Python ProcPool plugin

Evennia contribution - Griatch 2012

This is a plugin for the Evennia services. It will make the service
and run_async in python_procpool.py available to the system.

To activate, add the following line to your settings file:

SERVER_SERVICES_PLUGIN_MODULES.append("contrib.procpools.python_procpool_plugin")

Next reboot the server and the new service will be available.

If you want to adjust the defaults, copy this file to
game/gamesrc/conf/ and re-point
settings.SERVER_SERVICES_PLUGINS_MODULES to that file instead.  This
is to avoid clashes with eventual upstream modifications to this file.

It is not recommended to use this with an SQLite3 database, at least
if you plan to do many out-of-process database writes. SQLite3 does
not work very well with a high frequency of off-process writes due to
file locking clashes. Test what works with your mileage.

"""
import os
import sys
from django.conf import settings


# Process Pool setup

# convenient flag to turn off process pool without changing settings
PROCPOOL_ENABLED = True
# relay process stdout to log (debug mode, very spammy)
PROCPOOL_DEBUG = False
# max/min size of the process pool. Will expand up to max limit on demand.
PROCPOOL_MIN_NPROC = 5
PROCPOOL_MAX_NPROC = 20
# maximum time (seconds) a process may idle before being pruned from
# pool (if pool bigger than minsize)
PROCPOOL_IDLETIME = 20
# after sending a command, this is the maximum time in seconds the process
# may run without returning. After this time the process will be killed. This
# can be seen as a fallback; the run_async method takes a keyword proc_timeout
# that will override this value on a per-case basis.
PROCPOOL_TIMEOUT = 10
# only change if the port clashes with something else on the system
PROCPOOL_PORT = 5001
# 0.0.0.0 means listening to all interfaces
PROCPOOL_INTERFACE = '127.0.0.1'
# user-id and group-id to run the processes as (for OS:es supporting this).
# If you plan to run unsafe code one could experiment with setting this
# to an unprivileged user.
PROCPOOL_UID = None
PROCPOOL_GID = None
# real path to a directory where all processes will be run. If
# not given, processes will be executed in game/.
PROCPOOL_DIRECTORY = None


# don't need to change normally
SERVICE_NAME = "PythonProcPool"


# plugin hook

def start_plugin_services(server):
    """
    This will be called by the Evennia Server when starting up.

    server - the main Evennia server application
    """
    if not PROCPOOL_ENABLED:
        return

    # terminal output
    print '  amp (Process Pool): %s' % PROCPOOL_PORT

    from contrib.procpools.ampoule import main as ampoule_main
    from contrib.procpools.ampoule import service as ampoule_service
    from contrib.procpools.ampoule import pool as ampoule_pool
    from contrib.procpools.ampoule.main import BOOTSTRAP as _BOOTSTRAP
    from contrib.procpools.python_procpool import PythonProcPoolChild

    # for some reason absolute paths don't work here, only relative ones.
    apackages = ("twisted",
                 os.path.join(os.pardir, "contrib", "procpools", "ampoule"),
                 os.path.join(os.pardir, "ev"),
                 "settings")
    aenv = {"DJANGO_SETTINGS_MODULE": "settings",
            "DATABASE_NAME": settings.DATABASES.get("default", {}).get("NAME") or settings.DATABASE_NAME}
    if PROCPOOL_DEBUG:
        _BOOTSTRAP = _BOOTSTRAP % "log.startLogging(sys.stderr)"
    else:
        _BOOTSTRAP = _BOOTSTRAP % ""
    procpool_starter = ampoule_main.ProcessStarter(packages=apackages,
                                                   env=aenv,
                                                   path=PROCPOOL_DIRECTORY,
                                                   uid=PROCPOOL_UID,
                                                   gid=PROCPOOL_GID,
                                                   bootstrap=_BOOTSTRAP,
                                                   childReactor=sys.platform == 'linux2' and "epoll" or "default")
    procpool = ampoule_pool.ProcessPool(name=SERVICE_NAME,
                                        min=PROCPOOL_MIN_NPROC,
                                        max=PROCPOOL_MAX_NPROC,
                                        recycleAfter=500,
                                        timeout=PROCPOOL_TIMEOUT,
                                        maxIdle=PROCPOOL_IDLETIME,
                                        ampChild=PythonProcPoolChild,
                                        starter=procpool_starter)
    procpool_service = ampoule_service.AMPouleService(procpool,
                                                      PythonProcPoolChild,
                                                      PROCPOOL_PORT,
                                                      PROCPOOL_INTERFACE)
    procpool_service.setName(SERVICE_NAME)
    # add the new services to the server
    server.services.addService(procpool_service)




########NEW FILE########
__FILENAME__ = talking_npc
"""

Evennia Talkative NPC

Contribution - Griatch 2011

This is a simple NPC object capable of holding a
simple menu-driven conversation. Create it by
creating an object of typeclass contrib.talking_npc.TalkingNPC,
For example using @create:

 @create John : contrib.talking_npc.TalkingNPC

Walk up to it and give the talk command
to strike up a conversation. If there are many
talkative npcs in the same room you will get to
choose which one's talk command to call (Evennia
handles this automatically).

Note that this is only a prototype class, showcasing
the uses of the menusystem module. It is NOT a full
mob implementation.

"""

from ev import Object, CmdSet, default_cmds
from contrib import menusystem


#
# The talk command
#

class CmdTalk(default_cmds.MuxCommand):
    """
    talks to an npc

    Usage:
      talk

    This command is only available if a talkative non-player-character (NPC)
    is actually present. It will strike up a conversation with that NPC
    and give you options on what to talk about.
    """
    key = "talk"
    locks = "cmd:all()"
    help_category = "General"

    def func(self):
        "Implements the command."

        # self.obj is the NPC this is defined on
        obj = self.obj

        self.caller.msg("(You walk up and talk to %s.)" % self.obj.key)

        # conversation is a dictionary of keys, each pointing to
        # a dictionary defining the keyword arguments to the MenuNode
        # constructor.
        conversation = obj.db.conversation
        if not conversation:
            self.caller.msg("%s says: 'Sorry, I don't have time to talk right now.'" % (self.obj.key))
            return

        # build all nodes by loading them from the conversation tree.
        menu = menusystem.MenuTree(self.caller)
        for key, kwargs in conversation.items():
            menu.add(menusystem.MenuNode(key, **kwargs))
        menu.start()


class TalkingCmdSet(CmdSet):
    "Stores the talk command."
    key = "talkingcmdset"

    def at_cmdset_creation(self):
        "populates the cmdset"
        self.add(CmdTalk())

#
# Discussion tree. See contrib.menusystem.MenuNode for the keywords.
# (This could be in a separate module too)
#

CONV = {"START": {"text": "Hello there, how can I help you?",
                  "links": ["info1", "info2"],
                  "linktexts": ["Hey, do you know what this 'Evennia' thing is all about?",
                                "What's your name, little NPC?"],
                  "keywords": None,
                  "code": None},
        "info1": {"text": "Oh, Evennia is where you are right now! Don't you feel the power?",
                  "links": ["info3", "info2", "END"],
                  "linktexts":["Sure, *I* do, not sure how you do though. You are just an NPC.",
                              "Sure I do. What's yer name, NPC?",
                              "Ok, bye for now then."],
                 "keywords": None,
                 "code": None},
        "info2": {"text": "My name is not really important ... I'm just an NPC after all.",
                 "links": ["info3", "info1"],
                 "linktexts": ["I didn't really want to know it anyhow.",
                              "Okay then, so what's this 'Evennia' thing about?"],
                 "keywords": None,
                 "code": None},
        "info3": {"text": "Well ... I'm sort of busy so, have to go. NPC business. Important stuff. You wouldn't understand.",
                 "links": ["END", "info2"],
                 "linktexts": ["Oookay ... I won't keep you. Bye.",
                               "Wait, why don't you tell me your name first?"],
                 "keywords": None,
                 "code": None},
        }


class TalkingNPC(Object):
    """
    This implements a simple Object using the talk command and using the
    conversation defined above. .
    """

    def at_object_creation(self):
        "This is called when object is first created."
        # store the conversation.
        self.db.conversation = CONV
        self.db.desc = "This is a talkative NPC."
        # assign the talk command to npc
        self.cmdset.add_default(TalkingCmdSet, permanent=True)
########NEW FILE########
__FILENAME__ = mob
"""
This module implements a simple mobile object with
a very rudimentary AI as well as an aggressive enemy
object based on that mobile class.

"""

import random, time
from django.conf import settings

from ev import search_object, utils, Script
from contrib.tutorial_world import objects as tut_objects
from contrib.tutorial_world import scripts as tut_scripts

BASE_CHARACTER_TYPECLASS = settings.BASE_CHARACTER_TYPECLASS


#------------------------------------------------------------
#
# Mob - mobile object
#
# This object utilizes exits and moves about randomly from
# room to room.
#
#------------------------------------------------------------

class Mob(tut_objects.TutorialObject):
    """
    This type of mobile will roam from exit to exit at
    random intervals. Simply lock exits against the is_mob attribute
    to block them from the mob (lockstring = "traverse:not attr(is_mob)").
    """
    def at_object_creation(self):
        "This is called when the object is first created."
        self.db.tutorial_info = "This is a moving object. It moves randomly from room to room."

        self.scripts.add(tut_scripts.IrregularEvent)
        # this is a good attribute for exits to look for, to block
        # a mob from entering certain exits.
        self.db.is_mob = True
        self.db.last_location = None
        # only when True will the mob move.
        self.db.roam_mode = True

    def announce_move_from(self, destination):
        "Called just before moving"
        self.location.msg_contents("With a cold breeze, %s drifts in the direction of %s." % (self.key, destination.key))

    def announce_move_to(self, source_location):
        "Called just after arriving"
        self.location.msg_contents("With a wailing sound, %s appears from the %s." % (self.key, source_location.key))

    def update_irregular(self):
        "Called at irregular intervals. Moves the mob."
        if self.roam_mode:
            exits = [ex for ex in self.location.exits
                                    if ex.access(self, "traverse")]
            if exits:
                # Try to make it so the mob doesn't backtrack.
                new_exits = [ex for ex in exits
                                     if ex.destination != self.db.last_location]
                if new_exits:
                    exits = new_exits
                self.db.last_location = self.location
                # execute_cmd() allows the mob to respect exit and
                # exit-command locks, but may pose a problem if there is more
                # than one exit with the same name.
                # - see Enemy example for another way to move
                self.execute_cmd("%s" % exits[random.randint(0, len(exits) - 1)].key)


#------------------------------------------------------------
#
# Enemy - mobile attacking object
#
# An enemy is a mobile that is aggressive against players
# in its vicinity. An enemy will try to attack characters
# in the same location. It will also pursue enemies through
# exits if possible.
#
# An enemy needs to have a Weapon object in order to
# attack.
#
# This particular tutorial enemy is a ghostly apparition that can only
# be hurt by magical weapons. It will also not truly "die", but only
# teleport to another room. Players defeated by the apparition will
# conversely just be teleported to a holding room.
#
#------------------------------------------------------------

class AttackTimer(Script):
    """
    This script is what makes an eneny "tick".
    """
    def at_script_creation(self):
        "This sets up the script"
        self.key = "AttackTimer"
        self.desc = "Drives an Enemy's combat."
        self.interval = random.randint(2, 3) # how fast the Enemy acts
        self.start_delay = True # wait self.interval before first call
        self.persistent = True

    def at_repeat(self):
        "Called every self.interval seconds."
        if self.obj.db.inactive:
            return
        #print "attack timer: at_repeat", self.dbobj.id, self.ndb.twisted_task,
        # id(self.ndb.twisted_task)
        if self.obj.db.roam_mode:
            self.obj.roam()
            #return
        elif self.obj.db.battle_mode:
            #print "attack"
            self.obj.attack()
            return
        elif self.obj.db.pursue_mode:
            #print "pursue"
            self.obj.pursue()
            #return
        else:
            #dead mode. Wait for respawn.
            if not self.obj.db.dead_at:
                self.obj.db.dead_at = time.time()
            if (time.time() - self.obj.db.dead_at) > self.obj.db.dead_timer:
                self.obj.reset()


class Enemy(Mob):
    """
    This is a ghostly enemy with health (hit points). Their chance to hit,
    damage etc is determined by the weapon they are wielding, same as
    characters.

    An enemy can be in four modes:
       roam (inherited from Mob) - where it just moves around randomly
       battle - where it stands in one place and attacks players
       pursue - where it follows a player, trying to enter combat again
       dead - passive and invisible until it is respawned

    Upon creation, the following attributes describe the enemy's actions
      desc - description
      full_health - integer number > 0
      defeat_location - unique name or #dbref to the location the player is
                        taken when defeated. If not given, will remain in room.
      defeat_text - text to show player when they are defeated (just before
                    being whisped away to defeat_location)
      defeat_text_room - text to show other players in room when a player
                         is defeated
      win_text - text to show player when defeating the enemy
      win_text_room - text to show room when a player defeates the enemy
      respawn_text - text to echo to room when the mob is reset/respawn in
                     that room.

    """
    def at_object_creation(self):
        "Called at object creation."
        super(Enemy, self).at_object_creation()

        self.db.tutorial_info = "This moving object will attack players in the same room."

        # state machine modes
        self.db.roam_mode = True
        self.db.battle_mode = False
        self.db.pursue_mode = False
        self.db.dead_mode = False
        # health (change this at creation time)
        self.db.full_health = 20
        self.db.health = 20
        self.db.dead_at = time.time()
        self.db.dead_timer = 100 # how long to stay dead
        # this is used during creation to make sure the mob doesn't move away
        self.db.inactive = True
        # store the last player to hit
        self.db.last_attacker = None
        # where to take defeated enemies
        self.db.defeat_location = "darkcell"
        self.scripts.add(AttackTimer)

    def update_irregular(self):
        "the irregular event is inherited from Mob class"
        strings = self.db.irregular_echoes
        if strings:
            self.location.msg_contents(strings[random.randint(0, len(strings) - 1)])

    def roam(self):
        "Called by Attack timer. Will move randomly as long as exits are open."

        # in this mode, the mob is healed.
        self.db.health = self.db.full_health
        players = [obj for obj in self.location.contents
                   if utils.inherits_from(obj, BASE_CHARACTER_TYPECLASS) and not obj.is_superuser]
        if players:
            # we found players in the room. Attack.
            self.db.roam_mode = False
            self.db.pursue_mode = False
            self.db.battle_mode = True

        elif random.random() < 0.2:
            # no players to attack, move about randomly.
            exits = [ex.destination for ex in self.location.exits
                                                if ex.access(self, "traverse")]
            if exits:
                # Try to make it so the mob doesn't backtrack.
                new_exits = [ex for ex in exits
                                    if ex.destination != self.db.last_location]
                if new_exits:
                    exits = new_exits
                self.db.last_location = self.location
                # locks should be checked here
                self.move_to(exits[random.randint(0, len(exits) - 1)])
            else:
                # no exits - a dead end room. Respawn back to start.
                self.move_to(self.home)

    def attack(self):
        """
        This is the main mode of combat. It will try to hit players in
        the location. If players are defeated, it will whisp them off
        to the defeat location.
        """
        last_attacker = self.db.last_attacker
        players = [obj for obj in self.location.contents
                   if utils.inherits_from(obj, BASE_CHARACTER_TYPECLASS) and not obj.is_superuser]
        if players:

            # find a target
            if last_attacker in players:
                # prefer to attack the player last attacking.
                target = last_attacker
            else:
                # otherwise attack a random player in location
                target = players[random.randint(0, len(players) - 1)]

            # try to use the weapon in hand
            attack_cmds = ("thrust", "pierce", "stab", "slash", "chop")
            cmd = attack_cmds[random.randint(0, len(attack_cmds) - 1)]
            self.execute_cmd("%s %s" % (cmd, target))

            # analyze result.
            if target.db.health <= 0:
                # we reduced enemy to 0 health. Whisp them off to
                # the prison room.
                tloc = search_object(self.db.defeat_location)
                tstring = self.db.defeat_text
                if not tstring:
                    tstring = "You feel your conciousness slip away ... you fall to the ground as "
                    tstring += "the misty apparition envelopes you ...\n The world goes black ...\n"
                target.msg(tstring)
                ostring = self.db.defeat_text_room
                if tloc:
                    if not ostring:
                        ostring = "\n%s envelops the fallen ... and then their body is suddenly gone!" % self.key
                        # silently move the player to defeat location
                        # (we need to call hook manually)
                    target.location = tloc[0]
                    tloc[0].at_object_receive(target, self.location)
                elif not ostring:
                    ostring = "%s falls to the ground!" % target.key
                self.location.msg_contents(ostring, exclude=[target])
                # Pursue any stragglers after the battle
                self.battle_mode = False
                self.roam_mode = False
                self.pursue_mode = True
        else:
            # no players found, this could mean they have fled.
            # Switch to pursue mode.
            self.battle_mode = False
            self.roam_mode = False
            self.pursue_mode = True

    def pursue(self):
        """
        In pursue mode, the enemy tries to find players in adjoining rooms, preferably
        those that previously attacked it.
        """
        last_attacker = self.db.last_attacker
        players = [obj for obj in self.location.contents if utils.inherits_from(obj, BASE_CHARACTER_TYPECLASS) and not obj.is_superuser]
        if players:
            # we found players in the room. Maybe we caught up with some,
            # or some walked in on us before we had time to pursue them.
            # Switch to battle mode.
            self.battle_mode = True
            self.roam_mode = False
            self.pursue_mode = False
        else:
            # find all possible destinations.
            destinations = [ex.destination for ex in self.location.exits
                                                if ex.access(self, "traverse")]
            # find all players in the possible destinations. OBS-we cannot
            # just use the player's current position to move the Enemy; this
            # might have changed when the move is performed, causing the enemy
            # to teleport out of bounds.
            players = {}
            for dest in destinations:
                for obj in [o for o in dest.contents
                           if utils.inherits_from(o, BASE_CHARACTER_TYPECLASS)]:
                    players[obj] = dest
            if players:
                # we found targets. Move to intercept.
                if last_attacker in players:
                    # preferably the one that last attacked us
                    self.move_to(players[last_attacker])
                else:
                    # otherwise randomly.
                    key = players.keys()[random.randint(0, len(players) - 1)]
                    self.move_to(players[key])
            else:
                # we found no players nearby. Return to roam mode.
                self.battle_mode = False
                self.roam_mode = True
                self.pursue_mode = False

    def at_hit(self, weapon, attacker, damage):
        """
        Called when this object is hit by an enemy's weapon
        Should return True if enemy is defeated, False otherwise.

        In the case of players attacking, we handle all the events
        and information from here, so the return value is not used.
        """

        self.db.last_attacker = attacker
        if not self.db.battle_mode:
            # we were attacked, so switch to battle mode.
            self.db.roam_mode = False
            self.db.pursue_mode = False
            self.db.battle_mode = True
            #self.scripts.add(AttackTimer)

        if not weapon.db.magic:
            # In the tutorial, the enemy is a ghostly apparition, so
            # only magical weapons can harm it.
            string = self.db.weapon_ineffective_text
            if not string:
                string = "Your weapon just passes through your enemy, causing no effect!"
            attacker.msg(string)
            return
        else:
            # an actual hit
            health = float(self.db.health)
            health -= damage
            self.db.health = health
            if health <= 0:
                string = self.db.win_text
                if not string:
                    string = "After your last hit, %s folds in on itself, it seems to fade away into nothingness. " % self.key
                    string += "In a moment there is nothing left but the echoes of its screams. But you have a "
                    string += "feeling it is only temporarily weakened. "
                    string += "You fear it's only a matter of time before it materializes somewhere again."
                attacker.msg(string)
                string = self.db.win_text_room
                if not string:
                    string = "After %s's last hit, %s folds in on itself, it seems to fade away into nothingness. " % (attacker.name, self.key)
                    string += "In a moment there is nothing left but the echoes of its screams. But you have a "
                    string += "feeling it is only temporarily weakened. "
                    string += "You fear it's only a matter of time before it materializes somewhere again."
                self.location.msg_contents(string, exclude=[attacker])

                # put mob in dead mode and hide it from view.
                # AttackTimer will bring it back later.
                self.db.dead_at = time.time()
                self.db.roam_mode = False
                self.db.pursue_mode = False
                self.db.battle_mode = False
                self.db.dead_mode = True
                self.location = None
            else:
                self.location.msg_contents("%s wails, shudders and writhes." % self.key)
        return False

    def reset(self):
        """
        If the mob was 'dead', respawn it to its home position and reset
        all modes and damage."""
        if self.db.dead_mode:
            self.db.health = self.db.full_health
            self.db.roam_mode = True
            self.db.pursue_mode = False
            self.db.battle_mode = False
            self.db.dead_mode = False
            self.location = self.home
            string = self.db.respawn_text
            if not string:
                string = "%s fades into existence from out of thin air. It's looking pissed." % self.key
                self.location.msg_contents(string)
########NEW FILE########
__FILENAME__ = objects
"""
TutorialWorld - basic objects - Griatch 2011

This module holds all "dead" object definitions for
the tutorial world. Object-commands and -cmdsets
are also defined here, together with the object.

Objects:

TutorialObject

Readable
Climbable
Obelisk
LightSource
CrumblingWall
Weapon
WeaponRack

"""

import time
import random

from ev import create_object
from ev import Object, Exit, Command, CmdSet, Script

#------------------------------------------------------------
#
# TutorialObject
#
# The TutorialObject is the base class for all items
# in the tutorial. They have an attribute "tutorial_info"
# on them that a global tutorial command can use to extract
# interesting behind-the scenes information about the object.
#
# TutorialObjects may also be "reset". What the reset means
# is up to the object. It can be the resetting of the world
# itself, or the removal of an inventory item from a
# character's inventory when leaving the tutorial, for example.
#
#------------------------------------------------------------


class TutorialObject(Object):
    """
    This is the baseclass for all objects in the tutorial.
    """

    def at_object_creation(self):
        "Called when the object is first created."
        super(TutorialObject, self).at_object_creation()
        self.db.tutorial_info = "No tutorial info is available for this object."
        #self.db.last_reset = time.time()

    def reset(self):
        "Resets the object, whatever that may mean."
        self.location = self.home


#------------------------------------------------------------
#
# Readable - an object one can "read".
#
#------------------------------------------------------------

class CmdRead(Command):
    """
    Usage:
      read [obj]

    Read some text.
    """

    key = "read"
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "Implement the read command."
        if self.args:
            obj = self.caller.search(self.args.strip())
        else:
            obj = self.obj
        if not obj:
            return
        # we want an attribute read_text to be defined.
        readtext = obj.db.readable_text
        if readtext:
            string = "You read {C%s{n:\n  %s" % (obj.key, readtext)
        else:
            string = "There is nothing to read on %s." % obj.key
        self.caller.msg(string)


class CmdSetReadable(CmdSet):
    "CmdSet for readables"
    def at_cmdset_creation(self):
        "called when object is created."
        self.add(CmdRead())


class Readable(TutorialObject):
    """
    This object defines some attributes and defines a read method on itself.
    """
    def at_object_creation(self):
        "Called when object is created"
        super(Readable, self).at_object_creation()
        self.db.tutorial_info = "This is an object with a 'read' command defined in a command set on itself."
        self.db.readable_text = "There is no text written on %s." % self.key
        # define a command on the object.
        self.cmdset.add_default(CmdSetReadable, permanent=True)


#------------------------------------------------------------
#
# Climbable object
#
# The climbable object works so that once climbed, it sets
# a flag on the climber to show that it was climbed. A simple
# command 'climb' handles the actual climbing.
#
#------------------------------------------------------------

class CmdClimb(Command):
    """
    Usage:
      climb <object>
    """
    key = "climb"
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "Implements function"

        if not self.args:
            self.caller.msg("What do you want to climb?")
            return
        obj = self.caller.search(self.args.strip())
        if not obj:
            return
        if obj != self.obj:
            self.caller.msg("Try as you might, you cannot climb that.")
            return
        ostring = self.obj.db.climb_text
        if not ostring:
            ostring = "You climb %s. Having looked around, you climb down again." % self.obj.name
        self.caller.msg(ostring)
        self.caller.db.last_climbed = self.obj


class CmdSetClimbable(CmdSet):
    "Climbing cmdset"
    def at_cmdset_creation(self):
        "populate set"
        self.add(CmdClimb())


class Climbable(TutorialObject):
    "A climbable object."

    def at_object_creation(self):
        "Called at initial creation only"
        self.cmdset.add_default(CmdSetClimbable, permanent=True)



#------------------------------------------------------------
#
# Obelisk - a unique item
#
# The Obelisk is an object with a modified return_appearance
# method that causes it to look slightly different every
# time one looks at it. Since what you actually see
# is a part of a game puzzle, the act of looking also
# stores a key attribute on the looking object for later
# reference.
#
#------------------------------------------------------------

OBELISK_DESCS = ["You can briefly make out the image of {ba woman with a blue bird{n.",
                 "You for a moment see the visage of {ba woman on a horse{n.",
                 "For the briefest moment you make out an engraving of {ba regal woman wearing a crown{n.",
                 "You think you can see the outline of {ba flaming shield{n in the stone.",
                 "The surface for a moment seems to portray {ba woman fighting a beast{n."]


class Obelisk(TutorialObject):
    """
    This object changes its description randomly.
    """

    def at_object_creation(self):
        "Called when object is created."
        super(Obelisk, self).at_object_creation()
        self.db.tutorial_info = "This object changes its desc randomly, and makes sure to remember which one you saw."
        # make sure this can never be picked up
        self.locks.add("get:false()")

    def return_appearance(self, caller):
        "Overload the default version of this hook."
        clueindex = random.randint(0, len(OBELISK_DESCS) - 1)
        # set this description
        string = "The surface of the obelisk seem to waver, shift and writhe under your gaze, with "
        string += "different scenes and structures appearing whenever you look at it. "
        self.db.desc = string + OBELISK_DESCS[clueindex]
        # remember that this was the clue we got.
        caller.db.puzzle_clue = clueindex
        # call the parent function as normal (this will use db.desc we just set)
        return super(Obelisk, self).return_appearance(caller)


#------------------------------------------------------------
#
# LightSource
#
# This object that emits light and can be
# turned on or off. It must be carried to use and has only
# a limited burn-time.
# When burned out, it will remove itself from the carrying
# character's inventory.
#
#------------------------------------------------------------

class StateLightSourceOn(Script):
    """
    This script controls how long the light source is burning. When
    it runs out of fuel, the lightsource goes out.
    """
    def at_script_creation(self):
        "Called at creation of script."
        self.key = "lightsourceBurn"
        self.desc = "Keeps lightsources burning."
        self.start_delay = True # only fire after self.interval s.
        self.repeats = 1 # only run once.
        self.persistent = True  # survive a server reboot.

    def at_start(self):
        "Called at script start - this can also happen if server is restarted."
        self.interval = self.obj.db.burntime
        self.db.script_started = time.time()

    def at_repeat(self):
        "Called at self.interval seconds"
        # this is only called when torch has burnt out
        self.obj.db.burntime = -1
        self.obj.reset()

    def at_stop(self):
        """
        Since the user may also turn off the light
        prematurely, this hook will store the current
        burntime.
        """
        # calculate remaining burntime, if object is not
        # already deleted (because it burned out)
        if self.obj:
            try:
                time_burnt = time.time() - self.db.script_started
            except TypeError:
                # can happen if script_started is not defined
                time_burnt = self.interval
            burntime = self.interval - time_burnt
            self.obj.db.burntime = burntime

    def is_valid(self):
        "This script is only valid as long as the lightsource burns."
        return self.obj.db.is_active


class CmdLightSourceOn(Command):
    """
    Switches on the lightsource.
    """
    key = "on"
    aliases = ["switch on", "turn on", "light"]
    locks = "cmd:holds()"  # only allow if command.obj is carried by caller.
    help_category = "TutorialWorld"

    def func(self):
        "Implements the command"

        if self.obj.db.is_active:
            self.caller.msg("%s is already burning." % self.obj.key)
        else:
            # set lightsource to active
            self.obj.db.is_active = True
            # activate the script to track burn-time.
            self.obj.scripts.add(StateLightSourceOn)
            self.caller.msg("{gYou light {C%s.{n" % self.obj.key)
            self.caller.location.msg_contents("%s lights %s!" % (self.caller, self.obj.key), exclude=[self.caller])
            # run script validation on the room to make light/dark states tick.
            self.caller.location.scripts.validate()
            # look around
            self.caller.execute_cmd("look")


class CmdLightSourceOff(Command):
    """
    Switch off the lightsource.
    """
    key = "off"
    aliases = ["switch off", "turn off", "dowse"]
    locks = "cmd:holds()"  # only allow if command.obj is carried by caller.
    help_category = "TutorialWorld"

    def func(self):
        "Implements the command "

        if not self.obj.db.is_active:
            self.caller.msg("%s is not burning." % self.obj.key)
        else:
            # set lightsource to inactive
            self.obj.db.is_active = False
            # validating the scripts will kill it now that is_active=False.
            self.obj.scripts.validate()
            self.caller.msg("{GYou dowse {C%s.{n" % self.obj.key)
            self.caller.location.msg_contents("%s dowses %s." % (self.caller, self.obj.key), exclude=[self.caller])
            self.caller.location.scripts.validate()
            self.caller.execute_cmd("look")


class CmdSetLightSource(CmdSet):
    "CmdSet for the lightsource commands"
    key = "lightsource_cmdset"

    def at_cmdset_creation(self):
        "called at cmdset creation"
        self.add(CmdLightSourceOn())
        self.add(CmdLightSourceOff())


class LightSource(TutorialObject):
    """
    This implements a light source object.

    When burned out, lightsource will be moved to its home - which by
    default is the location it was first created at.
    """
    def at_object_creation(self):
        "Called when object is first created."
        super(LightSource, self).at_object_creation()
        self.db.tutorial_info = "This object can be turned on off and has a timed script controlling it."
        self.db.is_active = False
        self.db.burntime = 60 * 3  # 3 minutes
        self.db.desc = "A splinter of wood with remnants of resin on it, enough for burning."
        # add commands
        self.cmdset.add_default(CmdSetLightSource, permanent=True)

    def reset(self):
        """
        Can be called by tutorial world runner, or by the script when
        the lightsource has burned out.
        """
        if self.db.burntime <= 0:
            # light burned out. Since the lightsources's "location" should be
            # a character, notify them this way.
            try:
                loc = self.location.location
            except AttributeError:
                loc = self.location
            loc.msg_contents("{c%s{n {Rburns out.{n" % self.key)
        self.db.is_active = False
        try:
            # validate in holders current room, if possible
            self.location.location.scripts.validate()
        except AttributeError:
            # maybe it was dropped, try validating at current location.
            try:
                self.location.scripts.validate()
            except AttributeError:
                pass
        self.delete()


#------------------------------------------------------------
#
# Crumbling wall - unique exit
#
# This implements a simple puzzle exit that needs to be
# accessed with commands before one can get to traverse it.
#
# The puzzle is currently simply to move roots (that have
# presumably covered the wall) aside until a button for a
# secret door is revealed. The original position of the
# roots blocks the button, so they have to be moved to a certain
# position - when they have, the "press button" command
# is made available and the Exit is made traversable.
#
#------------------------------------------------------------

# There are four roots - two horizontal and two vertically
# running roots. Each can have three positions: top/middle/bottom
# and left/middle/right respectively. There can be any number of
# roots hanging through the middle position, but only one each
# along the sides. The goal is to make the center position clear.
# (yes, it's really as simple as it sounds, just move the roots
# to each side to "win". This is just a tutorial, remember?)

class CmdShiftRoot(Command):
    """
    Shifts roots around.

    shift blue root left/right
    shift red root left/right
    shift yellow root up/down
    shift green root up/down

    """
    key = "shift"
    aliases = ["move"]
    # the locattr() lock looks for the attribute is_dark on the current room.
    locks = "cmd:not locattr(is_dark)"
    help_category = "TutorialWorld"

    def parse(self):
        "custom parser; split input by spaces"
        self.arglist = self.args.strip().split()

    def func(self):
        """
        Implement the command.
          blue/red - vertical roots
          yellow/green - horizontal roots
        """

        if not self.arglist:
            self.caller.msg("What do you want to move, and in what direction?")
            return
        if "root" in self.arglist:
            self.arglist.remove("root")
        # we accept arguments on the form <color> <direction>
        if not len(self.arglist) > 1:
            self.caller.msg("You must define which colour of root you want to move, and in which direction.")
            return
        color = self.arglist[0].lower()
        direction = self.arglist[1].lower()
        # get current root positions dict
        root_pos = self.obj.db.root_pos

        if not color in root_pos:
            self.caller.msg("No such root to move.")
            return

        # first, vertical roots (red/blue) - can be moved left/right
        if color == "red":
            if direction == "left":
                root_pos[color] = max(-1, root_pos[color] - 1)
                self.caller.msg("You shift the reddish root to the left.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["blue"]:
                    root_pos["blue"] += 1
                    self.caller.msg("The root with blue flowers gets in the way and is pushed to the right.")
            elif direction == "right":
                root_pos[color] = min(1, root_pos[color] + 1)
                self.caller.msg("You shove the reddish root to the right.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["blue"]:
                    root_pos["blue"] -= 1
                    self.caller.msg("The root with blue flowers gets in the way and is pushed to the left.")
            else:
                self.caller.msg("You cannot move the root in that direction.")
        elif color == "blue":
            if direction == "left":
                root_pos[color] = max(-1, root_pos[color] - 1)
                self.caller.msg("You shift the root with small blue flowers to the left.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["red"]:
                    root_pos["red"] += 1
                    self.caller.msg("The reddish root is to big to fit as well, so that one falls away to the left.")
            elif direction == "right":
                root_pos[color] = min(1, root_pos[color] + 1)
                self.caller.msg("You shove the root adorned with small blue flowers to the right.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["red"]:
                    root_pos["red"] -= 1
                    self.caller.msg("The thick reddish root gets in the way and is pushed back to the left.")
            else:
                self.caller.msg("You cannot move the root in that direction.")
        # now the horizontal roots (yellow/green). They can be moved up/down
        elif color == "yellow":
            if direction == "up":
                root_pos[color] = max(-1, root_pos[color] - 1)
                self.caller.msg("You shift the root with small yellow flowers upwards.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["green"]:
                    root_pos["green"] += 1
                    self.caller.msg("The green weedy root falls down.")
            elif direction == "down":
                root_pos[color] = min(1, root_pos[color] + 1)
                self.caller.msg("You shove the root adorned with small yellow flowers downwards.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["green"]:
                    root_pos["green"] -= 1
                    self.caller.msg("The weedy green root is shifted upwards to make room.")
            else:
                self.caller.msg("You cannot move the root in that direction.")
        elif color == "green":
            if direction == "up":
                root_pos[color] = max(-1, root_pos[color] - 1)
                self.caller.msg("You shift the weedy green root upwards.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["yellow"]:
                    root_pos["yellow"] += 1
                    self.caller.msg("The root with yellow flowers falls down.")
            elif direction == "down":
                root_pos[color] = min(1, root_pos[color] + 1)
                self.caller.msg("You shove the weedy green root downwards.")
                if root_pos[color] != 0 and root_pos[color] == root_pos["yellow"]:
                    root_pos["yellow"] -= 1
                    self.caller.msg("The root with yellow flowers gets in the way and is pushed upwards.")
            else:
                self.caller.msg("You cannot move the root in that direction.")
        # store new position
        self.obj.db.root_pos = root_pos
        # check victory condition
        if root_pos.values().count(0) == 0: # no roots in middle position
            self.caller.db.crumbling_wall_found_button = True
            self.caller.msg("Holding aside the root you think you notice something behind it ...")


class CmdPressButton(Command):
    """
    Presses a button.
    """
    key = "press"
    aliases = ["press button", "button", "push", "push button"]
    # only accessible if the button was found and there is light.
    locks = "cmd:attr(crumbling_wall_found_button) and not locattr(is_dark)"
    help_category = "TutorialWorld"

    def func(self):
        "Implements the command"

        if self.caller.db.crumbling_wall_found_exit:
            # we already pushed the button
            self.caller.msg("The button folded away when the secret passage opened. You cannot push it again.")
            return

        # pushing the button
        string = "You move your fingers over the suspicious depression, then gives it a "
        string += "decisive push. First nothing happens, then there is a rumble and a hidden "
        string += "{wpassage{n opens, dust and pebbles rumbling as part of the wall moves aside."

        # we are done - this will make the exit traversable!
        self.caller.db.crumbling_wall_found_exit = True
        # this will make it into a proper exit
        eloc = self.caller.search(self.obj.db.destination, global_search=True)
        if not eloc:
            self.caller.msg("The exit leads nowhere, there's just more stone behind it ...")
            return
        self.obj.destination = eloc
        self.caller.msg(string)


class CmdSetCrumblingWall(CmdSet):
    "Group the commands for crumblingWall"
    key = "crumblingwall_cmdset"

    def at_cmdset_creation(self):
        "called when object is first created."
        self.add(CmdShiftRoot())
        self.add(CmdPressButton())


class CrumblingWall(TutorialObject, Exit):
    """
    The CrumblingWall can be examined in various
    ways, but only if a lit light source is in the room. The traversal
    itself is blocked by a traverse: lock on the exit that only
    allows passage if a certain attribute is set on the trying
    player.

    Important attribute
     destination - this property must be set to make this a valid exit
                   whenever the button is pushed (this hides it as an exit
                   until it actually is)
    """
    def at_object_creation(self):
        "called when the object is first created."
        super(CrumblingWall, self).at_object_creation()

        self.aliases.add(["secret passage", "passage",
                          "crack", "opening", "secret door"])
        # this is assigned first when pushing button, so assign
        # this at creation time!

        self.db.destination = 2
        # locks on the object directly transfer to the exit "command"
        self.locks.add("cmd:not locattr(is_dark)")

        self.db.tutorial_info = "This is an Exit with a conditional traverse-lock. Try to shift the roots around."
        # the lock is important for this exit; we only allow passage
        # if we "found exit".
        self.locks.add("traverse:attr(crumbling_wall_found_exit)")
        # set cmdset
        self.cmdset.add(CmdSetCrumblingWall, permanent=True)

        # starting root positions. H1/H2 are the horizontally hanging roots,
        # V1/V2 the vertically hanging ones. Each can have three positions:
        # (-1, 0, 1) where 0 means the middle position. yellow/green are
        # horizontal roots and red/blue vertical, all may have value 0, but n
        # ever any other identical value.
        self.db.root_pos = {"yellow": 0, "green": 0, "red": 0, "blue": 0}

    def _translate_position(self, root, ipos):
        "Translates the position into words"
        rootnames = {"red": "The {rreddish{n vertical-hanging root ",
                     "blue": "The thick vertical root with {bblue{n flowers ",
                     "yellow": "The thin horizontal-hanging root with {yyellow{n flowers ",
                     "green": "The weedy {ggreen{n horizontal root "}
        vpos = {-1: "hangs far to the {wleft{n on the wall.",
                 0: "hangs straight down the {wmiddle{n of the wall.",
                 1: "hangs far to the {wright{n of the wall."}
        hpos = {-1: "covers the {wupper{n part of the wall.",
                 0: "passes right over the {wmiddle{n of the wall.",
                 1: "nearly touches the floor, near the {wbottom{n of the wall."}

        if root in ("yellow", "green"):
            string = rootnames[root] + hpos[ipos]
        else:
            string = rootnames[root] + vpos[ipos]
        return string

    def return_appearance(self, caller):
        """
        This is called when someone looks at the wall. We need to echo the
        current root positions.
        """
        if caller.db.crumbling_wall_found_button:
            string = "Having moved all the roots aside, you find that the center of the wall, "
            string += "previously hidden by the vegetation, hid a curious square depression. It was maybe once "
            string += "concealed and made to look a part of the wall, but with the crumbling of stone around it,"
            string += "it's now easily identifiable as some sort of button."
        else:
            string =  "The wall is old and covered with roots that here and there have permeated the stone. "
            string += "The roots (or whatever they are - some of them are covered in small non-descript flowers) "
            string += "crisscross the wall, making it hard to clearly see its stony surface.\n"
            for key, pos in self.db.root_pos.items():
                string += "\n" + self._translate_position(key, pos)
        self.db.desc = string
        # call the parent to continue execution (will use desc we just set)
        return super(CrumblingWall, self).return_appearance(caller)

    def at_after_traverse(self, traverser, source_location):
        """
        This is called after we traversed this exit. Cleans up and resets
        the puzzle.
        """
        del traverser.db.crumbling_wall_found_button
        del traverser.db.crumbling_wall_found_exit
        self.reset()

    def at_failed_traverse(self, traverser):
        "This is called if the player fails to pass the Exit."
        traverser.msg("No matter how you try, you cannot force yourself through %s." % self.key)

    def reset(self):
        """
        Called by tutorial world runner, or whenever someone successfully
        traversed the Exit.
        """
        self.location.msg_contents("The secret door closes abruptly, roots falling back into place.")
        for obj in self.location.contents:
            # clear eventual puzzle-solved attribues on everyone that didn't
            # get out in time. They have to try again.
            del obj.db.crumbling_wall_found_exit

        # Reset the roots with some random starting positions for the roots:
        start_pos = [{"yellow":1, "green":0, "red":0, "blue":0},
                     {"yellow":0, "green":0, "red":0, "blue":0},
                     {"yellow":0, "green":1, "red":-1, "blue":0},
                     {"yellow":1, "green":0, "red":0, "blue":0},
                     {"yellow":0, "green":0, "red":0, "blue":1}]
        self.db.root_pos = start_pos[random.randint(0, 4)]
        self.destination = None


#------------------------------------------------------------
#
# Weapon - object type
#
# A weapon is necessary in order to fight in the tutorial
# world. A weapon (which here is assumed to be a bladed
# melee weapon for close combat) has three commands,
# stab, slash and defend. Weapons also have a property "magic"
# to determine if they are usable against certain enemies.
#
# Since Characters don't have special skills in the tutorial,
# we let the weapon itself determine how easy/hard it is
# to hit with it, and how much damage it can do.
#
#------------------------------------------------------------

class CmdAttack(Command):
    """
    Attack the enemy. Commands:

      stab <enemy>
      slash <enemy>
      parry

    stab - (thrust) makes a lot of damage but is harder to hit with.
    slash - is easier to land, but does not make as much damage.
    parry - forgoes your attack but will make you harder to hit on next
            enemy attack.

    """

    # this is an example of implementing many commands as a single
    # command class, using the given command alias to separate between them.

    key = "attack"
    aliases = ["hit","kill", "fight", "thrust", "pierce", "stab",
               "slash", "chop", "parry", "defend"]
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "Implements the stab"

        cmdstring = self.cmdstring

        if cmdstring in ("attack", "fight"):
            string = "How do you want to fight? Choose one of 'stab', 'slash' or 'defend'."
            self.caller.msg(string)
            return

        # parry mode
        if cmdstring in ("parry", "defend"):
            string = "You raise your weapon in a defensive pose, ready to block the next enemy attack."
            self.caller.msg(string)
            self.caller.db.combat_parry_mode = True
            self.caller.location.msg_contents("%s takes a defensive stance" % self.caller, exclude=[self.caller])
            return

        if not self.args:
            self.caller.msg("Who do you attack?")
            return
        target = self.caller.search(self.args.strip())
        if not target:
            return

        string = ""
        tstring = ""
        ostring = ""
        if cmdstring in ("thrust", "pierce", "stab"):
            hit = float(self.obj.db.hit) * 0.7  # modified due to stab
            damage = self.obj.db.damage * 2  # modified due to stab
            string = "You stab with %s. " % self.obj.key
            tstring = "%s stabs at you with %s. " % (self.caller.key, self.obj.key)
            ostring = "%s stabs at %s with %s. " % (self.caller.key, target.key, self.obj.key)
            self.caller.db.combat_parry_mode = False
        elif cmdstring in ("slash", "chop"):
            hit = float(self.obj.db.hit)   # un modified due to slash
            damage = self.obj.db.damage  # un modified due to slash
            string = "You slash with %s. " % self.obj.key
            tstring = "%s slash at you with %s. " % (self.caller.key, self.obj.key)
            ostring = "%s slash at %s with %s. " % (self.caller.key, target.key, self.obj.key)
            self.caller.db.combat_parry_mode = False
        else:
            self.caller.msg("You fumble with your weapon, unsure of whether to stab, slash or parry ...")
            self.caller.location.msg_contents("%s fumbles with their weapon." % self.obj.key)
            self.caller.db.combat_parry_mode = False
            return

        if target.db.combat_parry_mode:
            # target is defensive; even harder to hit!
            target.msg("{GYou defend, trying to avoid the attack.{n")
            hit *= 0.5

        if random.random() <= hit:
            self.caller.msg(string + "{gIt's a hit!{n")
            target.msg(tstring + "{rIt's a hit!{n")
            self.caller.location.msg_contents(ostring + "It's a hit!", exclude=[target,self.caller])

            # call enemy hook
            if hasattr(target, "at_hit"):
                # should return True if target is defeated, False otherwise.
                return target.at_hit(self.obj, self.caller, damage)
            elif target.db.health:
                target.db.health -= damage
            else:
                # sorry, impossible to fight this enemy ...
                self.caller.msg("The enemy seems unaffacted.")
                return False
        else:
            self.caller.msg(string + "{rYou miss.{n")
            target.msg(tstring + "{gThey miss you.{n")
            self.caller.location.msg_contents(ostring + "They miss.", exclude=[target, self.caller])


class CmdSetWeapon(CmdSet):
    "Holds the attack command."
    def at_cmdset_creation(self):
        "called at first object creation."
        self.add(CmdAttack())


class Weapon(TutorialObject):
    """
    This defines a bladed weapon.

    Important attributes (set at creation):
      hit - chance to hit (0-1)
      parry - chance to parry (0-1)
      damage - base damage given (modified by hit success and
               type of attack) (0-10)

    """
    def at_object_creation(self):
        "Called at first creation of the object"
        super(Weapon, self).at_object_creation()
        self.db.hit = 0.4    # hit chance
        self.db.parry = 0.8  # parry chance
        self.db.damage = 8.0
        self.db.magic = False
        self.cmdset.add_default(CmdSetWeapon, permanent=True)

    def reset(self):
        """
        When reset, the weapon is simply deleted, unless it has a place
        to return to.
        """
        if self.location.has_player and self.home == self.location:
            self.location.msg_contents("%s suddenly and magically fades into nothingness, as if it was never there ..." % self.key)
            self.delete()
        else:
            self.location = self.home


#------------------------------------------------------------
#
# Weapon rack - spawns weapons
#
#------------------------------------------------------------

class CmdGetWeapon(Command):
    """
    Usage:
      get weapon

    This will try to obtain a weapon from the container.
    """
    key = "get"
    aliases = "get weapon"
    locks = "cmd:all()"
    help_cateogory = "TutorialWorld"

    def func(self):
        "Implement the command"

        rack_id = self.obj.db.rack_id
        if self.caller.attributes.get(rack_id):
            # we don't allow a player to take more than one weapon from rack.
            self.caller.msg("%s has no more to offer you." % self.obj.name)
        else:
            dmg, name, aliases, desc, magic = self.obj.randomize_type()
            new_weapon = create_object(Weapon, key=name, aliases=aliases,location=self.caller, home=self.caller)
            new_weapon.db.rack_id = rack_id
            new_weapon.db.damage = dmg
            new_weapon.db.desc = desc
            new_weapon.db.magic = magic
            ostring = self.obj.db.get_text
            if not ostring:
                ostring = "You pick up %s."
            if '%s' in ostring:
                self.caller.msg(ostring % name)
            else:
                self.caller.msg(ostring)
            # tag the caller so they cannot keep taking objects from the rack.
            self.caller.attributes.add(rack_id, True)


class CmdSetWeaponRack(CmdSet):
    "group the rack cmd"
    key = "weaponrack_cmdset"
    mergemode = "Replace"

    def at_cmdset_creation(self):
        "Called at first creation of cmdset"
        self.add(CmdGetWeapon())


class WeaponRack(TutorialObject):
    """
    This will spawn a new weapon for the player unless the player already has
    one from this rack.

    attribute to set at creation:
    min_dmg  - the minimum damage of objects from this rack
    max_dmg - the maximum damage of objects from this rack
    magic - if weapons should be magical (have the magic flag set)
    get_text - the echo text to return when getting the weapon. Give '%s'
               to include the name of the weapon.
    """
    def at_object_creation(self):
        "called at creation"
        self.cmdset.add_default(CmdSetWeaponRack, permanent=True)
        self.db.rack_id = "weaponrack_1"
        self.db.min_dmg = 1.0
        self.db.max_dmg = 4.0
        self.db.magic = False

    def randomize_type(self):
        """
        this returns a random weapon
        """
        min_dmg = float(self.db.min_dmg)
        max_dmg = float(self.db.max_dmg)
        magic = bool(self.db.magic)
        dmg = min_dmg + random.random()*(max_dmg - min_dmg)
        aliases = [self.db.rack_id, "weapon"]
        if dmg < 1.5:
            name = "Knife"
            desc = "A rusty kitchen knife. Better than nothing."
        elif dmg < 2.0:
            name = "Rusty dagger"
            desc = "A double-edged dagger with nicked edge. It has a wooden handle."
        elif dmg < 3.0:
            name = "Sword"
            desc = "A rusty shortsword. It has leather wrapped around the handle."
        elif dmg < 4.0:
            name = "Club"
            desc = "A heavy wooden club with some rusty spikes in it."
        elif dmg < 5.0:
            name = "Ornate Longsword"
            aliases.extend(["longsword","ornate"])
            desc = "A fine longsword."
        elif dmg < 6.0:
            name = "Runeaxe"
            aliases.extend(["rune","axe"])
            desc = "A single-bladed axe, heavy but yet easy to use."
        elif dmg < 7.0:
            name = "Broadsword named Thruning"
            aliases.extend(["thruning","broadsword"])
            desc = "This heavy bladed weapon is marked with the name 'Thruning'. It is very powerful in skilled hands."
        elif dmg < 8.0:
            name = "Silver Warhammer"
            aliases.append("warhammer")
            desc = "A heavy war hammer with silver ornaments. This huge weapon causes massive damage."
        elif dmg < 9.0:
            name = "Slayer Waraxe"
            aliases.extend(["waraxe","slayer"])
            desc = "A huge double-bladed axe marked with the runes for 'Slayer'. It has more runic inscriptions on its head, which you cannot decipher."
        elif dmg < 10.0:
            name = "The Ghostblade"
            aliases.append("ghostblade")
            desc =  "This massive sword is large as you are tall. Its metal shine with a bluish glow."
        else:
            name = "The Hawkblade"
            aliases.append("hawkblade")
            desc = "White surges of magical power runs up and down this runic blade. The hawks depicted on its hilt almost seems to have a life of their own."
        if dmg < 9 and magic:
            desc += "\nThe metal seems to glow faintly, as if imbued with more power than what is immediately apparent."
        return dmg, name, aliases, desc, magic

########NEW FILE########
__FILENAME__ = rooms
"""

Room Typeclasses for the TutorialWorld.

"""

import random
from ev import CmdSet, Script, Command, Room
from ev import utils, create_object, search_object
from contrib.tutorial_world import scripts as tut_scripts
from contrib.tutorial_world.objects import LightSource, TutorialObject


#------------------------------------------------------------
#
# Tutorial room - parent room class
#
# This room is the parent of all rooms in the tutorial.
# It defines a tutorial command on itself (available to
# all who is in a tutorial room).
#
#------------------------------------------------------------

class CmdTutorial(Command):
    """
    Get help during the tutorial

    Usage:
      tutorial [obj]

    This command allows you to get behind-the-scenes info
    about an object or the current location.

    """
    key = "tutorial"
    aliases = ["tut"]
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        """
        All we do is to scan the current location for an attribute
        called `tutorial_info` and display that.
        """

        caller = self.caller

        if not self.args:
            target = self.obj # this is the room the command is defined on
        else:
            target = caller.search(self.args.strip())
            if not target:
                return
        helptext = target.db.tutorial_info
        if helptext:
            caller.msg("{G%s{n" % helptext)
        else:
            caller.msg("{RSorry, there is no tutorial help available here.{n")


class TutorialRoomCmdSet(CmdSet):
    "Implements the simple tutorial cmdset"
    key = "tutorial_cmdset"

    def at_cmdset_creation(self):
        "add the tutorial cmd"
        self.add(CmdTutorial())


class TutorialRoom(Room):
    """
    This is the base room type for all rooms in the tutorial world.
    It defines a cmdset on itself for reading tutorial info about the location.
    """
    def at_object_creation(self):
        "Called when room is first created"
        self.db.tutorial_info = "This is a tutorial room. It allows you to use the 'tutorial' command."
        self.cmdset.add_default(TutorialRoomCmdSet)

    def reset(self):
        "Can be called by the tutorial runner."
        pass


#------------------------------------------------------------
#
# Weather room - scripted room
#
# The weather room is called by a script at
# irregular intervals. The script is generally useful
# and so is split out into tutorialworld.scripts.
#
#------------------------------------------------------------

class WeatherRoom(TutorialRoom):
    """
    This should probably better be called a rainy room...

    This sets up an outdoor room typeclass. At irregular intervals,
    the effects of weather will show in the room. Outdoor rooms should
    inherit from this.

    """
    def at_object_creation(self):
        "Called when object is first created."
        super(WeatherRoom, self).at_object_creation()

        # we use the imported IrregularEvent script
        self.scripts.add(tut_scripts.IrregularEvent)
        self.db.tutorial_info = \
            "This room has a Script running that has it echo a weather-related message at irregular intervals."

    def update_irregular(self):
        "create a tuple of possible texts to return."
        strings = (
            "The rain coming down from the iron-grey sky intensifies.",
            "A gush of wind throws the rain right in your face. Despite your cloak you shiver.",
            "The rainfall eases a bit and the sky momentarily brightens.",
            "For a moment it looks like the rain is slowing, then it begins anew with renewed force.",
            "The rain pummels you with large, heavy drops. You hear the rumble of thunder in the distance.",
            "The wind is picking up, howling around you, throwing water droplets in your face. It's cold.",
            "Bright fingers of lightning flash over the sky, moments later followed by a deafening rumble.",
            "It rains so hard you can hardly see your hand in front of you. You'll soon be drenched to the bone.",
            "Lightning strikes in several thundering bolts, striking the trees in the forest to your west.",
            "You hear the distant howl of what sounds like some sort of dog or wolf.",
            "Large clouds rush across the sky, throwing their load of rain over the world.")

        # get a random value so we can select one of the strings above.
        # Send this to the room.
        irand = random.randint(0, 15)
        if irand > 10:
            return  # don't return anything, to add more randomness
        self.msg_contents("{w%s{n" % strings[irand])


#------------------------------------------------------------------------------
#
# Dark Room - a scripted room
#
# This room limits the movemenets of its denizens unless they carry a and active
# LightSource object (LightSource is defined in
#                     tutorialworld.objects.LightSource)
#
#------------------------------------------------------------------------------

class CmdLookDark(Command):
    """
    Look around in darkness

    Usage:
      look

    Looks in darkness
    """
    key = "look"
    aliases = ["l", 'feel', 'feel around', 'fiddle']
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "Implement the command."
        caller = self.caller
        # we don't have light, grasp around blindly.
        messages = ("It's pitch black. You fumble around but cannot find anything.",
                    "You don't see a thing. You feel around, managing to bump your fingers hard against something. Ouch!",
                    "You don't see a thing! Blindly grasping the air around you, you find nothing.",
                    "It's totally dark here. You almost stumble over some un-evenness in the ground.",
                    "You are completely blind. For a moment you think you hear someone breathing nearby ... \n ... surely you must be mistaken.",
                    "Blind, you think you find some sort of object on the ground, but it turns out to be just a stone.",
                    "Blind, you bump into a wall. The wall seems to be covered with some sort of vegetation, but its too damp to burn.",
                    "You can't see anything, but the air is damp. It feels like you are far underground.")
        irand = random.randint(0, 10)
        if irand < len(messages):
            caller.msg(messages[irand])
        else:
            # check so we don't already carry a lightsource.
            carried_lights = [obj for obj in caller.contents
                                       if utils.inherits_from(obj, LightSource)]
            if carried_lights:
                string = "You don't want to stumble around in blindness anymore. You already found what you need. Let's get light already!"
                caller.msg(string)
                return
            #if we are lucky, we find the light source.
            lightsources = [obj for obj in self.obj.contents
                                       if utils.inherits_from(obj, LightSource)]
            if lightsources:
                lightsource = lightsources[0]
            else:
                # create the light source from scratch.
                lightsource = create_object(LightSource, key="splinter")
            lightsource.location = caller
            string = "Your fingers bump against a splinter of wood in a corner. It smells of resin and seems dry enough to burn!"
            string += "\nYou pick it up, holding it firmly. Now you just need to {wlight{n it using the flint and steel you carry with you."
            caller.msg(string)


class CmdDarkHelp(Command):
    """
    Help command for the dark state.
    """
    key = "help"
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "Implements the help command."
        string = "Can't help you until you find some light! Try feeling around for something to burn."
        string += " You cannot give up even if you don't find anything right away."
        self.caller.msg(string)

# the nomatch system command will give a suitable error when we cannot find
# the normal commands.
from src.commands.default.syscommands import CMD_NOMATCH
from src.commands.default.general import CmdSay


class CmdDarkNoMatch(Command):
    "This is called when there is no match"
    key = CMD_NOMATCH
    locks = "cmd:all()"

    def func(self):
        "Implements the command."
        self.caller.msg("Until you find some light, there's not much you can do. Try feeling around.")


class DarkCmdSet(CmdSet):
    "Groups the commands."
    key = "darkroom_cmdset"
    mergetype = "Replace"  # completely remove all other commands

    def at_cmdset_creation(self):
        "populates the cmdset."
        self.add(CmdTutorial())
        self.add(CmdLookDark())
        self.add(CmdDarkHelp())
        self.add(CmdDarkNoMatch())
        self.add(CmdSay)

#
# Darkness room two-state system
#

class DarkState(Script):
    """
    The darkness state is a script that keeps tabs on when
    a player in the room carries an active light source. It places
    a new, very restrictive cmdset (DarkCmdSet) on all the players
    in the room whenever there is no light in it. Upon turning on
    a light, the state switches off and moves to LightState.
    """
    def at_script_creation(self):
        "This setups the script"
        self.key = "tutorial_darkness_state"
        self.desc = "A dark room"
        self.persistent = True

    def at_start(self):
        "called when the script is first starting up."
        for char in [char for char in self.obj.contents if char.has_player]:
            if char.is_superuser:
                char.msg("You are Superuser, so you are not affected by the dark state.")
            else:
                char.cmdset.add(DarkCmdSet)
            char.msg("The room is pitch dark! You are likely to be eaten by a Grue.")

    def is_valid(self):
        "is valid only as long as noone in the room has lit the lantern."
        return not self.obj.is_lit()

    def at_stop(self):
        "Someone turned on a light. This state dies. Switch to LightState."
        for char in [char for char in self.obj.contents if char.has_player]:
            char.cmdset.delete(DarkCmdSet)
        self.obj.db.is_dark = False
        self.obj.scripts.add(LightState)


class LightState(Script):
    """
    This is the counterpart to the Darkness state. It is active when the
    lantern is on.
    """
    def at_script_creation(self):
        "Called when script is first created."
        self.key = "tutorial_light_state"
        self.desc = "A room lit up"
        self.persistent = True

    def is_valid(self):
        """
        This state is only valid as long as there is an active light
        source in the room.
        """
        return self.obj.is_lit()

    def at_stop(self):
        "Light disappears. This state dies. Return to DarknessState."
        self.obj.db.is_dark = True
        self.obj.scripts.add(DarkState)


class DarkRoom(TutorialRoom):
    """
    A dark room. This tries to start the DarkState script on all
    objects entering. The script is responsible for making sure it is
    valid (that is, that there is no light source shining in the room).
    """
    def is_lit(self):
        """
        Helper method to check if the room is lit up. It checks all
        characters in room to see if they carry an active object of
        type LightSource.
        """
        return any([any([True for obj in char.contents
                         if utils.inherits_from(obj, LightSource) and obj.db.is_active])
                                 for char in self.contents if char.has_player])

    def at_object_creation(self):
        "Called when object is first created."
        super(DarkRoom, self).at_object_creation()
        self.db.tutorial_info = "This is a room with custom command sets on itself."
        # this variable is set by the scripts. It makes for an easy flag to
        # look for by other game elements (such as the crumbling wall in
        # the tutorial)
        self.db.is_dark = True
        # the room starts dark.
        self.scripts.add(DarkState)

    def at_object_receive(self, character, source_location):
        """
        Called when an object enters the room. We crank the wheels to make
        sure scripts are synced.
        """
        if character.has_player:
            if not self.is_lit() and not character.is_superuser:
                character.cmdset.add(DarkCmdSet)
            if character.db.health and character.db.health <= 0:
                # heal character coming here from being defeated by mob.
                health = character.db.health_max
                if not health:
                    health = 20
                character.db.health = health
        self.scripts.validate()

    def at_object_leave(self, character, target_location):
        """
        In case people leave with the light, we make sure to update the
        states accordingly.
        """
        character.cmdset.delete(DarkCmdSet)  # in case we are teleported away
        self.scripts.validate()


#------------------------------------------------------------
#
# Teleport room - puzzle room
#
# This is a sort of puzzle room that requires a certain
# attribute on the entering character to be the same as
# an attribute of the room. If not, the character will
# be teleported away to a target location. This is used
# by the Obelisk - grave chamber puzzle, where one must
# have looked at the obelisk to get an attribute set on
# oneself, and then pick the grave chamber with the
# matching imagery for this attribute.
#
#------------------------------------------------------------

class TeleportRoom(TutorialRoom):
    """
    Teleporter - puzzle room.

    Important attributes (set at creation):
      puzzle_key    - which attr to look for on character
      puzzle_value  - what char.db.puzzle_key must be set to
      teleport_to   - where to teleport to in case of failure to match

    """
    def at_object_creation(self):
        "Called at first creation"
        super(TeleportRoom, self).at_object_creation()
        # what character.db.puzzle_clue must be set to, to avoid teleportation.
        self.db.puzzle_value = 1
        # target of successful teleportation. Can be a dbref or a
        # unique room name.
        self.db.success_teleport_to = "treasure room"
        # the target of the failure teleportation.
        self.db.failure_teleport_to = "dark cell"

    def at_object_receive(self, character, source_location):
        """
        This hook is called by the engine whenever the player is moved into
        this room.
        """
        if not character.has_player:
            # only act on player characters.
            return
        #print character.db.puzzle_clue, self.db.puzzle_value
        if character.db.puzzle_clue != self.db.puzzle_value:
            # we didn't pass the puzzle. See if we can teleport.
            teleport_to = self.db.failure_teleport_to  # this is a room name
        else:
            # passed the puzzle
            teleport_to = self.db.success_teleport_to  # this is a room name

        results = search_object(teleport_to)
        if not results or len(results) > 1:
            # we cannot move anywhere since no valid target was found.
            print "no valid teleport target for %s was found." % teleport_to
            return
        if character.player.is_superuser:
            # superusers don't get teleported
            character.msg("Superuser block: You would have been teleported to %s." % results[0])
            return
        # teleport
        character.execute_cmd("look")
        character.location = results[0]  # stealth move
        character.location.at_object_receive(character, self)

#------------------------------------------------------------
#
# Bridge - unique room
#
# Defines a special west-eastward "bridge"-room, a large room it takes
# several steps to cross. It is complete with custom commands and a
# chance of falling off the bridge. This room has no regular exits,
# instead the exiting are handled by custom commands set on the player
# upon first entering the room.
#
# Since one can enter the bridge room from both ends, it is
# divided into five steps:
#       westroom <- 0 1 2 3 4 -> eastroom
#
#------------------------------------------------------------


class CmdEast(Command):
    """
    Try to cross the bridge eastwards.
    """
    key = "east"
    aliases = ["e"]
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "move forward"
        caller = self.caller

        bridge_step = min(5, caller.db.tutorial_bridge_position + 1)

        if bridge_step > 4:
            # we have reached the far east end of the bridge.
            # Move to the east room.
            eexit = search_object(self.obj.db.east_exit)
            if eexit:
                caller.move_to(eexit[0])
            else:
                caller.msg("No east exit was found for this room. Contact an admin.")
            return
        caller.db.tutorial_bridge_position = bridge_step
        caller.location.msg_contents("%s steps eastwards across the bridge." % caller.name, exclude=caller)
        caller.execute_cmd("look")


# go back across the bridge
class CmdWest(Command):
    """
    Go back across the bridge westwards.
    """
    key = "west"
    aliases = ["w"]
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "move forward"
        caller = self.caller

        bridge_step = max(-1, caller.db.tutorial_bridge_position - 1)

        if bridge_step < 0:
            # we have reached the far west end of the bridge.#
            # Move to the west room.
            wexit = search_object(self.obj.db.west_exit)
            if wexit:
                caller.move_to(wexit[0])
            else:
                caller.msg("No west exit was found for this room. Contact an admin.")
            return
        caller.db.tutorial_bridge_position = bridge_step
        caller.location.msg_contents("%s steps westwartswards across the bridge." % caller.name, exclude=caller)
        caller.execute_cmd("look")


class CmdLookBridge(Command):
    """
    looks around at the bridge.
    """
    key = 'look'
    aliases = ["l"]
    locks = "cmd:all()"
    help_category = "TutorialWorld"

    def func(self):
        "Looking around, including a chance to fall."
        bridge_position = self.caller.db.tutorial_bridge_position


        messages =("You are standing {wvery close to the the bridge's western foundation{n. If you go west you will be back on solid ground ...",
                   "The bridge slopes precariously where it extends eastwards towards the lowest point - the center point of the hang bridge.",
                   "You are {whalfways{n out on the unstable bridge.",
                   "The bridge slopes precariously where it extends westwards towards the lowest point - the center point of the hang bridge.",
                   "You are standing {wvery close to the bridge's eastern foundation{n. If you go east you will be back on solid ground ...")
        moods = ("The bridge sways in the wind.", "The hanging bridge creaks dangerously.",
                 "You clasp the ropes firmly as the bridge sways and creaks under you.",
                 "From the castle you hear a distant howling sound, like that of a large dog or other beast.",
                 "The bridge creaks under your feet. Those planks does not seem very sturdy.",
                 "Far below you the ocean roars and throws its waves against the cliff, as if trying its best to reach you.",
                 "Parts of the bridge come loose behind you, falling into the chasm far below!",
                 "A gust of wind causes the bridge to sway precariously.",
                 "Under your feet a plank comes loose, tumbling down. For a moment you dangle over the abyss ...",
                 "The section of rope you hold onto crumble in your hands, parts of it breaking apart. You sway trying to regain balance.")
        message = "{c%s{n\n" % self.obj.key + messages[bridge_position] + "\n" + moods[random.randint(0, len(moods) - 1)]
        chars = [obj for obj in self.obj.contents if obj != self.caller and obj.has_player]
        if chars:
            message += "\n You see: %s" % ", ".join("{c%s{n" % char.key for char in chars)

        self.caller.msg(message)

        # there is a chance that we fall if we are on the western or central
        # part of the bridge.
        if bridge_position < 3 and random.random() < 0.05 and not self.caller.is_superuser:
            # we fall on 5% of the times.
            fexit = search_object(self.obj.db.fall_exit)
            if fexit:
                string = "\n Suddenly the plank you stand on gives way under your feet! You fall!"
                string += "\n You try to grab hold of an adjoining plank, but all you manage to do is to "
                string += "divert your fall westwards, towards the cliff face. This is going to hurt ... "
                string += "\n ... The world goes dark ...\n"
                # note that we move silently so as to not call look hooks (this is a little trick to leave
                # the player with the "world goes dark ..." message, giving them ample time to read it. They
                # have to manually call look to find out their new location). Thus we also call the
                # at_object_leave hook manually (otherwise this is done by move_to()).
                self.caller.msg("{r%s{n" % string)
                self.obj.at_object_leave(self.caller, fexit)
                self.caller.location = fexit[0] # stealth move, without any other hook calls.
                self.obj.msg_contents("A plank gives way under %s's feet and they fall from the bridge!" % self.caller.key)


# custom help command
class CmdBridgeHelp(Command):
    """
    Overwritten help command
    """
    key = "help"
    aliases = ["h"]
    locks = "cmd:all()"
    help_category = "Tutorial world"

    def func(self):
        "Implements the command."
        string = "You are trying hard not to fall off the bridge ..."
        string += "\n\nWhat you can do is trying to cross the bridge {weast{n "
        string += "or try to get back to the mainland {wwest{n)."
        self.caller.msg(string)


class BridgeCmdSet(CmdSet):
    "This groups the bridge commands. We will store it on the room."
    key = "Bridge commands"
    priority = 1 # this gives it precedence over the normal look/help commands.
    def at_cmdset_creation(self):
        "Called at first cmdset creation"
        self.add(CmdTutorial())
        self.add(CmdEast())
        self.add(CmdWest())
        self.add(CmdLookBridge())
        self.add(CmdBridgeHelp())


class BridgeRoom(TutorialRoom):
    """
    The bridge room implements an unsafe bridge. It also enters the player into
    a state where they get new commands so as to try to cross the bridge.

     We want this to result in the player getting a special set of
        commands related to crossing the bridge. The result is that it will
        take several steps to cross it, despite it being represented by only a
        single room.

        We divide the bridge into steps:

        self.db.west_exit     -   -  |  -   -     self.db.east_exit
                              0   1  2  3   4

        The position is handled by a variable stored on the player when entering
        and giving special move commands will increase/decrease the counter
        until the bridge is crossed.

    """
    def at_object_creation(self):
        "Setups the room"
        super(BridgeRoom, self).at_object_creation()

        # at irregular intervals, this will call self.update_irregular()
        self.scripts.add(tut_scripts.IrregularEvent)
        # this identifies the exits from the room (should be the command
        # needed to leave through that exit). These are defaults, but you
        # could of course also change them after the room has been created.
        self.db.west_exit = "cliff"
        self.db.east_exit = "gate"
        self.db.fall_exit = "cliffledge"
        # add the cmdset on the room.
        self.cmdset.add_default(BridgeCmdSet)

        self.db.tutorial_info = \
            """The bridge seem large but is actually only a single room that assigns custom west/east commands."""

    def update_irregular(self):
        """
        This is called at irregular intervals and makes the passage
        over the bridge a little more interesting.
        """
        strings = (
            "The rain intensifies, making the planks of the bridge even more slippery.",
            "A gush of wind throws the rain right in your face.",
            "The rainfall eases a bit and the sky momentarily brightens.",
            "The bridge shakes under the thunder of a closeby thunder strike.",
            "The rain pummels you with large, heavy drops. You hear the distinct howl of a large hound in the distance.",
            "The wind is picking up, howling around you and causing the bridge to sway from side to side.",
            "Some sort of large bird sweeps by overhead, giving off an eery screech. Soon it has disappeared in the gloom.",
            "The bridge sways from side to side in the wind.")
        self.msg_contents("{w%s{n" % strings[random.randint(0, 7)])

    def at_object_receive(self, character, source_location):
        """
        This hook is called by the engine whenever the player is moved
        into this room.
        """
        if character.has_player:
            # we only run this if the entered object is indeed a player object.
            # check so our east/west exits are correctly defined.
            wexit = search_object(self.db.west_exit)
            eexit = search_object(self.db.east_exit)
            fexit = search_object(self.db.fall_exit)
            if not wexit or not eexit or not fexit:
                character.msg("The bridge's exits are not properly configured. Contact an admin. Forcing west-end placement.")
                character.db.tutorial_bridge_position = 0
                return
            if source_location == eexit[0]:
                character.db.tutorial_bridge_position = 4
            else:
                character.db.tutorial_bridge_position = 0

    def at_object_leave(self, character, target_location):
        """
        This is triggered when the player leaves the bridge room.
        """
        if character.has_player:
            # clean up the position attribute
            del character.db.tutorial_bridge_position


#-----------------------------------------------------------
#
# Intro Room - unique room
#
# This room marks the start of the tutorial. It sets up properties on
# the player char that is needed for the tutorial.
#
#------------------------------------------------------------

class IntroRoom(TutorialRoom):
    """
    Intro room

    properties to customize:
     char_health - integer > 0 (default 20)
    """

    def at_object_receive(self, character, source_location):
        """
        Assign properties on characters
        """

        # setup
        health = self.db.char_health
        if not health:
            health = 20

        if character.has_player:
            character.db.health = health
            character.db.health_max = health

        if character.is_superuser:
            string = "-"*78
            string += "\nWARNING: YOU ARE PLAYING AS A SUPERUSER (%s). TO EXPLORE NORMALLY YOU NEED " % character.key
            string += "\nTO CREATE AND LOG IN AS A REGULAR USER INSTEAD. IF YOU CONTINUE, KNOW THAT "
            string += "\nMANY FUNCTIONS AND PUZZLES WILL IGNORE THE PRESENCE OF A SUPERUSER.\n"
            string += "-"*78
            character.msg("{r%s{n" % string)


#------------------------------------------------------------
#
# Outro room - unique room
#
# Cleans up the character from all tutorial-related properties.
#
#------------------------------------------------------------

class OutroRoom(TutorialRoom):
    """
    Outro room.

    One can set an attribute list "wracklist" with weapon-rack ids
        in order to clear all weapon rack ids from the character.

    """

    def at_object_receive(self, character, source_location):
        """
        Do cleanup.
        """
        if character.has_player:
            if self.db.wracklist:
                for wrackid in self.db.wracklist:
                    character.del_attribute(wrackid)
            del character.db.health_max
            del character.db.health
            del character.db.last_climbed
            del character.db.puzzle_clue
            del character.db.combat_parry_mode
            del character.db.tutorial_bridge_position
            for tut_obj in [obj for obj in character.contents
                                  if utils.inherits_from(obj, TutorialObject)]:
                tut_obj.reset()

########NEW FILE########
__FILENAME__ = scripts
"""
This defines some generally useful scripts for the tutorial world.
"""

import random
from ev import Script


#------------------------------------------------------------
#
# IrregularEvent - script firing at random intervals
#
# This is a generally useful script for updating
# objects at irregular intervals. This is used by as diverse
# entities as Weather rooms and mobs.
#
#
#
#------------------------------------------------------------

class IrregularEvent(Script):
    """
    This script, which should be tied to a particular object upon
    instantiation, calls update_irregular on the object at random
    intervals.
    """
    def at_script_creation(self):
        "This setups the script"

        self.key = "update_irregular"
        self.desc = "Updates at irregular intervals"
        self.interval = random.randint(30, 70)  # interval to call.
        self.start_delay = True  # wait at least self.interval seconds before
                                 # calling at_repeat the first time
        self.persistent = True

        # this attribute determines how likely it is the
        # 'update_irregular' method gets called on self.obj (value is
        # 0.0-1.0 with 1.0 meaning it being called every time.)
        self.db.random_chance = 0.2

    def at_repeat(self):
        "This gets called every self.interval seconds."
        rand = random.random()
        if rand <= self.db.random_chance:
            try:
                #self.obj.msg_contents("irregular event for %s(#%i)" % (self.obj, self.obj.id))
                self.obj.update_irregular()
            except Exception:
                pass


class FastIrregularEvent(IrregularEvent):
    "A faster updating irregular event"
    def at_script_creation(self):
        "Called at initial script creation"
        super(FastIrregularEvent, self).at_script_creation()
        self.interval = 5  # every 5 seconds, 1/5 chance of firing


#------------------------------------------------------------
#
# Tutorial world Runner - root reset timer for TutorialWorld
#
# This is a runner that resets the world
#
#------------------------------------------------------------

# #
# # This sets up a reset system -- it resets the entire tutorial_world domain
# # and all objects inheriting from it back to an initial state, MORPG style.
# This is useful in order for different players to explore it without finding
# # things missing.
# #
# # Note that this will of course allow a single player to end up with
# # multiple versions of objects if they just wait around between resets;
# # In a real game environment this would have to be resolved e.g.
# # with custom versions of the 'get' command not accepting doublets.
# #

# # setting up an event for reseting the world.

# UPDATE_INTERVAL = 60 * 10 # Measured in seconds


# #This is a list of script parent objects that subscribe to the reset
# functionality.
# RESET_SUBSCRIBERS = ["examples.tutorial_world.p_weapon_rack",
#                      "examples.tutorial_world.p_mob"]

# class EventResetTutorialWorld(Script):
#     """
#     This calls the reset function on all subscribed objects
#     """
#     def __init__(self):
#         super(EventResetTutorialWorld, self).__init__()
#         self.name = 'reset_tutorial_world'
#         #this you see when running @ps in game:
#         self.description = 'Reset the tutorial world .'
#         self.interval = UPDATE_INTERVAL
#         self.persistent = True

#     def event_function(self):
#         """
#         This is called every self.interval seconds.
#         """
#         #find all objects inheriting the subscribing parents
#         for parent in RESET_SUBSCRIBERS:
#             objects = Object.objects.global_object_script_parent_search(parent)
#             for obj in objects:
#                 try:
#                     obj.scriptlink.reset()
#                 except:
#                     logger.log_errmsg(traceback.print_exc())
########NEW FILE########
__FILENAME__ = ev
"""
Central API for the Evennia MUD/MUX/MU* creation system.

This is a set of shortcuts for accessing common features in src/ with
less boiler-plate. Import this from your code, use it with @py from
in-game or explore it interactively from a python shell.

Notes:

 0) Use ev.help, ev.managers.help, ev.default_cmds.help and
    syscmdkeys.help to view the API structure and explore which
    variables/methods are available.
 1) This module holds variables, not modules in their own right. This
    means you cannot use import dot-notation to import nested things via
    this API.
 2) "managers" is a container object that contains shortcuts to
    initiated versions of Evennia's django database managers (e.g.
    managers.objects is an alias for ObjectDB.objects). These allow for
    exploring the database in various ways.
 3) "syscmdkeys" is a container object holding the names of system
    commands.  the syscmdkeys object.
 4) You -have- to use the create_* functions (shortcuts to
    src.utils.create) to create new typeclassed game entities (Objects,
    Scripts, Channels or Players).
 5) "settings" links to Evennia's game/settings file. "settings_full"
    shows all of django's available settings. Note that this is for
    viewing only - you cannot *change* settings from here in a meaningful
    way but have to update game/settings.py and restart the server.
"""

import sys
import os

######################################################################
# set Evennia version in __version__ property
######################################################################

try:
    f = open(os.path.dirname(os.path.abspath(__file__)) + os.sep + "VERSION", 'r')
    __version__ = "Evennia %s-r%s" % (f.read().strip(), os.popen("hg id -i").read().strip())
    f.close()
    del f
except IOError:
    __version__ = "Evennia (unknown version)"

######################################################################
# Stop erroneous direct run (would give a traceback since django is
#  not yet initialized)
######################################################################

if __name__ == "__main__":
    print \
"""
   Evennia MU* creation system (%s)

   This module gives access to Evennia's API (Application Programming
   Interface). It should *not* be run on its own, but be imported and
   accessed from your code or explored interactively from a Python
   shell.

   For help configuring and starting the Evennia server, see the
   INSTALL file. More help can be found at http://www.evennia.com.
""" % __version__
    sys.exit()

######################################################################
# make sure settings is available, also if starting this API stand-alone
# make settings available, and also the full django settings
######################################################################

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(1, os.path.dirname(os.path.abspath(__file__)) + os.path.sep + "game")
os.environ["DJANGO_SETTINGS_MODULE"] = "game.settings"
del sys, os

from game import settings
from django.conf import settings as settings_full

try:
    # test this first import to make sure environment is set up correctly
    from src.help.models import HelpEntry
except AttributeError, e:
    err = e.message
    err += "\nError initializing ev.py: Maybe the correct environment variables were not set."
    err += "\nUse \"python game/manage.py shell\" to start an interpreter"
    err += " with everything configured correctly."
    raise AttributeError(err)


######################################################################
# Start Evennia API
# (easiest is to import this module interactively to explore it)
######################################################################

README = __doc__

# help entries
from src.help.models import HelpEntry

from src.typeclasses.models import Attribute
# players
from src.players.player import Player
from src.players.models import PlayerDB

# commands
from src.commands.command import Command
from src.commands.cmdset import CmdSet
# (default_cmds is created below)

# locks
from src.locks import lockfuncs

# scripts
from src.scripts.scripts import Script

# comms
from src.comms.models import Msg, ChannelDB
from src.comms.comms import Channel

# objects
from src.objects.objects import Object, Character, Room, Exit

# extras
from src.typeclasses.models import Attribute, Tag

# utils

from src.utils.search import *
from src.utils.create import *
from src.scripts.tickerhandler import TICKER_HANDLER as tickerhandler
from src.utils import logger
from src.utils import utils
from src.utils import gametime
from src.utils import ansi


######################################################################
# API containers and helper functions
######################################################################

def help(header=False):
    """
    Main Evennia API.
       ev.help() views API contents
       ev.help(True) or ev.README shows module instructions

       See www.evennia.com for the full documentation.
    """
    if header:
        return __doc__
    else:
        import ev
        names = [str(var) for var in ev.__dict__ if not var.startswith('_')]
        return ", ".join(names)


class _EvContainer(object):
    """
    Parent for other containers

    """
    def _help(self):
        "Returns list of contents"
        names = [name for name in self.__class__.__dict__ if not name.startswith('_')]
        names += [name for name in self.__dict__ if not name.startswith('_')]
        print self.__doc__ + "-" * 60 + "\n" + ", ".join(names)
    help = property(_help)


class DBmanagers(_EvContainer):
    """
    Links to instantiated database managers.

    helpentry - HelpEntry.objects
    players - PlayerDB.objects
    scripts - ScriptDB.objects
    msgs    - Msg.objects
    channels - Channel.objects
    objects - ObjectDB.objects
    serverconfigs = ServerConfig.objects
    tags - Tags.objects
    attributes - Attributes.objects

    """
    from src.help.models import HelpEntry
    from src.players.models import PlayerDB
    from src.scripts.models import ScriptDB
    from src.comms.models import Msg, ChannelDB
    from src.objects.models import ObjectDB
    from src.server.models import ServerConfig
    from src.typeclasses.models import Tag, Attribute

    # create container's properties
    helpentries = HelpEntry.objects
    players = PlayerDB.objects
    scripts = ScriptDB.objects
    msgs = Msg.objects
    channels = ChannelDB.objects
    objects = ObjectDB.objects
    serverconfigs = ServerConfig.objects
    attributes = Attribute.objects
    tags = Tag.objects
    # remove these so they are not visible as properties
    del HelpEntry, PlayerDB, ScriptDB, Msg, ChannelDB
    #del ExternalChannelConnection
    del ObjectDB, ServerConfig, Tag, Attribute

managers = DBmanagers()
del DBmanagers


class DefaultCmds(_EvContainer):
    """
    This container holds direct shortcuts to all default commands in Evennia.

    To access in code, do 'from ev import default_cmds' then
    access the properties on the imported default_cmds object.

    """

    from src.commands.default.cmdset_character import CharacterCmdSet
    from src.commands.default.cmdset_player import PlayerCmdSet
    from src.commands.default.cmdset_unloggedin import UnloggedinCmdSet
    from src.commands.default.muxcommand import MuxCommand, MuxPlayerCommand

    def __init__(self):
        "populate the object with commands"

        def add_cmds(module):
            "helper method for populating this object with cmds"
            cmdlist = utils.variable_from_module(module, module.__all__)
            self.__dict__.update(dict([(c.__name__, c) for c in cmdlist]))

        from src.commands.default import (admin, batchprocess,
                                          building, comms, general,
                                          player, help, system, unloggedin)
        add_cmds(admin)
        add_cmds(building)
        add_cmds(batchprocess)
        add_cmds(building)
        add_cmds(comms)
        add_cmds(general)
        add_cmds(player)
        add_cmds(help)
        add_cmds(system)
        add_cmds(unloggedin)
default_cmds = DefaultCmds()
del DefaultCmds


class SystemCmds(_EvContainer):
    """
    Creating commands with keys set to these constants will make
    them system commands called as a replacement by the parser when
    special situations occur. If not defined, the hard-coded
    responses in the server are used.

    CMD_NOINPUT - no input was given on command line
    CMD_NOMATCH - no valid command key was found
    CMD_MULTIMATCH - multiple command matches were found
    CMD_CHANNEL - the command name is a channel name
    CMD_LOGINSTART - this command will be called as the very
                     first command when a player connects to
                     the server.

    To access in code, do 'from ev import syscmdkeys' then
    access the properties on the imported syscmdkeys object.

    """
    from src.commands import cmdhandler
    CMD_NOINPUT = cmdhandler.CMD_NOINPUT
    CMD_NOMATCH = cmdhandler.CMD_NOMATCH
    CMD_MULTIMATCH = cmdhandler.CMD_MULTIMATCH
    CMD_CHANNEL = cmdhandler.CMD_CHANNEL
    CMD_LOGINSTART = cmdhandler.CMD_LOGINSTART
    del cmdhandler
syscmdkeys = SystemCmds()
del SystemCmds
del _EvContainer

########NEW FILE########
__FILENAME__ = evennia
#!/usr/bin/env python
"""
EVENNIA SERVER STARTUP SCRIPT

This is the start point for running Evennia.

Sets the appropriate environmental variables and launches the server
and portal through the runner. Run without arguments to get a
menu. Run the script with the -h flag to see usage information.

"""
import os
import sys
import signal
from optparse import OptionParser
from subprocess import Popen

# Set the Python path up so we can get to settings.py from here.
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['DJANGO_SETTINGS_MODULE'] = 'game.settings'

if not os.path.exists('settings.py'):
    # make sure we have a settings.py file.
    print "    No settings.py file found. launching manage.py ..."

    # this triggers the settings file creation.
    import game.manage
    sys.exit()

# signal processing
SIG = signal.SIGINT


CMDLINE_HELP = \
"""
Main Evennia launcher. When starting in interactive (-i) mode, only
the Server will do so since this is the most commonly useful setup. To
activate interactive mode also for the Portal, use the menu or launch
the two services one after the other as two separate calls to this
program.
"""


VERSION_INFO = \
"""
 Evennia {version}
 {about}
 OS: {os}
 Python: {python}
 Twisted: {twisted}
 Django: {django}
 {south}
"""

ABOUT_INFO= \
"""
 MUD/MUX/MU* development system

 Licence: BSD 3-Clause Licence
 Web: http://www.evennia.com
 Irc: #evennia on FreeNode
 Forum: http://www.evennia.com/discussions
 Maintainer (2010-):   Griatch (griatch AT gmail DOT com)
 Maintainer (2006-10): Greg Taylor
"""

HELP_ENTRY = \
"""
                                         (version %s)

All functionality of the launcher can also be accessed directly from
the command line. Use  "python evennia.py -h" for command line
options.

Evennia consists of two separate parts that both must be running
for the server to work as it should:

Portal - the connection to the outside world (via telnet, web, ssh
         etc). This is normally running as a daemon and don't need to
         be reloaded unless you are debugging a new connection
         protocol.
Server - the game server itself. This will often need to be reloaded
         as you develop your game. The Portal will auto-connect to the
         Server whenever the Server activates.

In a production environment you will want to run with the default
option (1), which runs as much as possible as a background process.
When developing your game it is however convenient to directly see
tracebacks on standard output, so starting with options 2-4 may be a
good bet. As you make changes to your code, reload the server (option
5) to make changes appear in the game.

Reload and stop is not well supported in Windows. If you have issues,
log into the game to stop or restart the server instead.
"""

MENU = \
"""
+----Evennia Launcher-------------------------------------------------------+
|                                                                           |
+--- Starting --------------------------------------------------------------+
|                                                                           |
|  1) (default):      All output to logfiles.                               |
|  2) (game debug):   Server outputs to terminal instead of to logfile.     |
|  3) (portal debug): Portal outputs to terminal instead of to logfile.     |
|  4) (full debug):   Both Server and Portal output to terminal             |
|                                                                           |
+--- Restarting ------------------------------------------------------------+
|                                                                           |
|  5) Reload the Server                                                     |
|  6) Reload the Portal (only works when portal outputs to terminal).       |
|                                                                           |
+--- Stopping --------------------------------------------------------------+
|                                                                           |
|  7) Stopping both Portal and Server.                                      |
|  8) Stopping only Server.                                                 |
|  9) Stopping only Portal.                                                 |
|                                                                           |
+---------------------------------------------------------------------------+
|  h) Help                     i) About info                      q) Abort  |
+---------------------------------------------------------------------------+
"""


#
# System Configuration and setup
#

SERVER_PIDFILE = "server.pid"
PORTAL_PIDFILE = "portal.pid"

SERVER_RESTART = "server.restart"
PORTAL_RESTART = "portal.restart"

# Get the settings
from django.conf import settings

from src.utils.utils import get_evennia_version
EVENNIA_VERSION = get_evennia_version()

# Setup access of the evennia server itself
SERVER_PY_FILE = os.path.join(settings.SRC_DIR, 'server/server.py')
PORTAL_PY_FILE = os.path.join(settings.SRC_DIR, 'server/portal.py')

# Get logfile names
SERVER_LOGFILE = settings.SERVER_LOG_FILE
PORTAL_LOGFILE = settings.PORTAL_LOG_FILE

# Check so a database exists and is accessible
from django.db import DatabaseError
from src.players.models import PlayerDB
try:
    superuser = PlayerDB.objects.get(id=1)
except DatabaseError, e:
    print """
    Your database does not seem to be set up correctly.
    (error was '%s')

    Please run:

       python manage.py syncdb
       python manage.py migrate

    When you have a database set up, rerun evennia.py.
    """ % e
    sys.exit()
except PlayerDB.DoesNotExist:
    # no superuser yet. We need to create it.
    from django.core.management import call_command
    print "\nCreate a superuser below. The superuser is Player #1, the 'owner' account of the server.\n"
    call_command("createsuperuser", interactive=True)

# Add this to the environmental variable for the 'twistd' command.
currpath = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if 'PYTHONPATH' in os.environ:
    os.environ['PYTHONPATH'] += (":%s" % currpath)
else:
    os.environ['PYTHONPATH'] = currpath

TWISTED_BINARY = 'twistd'
if os.name == 'nt':
    # Windows needs more work to get the correct binary
    try:
        # Test for for win32api
        import win32api
    except ImportError:
        print """
    ERROR: Unable to import win32api, which Twisted requires to run.
    You may download it from:

    http://sourceforge.net/projects/pywin32
      or
    http://starship.python.net/crew/mhammond/win32/Downloads.html"""
        sys.exit()

    if not os.path.exists('twistd.bat'):
        # Test for executable twisted batch file. This calls the twistd.py
        # executable that is usually not found on the path in Windows.
        # It's not enough to locate scripts.twistd, what we want is the
        # executable script C:\PythonXX/Scripts/twistd.py. Alas we cannot
        # hardcode this location since we don't know if user has Python
        # in a non-standard location, so we try to figure it out.
        from twisted.scripts import twistd
        twistd_path = os.path.abspath(
            os.path.join(os.path.dirname(twistd.__file__),
                         os.pardir, os.pardir, os.pardir, os.pardir,
                         'scripts', 'twistd.py'))
        bat_file = open('twistd.bat', 'w')
        bat_file.write("@\"%s\" \"%s\" %%*" % (sys.executable, twistd_path))
        bat_file.close()
        print """
    INFO: Since you are running Windows, a file 'twistd.bat' was
    created for you. This is a simple batch file that tries to call
    the twisted executable. Evennia determined this to be:

       %(twistd_path)s

    If you run into errors at startup you might need to edit
    twistd.bat to point to the actual location of the Twisted
    executable (usually called twistd.py) on your machine.

    This procedure is only done once. Run evennia.py again when you
    are ready to start the server.
    """ % {'twistd_path': twistd_path}
        sys.exit()

    TWISTED_BINARY = 'twistd.bat'


# Functions

def get_pid(pidfile):
    """
    Get the PID (Process ID) by trying to access
    an PID file.
    """
    pid = None
    if os.path.exists(pidfile):
        f = open(pidfile, 'r')
        pid = f.read()
    return pid


def del_pid(pidfile):
    """
    The pidfile should normally be removed after a process has finished, but
    when sending certain signals they remain, so we need to clean them manually.
    """
    if os.path.exists(pidfile):
        os.remove(pidfile)


def kill(pidfile, signal=SIG, succmsg="", errmsg="", restart_file=SERVER_RESTART, restart="reload"):
    """
    Send a kill signal to a process based on PID. A customized success/error
    message will be returned. If clean=True, the system will attempt to manually
    remove the pid file.
    """
    pid = get_pid(pidfile)
    if pid:
        if os.name == 'nt':
            if sys.version < "2.7":
                print "Windows requires Python 2.7 or higher for this operation."
                return
            os.remove(pidfile)
        # set restart/norestart flag
        f = open(restart_file, 'w')
        f.write(str(restart))
        f.close()
        try:
            os.kill(int(pid), signal)
        except OSError:
            print "Process %(pid)s could not be signalled. The PID file '%(pidfile)s' seems stale. Try removing it." % {'pid': pid, 'pidfile': pidfile}
            return
        print "Evennia:", succmsg
        return
    print "Evennia:", errmsg

def show_version_info(about=False):
    """
    Display version info
    """
    import os, sys
    import twisted
    import django
    try:
        import south
        sversion = "South %s" % south.__version__
    except ImportError:
        sversion = "South <not installed>"

    return VERSION_INFO.format(version=EVENNIA_VERSION,
                             about=ABOUT_INFO if about else "",
                             os=os.name, python=sys.version.split()[0],
                             twisted=twisted.version.short(),
                             django=django.get_version(),
                             south=sversion)

def run_menu():
    """
    This launches an interactive menu.
    """

    cmdstr = [sys.executable, "runner.py"]

    while True:
        # menu loop

        print MENU
        inp = raw_input(" option > ")

        # quitting and help
        if inp.lower() == 'q':
            sys.exit()
        elif inp.lower() == 'h':
            print HELP_ENTRY % EVENNIA_VERSION
            raw_input("press <return> to continue ...")
            continue
        elif inp.lower() in ('v', 'i', 'a'):
            print show_version_info(about=True)
            raw_input("press <return> to continue ...")
            continue

        # options
        try:
            inp = int(inp)
        except ValueError:
            print "Not a valid option."
            continue
        errmsg = "The %s does not seem to be running."
        if inp < 5:
            if inp == 1:
                pass  # default operation
            elif inp == 2:
                cmdstr.extend(['--iserver'])
            elif inp == 3:
                cmdstr.extend(['--iportal'])
            elif inp == 4:
                cmdstr.extend(['--iserver', '--iportal'])
            return cmdstr
        elif inp < 10:
            if inp == 5:
                if os.name == 'nt':
                    print "This operation is not supported under Windows. Log into the game to restart/reload the server."
                    return
                kill(SERVER_PIDFILE, SIG, "Server reloaded.", errmsg % "Server", restart="reload")
            elif inp == 6:
                if os.name == 'nt':
                    print "This operation is not supported under Windows."
                    return
                kill(PORTAL_PIDFILE, SIG, "Portal reloaded (or stopped if in daemon mode).", errmsg % "Portal", restart=True)
            elif inp == 7:
                kill(SERVER_PIDFILE, SIG, "Stopped Portal.", errmsg % "Portal", PORTAL_RESTART, restart=False)
                kill(PORTAL_PIDFILE, SIG, "Stopped Server.", errmsg % "Server", restart="shutdown")
            elif inp == 8:
                kill(PORTAL_PIDFILE, SIG, "Stopped Server.", errmsg % "Server", restart="shutdown")
            elif inp == 9:
                kill(SERVER_PIDFILE, SIG, "Stopped Portal.", errmsg % "Portal", PORTAL_RESTART, restart=False)
            return
        else:
            print "Not a valid option."
    return None


def handle_args(options, mode, service):
    """
    Handle argument options given on the command line.

    options - parsed object for command line
    mode - str; start/stop etc
    service - str; server, portal or all
    """

    inter = options.interactive
    cmdstr = [sys.executable, "runner.py"]
    errmsg = "The %s does not seem to be running."

    if mode == 'start':

        # launch the error checker. Best to catch the errors already here.
        error_check_python_modules()

        # starting one or many services
        if service == 'server':
            if inter:
                cmdstr.append('--iserver')
            cmdstr.append('--noportal')
        elif service == 'portal':
            if inter:
                cmdstr.append('--iportal')
            cmdstr.append('--noserver')
        else:  # all
            # for convenience we don't start logging of
            # portal, only of server with this command.
            if inter:
                cmdstr.extend(['--iserver'])
        return cmdstr

    elif mode == 'reload':
        # restarting services
        if os.name == 'nt':
            print "Restarting from command line is not supported under Windows. Log into the game to restart."
            return
        if service == 'server':
            kill(SERVER_PIDFILE, SIG, "Server reloaded.", errmsg % 'Server', restart="reload")
        elif service == 'portal':
            print """
          Note: Portal usually don't need to be reloaded unless you are debugging in interactive mode.
          If Portal was running in default Daemon mode, it cannot be restarted. In that case you have
          to restart it manually with 'evennia.py start portal'
          """
            kill(PORTAL_PIDFILE, SIG, "Portal reloaded (or stopped, if it was in daemon mode).", errmsg % 'Portal', PORTAL_RESTART)
        else: # all
            # default mode, only restart server
            kill(SERVER_PIDFILE, SIG, "Server reload.", errmsg % 'Server', restart="reload")

    elif mode == 'stop':
        # stop processes, avoiding reload
        if service == 'server':
            kill(SERVER_PIDFILE, SIG, "Server stopped.", errmsg % 'Server', restart="shutdown")
        elif service == 'portal':
            kill(PORTAL_PIDFILE, SIG, "Portal stopped.", errmsg % 'Portal', PORTAL_RESTART, restart=False)
        else:
            kill(PORTAL_PIDFILE, SIG, "Portal stopped.", errmsg % 'Portal', PORTAL_RESTART, restart=False)
            kill(SERVER_PIDFILE, SIG, "Server stopped.", errmsg % 'Server', restart="shutdown")
    return None

def error_check_python_modules():
    """
    Import settings modules in settings. This will raise exceptions on
    pure python-syntax issues which are hard to catch gracefully
    with exceptions in the engine (since they are formatting errors in
    the python source files themselves). Best they fail already here
    before we get any further.
    """
    def imp(path, split=True):
        mod, fromlist = path, "None"
        if split:
            mod, fromlist = path.rsplit('.', 1)
        __import__(mod, fromlist=[fromlist])

    # core modules
    imp(settings.COMMAND_PARSER)
    imp(settings.SEARCH_AT_RESULT)
    imp(settings.SEARCH_AT_MULTIMATCH_INPUT)
    imp(settings.CONNECTION_SCREEN_MODULE, split=False)
    #imp(settings.AT_INITIAL_SETUP_HOOK_MODULE, split=False)
    for path in settings.LOCK_FUNC_MODULES:
        imp(path, split=False)
    # cmdsets

    deprstring = "settings.%s should be renamed to %s. If defaults are used, " \
                 "their path/classname must be updated (see src/settings_default.py)."
    if hasattr(settings, "CMDSET_DEFAULT"):
        raise DeprecationWarning(deprstring % ("CMDSET_DEFAULT", "CMDSET_CHARACTER"))
    if hasattr(settings, "CMDSET_OOC"):
        raise DeprecationWarning(deprstring % ("CMDSET_OOC", "CMDSET_PLAYER"))
    if settings.WEBSERVER_ENABLED and not isinstance(settings.WEBSERVER_PORTS[0], tuple):
        raise DeprecationWarning("settings.WEBSERVER_PORTS must be on the form [(proxyport, serverport), ...]")
    if hasattr(settings, "BASE_COMM_TYPECLASS"):
        raise DeprecationWarning(deprstring % ("BASE_COMM_TYPECLASS", "BASE_CHANNEL_TYPECLASS"))
    if hasattr(settings, "COMM_TYPECLASS_PATHS"):
        raise DeprecationWarning(deprstring % ("COMM_TYPECLASS_PATHS", "CHANNEL_TYPECLASS_PATHS"))
    if hasattr(settings, "CHARACTER_DEFAULT_HOME"):
        raise DeprecationWarning("settings.CHARACTER_DEFAULT_HOME should be renamed to DEFAULT_HOME. " \
                "See also settings.START_LOCATION (see src/settings_default.py).")

    from src.commands import cmdsethandler
    if not cmdsethandler.import_cmdset(settings.CMDSET_UNLOGGEDIN, None): print "Warning: CMDSET_UNLOGGED failed to load!"
    if not cmdsethandler.import_cmdset(settings.CMDSET_CHARACTER, None): print "Warning: CMDSET_CHARACTER failed to load"
    if not cmdsethandler.import_cmdset(settings.CMDSET_PLAYER, None): print "Warning: CMDSET_PLAYER failed to load"
    # typeclasses
    imp(settings.BASE_PLAYER_TYPECLASS)
    imp(settings.BASE_OBJECT_TYPECLASS)
    imp(settings.BASE_CHARACTER_TYPECLASS)
    imp(settings.BASE_ROOM_TYPECLASS)
    imp(settings.BASE_EXIT_TYPECLASS)
    imp(settings.BASE_SCRIPT_TYPECLASS)


def main():
    """
    This handles command line input.
    """

    parser = OptionParser(usage="%prog [-i] start|stop|reload|menu [server|portal]",
                          description=CMDLINE_HELP)
    parser.add_option('-i', '--interactive', action='store_true',
                      dest='interactive', default=False,
                      help="Start given processes in interactive mode.")
    parser.add_option('-v', '--version', action='store_true',
                      dest='show_version', default=False,
                      help="Show version info.")

    options, args = parser.parse_args()

    if not args:
        if options.show_version:
            print show_version_info()
            return
        mode = "menu"
        service = 'all'
    if args:
        mode = args[0]
        service = "all"
    if len(args) > 1:
        service = args[1]

    if mode not in ['menu', 'start', 'reload', 'stop']:
        print "mode should be none, 'menu', 'start', 'reload' or 'stop'."
        sys.exit()
    if  service not in ['server', 'portal', 'all']:
        print "service should be none, 'server', 'portal' or 'all'."
        sys.exit()

    if mode == 'menu':
        # launch menu
        cmdstr = run_menu()
    else:
        # handle command-line arguments
        cmdstr = handle_args(options, mode, service)
    if cmdstr:
        # call the runner.
        cmdstr.append('start')
        Popen(cmdstr)

if __name__ == '__main__':
    # start Evennia
    from src.utils.utils import check_evennia_dependencies
    if check_evennia_dependencies():
        main()

########NEW FILE########
__FILENAME__ = cmdset
"""
Example command set template module.

To create new commands to populate the cmdset, see
examples/command.py.

To extend the character command set:
  - copy this file up one level to gamesrc/commands and name it
    something fitting.
  - change settings.CMDSET_CHARACTER to point to the new module's
    CharacterCmdSet class
  - import/add commands at the end of CharacterCmdSet's add() method.

To extend Player cmdset:
  - like character set, but point settings.PLAYER on your new cmdset.

To extend Unloggedin cmdset:
  - like default set, but point settings.CMDSET_UNLOGGEDIN on your new cmdset.

To add a wholly new command set:
  - copy this file up one level to gamesrc/commands and name it
    something fitting.
  - add a new cmdset class
  - add it to objects e.g. with obj.cmdset.add(path.to.the.module.and.class)

"""

from ev import CmdSet, Command
from ev import default_cmds

#from contrib import menusystem, lineeditor
#from contrib import misc_commands
#from contrib import chargen


class ExampleCmdSet(CmdSet):
    """
    Implements an empty, example cmdset.
    """

    key = "ExampleSet"

    def at_cmdset_creation(self):
        """
        This is the only method defined in a cmdset, called during
        its creation. It should populate the set with command instances.

        As and example we just add the empty base Command object.
        It prints some info.
        """
        self.add(Command())


class CharacterCmdSet(default_cmds.CharacterCmdSet):
    """
    This is an example of how to overload the default command
    set defined in src/commands/default/cmdset_character.py.

    Here we copy everything by calling the parent, but you can
    copy&paste any combination of the default command to customize
    your default set. Next you change settings.CMDSET_CHARACTER to point
    to this class.
    """
    key = "DefaultCharacter"

    def at_cmdset_creation(self):
        """
        Populates the cmdset
        """
        # calling setup in src.commands.default.cmdset_character
        super(CharacterCmdSet, self).at_cmdset_creation()

        #
        # any commands you add below will overload the default ones.
        #
        #self.add(menusystem.CmdMenuTest())
        #self.add(lineeditor.CmdEditor())
        #self.add(misc_commands.CmdQuell())


class UnloggedinCmdSet(default_cmds.UnloggedinCmdSet):
    """
    This is an example of how to overload the command set of the
    unloggedin commands, defined in
    src/commands/default/cmdset_unloggedin.py.

    Here we copy everything by calling the parent, but you can
    copy&paste any combination of the default command to customize
    your default set. Next you change settings.CMDSET_UNLOGGEDIN to
    point to this class.
    """
    key = "DefaultUnloggedin"

    def at_cmdset_creation(self):
        """
        Populates the cmdset
        """
        # calling setup in src.commands.default.cmdset_unloggedin
        super(UnloggedinCmdSet, self).at_cmdset_creation()

        #
        # any commands you add below will overload the default ones.
        #


class PlayerCmdSet(default_cmds.PlayerCmdSet):
    """
    This is set is available to the player when they have no
    character connected to them (i.e. they are out-of-character, ooc).
    """
    key = "DefaultPlayer"

    def at_cmdset_creation(self):
        """
        Populates the cmdset
        """
        # calling setup in src.commands.default.cmdset_ooc
        super(PlayerCmdSet, self).at_cmdset_creation()
        #
        # any commands you add below will overload the default ones.
        #

########NEW FILE########
__FILENAME__ = cmdset_red_button
"""
This defines the cmdset for the red_button. Here we have defined
the commands and the cmdset in the same module, but if you
have many different commands to merge it is often better
to define the cmdset separately, picking and choosing from
among the available commands as to what should be included in the
cmdset - this way you can often re-use the commands too.
"""

import random
from ev import Command, CmdSet

# Some simple commands for the red button

#------------------------------------------------------------
# Commands defined on the red button
#------------------------------------------------------------


class CmdNudge(Command):
    """
    Try to nudge the button's lid

    Usage:
      nudge lid

    This command will have you try to
    push the lid of the button away.
    """

    key = "nudge lid"  # two-word command name!
    aliases = ["nudge"]
    locks = "cmd:all()"

    def func(self):
        """
        nudge the lid. Random chance of success to open it.
        """
        rand = random.random()
        if rand < 0.5:
            self.caller.msg("You nudge at the lid. It seems stuck.")
        elif 0.5 <= rand < 0.7:
            self.caller.msg("You move the lid back and forth. It won't budge.")
        else:
            self.caller.msg("You manage to get a nail under the lid.")
            self.caller.execute_cmd("open lid")


class CmdPush(Command):
    """
    Push the red button

    Usage:
      push button

    """
    key = "push button"
    aliases = ["push", "press button", "press"]
    locks = "cmd:all()"

    def func(self):
        """
        Note that we choose to implement this with checking for
        if the lid is open/closed. This is because this command
        is likely to be tried regardless of the state of the lid.

        An alternative would be to make two versions of this command
        and tuck them into the cmdset linked to the Open and Closed
        lid-state respectively.

        """

        if self.obj.db.lid_open:
            string = "You reach out to press the big red button ..."
            string += "\n\nA BOOM! A bright light blinds you!"
            string += "\nThe world goes dark ..."
            self.caller.msg(string)
            self.caller.location.msg_contents("%s presses the button. BOOM! %s is blinded by a flash!" %
                                              (self.caller.name, self.caller.name), exclude=self.caller)
            # the button's method will handle all setup of scripts etc.
            self.obj.press_button(self.caller)
        else:
            string = "You cannot push the button - there is a glass lid covering it."
            self.caller.msg(string)


class CmdSmashGlass(Command):
    """
    smash glass

    Usage:
      smash glass

    Try to smash the glass of the button.
    """

    key = "smash glass"
    aliases = ["smash lid", "break lid", "smash"]
    locks = "cmd:all()"

    def func(self):
        """
        The lid won't open, but there is a small chance
        of causing the lamp to break.
        """
        rand = random.random()

        if rand < 0.2:
            string = "You smash your hand against the glass"
            string += " with all your might. The lid won't budge"
            string += " but you cause quite the tremor through the button's mount."
            string += "\nIt looks like the button's lamp stopped working for the time being."
            self.obj.lamp_works = False
        elif rand < 0.6:
            string = "You hit the lid hard. It doesn't move an inch."
        else:
            string = "You place a well-aimed fist against the glass of the lid."
            string += " Unfortunately all you get is a pain in your hand. Maybe"
            string += " you should just try to open the lid instead?"
        self.caller.msg(string)
        self.caller.location.msg_contents("%s tries to smash the glass of the button." %
                                    (self.caller.name), exclude=self.caller)


class CmdOpenLid(Command):
    """
    open lid

    Usage:
      open lid

    """

    key = "open lid"
    aliases = ["open button", 'open']
    locks = "cmd:all()"

    def func(self):
        "simply call the right function."

        if self.obj.db.lid_locked:
            self.caller.msg("This lid seems locked in place for the moment.")
            return

        string = "\nA ticking sound is heard, like a winding mechanism. Seems "
        string += "the lid will soon close again."
        self.caller.msg(string)
        self.caller.location.msg_contents("%s opens the lid of the button." %
                                        (self.caller.name), exclude=self.caller)
        # add the relevant cmdsets to button
        self.obj.cmdset.add(LidClosedCmdSet)
        # call object method
        self.obj.open_lid()


class CmdCloseLid(Command):
    """
    close the lid

    Usage:
      close lid

    Closes the lid of the red button.
    """

    key = "close lid"
    aliases = ["close"]
    locks = "cmd:all()"

    def func(self):
        "Close the lid"

        self.obj.close_lid()

        # this will clean out scripts dependent on lid being open.
        self.caller.msg("You close the button's lid. It clicks back into place.")
        self.caller.location.msg_contents("%s closes the button's lid." %
                                          (self.caller.name), exclude=self.caller)


class CmdBlindLook(Command):
    """
    Looking around in darkness

    Usage:
      look <obj>

    ... not that there's much to see in the dark.

    """

    key = "look"
    aliases = ["l", "get", "examine", "ex", "feel", "listen"]
    locks = "cmd:all()"

    def func(self):
        "This replaces all the senses when blinded."

        # we decide what to reply based on which command was
        # actually tried

        if self.cmdstring == "get":
            string = "You fumble around blindly without finding anything."
        elif self.cmdstring == "examine":
            string = "You try to examine your surroundings, but can't see a thing."
        elif self.cmdstring == "listen":
            string = "You are deafened by the boom."
        elif self.cmdstring == "feel":
            string = "You fumble around, hands outstretched. You bump your knee."
        else:
            # trying to look
            string = "You are temporarily blinded by the flash. "
            string += "Until it wears off, all you can do is feel around blindly."
        self.caller.msg(string)
        self.caller.location.msg_contents("%s stumbles around, blinded." %
                                    (self.caller.name), exclude=self.caller)


class CmdBlindHelp(Command):
    """
    Help function while in the blinded state

    Usage:
      help

    """
    key = "help"
    aliases = "h"
    locks = "cmd:all()"

    def func(self):
        "Give a message."
        self.caller.msg("You are beyond help ... until you can see again.")


#---------------------------------------------------------------
# Command sets for the red button
#---------------------------------------------------------------

# We next tuck these commands into their respective command sets.
# (note that we are overdoing the cdmset separation a bit here
# to show how it works).

class DefaultCmdSet(CmdSet):
    """
    The default cmdset always sits
    on the button object and whereas other
    command sets may be added/merge onto it
    and hide it, removing them will always
    bring it back. It's added to the object
    using obj.cmdset.add_default().
    """
    key = "RedButtonDefault"
    mergetype = "Union"  # this is default, we don't really need to put it here.

    def at_cmdset_creation(self):
        "Init the cmdset"
        self.add(CmdPush())


class LidClosedCmdSet(CmdSet):
    """
    A simple cmdset tied to the redbutton object.

    It contains the commands that launches the other
    command sets, making the red button a self-contained
    item (i.e. you don't have to manually add any
    scripts etc to it when creating it).
    """
    key = "LidClosedCmdSet"
    # default Union is used *except* if we are adding to a
    # cmdset named LidOpenCmdSet - this one we replace
    # completely.
    key_mergetype = {"LidOpenCmdSet": "Replace"}

    def at_cmdset_creation(self):
        "Populates the cmdset when it is instantiated."
        self.add(CmdNudge())
        self.add(CmdSmashGlass())
        self.add(CmdOpenLid())


class LidOpenCmdSet(CmdSet):
    """
    This is the opposite of the Closed cmdset.
    """
    key = "LidOpenCmdSet"
    # default Union is used *except* if we are adding to a
    # cmdset named LidClosedCmdSet - this one we replace
    # completely.
    key_mergetype = {"LidClosedCmdSet": "Replace"}

    def at_cmdset_creation(self):
        "setup the cmdset (just one command)"
        self.add(CmdCloseLid())


class BlindCmdSet(CmdSet):
    """
    This is the cmdset added to the *player* when
    the button is pushed.
    """
    key = "BlindCmdSet"
    # we want it to completely replace all normal commands
    # until the timed script removes it again.
    mergetype = "Replace"
    # we want to stop the player from walking around
    # in this blinded state, so we hide all exits too.
    # (channel commands will still work).
    no_exits = True  # keep player in the same room
    no_objs = True  # don't allow object commands

    def at_cmdset_creation(self):
        "Setup the blind cmdset"
        from src.commands.default.general import CmdSay
        from src.commands.default.general import CmdPose
        self.add(CmdSay())
        self.add(CmdPose())
        self.add(CmdBlindLook())
        self.add(CmdBlindHelp())

########NEW FILE########
__FILENAME__ = command
"""
Example command module template

Copy this module up one level to gamesrc/commands/ and name it as
befits your use.  You can then use it as a template to define your new
commands. To use them you also need to group them in a CommandSet (see
examples/cmdset.py)

"""

from ev import Command as BaseCommand
from ev import default_cmds
from ev import utils


class Command(BaseCommand):
    """
    Inherit from this if you want to create your own
    command styles. Note that Evennia's default commands
    use MuxCommand instead (next in this module)

    Note that the class's __doc__ string (this text) is
    used by Evennia to create the automatic help entry for
    the command, so make sure to document consistently here.

    """
    # these need to be specified

    key = "MyCommand"
    aliases = ["mycmd", "myc"]
    locks = "cmd:all()"
    help_category = "General"

    # auto_help = False      # uncomment to deactive auto-help for this command.
    # arg_regex = r"\s.*?|$" # optional regex detailing how the part after
                             # the cmdname must look to match this command.

    # (we don't implement hook method access() here, you don't need to
    #  modify that unless you want to change how the lock system works
    #  (in that case see src.commands.command.Command))

    def at_pre_cmd(self):
        """
        This hook is called before self.parse() on all commands
        """
        pass

    def parse(self):
        """
        This method is called by the cmdhandler once the command name
        has been identified. It creates a new set of member variables
        that can be later accessed from self.func() (see below)

        The following variables are available to us:
           # class variables:

           self.key - the name of this command ('mycommand')
           self.aliases - the aliases of this cmd ('mycmd','myc')
           self.locks - lock string for this command ("cmd:all()")
           self.help_category - overall category of command ("General")

           # added at run-time by cmdhandler:

           self.caller - the object calling this command
           self.cmdstring - the actual command name used to call this
                            (this allows you to know which alias was used,
                             for example)
           self.args - the raw input; everything following self.cmdstring.
           self.cmdset - the cmdset from which this command was picked. Not
                         often used (useful for commands like 'help' or to
                         list all available commands etc)
           self.obj - the object on which this command was defined. It is often
                         the same as self.caller.
        """
        pass

    def func(self):
        """
        This is the hook function that actually does all the work. It is called
         by the cmdhandler right after self.parser() finishes, and so has access
         to all the variables defined therein.
        """
        self.caller.msg("Command called!")

    def at_post_cmd(self):
        """
        This hook is called after self.func().
        """
        pass


class MuxCommand(default_cmds.MuxCommand):
    """
    This sets up the basis for a Evennia's 'MUX-like' command
    style. The idea is that most other Mux-related commands should
    just inherit from this and don't have to implement parsing of
    their own unless they do something particularly advanced.

    A MUXCommand command understands the following possible syntax:

      name[ with several words][/switch[/switch..]] arg1[,arg2,...] [[=|,] arg[,..]]

    The 'name[ with several words]' part is already dealt with by the
    cmdhandler at this point, and stored in self.cmdname. The rest is stored
    in self.args.

    The MuxCommand parser breaks self.args into its constituents and stores them
    in the following variables:
      self.switches = optional list of /switches (without the /)
      self.raw = This is the raw argument input, including switches
      self.args = This is re-defined to be everything *except* the switches
      self.lhs = Everything to the left of = (lhs:'left-hand side'). If
                 no = is found, this is identical to self.args.
      self.rhs: Everything to the right of = (rhs:'right-hand side').
                If no '=' is found, this is None.
      self.lhslist - self.lhs split into a list by comma
      self.rhslist - list of self.rhs split into a list by comma
      self.arglist = list of space-separated args (including '=' if it exists)

      All args and list members are stripped of excess whitespace around the
      strings, but case is preserved.
      """

    def func(self):
        """
        This is the hook function that actually does all the work. It is called
        by the cmdhandler right after self.parser() finishes, and so has access
        to all the variables defined therein.
        """
        # this can be removed in your child class, it's just
        # printing the ingoing variables as a demo.
        super(MuxCommand, self).func()

########NEW FILE########
__FILENAME__ = at_server_startstop
"""

At_server_startstop module template

Copy this module one level up, to gamesrc/conf/, name it what you
will and use it as a template for your modifications.

Then edit settings.AT_SERVER_STARTSTOP_MODULE to point to your new
module.

This module contains functions that are imported and called by the
server whenever it changes its running status. At the point these
functions are run, all applicable hooks on individual objects have
already been executed. The main purpose of this is module is to have a
safe place to initialize eventual custom modules that your game needs
to start up or load.

The module should define at least these global functions:

at_server_start()
at_server_stop()
at_server_reload_start()
at_server_reload_stop()
at_server_cold_start()
at_server_cold_stop()

"""


def at_server_start():
    """
    This is called every time the server starts up, regardless of
    how it was shut down.
    """
    pass


def at_server_stop():
    """
    This is called just before a server is shut down, regardless
    of it is fore a reload, reset or shutdown.
    """
    pass


def at_server_reload_start():
    """
    This is called only when server starts back up after a reload.
    """
    pass


def at_server_reload_stop():
    """
    This is called only time the server stops before a reload.
    """
    pass


def at_server_cold_start():
    """
    This is called only when the server starts "cold", i.e. after a
    shutdown or a reset.
    """
    pass


def at_server_cold_stop():
    """
    This is called only when the server goes down due to a shutdown or reset.
    """
    pass

########NEW FILE########
__FILENAME__ = connection_screens
"""
Connect screen module template

Copy this module one level up, to gamesrc/conf/, name it what
you want and modify it to your liking.

Then you set settings.CONNECTION_SCREEN_MODULE to point to your
new module.


 This module holds textual connection screen definitions.  All global
 string variables (only) in this module are read by Evennia and
 assumed to define a Connection screen.

 The names of the string variables doesn't matter (except they
 shouldn't start with _), but each should hold a string defining a
 connection screen - as seen when first connecting to the game
 (before having logged in).

 OBS - If there are more than one string variable viable in this
 module, a random one is picked!

 After adding new connection screens to this module you must either
 reboot or reload the server to make them available.

"""

from src.commands.connection_screen import DEFAULT_SCREEN

## uncomment these for the name and version
# from django.conf import settings
# from src.utils import utils

# # A copy of the default screen to modify

# CUSTOM_SCREEN = \
#"""{b=============================================================={n
# Welcome to {g%s{n, version %s!
#
# If you have an existing account, connect to it by typing:
#      {wconnect <username> <password>{n
# If you need to create an account, type (without the <>'s):
#      {wcreate <username> <password>{n
#
# If you have spaces in your username, enclose it in quotes.
# Enter {whelp{n for more info. {wlook{n will re-show this screen.
#{b=============================================================={n""" \
# % (settings.SERVERNAME, utils.get_evennia_version())

# # Mux-like alternative screen for contrib/mux_login.py

# MUX_SCREEN = \
# """{b=============================================================={n
# Welcome to {g%s{n, version %s!
#
# If you have an existing account, connect to it by typing:
#      {wconnect <email> <password>{n
# If you need to create an account, type (without the <>'s):
#      {wcreate \"<username>\" <email> <password>{n
#
# Enter {whelp{n for more info. {wlook{n will re-load this screen.
#{b=============================================================={n""" \
# % (settings.SERVERNAME, utils.get_evennia_version())

# # Menu login minimal header for contrib/menu_login.py

# MENU_SCREEN = \
# """{b=============================================================={n
#  Welcome to {g%s{n, version %s!
# {b=============================================================={n""" \
# % (settings.SERVERNAME, utils.get_evennia_version())

########NEW FILE########
__FILENAME__ = lockfuncs
"""

Lockfuncs module template

Copy this module one level up, to gamesrc/conf/, name it what
you will and edit it to your liking.

Then add the new module's path to the end of the tuple
defined in settings.LOCK_FUNC_MODULES.

All functions defined globally in this module are assumed to be
available for use in lockstrings to determine access. See
http://code.google.com/p/evennia/wiki/Locks

A lock function is always called with two arguments, accessing_obj and
accessed_obj, followed by any number of arguments. All possible
arguments should be handled (excess ones calling magic (*args,
**kwargs) to avoid errors). The lock function should handle all
eventual tracebacks by logging the error and returning False.

See many more examples of lock functions in src.locks.lockfuncs.

"""


def myfalse(accessing_obj, accessed_obj, *args, **kwargs):
    """
    called in lockstring with myfalse().
    A simple logger that always returns false. Prints to stdout
    for simplicity, should use utils.logger for real operation.
    """
    print "%s tried to access %s. Access denied." % (accessing_obj, accessed_obj)
    return False

########NEW FILE########
__FILENAME__ = mssp
"""

MSSP module template

Copy this module one level up, to gamesrc/conf/, name it
what you want and edit it to your satisfaction.

Then change settings.MSSP_META_MODULE to point to your new module.

 MSSP (Mud Server Status Protocol) meta information

 MUD website listings (that you have registered with) can use this
 information to keep up-to-date with your game stats as you change
 them. Also number of currently active players and uptime will
 automatically be reported. You don't have to fill in everything
 (and most are not used by all crawlers); leave the default
 if so needed. You need to @reload the game before updated
 information is made available to crawlers (reloading does not
 affect uptime).
"""

MSSPTable =  {

    # Required fieldss

    "NAME":               "Evennia",

    # Generic

    "CRAWL DELAY":        "-1",     # limit how often crawler updates the listing. -1 for no limit

    "HOSTNAME":           "",       # current or new hostname
    "PORT":               ["4000"], # most important port should be last in list
    "CODEBASE":           "Evennia",
    "CONTACT":            "",       # email for contacting the mud
    "CREATED":            "",       # year MUD was created
    "ICON":               "",       # url to icon 32x32 or larger; <32kb.
    "IP":                 "",       # current or new IP address
    "LANGUAGE":           "",       # name of language used, e.g. English
    "LOCATION":           "",       # full English name of server country
    "MINIMUM AGE":        "0",      # set to 0 if not applicable
    "WEBSITE":            "www.evennia.com",

    # Categorisation

    "FAMILY":             "Custom", # evennia goes under 'Custom'
    "GENRE":              "None",   # Adult, Fantasy, Historical, Horror, Modern, None, or Science Fiction
    "GAMEPLAY":           "",       # Adventure, Educational, Hack and Slash, None,
                                      # Player versus Player, Player versus Environment,
                                      # Roleplaying, Simulation, Social or Strategy
    "STATUS":             "Open Beta",  # Alpha, Closed Beta, Open Beta, Live
    "GAMESYSTEM":         "Custom", # D&D, d20 System, World of Darkness, etc. Use Custom if homebrew
    "INTERMUD":           "IMC2",   # evennia supports IMC2.
    "SUBGENRE":           "None",   # LASG, Medieval Fantasy, World War II, Frankenstein,
                                      # Cyberpunk, Dragonlance, etc. Or None if not available.

    # World

    "AREAS":              "0",
    "HELPFILES":          "0",
    "MOBILES":            "0",
    "OBJECTS":            "0",
    "ROOMS":              "0",      # use 0 if room-less
    "CLASSES":            "0",      # use 0 if class-less
    "LEVELS":             "0",      # use 0 if level-less
    "RACES":              "0",      # use 0 if race-less
    "SKILLS":             "0",      # use 0 if skill-less

    # Protocols set to 1 or 0)

    "ANSI":               "1",
    "GMCP":               "0",
    "MCCP":               "0",
    "MCP":                "0",
    "MSDP":               "0",
    "MSP":                "0",
    "MXP":                "0",
    "PUEBLO":             "0",
    "UTF-8":              "1",
    "VT100":              "0",
    "XTERM 256 COLORS":   "0",

    # Commercial set to 1 or 0)

    "PAY TO PLAY":        "0",
    "PAY FOR PERKS":      "0",

    # Hiring  set to 1 or 0)

    "HIRING BUILDERS":    "0",
    "HIRING CODERS":      "0",

    # Extended variables

    # World

    "DBSIZE":             "0",
    "EXITS":              "0",
    "EXTRA DESCRIPTIONS": "0",
    "MUDPROGS":           "0",
    "MUDTRIGS":           "0",
    "RESETS":             "0",

    # Game  (set to 1 or 0, or one of the given alternatives)

    "ADULT MATERIAL":     "0",
    "MULTICLASSING":      "0",
    "NEWBIE FRIENDLY":    "0",
    "PLAYER CITIES":      "0",
    "PLAYER CLANS":       "0",
    "PLAYER CRAFTING":    "0",
    "PLAYER GUILDS":      "0",
    "EQUIPMENT SYSTEM":   "None",  # "None", "Level", "Skill", "Both"
    "MULTIPLAYING":       "None",  # "None", "Restricted", "Full"
    "PLAYERKILLING":      "None",  # "None", "Restricted", "Full"
    "QUEST SYSTEM":       "None",  # "None", "Immortal Run", "Automated", "Integrated"
    "ROLEPLAYING":        "None",  # "None", "Accepted", "Encouraged", "Enforced"
    "TRAINING SYSTEM":    "None",  # "None", "Level", "Skill", "Both"
    "WORLD ORIGINALITY":  "None",  # "All Stock", "Mostly Stock", "Mostly Original", "All Original"

    # Protocols (only change if you added/removed something manually)

    "ATCP":               "0",
    "MSDP":               "0",
    "MCCP":               "1",
    "SSL":                "1",
    "UTF-8":              "1",
    "ZMP":                "0",
    "XTERM 256 COLORS":   "0"}

########NEW FILE########
__FILENAME__ = oobfuncs
"""
OOB configuration.

This module should be included in (or replace) the
default module set in settings.OOB_PLUGIN_MODULES

All functions defined in this module are made available
to be called by the OOB handler.

See src/server/oob_msdp.py for more information.

    function execution - the oob protocol can execute a function directly on
                         the server. The available functions must be defined
                         as global functions via settings.OOB_PLUGIN_MODULES.
    repeat func execution - the oob protocol can request a given function be
                            executed repeatedly at a regular interval. This
                            uses an internal script pool.
    tracking - the oob protocol can request Evennia to track changes to
               fields on objects, as well as changes in Attributes. This is
               done by dynamically adding tracker-objects on entities. The
               behaviour of those objects can be customized via
               settings.OOB_PLUGIN_MODULES.

oob functions have the following call signature:
    function(caller, session, *args, **kwargs)

oob trackers should inherit from the OOBTracker class in src/server.oob_msdp.py
    and implement a minimum of the same functionality.

a global function oob_error will be used as optional error management.

"""

# import the contents of the default msdp module
from src.server/oob_msdp import *


########NEW FILE########
__FILENAME__ = portal_services_plugin
"""

This plugin module can define user-created services for the Server to start.

To use, copy this module up one level to game/gamesrc/conf/ and set
settings.SERVER_SERVICES_PLUGIN_MODULE to point to this module.

This module must handle all imports and setups required to start a twisted
services (see examples in src/server/server.py). It must also contain a
function start_plugin_services(application). Evennia will call this function
with the main Server application (so your services can be added to it). The
function should not return anything. Plugin services are started last in
the Server startup process.

"""


def start_plugin_services(server):
    """
    This hook is called by Evennia, last in the Server startup process.

    server - a reference to the main server application.
    """
    pass

########NEW FILE########
__FILENAME__ = server_services_plugin
"""

This plugin module can define user-created services for the Portal to start.

To use, copy this module up one level to game/gamesrc/conf/ and set
settings.PORTAL_SERVICES_PLUGIN_MODULE to point to this module.

This module must handle all imports and setups required to start a twisted
service (see examples in src/server/server.py). It must also contain a
function start_plugin_services(application). Evennia will call this function
with the main Portal application (so your services can be added to it). The
function should not return anything. Plugin services are started last in
the Portal startup process.

"""


def start_plugin_services(portal):
    """
    This hook is called by Evennia, last in the Portal startup process.

    portal - a reference to the main portal application.
    """
    pass

########NEW FILE########
__FILENAME__ = character
"""

Template for Characters

Copy this module up one level and name it as you like, then
use it as a template to create your own Character class.

To make new logins default to creating characters
of your new type, change settings.BASE_CHARACTER_TYPECLASS to point to
your new class, e.g.

settings.BASE_CHARACTER_TYPECLASS = "game.gamesrc.objects.mychar.MyChar"

Note that objects already created in the database will not notice
this change, you have to convert them manually e.g. with the
@typeclass command.

"""
from ev import Character as DefaultCharacter


class Character(DefaultCharacter):
    """
    The Character is like any normal Object (see example/object.py for
    a list of properties and methods), except it actually implements
    some of its hook methods to do some work:

    at_basetype_setup - always assigns the default_cmdset to this object type
                    (important!)sets locks so character cannot be picked up
                    and its commands only be called by itself, not anyone else.
                    (to change things, use at_object_creation() instead)
    at_after_move - launches the "look" command
    at_post_puppet(player) -  when Player disconnects from the Character, we
                    store the current location, so the "unconnected" character
                    object does not need to stay on grid but can be given a
                    None-location while offline.
    at_pre_puppet - just before Player re-connects, retrieves the character's
                    old location and puts it back on the grid with a "charname
                    has connected" message echoed to the room

    """
    pass

########NEW FILE########
__FILENAME__ = exit
"""

Template module for Exits

Copy this module up one level and name it as you like, then
use it as a template to create your own Exits.

To make the default commands (such as @dig/@open) default to creating exits
of your new type, change settings.BASE_EXIT_TYPECLASS to point to
your new class, e.g.

settings.BASE_EXIT_TYPECLASS = "game.gamesrc.objects.myexit.MyExit"

Note that objects already created in the database will not notice
this change, you have to convert them manually e.g. with the
@typeclass command.

"""
from ev import Exit as DefaultExit


class Exit(DefaultExit):
    """
    Exits are connectors between rooms. Exits are normal Objects except
    they defines the 'destination' property. It also does work in the
    following methods:

     basetype_setup() - sets default exit locks (to change, use at_object_creation instead)
     at_cmdset_get() - this auto-creates and caches a command and a command set on itself
                     with the same name as the Exit object. This
                     allows users to use the exit by only giving its
                     name alone on the command line.
     at_failed_traverse() - gives a default error message ("You cannot
                            go there") if exit traversal fails and an
                            attribute err_traverse is not defined.

    Relevant hooks to overload (compared to other types of Objects):
    at_before_traverse(traveller) - called just before traversing
    at_after_traverse(traveller, source_loc) - called just after traversing
    at_failed_traverse(traveller) - called if traversal failed for some reason. Will
                                    not be called if the attribute 'err_traverse' is
                                    defined, in which case that will simply be echoed.
    """
    pass

########NEW FILE########
__FILENAME__ = object
"""

Template for Objects

Copy this module up one level and name it as you like, then
use it as a template to create your own Objects.

To make the default commands default to creating objects of your new
type (and also change the "fallback" object used when typeclass
creation fails), change settings.BASE_OBJECT_TYPECLASS to point to
your new class, e.g.

settings.BASE_OBJECT_TYPECLASS = "game.gamesrc.objects.myobj.MyObj"

Note that objects already created in the database will not notice
this change, you have to convert them manually e.g. with the
@typeclass command.

"""
from ev import Object as DefaultObject


class Object(DefaultObject):
    """
    This is the root typeclass object, implementing an in-game Evennia
    game object, such as having a location, being able to be
    manipulated or looked at, etc. If you create a new typeclass, it
    must always inherit from this object (or any of the other objects
    in this file, since they all actually inherit from BaseObject, as
    seen in src.object.objects).

    The BaseObject class implements several hooks tying into the game
    engine. By re-implementing these hooks you can control the
    system. You should never need to re-implement special Python
    methods, such as __init__ and especially never __getattribute__ and
    __setattr__ since these are used heavily by the typeclass system
    of Evennia and messing with them might well break things for you.


    * Base properties defined/available on all Objects

     key (string) - name of object
     name (string)- same as key
     aliases (list of strings) - aliases to the object. Will be saved to
                           database as AliasDB entries but returned as strings.
     dbref (int, read-only) - unique #id-number. Also "id" can be used.
     dbobj (Object, read-only) - link to database model. dbobj.typeclass points
                                  back to this class
     typeclass (Object, read-only) - this links back to this class as an
                         identified only. Use self.swap_typeclass() to switch.
     date_created (string) - time stamp of object creation
     permissions (list of strings) - list of permission strings

     player (Player) - controlling player (if any, only set together with
                       sessid below)
     sessid (int, read-only) - session id (if any, only set together with
                       player above)
     location (Object) - current location. Is None if this is a room
     home (Object) - safety start-location
     sessions (list of Sessions, read-only) - returns all sessions connected
                       to this object
     has_player (bool, read-only)- will only return *connected* players
     contents (list of Objects, read-only) - returns all objects inside this
                       object (including exits)
     exits (list of Objects, read-only) - returns all exits from this
                       object, if any
     destination (Object) - only set if this object is an exit.
     is_superuser (bool, read-only) - True/False if this user is a superuser

    * Handlers available

     locks - lock-handler: use locks.add() to add new lock strings
     db - attribute-handler: store/retrieve database attributes on this
                             self.db.myattr=val, val=self.db.myattr
     ndb - non-persistent attribute handler: same as db but does not create
                             a database entry when storing data
     scripts - script-handler. Add new scripts to object with scripts.add()
     cmdset - cmdset-handler. Use cmdset.add() to add new cmdsets to object
     nicks - nick-handler. New nicks with nicks.add().

    * Helper methods (see src.objects.objects.py for full headers)

     search(ostring, global_search=False, attribute_name=None,
             use_nicks=False, location=None, ignore_errors=False, player=False)
     execute_cmd(raw_string)
     msg(text=None, **kwargs)
     msg_contents(message, exclude=None, from_obj=None, **kwargs)
     move_to(destination, quiet=False, emit_to_obj=None, use_destination=True)
     copy(new_key=None)
     delete()
     is_typeclass(typeclass, exact=False)
     swap_typeclass(new_typeclass, clean_attributes=False, no_default=True)
     access(accessing_obj, access_type='read', default=False)
     check_permstring(permstring)

    * Hooks (these are class methods, so args should start with self):

     basetype_setup()     - only called once, used for behind-the-scenes
                            setup. Normally not modified.
     basetype_posthook_setup() - customization in basetype, after the object
                            has been created; Normally not modified.

     at_object_creation() - only called once, when object is first created.
                            Object customizations go here.
     at_object_delete() - called just before deleting an object. If returning
                            False, deletion is aborted. Note that all objects
                            inside a deleted object are automatically moved
                            to their <home>, they don't need to be removed here.

     at_init()            - called whenever typeclass is cached from memory,
                            at least once every server restart/reload
     at_cmdset_get()      - this is called just before the command handler
                            requests a cmdset from this object
     at_pre_puppet(player)- (player-controlled objects only) called just
                            before puppeting
     at_post_puppet()     - (player-controlled objects only) called just
                            after completing connection player<->object
     at_pre_unpuppet()    - (player-controlled objects only) called just
                            before un-puppeting
     at_post_unpuppet(player) - (player-controlled objects only) called just
                            after disconnecting player<->object link
     at_server_reload()   - called before server is reloaded
     at_server_shutdown() - called just before server is fully shut down

     at_access(result, accessing_obj, access_type) - called with the result
                            of a lock access check on this object. Return value
                            does not affect check result.

     at_before_move(destination)             - called just before moving object
                        to the destination. If returns False, move is cancelled.
     announce_move_from(destination)         - called in old location, just
                        before move, if obj.move_to() has quiet=False
     announce_move_to(source_location)       - called in new location, just
                        after move, if obj.move_to() has quiet=False
     at_after_move(source_location)          - always called after a move has
                        been successfully performed.
     at_object_leave(obj, target_location)   - called when an object leaves
                        this object in any fashion
     at_object_receive(obj, source_location) - called when this object receives
                        another object

     at_before_traverse(traversing_object)                 - (exit-objects only)
                              called just before an object traverses this object
     at_after_traverse(traversing_object, source_location) - (exit-objects only)
                              called just after a traversal has happened.
     at_failed_traverse(traversing_object)      - (exit-objects only) called if
                       traversal fails and property err_traverse is not defined.

     at_msg_receive(self, msg, from_obj=None, **kwargs) - called when a message
                             (via self.msg()) is sent to this obj.
                             If returns false, aborts send.
     at_msg_send(self, msg, to_obj=None, **kwargs) - called when this objects
                             sends a message to someone via self.msg().

     return_appearance(looker) - describes this object. Used by "look"
                                 command by default
     at_desc(looker=None)      - called by 'look' whenever the
                                 appearance is requested.
     at_get(getter)            - called after object has been picked up.
                                 Does not stop pickup.
     at_drop(dropper)          - called when this object has been dropped.
     at_say(speaker, message)  - by default, called if an object inside this
                                 object speaks

     """
    pass

########NEW FILE########
__FILENAME__ = player
"""

Template module for Players

Copy this module up one level and name it as you like, then
use it as a template to create your own Player class.

To make the default account login default to using a Player
of your new type, change settings.BASE_PLAYER_TYPECLASS to point to
your new class, e.g.

settings.BASE_PLAYER_TYPECLASS = "game.gamesrc.objects.myplayer.MyPlayer"

Note that objects already created in the database will not notice
this change, you have to convert them manually e.g. with the
@typeclass command.

"""
from ev import Player as DefaultPlayer


class Player(DefaultPlayer):
    """
    This class describes the actual OOC player (i.e. the user connecting
    to the MUD). It does NOT have visual appearance in the game world (that
    is handled by the character which is connected to this). Comm channels
    are attended/joined using this object.

    It can be useful e.g. for storing configuration options for your game, but
    should generally not hold any character-related info (that's best handled
    on the character level).

    Can be set using BASE_PLAYER_TYPECLASS.


    * available properties

     key (string) - name of player
     name (string)- wrapper for user.username
     aliases (list of strings) - aliases to the object. Will be saved to database as AliasDB entries but returned as strings.
     dbref (int, read-only) - unique #id-number. Also "id" can be used.
     dbobj (Player, read-only) - link to database model. dbobj.typeclass points back to this class
     typeclass (Player, read-only) - this links back to this class as an identified only. Use self.swap_typeclass() to switch.
     date_created (string) - time stamp of object creation
     permissions (list of strings) - list of permission strings

     user (User, read-only) - django User authorization object
     obj (Object) - game object controlled by player. 'character' can also be used.
     sessions (list of Sessions) - sessions connected to this player
     is_superuser (bool, read-only) - if the connected user is a superuser

    * Handlers

     locks - lock-handler: use locks.add() to add new lock strings
     db - attribute-handler: store/retrieve database attributes on this self.db.myattr=val, val=self.db.myattr
     ndb - non-persistent attribute handler: same as db but does not create a database entry when storing data
     scripts - script-handler. Add new scripts to object with scripts.add()
     cmdset - cmdset-handler. Use cmdset.add() to add new cmdsets to object
     nicks - nick-handler. New nicks with nicks.add().

    * Helper methods

     msg(text=None, **kwargs)
     swap_character(new_character, delete_old_character=False)
     execute_cmd(raw_string, sessid=None)
     search(ostring, global_search=False, attribute_name=None, use_nicks=False, location=None, ignore_errors=False, player=False)
     is_typeclass(typeclass, exact=False)
     swap_typeclass(new_typeclass, clean_attributes=False, no_default=True)
     access(accessing_obj, access_type='read', default=False)
     check_permstring(permstring)

    * Hook methods (when re-implementation, remember methods need to have self as first arg)

     basetype_setup()
     at_player_creation()

     - note that the following hooks are also found on Objects and are
       usually handled on the character level:

     at_init()
     at_cmdset_get()
     at_first_login()
     at_post_login(sessid=None)
     at_disconnect()
     at_message_receive()
     at_message_send()
     at_server_reload()
     at_server_shutdown()

    """
    pass

########NEW FILE########
__FILENAME__ = red_button
"""

This is a more advanced example object. It combines functions from
script.examples as well as commands.examples to make an interactive
button typeclass.

Create this button with

 @create/drop examples.red_button.RedButton

Note that you must drop the button before you can see its messages!
"""
import random
from ev import Object
from game.gamesrc.scripts.examples import red_button_scripts as scriptexamples
from game.gamesrc.commands.examples import cmdset_red_button as cmdsetexamples

#
# Definition of the object itself
#


class RedButton(Object):
    """
    This class describes an evil red button.  It will use the script
    definition in game/gamesrc/events/example.py to blink at regular
    intervals.  It also uses a series of script and commands to handle
    pushing the button and causing effects when doing so.

    The following attributes can be set on the button:
     desc_lid_open - description when lid is open
     desc_lid_closed - description when lid is closed
     desc_lamp_broken - description when lamp is broken

    """
    def at_object_creation(self):
        """
        This function is called when object is created. Use this
        instead of e.g. __init__.
        """
        # store desc (default, you can change this at creation time)
        desc = "This is a large red button, inviting yet evil-looking. "
        desc += "A closed glass lid protects it."
        self.db.desc = desc

        # We have to define all the variables the scripts
        # are checking/using *before* adding the scripts or
        # they might be deactivated before even starting!
        self.db.lid_open = False
        self.db.lamp_works = True
        self.db.lid_locked = False

        self.cmdset.add_default(cmdsetexamples.DefaultCmdSet, permanent=True)

        # since the cmdsets relevant to the button are added 'on the fly',
        # we need to setup custom scripts to do this for us (also, these scripts
        # check so they are valid (i.e. the lid is actually still closed)).
        # The AddClosedCmdSet script makes sure to add the Closed-cmdset.
        self.scripts.add(scriptexamples.ClosedLidState)
        # the script EventBlinkButton makes the button blink regularly.
        self.scripts.add(scriptexamples.BlinkButtonEvent)

    # state-changing methods

    def open_lid(self):
        """
        Opens the glass lid and start the timer so it will soon close
        again.
        """

        if self.db.lid_open:
            return
        desc = self.db.desc_lid_open
        if not desc:
            desc = "This is a large red button, inviting yet evil-looking. "
            desc += "Its glass cover is open and the button exposed."
        self.db.desc = desc
        self.db.lid_open = True

        # with the lid open, we validate scripts; this will clean out
        # scripts that depend on the lid to be closed.
        self.scripts.validate()
        # now add new scripts that define the open-lid state
        self.scripts.add(scriptexamples.OpenLidState)
        # we also add a scripted event that will close the lid after a while.
        # (this one cleans itself after being called once)
        self.scripts.add(scriptexamples.CloseLidEvent)

    def close_lid(self):
        """
        Close the glass lid. This validates all scripts on the button,
        which means that scripts only being valid when the lid is open
        will go away automatically.
        """

        if not self.db.lid_open:
            return
        desc = self.db.desc_lid_closed
        if not desc:
            desc = "This is a large red button, inviting yet evil-looking. "
            desc += "Its glass cover is closed, protecting it."
        self.db.desc = desc
        self.db.lid_open = False

        # clean out scripts depending on lid to be open
        self.scripts.validate()
        # add scripts related to the closed state
        self.scripts.add(scriptexamples.ClosedLidState)

    def break_lamp(self, feedback=True):
        """
        Breaks the lamp in the button, stopping it from blinking.

        """
        self.db.lamp_works = False
        desc = self.db.desc_lamp_broken
        if not desc:
            self.db.desc += "\nThe big red button has stopped blinking for the time being."
        else:
            self.db.desc = desc

        if feedback and self.location:
            self.location.msg_contents("The lamp flickers, the button going dark.")
        self.scripts.validate()

    def press_button(self, pobject):
        """
        Someone was foolish enough to press the button!
        pobject - the person pressing the button
        """
        # deactivate the button so it won't flash/close lid etc.
        self.scripts.add(scriptexamples.DeactivateButtonEvent)
        # blind the person pressing the button. Note that this
        # script is set on the *character* pressing the button!
        pobject.scripts.add(scriptexamples.BlindedState)

    # script-related methods

    def blink(self):
        """
        The script system will regularly call this
        function to make the button blink. Now and then
        it won't blink at all though, to add some randomness
        to how often the message is echoed.
        """
        loc = self.location
        if loc:
            rand = random.random()
            if rand < 0.2:
                string = "The red button flashes briefly."
            elif rand < 0.4:
                string = "The red button blinks invitingly."
            elif rand < 0.6:
                string = "The red button flashes. You know you wanna push it!"
            else:
                # no blink
                return
            loc.msg_contents(string)

########NEW FILE########
__FILENAME__ = room
"""

Template module for Rooms

Copy this module up one level and name it as you like, then
use it as a template to create your own Objects.

To make the default commands (such as @dig) default to creating rooms
of your new type, change settings.BASE_ROOM_TYPECLASS to point to
your new class, e.g.

settings.BASE_ROOM_TYPECLASS = "game.gamesrc.objects.myroom.MyRoom"

Note that objects already created in the database will not notice
this change, you have to convert them manually e.g. with the
@typeclass command.

"""

from ev import Room as DefaultRoom


class Room(DefaultRoom):
    """
    Rooms are like any Object, except their location is None
    (which is default). They also use basetype_setup() to
    add locks so they cannot be puppeted or picked up.
    (to change that, use at_object_creation instead)

    See examples/object.py for a list of
    properties and methods available on all Objects.
    """
    pass

########NEW FILE########
__FILENAME__ = bodyfunctions
"""
Example script for testing. This adds a simple timer that
has your character make observations and noices at irregular
intervals.

To test, use
  @script me = examples.bodyfunctions.BodyFunctions

The script will only send messages to the object it
is stored on, so make sure to put it on yourself
or you won't see any messages!

"""
import random
from ev import Script

class BodyFunctions(Script):
    """
    This class defines the script itself
    """

    def at_script_creation(self):
        self.key = "bodyfunction"
        self.desc = "Adds various timed events to a character."
        self.interval = 20  # seconds
        #self.repeats = 5  # repeat only a certain number of times
        self.start_delay = True  # wait self.interval until first call
        #self.persistent = True

    def at_repeat(self):
        """
        This gets called every self.interval seconds. We make
        a random check here so as to only return 33% of the time.
        """

        if random.random() < 0.66:
            # no message this time
            return
        rand = random.random()
        # return a random message
        if rand < 0.1:
            string = "You tap your foot, looking around."
        elif rand < 0.2:
            string = "You have an itch. Hard to reach too."
        elif rand < 0.3:
            string = "You think you hear someone behind you. ... but when you look there's noone there."
        elif rand < 0.4:
            string = "You inspect your fingernails. Nothing to report."
        elif rand < 0.5:
            string = "You cough discreetly into your hand."
        elif rand < 0.6:
            string = "You scratch your head, looking around."
        elif rand < 0.7:
            string = "You blink, forgetting what it was you were going to do."
        elif rand < 0.8:
            string = "You feel lonely all of a sudden."
        elif rand < 0.9:
            string = "You get a great idea. Of course you won't tell anyone."
        else:
            string = "You suddenly realize how much you love Evennia!"

        # echo the message to the object
        self.obj.msg(string)

########NEW FILE########
__FILENAME__ = red_button_scripts
"""
Example of scripts.

These are scripts intended for a particular object - the
red_button object type in gamesrc/types/examples. A few variations
on uses of scripts are included.

"""
from ev import Script
from game.gamesrc.commands.examples import cmdset_red_button as cmdsetexamples

#
# Scripts as state-managers
#
# Scripts have many uses, one of which is to statically
# make changes when a particular state of an object changes.
# There is no "timer" involved in this case (although there could be),
# whenever the script determines it is "invalid", it simply shuts down
# along with all the things it controls.
#
# To show as many features as possible of the script and cmdset systems,
# we will use three scripts controlling one state each of the red_button,
# each with its own set of commands, handled by cmdsets - one for when
# the button has its lid open, and one for when it is closed and a
# last one for when the player pushed the button and gets blinded by
# a bright light. The last one also has a timer component that allows it
# to remove itself after a while (and the player recovers their eyesight).

class ClosedLidState(Script):
    """
    This manages the cmdset for the "closed" button state. What this
    means is that while this script is valid, we add the RedButtonClosed
    cmdset to it (with commands like open, nudge lid etc)
    """
    def at_script_creation(self):
        "Called when script first created."
        self.desc = "Script that manages the closed-state cmdsets for red button."
        self.persistent = True

    def at_start(self):
        """
        This is called once every server restart, so we want to add the
        (memory-resident) cmdset to the object here. is_valid is automatically
        checked so we don't need to worry about adding the script to an
        open lid.
        """
        #All we do is add the cmdset for the closed state.
        self.obj.cmdset.add(cmdsetexamples.LidClosedCmdSet)

    def is_valid(self):
        """
        The script is only valid while the lid is closed.
        self.obj is the red_button on which this script is defined.
        """
        return not self.obj.db.lid_open

    def at_stop(self):
        """
        When the script stops we must make sure to clean up after us.

        """
        self.obj.cmdset.delete(cmdsetexamples.LidClosedCmdSet)


class OpenLidState(Script):
    """
    This manages the cmdset for the "open" button state. This will add
    the RedButtonOpen
    """
    def at_script_creation(self):
        "Called when script first created."
        self.desc = "Script that manages the opened-state cmdsets for red button."
        self.persistent = True

    def at_start(self):
        """
        This is called once every server restart, so we want to add the
        (memory-resident) cmdset to the object here. is_valid is
        automatically checked, so we don't need to worry about
        adding the cmdset to a closed lid-button.
        """
        #print "In Open at_start (should add cmdset)"
        self.obj.cmdset.add(cmdsetexamples.LidOpenCmdSet)

    def is_valid(self):
        """
        The script is only valid while the lid is open.
        self.obj is the red_button on which this script is defined.
        """
        return self.obj.db.lid_open

    def at_stop(self):
        """
        When the script stops (like if the lid is closed again)
        we must make sure to clean up after us.
        """
        self.obj.cmdset.delete(cmdsetexamples.LidOpenCmdSet)


class BlindedState(Script):
    """
    This is a timed state.

    This adds a (very limited) cmdset TO THE PLAYER, during a certain time,
    after which the script will close and all functions are
    restored. It's up to the function starting the script to actually
    set it on the right player object.
    """
    def at_script_creation(self):
        """
        We set up the script here.
        """
        self.key = "temporary_blinder"
        self.desc = "Temporarily blinds the player for a little while."
        self.interval = 20  # seconds
        self.start_delay = True  # we don't want it to stop until after 20s.
        self.repeats = 1  # this will go away after interval seconds.
        self.persistent = False  # we will ditch this if server goes down

    def at_start(self):
        """
        We want to add the cmdset to the linked object.

        Note that the RedButtonBlind cmdset is defined to completly
        replace the other cmdsets on the stack while it is active
        (this means that while blinded, only operations in this cmdset
        will be possible for the player to perform). It is however
        not persistent, so should there be a bug in it, we just need
        to restart the server to clear out of it during development.
        """
        self.obj.cmdset.add(cmdsetexamples.BlindCmdSet)

    def at_stop(self):
        """
        It's important that we clear out that blinded cmdset
        when we are done!
        """
        self.obj.msg("You blink feverishly as your eyesight slowly returns.")
        self.obj.location.msg_contents("%s seems to be recovering their eyesight."
                                       % self.obj.name,
                                       exclude=self.obj)
        self.obj.cmdset.delete()  # this will clear the latest added cmdset,
                                  # (which is the blinded one).


#
# Timer/Event-like Scripts
#
# Scripts can also work like timers, or "events". Below we
# define three such timed events that makes the button a little
# more "alive" - one that makes the button blink menacingly, another
# that makes the lid covering the button slide back after a while.
#

class CloseLidEvent(Script):
    """
    This event closes the glass lid over the button
    some time after it was opened. It's a one-off
    script that should be started/created when the
    lid is opened.
    """
    def at_script_creation(self):
        """
        Called when script object is first created. Sets things up.
        We want to have a lid on the button that the user can pull
        aside in order to make the button 'pressable'. But after a set
        time that lid should auto-close again, making the button safe
        from pressing (and deleting this command).
        """
        self.key = "lid_closer"
        self.desc = "Closes lid on a red buttons"
        self.interval = 20  # seconds
        self.start_delay = True  # we want to pospone the launch.
        self.repeats = 1  # we only close the lid once
        self.persistent = True  # even if the server crashes in those 20 seconds,
                                # the lid will still close once the game restarts.

    def is_valid(self):
        """
        This script can only operate if the lid is open; if it
        is already closed, the script is clearly invalid.

        Note that we are here relying on an self.obj being
        defined (and being a RedButton object) - this we should be able to
        expect since this type of script is always tied to one individual
        red button object and not having it would be an error.
        """
        return self.obj.db.lid_open

    def at_repeat(self):
        """
        Called after self.interval seconds. It closes the lid. Before this method is
        called, self.is_valid() is automatically checked, so there is no need to
        check this manually.
        """
        self.obj.close_lid()

class BlinkButtonEvent(Script):
    """
    This timed script lets the button flash at regular intervals.
    """
    def at_script_creation(self):
        """
        Sets things up. We want the button's lamp to blink at
        regular intervals, unless it's broken (can happen
        if you try to smash the glass, say).
        """
        self.key = "blink_button"
        self.desc = "Blinks red buttons"
        self.interval = 35  #seconds
        self.start_delay = False  #blink right away
        self.persistent = True  #keep blinking also after server reboot

    def is_valid(self):
        """
        Button will keep blinking unless it is broken.
        """
        #print "self.obj.db.lamp_works:", self.obj.db.lamp_works
        return self.obj.db.lamp_works

    def at_repeat(self):
        """
        Called every self.interval seconds. Makes the lamp in
        the button blink.
        """
        self.obj.blink()

class DeactivateButtonEvent(Script):
    """
    This deactivates the button for a short while (it won't blink, won't
    close its lid etc). It is meant to be called when the button is pushed
    and run as long as the blinded effect lasts. We cannot put these methods
    in the AddBlindedCmdSet script since that script is defined on the *player*
    whereas this one must be defined on the *button*.
    """
    def at_script_creation(self):
        """
        Sets things up.
        """
        self.key = "deactivate_button"
        self.desc = "Deactivate red button temporarily"
        self.interval = 21  #seconds
        self.start_delay = True  # wait with the first repeat for self.interval seconds.
        self.persistent = True
        self.repeats = 1  # only do this once

    def at_start(self):
        """
        Deactivate the button. Observe that this method is always
        called directly, regardless of the value of self.start_delay
        (that just controls when at_repeat() is called)
        """
        # closing the lid will also add the ClosedState script
        self.obj.close_lid()
        # lock the lid so other players can't access it until the
        # first one's effect has worn off.
        self.obj.db.lid_locked = True
        # breaking the lamp also sets a correct desc
        self.obj.break_lamp(feedback=False)

    def at_repeat(self):
        """
        When this is called, reset the functionality of the button.
        """
        # restore button's desc.

        self.obj.db.lamp_works = True
        desc = "This is a large red button, inviting yet evil-looking. "
        desc += "Its glass cover is closed, protecting it."
        self.db.desc = desc
        # re-activate the blink button event.
        self.obj.scripts.add(BlinkButtonEvent)
        # unlock the lid
        self.obj.db.lid_locked = False
        self.obj.scripts.validate()

########NEW FILE########
__FILENAME__ = script
"""

Template module for Scripts

Copy this module up one level to gamesrc/scripts and name it
appropriately, then use that as a template to create your own script.

Test scripts in-game e.g. with the @script command. In code you can
create new scripts of a given class with
  script = ev.create.script("path.to.module.and.class")

Scripts are objects that handle everything in the game having
a time-component (i.e. that may change with time, with or without
a player being involved in the change). Scripts can work like "events",
in that they are triggered at regular intervals to do a certain script,
but an Script set on an object can also be responsible for silently
checking if its state changes, so as to update it. Evennia use several
in-built scripts to keep track of things like time, to clean out
dropped connections etc.

"""

from ev import Script as BaseScript


class ExampleScript(BaseScript):
    """
    A script type is customized by redefining some or all of its hook
    methods and variables.

    * available properties

     key (string) - name of object
     name (string)- same as key
     aliases (list of strings) - aliases to the object. Will be saved
              to database as AliasDB entries but returned as strings.
     dbref (int, read-only) - unique #id-number. Also "id" can be used.
     dbobj (Object, read-only) - link to database model. dbobj.typeclass
             points back to this class
     typeclass (Object, read-only) - this links back to this class as an
             identified only. Use self.swap_typeclass() to switch.
     date_created (string) - time stamp of object creation
     permissions (list of strings) - list of permission strings

     desc (string)      - optional description of script, shown in listings
     obj (Object)       - optional object that this script is connected to
                          and acts on (set automatically by obj.scripts.add())
     interval (int)     - how often script should run, in seconds. <0 turns
                          off ticker
     start_delay (bool) - if the script should start repeating right away or
                          wait self.interval seconds
     repeats (int)      - how many times the script should repeat before
                          stopping. 0 means infinite repeats
     persistent (bool)  - if script should survive a server shutdown or not
     is_active (bool)   - if script is currently running

    * Handlers

     locks - lock-handler: use locks.add() to add new lock strings
     db - attribute-handler: store/retrieve database attributes on this
                        self.db.myattr=val, val=self.db.myattr
     ndb - non-persistent attribute handler: same as db but does not
                        create a database entry when storing data

    * Helper methods

     start() - start script (this usually happens automatically at creation
               and obj.script.add() etc)
     stop()  - stop script, and delete it
     pause() - put the script on hold, until unpause() is called. If script
               is persistent, the pause state will survive a shutdown.
     unpause() - restart a previously paused script. The script will continue
                 from the paused timer (but at_start() will be called).
     time_until_next_repeat() - if a timed script (interval>0), returns time
                 until next tick

    * Hook methods (should also include self as the first argument):

     at_script_creation() - called only once, when an object of this
                            class is first created.
     is_valid() - is called to check if the script is valid to be running
                  at the current time. If is_valid() returns False, the running
                  script is stopped and removed from the game. You can use this
                  to check state changes (i.e. an script tracking some combat
                  stats at regular intervals is only valid to run while there is
                  actual combat going on).
      at_start() - Called every time the script is started, which for persistent
                  scripts is at least once every server start. Note that this is
                  unaffected by self.delay_start, which only delays the first
                  call to at_repeat().
      at_repeat() - Called every self.interval seconds. It will be called
                  immediately upon launch unless self.delay_start is True, which
                  will delay the first call of this method by self.interval
                  seconds. If self.interval==0, this method will never
                  be called.
      at_stop() - Called as the script object is stopped and is about to be
                  removed from the game, e.g. because is_valid() returned False.
      at_server_reload() - Called when server reloads. Can be used to
                  save temporary variables you want should survive a reload.
      at_server_shutdown() - called at a full server shutdown.

    """
    pass

########NEW FILE########
__FILENAME__ = batch_code
#
# Batchcode script
#
#
# The Batch-code processor accepts full python modules (e.g. "batch.py") that
# looks identical to normal Python files with a few exceptions that allows them
# to the executed in blocks. This way of working assures a sequential execution
# of the file and allows for features like stepping from block to block
# (without executing those coming before), as well as automatic deletion
# of created objects etc. You can however also run a batch-code python file
# directly using Python (and can also be de).

# Code blocks are separated by python comments starting with special code words.

# #HEADER - this denotes commands global to the entire file, such as
#           import statements and global variables. They will
#           automatically be made available for each block.  Observe
#           that changes to these variables made in one block is not
#           preserved between blocks!)
# #CODE (infotext) [objname, objname, ...] - This designates a code block that
#            will be executed like a stand-alone piece of code together with
#            any #HEADER defined.
#            infotext is a describing text about what goes in in this block.
#            It will be shown by the batchprocessing command.
#            <objname>s mark the (variable-)names of objects created in
#            the code, and which may be auto-deleted by the processor if
#            desired (such as when debugging the script). E.g., if the code
#            contains the command myobj = create.create_object(...), you could
#            put 'myobj' in the #CODE header regardless of what the created
#            object is actually called in-game.
# #INSERT filename - this includes another code batch file. The named file will
#            be loaded and run at this point. Note that code from the inserted
#            file will NOT share #HEADERs with the importing file, but will
#            only use the headers in the importing file. Make sure to not
#            create a cyclic import here!

# The following variable is automatically made available for the script:

# caller - the object executing the script
#


#HEADER

# everything in this block will be appended to the beginning of
# all other #CODE blocks when they are executed.

from ev import create_object, search_object
from game.gamesrc.objects.examples import red_button
from ev import Object

limbo = search_object('Limbo')[0]


#CODE (create red button)

# This is the first code block. Within each block, python
# code works as normal. Note how we make use if imports and
# 'limbo' defined in the #HEADER block. This block's header
# offers no information about red_button variable, so it
# won't be able to be deleted in debug mode.

# create a red button in limbo
red_button = create_object(red_button.RedButton, key="Red button",
                                  location=limbo, aliases=["button"])

# we take a look at what we created
caller.msg("A %s was created." % red_button.key)

#CODE (create table and chair) table, chair

# this code block has 'table' and 'chair' set as deletable
# objects. This means that when the batchcode processor runs in
# testing mode, objects created in these variables will be deleted
# again (so as to avoid duplicate objects when testing the script many
# times).

# the python variables we assign to must match the ones given in the
# header for the system to be able to delete them afterwards during a
# debugging run.
table = create_object(Object, key="Table", location=limbo)
chair = create_object(Object, key="Chair", location=limbo)

string = "A %s and %s were created. If debug was active, they were deleted again."
caller.msg(string % (table, chair))

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
"""
Set up the evennia system. A first startup consists of giving
the command './manage syncdb' to setup the system and create
the database.
"""

import sys
import os

# Tack on the root evennia directory to the python path.
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

#------------------------------------------------------------
# Get Evennia version
#------------------------------------------------------------
try:
    f = open(os.pardir + os.sep + 'VERSION.txt', 'r''')
    VERSION = "%s" % f.read().strip()
    f.close()
except IOError:
    VERSION = "Unknown version"

#------------------------------------------------------------
# Check so session file exists in the current dir- if not, create it.
#------------------------------------------------------------

_CREATED_SETTINGS = False
if not os.path.exists('settings.py'):
    # If settings.py doesn't already exist, create it and populate it with some
    # basic stuff.

    # make random secret_key.
    import random
    import string
    secret_key = list((string.letters +
        string.digits + string.punctuation).replace("\\", "").replace("'", '"'))
    random.shuffle(secret_key)
    secret_key = "".join(secret_key[:40])

    settings_file = open('settings.py', 'w')
    _CREATED_SETTINGS = True

    string = \
    """
######################################################################
# Evennia MU* server configuration file
#
# You may customize your setup by copy&pasting the variables you want
# to change from the master config file src/settings_default.py to
# this file. Try to *only* copy over things you really need to customize
# and do *not* make any changes to src/settings_default.py directly.
# This way you'll always have a sane default to fall back on
# (also, the master config file may change with server updates).
#
######################################################################

from src.settings_default import *

######################################################################
# Custom settings
######################################################################


######################################################################
# SECRET_KEY was randomly seeded when settings.py was first created.
# Don't share this with anybody. It is used by Evennia to handle
# cryptographic hashing for things like cookies on the web side.
######################################################################
SECRET_KEY = '%s'

""" % secret_key

    settings_file.write(string)
    settings_file.close()

    # obs - this string cannot be under i18n since settings didn't exist yet.
    print """
    Welcome to Evennia!

    This looks like your first startup, so we created a fresh
    game/settings.py file for you. No database has yet been created.
    You may edit the settings file now if you like, but if you just
    want to quickly get started you don't have to touch anything.

    Once you are ready to continue, (re)run
        python manage.py syncdb
    followed by
        python manage.py migrate
    """


#------------------------------------------------------------
# Test the import of the settings file
#------------------------------------------------------------
try:
    from game import settings
except Exception:
    import traceback
    string = "\n" + traceback.format_exc()

    # note - if this fails, ugettext will also fail, so we cannot translate this string.

    string += """\n
    Error: Couldn't import the file 'settings.py' in the directory containing %(file)r.
    There are usually two reasons for this:
    1) The settings module contains errors. Review the traceback above to resolve the
       problem, then try again.
    2) If you get errors on finding DJANGO_SETTINGS_MODULE you might have set up django
       wrong in some way. If you run a virtual machine, it might be worth to restart it
       to see if this resolves the issue. Evennia should not require you to define any
       environment variables manually.
    """ % {'file': __file__}
    print string
    sys.exit(1)

os.environ['DJANGO_SETTINGS_MODULE'] = 'game.settings'

#------------------------------------------------------------
# This is run only if the module is called as a program
#------------------------------------------------------------
if __name__ == "__main__":

    if _CREATED_SETTINGS:
        # if settings were created, info has already been printed.
        sys.exit()

    # run the standard django manager, if dependencies match
    from src.utils.utils import check_evennia_dependencies
    if check_evennia_dependencies():
        if len(sys.argv) > 1 and sys.argv[1] in ('runserver', 'testserver'):
            print """
            WARNING: There is no need to run the Django development
            webserver to test out Evennia web features (the web client
            will in fact not work since the Django test server knows
            nothing about MUDs).  Instead, just start Evennia with the
            webserver component active (this is the default).
            """
        from django.core.management import execute_from_command_line
        execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/env python
"""

This runner is controlled by evennia.py and should normally not be
 launched directly.  It manages the two main Evennia processes (Server
 and Portal) and most importanly runs a passive, threaded loop that
 makes sure to restart Server whenever it shuts down.

Since twistd does not allow for returning an optional exit code we
need to handle the current reload state for server and portal with
flag-files instead. The files, one each for server and portal either
contains True or False indicating if the process should be restarted
upon returning, or not. A process returning != 0 will always stop, no
matter the value of this file.

"""
import os
import sys
from optparse import OptionParser
from subprocess import Popen
import Queue, thread

try:
    # check if launched with pypy
    import __pypy__ as is_pypy
except ImportError:
    is_pypy = False

#
# System Configuration
#

SERVER_PIDFILE = "server.pid"
PORTAL_PIDFILE = "portal.pid"

SERVER_RESTART = "server.restart"
PORTAL_RESTART = "portal.restart"

# Set the Python path up so we can get to settings.py from here.
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['DJANGO_SETTINGS_MODULE'] = 'game.settings'

if not os.path.exists('settings.py'):

    print "No settings.py file found. Run evennia.py to create it."
    sys.exit()

# Get the settings
from django.conf import settings

# Setup access of the evennia server itself
SERVER_PY_FILE = os.path.join(settings.SRC_DIR, 'server/server.py')
PORTAL_PY_FILE = os.path.join(settings.SRC_DIR, 'server/portal/portal.py')

# Get logfile names
SERVER_LOGFILE = settings.SERVER_LOG_FILE
PORTAL_LOGFILE = settings.PORTAL_LOG_FILE
HTTP_LOGFILE = settings.HTTP_LOG_FILE.strip()

CYCLE_LOGFILES = settings.CYCLE_LOGFILES

# Add this to the environmental variable for the 'twistd' command.
currpath = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if 'PYTHONPATH' in os.environ:
    os.environ['PYTHONPATH'] += (":%s" % currpath)
else:
    os.environ['PYTHONPATH'] = currpath

TWISTED_BINARY = 'twistd'
if os.name == 'nt':
    TWISTED_BINARY = 'twistd.bat'
    err = False
    try:
        import win32api  # Test for for win32api
    except ImportError:
        err = True
    if not os.path.exists(TWISTED_BINARY):
        err = True
    if err:
        print "Twisted binary for Windows is not ready to use. Please run evennia.py."
        sys.exit()

# Functions


def set_restart_mode(restart_file, flag="reload"):
    """
    This sets a flag file for the restart mode.
    """
    with open(restart_file, 'w') as f:
        f.write(str(flag))


def get_restart_mode(restart_file):
    """
    Parse the server/portal restart status
    """
    if os.path.exists(restart_file):
        with open(restart_file, 'r') as f:
            return f.read()
    return "shutdown"


def get_pid(pidfile):
    """
    Get the PID (Process ID) by trying to access
    an PID file.
    """
    pid = None
    if os.path.exists(pidfile):
        with open(pidfile, 'r') as f:
            pid = f.read()
    return pid


def cycle_logfile(logfile):
    """
    Rotate the old log files to <filename>.old
    """
    logfile_old = logfile + '.old'
    if os.path.exists(logfile):
        # Cycle the old logfiles to *.old
        if os.path.exists(logfile_old):
            # E.g. Windows don't support rename-replace
            os.remove(logfile_old)
        os.rename(logfile, logfile_old)

# Start program management

SERVER = None
PORTAL = None


def start_services(server_argv, portal_argv):
    """
    This calls a threaded loop that launces the Portal and Server
    and then restarts them when they finish.
    """
    global SERVER, PORTAL
    processes = Queue.Queue()

    def server_waiter(queue):
        try:
            rc = Popen(server_argv).wait()
        except Exception, e:
            print "Server process error: %(e)s" % {'e': e}
            return
        # this signals the controller that the program finished
        queue.put(("server_stopped", rc))

    def portal_waiter(queue):
        try:
            rc = Popen(portal_argv).wait()
        except Exception, e:
            print "Portal process error: %(e)s" % {'e': e}
            return
        # this signals the controller that the program finished
        queue.put(("portal_stopped", rc))

    if portal_argv:
        try:
            if get_restart_mode(PORTAL_RESTART) == "True":
                # start portal as interactive, reloadable thread
                PORTAL = thread.start_new_thread(portal_waiter, (processes, ))
            else:
                # normal operation: start portal as a daemon;
                # we don't care to monitor it for restart
                PORTAL = Popen(portal_argv)
        except IOError, e:
            print "Portal IOError: %s\nA possible explanation for this is that 'twistd' is not found." % e
            return

    try:
        if server_argv:
            # start server as a reloadable thread
            SERVER = thread.start_new_thread(server_waiter, (processes, ))
    except IOError, e:
        print "Server IOError: %s\nA possible explanation for this is that 'twistd' is not found." % e
        return

    # Reload loop
    while True:

        # this blocks until something is actually returned.
        message, rc = processes.get()

        # restart only if process stopped cleanly
        if (message == "server_stopped" and int(rc) == 0 and
             get_restart_mode(SERVER_RESTART) in ("True", "reload", "reset")):
            print "Evennia Server stopped. Restarting ..."
            SERVER = thread.start_new_thread(server_waiter, (processes, ))
            continue

        # normally the portal is not reloaded since it's run as a daemon.
        if (message == "portal_stopped" and int(rc) == 0 and
              get_restart_mode(PORTAL_RESTART) == "True"):
            print "Evennia Portal stopped in interactive mode. Restarting ..."
            PORTAL = thread.start_new_thread(portal_waiter, (processes, ))
            continue
        break

# Setup signal handling

def main():
    """
    This handles the command line input of the runner
    (it's most often called by evennia.py)
    """

    parser = OptionParser(usage="%prog [options] start",
      description="This runner should normally *not* be called directly - it is called automatically from the evennia.py main program. It manages the Evennia game server and portal processes an hosts a threaded loop to restart the Server whenever it is stopped (this constitues Evennia's reload mechanism).")
    parser.add_option('-s', '--noserver', action='store_true',
                      dest='noserver', default=False,
                      help='Do not start Server process')
    parser.add_option('-p', '--noportal', action='store_true',
                      dest='noportal', default=False,
                      help='Do not start Portal process')
    parser.add_option('-i', '--iserver', action='store_true',
                      dest='iserver', default=False,
                      help='output server log to stdout instead of logfile')
    parser.add_option('-d', '--iportal', action='store_true',
                      dest='iportal', default=False,
                      help='output portal log to stdout. Does not make portal a daemon.')
    parser.add_option('-S', '--profile-server', action='store_true',
                      dest='sprof', default=False,
                      help='run server under cProfile')
    parser.add_option('-P', '--profile-portal', action='store_true',
                      dest='pprof', default=False,
                      help='run portal under cProfile')

    options, args = parser.parse_args()

    if not args or args[0] != 'start':
        # this is so as to avoid runner.py be accidentally launched manually.
        parser.print_help()
        sys.exit()

    # set up default project calls
    server_argv = [TWISTED_BINARY,
                   '--nodaemon',
                   '--logfile=%s' % SERVER_LOGFILE,
                   '--pidfile=%s' % SERVER_PIDFILE,
                   '--python=%s' % SERVER_PY_FILE]
    portal_argv = [TWISTED_BINARY,
                   '--logfile=%s' % PORTAL_LOGFILE,
                   '--pidfile=%s' % PORTAL_PIDFILE,
                   '--python=%s' % PORTAL_PY_FILE]

    # Profiling settings (read file from python shell e.g with
    # p = pstats.Stats('server.prof')
    sprof_argv = ['--savestats',
                  '--profiler=cprofile',
                  '--profile=server.prof']
    pprof_argv = ['--savestats',
                  '--profiler=cprofile',
                  '--profile=portal.prof']

    # Server

    pid = get_pid(SERVER_PIDFILE)
    if pid and not options.noserver:
            print "\nEvennia Server is already running as process %(pid)s. Not restarted." % {'pid': pid}
            options.noserver = True
    if options.noserver:
        server_argv = None
    else:
        set_restart_mode(SERVER_RESTART, "shutdown")
        if options.iserver:
            # don't log to server logfile
            del server_argv[2]
            print "\nStarting Evennia Server (output to stdout)."
        else:
            if CYCLE_LOGFILES:
                cycle_logfile(SERVER_LOGFILE)
            print "\nStarting Evennia Server (output to server logfile)."
        if options.sprof:
            server_argv.extend(sprof_argv)
            print "\nRunning Evennia Server under cProfile."

    # Portal

    pid = get_pid(PORTAL_PIDFILE)
    if pid and not options.noportal:
        print "\nEvennia Portal is already running as process %(pid)s. Not restarted." % {'pid': pid}
        options.noportal = True
    if options.noportal:
        portal_argv = None
    else:
        if options.iportal:
            # make portal interactive
            portal_argv[1] = '--nodaemon'
            set_restart_mode(PORTAL_RESTART, True)
            print "\nStarting Evennia Portal in non-Daemon mode (output to stdout)."
        else:
            if CYCLE_LOGFILES:
                cycle_logfile(PORTAL_LOGFILE)
                cycle_logfile(HTTP_LOGFILE)
            set_restart_mode(PORTAL_RESTART, False)
            print "\nStarting Evennia Portal in Daemon mode (output to portal logfile)."
        if options.pprof:
            portal_argv.extend(pprof_argv)
            print "\nRunning Evennia Portal under cProfile."

    # Windows fixes (Windows don't support pidfiles natively)
    if os.name == 'nt':
        if server_argv:
            del server_argv[-2]
        if portal_argv:
            del portal_argv[-2]

    # Start processes
    start_services(server_argv, portal_argv)

if __name__ == '__main__':
    from src.utils.utils import check_evennia_dependencies
    if check_evennia_dependencies():
        main()

########NEW FILE########
__FILENAME__ = sitecustomize
"""
This special Python config file sets the default encoding for
the codebase to UTF-8 instead of ascii. This allows for just
about any language to be used in-game.

It is not advisable to change the value set below, as
there will be a lot of encoding errors that result in
server crashes.
"""
import sys
sys.setdefaultencoding('utf-8')

########NEW FILE########
__FILENAME__ = cmdhandler
"""
Command handler

This module contains the infrastructure for accepting commands on the
command line. The process is as follows:

1) The calling object (caller) inputs a string and triggers the command parsing system.
2) The system checks the state of the caller - loggedin or not
3) If no command string was supplied, we search the merged cmdset for system command CMD_NOINPUT
   and branches to execute that.  --> Finished
4) Cmdsets are gathered from different sources (in order of dropping priority):
           channels - all available channel names are auto-created into a cmdset, to allow
                  for giving the channel name and have the following immediately
                  sent to the channel. The sending is performed by the CMD_CHANNEL
                  system command.
           object cmdsets - all objects at caller's location are scanned for non-empty
                  cmdsets. This includes cmdsets on exits.
           caller - the caller is searched for its own currently active cmdset.
           player - lastly the cmdsets defined on caller.player are added.
5) All the gathered cmdsets (if more than one) are merged into one using the cmdset priority rules.
6) If merged cmdset is empty, raise NoCmdSet exception (this should not happen, at least the
   player should have a default cmdset available at all times). --> Finished
7) The raw input string is parsed using the parser defined by settings.COMMAND_PARSER. It
   uses the available commands from the merged cmdset to know which commands to look for and
   returns one or many matches.
8)   If match list is empty, branch to system command CMD_NOMATCH --> Finished
9)   If match list has more than one element, branch to system command CMD_MULTIMATCH --> Finished
10) A single match was found. If this is a channel-command (i.e. the command name is that of a channel),
    branch to CMD_CHANNEL --> Finished
11) At this point we have found a normal command. We assign useful variables to it that
    will be available to the command coder at run-time.
12) We have a unique cmdobject, primed for use. Call all hooks:
    at_pre_cmd(), cmdobj.parse(), cmdobj.func() and finally at_post_cmd().


"""

from copy import copy
from traceback import format_exc
from twisted.internet.defer import inlineCallbacks, returnValue
from django.conf import settings
from src.comms.channelhandler import CHANNELHANDLER
from src.utils import logger, utils
from src.commands.cmdparser import at_multimatch_cmd
from src.utils.utils import string_suggestions, make_iter, to_unicode

from django.utils.translation import ugettext as _

__all__ = ("cmdhandler",)
_GA = object.__getattribute__
_CMDSET_MERGE_CACHE = {}

# This decides which command parser is to be used.
# You have to restart the server for changes to take effect.
_COMMAND_PARSER = utils.variable_from_module(*settings.COMMAND_PARSER.rsplit('.', 1))

# System command names - import these variables rather than trying to
# remember the actual string constants. If not defined, Evennia
# hard-coded defaults are used instead.

# command to call if user just presses <return> with no input
CMD_NOINPUT = "__noinput_command"
# command to call if no command match was found
CMD_NOMATCH = "__nomatch_command"
# command to call if multiple command matches were found
CMD_MULTIMATCH = "__multimatch_command"
# command to call if found command is the name of a channel
CMD_CHANNEL = "__send_to_channel_command"
# command to call as the very first one when the user connects.
# (is expected to display the login screen)
CMD_LOGINSTART = "__unloggedin_look_command"

# custom Exceptions


class NoCmdSets(Exception):
    "No cmdsets found. Critical error."
    pass


class ExecSystemCommand(Exception):
    "Run a system command"
    def __init__(self, syscmd, sysarg):
        self.args = (syscmd, sysarg)  # needed by exception error handling
        self.syscmd = syscmd
        self.sysarg = sysarg

# Helper function


@inlineCallbacks
def get_and_merge_cmdsets(caller, session, player, obj,
                          callertype, sessid=None):
    """
    Gather all relevant cmdsets and merge them.

    callertype is one of "session", "player" or "object" dependin
    on which level the cmdhandler is invoked. Session includes the
    cmdsets available to Session, Player and its eventual puppeted Object.
    Player-level include cmdsets on Player and Object, while calling
    the handler on an Object only includes cmdsets on itself.

    The cdmsets are merged in order generality, so that the Object's
    cmdset is merged last (and will thus take precedence over
    same-named and same-prio commands on Player and Session).

    Note that this function returns a deferred!
    """
    local_obj_cmdsets = [None]

    @inlineCallbacks
    def _get_channel_cmdsets(player, player_cmdset):
        "Channel-cmdsets"
        # Create cmdset for all player's available channels
        channel_cmdset = None
        if not player_cmdset.no_channels:
            channel_cmdset = yield CHANNELHANDLER.get_cmdset(player)
        returnValue(channel_cmdset)

    @inlineCallbacks
    def _get_local_obj_cmdsets(obj, obj_cmdset):
        "Object-level cmdsets"
        # Gather cmdsets from location, objects in location or carried
        local_obj_cmdsets = [None]
        try:
            location = obj.location
        except Exception:
            location = None
        if location and not obj_cmdset.no_objs:
            # Gather all cmdsets stored on objects in the room and
            # also in the caller's inventory and the location itself
            local_objlist = yield (location.contents_get(exclude=obj.dbobj) +
                                   obj.contents +
                                   [location])
            for lobj in local_objlist:
                try:
                    # call hook in case we need to do dynamic changing to cmdset
                    _GA(lobj, "at_cmdset_get")()
                except Exception:
                    logger.log_trace()
            # the call-type lock is checked here, it makes sure a player
            # is not seeing e.g. the commands on a fellow player (which is why
            # the no_superuser_bypass must be True)
            local_obj_cmdsets = \
                yield [lobj.cmdset.current for lobj in local_objlist
                   if (lobj.cmdset.current and
                   lobj.locks.check(caller, 'call', no_superuser_bypass=True))]
            for cset in local_obj_cmdsets:
                #This is necessary for object sets, or we won't be able to
                # separate the command sets from each other in a busy room.
                cset.old_duplicates = cset.duplicates
                cset.duplicates = True
        returnValue(local_obj_cmdsets)

    @inlineCallbacks
    def _get_cmdset(obj):
        "Get cmdset, triggering all hooks"
        try:
            yield obj.at_cmdset_get()
        except Exception:
            logger.log_trace()
        try:
            returnValue(obj.cmdset.current)
        except AttributeError:
            returnValue(None)

    if callertype == "session":
        # we are calling the command from the session level
        report_to = session
        session_cmdset = yield _get_cmdset(session)
        cmdsets = [session_cmdset]
        if player:  # this automatically implies logged-in
            player_cmdset = yield _get_cmdset(player)
            channel_cmdset = yield _get_channel_cmdsets(player, player_cmdset)
            cmdsets.extend([player_cmdset, channel_cmdset])
            if obj:
                obj_cmdset = yield _get_cmdset(obj)
                local_obj_cmdsets = yield _get_local_obj_cmdsets(obj, obj_cmdset)
                cmdsets.extend([obj_cmdset] + local_obj_cmdsets)
    elif callertype == "player":
        # we are calling the command from the player level
        report_to = player
        player_cmdset = yield _get_cmdset(player)
        channel_cmdset = yield _get_channel_cmdsets(player, player_cmdset)
        cmdsets = [player_cmdset, channel_cmdset]
        if obj:
            obj_cmdset = yield _get_cmdset(obj)
            local_obj_cmdsets = yield _get_local_obj_cmdsets(obj, obj_cmdset)
            cmdsets.extend([obj_cmdset] + local_obj_cmdsets)
    elif callertype == "object":
        # we are calling the command from the object level
        report_to = obj
        obj_cmdset = yield _get_cmdset(obj)
        local_obj_cmdsets = yield _get_local_obj_cmdsets(obj, obj_cmdset)
        cmdsets = [obj_cmdset] + local_obj_cmdsets
    else:
        raise Exception("get_and_merge_cmdsets: callertype %s is not valid." % callertype)
    #cmdsets = yield [caller_cmdset] + [player_cmdset] +
    #          [channel_cmdset] + local_obj_cmdsets

    # weed out all non-found sets
    cmdsets = yield [cmdset for cmdset in cmdsets
                     if cmdset and cmdset.key != "_EMPTY_CMDSET"]
    # report cmdset errors to user (these should already have been logged)
    yield [report_to.msg(cmdset.errmessage) for cmdset in cmdsets
           if cmdset.key == "_CMDSET_ERROR"]

    if cmdsets:
        # faster to do tuple on list than to build tuple directly
        mergehash = tuple([id(cmdset) for cmdset in cmdsets])
        if mergehash in _CMDSET_MERGE_CACHE:
            # cached merge exist; use that
            cmdset = _CMDSET_MERGE_CACHE[mergehash]
        else:
            # we group and merge all same-prio cmdsets separately (this avoids
            # order-dependent clashes in certain cases, such as
            # when duplicates=True)
            tempmergers = {}
            for cmdset in cmdsets:
                prio = cmdset.priority
                #print cmdset.key, prio
                if prio in tempmergers:
                    # merge same-prio cmdset together separately
                    tempmergers[prio] = yield cmdset + tempmergers[prio]
                else:
                    tempmergers[prio] = cmdset

            # sort cmdsets after reverse priority (highest prio are merged in last)
            cmdsets = yield sorted(tempmergers.values(), key=lambda x: x.priority)

            # Merge all command sets into one, beginning with the lowest-prio one
            cmdset = cmdsets[0]
            for merging_cmdset in cmdsets[1:]:
                #print "<%s(%s,%s)> onto <%s(%s,%s)>" % (merging_cmdset.key, merging_cmdset.priority, merging_cmdset.mergetype,
                #                                        cmdset.key, cmdset.priority, cmdset.mergetype)
                cmdset = yield merging_cmdset + cmdset
            # store the full sets for diagnosis
            cmdset.merged_from = cmdsets
            # cache
            _CMDSET_MERGE_CACHE[mergehash] = cmdset
    else:
        cmdset = None

    for cset in (cset for cset in local_obj_cmdsets if cset):
        cset.duplicates = cset.old_duplicates
    #print "merged set:", cmdset.key
    returnValue(cmdset)


# Main command-handler function

@inlineCallbacks
def cmdhandler(called_by, raw_string, testing=False, callertype="session", sessid=None):
    """
    This is the main function to handle any string sent to the engine.

    called_by - object on which this was called from. This is either a Session, a Player or an Object.
    raw_string - the command string given on the command line
    testing - if we should actually execute the command or not.
              if True, the command instance will be returned instead.
    callertype - this is one of "session", "player" or "object", in decending
                 order. So when the Session is the caller, it will merge its
                 own cmdset into cmdsets from both Player and eventual puppeted
                 Object (and cmdsets in its room etc). A Player will only
                 include its own cmdset and the Objects and so on. Merge order
                 is the same order, so that Object cmdsets are merged in last,
                 giving them precendence for same-name and same-prio commands.
    sessid - Relevant if callertype is "player" - the session id will help
             retrieve the correct cmdsets from puppeted objects.

    Note that this function returns a deferred!
    """

    raw_string = to_unicode(raw_string, force_string=True)

    session, player, obj = None, None, None
    if callertype == "session":
        session = called_by
        player = session.player
        if player:
            obj = yield _GA(player.dbobj, "get_puppet")(session.sessid)
    elif callertype == "player":
        player = called_by
        if sessid:
            obj = yield _GA(player.dbobj, "get_puppet")(sessid)
    elif callertype == "object":
        obj = called_by
    else:
        raise RuntimeError("cmdhandler: callertype %s is not valid." % callertype)

    # the caller will be the one to receive messages and excert its permissions.
    # we assign the caller with preference 'bottom up'
    caller = obj or player or session

    try:  # catch bugs in cmdhandler itself
        try:  # catch special-type commands

            cmdset = yield get_and_merge_cmdsets(caller, session, player, obj,
                                                  callertype, sessid)
            if not cmdset:
                # this is bad and shouldn't happen.
                raise NoCmdSets
            unformatted_raw_string = raw_string
            raw_string = raw_string.strip()
            if not raw_string:
                # Empty input. Test for system command instead.
                syscmd = yield cmdset.get(CMD_NOINPUT)
                sysarg = ""
                raise ExecSystemCommand(syscmd, sysarg)
            # Parse the input string and match to available cmdset.
            # This also checks for permissions, so all commands in match
            # are commands the caller is allowed to call.
            matches = yield _COMMAND_PARSER(raw_string, cmdset, caller)

            # Deal with matches

            if len(matches) > 1:
                # We have a multiple-match
                syscmd = yield cmdset.get(CMD_MULTIMATCH)
                sysarg = _("There were multiple matches.")
                if syscmd:
                    # use custom CMD_MULTIMATCH
                    syscmd.matches = matches
                else:
                    # fall back to default error handling
                    sysarg = yield at_multimatch_cmd(caller, matches)
                raise ExecSystemCommand(syscmd, sysarg)

            if len(matches) == 1:
                # We have a unique command match. But it may still be invalid.
                match = matches[0]
                cmdname, args, cmd = match[0], match[1], match[2]

                # check if we allow this type of command
                if cmdset.no_channels and hasattr(cmd, "is_channel") and cmd.is_channel:
                    matches = []
                if cmdset.no_exits and hasattr(cmd, "is_exit") and cmd.is_exit:
                    matches = []

            if not matches:
                # No commands match our entered command
                syscmd = yield cmdset.get(CMD_NOMATCH)
                if syscmd:
                    # use custom CMD_NOMATH command
                    sysarg = raw_string
                else:
                    # fallback to default error text
                    sysarg = _("Command '%s' is not available.") % raw_string
                    suggestions = string_suggestions(raw_string,
                                    cmdset.get_all_cmd_keys_and_aliases(caller),
                                    cutoff=0.7, maxnum=3)
                    if suggestions:
                        sysarg += _(" Maybe you meant %s?") % utils.list_to_string(suggestions, _('or'), addquote=True)
                    else:
                        sysarg += _(" Type \"help\" for help.")
                raise ExecSystemCommand(syscmd, sysarg)

            # Check if this is a Channel-cmd match.
            if hasattr(cmd, 'is_channel') and cmd.is_channel:
                # even if a user-defined syscmd is not defined, the
                # found cmd is already a system command in its own right.
                syscmd = yield cmdset.get(CMD_CHANNEL)
                if syscmd:
                    # replace system command with custom version
                    cmd = syscmd
                cmd.sessid = session.sessid if session else None
                sysarg = "%s:%s" % (cmdname, args)
                raise ExecSystemCommand(cmd, sysarg)

            # A normal command.

            # Assign useful variables to the instance
            cmd.caller = caller
            cmd.cmdstring = cmdname
            cmd.args = args
            cmd.cmdset = cmdset
            cmd.sessid = session.sessid if session else sessid
            cmd.session = session
            cmd.player = player
            cmd.raw_string = unformatted_raw_string
            #cmd.obj  # set via on-object cmdset handler for each command,
                      # since this may be different for every command when
                      # merging multuple cmdsets

            if hasattr(cmd, 'obj') and hasattr(cmd.obj, 'scripts'):
                # cmd.obj is automatically made available by the cmdhandler.
                # we make sure to validate its scripts.
                yield cmd.obj.scripts.validate()

            if testing:
                # only return the command instance
                returnValue(cmd)

            # pre-command hook
            yield cmd.at_pre_cmd()

            # Parse and execute
            yield cmd.parse()
            # (return value is normally None)
            ret = yield cmd.func()

            # post-command hook
            yield cmd.at_post_cmd()

            if cmd.save_for_next:
                # store a reference to this command, possibly
                # accessible by the next command.
                caller.ndb.last_cmd = yield copy(cmd)
            else:
                caller.ndb.last_cmd = None
            # Done! This returns a deferred. By default, Evennia does
            # not use this at all.
            returnValue(ret)

        except ExecSystemCommand, exc:
            # Not a normal command: run a system command, if available,
            # or fall back to a return string.
            syscmd = exc.syscmd
            sysarg = exc.sysarg
            if syscmd:
                syscmd.caller = caller
                syscmd.cmdstring = syscmd.key
                syscmd.args = sysarg
                syscmd.cmdset = cmdset
                syscmd.sessid = session.sessid if session else None
                syscmd.raw_string = unformatted_raw_string

                if hasattr(syscmd, 'obj') and hasattr(syscmd.obj, 'scripts'):
                    # cmd.obj is automatically made available.
                    # we make sure to validate its scripts.
                    yield syscmd.obj.scripts.validate()

                if testing:
                    # only return the command instance
                    returnValue(syscmd)

                # parse and run the command
                yield syscmd.parse()
                yield syscmd.func()
            elif sysarg:
                # return system arg
                caller.msg(exc.sysarg)

        except NoCmdSets:
            # Critical error.
            string = "No command sets found! This is a sign of a critical bug.\n"
            string += "The error was logged.\n"
            string += "If logging out/in doesn't solve the problem, try to "
            string += "contact the server admin through some other means "
            string += "for assistance."
            caller.msg(_(string))
            logger.log_errmsg("No cmdsets found: %s" % caller)

        except Exception:
            # We should not end up here. If we do, it's a programming bug.
            string = "%s\nAbove traceback is from an untrapped error."
            string += " Please file a bug report."
            logger.log_trace(_(string))
            caller.msg(string % format_exc())

    except Exception:
        # This catches exceptions in cmdhandler exceptions themselves
        string = "%s\nAbove traceback is from a Command handler bug."
        string += " Please contact an admin and/or file a bug report."
        logger.log_trace(_(string))
        caller.msg(string % format_exc())

########NEW FILE########
__FILENAME__ = cmdparser
"""
The default command parser. Use your own by assigning
settings.ALTERNATE_PARSER to a Python path to a module containing the
replacing cmdparser function. The replacement parser must
return a CommandCandidates object.
"""

from src.utils.logger import log_trace
from django.utils.translation import ugettext as _

def cmdparser(raw_string, cmdset, caller, match_index=None):
    """
    This function is called by the cmdhandler once it has
    gathered all valid cmdsets for the calling player. raw_string
    is the unparsed text entered by the caller.

    The cmdparser understand the following command combinations (where
    [] marks optional parts.

    [cmdname[ cmdname2 cmdname3 ...] [the rest]

    A command may consist of any number of space-separated words of any
    length, and contain any character.

    The parser makes use of the cmdset to find command candidates. The
    parser return a list of matches. Each match is a tuple with its
    first three elements being the parsed cmdname (lower case),
    the remaining arguments, and the matched cmdobject from the cmdset.
    """

    def create_match(cmdname, string, cmdobj):
        """
        Evaluates the quality of a match by counting how many chars of cmdname
        matches string (counting from beginning of string). We also calculate
        a ratio from 0-1 describing how much cmdname matches string.
        We return a tuple (cmdname, count, ratio, args, cmdobj).

        """
        cmdlen, strlen = len(cmdname), len(string)
        mratio = 1 - (strlen - cmdlen) / (1.0 * strlen)
        args = string[cmdlen:]
        return (cmdname, args, cmdobj, cmdlen, mratio)

    if not raw_string:
        return None

    matches = []

    # match everything that begins with a matching cmdname.
    l_raw_string = raw_string.lower()
    for cmd in cmdset:
        try:
            matches.extend([create_match(cmdname, raw_string, cmd)
                      for cmdname in [cmd.key] + cmd.aliases
                        if cmdname and l_raw_string.startswith(cmdname.lower())
                           and (not cmd.arg_regex or
                             cmd.arg_regex.match(l_raw_string[len(cmdname):]))])
        except Exception:
            log_trace("cmdhandler error. raw_input:%s" % raw_string)

    if not matches:
        # no matches found.
        if '-' in raw_string:
            # This could be due to the user trying to identify the
            # command with a #num-<command> style syntax.
            mindex, new_raw_string = raw_string.split("-", 1)
            if mindex.isdigit():
                mindex = int(mindex) - 1
                # feed result back to parser iteratively
                return cmdparser(new_raw_string, cmdset,
                                 caller, match_index=mindex)

    # only select command matches we are actually allowed to call.
    matches = [match for match in matches if match[2].access(caller, 'cmd')]

    if len(matches) > 1:
        # See if it helps to analyze the match with preserved case but only if
        # it leaves at least one match.
        trimmed = [match for match in matches
                     if raw_string.startswith(match[0])]
        if trimmed:
            matches = trimmed

    if len(matches) > 1:
        # we still have multiple matches. Sort them by count quality.
        matches = sorted(matches, key=lambda m: m[3])
        # only pick the matches with highest count quality
        quality = [mat[3] for mat in matches]
        matches = matches[-quality.count(quality[-1]):]

    if len(matches) > 1:
        # still multiple matches. Fall back to ratio-based quality.
        matches = sorted(matches, key=lambda m: m[4])
        # only pick the highest rated ratio match
        quality = [mat[4] for mat in matches]
        matches = matches[-quality.count(quality[-1]):]

    if len(matches) > 1 and match_index != None and 0 <= match_index < len(matches):
        # We couldn't separate match by quality, but we have an
        # index argument to tell us which match to use.
        matches = [matches[match_index]]

    # no matter what we have at this point, we have to return it.
    return matches

#------------------------------------------------------------
# Search parsers and support methods
#------------------------------------------------------------
#
# Default functions for formatting and processing searches.
#
# This is in its own module due to them being possible to
# replace from the settings file by setting the variables
#
# SEARCH_AT_RESULTERROR_HANDLER
# SEARCH_MULTIMATCH_PARSER
#
# The the replacing modules must have the same inputs and outputs as
# those in this module.
#
def at_search_result(msg_obj, ostring, results, global_search=False,
                     nofound_string=None, multimatch_string=None):
    """
    Called by search methods after a result of any type has been found.

    Takes a search result (a list) and
    formats eventual errors.

    msg_obj - object to receive feedback.
    ostring - original search string
    results - list of found matches (0, 1 or more)
    global_search - if this was a global_search or not
            (if it is, there might be an idea of supplying
            dbrefs instead of only numbers)
    nofound_string - optional custom string for not-found error message.
    multimatch_string - optional custom string for multimatch error header

    Multiple matches are returned to the searching object
    as
     1-object
     2-object
     3-object
       etc

    """
    string = ""
    if not results:
        # no results.
        if nofound_string:
            # custom return string
            string = nofound_string
        else:
            string = _("Could not find '%s'." % ostring)
        results = None

    elif len(results) > 1:
        # we have more than one match. We will display a
        # list of the form 1-objname, 2-objname etc.

        # check if the msg_object may se dbrefs
        show_dbref = global_search

        if multimatch_string:
            # custom header
            string = multimatch_string
        else:
            string = "More than one match for '%s'" % ostring
            string += " (please narrow target):"
            string = _(string)

        for num, result in enumerate(results):
            invtext = ""
            dbreftext = ""
            if hasattr(result, _("location")) and result.location == msg_obj:
                invtext = _(" (carried)")
            if show_dbref:
                dbreftext = "(#%i)" % result.dbid
            string += "\n %i-%s%s%s" % (num + 1, result.name,
                                        dbreftext, invtext)
        results = None
    else:
        # we have exactly one match.
        results = results[0]

    if string:
        msg_obj.msg(string.strip())
    return results


def at_multimatch_input(ostring):
    """
    Parse number-identifiers.

    This parser will be called by the engine when a user supplies
    a search term. The search term must be analyzed to determine
    if the user wants to differentiate between multiple matches
    (usually found during a previous search).

    This method should separate out any identifiers from the search
    string used to differentiate between same-named objects. The
    result should be a tuple (index, search_string) where the index
    gives which match among multiple matches should be used (1 being
    the lowest number, rather than 0 as in Python).

    This parser version will identify search strings on the following
    forms

      2-object

    This will be parsed to (2, "object") and, if applicable, will tell
    the engine to pick the second from a list of same-named matches of
    objects called "object".

    Ex for use in a game session:

     > look
    You see: ball, ball, ball and ball.
     > get ball
    There where multiple matches for ball:
        1-ball
        2-ball
        3-ball
        4-ball
     > get 3-ball
     You get the ball.

    """

    if not isinstance(ostring, basestring):
        return (None, ostring)
    if not '-' in ostring:
        return (None, ostring)
    try:
        index = ostring.find('-')
        number = int(ostring[:index]) - 1
        return (number, ostring[index + 1:])
    except ValueError:
        #not a number; this is not an identifier.
        return (None, ostring)
    except IndexError:
        return (None, ostring)


def at_multimatch_cmd(caller, matches):
    """
    Format multiple command matches to a useful error.
    """
    string = "There were multiple matches:"
    for num, match in enumerate(matches):
        # each match is a tuple (candidate, cmd)
        cmdname, arg, cmd, dum, dum = match

        is_channel = hasattr(cmd, "is_channel") and cmd.is_channel
        if is_channel:
            is_channel = _(" (channel)")
        else:
            is_channel = ""
        if cmd.is_exit and cmd.destination:
            is_exit = (" (exit to %s)") % cmd.destination
        else:
            is_exit = ""

        id1 = ""
        id2 = ""
        if (not (is_channel or is_exit) and
            (hasattr(cmd, 'obj') and cmd.obj != caller) and
             hasattr(cmd.obj, "key")):
            # the command is defined on some other object
            id1 = "%s-%s" % (num + 1, cmdname)
            id2 = " (%s)" % (cmd.obj.key)
        else:
            id1 = "%s-%s" % (num + 1, cmdname)
            id2 = ""
        string += "\n  %s%s%s%s" % (id1, id2, is_channel, is_exit)
    return string

########NEW FILE########
__FILENAME__ = cmdset
"""
A cmdset holds a set of commands available to the object or to other
objects near it. All the commands a player can give (look, @create etc)
are stored as the default cmdset on the player object and managed using the
CmdHandler object (see cmdhandler.py).

The power of having command sets in CmdSets like this is that CmdSets
can be merged together according to individual rules to create a new
on-the-fly CmdSet that is some combination of the
previous ones. Their function are borrowed to a large parts from mathematical
Set theory, it should not be much of a problem to understand.

See CmdHandler for practical examples on how to apply cmdsets
together to create interesting in-game effects.
"""

from django.utils.translation import ugettext as _
from src.utils.utils import inherits_from, is_iter
__all__ = ("CmdSet",)


class _CmdSetMeta(type):
    """
    This metaclass makes some minor on-the-fly convenience fixes to
    the cmdset class.
    """
    def __init__(mcs, *args, **kwargs):
        """
        Fixes some things in the cmdclass
        """
        # by default we key the cmdset the same as the
        # name of its class.
        if not hasattr(mcs, 'key') or not mcs.key:
            mcs.key = mcs.__name__
        mcs.path = "%s.%s" % (mcs.__module__, mcs.__name__)

        if not type(mcs.key_mergetypes) == dict:
            mcs.key_mergetypes = {}

        super(_CmdSetMeta, mcs).__init__(*args, **kwargs)


class CmdSet(object):
    """
    This class describes a unique cmdset that understands priorities. CmdSets
    can be merged and made to perform various set operations on each other.
    CmdSets have priorities that affect which of their ingoing commands
    gets used.

        In the examples, cmdset A always have higher priority than cmdset B.

        key - the name of the cmdset. This can be used on its own for game
        operations

        mergetype (partly from Set theory):

            Union -    The two command sets are merged so that as many
                        commands as possible of each cmdset ends up in the
                        merged cmdset. Same-name commands are merged by
                        priority.  This is the most common default.
                        Ex: A1,A3 + B1,B2,B4,B5 = A1,B2,A3,B4,B5
            Intersect - Only commands found in *both* cmdsets
                        (i.e. which have same names) end up in the merged
                        cmdset, with the higher-priority cmdset replacing the
                        lower one.  Ex: A1,A3 + B1,B2,B4,B5 = A1
            Replace -   The commands of this cmdset completely replaces
                        the lower-priority cmdset's commands, regardless
                        of if same-name commands exist.
                        Ex: A1,A3 + B1,B2,B4,B5 = A1,A3
            Remove -    This removes the relevant commands from the
                        lower-priority cmdset completely.  They are not
                        replaced with anything, so this in effects uses the
                        high-priority cmdset as a filter to affect the
                        low-priority cmdset.
                        Ex: A1,A3 + B1,B2,B4,B5 = B2,B4,B5

                     Note: Commands longer than 2 characters and starting
                           with double underscrores, like '__noinput_command'
                           are considered 'system commands' and are
                           excempt from all merge operations - they are
                           ALWAYS included across mergers and only affected
                           if same-named system commands replace them.

        priority- All cmdsets are always merged in pairs of two so that
                  the higher set's mergetype is applied to the
                  lower-priority cmdset. Default commands have priority 0,
                  high-priority ones like Exits and Channels have 10 and 9.
                  Priorities can be negative as well to give default
                  commands preference.

        duplicates - determines what happens when two sets of equal
                     priority merge. Default has the first of them in the
                     merger (i.e. A above) automatically taking
                     precedence. But if allow_duplicates is true, the
                     result will be a merger with more than one of each
                     name match.  This will usually lead to the player
                     receiving a multiple-match error higher up the road,
                     but can be good for things like cmdsets on non-player
                     objects in a room, to allow the system to warn that
                     more than one 'ball' in the room has the same 'kick'
                     command defined on it, so it may offer a chance to
                     select which ball to kick ...  Allowing duplicates
                     only makes sense for Union and Intersect, the setting
                     is ignored for the other mergetypes.

        key_mergetype (dict) - allows the cmdset to define a unique
                 mergetype for particular cmdsets.  Format is
                 {CmdSetkeystring:mergetype}. Priorities still apply.
                 Example: {'Myevilcmdset','Replace'} which would make
                 sure for this set to always use 'Replace' on
                 Myevilcmdset no matter what overall mergetype this set
                 has.

        no_objs  - don't include any commands from nearby objects
                      when searching for suitable commands
        no_exits  - ignore the names of exits when matching against
                            commands
        no_channels   - ignore the name of channels when matching against
                            commands (WARNING- this is dangerous since the
                            player can then not even ask staff for help if
                            something goes wrong)


    """
    __metaclass__ = _CmdSetMeta

    key = "Unnamed CmdSet"
    mergetype = "Union"
    priority = 0
    duplicates = False
    key_mergetypes = {}
    no_exits = False
    no_objs = False
    no_channels = False
    permanent = False
    errmessage = ""
    # pre-store properties to duplicate straight off
    to_duplicate = ("key", "cmdsetobj", "no_exits", "no_objs",
                    "no_channels", "permanent", "mergetype",
                    "priority", "duplicates", "errmessage")

    def __init__(self, cmdsetobj=None, key=None):
        """
        Creates a new CmdSet instance.

        cmdsetobj - this is the database object to which this particular
             instance of cmdset is related. It is often a character but
             may also be a regular object.
        """
        if key:
            self.key = key
        self.commands = []
        self.system_commands = []
        self.actual_mergetype = self.mergetype
        self.cmdsetobj = cmdsetobj
        # this is set only on merged sets, in cmdhandler.py, in order to
        # track, list and debug mergers correctly.
        self.merged_from = []

        # initialize system
        self.at_cmdset_creation()
        self._contains_cache = {}

    # Priority-sensitive merge operations for cmdsets

    def _union(self, cmdset_a, cmdset_b):
        "C = A U B. CmdSet A is assumed to have higher priority"
        cmdset_c = cmdset_a._duplicate()
        # we make copies, not refs by use of [:]
        cmdset_c.commands = cmdset_a.commands[:]
        if cmdset_a.duplicates and cmdset_a.priority == cmdset_b.priority:
            cmdset_c.commands.extend(cmdset_b.commands)
        else:
            cmdset_c.commands.extend([cmd for cmd in cmdset_b
                                      if not cmd in cmdset_a])
        return cmdset_c

    def _intersect(self, cmdset_a, cmdset_b):
        "C = A (intersect) B. A is assumed higher priority"
        cmdset_c = cmdset_a._duplicate()
        if cmdset_a.duplicates and cmdset_a.priority == cmdset_b.priority:
            for cmd in [cmd for cmd in cmdset_a if cmd in cmdset_b]:
                cmdset_c.add(cmd)
                cmdset_c.add(cmdset_b.get(cmd))
        else:
            cmdset_c.commands = [cmd for cmd in cmdset_a if cmd in cmdset_b]
        return cmdset_c

    def _replace(self, cmdset_a, cmdset_b):
        "C = A + B where the result is A."
        cmdset_c = cmdset_a._duplicate()
        cmdset_c.commands = cmdset_a.commands[:]
        return cmdset_c

    def _remove(self, cmdset_a, cmdset_b):
        "C = A + B, where B is filtered by A"
        cmdset_c = cmdset_a._duplicate()
        cmdset_c.commands = [cmd for cmd in cmdset_b if not cmd in cmdset_a]
        return cmdset_c

    def _instantiate(self, cmd):
        """
        checks so that object is an instantiated command
        and not, say a cmdclass. If it is, instantiate it.
        Other types, like strings, are passed through.
        """
        try:
            return cmd()
        except TypeError:
            return cmd

    def _duplicate(self):
        """
        Returns a new cmdset with the same settings as this one
        (no actual commands are copied over)
        """
        cmdset = CmdSet()
        for key, val in ((key, getattr(self, key)) for key in self.to_duplicate):
            if val != getattr(cmdset, key):
                # only copy if different from default; avoid turning
                # class-vars into instance vars
                setattr(cmdset, key, val)
        cmdset.key_mergetypes = self.key_mergetypes.copy()
        return cmdset
        #cmdset = self.__class__()
        #cmdset.__dict__.update(dict((key, val) for key, val in self.__dict__.items() if key in self.to_duplicate))
        #cmdset.key_mergetypes = self.key_mergetypes.copy() #copy.deepcopy(self.key_mergetypes)
        #return cmdset

    def __str__(self):
        """
        Show all commands in cmdset when printing it.
        """
        return ", ".join([str(cmd) for cmd in sorted(self.commands, key=lambda o:o.key)])

    def __iter__(self):
        """
        Allows for things like 'for cmd in cmdset':
        """
        return iter(self.commands)

    def __contains__(self, othercmd):
        """
        Returns True if this cmdset contains the given command (as defined
        by command name and aliases). This allows for things
        like 'if cmd in cmdset'
        """
        ret = self._contains_cache.get(othercmd)
        if ret is None:
            ret = othercmd in self.commands
            self._contains_cache[othercmd] = ret
        return ret

    def __add__(self, cmdset_b):
        """
        Merge this cmdset (A) with another cmdset (B) using the + operator,

        C = A + B

        Here, we (by convention) say that 'A is merged onto B to form
        C'.  The actual merge operation used in the 'addition' depends
        on which priorities A and B have. The one of the two with the
        highest priority will apply and give its properties to C. In
        the case of a tie, A takes priority and replaces the
        same-named commands in B unless A has the 'duplicate' variable
        set (which means both sets' commands are kept).
        """

        # It's okay to merge with None
        if not cmdset_b:
            return self

        sys_commands_a = self.get_system_cmds()
        sys_commands_b = cmdset_b.get_system_cmds()

        if self.priority >= cmdset_b.priority:
            # A higher or equal priority than B

            # preserve system __commands
            sys_commands = sys_commands_a + [cmd for cmd in sys_commands_b
                                             if cmd not in sys_commands_a]

            mergetype = self.key_mergetypes.get(cmdset_b.key, self.mergetype)
            if mergetype == "Intersect":
                cmdset_c = self._intersect(self, cmdset_b)
            elif mergetype == "Replace":
                cmdset_c = self._replace(self, cmdset_b)
            elif mergetype == "Remove":
                cmdset_c = self._remove(self, cmdset_b)
            else: # Union
                cmdset_c = self._union(self, cmdset_b)
            cmdset_c.no_channels = self.no_channels
            cmdset_c.no_exits = self.no_exits
            cmdset_c.no_objs = self.no_objs
            if self.key.startswith("_"):
                # don't rename new output if the merge set's name starts with _
                cmdset_c.key = cmdset_b.key

        else:
            # B higher priority than A

            # preserver system __commands
            sys_commands = sys_commands_b + [cmd for cmd in sys_commands_a
                                             if cmd not in sys_commands_b]

            mergetype = cmdset_b.key_mergetypes.get(self.key, cmdset_b.mergetype)
            if mergetype == "Intersect":
                cmdset_c = self._intersect(cmdset_b, self)
            elif mergetype == "Replace":
                cmdset_c = self._replace(cmdset_b, self)
            elif mergetype == "Remove":
                cmdset_c = self._remove(self, cmdset_b)
            else:  # Union
                cmdset_c = self._union(cmdset_b, self)
            cmdset_c.no_channels = cmdset_b.no_channels
            cmdset_c.no_exits = cmdset_b.no_exits
            cmdset_c.no_objs = cmdset_b.no_objs
            if cmdset_b.key.startswith("_"):
                # don't rename new output if the merge set's name starts with _
                cmdset_c.key = self.key

        # we store actual_mergetype since key_mergetypes
        # might be different from the main mergetype.
        # This is used for diagnosis.
        cmdset_c.actual_mergetype = mergetype

        # return the system commands to the cmdset
        cmdset_c.add(sys_commands)
        return cmdset_c

    def add(self, cmd):
        """
        Add a command, a list of commands or a cmdset to this cmdset.

        Note that if cmd already exists in set,
        it will replace the old one (no priority checking etc
        at this point; this is often used to overload
        default commands).

        If cmd is another cmdset class or -instance, the commands
        of that command set is added to this one, as if they were part
        of the original cmdset definition. No merging or priority checks
        are made, rather later added commands will simply replace
        existing ones to make a unique set.
        """

        if inherits_from(cmd, "src.commands.cmdset.CmdSet"):
            # cmd is a command set so merge all commands in that set
            # to this one. We raise a visible error if we created
            # an infinite loop (adding cmdset to itself somehow)
            try:
                cmd = self._instantiate(cmd)
            except RuntimeError:
                string = "Adding cmdset %(cmd)s to %(class)s lead to an "
                string += "infinite loop. When adding a cmdset to another, "
                string += "make sure they are not themself cyclically added to "
                string += "the new cmdset somewhere in the chain."
                raise RuntimeError(_(string) % {"cmd": cmd,
                                                "class": self.__class__})
            cmds = cmd.commands
        elif is_iter(cmd):
            cmds = [self._instantiate(c) for c in cmd]
        else:
            cmds = [self._instantiate(cmd)]
        commands = self.commands
        system_commands = self.system_commands
        for cmd in cmds:
            # add all commands
            if not hasattr(cmd, 'obj'):
                cmd.obj = self.cmdsetobj
            try:
                ic = commands.index(cmd)
                commands[ic] = cmd  # replace
            except ValueError:
                commands.append(cmd)
            # extra run to make sure to avoid doublets
            self.commands = list(set(commands))
            #print "In cmdset.add(cmd):", self.key, cmd
            # add system_command to separate list as well,
            # for quick look-up
            if cmd.key.startswith("__"):
                try:
                    ic = system_commands.index(cmd)
                    system_commands[ic] = cmd  # replace
                except ValueError:
                    system_commands.append(cmd)

    def remove(self, cmd):
        """
        Remove a command instance from the cmdset.
        cmd can be either a cmd instance or a key string.
        """
        cmd = self._instantiate(cmd)
        self.commands = [oldcmd for oldcmd in self.commands if oldcmd != cmd]

    def get(self, cmd):
        """
        Return the command in this cmdset that matches the
        given command. cmd may be either a command instance or
        a key string.
        """
        cmd = self._instantiate(cmd)
        for thiscmd in self.commands:
            if thiscmd == cmd:
                return thiscmd

    def count(self):
        "Return number of commands in set"
        return len(self.commands)

    def get_system_cmds(self):
        """
        Return system commands in the cmdset, defined as
        commands starting with double underscore __.
        These are excempt from merge operations.
        """
        return self.system_commands
        #return [cmd for cmd in self.commands if cmd.key.startswith('__')]

    def make_unique(self, caller):
        """
        This is an unsafe command meant to clean out a cmdset of
        doublet commands after it has been created. It is useful
        for commands inheriting cmdsets from the cmdhandler where
        obj-based cmdsets always are added double. Doublets will
        be weeded out with preference to commands defined on caller,
        otherwise just by first-come-first-served.
        """
        unique = {}
        for cmd in self.commands:
            if cmd.key in unique:
                ocmd = unique[cmd.key]
                if (hasattr(cmd, 'obj') and cmd.obj == caller) and not \
                        (hasattr(ocmd, 'obj') and ocmd.obj == caller):
                    unique[cmd.key] = cmd
            else:
                unique[cmd.key] = cmd
        self.commands = unique.values()

    def get_all_cmd_keys_and_aliases(self, caller=None):
        """
        Returns a list of all command keys and aliases
        available in this cmdset. If caller is given, the
        commands is checked for access on the "call" type
        before being returned.
        """
        names = []
        if caller:
            [names.extend(cmd._keyaliases) for cmd in self.commands
                           if cmd.access(caller)]
        else:
            [names.extend(cmd._keyaliases) for cmd in self.commands]
        return names

    def at_cmdset_creation(self):
        """
        Hook method - this should be overloaded in the inheriting
        class, and should take care of populating the cmdset
        by use of self.add().
        """
        pass

########NEW FILE########
__FILENAME__ = cmdsethandler
"""
CmdSethandler

The Cmdsethandler tracks an object's 'Current CmdSet', which is the
current merged sum of all CmdSets added to it.

A CmdSet constitues a set of commands. The CmdSet works as a special
intelligent container that, when added to other CmdSet make sure that
same-name commands are treated correctly (usually so there are no
doublets).  This temporary but up-to-date merger of CmdSet is jointly
called the Current Cmset. It is this Current CmdSet that the
commandhandler looks through whenever a player enters a command (it
also adds CmdSets from objects in the room in real-time). All player
objects have a 'default cmdset' containing all the normal in-game mud
commands (look etc).

So what is all this cmdset complexity good for?

In its simplest form, a CmdSet has no commands, only a key name. In
this case the cmdset's use is up to each individual game - it can be
used by an AI module for example (mobs in cmdset 'roam' move from room
to room, in cmdset 'attack' they enter combat with players).

Defining commands in cmdsets offer some further powerful game-design
consequences however. Here are some examples:

As mentioned above, all players always have at least the Default
CmdSet.  This contains the set of all normal-use commands in-game,
stuff like look and @desc etc. Now assume our players end up in a dark
room. You don't want the player to be able to do much in that dark
room unless they light a candle. You could handle this by changing all
your normal commands to check if the player is in a dark room. This
rapidly goes unwieldly and error prone. Instead you just define a
cmdset with only those commands you want to be available in the 'dark'
cmdset - maybe a modified look command and a 'light candle' command -
and have this completely replace the default cmdset.

Another example: Say you want your players to be able to go
fishing. You could implement this as a 'fish' command that fails
whenever the player has no fishing rod. Easy enough.  But what if you
want to make fishing more complex - maybe you want four-five different
commands for throwing your line, reeling in, etc? Most players won't
(we assume) have fishing gear, and having all those detailed commands
is cluttering up the command list. And what if you want to use the
'throw' command also for throwing rocks etc instead of 'using it up'
for a minor thing like fishing?

So instead you put all those detailed fishing commands into their own
CommandSet called 'Fishing'. Whenever the player gives the command
'fish' (presumably the code checks there is also water nearby), only
THEN this CommandSet is added to the Cmdhandler of the player. The
'throw' command (which normally throws rocks) is replaced by the
custom 'fishing variant' of throw. What has happened is that the
Fishing CommandSet was merged on top of the Default ones, and due to
how we defined it, its command overrules the default ones.

When we are tired of fishing, we give the 'go home' command (or
whatever) and the Cmdhandler simply removes the fishing CommandSet
so that we are back at defaults (and can throw rocks again).

Since any number of CommandSets can be piled on top of each other, you
can then implement separate sets for different situations. For
example, you can have a 'On a boat' set, onto which you then tack on
the 'Fishing' set. Fishing from a boat? No problem!
"""
from src.utils import logger, utils
from src.commands.cmdset import CmdSet
from src.server.models import ServerConfig

from django.utils.translation import ugettext as _
__all__ = ("import_cmdset", "CmdSetHandler")

_CACHED_CMDSETS = {}


class _ErrorCmdSet(CmdSet):
    "This is a special cmdset used to report errors"
    key = "_CMDSET_ERROR"
    errmessage = "Error when loading cmdset."

class _EmptyCmdSet(CmdSet):
    "This cmdset represents an empty cmdset"
    key = "_EMPTY_CMDSET"
    priority = -101
    mergetype = "Union"

def import_cmdset(python_path, cmdsetobj, emit_to_obj=None, no_logging=False):
    """
    This helper function is used by the cmdsethandler to load a cmdset
    instance from a python module, given a python_path. It's usually accessed
    through the cmdsethandler's add() and add_default() methods.
    python_path - This is the full path to the cmdset object.
    cmdsetobj - the database object/typeclass on which this cmdset is to be
            assigned (this can be also channels and exits, as well as players
            but there will always be such an object)
    emit_to_obj - if given, error is emitted to this object (in addition
                  to logging)
    no_logging - don't log/send error messages. This can be useful
                if import_cmdset is just used to check if this is a
                valid python path or not.
    function returns None if an error was encountered or path not found.
    """

    try:
        try:
            #print "importing %s: _CACHED_CMDSETS=%s" % (python_path, _CACHED_CMDSETS)
            wanted_cache_key = python_path
            cmdsetclass = _CACHED_CMDSETS.get(wanted_cache_key, None)
            errstring = ""
            if not cmdsetclass:
                #print "cmdset '%s' not in cache. Reloading %s on %s." % (wanted_cache_key, python_path, cmdsetobj)
                # Not in cache. Reload from disk.
                modulepath, classname = python_path.rsplit('.', 1)
                module = __import__(modulepath, fromlist=[True])
                cmdsetclass = module.__dict__[classname]
                _CACHED_CMDSETS[wanted_cache_key] = cmdsetclass
            #instantiate the cmdset (and catch its errors)
            if callable(cmdsetclass):
                cmdsetclass = cmdsetclass(cmdsetobj)
            return cmdsetclass

        except ImportError:
            errstring = _("Error loading cmdset: Couldn't import module '%s'.")
            errstring = errstring % modulepath
            raise
        except KeyError:
            errstring = _("Error in loading cmdset: No cmdset class '%(classname)s' in %(modulepath)s.")
            errstring = errstring % {"classname": classname,
                                     "modulepath": modulepath}
            raise
        except Exception:
            errstring = _("Compile/Run error when loading cmdset '%s'. Error was logged.")
            errstring = errstring % (python_path)
            raise
    except Exception:
        # returning an empty error cmdset
        if not no_logging:
            logger.log_trace(errstring)
            if emit_to_obj and not ServerConfig.objects.conf("server_starting_mode"):
                object.__getattribute__(emit_to_obj, "msg")(errstring)
        err_cmdset = _ErrorCmdSet()
        err_cmdset.errmessage = errstring
        return err_cmdset

# classes


class CmdSetHandler(object):
    """
    The CmdSetHandler is always stored on an object, this object is supplied
    as an argument.

    The 'current' cmdset is the merged set currently active for this object.
    This is the set the game engine will retrieve when determining which
    commands are available to the object. The cmdset_stack holds a history of
    all CmdSets to allow the handler to remove/add cmdsets at will. Doing so
    will re-calculate the 'current' cmdset.
    """

    def __init__(self, obj):
        """
        This method is called whenever an object is recreated.

        obj - this is a reference to the game object this handler
              belongs to.
        """
        self.obj = obj

        # the id of the "merged" current cmdset for easy access.
        self.key = None
        # this holds the "merged" current command set
        self.current = None
        # this holds a history of CommandSets
        self.cmdset_stack = [_EmptyCmdSet(cmdsetobj=self.obj)]
        # this tracks which mergetypes are actually in play in the stack
        self.mergetype_stack = ["Union"]

        # the subset of the cmdset_paths that are to be stored in the database
        self.permanent_paths = [""]

        #self.update(init_mode=True) is then called from the object __init__.

    def __str__(self):
        "Display current commands"

        string = ""
        mergelist = []
        if len(self.cmdset_stack) > 1:
            # We have more than one cmdset in stack; list them all
            #print self.cmdset_stack, self.mergetype_stack
            for snum, cmdset in enumerate(self.cmdset_stack):
                mergetype = self.mergetype_stack[snum]
                permstring = "non-perm"
                if cmdset.permanent:
                    permstring = "perm"
                if mergetype != cmdset.mergetype:
                    mergetype = "%s^" % (mergetype)
                string += "\n %i: <%s (%s, prio %i, %s)>: %s" % \
                    (snum, cmdset.key, mergetype,
                     cmdset.priority, permstring, cmdset)
                mergelist.append(str(snum))
            string += "\n"

        # Display the currently active cmdset, limited by self.obj's permissions
        mergetype = self.mergetype_stack[-1]
        if mergetype != self.current.mergetype:
            merged_on = self.cmdset_stack[-2].key
            mergetype = _("custom %(mergetype)s on cmdset '%(merged_on)s'") % \
                          {"mergetype": mergetype, "merged_on":merged_on}
        if mergelist:
            string += _(" <Merged %(mergelist)s (%(mergetype)s, prio %(prio)i)>: %(current)s") % \
                    {"mergelist": "+".join(mergelist),
                     "mergetype": mergetype, "prio": self.current.priority,
                     "current":self.current}
        else:
            permstring = "non-perm"
            if self.current.permanent:
                permstring = "perm"
            string += _(" <%(key)s (%(mergetype)s, prio %(prio)i, %(permstring)s)>: %(keylist)s") % \
                     {"key": self.current.key, "mergetype": mergetype,
                      "prio": self.current.priority, "permstring": permstring,
                      "keylist": ", ".join(cmd.key for cmd in sorted(self.current, key=lambda o: o.key))}
        return string.strip()

    def _import_cmdset(self, cmdset_path, emit_to_obj=None):
        """
        Method wrapper for import_cmdset.
        load a cmdset from a module.
        cmdset_path - the python path to an cmdset object.
        emit_to_obj - object to send error messages to
        """
        if not emit_to_obj:
            emit_to_obj = self.obj
        return import_cmdset(cmdset_path, self.obj, emit_to_obj)

    def update(self, init_mode=False):
        """
        Re-adds all sets in the handler to have an updated
        current set.

        init_mode is used right after this handler was
        created; it imports all permanent cmdsets from db.
        """
        if init_mode:
            # reimport all permanent cmdsets
            storage = self.obj.cmdset_storage
            #print "cmdset_storage:", self.obj.cmdset_storage
            if storage:
                self.cmdset_stack = []
                for pos, path in enumerate(storage):
                    if pos == 0 and not path:
                        self.cmdset_stack = [_EmptyCmdSet(cmdsetobj=self.obj)]
                    elif path:
                        cmdset = self._import_cmdset(path)
                        if cmdset:
                            cmdset.permanent = cmdset.key != '_ERROR_CMDSET'
                            self.cmdset_stack.append(cmdset)

        # merge the stack into a new merged cmdset
        new_current = None
        self.mergetype_stack = []
        for cmdset in self.cmdset_stack:
            try:
                # for cmdset's '+' operator, order matters.
                new_current = cmdset + new_current
            except TypeError:
                continue
            self.mergetype_stack.append(new_current.actual_mergetype)
        self.current = new_current

    def add(self, cmdset, emit_to_obj=None, permanent=False):
        """
        Add a cmdset to the handler, on top of the old ones.
        Default is to not make this permanent, i.e. the set
        will not survive a server reset.

        cmdset - can be a cmdset object or the python path to
                 such an object.
        emit_to_obj - an object to receive error messages.
        permanent - this cmdset will remain across a server reboot

        Note: An interesting feature of this method is if you were to
        send it an *already instantiated cmdset* (i.e. not a class),
        the current cmdsethandler's obj attribute will then *not* be
        transferred over to this already instantiated set (this is
        because it might be used elsewhere and can cause strange effects).
        This means you could in principle have the handler
        launch command sets tied to a *different* object than the
        handler. Not sure when this would be useful, but it's a 'quirk'
        that has to be documented.
        """
        if callable(cmdset):
            if not utils.inherits_from(cmdset, CmdSet):
                raise Exception(_("Only CmdSets can be added to the cmdsethandler!"))
            cmdset = cmdset(self.obj)
        elif isinstance(cmdset, basestring):
            # this is (maybe) a python path. Try to import from cache.
            cmdset = self._import_cmdset(cmdset)
        if cmdset and cmdset.key != '_CMDSET_ERROR':
            if permanent and cmdset.key != '_CMDSET_ERROR':
                # store the path permanently
                cmdset.permanent = True
                storage = self.obj.cmdset_storage
                if not storage:
                    storage = ["", cmdset.path]
                else:
                    storage.append(cmdset.path)
                self.obj.cmdset_storage = storage
            else:
                cmdset.permanent = False
            self.cmdset_stack.append(cmdset)
            self.update()

    def add_default(self, cmdset, emit_to_obj=None, permanent=True):
        """
        Add a new default cmdset. If an old default existed,
        it is replaced. If permanent is set, the set will survive a reboot.
        cmdset - can be a cmdset object or the python path to
                 an instance of such an object.
        emit_to_obj - an object to receive error messages.
        permanent - save cmdset across reboots
        See also the notes for self.add(), which applies here too.
        """
        if callable(cmdset):
            if not utils.inherits_from(cmdset, CmdSet):
                raise Exception(_("Only CmdSets can be added to the cmdsethandler!"))
            cmdset = cmdset(self.obj)
        elif isinstance(cmdset, basestring):
            # this is (maybe) a python path. Try to import from cache.
            cmdset = self._import_cmdset(cmdset)
        if cmdset and cmdset.key != '_CMDSET_ERROR':
            if self.cmdset_stack:
                self.cmdset_stack[0] = cmdset
                self.mergetype_stack[0] = cmdset.mergetype
            else:
                self.cmdset_stack = [cmdset]
                self.mergetype_stack = [cmdset.mergetype]

            if permanent and cmdset.key != '_CMDSET_ERROR':
                cmdset.permanent = True
                storage = self.obj.cmdset_storage
                if storage:
                    storage[0] = cmdset.path
                else:
                    storage = [cmdset.path]
                self.obj.cmdset_storage = storage
            else:
                cmdset.permanent = False
            self.update()

    def delete(self, cmdset=None):
        """
        Remove a cmdset from the  handler.

        cmdset can be supplied either as a cmdset-key,
        an instance of the CmdSet or a python path
        to the cmdset. If no key is given,
        the last cmdset in the stack is removed. Whenever
        the cmdset_stack changes, the cmdset is updated.
        The default cmdset (first entry in stack) is never
        removed - remove it explicitly with delete_default.

        """
        if len(self.cmdset_stack) < 2:
            # don't allow deleting default cmdsets here.
            return

        if not cmdset:
            # remove the last one in the stack
            cmdset = self.cmdset_stack.pop()
            if cmdset.permanent:
                storage = self.obj.cmdset_storage
                storage.pop()
                self.obj.cmdset_storage = storage
        else:
            # try it as a callable
            if callable(cmdset) and hasattr(cmdset, 'path'):
                delcmdsets = [cset for cset in self.cmdset_stack[1:]
                              if cset.path == cmdset.path]
            else:
                # try it as a path or key
                delcmdsets = [cset for cset in self.cmdset_stack[1:]
                              if cset.path == cmdset or cset.key == cmdset]
            storage = []

            if any(cset.permanent for cset in delcmdsets):
                # only hit database if there's need to
                storage = self.obj.cmdset_storage
                for cset in delcmdsets:
                    if cset.permanent:
                        try:
                            storage.remove(cset.path)
                        except ValueError:
                            pass
            for cset in delcmdsets:
                # clean the in-memory stack
                try:
                    self.cmdset_stack.remove(cset)
                except ValueError:
                    pass
        # re-sync the cmdsethandler.
        self.update()

    def delete_default(self):
        """
        This explicitly deletes the default cmdset. It's the
        only command that can.
        """
        if self.cmdset_stack:
            cmdset = self.cmdset_stack[0]
            if cmdset.permanent:
                storage = self.obj.cmdset_storage
                if storage:
                    storage[0] = ""
                else:
                    storage = [""]
                self.cmdset_storage = storage
            self.cmdset_stack[0] = _EmptyCmdSet(cmdsetobj=self.obj)
        else:
            self.cmdset_stack = [_EmptyCmdSet(cmdsetobj=self.obj)]
        self.update()

    def all(self):
        """
        Returns the list of cmdsets. Mostly useful to check
        if stack if empty or not.
        """
        return self.cmdset_stack

    def clear(self):
        """
        Removes all extra Command sets from the handler, leaving only the
        default one.
        """
        self.cmdset_stack = [self.cmdset_stack[0]]
        self.mergetype_stack = [self.cmdset_stack[0].mergetype]
        storage = self.obj.cmdset_storage
        if storage:
            storage = storage[0]
            self.obj.cmdset_storage = storage
        self.update()

    def has_cmdset(self, cmdset_key, must_be_default=False):
        """
        checks so the cmdsethandler contains a cmdset with the given key.
        must_be_default - only match against the default cmdset.
        """
        if must_be_default:
            return self.cmdset_stack and self.cmdset_stack[0].key == cmdset_key
        else:
            return any([cmdset.key == cmdset_key for cmdset in self.cmdset_stack])

    def reset(self):
        """
        Force reload of all cmdsets in handler. This should be called
        after _CACHED_CMDSETS have been cleared (normally by @reload).
        """
        new_cmdset_stack = []
        new_mergetype_stack = []
        for cmdset in self.cmdset_stack:
            if cmdset.key == "_EMPTY_CMDSET":
                new_cmdset_stack.append(cmdset)
                new_mergetype_stack.append("Union")
            else:
                new_cmdset_stack.append(self._import_cmdset(cmdset.path))
                new_mergetype_stack.append(cmdset.mergetype)
        self.cmdset_stack = new_cmdset_stack
        self.mergetype_stack = new_mergetype_stack
        self.update()

########NEW FILE########
__FILENAME__ = command
"""
The base Command class.

All commands in Evennia inherit from the 'Command' class in this module.

"""

import re
from src.locks.lockhandler import LockHandler
from src.utils.utils import is_iter, fill


def _init_command(mcs, **kwargs):
    """
    Helper command.
    Makes sure all data are stored as lowercase and
    do checking on all properties that should be in list form.
    Sets up locks to be more forgiving. This is used both by the metaclass
    and (optionally) at instantiation time.

    If kwargs are given, these are set as instance-specific properties
    on the command.
    """
    for i in range(len(kwargs)):
        # used for dynamic creation of commands
        key, value = kwargs.popitem()
        setattr(mcs, key, value)

    mcs.key = mcs.key.lower()
    if mcs.aliases and not is_iter(mcs.aliases):
        try:
            mcs.aliases = [str(alias).strip().lower()
                          for alias in mcs.aliases.split(',')]
        except Exception:
            mcs.aliases = []
    mcs.aliases = list(set(alias for alias in mcs.aliases
                           if alias and alias != mcs.key))

    # optimization - a set is much faster to match against than a list
    mcs._matchset = set([mcs.key] + mcs.aliases)
    # optimization for looping over keys+aliases
    mcs._keyaliases = tuple(mcs._matchset)

    # by default we don't save the command between runs
    if not hasattr(mcs, "save_for_next"):
        mcs.save_for_next = False

    # pre-process locks as defined in class definition
    temp = []
    if hasattr(mcs, 'permissions'):
        mcs.locks = mcs.permissions
    if not hasattr(mcs, 'locks'):
        # default if one forgets to define completely
        mcs.locks = "cmd:all()"
    if not "cmd:" in mcs.locks:
        mcs.locks = "cmd:all();" + mcs.locks
    for lockstring in mcs.locks.split(';'):
        if lockstring and not ':' in lockstring:
            lockstring = "cmd:%s" % lockstring
        temp.append(lockstring)
    mcs.lock_storage = ";".join(temp)

    if hasattr(mcs, 'arg_regex') and isinstance(mcs.arg_regex, basestring):
        mcs.arg_regex = re.compile(r"%s" % mcs.arg_regex, re.I)
    else:
        mcs.arg_regex = None
    if not hasattr(mcs, "auto_help"):
        mcs.auto_help = True
    if not hasattr(mcs, 'is_exit'):
        mcs.is_exit = False
    if not hasattr(mcs, "help_category"):
        mcs.help_category = "general"
    mcs.help_category = mcs.help_category.lower()


class CommandMeta(type):
    """
    The metaclass cleans up all properties on the class
    """
    def __init__(mcs, *args, **kwargs):
        _init_command(mcs, **kwargs)
        super(CommandMeta, mcs).__init__(*args, **kwargs)

#    The Command class is the basic unit of an Evennia command; when
#    defining new commands, the admin subclass this class and
#    define their own parser method to handle the input. The
#    advantage of this is inheritage; commands that have similar
#    structure can parse the input string the same way, minimizing
#    parsing errors.


class Command(object):
    """
    Base command

    Usage:
      command [args]

    This is the base command class. Inherit from this
    to create new commands.

    The cmdhandler makes the following variables available to the
    command methods (so you can always assume them to be there):
    self.caller - the game object calling the command
    self.cmdstring - the command name used to trigger this command (allows
                     you to know which alias was used, for example)
    cmd.args - everything supplied to the command following the cmdstring
               (this is usually what is parsed in self.parse())
    cmd.cmdset - the cmdset from which this command was matched (useful only
                seldomly, notably for help-type commands, to create dynamic
                help entries and lists)
    cmd.obj - the object on which this command is defined. If a default command,
                 this is usually the same as caller.

    The following class properties can/should be defined on your child class:

    key - identifier for command (e.g. "look")
    aliases - (optional) list of aliases (e.g. ["l", "loo"])
    locks - lock string (default is "cmd:all()")
    help_category - how to organize this help entry in help system
                    (default is "General")
    auto_help - defaults to True. Allows for turning off auto-help generation
    arg_regex - (optional) raw string regex defining how the argument part of
                the command should look in order to match for this command
                (e.g. must it be a space between cmdname and arg?)

    (Note that if auto_help is on, this initial string is also used by the
    system to create the help entry for the command, so it's a good idea to
    format it similar to this one)
    """
    # Tie our metaclass, for some convenience cleanup
    __metaclass__ = CommandMeta

    # the main way to call this command (e.g. 'look')
    key = "command"
    # alternative ways to call the command (e.g. 'l', 'glance', 'examine')
    aliases = []
    # a list of lock definitions on the form
    #   cmd:[NOT] func(args) [ AND|OR][ NOT] func2(args)
    locks = ""
    # used by the help system to group commands in lists.
    help_category = "general"

    # This allows to turn off auto-help entry creation for individual commands.
    auto_help = True
    # auto-set (by Evennia on command instantiation) are:
    #   obj - which object this command is defined on
    #   sessid - which session-id (if any) is responsible for
    # triggering this command
    #

    def __init__(self, **kwargs):
        """the lockhandler works the same as for objects.
        optional kwargs will be set as properties on the Command at runtime,
        overloading evential same-named class properties."""
        if kwargs:
            _init_command(self, **kwargs)
        self.lockhandler = LockHandler(self)

    def __str__(self):
        "Print the command"
        return self.key

    def __eq__(self, cmd):
        """
        Compare two command instances to each other by matching their
        key and aliases.
        input can be either a cmd object or the name of a command.
        """
        try:
            # first assume input is a command (the most common case)
            return cmd.key in self._matchset
        except AttributeError:
            # probably got a string
            return cmd in self._matchset

    def __ne__(self, cmd):
        """
        The logical negation of __eq__. Since this is one of the
        most called methods in Evennia (along with __eq__) we do some
        code-duplication here rather than issuing a method-lookup to __eq__.
        """
        try:
            return not cmd.key in self._matcheset
        except AttributeError:
            return not cmd in self._matchset

    def __contains__(self, query):
        """
        This implements searches like 'if query in cmd'. It's a fuzzy matching
        used by the help system, returning True if query can be found
        as a substring of the commands key or its aliases.

        query (str) - query to match against. Should be lower case.

        """
        return any(query in keyalias for keyalias in self._keyaliases)

    def match(self, cmdname):
        """
        This is called by the system when searching the available commands,
        in order to determine if this is the one we wanted. cmdname was
        previously extracted from the raw string by the system.

        cmdname (str) is always lowercase when reaching this point.

        """
        return cmdname in self._matchset

    def access(self, srcobj, access_type="cmd", default=False):
        """
        This hook is called by the cmdhandler to determine if srcobj
        is allowed to execute this command. It should return a boolean
        value and is not normally something that need to be changed since
        it's using the Evennia permission system directly.
        """
        return self.lockhandler.check(srcobj, access_type, default=default)

    def msg(self, msg="", to_obj=None, from_obj=None,
            sessid=None, all_sessions=False, **kwargs):
        """
        This is a shortcut instad of calling msg() directly on an object - it
        will detect if caller is an Object or a Player and also appends
        self.sessid automatically.

        msg - text string of message to send
        to_obj - target object of message. Defaults to self.caller
        from_obj - source of message. Defaults to to_obj
        data - optional dictionary of data
        sessid - supply data only to a unique sessid (normally not used -
           this is only potentially useful if to_obj is a Player object
           different from self.caller or self.caller.player)
        all_sessions (bool) - default is to send only to the session
           connected to the target object
        """
        from_obj = from_obj or self.caller
        to_obj = to_obj or from_obj
        if not sessid:
            if hasattr(to_obj, "sessid"):
                # this is the case when to_obj is e.g. a Character
                sessid = all_sessions and None or to_obj.sessid
            elif to_obj == self.caller:
                # this is the case if to_obj is the calling Player
                sessid = all_sessions and None or self.sessid
            else:
                # if to_obj is a different Player, all their sessions
                # will be notified unless sessid was given specifically
                sessid = None
        to_obj.msg(msg, from_obj=from_obj, sessid=sessid, **kwargs)

    # Common Command hooks

    def at_pre_cmd(self):
        """
        This hook is called before self.parse() on all commands
        """
        pass

    def at_post_cmd(self):
        """
        This hook is called after the command has finished executing
        (after self.func()).
        """
        pass

    def parse(self):
        """
        Once the cmdhandler has identified this as the command we
        want, this function is run. If many of your commands have
        a similar syntax (for example 'cmd arg1 = arg2') you should simply
        define this once and just let other commands of the same form
        inherit from this. See the docstring of this module for
        which object properties are available to use
        (notably self.args).
        """
        pass

    def func(self):
        """
        This is the actual executing part of the command.
        It is called directly after self.parse(). See the docstring
        of this module for which object properties are available
        (beyond those set in self.parse())
        """
        # a simple test command to show the available properties
        string = "-" * 50
        string += "\n{w%s{n - Command variables from evennia:\n" % self.key
        string += "-" * 50
        string += "\nname of cmd (self.key): {w%s{n\n" % self.key
        string += "cmd aliases (self.aliases): {w%s{n\n" % self.aliases
        string += "cmd perms (self.permissions): {w%s{n\n" % self.permissions
        string += "help category (self.help_category): {w%s{n\n" % self.help_category
        string += "object calling (self.caller): {w%s{n\n" % self.caller
        string += "object storing cmdset (self.obj): {w%s{n\n" % self.obj
        string += "command string given (self.cmdstring): {w%s{n\n" % self.cmdstring
        # show cmdset.key instead of cmdset to shorten output
        string += fill("current cmdset (self.cmdset): {w%s{n\n" % self.cmdset)

        self.caller.msg(string)

########NEW FILE########
__FILENAME__ = connection_screen
#
# This is Evennia's default connection screen. It is imported
# and run from game/gamesrc/world/connection_screens.py.
#

from django.conf import settings
from src.utils import utils

DEFAULT_SCREEN = \
"""{b=============================================================={n
 Welcome to {g%s{n, version %s!

 If you have an existing account, connect to it by typing:
      {wconnect <username> <password>{n
 If you need to create an account, type (without the <>'s):
      {wcreate <username> <password>{n

 If you have spaces in your username, enclose it in quotes.
 Enter {whelp{n for more info. {wlook{n will re-show this screen.
{b=============================================================={n""" \
% (settings.SERVERNAME, utils.get_evennia_version())

########NEW FILE########
__FILENAME__ = admin
"""

Admin commands

"""

import time
import re
from django.conf import settings
from src.server.sessionhandler import SESSIONS
from src.server.models import ServerConfig
from src.utils import prettytable, search
from src.commands.default.muxcommand import MuxCommand

PERMISSION_HIERARCHY = [p.lower() for p in settings.PERMISSION_HIERARCHY]

# limit members for API inclusion
__all__ = ("CmdBoot", "CmdBan", "CmdUnban", "CmdDelPlayer",
           "CmdEmit", "CmdNewPassword", "CmdPerm", "CmdWall")


class CmdBoot(MuxCommand):
    """
    kick a player from the server.

    Usage
      @boot[/switches] <player obj> [: reason]

    Switches:
      quiet - Silently boot without informing player
      port - boot by port number instead of name or dbref

    Boot a player object from the server. If a reason is
    supplied it will be echoed to the user unless /quiet is set.
    """

    key = "@boot"
    locks = "cmd:perm(boot) or perm(Wizards)"
    help_category = "Admin"

    def func(self):
        "Implementing the function"
        caller = self.caller
        args = self.args

        if not args:
            caller.msg("Usage: @boot[/switches] <player> [:reason]")
            return

        if ':' in args:
            args, reason = [a.strip() for a in args.split(':', 1)]
        else:
            args, reason = args, ""

        boot_list = []

        if 'port' in self.switches:
            # Boot a particular port.
            sessions = SESSIONS.get_session_list(True)
            for sess in sessions:
                # Find the session with the matching port number.
                if sess.getClientAddress()[1] == int(args):
                    boot_list.append(sess)
                    break
        else:
            # Boot by player object
            pobj = search.player_search(args)
            if not pobj:
                self.caller("Player %s was not found." % pobj.key)
                return
            pobj = pobj[0]
            if not pobj.access(caller, 'boot'):
                string = "You don't have the permission to boot %s."
                pobj.msg(string)
                return
            # we have a bootable object with a connected user
            matches = SESSIONS.sessions_from_player(pobj)
            for match in matches:
                boot_list.append(match)

        if not boot_list:
            caller.msg("No matching sessions found. The Player does not seem to be online.")
            return

        # Carry out the booting of the sessions in the boot list.

        feedback = None
        if not 'quiet' in self.switches:
            feedback = "You have been disconnected by %s.\n" % caller.name
            if reason:
                feedback += "\nReason given: %s" % reason

        for session in boot_list:
            session.msg(feedback)
            pobj.disconnect_session_from_player(session.sessid)


# regex matching IP addresses with wildcards, eg. 233.122.4.*
IPREGEX = re.compile(r"[0-9*]{1,3}\.[0-9*]{1,3}\.[0-9*]{1,3}\.[0-9*]{1,3}")


def list_bans(banlist):
    """
    Helper function to display a list of active bans. Input argument
    is the banlist read into the two commands @ban and @unban below.
    """
    if not banlist:
        return "No active bans were found."

    table = prettytable.PrettyTable(["{wid", "{wname/ip", "{wdate", "{wreason"])
    for inum, ban in enumerate(banlist):
        table.add_row([str(inum + 1),
                       ban[0] and ban[0] or ban[1],
                       ban[3], ban[4]])
    string = "{wActive bans:{n\n%s" % table
    return string


class CmdBan(MuxCommand):
    """
    ban a player from the server

    Usage:
      @ban [<name or ip> [: reason]]

    Without any arguments, shows numbered list of active bans.

    This command bans a user from accessing the game. Supply an
    optional reason to be able to later remember why the ban was put in
    place

    It is often to
    prefer over deleting a player with @delplayer. If banned by name,
    that player account can no longer be logged into.

    IP (Internet Protocol) address banning allows to block all access
    from a specific address or subnet. Use the asterisk (*) as a
    wildcard.

    Examples:
      @ban thomas             - ban account 'thomas'
      @ban/ip 134.233.2.111   - ban specific ip address
      @ban/ip 134.233.2.*     - ban all in a subnet
      @ban/ip 134.233.*.*     - even wider ban

    A single IP filter is easy to circumvent by changing the computer
    (also, some ISPs assign only temporary IPs to their users in the
    first placer. Widening the IP block filter with wildcards might be
    tempting, but remember that blocking too much may accidentally
    also block innocent users connecting from the same country and
    region.

    """
    key = "@ban"
    aliases = ["@bans"]
    locks = "cmd:perm(ban) or perm(Immortals)"
    help_category = "Admin"

    def func(self):
        """
        Bans are stored in a serverconf db object as a list of
        dictionaries:
          [ (name, ip, ipregex, date, reason),
            (name, ip, ipregex, date, reason),...  ]
        where name and ip are set by the user and are shown in
        lists. ipregex is a converted form of ip where the * is
        replaced by an appropriate regex pattern for fast
        matching. date is the time stamp the ban was instigated and
        'reason' is any optional info given to the command. Unset
        values in each tuple is set to the empty string.
        """
        banlist = ServerConfig.objects.conf('server_bans')
        if not banlist:
            banlist = []

        if not self.args or (self.switches
                             and not any(switch in ('ip', 'name')
                             for switch in self.switches)):
            self.caller.msg(list_bans(banlist))
            return

        now = time.ctime()
        reason = ""
        if ':' in self.args:
            ban, reason = self.args.rsplit(':', 1)
        else:
            ban = self.args
        ban = ban.lower()
        ipban = IPREGEX.findall(ban)
        if not ipban:
            # store as name
            typ = "Name"
            bantup = (ban, "", "", now, reason)
        else:
            # an ip address.
            typ = "IP"
            ban = ipban[0]
            # replace * with regex form and compile it
            ipregex = ban.replace('.', '\.')
            ipregex = ipregex.replace('*', '[0-9]{1,3}')
            #print "regex:",ipregex
            ipregex = re.compile(r"%s" % ipregex)
            bantup = ("", ban, ipregex, now, reason)
        # save updated banlist
        banlist.append(bantup)
        ServerConfig.objects.conf('server_bans', banlist)
        self.caller.msg("%s-Ban {w%s{n was added." % (typ, ban))


class CmdUnban(MuxCommand):
    """
    remove a ban from a player

    Usage:
      @unban <banid>

    This will clear a player name/ip ban previously set with the @ban
    command.  Use this command without an argument to view a numbered
    list of bans. Use the numbers in this list to select which one to
    unban.

    """
    key = "@unban"
    locks = "cmd:perm(unban) or perm(Immortals)"
    help_category = "Admin"

    def func(self):
        "Implement unbanning"

        banlist = ServerConfig.objects.conf('server_bans')

        if not self.args:
            self.caller.msg(list_bans(banlist))
            return

        try:
            num = int(self.args)
        except Exception:
            self.caller.msg("You must supply a valid ban id to clear.")
            return

        if not banlist:
            self.caller.msg("There are no bans to clear.")
        elif not (0 < num < len(banlist) + 1):
            self.caller.msg("Ban id {w%s{x was not found." % self.args)
        else:
            # all is ok, clear ban
            ban = banlist[num - 1]
            del banlist[num - 1]
            ServerConfig.objects.conf('server_bans', banlist)
            self.caller.msg("Cleared ban %s: %s" %
                                    (num, " ".join([s for s in ban[:2]])))


class CmdDelPlayer(MuxCommand):
    """
    delete a player from the server

    Usage:
      @delplayer[/switch] <name> [: reason]

    Switch:
      delobj - also delete the player's currently
               assigned in-game object.

    Completely deletes a user from the server database,
    making their nick and e-mail again available.
    """

    key = "@delplayer"
    locks = "cmd:perm(delplayer) or perm(Immortals)"
    help_category = "Admin"

    def func(self):
        "Implements the command."

        caller = self.caller
        args = self.args

        if hasattr(caller, 'player'):
            caller = caller.player

        if not args:
            self.msg("Usage: @delplayer <player/user name or #id> [: reason]")
            return

        reason = ""
        if ':' in args:
            args, reason = [arg.strip() for arg in args.split(':', 1)]

        # We use player_search since we want to be sure to find also players
        # that lack characters.
        players = search.player_search(args)

        if not players:
            self.msg('Could not find a player by that name.')
            return

        if len(players) > 1:
            string = "There were multiple matches:"
            for player in players:
                string += "\n %s %s" % (player.id, player.key)
            return

        # one single match

        player = players.pop()

        if not player.access(caller, 'delete'):
            string = "You don't have the permissions to delete that player."
            self.msg(string)
            return

        uname = player.username
        # boot the player then delete
        self.msg("Informing and disconnecting player ...")
        string = "\nYour account '%s' is being *permanently* deleted.\n" % uname
        if reason:
            string += " Reason given:\n  '%s'" % reason
        player.msg(string)
        player.delete()
        self.msg("Player %s was successfully deleted." % uname)


class CmdEmit(MuxCommand):
    """
    admin command for emitting message to multiple objects

    Usage:
      @emit[/switches] [<obj>, <obj>, ... =] <message>
      @remit           [<obj>, <obj>, ... =] <message>
      @pemit           [<obj>, <obj>, ... =] <message>

    Switches:
      room : limit emits to rooms only (default)
      players : limit emits to players only
      contents : send to the contents of matched objects too

    Emits a message to the selected objects or to
    your immediate surroundings. If the object is a room,
    send to its contents. @remit and @pemit are just
    limited forms of @emit, for sending to rooms and
    to players respectively.
    """
    key = "@emit"
    aliases = ["@pemit", "@remit"]
    locks = "cmd:perm(emit) or perm(Builders)"
    help_category = "Admin"

    def func(self):
        "Implement the command"

        caller = self.caller
        args = self.args

        if not args:
            string = "Usage: "
            string += "\n@emit[/switches] [<obj>, <obj>, ... =] <message>"
            string += "\n@remit           [<obj>, <obj>, ... =] <message>"
            string += "\n@pemit           [<obj>, <obj>, ... =] <message>"
            caller.msg(string)
            return

        rooms_only = 'rooms' in self.switches
        players_only = 'players' in self.switches
        send_to_contents = 'contents' in self.switches

        # we check which command was used to force the switches
        if self.cmdstring == '@remit':
            rooms_only = True
            send_to_contents = True
        elif self.cmdstring == '@pemit':
            players_only = True

        if not self.rhs:
            message = self.args
            objnames = [caller.location.key]
        else:
            message = self.rhs
            objnames = self.lhslist

        # send to all objects
        for objname in objnames:
            obj = caller.search(objname, global_search=True)
            if not obj:
                return
            if rooms_only and not obj.location is None:
                caller.msg("%s is not a room. Ignored." % objname)
                continue
            if players_only and not obj.has_player:
                caller.msg("%s has no active player. Ignored." % objname)
                continue
            if obj.access(caller, 'tell'):
                obj.msg(message)
                if send_to_contents and hasattr(obj, "msg_contents"):
                    obj.msg_contents(message)
                    caller.msg("Emitted to %s and contents:\n%s" % (objname, message))
                else:
                    caller.msg("Emitted to %s:\n%s" % (objname, message))
            else:
                caller.msg("You are not allowed to emit to %s." % objname)


class CmdNewPassword(MuxCommand):
    """
    change the password of a player

    Usage:
      @userpassword <user obj> = <new password>

    Set a player's password.
    """

    key = "@userpassword"
    locks = "cmd:perm(newpassword) or perm(Wizards)"
    help_category = "Admin"

    def func(self):
        "Implement the function."

        caller = self.caller

        if not self.rhs:
            self.msg("Usage: @userpassword <user obj> = <new password>")
            return

        # the player search also matches 'me' etc.
        player = caller.search_player(self.lhs)
        if not player:
            return
        player.user.set_password(self.rhs)
        player.user.save()
        self.msg("%s - new password set to '%s'." % (player.name, self.rhs))
        if player.character != caller:
            player.msg("%s has changed your password to '%s'." % (caller.name,
                                                                  self.rhs))


class CmdPerm(MuxCommand):
    """
    set the permissions of a player/object

    Usage:
      @perm[/switch] <object> [= <permission>[,<permission>,...]]
      @perm[/switch] *<player> [= <permission>[,<permission>,...]]

    Switches:
      del : delete the given permission from <object> or <player>.
      player : set permission on a player (same as adding * to name)

    This command sets/clears individual permission strings on an object
    or player. If no permission is given, list all permissions on <object>.
    """
    key = "@perm"
    aliases = "@setperm"
    locks = "cmd:perm(perm) or perm(Immortals)"
    help_category = "Admin"

    def func(self):
        "Implement function"

        caller = self.caller
        switches = self.switches
        lhs, rhs = self.lhs, self.rhs

        if not self.args:
            string = "Usage: @perm[/switch] object [ = permission, permission, ...]"
            caller.msg(string)
            return

        playermode = 'player' in self.switches or lhs.startswith('*')
        lhs = lhs.lstrip("*")

        if playermode:
            obj = caller.search_player(lhs)
        else:
            obj = caller.search(lhs, global_search=True)
        if not obj:
            return

        if not rhs:
            if not obj.access(caller, 'examine'):
                caller.msg("You are not allowed to examine this object.")
                return

            string = "Permissions on {w%s{n: " % obj.key
            if not obj.permissions.all():
                string += "<None>"
            else:
                string += ", ".join(obj.permissions.all())
                if (hasattr(obj, 'player') and
                    hasattr(obj.player, 'is_superuser') and
                    obj.player.is_superuser):
                    string += "\n(... but this object is currently controlled by a SUPERUSER! "
                    string += "All access checks are passed automatically.)"
            caller.msg(string)
            return

        # we supplied an argument on the form obj = perm

        if not obj.access(caller, 'control'):
            caller.msg("You are not allowed to edit this object's permissions.")
            return

        cstring = ""
        tstring = ""
        if 'del' in switches:
            # delete the given permission(s) from object.
            for perm in self.rhslist:
                obj.permissions.remove(perm)
                if obj.permissions.get(perm):
                    cstring += "\nPermissions %s could not be removed from %s." % (perm, obj.name)
                else:
                    cstring += "\nPermission %s removed from %s (if they existed)." % (perm, obj.name)
                    tstring += "\n%s revokes the permission(s) %s from you." % (caller.name, perm)
        else:
            # add a new permission
            permissions = obj.permissions.all()

            for perm in self.rhslist:

                # don't allow to set a permission higher in the hierarchy than
                # the one the caller has (to prevent self-escalation)
                if (perm.lower() in PERMISSION_HIERARCHY and not
                        obj.locks.check_lockstring(caller, "dummy:perm(%s)" % perm)):
                    caller.msg("You cannot assign a permission higher than the one you have yourself.")
                    return

                if perm in permissions:
                    cstring += "\nPermission '%s' is already defined on %s." % (rhs, obj.name)
                else:
                    obj.permissions.add(perm)
                    plystring = "the Player" if playermode else "the Object/Character"
                    cstring += "\nPermission '%s' given to %s (%s)." % (rhs, obj.name, plystring)
                    tstring += "\n%s gives you (%s, %s) the permission '%s'." % (caller.name, obj.name, plystring, rhs)
        caller.msg(cstring.strip())
        if tstring:
            obj.msg(tstring.strip())

class CmdWall(MuxCommand):
    """
    make an announcement to all

    Usage:
      @wall <message>

    Announces a message to all connected players.
    """
    key = "@wall"
    locks = "cmd:perm(wall) or perm(Wizards)"
    help_category = "Admin"

    def func(self):
        "Implements command"
        if not self.args:
            self.caller.msg("Usage: @wall <message>")
            return
        message = "%s shouts \"%s\"" % (self.caller.name, self.args)
        self.msg("Announcing to all connected players ...")
        SESSIONS.announce_all(message)

########NEW FILE########
__FILENAME__ = batchprocess
"""
Batch processors

These commands implements the 'batch-command' and 'batch-code'
processors, using the functionality in src.utils.batchprocessors.
They allow for offline world-building.

Batch-command is the simpler system. This reads a file (*.ev)
containing a list of in-game commands and executes them in sequence as
if they had been entered in the game (including permission checks
etc).

Example batch-command file: game/gamesrc/commands/examples/batch_cmds.ev

Batch-code is a full-fledged python code interpreter that reads blocks
of python code (*.py) and executes them in sequence. This allows for
much more power than Batch-command, but requires knowing Python and
the Evennia API.  It is also a severe security risk and should
therefore always be limited to superusers only.

Example batch-code file: game/gamesrc/commands/examples/batch_code.py

"""
from traceback import format_exc
from django.conf import settings
from src.utils.batchprocessors import BATCHCMD, BATCHCODE
from src.commands.cmdset import CmdSet
from src.commands.default.muxcommand import MuxCommand
from src.utils import utils

# limit symbols for API inclusion
__all__ = ("CmdBatchCommands", "CmdBatchCode")

_HEADER_WIDTH = 70
_UTF8_ERROR = \
"""
 {rDecode error in '%s'.{n

 This file contains non-ascii character(s). This is common if you
 wrote some input in a language that has more letters and special
 symbols than English; such as accents or umlauts.  This is usually
 fine and fully supported! But for Evennia to know how to decode such
 characters in a universal way, the batchfile must be saved with the
 international 'UTF-8' encoding. This file is not.

 Please re-save the batchfile with the UTF-8 encoding (refer to the
 documentation of your text editor on how to do this, or switch to a
 better featured one) and try again.

 Error reported was: '%s'
"""

_PROCPOOL_BATCHCMD_SOURCE = """
from src.commands.default.batchprocess import batch_cmd_exec, step_pointer, BatchSafeCmdSet
caller.ndb.batch_stack = commands
caller.ndb.batch_stackptr = 0
caller.ndb.batch_batchmode = "batch_commands"
caller.cmdset.add(BatchSafeCmdSet)
for inum in range(len(commands)):
    print "command:", inum
    caller.cmdset.add(BatchSafeCmdSet)
    if not batch_cmd_exec(caller):
        break
    step_pointer(caller, 1)
print "leaving run ..."
"""
_PROCPOOL_BATCHCODE_SOURCE = """
from src.commands.default.batchprocess import batch_code_exec, step_pointer, BatchSafeCmdSet
caller.ndb.batch_stack = codes
caller.ndb.batch_stackptr = 0
caller.ndb.batch_batchmode = "batch_code"
caller.cmdset.add(BatchSafeCmdSet)
for inum in range(len(codes)):
    print "code:", inum
    caller.cmdset.add(BatchSafeCmdSet)
    if not batch_code_exec(caller):
        break
    step_pointer(caller, 1)
print "leaving run ..."
"""


#------------------------------------------------------------
# Helper functions
#------------------------------------------------------------

def format_header(caller, entry):
    """
    Formats a header
    """
    width = _HEADER_WIDTH - 10
    entry = entry.strip()
    header = utils.crop(entry, width=width)
    ptr = caller.ndb.batch_stackptr + 1
    stacklen = len(caller.ndb.batch_stack)
    header = "{w%02i/%02i{G: %s{n" % (ptr, stacklen, header)
    # add extra space to the side for padding.
    header = "%s%s" % (header, " " * (width - len(header)))
    header = header.replace('\n', '\\n')

    return header


def format_code(entry):
    """
    Formats the viewing of code and errors
    """
    code = ""
    for line in entry.split('\n'):
        code += "\n{G>>>{n %s" % line
    return code.strip()


def batch_cmd_exec(caller):
    """
    Helper function for executing a single batch-command entry
    """
    ptr = caller.ndb.batch_stackptr
    stack = caller.ndb.batch_stack
    command = stack[ptr]
    caller.msg(format_header(caller, command))
    try:
        caller.execute_cmd(command)
    except Exception:
        caller.msg(format_code(format_exc()))
        return False
    return True


def batch_code_exec(caller):
    """
    Helper function for executing a single batch-code entry
    """
    ptr = caller.ndb.batch_stackptr
    stack = caller.ndb.batch_stack
    debug = caller.ndb.batch_debug
    code = stack[ptr]

    caller.msg(format_header(caller, code))
    err = BATCHCODE.code_exec(code,
                              extra_environ={"caller": caller}, debug=debug)
    if err:
        caller.msg(format_code(err))
        return False
    return True


def step_pointer(caller, step=1):
    """
    Step in stack, returning the item located.

    stackptr - current position in stack
    stack - the stack of units
    step - how many steps to move from stackptr
    """
    ptr = caller.ndb.batch_stackptr
    stack = caller.ndb.batch_stack
    nstack = len(stack)
    if ptr + step <= 0:
        caller.msg("{RBeginning of batch file.")
    if ptr + step >= nstack:
        caller.msg("{REnd of batch file.")
    caller.ndb.batch_stackptr = max(0, min(nstack - 1, ptr + step))


def show_curr(caller, showall=False):
    """
    Show the current position in stack
    """
    stackptr = caller.ndb.batch_stackptr
    stack = caller.ndb.batch_stack

    if stackptr >= len(stack):
        caller.ndb.batch_stackptr = len(stack) - 1
        show_curr(caller, showall)
        return

    entry = stack[stackptr]

    string = format_header(caller, entry)
    codeall = entry.strip()
    string += "{G(hh for help)"
    if showall:
        for line in codeall.split('\n'):
            string += "\n{G|{n %s" % line
    caller.msg(string)


def purge_processor(caller):
    """
    This purges all effects running
    on the caller.
    """
    try:
        del caller.ndb.batch_stack
        del caller.ndb.batch_stackptr
        del caller.ndb.batch_pythonpath
        del caller.ndb.batch_batchmode
    except:
        pass
    # clear everything but the default cmdset.
    caller.cmdset.delete(BatchSafeCmdSet)
    caller.cmdset.clear()
    caller.scripts.validate()  # this will purge interactive mode

#------------------------------------------------------------
# main access commands
#------------------------------------------------------------


class CmdBatchCommands(MuxCommand):
    """
    build from batch-command file

    Usage:
     @batchcommands[/interactive] <python.path.to.file>

    Switch:
       interactive - this mode will offer more control when
                     executing the batch file, like stepping,
                     skipping, reloading etc.

    Runs batches of commands from a batch-cmd text file (*.ev).

    """
    key = "@batchcommands"
    aliases = ["@batchcommand", "@batchcmd"]
    locks = "cmd:perm(batchcommands) or superuser()"
    help_category = "Building"

    def func(self):
        "Starts the processor."

        caller = self.caller

        args = self.args
        if not args:
            caller.msg("Usage: @batchcommands[/interactive] <path.to.file>")
            return
        python_path = self.args

        #parse indata file

        try:
            commands = BATCHCMD.parse_file(python_path)
        except UnicodeDecodeError, err:
            caller.msg(_UTF8_ERROR % (python_path, err))
            return
        except IOError:
            string = "'%s' not found.\nYou have to supply the python path "
            string += "of the file relative to \none of your batch-file directories (%s)."
            caller.msg(string % (python_path, ", ".join(settings.BASE_BATCHPROCESS_PATHS)))
            return
        if not commands:
            caller.msg("File %s seems empty of valid commands." % python_path)
            return

        switches = self.switches

        # Store work data in cache
        caller.ndb.batch_stack = commands
        caller.ndb.batch_stackptr = 0
        caller.ndb.batch_pythonpath = python_path
        caller.ndb.batch_batchmode = "batch_commands"
        caller.cmdset.add(BatchSafeCmdSet)

        if 'inter' in switches or 'interactive' in switches:
            # Allow more control over how batch file is executed

            # Set interactive state directly
            caller.cmdset.add(BatchInteractiveCmdSet)

            caller.msg("\nBatch-command processor - Interactive mode for %s ..." % python_path)
            show_curr(caller)
        else:
            caller.msg("Running Batch-command processor - Automatic mode for %s (this might take some time) ..." % python_path)

            procpool = False
            if "PythonProcPool" in utils.server_services():
                if utils.uses_database("sqlite3"):
                    caller.msg("Batchprocessor disabled ProcPool under SQLite3.")
                else:
                    procpool = True

            if procpool:
                # run in parallel process
                def callback(r):
                    caller.msg("  {GBatchfile '%s' applied." % python_path)
                    purge_processor(caller)

                def errback(e):
                    caller.msg("  {RError from processor: '%s'" % e)
                    purge_processor(caller)

                utils.run_async(_PROCPOOL_BATCHCMD_SOURCE,
                                commands=commands,
                                caller=caller,
                                at_return=callback,
                                at_err=errback)
            else:
                # run in-process (might block)
                for inum in range(len(commands)):
                    # loop through the batch file
                    if not batch_cmd_exec(caller):
                        return
                    step_pointer(caller, 1)
                # clean out the safety cmdset and clean out all other
                # temporary attrs.
                string = "  Batchfile '%s' applied." % python_path
                caller.msg("{G%s" % string)
                purge_processor(caller)


class CmdBatchCode(MuxCommand):
    """
    build from batch-code file

    Usage:
     @batchcode[/interactive] <python path to file>

    Switch:
       interactive - this mode will offer more control when
                     executing the batch file, like stepping,
                     skipping, reloading etc.
       debug - auto-delete all objects that has been marked as
               deletable in the script file (see example files for
               syntax). This is useful so as to to not leave multiple
               object copies behind when testing out the script.

    Runs batches of commands from a batch-code text file (*.py).

    """
    key = "@batchcode"
    aliases = ["@batchcodes"]
    locks = "cmd:superuser()"
    help_category = "Building"

    def func(self):
        "Starts the processor."

        caller = self.caller

        args = self.args
        if not args:
            caller.msg("Usage: @batchcode[/interactive/debug] <path.to.file>")
            return
        python_path = self.args
        debug = 'debug' in self.switches

        #parse indata file
        try:
            codes = BATCHCODE.parse_file(python_path, debug=debug)
        except UnicodeDecodeError, err:
            caller.msg(_UTF8_ERROR % (python_path, err))
            return
        except IOError:
            string = "'%s' not found.\nYou have to supply the python path "
            string += "of the file relative to \nyour batch-file directories (%s)."
            caller.msg(string % (python_path, ", ".join(settings.BASE_BATCHPROCESS_PATHS)))
            return
        if not codes:
            caller.msg("File %s seems empty of functional code." % python_path)
            return

        switches = self.switches

        # Store work data in cache
        caller.ndb.batch_stack = codes
        caller.ndb.batch_stackptr = 0
        caller.ndb.batch_pythonpath = python_path
        caller.ndb.batch_batchmode = "batch_code"
        caller.ndb.batch_debug = debug
        caller.cmdset.add(BatchSafeCmdSet)

        if 'inter' in switches or 'interactive'in switches:
            # Allow more control over how batch file is executed

            # Set interactive state directly
            caller.cmdset.add(BatchInteractiveCmdSet)

            caller.msg("\nBatch-code processor - Interactive mode for %s ..." % python_path)
            show_curr(caller)
        else:
            caller.msg("Running Batch-code processor - Automatic mode for %s ..." % python_path)

            procpool = False
            if "PythonProcPool" in utils.server_services():
                if utils.uses_database("sqlite3"):
                    caller.msg("Batchprocessor disabled ProcPool under SQLite3.")
                else:
                    procpool = True
            if procpool:
                # run in parallel process
                def callback(r):
                    caller.msg("  {GBatchfile '%s' applied." % python_path)
                    purge_processor(caller)

                def errback(e):
                    caller.msg("  {RError from processor: '%s'" % e)
                    purge_processor(caller)
                utils.run_async(_PROCPOOL_BATCHCODE_SOURCE,
                                codes=codes,
                                caller=caller,
                                at_return=callback,
                                at_err=errback)
            else:
                # un in-process (will block)
                for inum in range(len(codes)):
                    # loop through the batch file
                    if not batch_code_exec(caller):
                        return
                    step_pointer(caller, 1)
                # clean out the safety cmdset and clean out all other
                # temporary attrs.
                string = "  Batchfile '%s' applied." % python_path
                caller.msg("{G%s" % string)
                purge_processor(caller)


#------------------------------------------------------------
# State-commands for the interactive batch processor modes
# (these are the same for both processors)
#------------------------------------------------------------

class CmdStateAbort(MuxCommand):
    """
    @abort

    This is a safety feature. It force-ejects us out of the processor and to
    the default cmdset, regardless of what current cmdset the processor might
    have put us in (e.g. when testing buggy scripts etc).
    """
    key = "@abort"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        "Exit back to default."
        purge_processor(self.caller)
        self.caller.msg("Exited processor and reset out active cmdset back to the default one.")


class CmdStateLL(MuxCommand):
    """
    ll

    Look at the full source for the current
    command definition.
    """
    key = "ll"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        show_curr(self.caller, showall=True)

class CmdStatePP(MuxCommand):
    """
    pp

    Process the currently shown command definition.
    """
    key = "pp"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        """
        This checks which type of processor we are running.
        """
        caller = self.caller
        if caller.ndb.batch_batchmode == "batch_code":
            batch_code_exec(caller)
        else:
            batch_cmd_exec(caller)


class CmdStateRR(MuxCommand):
    """
    rr

    Reload the batch file, keeping the current
    position in it.
    """
    key = "rr"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        if caller.ndb.batch_batchmode == "batch_code":
            new_data = BATCHCODE.parse_file(caller.ndb.batch_pythonpath)
        else:
            new_data = BATCHCMD.parse_file(caller.ndb.batch_pythonpath)
        caller.ndb.batch_stack = new_data
        caller.msg(format_code("File reloaded. Staying on same command."))
        show_curr(caller)


class CmdStateRRR(MuxCommand):
    """
    rrr

    Reload the batch file, starting over
    from the beginning.
    """
    key = "rrr"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        if caller.ndb.batch_batchmode == "batch_code":
            BATCHCODE.parse_file(caller.ndb.batch_pythonpath)
        else:
            BATCHCMD.parse_file(caller.ndb.batch_pythonpath)
        caller.ndb.batch_stackptr = 0
        caller.msg(format_code("File reloaded. Restarting from top."))
        show_curr(caller)


class CmdStateNN(MuxCommand):
    """
    nn

    Go to next command. No commands are executed.
    """
    key = "nn"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            step = int(self.args)
        else:
            step = 1
        step_pointer(caller, step)
        show_curr(caller)


class CmdStateNL(MuxCommand):
    """
    nl

    Go to next command, viewing its full source.
    No commands are executed.
    """
    key = "nl"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            step = int(self.args)
        else:
            step = 1
        step_pointer(caller, step)
        show_curr(caller, showall=True)


class CmdStateBB(MuxCommand):
    """
    bb

    Backwards to previous command. No commands
    are executed.
    """
    key = "bb"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            step = -int(self.args)
        else:
            step = -1
        step_pointer(caller, step)
        show_curr(caller)


class CmdStateBL(MuxCommand):
    """
    bl

    Backwards to previous command, viewing its full
    source. No commands are executed.
    """
    key = "bl"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            step = -int(self.args)
        else:
            step = -1
        step_pointer(caller, step)
        show_curr(caller, showall=True)


class CmdStateSS(MuxCommand):
    """
    ss [steps]

    Process current command, then step to the next
    one. If steps is given,
    process this many commands.
    """
    key = "ss"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            step = int(self.args)
        else:
            step = 1

        for istep in range(step):
            if caller.ndb.batch_batchmode == "batch_code":
                batch_code_exec(caller)
            else:
                batch_cmd_exec(caller)
            step_pointer(caller, 1)
            show_curr(caller)


class CmdStateSL(MuxCommand):
    """
    sl [steps]

    Process current command, then step to the next
    one, viewing its full source. If steps is given,
    process this many commands.
    """
    key = "sl"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            step = int(self.args)
        else:
            step = 1

        for istep in range(step):
            if caller.ndb.batch_batchmode == "batch_code":
                batch_code_exec(caller)
            else:
                batch_cmd_exec(caller)
            step_pointer(caller, 1)
            show_curr(caller)


class CmdStateCC(MuxCommand):
    """
    cc

    Continue to process all remaining
    commands.
    """
    key = "cc"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        nstack = len(caller.ndb.batch_stack)
        ptr = caller.ndb.batch_stackptr
        step = nstack - ptr

        for istep in range(step):
            if caller.ndb.batch_batchmode == "batch_code":
                batch_code_exec(caller)
            else:
                batch_cmd_exec(caller)
            step_pointer(caller, 1)
            show_curr(caller)

        del caller.ndb.batch_stack
        del caller.ndb.batch_stackptr
        del caller.ndb.batch_pythonpath
        del caller.ndb.batch_batchmode
        caller.msg(format_code("Finished processing batch file."))


class CmdStateJJ(MuxCommand):
    """
    j <command number>

    Jump to specific command number
    """
    key = "j"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            number = int(self.args) - 1
        else:
            caller.msg(format_code("You must give a number index."))
            return
        ptr = caller.ndb.batch_stackptr
        step = number - ptr
        step_pointer(caller, step)
        show_curr(caller)


class CmdStateJL(MuxCommand):
    """
    jl <command number>

    Jump to specific command number and view its full source.
    """
    key = "jl"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        caller = self.caller
        arg = self.args
        if arg and arg.isdigit():
            number = int(self.args) - 1
        else:
            caller.msg(format_code("You must give a number index."))
            return
        ptr = caller.ndb.batch_stackptr
        step = number - ptr
        step_pointer(caller, step)
        show_curr(caller, showall=True)


class CmdStateQQ(MuxCommand):
    """
    qq

    Quit the batchprocessor.
    """
    key = "qq"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        purge_processor(self.caller)
        self.caller.msg("Aborted interactive batch mode.")


class CmdStateHH(MuxCommand):
    "Help command"

    key = "hh"
    help_category = "BatchProcess"
    locks = "cmd:perm(batchcommands)"

    def func(self):
        string = """
    Interactive batch processing commands:

     nn [steps] - next command (no processing)
     nl [steps] - next & look
     bb [steps] - back to previous command (no processing)
     bl [steps] - back & look
     jj   <N>   - jump to command nr N (no processing)
     jl   <N>   - jump & look
     pp         - process currently shown command (no step)
     ss [steps] - process & step
     sl [steps] - process & step & look
     ll         - look at full definition of current command
     rr         - reload batch file (stay on current)
     rrr        - reload batch file (start from first)
     hh         - this help list

     cc         - continue processing to end, then quit.
     qq         - quit (abort all remaining commands)

     @abort - this is a safety command that always is available
              regardless of what cmdsets gets added to us during
              batch-command processing. It immediately shuts down
              the processor and returns us to the default cmdset.
    """
        self.caller.msg(string)


#------------------------------------------------------------
#
# Defining the cmdsets for the interactive batchprocessor
# mode (same for both processors)
#
#------------------------------------------------------------

class BatchSafeCmdSet(CmdSet):
    """
    The base cmdset for the batch processor.
    This sets a 'safe' @abort command that will
    always be available to get out of everything.
    """
    key = "Batch_default"
    priority = 150  # override other cmdsets.

    def at_cmdset_creation(self):
        "Init the cmdset"
        self.add(CmdStateAbort())


class BatchInteractiveCmdSet(CmdSet):
    """
    The cmdset for the interactive batch processor mode.
    """
    key = "Batch_interactive"
    priority = 104

    def at_cmdset_creation(self):
        "init the cmdset"
        self.add(CmdStateAbort())
        self.add(CmdStateLL())
        self.add(CmdStatePP())
        self.add(CmdStateRR())
        self.add(CmdStateRRR())
        self.add(CmdStateNN())
        self.add(CmdStateNL())
        self.add(CmdStateBB())
        self.add(CmdStateBL())
        self.add(CmdStateSS())
        self.add(CmdStateSL())
        self.add(CmdStateCC())
        self.add(CmdStateJJ())
        self.add(CmdStateJL())
        self.add(CmdStateQQ())
        self.add(CmdStateHH())

########NEW FILE########
__FILENAME__ = building
"""
import sys

Building and world design commands

"""
from django.conf import settings
from src.objects.models import ObjectDB
from src.utils import create, utils, search
from src.utils.ansi import raw
from src.locks.lockhandler import LockException
from src.commands.default.muxcommand import MuxCommand
from src.commands.cmdhandler import get_and_merge_cmdsets

# limit symbol import for API
__all__ = ("ObjManipCommand", "CmdSetObjAlias", "CmdCopy",
           "CmdCpAttr", "CmdMvAttr", "CmdCreate",
           "CmdDesc", "CmdDestroy", "CmdDig", "CmdTunnel", "CmdLink",
           "CmdUnLink", "CmdSetHome", "CmdListCmdSets", "CmdName",
           "CmdOpen", "CmdSetAttribute", "CmdTypeclass", "CmdWipe",
           "CmdLock", "CmdExamine", "CmdFind", "CmdTeleport",
           "CmdScript", "CmdTag")

try:
    # used by @set
    from ast import literal_eval as _LITERAL_EVAL
except ImportError:
    # literal_eval is not available before Python 2.6
    _LITERAL_EVAL = None

# used by @find
CHAR_TYPECLASS = settings.BASE_CHARACTER_TYPECLASS


class ObjManipCommand(MuxCommand):
    """
    This is a parent class for some of the defining objmanip commands
    since they tend to have some more variables to define new objects.

    Each object definition can have several components. First is
    always a name, followed by an optional alias list and finally an
    some optional data, such as a typeclass or a location. A comma ','
    separates different objects. Like this:

        name1;alias;alias;alias:option, name2;alias;alias ...

    Spaces between all components are stripped.

    A second situation is attribute manipulation. Such commands
    are simpler and offer combinations

        objname/attr/attr/attr, objname/attr, ...

    """
    # OBS - this is just a parent - it's not intended to actually be
    # included in a commandset on its own!

    def parse(self):
        """
        We need to expand the default parsing to get all
        the cases, see the module doc.
        """
        # get all the normal parsing done (switches etc)
        super(ObjManipCommand, self).parse()

        obj_defs = ([], [])    # stores left- and right-hand side of '='
        obj_attrs = ([], [])  #                   "

        for iside, arglist in enumerate((self.lhslist, self.rhslist)):
            # lhslist/rhslist is already split by ',' at this point
            for objdef in arglist:
                aliases, option, attrs = [], None, []
                if ':' in objdef:
                    objdef, option = [part.strip() for part in objdef.rsplit(':', 1)]
                if ';' in objdef:
                    objdef, aliases = [part.strip() for part in objdef.split(';', 1)]
                    aliases = [alias.strip() for alias in aliases.split(';') if alias.strip()]
                if '/' in objdef:
                    objdef, attrs = [part.strip() for part in objdef.split('/', 1)]
                    attrs = [part.strip().lower() for part in attrs.split('/') if part.strip()]
                # store data
                obj_defs[iside].append({"name":objdef, 'option':option, 'aliases':aliases})
                obj_attrs[iside].append({"name":objdef, 'attrs':attrs})

        # store for future access
        self.lhs_objs = obj_defs[0]
        self.rhs_objs = obj_defs[1]
        self.lhs_objattr = obj_attrs[0]
        self.rhs_objattr = obj_attrs[1]


class CmdSetObjAlias(MuxCommand):
    """
    adding permanent aliases for object

    Usage:
      @alias <obj> [= [alias[,alias,alias,...]]]
      @alias <obj> =

    Assigns aliases to an object so it can be referenced by more
    than one name. Assign empty to remove all aliases from object.

    Observe that this is not the same thing as personal aliases
    created with the 'nick' command! Aliases set with @alias are
    changing the object in question, making those aliases usable
    by everyone.
    """

    key = "@alias"
    aliases = "@setobjalias"
    locks = "cmd:perm(setobjalias) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Set the aliases."

        caller = self.caller

        if not self.lhs:
            string = "Usage: @alias <obj> [= [alias[,alias ...]]]"
            self.caller.msg(string)
            return
        objname = self.lhs

        # Find the object to receive aliases
        obj = caller.search(objname)
        if not obj:
            return
        if self.rhs is None:
            # no =, so we just list aliases on object.
            aliases = obj.aliases.all()
            if aliases:
                caller.msg("Aliases for '%s': %s" % (obj.key, ", ".join(aliases)))
            else:
                caller.msg("No aliases exist for '%s'." % obj.key)
            return

        if not obj.access(caller, 'edit'):
            caller.msg("You don't have permission to do that.")
            return

        if not self.rhs:
            # we have given an empty =, so delete aliases
            old_aliases = obj.aliases.all()
            if old_aliases:
                caller.msg("Cleared aliases from %s: %s" % (obj.key, ", ".join(old_aliases)))
                obj.dbobj.aliases.clear()
            else:
                caller.msg("No aliases to clear.")
            return

        # merge the old and new aliases (if any)
        old_aliases = obj.aliases.all()
        new_aliases = [alias.strip().lower() for alias in self.rhs.split(',')
                       if alias.strip()]
        # make the aliases only appear once
        old_aliases.extend(new_aliases)
        aliases = list(set(old_aliases))
        # save back to object.
        obj.aliases.add(aliases)
        # we treat this as a re-caching (relevant for exits to re-build their
        # exit commands with the correct aliases)
        caller.msg("Alias(es) for '%s' set to %s." % (obj.key, str(obj.aliases)))


class CmdCopy(ObjManipCommand):
    """
    copy an object and its properties

    Usage:
      @copy[/reset] <original obj> [= new_name][;alias;alias..][:new_location] [,new_name2 ...]

    switch:
      reset - make a 'clean' copy off the object, thus
              removing any changes that might have been made to the original
              since it was first created.

    Create one or more copies of an object. If you don't supply any targets,
    one exact copt of the original object will be created with the name *_copy.
    """

    key = "@copy"
    locks = "cmd:perm(copy) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Uses ObjManipCommand.parse()"

        caller = self.caller
        args = self.args
        if not args:
            caller.msg("Usage: @copy <obj> [=new_name[;alias;alias..]][:new_location] [, new_name2...]")
            return

        if not self.rhs:
            # this has no target =, so an identical new object is created.
            from_obj_name = self.args
            from_obj = caller.search(from_obj_name)
            if not from_obj:
                return
            to_obj_name = "%s_copy" % from_obj_name
            to_obj_aliases = ["%s_copy" % alias for alias in from_obj.aliases.all()]
            copiedobj = ObjectDB.objects.copy_object(from_obj, new_key=to_obj_name,
                                                     new_aliases=to_obj_aliases)
            if copiedobj:
                string = "Identical copy of %s, named '%s' was created." % (from_obj_name, to_obj_name)
            else:
                string = "There was an error copying %s."
        else:
            # we have specified =. This might mean many object targets
            from_obj_name = self.lhs_objs[0]['name']
            from_obj = caller.search(from_obj_name)
            if not from_obj:
                return
            for objdef in self.rhs_objs:
                # loop through all possible copy-to targets
                to_obj_name = objdef['name']
                to_obj_aliases = objdef['aliases']
                to_obj_location = objdef['option']
                if to_obj_location:
                    to_obj_location = caller.search(to_obj_location,
                                                    global_search=True)
                    if not to_obj_location:
                        return

                copiedobj = ObjectDB.objects.copy_object(from_obj,
                                                        new_key=to_obj_name,
                                                        new_location=to_obj_location,
                                                        new_aliases=to_obj_aliases)
                if copiedobj:
                    string = "Copied %s to '%s' (aliases: %s)." % (from_obj_name, to_obj_name,
                                                                   to_obj_aliases)
                else:
                    string = "There was an error copying %s to '%s'." % (from_obj_name,
                                                                         to_obj_name)
        # we are done, echo to user
        caller.msg(string)


class CmdCpAttr(ObjManipCommand):
    """
    copy attributes between objects

    Usage:
      @cpattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
      @cpattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
      @cpattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
      @cpattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...]

    Switches:
      move - delete the attribute from the source object after copying.

    Example:
      @cpattr coolness = Anna/chillout, Anna/nicety, Tom/nicety
      ->
      copies the coolness attribute (defined on yourself), to attributes
      on Anna and Tom.

    Copy the attribute one object to one or more attributes on another object.
    If you don't supply a source object, yourself is used.
    """
    key = "@cpattr"
    locks = "cmd:perm(cpattr) or perm(Builders)"
    help_category = "Building"

    def func(self):
        """
        Do the copying.
        """
        caller = self.caller

        if not self.rhs:
            string = """Usage:
            @cpattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
            @cpattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
            @cpattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
            @cpattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...]"""
            caller.msg(string)
            return

        lhs_objattr = self.lhs_objattr
        to_objs = self.rhs_objattr
        from_obj_name = lhs_objattr[0]['name']
        from_obj_attrs = lhs_objattr[0]['attrs']

        if not from_obj_attrs:
            # this means the from_obj_name is actually an attribute
            # name on self.
            from_obj_attrs = [from_obj_name]
            from_obj = self.caller
            from_obj_name = self.caller.name
        else:
            from_obj = caller.search(from_obj_name)
        if not from_obj or not to_objs:
            caller.msg("You have to supply both source object and target(s).")
            return
        if not from_obj.attributes.has(from_obj_attrs[0]):
            caller.msg("%s doesn't have an attribute %s." % (from_obj_name,
                                                             from_obj_attrs[0]))
            return
        srcvalue = from_obj.attributes.get(from_obj_attrs[0])

        #copy to all to_obj:ects
        if "move" in self.switches:
            string = "Moving "
        else:
            string = "Copying "
        string += "%s/%s (with value %s) ..." % (from_obj_name,
                                                 from_obj_attrs[0], srcvalue)

        for to_obj in to_objs:
            to_obj_name = to_obj['name']
            to_obj_attrs = to_obj['attrs']
            to_obj = caller.search(to_obj_name)
            if not to_obj:
                string += "\nCould not find object '%s'" % to_obj_name
                continue
            for inum, from_attr in enumerate(from_obj_attrs):
                try:
                    to_attr = to_obj_attrs[inum]
                except IndexError:
                    # if there are too few attributes given
                    # on the to_obj, we copy the original name instead.
                    to_attr = from_attr
                to_obj.attributes.add(to_attr, srcvalue)
                if ("move" in self.switches and not (from_obj == to_obj and
                                                     from_attr == to_attr)):
                    from_obj.del_attribute(from_attr)
                    string += "\nMoved %s.%s -> %s.%s." % (from_obj.name,
                                                           from_attr,
                                                           to_obj_name, to_attr)
                else:
                    string += "\nCopied %s.%s -> %s.%s." % (from_obj.name,
                                                            from_attr,
                                                            to_obj_name,
                                                            to_attr)
        caller.msg(string)


class CmdMvAttr(ObjManipCommand):
    """
    move attributes between objects

    Usage:
      @mvattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
      @mvattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
      @mvattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
      @mvattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...]

    Switches:
      copy - Don't delete the original after moving.

    Move an attribute from one object to one or more attributes on another
    object. If you don't supply a source object, yourself is used.
    """
    key = "@mvattr"
    locks = "cmd:perm(mvattr) or perm(Builders)"
    help_category = "Building"

    def func(self):
        """
        Do the moving
        """
        if not self.rhs:
            string = """Usage:
      @mvattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
      @mvattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
      @mvattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
      @mvattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...]"""
            self.caller.msg(string)
            return

        # simply use @cpattr for all the functionality
        if "copy" in self.switches:
            self.caller.execute_cmd("@cpattr %s" % self.args)
        else:
            self.caller.execute_cmd("@cpattr/move %s" % self.args)


class CmdCreate(ObjManipCommand):
    """
    create new objects

    Usage:
      @create[/drop] objname[;alias;alias...][:typeclass], objname...

    switch:
       drop - automatically drop the new object into your current
              location (this is not echoed). This also sets the new
              object's home to the current location rather than to you.

    Creates one or more new objects. If typeclass is given, the object
    is created as a child of this typeclass. The typeclass script is
    assumed to be located under game/gamesrc/types and any further
    directory structure is given in Python notation. So if you have a
    correct typeclass object defined in
    game/gamesrc/types/examples/red_button.py, you could create a new
    object of this type like this:

       @create button;red : examples.red_button.RedButton

    """

    key = "@create"
    locks = "cmd:perm(create) or perm(Builders)"
    help_category = "Building"

    def func(self):
        """
        Creates the object.
        """

        caller = self.caller

        if not self.args:
            string = "Usage: @create[/drop] <newname>[;alias;alias...] [:typeclass_path]"
            caller.msg(string)
            return

        # create the objects
        for objdef in self.lhs_objs:
            string = ""
            name = objdef['name']
            aliases = objdef['aliases']
            typeclass = objdef['option']

            # create object (if not a valid typeclass, the default
            # object typeclass will automatically be used)
            lockstring = "control:id(%s);examine:perm(Builders);delete:id(%s) or perm(Wizards)" % (caller.id, caller.id)
            obj = create.create_object(typeclass, name, caller,
                                       home=caller, aliases=aliases,
                                       locks=lockstring, report_to=caller)
            if not obj:
                continue
            if aliases:
                string = "You create a new %s: %s (aliases: %s)."
                string = string % (obj.typeclass.typename, obj.name, ", ".join(aliases))
            else:
                string = "You create a new %s: %s."
                string = string % (obj.typeclass.typename, obj.name)
            # set a default desc
            if not obj.db.desc:
                obj.db.desc = "You see nothing special."
            if 'drop' in self.switches:
                if caller.location:
                    obj.home = caller.location
                    obj.move_to(caller.location, quiet=True)
        if string:
            caller.msg(string)


class CmdDesc(MuxCommand):
    """
    describe an object

    Usage:
      @desc [<obj> =] >description>

    Setts the "desc" attribute on an
    object. If an object is not given,
    describe the current room.
    """
    key = "@desc"
    aliases = "@describe"
    locks = "cmd:perm(desc) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Define command"

        caller = self.caller
        if not self.args:
            caller.msg("Usage: @desc [<obj> =] >description>")
            return

        if self.rhs:
            # We have an =
            obj = caller.search(self.lhs)
            if not obj:
                return
            desc = self.rhs
        else:
            obj = caller.location
            desc = self.args
        # storing the description
        obj.db.desc = desc
        caller.msg("The description was set on %s." % obj.key)


class CmdDestroy(MuxCommand):
    """
    permanently delete objects

    Usage:
       @destroy[/switches] [obj, obj2, obj3, [dbref-dbref], ...]

    switches:
       override - The @destroy command will usually avoid accidentally
                  destroying player objects. This switch overrides this safety.
    examples:
       @destroy house, roof, door, 44-78
       @destroy 5-10, flower, 45

    Destroys one or many objects. If dbrefs are used, a range to delete can be
    given, e.g. 4-10. Also the end points will be deleted.
    """

    key = "@destroy"
    aliases = ["@delete", "@del"]
    locks = "cmd:perm(destroy) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Implements the command."

        caller = self.caller

        if not self.args or not self.lhslist:
            caller.msg("Usage: @destroy[/switches] [obj, obj2, obj3, [dbref-dbref],...]")
            return ""

        def delobj(objname, byref=False):
            # helper function for deleting a single object
            string = ""
            obj = caller.search(objname)
            if not obj:
                self.caller.msg(" (Objects to destroy must either be local or specified with a unique #dbref.)")
                return ""
            objname = obj.name
            if not obj.access(caller, 'delete'):
                return "\nYou don't have permission to delete %s." % objname
            if obj.player and not 'override' in self.switches:
                return "\nObject %s is controlled by an active player. Use /override to delete anyway." % objname
            if obj.dbid == int(settings.DEFAULT_HOME.lstrip("#")):
                return "\nYou are trying to delete {c%s{n, which is set as DEFAULT_HOME. " \
                        "Re-point settings.DEFAULT_HOME to another " \
                        "object before continuing." % objname

            had_exits = hasattr(obj, "exits") and obj.exits
            had_objs = hasattr(obj, "contents") and any(obj for obj in obj.contents
                                                        if not (hasattr(obj, "exits") and obj not in obj.exits))
            # do the deletion
            okay = obj.delete()
            if not okay:
                string += "\nERROR: %s not deleted, probably because at_obj_delete() returned False." % objname
            else:
                string += "\n%s was destroyed." % objname
                if had_exits:
                    string += " Exits to and from %s were destroyed as well." % objname
                if had_objs:
                    string += " Objects inside %s were moved to their homes." % objname
            return string

        string = ""
        for objname in self.lhslist:
            if '-' in objname:
                # might be a range of dbrefs
                dmin, dmax = [utils.dbref(part, reqhash=False)
                              for part in objname.split('-', 1)]
                if dmin and dmax:
                    for dbref in range(int(dmin), int(dmax + 1)):
                        string += delobj("#" + str(dbref), True)
                else:
                    string += delobj(objname)
            else:
                string += delobj(objname, True)
        if string:
            caller.msg(string.strip())


class CmdDig(ObjManipCommand):
    """
    build new rooms and connect them to the current location

    Usage:
      @dig[/switches] roomname[;alias;alias...][:typeclass]
            [= exit_to_there[;alias][:typeclass]]
               [, exit_to_here[;alias][:typeclass]]

    Switches:
       tel or teleport - move yourself to the new room

    Examples:
       @dig kitchen = north;n, south;s
       @dig house:myrooms.MyHouseTypeclass
       @dig sheer cliff;cliff;sheer = climb up, climb down

    This command is a convenient way to build rooms quickly; it creates the
    new room and you can optionally set up exits back and forth between your
    current room and the new one. You can add as many aliases as you
    like to the name of the room and the exits in question; an example
    would be 'north;no;n'.
    """
    key = "@dig"
    locks = "cmd:perm(dig) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Do the digging. Inherits variables from ObjManipCommand.parse()"

        caller = self.caller

        if not self.lhs:
            string = "Usage: @dig[/teleport] roomname[;alias;alias...][:parent] [= exit_there"
            string += "[;alias;alias..][:parent]] "
            string += "[, exit_back_here[;alias;alias..][:parent]]"
            caller.msg(string)
            return

        room = self.lhs_objs[0]

        if not room["name"]:
            caller.msg("You must supply a new room name.")
            return
        location = caller.location

        # Create the new room
        typeclass = room['option']
        if not typeclass:
            typeclass = settings.BASE_ROOM_TYPECLASS

        # create room
        lockstring = "control:id(%s) or perm(Immortals); delete:id(%s) or perm(Wizards); edit:id(%s) or perm(Wizards)"
        lockstring = lockstring % (caller.dbref, caller.dbref, caller.dbref)

        new_room = create.create_object(typeclass, room["name"],
                                        aliases=room["aliases"],
                                        report_to=caller)
        new_room.locks.add(lockstring)
        alias_string = ""
        if new_room.aliases.all():
            alias_string = " (%s)" % ", ".join(new_room.aliases.all())
        room_string = "Created room %s(%s)%s of type %s." % (new_room,
                                        new_room.dbref, alias_string, typeclass)

        # create exit to room

        exit_to_string = ""
        exit_back_string = ""

        if self.rhs_objs:
            to_exit = self.rhs_objs[0]
            if not to_exit["name"]:
                exit_to_string = \
                    "\nNo exit created to new room."
            elif not location:
                exit_to_string = \
                  "\nYou cannot create an exit from a None-location."
            else:
                # Build the exit to the new room from the current one
                typeclass = to_exit["option"]
                if not typeclass:
                    typeclass = settings.BASE_EXIT_TYPECLASS

                new_to_exit = create.create_object(typeclass, to_exit["name"],
                                                   location,
                                                   aliases=to_exit["aliases"],
                                                   locks=lockstring,
                                                   destination=new_room,
                                                   report_to=caller)
                alias_string = ""
                if new_to_exit.aliases.all():
                    alias_string = " (%s)" % ", ".join(new_to_exit.aliases.all())
                exit_to_string = "\nCreated Exit from %s to %s: %s(%s)%s."
                exit_to_string = exit_to_string % (location.name,
                                                   new_room.name,
                                                   new_to_exit,
                                                   new_to_exit.dbref,
                                                   alias_string)

        # Create exit back from new room

        if len(self.rhs_objs) > 1:
            # Building the exit back to the current room
            back_exit = self.rhs_objs[1]
            if not back_exit["name"]:
                exit_back_string = \
                    "\nNo back exit created."
            elif not location:
                exit_back_string = \
                   "\nYou cannot create an exit back to a None-location."
            else:
                typeclass = back_exit["option"]
                if not typeclass:
                    typeclass = settings.BASE_EXIT_TYPECLASS
                new_back_exit = create.create_object(typeclass,
                                                   back_exit["name"],
                                                   new_room,
                                                   aliases=back_exit["aliases"],
                                                   locks=lockstring,
                                                   destination=location,
                                                   report_to=caller)
                alias_string = ""
                if new_back_exit.aliases.all():
                    alias_string = " (%s)" % ", ".join(new_back_exit.aliases.all())
                exit_back_string = "\nCreated Exit back from %s to %s: %s(%s)%s."
                exit_back_string = exit_back_string % (new_room.name,
                                                       location.name,
                                                       new_back_exit,
                                                       new_back_exit.dbref,
                                                       alias_string)
        caller.msg("%s%s%s" % (room_string, exit_to_string, exit_back_string))
        if new_room and ('teleport' in self.switches or "tel" in self.switches):
            caller.move_to(new_room)

class CmdTunnel(MuxCommand):
    """
    create new rooms in cardinal directions only

    Usage:
      @tunnel[/switch] <direction> [= roomname[;alias;alias;...][:typeclass]]

    Switches:
      oneway - do not create an exit back to the current location
      tel - teleport to the newly created room

    Example:
      @tunnel n
      @tunnel n = house;mike's place;green building

    This is a simple way to build using pre-defined directions:
     {wn,ne,e,se,s,sw,w,nw{n (north, northeast etc)
     {wu,d{n (up and down)
     {wi,o{n (in and out)
    The full names (north, in, southwest, etc) will always be put as
    main name for the exit, using the abbreviation as an alias (so an
    exit will always be able to be used with both "north" as well as
    "n" for example). Opposite directions will automatically be
    created back from the new room unless the /oneway switch is given.
    For more flexibility and power in creating rooms, use @dig.
    """

    key = "@tunnel"
    aliases = ["@tun"]
    locks = "cmd: perm(tunnel) or perm(Builders)"
    help_category = "Building"

    # store the direction, full name and its opposite
    directions = {"n": ("north", "s"),
                  "ne": ("northeast", "sw"),
                  "e": ("east", "w"),
                  "se": ("southeast", "nw"),
                  "s": ("south", "n"),
                  "sw": ("southwest", "ne"),
                  "w": ("west", "e"),
                  "nw": ("northwest", "se"),
                  "u": ("up", "d"),
                  "d": ("down", "u"),
                  "i": ("in", "o"),
                  "o": ("out", "i")}

    def func(self):
        "Implements the tunnel command"

        if not self.args or not self.lhs:
            string = "Usage: @tunnel[/switch] <direction> [= roomname[;alias;alias;...][:typeclass]]"
            self.caller.msg(string)
            return
        if self.lhs not in self.directions:
            string = "@tunnel can only understand the following directions: %s." % ",".join(sorted(self.directions.keys()))
            string += "\n(use @dig for more freedom)"
            self.caller.msg(string)
            return
        # retrieve all input and parse it
        exitshort = self.lhs
        exitname, backshort = self.directions[exitshort]
        backname = self.directions[backshort][0]

        roomname = "Some place"
        if self.rhs:
            roomname = self.rhs  # this may include aliases; that's fine.

        telswitch = ""
        if "tel" in self.switches:
            telswitch = "/teleport"
        backstring = ""
        if not "oneway" in self.switches:
            backstring = ", %s;%s" % (backname, backshort)

        # build the string we will use to call @dig
        digstring = "@dig%s %s = %s;%s%s" % (telswitch, roomname,
                                             exitname, exitshort, backstring)
        self.caller.execute_cmd(digstring)


class CmdLink(MuxCommand):
    """
    link existing rooms together with exits

    Usage:
      @link[/switches] <object> = <target>
      @link[/switches] <object> =
      @link[/switches] <object>

    Switch:
      twoway - connect two exits. For this to work, BOTH <object>
               and <target> must be exit objects.

    If <object> is an exit, set its destination to <target>. Two-way operation
    instead sets the destination to the *locations* of the respective given
    arguments.
    The second form (a lone =) sets the destination to None (same as
    the @unlink command) and the third form (without =) just shows the
    currently set destination.
    """

    key = "@link"
    locks = "cmd:perm(link) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Perform the link"
        caller = self.caller

        if not self.args:
            caller.msg("Usage: @link[/twoway] <object> = <target>")
            return

        object_name = self.lhs

        # get object
        obj = caller.search(object_name, global_search=True)
        if not obj:
            return

        string = ""
        if self.rhs:
            # this means a target name was given
            target = caller.search(self.rhs, global_search=True)
            if not target:
                return

            string = ""
            if not obj.destination:
                string += "Note: %s(%s) did not have a destination set before. Make sure you linked the right thing." % (obj.name,obj.dbref)
            if "twoway" in self.switches:
                if not (target.location and obj.location):
                    string = "To create a two-way link, %s and %s must both have a location" % (obj, target)
                    string += " (i.e. they cannot be rooms, but should be exits)."
                    self.caller.msg(string)
                    return
                if not target.destination:
                    string += "\nNote: %s(%s) did not have a destination set before. Make sure you linked the right thing." % (target.name, target.dbref)
                obj.destination = target.location
                target.destination = obj.location
                string += "\nLink created %s (in %s) <-> %s (in %s) (two-way)." % (obj.name, obj.location, target.name, target.location)
            else:
                obj.destination = target
                string += "\nLink created %s -> %s (one way)." % (obj.name, target)

        elif self.rhs is None:
            # this means that no = was given (otherwise rhs
            # would have been an empty string). So we inspect
            # the home/destination on object
            dest = obj.destination
            if dest:
                string = "%s is an exit to %s." % (obj.name, dest.name)
            else:
                string = "%s is not an exit. Its home location is %s." % (obj.name, obj.home)

        else:
            # We gave the command @link 'obj = ' which means we want to
            # clear destination.
            if obj.destination:
                obj.destination = None
                string = "Former exit %s no longer links anywhere." % obj.name
            else:
                string = "%s had no destination to unlink." % obj.name
        # give feedback
        caller.msg(string.strip())


class CmdUnLink(CmdLink):
    """
    remove exit-connections between rooms

    Usage:
      @unlink <Object>

    Unlinks an object, for example an exit, disconnecting
    it from whatever it was connected to.
    """
    # this is just a child of CmdLink

    key = "@unlink"
    locks = "cmd:perm(unlink) or perm(Builders)"
    help_key = "Building"

    def func(self):
        """
        All we need to do here is to set the right command
        and call func in CmdLink
        """

        caller = self.caller

        if not self.args:
            caller.msg("Usage: @unlink <object>")
            return

        # This mimics '@link <obj> = ' which is the same as @unlink
        self.rhs = ""

        # call the @link functionality
        super(CmdUnLink, self).func()


class CmdSetHome(CmdLink):
    """
    set an object's home location

    Usage:
      @home <obj> [= home_location]

    The "home" location is a "safety" location for objects; they
    will be moved there if their current location ceases to exist. All
    objects should always have a home location for this reason.
    It is also a convenient target of the "home" command.

    If no location is given, just view the object's home location.
    """

    key = "@home"
    aliases = "@sethome"
    locks = "cmd:perm(@home) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "implement the command"
        if not self.args:
            string = "Usage: @home <obj> [= home_location]"
            self.caller.msg(string)
            return

        obj = self.caller.search(self.lhs, global_search=True)
        if not obj:
            return
        if not self.rhs:
            # just view
            home = obj.home
            if not home:
                string = "This object has no home location set!"
            else:
                string = "%s's current home is %s(%s)." % (obj, home,
                                                           home.dbref)
        else:
            # set a home location
            new_home = self.caller.search(self.rhs, global_search=True)
            if not new_home:
                return
            old_home = obj.home
            obj.home = new_home
            if old_home:
                string = "%s's home location was changed from %s(%s) to %s(%s)." % (obj, old_home, old_home.dbref, new_home, new_home.dbref)
            else:
                string = "%s' home location was set to %s(%s)." % (obj, new_home, new_home.dbref)
        self.caller.msg(string)


class CmdListCmdSets(MuxCommand):
    """
    list command sets defined on an object

    Usage:
      @cmdsets [obj]

    This displays all cmdsets assigned
    to a user. Defaults to yourself.
    """
    key = "@cmdsets"
    aliases = "@listcmsets"
    locks = "cmd:perm(listcmdsets) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "list the cmdsets"

        caller = self.caller
        if self.arglist:
            obj = caller.search(self.arglist[0])
            if not obj:
                return
        else:
            obj = caller
        string = "%s" % obj.cmdset
        caller.msg(string)


class CmdName(ObjManipCommand):
    """
    change the name and/or aliases of an object

    Usage:
      @name obj = name;alias1;alias2

    Rename an object to something new.

    """

    key = "@name"
    aliases = ["@rename"]
    locks = "cmd:perm(rename) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "change the name"

        caller = self.caller
        if not self.args:
            string = "Usage: @name <obj> = <newname>[;alias;alias;...]"
            caller.msg(string)
            return

        if self.lhs_objs:
            objname = self.lhs_objs[0]['name']
            obj = caller.search(objname)
            if not obj:
                return
        if self.rhs_objs:
            newname = self.rhs_objs[0]['name']
            aliases = self.rhs_objs[0]['aliases']
        else:
            newname = self.rhs
            aliases = None
        if not newname and not aliases:
            caller.msg("No names or aliases defined!")
            return
        # change the name and set aliases:
        if newname:
            obj.name = newname
        astring = ""
        if aliases:
            [obj.aliases.add(alias) for alias in aliases]
            astring = " (%s)" % (", ".join(aliases))
        # fix for exits - we need their exit-command to change name too
        if obj.destination:
            obj.flush_from_cache()
        caller.msg("Object's name changed to '%s'%s." % (newname, astring))


class CmdOpen(ObjManipCommand):
    """
    open a new exit from the current room

    Usage:
      @open <new exit>[;alias;alias..][:typeclass] [,<return exit>[;alias;..][:typeclass]]] = <destination>

    Handles the creation of exits. If a destination is given, the exit
    will point there. The <return exit> argument sets up an exit at the
    destination leading back to the current room. Destination name
    can be given both as a #dbref and a name, if that name is globally
    unique.

    """
    key = "@open"
    locks = "cmd:perm(open) or perm(Builders)"
    help_category = "Building"

    # a custom member method to chug out exits and do checks
    def create_exit(self, exit_name, location, destination,
                                    exit_aliases=None, typeclass=None):
        """
        Helper function to avoid code duplication.
        At this point we know destination is a valid location

        """
        caller = self.caller
        string = ""
        # check if this exit object already exists at the location.
        # we need to ignore errors (so no automatic feedback)since we
        # have to know the result of the search to decide what to do.
        exit_obj = caller.search(exit_name, location=location, quiet=True)
        if len(exit_obj) > 1:
            # give error message and return
            caller.search(exit_name, location=location)
            return
        if exit_obj:
            exit_obj = exit_obj[0]
            if not exit_obj.destination:
                # we are trying to link a non-exit
                string = "'%s' already exists and is not an exit!\nIf you want to convert it "
                string += "to an exit, you must assign an object to the 'destination' property first."
                caller.msg(string % exit_name)
                return None
            # we are re-linking an old exit.
            old_destination = exit_obj.destination
            if old_destination:
                string = "Exit %s already exists." % exit_name
                if old_destination.id != destination.id:
                    # reroute the old exit.
                    exit_obj.destination = destination
                    [exit_obj.aliases.add(alias) for alias in exit_aliases]
                    string += " Rerouted its old destination '%s' to '%s' and changed aliases." % \
                        (old_destination.name, destination.name)
                else:
                    string += " It already points to the correct place."

        else:
            # exit does not exist before. Create a new one.
            if not typeclass:
                typeclass = settings.BASE_EXIT_TYPECLASS
            exit_obj = create.create_object(typeclass,
                                            key=exit_name,
                                            location=location,
                                            aliases=exit_aliases,
                                            report_to=caller)
            if exit_obj:
                # storing a destination is what makes it an exit!
                exit_obj.destination = destination
                string = "Created new Exit '%s' from %s to %s (aliases: %s)." % (exit_name,location.name,
                                                                                 destination.name,
                                                                                 ", ".join([str(e) for e in exit_aliases]))
            else:
                string = "Error: Exit '%s' not created." % (exit_name)
        # emit results
        caller.msg(string)
        return exit_obj

    def func(self):
        """
        This is where the processing starts.
        Uses the ObjManipCommand.parser() for pre-processing
        as well as the self.create_exit() method.
        """
        caller = self.caller

        if not self.args or not self.rhs:
            string = "Usage: @open <new exit>[;alias...][:typeclass][,<return exit>[;alias..][:typeclass]]] "
            string += "= <destination>"
            caller.msg(string)
            return

        # We must have a location to open an exit
        location = caller.location
        if not location:
            caller.msg("You cannot create an exit from a None-location.")
            return

        # obtain needed info from cmdline

        exit_name = self.lhs_objs[0]['name']
        exit_aliases = self.lhs_objs[0]['aliases']
        exit_typeclass = self.lhs_objs[0]['option']
        dest_name = self.rhs

        # first, check so the destination exists.
        destination = caller.search(dest_name, global_search=True)
        if not destination:
            return

        # Create exit
        ok = self.create_exit(exit_name,
                              location,
                              destination,
                              exit_aliases,
                              exit_typeclass)
        if not ok:
            # an error; the exit was not created, so we quit.
            return
        # Create back exit, if any
        if len(self.lhs_objs) > 1:
            back_exit_name = self.lhs_objs[1]['name']
            back_exit_aliases = self.lhs_objs[1]['aliases']
            back_exit_typeclass = self.lhs_objs[1]['option']
            ok = self.create_exit(back_exit_name,
                                  destination,
                                  location,
                                  back_exit_aliases,
                                  back_exit_typeclass)


class CmdSetAttribute(ObjManipCommand):
    """
    set attribute on an object or player

    Usage:
      @set <obj>/<attr> = <value>
      @set <obj>/<attr> =
      @set <obj>/<attr>
      @set *<player>/attr = <value>

    Sets attributes on objects. The second form clears
    a previously set attribute while the last form
    inspects the current value of the attribute
    (if any).

    The most common data to save with this command are strings and
    numbers. You can however also set Python primities such as lists,
    dictionaries and tuples on objects (this might be important for
    the functionality of certain custom objects).  This is indicated
    by you starting your value with one of {c'{n, {c"{n, {c({n, {c[{n
    or {c{ {n.
    Note that you should leave a space after starting a dictionary ('{ ')
    so as to not confuse the dictionary start with a colour code like \{g.
    Remember that if you use Python primitives like this, you must
    write proper Python syntax too - notably you must include quotes
    around your strings or you will get an error.

    """

    key = "@set"
    locks = "cmd:perm(set) or perm(Builders)"
    help_category = "Building"

    def convert_from_string(self, strobj):
        """
        Converts a single object in *string form* to its equivalent python
        type.

         Python earlier than 2.6:
        Handles floats, ints, and limited nested lists and dicts
        (can't handle lists in a dict, for example, this is mainly due to
        the complexity of parsing this rather than any technical difficulty -
        if there is a need for @set-ing such complex structures on the
        command line we might consider adding it).
         Python 2.6 and later:
        Supports all Python structures through literal_eval as long as they
        are valid Python syntax. If they are not (such as [test, test2], ie
        withtout the quotes around the strings), the entire structure will
        be converted to a string and a warning will be given.

        We need to convert like this since all data being sent over the
        telnet connection by the Player is text - but we will want to
        store it as the "real" python type so we can do convenient
        comparisons later (e.g.  obj.db.value = 2, if value is stored as a
        string this will always fail).
        """

        def rec_convert(obj):
            """
            Helper function of recursive conversion calls. This is only
            used for Python <=2.5. After that literal_eval is available.
            """
            # simple types
            try:
                return int(obj)
            except ValueError:
                pass
            try:
                return float(obj)
            except ValueError:
                pass
            # iterables
            if obj.startswith('[') and obj.endswith(']'):
                "A list. Traverse recursively."
                return [rec_convert(val) for val in obj[1:-1].split(',')]
            if obj.startswith('(') and obj.endswith(')'):
                "A tuple. Traverse recursively."
                return tuple([rec_convert(val) for val in obj[1:-1].split(',')])
            if obj.startswith('{') and obj.endswith('}') and ':' in obj:
                "A dict. Traverse recursively."
                return dict([(rec_convert(pair.split(":", 1)[0]),
                              rec_convert(pair.split(":", 1)[1]))
                             for pair in obj[1:-1].split(',') if ":" in pair])
            # if nothing matches, return as-is
            return obj

        if _LITERAL_EVAL:
            # Use literal_eval to parse python structure exactly.
            try:
                return _LITERAL_EVAL(strobj)
            except (SyntaxError, ValueError):
                # treat as string
                string = "{RNote: Value was converted to string. If you don't want this, "
                string += "use proper Python syntax, like enclosing strings in quotes.{n"
                self.caller.msg(string)
                return utils.to_str(strobj)
        else:
            # fall back to old recursive solution (does not support
            # nested lists/dicts)
            return rec_convert(strobj.strip())

    def func(self):
        "Implement the set attribute - a limited form of @py."

        caller = self.caller
        if not self.args:
            caller.msg("Usage: @set obj/attr = value. Use empty value to clear.")
            return

        # get values prepared by the parser
        value = self.rhs
        objname = self.lhs_objattr[0]['name']
        attrs = self.lhs_objattr[0]['attrs']

        if objname.startswith('*'):
            obj = caller.search_player(objname.lstrip('*'))
        else:
            obj = caller.search(objname)
        if not obj:
            return

        string = ""
        if not value:
            if self.rhs is None:
                # no = means we inspect the attribute(s)
                if not attrs:
                    attrs = [attr.key for attr in obj.get_all_attributes()]
                for attr in attrs:
                    if obj.attributes.has(attr):
                        string += "\nAttribute %s/%s = %s" % (obj.name, attr,
                                                      obj.attributes.get(attr))
                    else:
                        string += "\n%s has no attribute '%s'." % (obj.name, attr)
                    # we view it without parsing markup.
                self.caller.msg(string.strip(), data={"raw": True})
                return
            else:
                # deleting the attribute(s)
                for attr in attrs:
                    if obj.attributes.has(attr):
                        val = obj.attributes.has(attr)
                        obj.attributes.remove(attr)
                        string += "\nDeleted attribute '%s' (= %s) from %s." % (attr, val, obj.name)
                    else:
                        string += "\n%s has no attribute '%s'." % (obj.name, attr)
        else:
            # setting attribute(s). Make sure to convert to real Python type before saving.
             for attr in attrs:
                try:
                    obj.attributes.add(attr, self.convert_from_string(value))
                    string += "\nCreated attribute %s/%s = %s" % (obj.name, attr, value)
                except SyntaxError:
                    # this means literal_eval tried to parse a faulty string
                    string = "{RCritical Python syntax error in your value. "
                    string += "Only primitive Python structures are allowed. "
                    string += "\nYou also need to use correct Python syntax. "
                    string += "Remember especially to put quotes around all "
                    string += "strings inside lists and dicts.{n"
        # send feedback
        caller.msg(string.strip('\n'))


class CmdTypeclass(MuxCommand):
    """
    set or change an object's typeclass

    Usage:
      @typclass[/switch] <object> [= <typeclass.path>]
      @type                     ''
      @parent                   ''

    Switch:
      reset - clean out *all* the attributes on the object -
              basically making this a new clean object.
      force - change to the typeclass also if the object
              already has a typeclass of the same name.
    Example:
      @type button = examples.red_button.RedButton

    View or set an object's typeclass. If setting, the creation hooks
    of the new typeclass will be run on the object. If you have
    clashing properties on the old class, use /reset. By default you
    are protected from changing to a typeclass of the same name as the
    one you already have, use /force to override this protection.

    The given typeclass must be identified by its location using
    python dot-notation pointing to the correct module and class. If
    no typeclass is given (or a wrong typeclass is given). Errors in
    the path or new typeclass will lead to the old typeclass being
    kept. The location of the typeclass module is searched from the
    default typeclass directory, as defined in the server settings.

    """

    key = "@typeclass"
    aliases = "@type, @parent"
    locks = "cmd:perm(typeclass) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Implements command"

        caller = self.caller

        if not self.args:
            caller.msg("Usage: @type <object> [=<typeclass]")
            return

        # get object to swap on
        obj = caller.search(self.lhs)
        if not obj:
            return

        if not self.rhs:
            # we did not supply a new typeclass, view the
            # current one instead.
            if hasattr(obj, "typeclass"):
                string = "%s's current typeclass is '%s' (%s)." % (obj.name,
                                    obj.typeclass.typename, obj.typeclass.path)
            else:
                string = "%s is not a typed object." % obj.name
            caller.msg(string)
            return

        # we have an =, a typeclass was supplied.
        typeclass = self.rhs

        if not obj.access(caller, 'edit'):
            caller.msg("You are not allowed to do that.")
            return

        if not hasattr(obj, 'swap_typeclass') or not hasattr(obj, 'typeclass'):
            caller.msg("This object cannot have a type at all!")
            return

        is_same = obj.is_typeclass(typeclass, exact=True)
        if is_same and not 'force' in self.switches:
            string = "%s already has the typeclass '%s'. Use /force to override." % (obj.name, typeclass)
        else:
            reset = "reset" in self.switches
            old_typeclass_path = obj.typeclass_path
            ok = obj.swap_typeclass(typeclass, clean_attributes=reset)
            if ok:
                if is_same:
                    string = "%s updated its existing typeclass (%s).\n" % (obj.name, obj.typeclass.path)
                else:
                    string = "%s changed typeclass from %s to %s.\n" % (obj.name,
                                                             old_typeclass_path,
                                                             obj.typeclass_path)
                string += "Creation hooks were run."
                if reset:
                    string += " All old attributes where deleted before the swap."
                else:
                    string += " Note that the typeclassed object could have ended up with a mixture of old"
                    string += "\nand new attributes. Use /reset to remove old attributes if you don't want this."
            else:
                string = obj.typeclass_last_errmsg
                string += "\nCould not swap '%s' (%s) to typeclass '%s'." % (obj.name,
                                                             old_typeclass_path,
                                                             typeclass)
        caller.msg(string)


class CmdWipe(ObjManipCommand):
    """
    clear all attributes from an object

    Usage:
      @wipe <object>[/attribute[/attribute...]]

    Example:
      @wipe box
      @wipe box/colour

    Wipes all of an object's attributes, or optionally only those
    matching the given attribute-wildcard search string.
    """
    key = "@wipe"
    locks = "cmd:perm(wipe) or perm(Builders)"
    help_category = "Building"

    def func(self):
        """
        inp is the dict produced in ObjManipCommand.parse()
        """

        caller = self.caller

        if not self.args:
            caller.msg("Usage: @wipe <object>[/attribute/attribute...]")
            return

        # get the attributes set by our custom parser
        objname = self.lhs_objattr[0]['name']
        attrs = self.lhs_objattr[0]['attrs']

        obj = caller.search(objname)
        if not obj:
            return
        if not obj.access(caller, 'edit'):
            caller.msg("You are not allowed to do that.")
            return
        if not attrs:
            # wipe everything
            for attr in obj.get_all_attributes():
                attr.delete()
            string = "Wiped all attributes on %s." % obj.name
        else:
            for attrname in attrs:
                obj.attributes.remove(attrname)
            string = "Wiped attributes %s on %s."
            string = string % (",".join(attrs), obj.name)
        caller.msg(string)


class CmdLock(ObjManipCommand):
    """
    assign a lock definition to an object

    Usage:
      @lock <object>[ = <lockstring>]
      or
      @lock[/switch] object/<access_type>

    Switch:
      del - delete given access type
      view - view lock associated with given access type (default)

    If no lockstring is given, shows all locks on
    object.

    Lockstring is on the form
       'access_type:[NOT] func1(args)[ AND|OR][ NOT] func2(args) ...]
    Where func1, func2 ... valid lockfuncs with or without arguments.
    Separator expressions need not be capitalized.

    For example:
       'get: id(25) or perm(Wizards)'
    The 'get' access_type is checked by the get command and will
    an object locked with this string will only be possible to
    pick up by Wizards or by object with id 25.

    You can add several access_types after oneanother by separating
    them by ';', i.e:
       'get:id(25);delete:perm(Builders)'
    """
    key = "@lock"
    aliases = ["@locks", "lock", "locks"]
    locks = "cmd: perm(@locks) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Sets up the command"

        caller = self.caller
        if not self.args:
            string = "@lock <object>[ = <lockstring>] or @lock[/switch] object/<access_type>"
            caller.msg(string)
            return
        if '/' in self.lhs:
            # call on the form @lock obj/access_type
            objname, access_type = [p.strip() for p in self.lhs.split('/', 1)]
            obj = caller.search(objname)
            if not obj:
                return
            lockdef = obj.locks.get(access_type)
            if lockdef:
                if 'del' in self.switches:
                    if not obj.access(caller, 'control'):
                        caller.msg("You are not allowed to do that.")
                        return
                    obj.locks.delete(access_type)
                    string = "deleted lock %s" % lockdef
            else:
                string = "%s has no lock of access type '%s'." % (obj, access_type)
            caller.msg(string)
            return

        if self.rhs:
            # we have a = separator, so we are assigning a new lock
            objname, lockdef = self.lhs, self.rhs
            obj = caller.search(objname)
            if not obj:
                return
            if not obj.access(caller, 'control'):
                caller.msg("You are not allowed to do that.")
                return
            try:
                ok = obj.locks.add(lockdef)
            except LockException, e:
                caller.msg(str(e))
            if ok:
                caller.msg("Added lock '%s' to %s." % (lockdef, obj))
            return

        # if we get here, we are just viewing all locks
        obj = caller.search(self.lhs)
        if not obj:
            return
        caller.msg(obj.locks)


class CmdExamine(ObjManipCommand):
    """
    get detailed information about an object

    Usage:
      examine [<object>[/attrname]]
      examine [*<player>[/attrname]]

    Switch:
      player - examine a Player (same as adding *)

    The examine command shows detailed game info about an
    object and optionally a specific attribute on it.
    If object is not specified, the current location is examined.

    Append a * before the search string to examine a player.

    """
    key = "@examine"
    aliases = ["@ex","ex", "exam", "examine"]
    locks = "cmd:perm(examine) or perm(Builders)"
    help_category = "Building"
    arg_regex = r"(/\w+?(\s|$))|\s|$"

    player_mode = False

    def list_attribute(self, crop, attr, value):
        """
        Formats a single attribute line.
        """
        if crop and isinstance(value, basestring):
            value = utils.crop(value)
            value = utils.to_unicode(value)
        string = "\n %s = %s" % (attr, value)
        string = raw(string)
        return string

    def format_attributes(self, obj, attrname=None, crop=True):
        """
        Helper function that returns info about attributes and/or
        non-persistent data stored on object
        """

        if attrname:
            db_attr = [(attrname, obj.attributes.get(attrname))]
            try:
                ndb_attr = [(attrname, object.__getattribute__(obj.ndb, attrname))]
            except Exception:
                ndb_attr = None
        else:
            db_attr = [(attr.key, attr.value) for attr in obj.db_attributes.all()]
            try:
                ndb_attr = [(aname, avalue)
                            for aname, avalue in obj.ndb.__dict__.items()
                            if not aname.startswith("_")]
            except Exception:
                ndb_attr = None
        string = ""
        if db_attr and db_attr[0]:
            string += "\n{wPersistent attributes{n:"
            for attr, value in db_attr:
                string += self.list_attribute(crop, attr, value)
        if ndb_attr and ndb_attr[0]:
            string += "\n{wNon-Persistent attributes{n:"
            for attr, value in ndb_attr:
                string += self.list_attribute(crop, attr, value)
        return string

    def format_output(self, obj, avail_cmdset):
        """
        Helper function that creates a nice report about an object.

        returns a string.
        """

        string = "\n{wName/key{n: {c%s{n (%s)" % (obj.name, obj.dbref)
        if hasattr(obj, "aliases") and obj.aliases.all():
            string += "\n{wAliases{n: %s" % (", ".join(utils.make_iter(str(obj.aliases))))
        if hasattr(obj, "sessid") and obj.sessid:
            string += "\n{wsession{n: %s" % obj.sessid
        elif hasattr(obj, "sessions") and obj.sessions:
            string += "\n{wsession(s){n: %s" % (", ".join(str(sess.sessid)
                                                for sess in obj.sessions))
        if hasattr(obj, "has_player") and obj.has_player:
            string += "\n{wPlayer{n: {c%s{n" % obj.player.name
            perms = obj.player.permissions.all()
            if obj.player.is_superuser:
                perms = ["<Superuser>"]
            elif not perms:
                perms = ["<None>"]
            string += "\n{wPlayer Perms{n: %s" % (", ".join(perms))
            if obj.player.attributes.has("_quell"):
                string += " {r(quelled){n"
        string += "\n{wTypeclass{n: %s (%s)" % (obj.typeclass.typename,
                                                obj.typeclass_path)
        if hasattr(obj, "location"):
            string += "\n{wLocation{n: %s" % obj.location
            if obj.location:
                string += " (#%s)" % obj.location.id
        if hasattr(obj, "destination") and obj.destination:
            string += "\n{wDestination{n: %s" % obj.destination
            if obj.destination:
                string += " (#%s)" % obj.destination.id
        perms = obj.permissions.all()
        if perms:
            perms_string = (", ".join(perms))
        else:
            perms_string = "Default"
        if obj.is_superuser:
            perms_string += " [Superuser]"

        string += "\n{wPermissions{n: %s" % perms_string

        tags_string = utils.fill(", ".join(tag for tag in obj.tags.all()), indent=5)
        if tags_string:
            string += "\n{wTags{n: %s" % tags_string

        locks = str(obj.locks)
        if locks:
            locks_string = utils.fill("; ".join([lock for lock in locks.split(';')]), indent=6)
        else:
            locks_string = " Default"
        string += "\n{wLocks{n:%s" % locks_string


        if not (len(obj.cmdset.all()) == 1 and obj.cmdset.current.key == "_EMPTY_CMDSET"):
            stored_cmdsets = obj.cmdset.all()
            stored_cmdsets.sort(key=lambda x: x.priority, reverse=True)
            string += "\n{wStored Cmdset(s){n:\n %s" % ("\n ".join("%s [%s] (%s, prio %s)" % \
                                      (cmdset.path, cmdset.key, cmdset.mergetype, cmdset.priority)
                                       for cmdset in stored_cmdsets if cmdset.key != "_EMPTY_CMDSET"))

            # this gets all components of the currently merged set
            all_cmdsets = [(cmdset.key, cmdset) for cmdset in avail_cmdset.merged_from]
            # we always at least try to add player- and session sets since these are ignored
            # if we merge on the object level.
            if hasattr(obj, "player") and obj.player:
                all_cmdsets.extend([(cmdset.key, cmdset) for cmdset in  obj.player.cmdset.all()])
                if obj.sessid:
                    all_cmdsets.extend([(cmdset.key, cmdset) for cmdset in obj.player.get_session(obj.sessid).cmdset.all()])
            else:
                try:
                    # we have to protect this since many objects don't have sessions.
                    all_cmdsets.extend([(cmdset.key, cmdset) for cmdset in obj.get_session(obj.sessid).cmdset.all()])
                except (TypeError, AttributeError):
                    pass
            all_cmdsets = [cmdset for cmdset in dict(all_cmdsets).values()]
            all_cmdsets.sort(key=lambda x: x.priority, reverse=True)
            string += "\n{wMerged Cmdset(s){n:\n %s" % ("\n ".join("%s [%s] (%s, prio %s)" % \
                                      (cmdset.path, cmdset.key, cmdset.mergetype, cmdset.priority)
                                       for cmdset in all_cmdsets))


            # list the commands available to this object
            avail_cmdset = sorted([cmd.key for cmd in avail_cmdset
                                    if cmd.access(obj, "cmd")])

            cmdsetstr = utils.fill(", ".join(avail_cmdset), indent=2)
            string += "\n{wCommands available to %s (result of Merged CmdSets){n:\n %s" % (obj.key, cmdsetstr)

        if hasattr(obj, "scripts") and hasattr(obj.scripts, "all") and obj.scripts.all():
            string += "\n{wScripts{n:\n %s" % obj.scripts
        # add the attributes
        string += self.format_attributes(obj)
        # add the contents
        exits = []
        pobjs = []
        things = []
        if hasattr(obj, "contents"):
            for content in obj.contents:
                if content.destination:
                    exits.append(content)
                elif content.player:
                    pobjs.append(content)
                else:
                    things.append(content)
            if exits:
                string += "\n{wExits{n: %s" % ", ".join([exit.name for exit in exits])
            if pobjs:
                string += "\n{wCharacters{n: %s" % ", ".join(["{c%s{n" % pobj.name for pobj in pobjs])
            if things:
                string += "\n{wContents{n: %s" % ", ".join([cont.name for cont in obj.contents
                                                            if cont not in exits and cont not in pobjs])
        separator = "-" * 78
        #output info
        return '%s\n%s\n%s' % (separator, string.strip(), separator)

    def func(self):
        "Process command"
        caller = self.caller

        def get_cmdset_callback(cmdset):
            """
            We make use of the cmdhandeler.get_and_merge_cmdsets below. This
            is an asynchronous function, returning a Twisted deferred.
            So in order to properly use this we need use this callback;
            it is called with the result of get_and_merge_cmdsets, whenever
            that function finishes. Taking the resulting cmdset, we continue
            to format and output the result.
            """
            string = self.format_output(obj, cmdset)
            self.msg(string.strip())

        if not self.args:
            # If no arguments are provided, examine the invoker's location.
            if hasattr(caller, "location"):
                obj = caller.location
                if not obj.access(caller, 'examine'):
                #If we don't have special info access, just look at the object instead.
                    caller.execute_cmd('look %s' % obj.name)
                    return
                # using callback for printing result whenever function returns.
                get_and_merge_cmdsets(obj, self.session, self.player, obj, "object").addCallback(get_cmdset_callback)
            else:
                self.msg("You need to supply a target to examine.")
            return

        # we have given a specific target object
        for objdef in self.lhs_objattr:

            obj_name = objdef['name']
            obj_attrs = objdef['attrs']

            self.player_mode = utils.inherits_from(caller, "src.players.player.Player") or \
                           "player" in self.switches or obj_name.startswith('*')
            if self.player_mode:
                try:
                    obj = caller.search_player(obj_name.lstrip('*'))
                except AttributeError:
                    # this means we are calling examine from a player object
                    obj = caller.search(obj_name.lstrip('*'))
            else:
                obj = caller.search(obj_name)
            if not obj:
                continue

            if not obj.access(caller, 'examine'):
                #If we don't have special info access, just look
                # at the object instead.
                caller.execute_cmd('look %s' % obj_name)
                continue

            if obj_attrs:
                for attrname in obj_attrs:
                    # we are only interested in specific attributes
                    caller.msg(self.format_attributes(obj, attrname, crop=False))
            else:
                if hasattr(obj, "sessid") and obj.sessid:
                    mergemode = "session"
                elif self.player_mode:
                    mergemode = "player"
                else:
                    mergemode = "object"
                # using callback to print results whenever function returns.
                get_and_merge_cmdsets(obj, self.session, self.player, obj, mergemode).addCallback(get_cmdset_callback)


class CmdFind(MuxCommand):
    """
    search the database for objects

    Usage:
      @find[/switches] <name or dbref or *player> [= dbrefmin[-dbrefmax]]

    Switches:
      room - only look for rooms (location=None)
      exit - only look for exits (destination!=None)
      char - only look for characters (BASE_CHARACTER_TYPECLASS)

    Searches the database for an object of a particular name or dbref.
    Use *playername to search for a player. The switches allows for
    limiting object matches to certain game entities. Dbrefmin and dbrefmax
    limits matches to within the given dbrefs, or above/below if only
    one is given.
    """

    key = "@find"
    aliases = "find, @search, search, @locate, locate"
    locks = "cmd:perm(find) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Search functionality"
        caller = self.caller
        switches = self.switches

        if not self.args:
            caller.msg("Usage: @find <string> [= low [-high]]")
            return

        searchstring = self.lhs
        low, high = 1, ObjectDB.objects.all().order_by("-id")[0].id
        if self.rhs:
            if "-" in self.rhs:
                # also support low-high syntax
                limlist = [part.strip() for part in self.rhs.split("-", 1)]
            else:
                # otherwise split by space
                limlist = self.rhs.split(None, 1)
            if limlist and limlist[0].isdigit():
                low = max(low, int(limlist[0]))
            if len(limlist) > 1 and limlist[1].isdigit():
                high = min(high, int(limlist[1]))
        low = min(low, high)
        high = max(low, high)

        is_dbref = utils.dbref(searchstring)
        is_player = searchstring.startswith("*")

        if is_dbref or is_player:

            if is_dbref:
                # a dbref search
                result = caller.search(searchstring, global_search=True)
            else:
                # a player search
                searchstring = searchstring.lstrip("*")
                result = caller.search_player(searchstring)

            string = "{wMatch{n(#%i-#%i):" % (low, high)
            if not result:
                return
            if not low <= int(result.id) <= high:
                string += "\n   {RNo match found for '%s' within the given dbref limits.{n" % searchstring
            else:
                string += "\n{g   %s(%s) - %s{n" % (result.key, result.dbref,
                                                    result.typeclass.path)
        else:
            # Not a player/dbref search but a wider search; build a queryset.

            results = ObjectDB.objects.filter(db_key__istartswith=searchstring,
                                              id__gte=low, id__lte=high)
            if "room" in switches:
                results = results.filter(db_location__isnull=True)
            if "exit" in switches:
                results = results.filter(db_destination__isnull=False)
            if "char" in switches:
                results = results.filter(db_typeclass_path=CHAR_TYPECLASS)
            nresults = results.count()
            if not nresults:
                # no matches on the keys. Try aliases instead.
                results = ObjectDB.objects.filter(db_tags__db_key__iexact=searchstring, db_tags__db_tagtype__iexact="alias")
                if "room" in switches:
                    results = results.filter(db_location__isnull=True)
                if "exit" in switches:
                    results = results.filter(db_destination__isnull=False)
                if "char" in switches:
                    results = results.filter(db_typeclass_path=CHAR_TYPECLASS)
                # we have to parse alias -> real object here
                results = [result.dbobj for result in results]
                nresults = len(results)

            restrictions = ""
            if self.switches:
                restrictions = ", %s" % (",".join(self.switches))
            if nresults:
                # convert result to typeclasses.
                results = [result.typeclass for result in results]
                if nresults > 1:
                    string = "{w%i Matches{n(#%i-#%i%s):" % (nresults, low, high, restrictions)
                    for res in results:
                        string += "\n   {g%s(%s) - %s{n" % (res.key, res.dbref, res.path)
                else:
                    string = "{wOne Match{n(#%i-#%i%s):" % (low, high, restrictions)
                    string += "\n   {g%s(%s) - %s{n" % (results[0].key, results[0].dbref, results[0].path)
            else:
                string = "{wMatch{n(#%i-#%i%s):" % (low, high, restrictions)
                string += "\n   {RNo matches found for '%s'{n" % searchstring

        # send result
        caller.msg(string.strip())


class CmdTeleport(MuxCommand):
    """
    teleport object to another location

    Usage:
      @tel/switch [<object> =] <target location>

    Examples:
      @tel Limbo
      @tel/quiet box Limbo
      @tel/tonone box

    Switches:
      quiet  - don't echo leave/arrive messages to the source/target
               locations for the move.
      intoexit - if target is an exit, teleport INTO
                 the exit object instead of to its destination
      tonone - if set, teleport the object to a None-location. If this
               switch is set, <target location> is ignored.
               Note that the only way to retrieve
               an object from a None location is by direct #dbref
               reference.

    Teleports an object somewhere. If no object is given, you yourself
    is teleported to the target location.     """
    key = "@tel"
    aliases = "@teleport"
    locks = "cmd:perm(teleport) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Performs the teleport"

        caller = self.caller
        args = self.args
        lhs, rhs = self.lhs, self.rhs
        switches = self.switches

        # setting switches
        tel_quietly = "quiet" in switches
        to_none = "tonone" in switches

        if to_none:
            # teleporting to None
            if not args:
                obj_to_teleport = caller
                caller.msg("Teleported to None-location.")
                if caller.location and not tel_quietly:
                    caller.location.msg_contents("%s teleported into nothingness." % caller, exclude=caller)
            else:
                obj_to_teleport = caller.search(lhs, global_search=True)
                if not obj_to_teleport:
                    caller.msg("Did not find object to teleport.")
                    return
                caller.msg("Teleported %s -> None-location." % obj_to_teleport)
                if obj_to_teleport.location and not tel_quietly:
                    obj_to_teleport.location.msg_contents("%s teleported %s into nothingness."
                                                          % (caller, obj_to_teleport),
                                                          exclude=caller)
            obj_to_teleport.location=None
            return

        # not teleporting to None location
        if not args and not to_none:
            caller.msg("Usage: teleport[/switches] [<obj> =] <target_loc>|home")
            return

        if rhs:
            obj_to_teleport = caller.search(lhs, global_search=True)
            destination = caller.search(rhs, global_search=True)
        else:
            obj_to_teleport = caller
            destination = caller.search(lhs, global_search=True)
        if not obj_to_teleport:
            caller.msg("Did not find object to teleport.")
            return

        if not destination:
            caller.msg("Destination not found.")
            return
        if obj_to_teleport == destination:
            caller.msg("You can't teleport an object inside of itself!")
            return
        if obj_to_teleport.location and obj_to_teleport.location == destination:
            caller.msg("%s is already at %s." % (obj_to_teleport, destination))
            return
        use_destination = True
        if "intoexit" in self.switches:
            use_destination = False

        # try the teleport
        if obj_to_teleport.move_to(destination, quiet=tel_quietly,
                                   emit_to_obj=caller,
                                   use_destination=use_destination):
            if obj_to_teleport == caller:
                caller.msg("Teleported to %s." % destination)
            else:
                caller.msg("Teleported %s -> %s." % (obj_to_teleport,
                                                     destination))


class CmdScript(MuxCommand):
    """
    attach a script to an object

    Usage:
      @script[/switch] <obj> [= <script.path or scriptkey>]

    Switches:
      start - start all non-running scripts on object, or a given script only
      stop - stop all scripts on objects, or a given script only

    If no script path/key is given, lists all scripts active on the given
    object.
    Script path can be given from the base location for scripts as given in
    settings. If adding a new script, it will be started automatically
    (no /start switch is needed). Using the /start or /stop switches on an
    object without specifying a script key/path will start/stop ALL scripts on
    the object.
    """

    key = "@script"
    aliases = "@addscript"
    locks = "cmd:perm(script) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Do stuff"

        caller = self.caller

        if not self.args:
            string = "Usage: @script[/switch] <obj> [= <script.path or script key>]"
            caller.msg(string)
            return

        obj = caller.search(self.lhs)
        if not obj:
            return

        string = ""
        if not self.rhs:
            # no rhs means we want to operate on all scripts
            scripts = obj.scripts.all()
            if not scripts:
                string += "No scripts defined on %s." % obj.key
            elif not self.switches:
                # view all scripts
                from src.commands.default.system import format_script_list
                string += format_script_list(scripts)
            elif "start" in self.switches:
                num = sum([obj.scripts.start(script.key) for script in scripts])
                string += "%s scripts started on %s." % (num, obj.key)
            elif "stop" in self.switches:
                for script in scripts:
                    string += "Stopping script %s on %s." % (script.key,
                                                             obj.key)
                    script.stop()
                string = string.strip()
            obj.scripts.validate()
        else: # rhs exists
            if not self.switches:
                # adding a new script, and starting it
                ok = obj.scripts.add(self.rhs, autostart=True)
                if not ok:
                    string += "\nScript %s could not be added and/or started on %s." % (self.rhs, obj.key)
                else:
                    string = "Script {w%s{n successfully added and started on %s." % (self.rhs, obj.key)

            else:
                paths = [self.rhs] + ["%s.%s" % (prefix, self.rhs)
                                      for prefix in settings.SCRIPT_TYPECLASS_PATHS]
                if "stop" in self.switches:
                    # we are stopping an already existing script
                    for path in paths:
                        ok = obj.scripts.stop(path)
                        if not ok:
                            string += "\nScript %s could not be stopped. Does it exist?" % path
                        else:
                            string = "Script stopped and removed from object."
                            break
                if "start" in self.switches:
                    # we are starting an already existing script
                    for path in paths:
                        ok = obj.scripts.start(path)
                        if not ok:
                            string += "\nScript %s could not be (re)started." % path
                        else:
                            string = "Script started successfully."
                            break
        caller.msg(string.strip())


class CmdTag(MuxCommand):
    """
    handles the tags of an object

    Usage:
      @tag[/del] <obj> [= <tag>[:<category>]]
      @tag/search <tag>

    Switches:
      search - return all objects
      del - remove the given tag. If no tag is specified,
            clear all tags on object.

    Manipulates and lists tags on objects. Tags allow for quick
    grouping of and searching for objects.  If only <obj> is given,
    list all tags on the object.  If /search is used, list objects
    with the given tag.
    The category can be used for grouping tags themselves, but it
    should be used with restrain - tags on their own are usually
    enough to for most grouping schemes.
    """

    key = "@tag"
    locks = "cmd:perm(tag) or perm(Builders)"
    help_category = "Building"

    def func(self):
        "Implement the @tag functionality"

        if not self.args:
            self.caller.msg("Usage: @tag[/switches] <obj> [= <tag>[:<category>]]")
            return
        if "search" in self.switches:
            # search by tag
            tag = self.args
            category = None
            if ":" in tag:
                tag, category = [part.strip() for part in tag.split(":", 1)]
            #print "tag search:", tag, search_category
            objs = search.search_tag(tag, category=category)
            nobjs = len(objs)
            if nobjs > 0:
                catstr = " (category: '{w%s{n')" % category if category else \
                                ("" if nobjs == 1 else " (may have different tag categories)")
                matchstr = ", ".join("{w%s{n(#%i)" % (o.key, o.dbid) for o in objs)

                string = "Found {w%i{n object%s with tag '{w%s{n'%s:\n %s" % (nobjs,
                                                       "s" if nobjs > 1 else "",
                                                       tag,
                                                       catstr, matchstr)
            else:
                string = "No objects found with tag '%s%s'." % (tag,
                                                        " (category: %s)" % category if category else "")
            self.caller.msg(string)
            return
        if "del" in self.switches:
            # remove one or all tags
            obj = self.caller.search(self.lhs, global_search=True)
            if not obj:
                return
            if self.rhs:
                # remove individual tag
                tag = self.rhs
                category = None
                if ":" in tag:
                    tag, category = [part.strip() for part in tag.split(":", 1)]
                obj.tags.remove(tag, category=category)
                string = "Removed tag '%s'%s from %s (if it existed)" % (tag,
                                                    " (category: %s)" % category if category else "",
                                                    obj)
            else:
                # no tag specified, clear all tags
                obj.tags.clear()
                string = "Cleared all tags from from %s." % obj
            self.caller.msg(string)
            return
        # no search/deletion
        if self.rhs:
            # = is found, so we are on the form obj = tag
            obj = self.caller.search(self.lhs, global_search=True)
            if not obj:
                return
            tag = self.rhs
            category = None
            if ":" in tag:
                tag, category = [part.strip() for part in tag.split(":", 1)]
            # create the tag
            obj.tags.add(tag, category=category)
            string = "Added tag '%s'%s to %s." % (tag,
                                                  " (category: %s)" % category if category else "",
                                                  obj)
            self.caller.msg(string)
        else:
            # no = found - list tags on object
            obj = self.caller.search(self.args, global_search=True)
            if not obj:
                return
            tagtuples = obj.tags.all(return_key_and_category=True)
            ntags = len(tagtuples)
            tags = [tup[0] for tup in tagtuples]
            categories = [" (category: %s)" % tup[1] if tup[1] else "" for tup in tagtuples]
            if ntags:
                string = "Tag%s on %s: %s" % ("s" if ntags > 1 else "", obj,
                                        ", ".join("'%s'%s" % (tags[i], categories[i]) for i in range(ntags)))
            else:
                string = "No tags attached to %s." % obj
            self.caller.msg(string)

########NEW FILE########
__FILENAME__ = cmdset_character
"""
This module ties together all the commands default Character objects have
available (i.e. IC commands). Note that some commands, such as
communication-commands are instead put on the player level, in the
Player cmdset. Player commands remain available also to Characters.
"""
from src.commands.cmdset import CmdSet
from src.commands.default import general, help, admin, system
from src.commands.default import building
from src.commands.default import batchprocess


class CharacterCmdSet(CmdSet):
    """
    Implements the default command set.
    """
    key = "DefaultCharacter"
    priority = 0

    def at_cmdset_creation(self):
        "Populates the cmdset"

        # The general commands
        self.add(general.CmdLook())
        self.add(general.CmdHome())
        self.add(general.CmdInventory())
        self.add(general.CmdPose())
        self.add(general.CmdNick())
        self.add(general.CmdGet())
        self.add(general.CmdDrop())
        self.add(general.CmdGive())
        self.add(general.CmdSay())
        self.add(general.CmdAccess())

        # The help system
        self.add(help.CmdHelp())
        self.add(help.CmdSetHelp())

        # System commands
        self.add(system.CmdPy())
        self.add(system.CmdScripts())
        self.add(system.CmdObjects())
        self.add(system.CmdPlayers())
        self.add(system.CmdService())
        self.add(system.CmdAbout())
        self.add(system.CmdTime())
        self.add(system.CmdServerLoad())
        #self.add(system.CmdPs())

        # Admin commands
        self.add(admin.CmdBoot())
        self.add(admin.CmdBan())
        self.add(admin.CmdUnban())
        self.add(admin.CmdEmit())
        self.add(admin.CmdPerm())
        self.add(admin.CmdWall())

        # Building and world manipulation
        self.add(building.CmdTeleport())
        self.add(building.CmdSetObjAlias())
        self.add(building.CmdListCmdSets())
        self.add(building.CmdWipe())
        self.add(building.CmdSetAttribute())
        self.add(building.CmdName())
        self.add(building.CmdDesc())
        self.add(building.CmdCpAttr())
        self.add(building.CmdMvAttr())
        self.add(building.CmdCopy())
        self.add(building.CmdFind())
        self.add(building.CmdOpen())
        self.add(building.CmdLink())
        self.add(building.CmdUnLink())
        self.add(building.CmdCreate())
        self.add(building.CmdDig())
        self.add(building.CmdTunnel())
        self.add(building.CmdDestroy())
        self.add(building.CmdExamine())
        self.add(building.CmdTypeclass())
        self.add(building.CmdLock())
        self.add(building.CmdScript())
        self.add(building.CmdSetHome())
        self.add(building.CmdTag())

        # Batchprocessor commands
        self.add(batchprocess.CmdBatchCommands())
        self.add(batchprocess.CmdBatchCode())

########NEW FILE########
__FILENAME__ = cmdset_player
"""

This is the cmdset for Player (OOC) commands.  These are
stored on the Player object and should thus be able to handle getting
a Player object as caller rather than a Character.

Note - in order for session-rerouting (in MULTISESSION_MODE=2) to
function, all commands in this cmdset should use the self.msg()
command method rather than caller.msg().
"""

from src.commands.cmdset import CmdSet
from src.commands.default import help, comms, admin, system
from src.commands.default import building, player


class PlayerCmdSet(CmdSet):
    """
    Implements the player command set.
    """

    key = "DefaultPlayer"
    priority = -10

    def at_cmdset_creation(self):
        "Populates the cmdset"

        # Player-specific commands
        self.add(player.CmdOOCLook())
        self.add(player.CmdIC())
        self.add(player.CmdOOC())
        self.add(player.CmdCharCreate())
        #self.add(player.CmdSessions())
        self.add(player.CmdWho())
        self.add(player.CmdEncoding())
        self.add(player.CmdQuit())
        self.add(player.CmdPassword())
        self.add(player.CmdColorTest())
        self.add(player.CmdQuell())

        # testing
        self.add(building.CmdExamine())

        # Help command
        self.add(help.CmdHelp())

        # system commands
        self.add(system.CmdReload())
        self.add(system.CmdReset())
        self.add(system.CmdShutdown())
        self.add(system.CmdPy())

        # Admin commands
        self.add(admin.CmdDelPlayer())
        self.add(admin.CmdNewPassword())

        # Comm commands
        self.add(comms.CmdAddCom())
        self.add(comms.CmdDelCom())
        self.add(comms.CmdAllCom())
        self.add(comms.CmdChannels())
        self.add(comms.CmdCdestroy())
        self.add(comms.CmdChannelCreate())
        self.add(comms.CmdClock())
        self.add(comms.CmdCBoot())
        self.add(comms.CmdCemit())
        self.add(comms.CmdCWho())
        self.add(comms.CmdCdesc())
        self.add(comms.CmdPage())
        self.add(comms.CmdIRC2Chan())
        self.add(comms.CmdRSS2Chan())
        #self.add(comms.CmdIMC2Chan())
        #self.add(comms.CmdIMCInfo())
        #self.add(comms.CmdIMCTell())

########NEW FILE########
__FILENAME__ = cmdset_session
"""
This module stores session-level commands.
"""
from src.commands.cmdset import CmdSet
from src.commands.default import player

class SessionCmdSet(CmdSet):
    """
    Sets up the unlogged cmdset.
    """
    key = "DefaultSession"
    priority = -20

    def at_cmdset_creation(self):
        "Populate the cmdset"
        self.add(player.CmdSessions())

########NEW FILE########
__FILENAME__ = cmdset_unloggedin
"""
This module describes the unlogged state of the default game.
The setting STATE_UNLOGGED should be set to the python path
of the state instance in this module.
"""
from src.commands.cmdset import CmdSet
from src.commands.default import unloggedin


class UnloggedinCmdSet(CmdSet):
    """
    Sets up the unlogged cmdset.
    """
    key = "DefaultUnloggedin"
    priority = 0

    def at_cmdset_creation(self):
        "Populate the cmdset"
        self.add(unloggedin.CmdUnconnectedConnect())
        self.add(unloggedin.CmdUnconnectedCreate())
        self.add(unloggedin.CmdUnconnectedQuit())
        self.add(unloggedin.CmdUnconnectedLook())
        self.add(unloggedin.CmdUnconnectedHelp())

########NEW FILE########
__FILENAME__ = comms
"""
Comsystem command module.

Comm commands are OOC commands and intended to be made available to
the Player at all times (they go into the PlayerCmdSet). So we
make sure to homogenize self.caller to always be the player object
for easy handling.

"""
from django.conf import settings
from src.comms.models import ChannelDB, Msg
#from src.comms import irc, imc2, rss
from src.players.models import PlayerDB
from src.players import bots
from src.comms.channelhandler import CHANNELHANDLER
from src.utils import create, utils, prettytable, evtable
from src.utils.utils import make_iter
from src.commands.default.muxcommand import MuxCommand, MuxPlayerCommand

# limit symbol import for API
__all__ = ("CmdAddCom", "CmdDelCom", "CmdAllCom",
           "CmdChannels", "CmdCdestroy", "CmdCBoot", "CmdCemit",
           "CmdCWho", "CmdChannelCreate", "CmdClock", "CmdCdesc",
           "CmdPage", "CmdIRC2Chan", "CmdRSS2Chan")#, "CmdIMC2Chan", "CmdIMCInfo",
           #"CmdIMCTell")


def find_channel(caller, channelname, silent=False, noaliases=False):
    """
    Helper function for searching for a single channel with
    some error handling.
    """
    channels = ChannelDB.objects.channel_search(channelname)
    if not channels:
        if not noaliases:
            channels = [chan for chan in ChannelDB.objects.get_all_channels()
                        if channelname in chan.aliases.all()]
        if channels:
            return channels[0]
        if not silent:
            caller.msg("Channel '%s' not found." % channelname)
        return None
    elif len(channels) > 1:
        matches = ", ".join(["%s(%s)" % (chan.key, chan.id) for chan in channels])
        if not silent:
            caller.msg("Multiple channels match (be more specific): \n%s" % matches)
        return None
    return channels[0]


class CmdAddCom(MuxPlayerCommand):
    """
    add a channel alias and/or subscribe to a channel

    Usage:
       addcom [alias=] <channel>

    Joins a given channel. If alias is given, this will allow you to
    refer to the channel by this alias rather than the full channel
    name. Subsequent calls of this command can be used to add multiple
    aliases to an already joined channel.
    """

    key = "addcom"
    aliases = ["aliaschan", "chanalias"]
    help_category = "Comms"
    locks = "cmd:not pperm(channel_banned)"

    def func(self):
        "Implement the command"

        caller = self.caller
        args = self.args
        player = caller

        if not args:
            self.msg("Usage: addcom [alias =] channelname.")
            return

        if self.rhs:
            # rhs holds the channelname
            channelname = self.rhs
            alias = self.lhs
        else:
            channelname = self.args
            alias = None

        channel = find_channel(caller, channelname)
        if not channel:
            # we use the custom search method to handle errors.
            return

        # check permissions
        if not channel.access(player, 'listen'):
            self.msg("%s: You are not allowed to listen to this channel." % channel.key)
            return

        string = ""
        if not channel.has_connection(player):
            # we want to connect as well.
            if not channel.connect(player):
                # if this would have returned True, the player is connected
                self.msg("%s: You are not allowed to join this channel." % channel.key)
                return
            else:
                string += "You now listen to the channel %s. " % channel.key
        else:
            string += "You are already connected to channel %s." % channel.key

        if alias:
            # create a nick and add it to the caller.
            caller.nicks.add(alias, channel.key, category="channel")
            string += " You can now refer to the channel %s with the alias '%s'."
            self.msg(string % (channel.key, alias))
        else:
            string += " No alias added."
            self.msg(string)


class CmdDelCom(MuxPlayerCommand):
    """
    remove a channel alias and/or unsubscribe from channel

    Usage:
       delcom <alias or channel>

    If the full channel name is given, unsubscribe from the
    channel. If an alias is given, remove the alias but don't
    unsubscribe.
    """

    key = "delcom"
    aliases = ["delaliaschan, delchanalias"]
    help_category = "Comms"
    locks = "cmd:not perm(channel_banned)"

    def func(self):
        "Implementing the command. "

        caller = self.caller
        player = caller

        if not self.args:
            self.msg("Usage: delcom <alias or channel>")
            return
        ostring = self.args.lower()

        channel = find_channel(caller, ostring, silent=True, noaliases=True)
        if channel:
            # we have given a channel name - unsubscribe
            if not channel.has_connection(player):
                self.msg("You are not listening to that channel.")
                return
            chkey = channel.key.lower()
            # find all nicks linked to this channel and delete them
            for nick in [nick for nick in caller.nicks.get(category="channel")
                         if nick.strvalue.lower() == chkey]:
                nick.delete()
            disconnect = channel.disconnect(player)
            if disconnect:
                self.msg("You stop listening to channel '%s'. Eventual aliases were removed." % channel.key)
            return
        else:
            # we are removing a channel nick
            channame = caller.nicks.get(key=ostring, category="channel")
            channel = find_channel(caller, channame, silent=True)
            if not channel:
                self.msg("No channel with alias '%s' was found." % ostring)
            else:
                if caller.nicks.get(ostring, category="channel"):
                    caller.nicks.remove(ostring, category="channel")
                    self.msg("Your alias '%s' for channel %s was cleared." % (ostring, channel.key))
                else:
                    self.msg("You had no such alias defined for this channel.")


class CmdAllCom(MuxPlayerCommand):
    """
    perform admin operations on all channels

    Usage:
      allcom [on | off | who | destroy]

    Allows the user to universally turn off or on all channels they are on,
    as well as perform a 'who' for all channels they are on. Destroy deletes
    all channels that you control.

    Without argument, works like comlist.
    """

    key = "allcom"
    locks = "cmd: not pperm(channel_banned)"
    help_category = "Comms"

    def func(self):
        "Runs the function"

        caller = self.caller
        args = self.args
        if not args:
            caller.execute_cmd("@channels")
            self.msg("(Usage: allcom on | off | who | destroy)")
            return

        if args == "on":
            # get names of all channels available to listen to
            # and activate them all
            channels = [chan for chan in ChannelDB.objects.get_all_channels()
                        if chan.access(caller, 'listen')]
            for channel in channels:
                caller.execute_cmd("addcom %s" % channel.key)
        elif args == "off":
             #get names all subscribed channels and disconnect from them all
            channels = ChannelDB.objects.get_subscriptions(caller)
            for channel in channels:
                caller.execute_cmd("delcom %s" % channel.key)
        elif args == "destroy":
            # destroy all channels you control
            channels = [chan for chan in ChannelDB.objects.get_all_channels()
                        if chan.access(caller, 'control')]
            for channel in channels:
                caller.execute_cmd("@cdestroy %s" % channel.key)
        elif args == "who":
            # run a who, listing the subscribers on visible channels.
            string = "\n{CChannel subscriptions{n"
            channels = [chan for chan in ChannelDB.objects.get_all_channels()
                        if chan.access(caller, 'listen')]
            if not channels:
                string += "No channels."
            for channel in channels:
                string += "\n{w%s:{n\n" % channel.key
                subs = channel.subscriptions.all()
                if subs:
                    string += "  " + ", ".join([player.key for player in subs])
                else:
                    string += "  <None>"
            self.msg(string.strip())
        else:
            # wrong input
            self.msg("Usage: allcom on | off | who | clear")


class CmdChannels(MuxPlayerCommand):
    """
    list all channels available to you

    Usage:
      @channels
      @clist
      comlist

    Lists all channels available to you, whether you listen to them or not.
    Use 'comlist' to only view your current channel subscriptions.
    Use addcom/delcom to join and leave channels
    """
    key = "@channels"
    aliases = ["@clist", "channels", "comlist", "chanlist", "channellist", "all channels"]
    help_category = "Comms"
    locks = "cmd: not pperm(channel_banned)"

    def func(self):
        "Implement function"

        caller = self.caller

        # all channels we have available to listen to
        channels = [chan for chan in ChannelDB.objects.get_all_channels()
                    if chan.access(caller, 'listen')]
        #print channels
        if not channels:
            self.msg("No channels available.")
            return
        # all channel we are already subscribed to
        subs = ChannelDB.objects.get_subscriptions(caller)
        #print subs

        if self.cmdstring == "comlist":
            # just display the subscribed channels with no extra info
            comtable = evtable.EvTable("{wchannel{n", "{wmy aliases{n", "{wdescription{n", align="l", maxwidth=78)
            #comtable = prettytable.PrettyTable(["{wchannel", "{wmy aliases", "{wdescription"])
            for chan in subs:
                clower = chan.key.lower()
                nicks = caller.nicks.get(category="channel")
                comtable.add_row(*["%s%s" % (chan.key, chan.aliases.all() and
                                  "(%s)" % ",".join(chan.aliases.all()) or ""),
                                  "%s".join(nick for nick in make_iter(nicks)
                                  if nick and nick.lower() == clower),
                                  chan.db.desc])
            caller.msg("\n{wChannel subscriptions{n (use {w@channels{n to list all, {waddcom{n/{wdelcom{n to sub/unsub):{n\n%s" % comtable)
        else:
            # full listing (of channels caller is able to listen to)
            comtable = evtable.EvTable("{wsub{n", "{wchannel{n", "{wmy aliases{n", "{wlocks{n", "{wdescription{n", maxwidth=78)
            #comtable = prettytable.PrettyTable(["{wsub", "{wchannel", "{wmy aliases", "{wlocks", "{wdescription"])
            for chan in channels:
                clower = chan.key.lower()
                nicks = caller.nicks.get(category="channel")
                nicks = nicks or []
                comtable.add_row(*[chan in subs and "{gYes{n" or "{rNo{n",
                                  "%s%s" % (chan.key, chan.aliases.all() and
                                  "(%s)" % ",".join(chan.aliases.all()) or ""),
                                  "%s".join(nick for nick in make_iter(nicks)
                                  if nick.lower() == clower),
                                  str(chan.locks),
                                  chan.db.desc])
            caller.msg("\n{wAvailable channels{n (use {wcomlist{n,{waddcom{n and {wdelcom{n to manage subscriptions):\n%s" % comtable)


class CmdCdestroy(MuxPlayerCommand):
    """
    destroy a channel you created

    Usage:
      @cdestroy <channel>

    Destroys a channel that you control.
    """

    key = "@cdestroy"
    help_category = "Comms"
    locks = "cmd: not pperm(channel_banned)"

    def func(self):
        "Destroy objects cleanly."
        caller = self.caller

        if not self.args:
            self.msg("Usage: @cdestroy <channelname>")
            return
        channel = find_channel(caller, self.args)
        if not channel:
            self.msg("Could not find channel %s." % self.args)
            return
        if not channel.access(caller, 'control'):
            self.msg("You are not allowed to do that.")
            return

        message = "%s is being destroyed. Make sure to change your aliases." % channel
        msgobj = create.create_message(caller, message, channel)
        channel.msg(msgobj)
        channel.delete()
        CHANNELHANDLER.update()
        self.msg("Channel '%s' was destroyed." % channel)


class CmdCBoot(MuxPlayerCommand):
    """
    kick a player from a channel you control

    Usage:
       @cboot[/quiet] <channel> = <player> [:reason]

    Switches:
       quiet - don't notify the channel

    Kicks a player or object from a channel you control.

    """

    key = "@cboot"
    locks = "cmd: not pperm(channel_banned)"
    help_category = "Comms"

    def func(self):
        "implement the function"

        if not self.args or not self.rhs:
            string = "Usage: @cboot[/quiet] <channel> = <player> [:reason]"
            self.msg(string)
            return

        channel = find_channel(self.caller, self.lhs)
        if not channel:
            return
        reason = ""
        if ":" in self.rhs:
            playername, reason = self.rhs.rsplit(":", 1)
            searchstring = playername.lstrip('*')
        else:
            searchstring = self.rhs.lstrip('*')
        player = self.caller.search(searchstring, player=True)
        if not player:
            return
        if reason:
            reason = " (reason: %s)" % reason
        if not channel.access(self.caller, "control"):
            string = "You don't control this channel."
            self.msg(string)
            return
        if not player.dbobj in channel.db_subscriptions.all():
            string = "Player %s is not connected to channel %s." % (player.key, channel.key)
            self.msg(string)
            return
        if not "quiet" in self.switches:
            string = "%s boots %s from channel.%s" % (self.caller, player.key, reason)
            channel.msg(string)
        # find all player's nicks linked to this channel and delete them
        for nick in [nick for nick in
                     player.character.nicks.get(category="channel") or []
                     if nick.db_real.lower() == channel.key]:
            nick.delete()
        # disconnect player
        channel.disconnect(player)
        CHANNELHANDLER.update()


class CmdCemit(MuxPlayerCommand):
    """
    send an admin message to a channel you control

    Usage:
      @cemit[/switches] <channel> = <message>

    Switches:
      sendername - attach the sender's name before the message
      quiet - don't echo the message back to sender

    Allows the user to broadcast a message over a channel as long as
    they control it. It does not show the user's name unless they
    provide the /sendername switch.

    """

    key = "@cemit"
    aliases = ["@cmsg"]
    locks = "cmd: not pperm(channel_banned)"
    help_category = "Comms"

    def func(self):
        "Implement function"

        if not self.args or not self.rhs:
            string = "Usage: @cemit[/switches] <channel> = <message>"
            self.msg(string)
            return
        channel = find_channel(self.caller, self.lhs)
        if not channel:
            return
        if not channel.access(self.caller, "control"):
            string = "You don't control this channel."
            self.msg(string)
            return
        message = self.rhs
        if "sendername" in self.switches:
            message = "%s: %s" % (self.key, message)
        channel.msg(message)
        if not "quiet" in self.switches:
            string = "Sent to channel %s: %s" % (channel.key, message)
            self.msg(string)


class CmdCWho(MuxPlayerCommand):
    """
    show who is listening to a channel

    Usage:
      @cwho <channel>

    List who is connected to a given channel you have access to.
    """
    key = "@cwho"
    locks = "cmd: not pperm(channel_banned)"
    help_category = "Comms"

    def func(self):
        "implement function"

        if not self.args:
            string = "Usage: @cwho <channel>"
            self.msg(string)
            return

        channel = find_channel(self.caller, self.lhs)
        if not channel:
            return
        if not channel.access(self.caller, "listen"):
            string = "You can't access this channel."
            self.msg(string)
            return
        string = "\n{CChannel subscriptions{n"
        string += "\n{w%s:{n\n" % channel.key
        subs = channel.db_subscriptions.all()
        if subs:
            string += "  " + ", ".join([player.key for player in subs])
        else:
            string += "  <None>"
        self.msg(string.strip())


class CmdChannelCreate(MuxPlayerCommand):
    """
    create a new channel

    Usage:
     @ccreate <new channel>[;alias;alias...] = description

    Creates a new channel owned by you.
    """

    key = "@ccreate"
    aliases = "channelcreate"
    locks = "cmd:not pperm(channel_banned)"
    help_category = "Comms"

    def func(self):
        "Implement the command"

        caller = self.caller

        if not self.args:
            self.msg("Usage @ccreate <channelname>[;alias;alias..] = description")
            return

        description = ""

        if self.rhs:
            description = self.rhs
        lhs = self.lhs
        channame = lhs
        aliases = None
        if ';' in lhs:
            channame, aliases = [part.strip().lower()
                                 for part in lhs.split(';', 1) if part.strip()]
            aliases = [alias.strip().lower()
                       for alias in aliases.split(';') if alias.strip()]
        channel = ChannelDB.objects.channel_search(channame)
        if channel:
            self.msg("A channel with that name already exists.")
            return
        # Create and set the channel up
        lockstring = "send:all();listen:all();control:id(%s)" % caller.id
        new_chan = create.create_channel(channame,
                                         aliases,
                                         description,
                                         locks=lockstring)
        new_chan.connect(caller)
        self.msg("Created channel %s and connected to it." % new_chan.key)


class CmdClock(MuxPlayerCommand):
    """
    change channel locks of a channel you control

    Usage:
      @clock <channel> [= <lockstring>]

    Changes the lock access restrictions of a channel. If no
    lockstring was given, view the current lock definitions.
    """

    key = "@clock"
    locks = "cmd:not pperm(channel_banned)"
    aliases = ["@clock"]
    help_category = "Comms"

    def func(self):
        "run the function"

        if not self.args:
            string = "Usage: @clock channel [= lockstring]"
            self.msg(string)
            return

        channel = find_channel(self.caller, self.lhs)
        if not channel:
            return
        if not self.rhs:
            # no =, so just view the current locks
            string = "Current locks on %s:" % channel.key
            string = "%s\n %s" % (string, channel.locks)
            self.msg(string)
            return
        # we want to add/change a lock.
        if not channel.access(self.caller, "control"):
            string = "You don't control this channel."
            self.msg(string)
            return
        # Try to add the lock
        channel.locks.add(self.rhs)
        string = "Lock(s) applied. "
        string += "Current locks on %s:" % channel.key
        string = "%s\n %s" % (string, channel.locks)
        self.msg(string)


class CmdCdesc(MuxPlayerCommand):
    """
    describe a channel you control

    Usage:
      @cdesc <channel> = <description>

    Changes the description of the channel as shown in
    channel lists.
    """

    key = "@cdesc"
    locks = "cmd:not pperm(channel_banned)"
    help_category = "Comms"

    def func(self):
        "Implement command"

        caller = self.caller

        if not self.rhs:
            self.msg("Usage: @cdesc <channel> = <description>")
            return
        channel = find_channel(caller, self.lhs)
        if not channel:
            self.msg("Channel '%s' not found." % self.lhs)
            return
        #check permissions
        if not channel.access(caller, 'control'):
            self.msg("You cannot admin this channel.")
            return
        # set the description
        channel.db.desc = self.rhs
        channel.save()
        self.msg("Description of channel '%s' set to '%s'." % (channel.key,
                                                               self.rhs))


class CmdPage(MuxPlayerCommand):
    """
    send a private message to another player

    Usage:
      page[/switches] [<player>,<player>,... = <message>]
      tell        ''
      page <number>

    Switch:
      last - shows who you last messaged
      list - show your last <number> of tells/pages (default)

    Send a message to target user (if online). If no
    argument is given, you will get a list of your latest messages.
    """

    key = "page"
    aliases = ['tell']
    locks = "cmd:not pperm(page_banned)"
    help_category = "Comms"

    def func(self):
        "Implement function using the Msg methods"

        # this is a MuxPlayerCommand, which means caller will be a Player.
        caller = self.caller

        # get the messages we've sent (not to channels)
        pages_we_sent = Msg.objects.get_messages_by_sender(caller,
                                                 exclude_channel_messages=True)
        # get last messages we've got
        pages_we_got = Msg.objects.get_messages_by_receiver(caller)

        if 'last' in self.switches:
            if pages_we_sent:
                recv = ",".join(obj.key for obj in pages_we_sent[-1].receivers)
                self.msg("You last paged {c%s{n:%s" % (recv,
                                                    pages_we_sent[-1].message))
                return
            else:
                self.msg("You haven't paged anyone yet.")
                return

        if not self.args or not self.rhs:
            pages = pages_we_sent + pages_we_got
            pages.sort(lambda x, y: cmp(x.date_sent, y.date_sent))

            number = 5
            if self.args:
                try:
                    number = int(self.args)
                except ValueError:
                    self.msg("Usage: tell [<player> = msg]")
                    return

            if len(pages) > number:
                lastpages = pages[-number:]
            else:
                lastpages = pages
            template = "{w%s{n {c%s{n to {c%s{n: %s"
            lastpages = "\n ".join(template %
                                   (utils.datetime_format(page.date_sent),
                                    ",".join(obj.key for obj in page.senders),
                                    "{n,{c ".join([obj.name for obj in page.receivers]),
                                    page.message) for page in lastpages)

            if lastpages:
                string = "Your latest pages:\n %s" % lastpages
            else:
                string = "You haven't paged anyone yet."
            self.msg(string)
            return

        # We are sending. Build a list of targets

        if not self.lhs:
            # If there are no targets, then set the targets
            # to the last person we paged.
            if pages_we_sent:
                receivers = pages_we_sent[-1].receivers
            else:
                self.msg("Who do you want to page?")
                return
        else:
            receivers = self.lhslist

        recobjs = []
        for receiver in set(receivers):
            if isinstance(receiver, basestring):
                pobj = caller.search(receiver)
            elif hasattr(receiver, 'character'):
                pobj = receiver.character
            else:
                self.msg("Who do you want to page?")
                return
            if pobj:
                recobjs.append(pobj)
        if not recobjs:
            self.msg("Noone found to page.")
            return

        header = "{wPlayer{n {c%s{n {wpages:{n" % caller.key
        message = self.rhs

        # if message begins with a :, we assume it is a 'page-pose'
        if message.startswith(":"):
            message = "%s %s" % (caller.key, message.strip(':').strip())

        # create the persistent message object
        create.create_message(caller, message,
                              receivers=recobjs)

        # tell the players they got a message.
        received = []
        rstrings = []
        for pobj in recobjs:
            if not pobj.access(caller, 'msg'):
                rstrings.append("You are not allowed to page %s." % pobj)
                continue
            pobj.msg("%s %s" % (header, message))
            if hasattr(pobj, 'has_player') and not pobj.has_player:
                received.append("{C%s{n" % pobj.name)
                rstrings.append("%s is offline. They will see your message if they list their pages later." % received[-1])
            else:
                received.append("{c%s{n" % pobj.name)
        if rstrings:
            self.msg(rstrings="\n".join(rstrings))
        self.msg("You paged %s with: '%s'." % (", ".join(received), message))


class CmdIRC2Chan(MuxCommand):
    """
    link an evennia channel to an external IRC channel

    Usage:
      @irc2chan[/switches] <evennia_channel> = <ircnetwork> <port> <#irchannel> <botname>
      @irc2chan/list
      @irc2chan/delete botname|dbid

    Switches:
      /disconnect - this will delete the bot and remove the irc connection
                    to the channel.
      /remove     -                                 "
      /list       - show all irc<->evennia mappings

    Example:
      @irc2chan myircchan = irc.dalnet.net 6667 myevennia-channel evennia-bot

    This creates an IRC bot that connects to a given IRC network and channel.
    It will relay everything said in the evennia channel to the IRC channel and
    vice versa. The bot will automatically connect at server start, so this
    comman need only be given once. The /disconnect switch will permanently
    delete the bot. To only temporarily deactivate it, use the  {w@services{n
    command instead.
    """

    key = "@irc2chan"
    locks = "cmd:serversetting(IRC_ENABLED) and pperm(Immortals)"
    help_category = "Comms"

    def func(self):
        "Setup the irc-channel mapping"

        if not settings.IRC_ENABLED:
            string = """IRC is not enabled. You need to activate it in game/settings.py."""
            self.msg(string)
            return

        if 'list' in self.switches:
            # show all connections
            ircbots = [bot.typeclass for bot in PlayerDB.objects.filter(db_is_bot=True, username__startswith="ircbot-")]
            if ircbots:
                from src.utils.evtable import EvTable
                table = EvTable("{wdbid{n", "{wbotname{n", "{wev-channel{n", "{wirc-channel{n", maxwidth=78)
                for ircbot in ircbots:
                    ircinfo = "%s (%s:%s)" % (ircbot.db.irc_channel, ircbot.db.irc_network, ircbot.db.irc_port)
                    table.add_row(ircbot.id, ircbot.db.irc_botname, ircbot.db.ev_channel, ircinfo)
                self.caller.msg(table)
            else:
                self.msg("No irc bots found.")
            return


        if('disconnect' in self.switches or 'remove' in self.switches or
                                                    'delete' in self.switches):
            botname = "ircbot-%s" % self.lhs
            matches = PlayerDB.objects.filter(db_is_bot=True, db_key=botname)
            if not matches:
                # try dbref match
                matches = PlayerDB.objects.filter(db_is_bot=True, id=self.args.lstrip("#"))
            if matches:
                matches[0].delete()
                self.msg("IRC connection destroyed.")
            else:
                self.msg("IRC connection/bot could not be removed, does it exist?")
            return

        if not self.args or not self.rhs:
            string = "Usage: @irc2chan[/switches] <evennia_channel> = <ircnetwork> <port> <#irchannel> <botname>"
            self.msg(string)
            return

        channel = self.lhs
        self.rhs = self.rhs.replace('#', ' ') # to avoid Python comment issues
        try:
            irc_network, irc_port, irc_channel, irc_botname = \
                       [part.strip() for part in self.rhs.split(None, 3)]
            irc_channel = "#%s" % irc_channel
        except Exception:
            string = "IRC bot definition '%s' is not valid." % self.rhs
            self.msg(string)
            return

        botname = "ircbot-%s" % irc_botname

        # create a new bot
        bot = PlayerDB.objects.filter(username__iexact=botname)
        if bot:
            # re-use an existing bot
            bot = bot[0].typeclass
            if not bot.is_bot:
                self.msg("Player '%s' already exists and is not a bot." % botname)
                return
        else:
            bot = create.create_player(botname, None, None, typeclass=bots.IRCBot)
        bot.start(ev_channel=channel, irc_botname=irc_botname, irc_channel=irc_channel,
                  irc_network=irc_network, irc_port=irc_port)
        self.msg("Connection created. Starting IRC bot.")

# RSS connection
class CmdRSS2Chan(MuxCommand):
    """
    link an evennia channel to an external RSS feed

    Usage:
      @rss2chan[/switches] <evennia_channel> = <rss_url>

    Switches:
      /disconnect - this will stop the feed and remove the connection to the
                    channel.
      /remove     -                                 "
      /list       - show all rss->evennia mappings

    Example:
      @rss2chan rsschan = http://code.google.com/feeds/p/evennia/updates/basic

    This creates an RSS reader  that connects to a given RSS feed url. Updates
    will be echoed as a title and news link to the given channel. The rate of
    updating is set with the RSS_UPDATE_INTERVAL variable in settings (default
    is every 10 minutes).

    When disconnecting you need to supply both the channel and url again so as
    to identify the connection uniquely.
    """

    key = "@rss2chan"
    locks = "cmd:serversetting(RSS_ENABLED) and pperm(Immortals)"
    help_category = "Comms"

    def func(self):
        "Setup the rss-channel mapping"

        # checking we have all we need
        if not settings.RSS_ENABLED:
            string = """RSS is not enabled. You need to activate it in game/settings.py."""
            self.msg(string)
            return
        try:
            import feedparser
            feedparser   # to avoid checker error of not being used
        except ImportError:
            string = ("RSS requires python-feedparser (https://pypi.python.org/pypi/feedparser). "
                      "Install before continuing.")
            self.msg(string)
            return

        if 'list' in self.switches:
            # show all connections
            rssbots = [bot.typeclass for bot in PlayerDB.objects.filter(db_is_bot=True, username__startswith="rssbot-")]
            if rssbots:
                from src.utils.evtable import EvTable
                table = EvTable("{wdbid{n", "{wupdate rate{n", "{wev-channel", "{wRSS feed URL{n", border="cells", maxwidth=78)
                for rssbot in rssbots:
                    table.add_row(rssbot.id, rssbot.db.rss_rate, rssbot.db.ev_channel, rssbot.db.rss_url)
                self.caller.msg(table)
            else:
                self.msg("No rss bots found.")
            return

        if('disconnect' in self.switches or 'remove' in self.switches or
                                                    'delete' in self.switches):
            botname = "rssbot-%s" % self.lhs
            matches = PlayerDB.objects.filter(db_is_bot=True, db_key=botname)
            if not matches:
                # try dbref match
                matches = PlayerDB.objects.filter(db_is_bot=True, id=self.args.lstrip("#"))
            if matches:
                matches[0].delete()
                self.msg("RSS connection destroyed.")
            else:
                self.msg("RSS connection/bot could not be removed, does it exist?")
            return

        if not self.args or not self.rhs:
            string = "Usage: @rss2chan[/switches] <evennia_channel> = <rss url>"
            self.msg(string)
            return
        channel = self.lhs
        url = self.rhs

        botname = "rssbot-%s" % url
        # create a new bot
        bot = PlayerDB.objects.filter(username__iexact=botname)
        if bot:
            # re-use existing bot
            bot = bot[0].typeclass
            if not bot.is_bot:
                self.msg("Player '%s' already exists and is not a bot." % botname)
                return
        else:
            bot = create.create_player(botname, None, None, typeclass=bots.RSSBot)
        bot.start(ev_channel=channel, rss_url=url, rss_rate=10)
        self.msg("RSS reporter created. Fetching RSS.")


#class CmdIMC2Chan(MuxCommand):
#    """
#    link an evennia channel to an external IMC2 channel
#
#    Usage:
#      @imc2chan[/switches] <evennia_channel> = <imc2_channel>
#
#    Switches:
#      /disconnect - this clear the imc2 connection to the channel.
#      /remove     -                "
#      /list       - show all imc2<->evennia mappings
#
#    Example:
#      @imc2chan myimcchan = ievennia
#
#    Connect an existing evennia channel to a channel on an IMC2
#    network. The network contact information is defined in settings and
#    should already be accessed at this point. Use @imcchanlist to see
#    available IMC channels.
#
#    """
#
#    key = "@imc2chan"
#    locks = "cmd:serversetting(IMC2_ENABLED) and pperm(Immortals)"
#    help_category = "Comms"
#
#    def func(self):
#        "Setup the imc-channel mapping"
#
#        if not settings.IMC2_ENABLED:
#            string = """IMC is not enabled. You need to activate it in game/settings.py."""
#            self.msg(string)
#            return
#
#        if 'list' in self.switches:
#            # show all connections
#            connections = ExternalChannelConnection.objects.filter(db_external_key__startswith='imc2_')
#            if connections:
#                table = prettytable.PrettyTable(["Evennia channel", "IMC channel"])
#                for conn in connections:
#                    table.add_row([conn.channel.key, conn.external_config])
#                string = "{wIMC connections:{n\n%s" % table
#                self.msg(string)
#            else:
#                self.msg("No connections found.")
#            return
#
#        if not self.args or not self.rhs:
#            string = "Usage: @imc2chan[/switches] <evennia_channel> = <imc2_channel>"
#            self.msg(string)
#            return
#
#        channel = self.lhs
#        imc2_channel = self.rhs
#
#        if('disconnect' in self.switches or 'remove' in self.switches or
#                                                    'delete' in self.switches):
#            # we don't search for channels before this since we want
#            # to clear the link also if the channel no longer exists.
#            ok = imc2.delete_connection(channel, imc2_channel)
#            if not ok:
#                self.msg("IMC2 connection could not be removed, does it exist?")
#            else:
#                self.msg("IMC2 connection destroyed.")
#            return
#
#        # actually get the channel object
#        channel = find_channel(self.caller, channel)
#        if not channel:
#            return
#
#        ok = imc2.create_connection(channel, imc2_channel)
#        if not ok:
#            self.msg("The connection %s <-> %s  already exists." % (channel.key, imc2_channel))
#            return
#        self.msg("Created connection channel %s <-> IMC channel %s." % (channel.key, imc2_channel))
#
#
#class CmdIMCInfo(MuxCommand):
#    """
#    get various IMC2 information
#
#    Usage:
#      @imcinfo[/switches]
#      @imcchanlist - list imc2 channels
#      @imclist -     list connected muds
#      @imcwhois <playername> - whois info about a remote player
#
#    Switches for @imcinfo:
#      channels - as @imcchanlist (default)
#      games or muds - as @imclist
#      whois - as @imcwhois (requires an additional argument)
#      update - force an update of all lists
#
#    Shows lists of games or channels on the IMC2 network.
#    """
#
#    key = "@imcinfo"
#    aliases = ["@imcchanlist", "@imclist", "@imcwhois"]
#    locks = "cmd: serversetting(IMC2_ENABLED) and pperm(Wizards)"
#    help_category = "Comms"
#
#    def func(self):
#        "Run the command"
#
#        if not settings.IMC2_ENABLED:
#            string = """IMC is not enabled. You need to activate it in game/settings.py."""
#            self.msg(string)
#            return
#
#        if "update" in self.switches:
#            # update the lists
#            import time
#            from src.comms.imc2lib import imc2_packets as pck
#            from src.comms.imc2 import IMC2_MUDLIST, IMC2_CHANLIST, IMC2_CLIENT
#            # update connected muds
#            IMC2_CLIENT.send_packet(pck.IMC2PacketKeepAliveRequest())
#            # prune inactive muds
#            for name, mudinfo in IMC2_MUDLIST.mud_list.items():
#                if time.time() - mudinfo.last_updated > 3599:
#                    del IMC2_MUDLIST.mud_list[name]
#            # update channel list
#            IMC2_CLIENT.send_packet(pck.IMC2PacketIceRefresh())
#            self.msg("IMC2 lists were re-synced.")
#
#        elif("games" in self.switches or "muds" in self.switches
#                                            or self.cmdstring == "@imclist"):
#            # list muds
#            from src.comms.imc2 import IMC2_MUDLIST
#
#            muds = IMC2_MUDLIST.get_mud_list()
#            networks = set(mud.networkname for mud in muds)
#            string = ""
#            nmuds = 0
#            for network in networks:
#                table = prettytable.PrettyTable(["Name", "Url", "Host", "Port"])
#                for mud in (mud for mud in muds if mud.networkname == network):
#                    nmuds += 1
#                    table.add_row([mud.name, mud.url, mud.host, mud.port])
#                string += "\n{wMuds registered on %s:{n\n%s" % (network, table)
#            string += "\n %i Muds found." % nmuds
#            self.msg(string)
#
#        elif "whois" in self.switches or self.cmdstring == "@imcwhois":
#            # find out about a player
#            if not self.args:
#                self.msg("Usage: @imcwhois <playername>")
#                return
#            from src.comms.imc2 import IMC2_CLIENT
#            self.msg("Sending IMC whois request. If you receive no response, no matches were found.")
#            IMC2_CLIENT.msg_imc2(None,
#                                 from_obj=self.caller,
#                                 packet_type="imcwhois",
#                                 target=self.args)
#
#        elif(not self.switches or "channels" in self.switches or
#                                              self.cmdstring == "@imcchanlist"):
#            # show channels
#            from src.comms.imc2 import IMC2_CHANLIST, IMC2_CLIENT
#
#            channels = IMC2_CHANLIST.get_channel_list()
#            string = ""
#            nchans = 0
#            table = prettytable.PrettyTable(["Full name", "Name", "Owner", "Perm", "Policy"])
#            for chan in channels:
#                nchans += 1
#                table.add_row([chan.name, chan.localname, chan.owner,
#                               chan.level, chan.policy])
#            string += "\n{wChannels on %s:{n\n%s" % (IMC2_CLIENT.factory.network, table)
#            string += "\n%i Channels found." % nchans
#            self.msg(string)
#        else:
#            # no valid inputs
#            string = "Usage: imcinfo|imcchanlist|imclist"
#            self.msg(string)
#
#
## unclear if this is working ...
#class CmdIMCTell(MuxCommand):
#    """
#    send a page to a remote IMC player
#
#    Usage:
#      imctell User@MUD = <msg>
#      imcpage      "
#
#    Sends a page to a user on a remote MUD, connected
#    over IMC2.
#    """
#
#    key = "imctell"
#    aliases = ["imcpage", "imc2tell", "imc2page"]
#    locks = "cmd: serversetting(IMC2_ENABLED)"
#    help_category = "Comms"
#
#    def func(self):
#        "Send tell across IMC"
#
#        if not settings.IMC2_ENABLED:
#            string = """IMC is not enabled. You need to activate it in game/settings.py."""
#            self.msg(string)
#            return
#
#        from src.comms.imc2 import IMC2_CLIENT
#
#        if not self.args or not '@' in self.lhs or not self.rhs:
#            string = "Usage: imctell User@Mud = <msg>"
#            self.msg(string)
#            return
#        target, destination = self.lhs.split("@", 1)
#        message = self.rhs.strip()
#        data = {"target":target, "destination":destination}
#
#        # send to imc2
#        IMC2_CLIENT.msg_imc2(message, from_obj=self.caller, packet_type="imctell", **data)
#
#        self.msg("You paged {c%s@%s{n (over IMC): '%s'." % (target, destination, message))
#
#

########NEW FILE########
__FILENAME__ = general
"""
General Character commands usually availabe to all characters
"""
from django.conf import settings
from src.utils import utils, prettytable
from src.commands.default.muxcommand import MuxCommand


# limit symbol import for API
__all__ = ("CmdHome", "CmdLook", "CmdNick",
           "CmdInventory", "CmdGet", "CmdDrop", "CmdGive",
           "CmdSay", "CmdPose", "CmdAccess")

AT_SEARCH_RESULT = utils.variable_from_module(*settings.SEARCH_AT_RESULT.rsplit('.', 1))


class CmdHome(MuxCommand):
    """
    move to your character's home location

    Usage:
      home

    Teleports you to your home location.
    """

    key = "home"
    locks = "cmd:perm(home) or perm(Builders)"

    def func(self):
        "Implement the command"
        caller = self.caller
        home = caller.home
        if not home:
            caller.msg("You have no home!")
        elif home == caller.location:
            caller.msg("You are already home!")
        else:
            caller.move_to(home)
            caller.msg("There's no place like home ...")


class CmdLook(MuxCommand):
    """
    look at location or object

    Usage:
      look
      look <obj>
      look *<player>

    Observes your location or objects in your vicinity.
    """
    key = "look"
    aliases = ["l", "ls"]
    locks = "cmd:all()"
    arg_regex = r"\s.*?|$"

    def func(self):
        """
        Handle the looking.
        """
        caller = self.caller
        args = self.args

        if args:
            # Use search to handle duplicate/nonexistant results.
            looking_at_obj = caller.search(args, use_nicks=True)
            if not looking_at_obj:
                return
        else:
            looking_at_obj = caller.location
            if not looking_at_obj:
                caller.msg("You have no location to look at!")
                return

        if not hasattr(looking_at_obj, 'return_appearance'):
            # this is likely due to us having a player instead
            looking_at_obj = looking_at_obj.character
        if not looking_at_obj.access(caller, "view"):
            caller.msg("Could not find '%s'." % args)
            return
        # get object's appearance
        caller.msg(looking_at_obj.return_appearance(caller))
        # the object's at_desc() method.
        looking_at_obj.at_desc(looker=caller)


class CmdNick(MuxCommand):
    """
    define a personal alias/nick

    Usage:
      nick[/switches] <nickname> = [<string>]
      alias             ''

    Switches:
      object   - alias an object
      player   - alias a player
      clearall - clear all your aliases
      list     - show all defined aliases (also "nicks" works)

    Examples:
      nick hi = say Hello, I'm Sarah!
      nick/object tom = the tall man

    A 'nick' is a personal shortcut you create for your own use. When
    you enter the nick, the alternative string will be sent instead.
    The switches control in which situations the substitution will
    happen. The default is that it will happen when you enter a
    command. The 'object' and 'player' nick-types kick in only when
    you use commands that requires an object or player as a target -
    you can then use the nick to refer to them.

    Note that no objects are actually renamed or changed by this
    command - the nick is only available to you. If you want to
    permanently add keywords to an object for everyone to use, you
    need build privileges and to use the @alias command.
    """
    key = "nick"
    aliases = ["nickname", "nicks", "@nick", "alias"]
    locks = "cmd:all()"

    def func(self):
        "Create the nickname"

        caller = self.caller
        switches = self.switches
        nicks = caller.nicks.get(return_obj=True)

        if 'list' in switches:
            table = prettytable.PrettyTable(["{wNickType",
                                             "{wNickname",
                                             "{wTranslates-to"])
            for nick in utils.make_iter(nicks):
                table.add_row([nick.db_category, nick.db_key, nick.db_strvalue])
            string = "{wDefined Nicks:{n\n%s" % table
            caller.msg(string)
            return
        if 'clearall' in switches:
            caller.nicks.clear()
            caller.msg("Cleared all aliases.")
            return
        if not self.args or not self.lhs:
            caller.msg("Usage: nick[/switches] nickname = [realname]")
            return
        nick = self.lhs
        real = self.rhs

        if real == nick:
            caller.msg("No point in setting nick same as the string to replace...")
            return

        # check so we have a suitable nick type
        if not any(True for switch in switches if switch in ("object", "player", "inputline")):
            switches = ["inputline"]
        string = ""
        for switch in switches:
            oldnick = caller.nicks.get(key=nick, category=switch)
            #oldnick = Nick.objects.filter(db_obj=caller.dbobj, db_nick__iexact=nick, db_type__iexact=switch)
            if not real:
                # removal of nick
                if oldnick:
                    # clear the alias
                    string += "\nNick '%s' (= '%s') was cleared." % (nick, oldnick)
                    caller.nicks.delete(nick, category=switch)
                else:
                    string += "\nNo nick '%s' found, so it could not be removed." % nick
            else:
                # creating new nick
                if oldnick:
                    string += "\nNick %s changed from '%s' to '%s'." % (nick, oldnick, real)
                else:
                    string += "\nNick set: '%s' = '%s'." % (nick, real)
                caller.nicks.add(nick, real, category=switch)
        caller.msg(string)


class CmdInventory(MuxCommand):
    """
    view inventory

    Usage:
      inventory
      inv

    Shows your inventory.
    """
    key = "inventory"
    aliases = ["inv", "i"]
    locks = "cmd:all()"

    def func(self):
        "check inventory"
        items = self.caller.contents
        if not items:
            string = "You are not carrying anything."
        else:
            table = prettytable.PrettyTable(["name", "desc"])
            table.header = False
            table.border = False
            for item in items:
                table.add_row(["{C%s{n" % item.name, item.db.desc and item.db.desc or ""])
            string = "{wYou are carrying:\n%s" % table
        self.caller.msg(string)


class CmdGet(MuxCommand):
    """
    pick up something

    Usage:
      get <obj>

    Picks up an object from your location and puts it in
    your inventory.
    """
    key = "get"
    aliases = "grab"
    locks = "cmd:all()"

    def func(self):
        "implements the command."

        caller = self.caller

        if not self.args:
            caller.msg("Get what?")
            return
        #print "general/get:", caller, caller.location, self.args, caller.location.contents
        obj = caller.search(self.args, location=caller.location)
        if not obj:
            return
        if caller == obj:
            caller.msg("You can't get yourself.")
            return
        #print obj, obj.location, caller, caller==obj.location
        if caller == obj.location:
            caller.msg("You already hold that.")
            return
        if not obj.access(caller, 'get'):
            if obj.db.get_err_msg:
                caller.msg(obj.db.get_err_msg)
            else:
                caller.msg("You can't get that.")
            return

        obj.move_to(caller, quiet=True)
        caller.msg("You pick up %s." % obj.name)
        caller.location.msg_contents("%s picks up %s." %
                                        (caller.name,
                                         obj.name),
                                         exclude=caller)
        # calling hook method
        obj.at_get(caller)


class CmdDrop(MuxCommand):
    """
    drop something

    Usage:
      drop <obj>

    Lets you drop an object from your inventory into the
    location you are currently in.
    """

    key = "drop"
    locks = "cmd:all()"

    def func(self):
        "Implement command"

        caller = self.caller
        if not self.args:
            caller.msg("Drop what?")
            return

        # Because the DROP command by definition looks for items
        # in inventory, call the search function using location = caller
        results = caller.search(self.args, location=caller, quiet=True)

        # now we send it into the error handler (this will output consistent
        # error messages if there are problems).
        obj = AT_SEARCH_RESULT(caller, self.args, results, False,
                              nofound_string="You aren't carrying %s." % self.args,
                              multimatch_string="You carry more than one %s:" % self.args)
        if not obj:
            return

        obj.move_to(caller.location, quiet=True)
        caller.msg("You drop %s." % (obj.name,))
        caller.location.msg_contents("%s drops %s." %
                                         (caller.name, obj.name),
                                         exclude=caller)
        # Call the object script's at_drop() method.
        obj.at_drop(caller)


class CmdGive(MuxCommand):
    """
    give away something to someone

    Usage:
      give <inventory obj> = <target>

    Gives an items from your inventory to another character,
    placing it in their inventory.
    """
    key = "give"
    locks = "cmd:all()"

    def func(self):
        "Implement give"

        caller = self.caller
        if not self.args or not self.rhs:
            caller.msg("Usage: give <inventory object> = <target>")
            return
        to_give = caller.search(self.lhs)
        target = caller.search(self.rhs)
        if not (to_give and target):
            return
        if target == caller:
            caller.msg("You keep %s to yourself." % to_give.key)
            return
        if not to_give.location == caller:
            caller.msg("You are not holding %s." % to_give.key)
            return
        # give object
        to_give.location = target
        caller.msg("You give %s to %s." % (to_give.key, target.key))
        target.msg("%s gives you %s." % (caller.key, to_give.key))


class CmdSay(MuxCommand):
    """
    speak as your character

    Usage:
      say <message>

    Talk to those in your current location.
    """

    key = "say"
    aliases = ['"', "'"]
    locks = "cmd:all()"

    def func(self):
        "Run the say command"

        caller = self.caller

        if not self.args:
            caller.msg("Say what?")
            return

        speech = self.args

        # calling the speech hook on the location
        speech = caller.location.at_say(caller, speech)

        # Feedback for the object doing the talking.
        caller.msg('You say, "%s{n"' % speech)

        # Build the string to emit to neighbors.
        emit_string = '{c%s{n says, "%s{n"' % (caller.name,
                                               speech)
        caller.location.msg_contents(emit_string,
                                     exclude=caller)


class CmdPose(MuxCommand):
    """
    strike a pose

    Usage:
      pose <pose text>
      pose's <pose text>

    Example:
      pose is standing by the wall, smiling.
       -> others will see:
      Tom is standing by the wall, smiling.

    Describe an action being taken. The pose text will
    automatically begin with your name.
    """
    key = "pose"
    aliases = [":", "emote"]
    locks = "cmd:all()"

    def parse(self):
        """
        Custom parse the cases where the emote
        starts with some special letter, such
        as 's, at which we don't want to separate
        the caller's name and the emote with a
        space.
        """
        args = self.args
        if args and not args[0] in ["'", ",", ":"]:
            args = " %s" % args.strip()
        self.args = args

    def func(self):
        "Hook function"
        if not self.args:
            msg = "What do you want to do?"
            self.caller.msg(msg)
        else:
            msg = "%s%s" % (self.caller.name, self.args)
            self.caller.location.msg_contents(msg)


class CmdAccess(MuxCommand):
    """
    show your current game access

    Usage:
      access

    This command shows you the permission hierarchy and
    which permission groups you are a member of.
    """
    key = "access"
    aliases = ["groups", "hierarchy"]
    locks = "cmd:all()"

    def func(self):
        "Load the permission groups"

        caller = self.caller
        hierarchy_full = settings.PERMISSION_HIERARCHY
        string = "\n{wPermission Hierarchy{n (climbing):\n %s" % ", ".join(hierarchy_full)
        #hierarchy = [p.lower() for p in hierarchy_full]

        if self.caller.player.is_superuser:
            cperms = "<Superuser>"
            pperms = "<Superuser>"
        else:
            cperms = ", ".join(caller.permissions.all())
            pperms = ", ".join(caller.player.permissions.all())

        string += "\n{wYour access{n:"
        string += "\nCharacter {c%s{n: %s" % (caller.key, cperms)
        if hasattr(caller, 'player'):
            string += "\nPlayer {c%s{n: %s" % (caller.player.key, pperms)
        caller.msg(string)

########NEW FILE########
__FILENAME__ = help
"""
The help command. The basic idea is that help texts for commands
are best written by those that write the commands - the admins. So
command-help is all auto-loaded and searched from the current command
set. The normal, database-tied help system is used for collaborative
creation of other help topics such as RP help or game-world aides.
"""

from collections import defaultdict
from src.utils.utils import fill, dedent
from src.commands.command import Command
from src.help.models import HelpEntry
from src.utils import create
from src.utils.utils import string_suggestions
from src.commands.default.muxcommand import MuxCommand

# limit symbol import for API
__all__ = ("CmdHelp", "CmdSetHelp")


SEP = "{C" + "-" * 78 + "{n"


def format_help_entry(title, help_text, aliases=None, suggested=None):
    """
    This visually formats the help entry.
    """
    string = SEP + "\n"
    if title:
        string += "{CHelp topic for {w%s{n" % title
    if aliases:
        string += " {C(aliases: {w%s{n{C){n" % (", ".join(aliases))
    if help_text:
        string += "\n%s" % dedent(help_text.rstrip())
    if suggested:
        string += "\n\n{CSuggested:{n "
        string += "{w%s{n" % fill(", ".join(suggested))
    string.strip()
    string += "\n" + SEP
    return string


def format_help_list(hdict_cmds, hdict_db):
    """
    Output a category-ordered list. The input are the
    pre-loaded help files for commands and database-helpfiles
    resectively.
    """
    string = ""
    if hdict_cmds and any(hdict_cmds.values()):
        string += "\n" + SEP + "\n   {CCommand help entries{n\n" + SEP
        for category in sorted(hdict_cmds.keys()):
            string += "\n  {w%s{n:\n" % (str(category).title())
            string += "{G" + fill(", ".join(sorted(hdict_cmds[category]))) + "{n"
    if hdict_db and any(hdict_db.values()):
        string += "\n\n" + SEP + "\n\r  {COther help entries{n\n" + SEP
        for category in sorted(hdict_db.keys()):
            string += "\n\r  {w%s{n:\n" % (str(category).title())
            string += "{G" + fill(", ".join(sorted([str(topic) for topic in hdict_db[category]]))) + "{n"
    return string


class CmdHelp(Command):
    """
    view help or a list of topics

    Usage:
      help <topic or command>
      help list
      help all

    This will search for help on commands and other
    topics related to the game.
    """
    key = "help"
    locks = "cmd:all()"

    # this is a special cmdhandler flag that makes the cmdhandler also pack
    # the current cmdset with the call to self.func().
    return_cmdset = True

    def parse(self):
        """
        input is a string containing the command or topic to match.
        """
        self.original_args = self.args.strip()
        self.args = self.args.strip().lower()

    def func(self):
        """
        Run the dynamic help entry creator.
        """
        query, cmdset = self.args, self.cmdset
        caller = self.caller

        suggestion_cutoff = 0.6
        suggestion_maxnum = 5

        if not query:
            query = "all"

        # removing doublets in cmdset, caused by cmdhandler
        # having to allow doublet commands to manage exits etc.
        cmdset.make_unique(caller)

        # retrieve all available commands and database topics
        all_cmds = [cmd for cmd in cmdset if cmd.auto_help and cmd.access(caller)]
        all_topics = [topic for topic in HelpEntry.objects.all() if topic.access(caller, 'view', default=True)]
        all_categories = list(set([cmd.help_category.lower() for cmd in all_cmds] + [topic.help_category.lower() for topic in all_topics]))

        if query in ("list", "all"):
            # we want to list all available help entries, grouped by category
            hdict_cmd = defaultdict(list)
            hdict_topic = defaultdict(list)
            # create the dictionaries {category:[topic, topic ...]} required by format_help_list
            [hdict_cmd[cmd.help_category].append(cmd.key) for cmd in all_cmds]
            [hdict_topic[topic.help_category].append(topic.key) for topic in all_topics]
            # report back
            self.msg(format_help_list(hdict_cmd, hdict_topic))
            return

        # Try to access a particular command

        # build vocabulary of suggestions and rate them by string similarity.
        vocabulary = [cmd.key for cmd in all_cmds if cmd] + [topic.key for topic in all_topics] + all_categories
        [vocabulary.extend(cmd.aliases) for cmd in all_cmds]
        suggestions = [sugg for sugg in string_suggestions(query, set(vocabulary), cutoff=suggestion_cutoff, maxnum=suggestion_maxnum)
                       if sugg != query]
        if not suggestions:
            suggestions = [sugg for sugg in vocabulary if sugg != query and sugg.startswith(query)]

        # try an exact command auto-help match
        match = [cmd for cmd in all_cmds if cmd == query]
        if len(match) == 1:
            self.msg(format_help_entry(match[0].key,
                     match[0].__doc__,
                     aliases=match[0].aliases,
                     suggested=suggestions))
            return

        # try an exact database help entry match
        match = list(HelpEntry.objects.find_topicmatch(query, exact=True))
        if len(match) == 1:
            self.msg(format_help_entry(match[0].key,
                     match[0].entrytext,
                     suggested=suggestions))
            return

        # try to see if a category name was entered
        if query in all_categories:
            self.msg(format_help_list({query:[cmd.key for cmd in all_cmds if cmd.help_category==query]},
                                        {query:[topic.key for topic in all_topics if topic.help_category==query]}))
            return

        # no exact matches found. Just give suggestions.
        self.msg(format_help_entry("", "No help entry found for '%s'" % query, None, suggested=suggestions))


class CmdSetHelp(MuxCommand):
    """
    edit the help database

    Usage:
      @help[/switches] <topic>[,category[,locks]] = <text>

    Switches:
      add    - add or replace a new topic with text.
      append - add text to the end of topic with a newline between.
      merge  - As append, but don't add a newline between the old
               text and the appended text.
      delete - remove help topic.
      force  - (used with add) create help topic also if the topic
               already exists.

    Examples:
      @sethelp/add throw = This throws something at ...
      @sethelp/append pickpocketing,Thievery = This steals ...
      @sethelp/append pickpocketing, ,attr(is_thief) = This steals ...

    This command manipulates the help database. A help entry can be created,
    appended/merged to and deleted. If you don't assign a category, the
    "General" category will be used. If no lockstring is specified, default
    is to let everyone read the help file.

    """
    key = "@help"
    aliases = "@sethelp"
    locks = "cmd:perm(PlayerHelpers)"
    help_category = "Building"

    def func(self):
        "Implement the function"

        switches = self.switches
        lhslist = self.lhslist

        if not self.args:
            self.msg("Usage: @sethelp/[add|del|append|merge] <topic>[,category[,locks,..] = <text>")
            return

        topicstr = ""
        category = "General"
        lockstring = "view:all()"
        try:
            topicstr = lhslist[0]
            category = lhslist[1]
            lockstring = ",".join(lhslist[2:])
        except Exception:
            pass

        if not topicstr:
            self.msg("You have to define a topic!")
            return
        # check if we have an old entry with the same name
        try:
            old_entry = HelpEntry.objects.get(db_key__iexact=topicstr)
        except Exception:
            old_entry = None

        if 'append' in switches or "merge" in switches:
            # merge/append operations
            if not old_entry:
                self.msg("Could not find topic '%s'. You must give an exact name." % topicstr)
                return
            if not self.rhs:
                self.msg("You must supply text to append/merge.")
                return
            if 'merge' in switches:
                old_entry.entrytext += " " + self.rhs
            else:
                old_entry.entrytext += "\n\n%s" % self.rhs
            self.msg("Entry updated:\n%s" % old_entry.entrytext)
            return
        if 'delete' in switches or 'del' in switches:
            # delete the help entry
            if not old_entry:
                self.msg("Could not find topic '%s'" % topicstr)
                return
            old_entry.delete()
            self.msg("Deleted help entry '%s'." % topicstr)
            return

        # at this point it means we want to add a new help entry.
        if not self.rhs:
            self.msg("You must supply a help text to add.")
            return
        if old_entry:
            if 'for' in switches or 'force' in switches:
                # overwrite old entry
                old_entry.key = topicstr
                old_entry.entrytext = self.rhs
                old_entry.help_category = category
                old_entry.locks.clear()
                old_entry.locks.add(lockstring)
                old_entry.save()
                self.msg("Overwrote the old topic '%s' with a new one." % topicstr)
            else:
                self.msg("Topic '%s' already exists. Use /force to overwrite or /append or /merge to add text to it." % topicstr)
        else:
            # no old entry. Create a new one.
            new_entry = create.create_help_entry(topicstr,
                                                 self.rhs, category, lockstring)
            if new_entry:
                self.msg("Topic '%s' was successfully created." % topicstr)
            else:
                self.msg("Error when creating topic '%s'! Maybe it already exists?" % topicstr)

########NEW FILE########
__FILENAME__ = muxcommand
"""
The command template for the default MUX-style command set. There
is also an Player/OOC version that makes sure caller is a Player object.
"""

from src.utils import utils
from src.commands.command import Command

# limit symbol import for API
__all__ = ("MuxCommand", "MuxPlayerCommand")

class MuxCommand(Command):
    """
    This sets up the basis for a MUX command. The idea
    is tkhat most other Mux-related commands should just
    inherit from this and don't have to implement much
    parsing of their own unless they do something particularly
    advanced.

    Note that the class's __doc__ string (this text) is
    used by Evennia to create the automatic help entry for
    the command, so make sure to document consistently here.
    """
    def has_perm(self, srcobj):
        """
        This is called by the cmdhandler to determine
        if srcobj is allowed to execute this command.
        We just show it here for completeness - we
        are satisfied using the default check in Command.
        """
        return super(MuxCommand, self).has_perm(srcobj)

    def at_pre_cmd(self):
        """
        This hook is called before self.parse() on all commands
        """
        pass

    def at_post_cmd(self):
        """
        This hook is called after the command has finished executing
        (after self.func()).
        """
        pass

    def parse(self):
        """
        This method is called by the cmdhandler once the command name
        has been identified. It creates a new set of member variables
        that can be later accessed from self.func() (see below)

        The following variables are available for our use when entering this
        method (from the command definition, and assigned on the fly by the
        cmdhandler):
           self.key - the name of this command ('look')
           self.aliases - the aliases of this cmd ('l')
           self.permissions - permission string for this command
           self.help_category - overall category of command

           self.caller - the object calling this command
           self.cmdstring - the actual command name used to call this
                            (this allows you to know which alias was used,
                             for example)
           self.args - the raw input; everything following self.cmdstring.
           self.cmdset - the cmdset from which this command was picked. Not
                         often used (useful for commands like 'help' or to
                         list all available commands etc)
           self.obj - the object on which this command was defined. It is often
                         the same as self.caller.

        A MUX command has the following possible syntax:

          name[ with several words][/switch[/switch..]] arg1[,arg2,...] [[=|,] arg[,..]]

        The 'name[ with several words]' part is already dealt with by the
        cmdhandler at this point, and stored in self.cmdname (we don't use
        it here). The rest of the command is stored in self.args, which can
        start with the switch indicator /.

        This parser breaks self.args into its constituents and stores them in the
        following variables:
          self.switches = [list of /switches (without the /)]
          self.raw = This is the raw argument input, including switches
          self.args = This is re-defined to be everything *except* the switches
          self.lhs = Everything to the left of = (lhs:'left-hand side'). If
                     no = is found, this is identical to self.args.
          self.rhs: Everything to the right of = (rhs:'right-hand side').
                    If no '=' is found, this is None.
          self.lhslist - [self.lhs split into a list by comma]
          self.rhslist - [list of self.rhs split into a list by comma]
          self.arglist = [list of space-separated args (stripped, including '=' if it exists)]

          All args and list members are stripped of excess whitespace around the
          strings, but case is preserved.
        """
        raw = self.args
        args = raw.strip()

        # split out switches
        switches = []
        if args and len(args) > 1 and args[0] == "/":
            # we have a switch, or a set of switches. These end with a space.
            #print "'%s'" % args
            switches = args[1:].split(None, 1)
            if len(switches) > 1:
                switches, args = switches
                switches = switches.split('/')
            else:
                args = ""
                switches = switches[0].split('/')
        arglist = [arg.strip() for arg in args.split()]

        # check for arg1, arg2, ... = argA, argB, ... constructs
        lhs, rhs = args, None
        lhslist, rhslist = [arg.strip() for arg in args.split(',')], []
        if args and '=' in args:
            lhs, rhs = [arg.strip() for arg in args.split('=', 1)]
            lhslist = [arg.strip() for arg in lhs.split(',')]
            rhslist = [arg.strip() for arg in rhs.split(',')]

        # save to object properties:
        self.raw = raw
        self.switches = switches
        self.args = args.strip()
        self.arglist = arglist
        self.lhs = lhs
        self.lhslist = lhslist
        self.rhs = rhs
        self.rhslist = rhslist

    def func(self):
        """
        This is the hook function that actually does all the work. It is called
         by the cmdhandler right after self.parser() finishes, and so has access
         to all the variables defined therein.
        """
        # a simple test command to show the available properties
        string = "-" * 50
        string += "\n{w%s{n - Command variables from evennia:\n" % self.key
        string += "-" * 50
        string += "\nname of cmd (self.key): {w%s{n\n" % self.key
        string += "cmd aliases (self.aliases): {w%s{n\n" % self.aliases
        string += "cmd locks (self.locks): {w%s{n\n" % self.locks
        string += "help category (self.help_category): {w%s{n\n" % self.help_category
        string += "object calling (self.caller): {w%s{n\n" % self.caller
        string += "object storing cmdset (self.obj): {w%s{n\n" % self.obj
        string += "command string given (self.cmdstring): {w%s{n\n" % self.cmdstring
        # show cmdset.key instead of cmdset to shorten output
        string += utils.fill("current cmdset (self.cmdset): {w%s{n\n" % self.cmdset)


        string += "\n" + "-" * 50
        string +=  "\nVariables from MuxCommand baseclass\n"
        string += "-" * 50
        string += "\nraw argument (self.raw): {w%s{n \n" % self.raw
        string += "cmd args (self.args): {w%s{n\n" % self.args
        string += "cmd switches (self.switches): {w%s{n\n" % self.switches
        string += "space-separated arg list (self.arglist): {w%s{n\n" % self.arglist
        string += "lhs, left-hand side of '=' (self.lhs): {w%s{n\n" % self.lhs
        string += "lhs, comma separated (self.lhslist): {w%s{n\n" % self.lhslist
        string += "rhs, right-hand side of '=' (self.rhs): {w%s{n\n" % self.rhs
        string += "rhs, comma separated (self.rhslist): {w%s{n\n" % self.rhslist
        string += "-" * 50
        self.caller.msg(string)

class MuxPlayerCommand(MuxCommand):
    """
    This is an on-Player version of the MuxCommand. Since these commands sit
    on Players rather than on Characters/Objects, we need to check
    this in the parser.

    Player commands are available also when puppeting a Character, it's
    just that they are applied with a lower priority and are always
    available, also when disconnected from a character (i.e. "ooc").

    This class makes sure that caller is always a Player object, while
    creating a new property "character" that is set only if a
    character is actually attached to this Player and Session.
    """
    def parse(self):
        """
        We run the parent parser as usual, then fix the result
        """
        super(MuxPlayerCommand, self).parse()

        if utils.inherits_from(self.caller, "src.objects.objects.Object"):
            # caller is an Object/Character
            self.character = self.caller
            self.caller = self.caller.player
        elif utils.inherits_from(self.caller, "src.players.players.Player"):
            # caller was already a Player
            self.character = self.caller.get_puppet(self.sessid)
        else:
            self.character = None

########NEW FILE########
__FILENAME__ = player
"""
Player (OOC) commands. These are stored on the Player object
and self.caller is thus always a Player, not an Object/Character.

These commands go in the PlayerCmdset and are accessible also
when puppeting a Character (although with lower priority)

These commands use the MuxCommandOOC parent that makes sure
to setup caller correctly. They use self.player to make sure
to always use the player object rather than self.caller (which
change depending on the level you are calling from)
The property self.character can be used to
access the character when these commands are triggered with
a connected character (such as the case of the @ooc command), it
is None if we are OOC.

Note that under MULTISESSION_MODE=2, Player- commands should use
self.msg() and similar methods to reroute returns to the correct
method. Otherwise all text will be returned to all connected sessions.

"""
import time
from django.conf import settings
from src.server.sessionhandler import SESSIONS
from src.commands.default.muxcommand import MuxPlayerCommand
from src.utils import utils, create, search, prettytable

from settings import MAX_NR_CHARACTERS, MULTISESSION_MODE
# limit symbol import for API
__all__ = ("CmdOOCLook", "CmdIC", "CmdOOC", "CmdPassword", "CmdQuit",
           "CmdCharCreate", "CmdEncoding", "CmdSessions", "CmdWho",
           "CmdColorTest", "CmdQuell")

# force max nr chars to 1 if mode is 0 or 1
MAX_NR_CHARACTERS = MULTISESSION_MODE < 2 and 1 or MAX_NR_CHARACTERS
BASE_PLAYER_TYPECLASS = settings.BASE_PLAYER_TYPECLASS

PERMISSION_HIERARCHY = settings.PERMISSION_HIERARCHY
PERMISSION_HIERARCHY_LOWER = [perm.lower() for perm in PERMISSION_HIERARCHY]

# Obs - these are all intended to be stored on the Player, and as such,
# use self.player instead of self.caller, just to be sure. Also self.msg()
# is used to make sure returns go to the right session

class CmdOOCLook(MuxPlayerCommand):
    """
    look while out-of-character

    Usage:
      look

    Look in the ooc state.
    """

    #This is an OOC version of the look command. Since a
    #Player doesn't have an in-game existence, there is no
    #concept of location or "self". If we are controlling
    #a character, pass control over to normal look.

    key = "look"
    aliases = ["l", "ls"]
    locks = "cmd:all()"
    help_category = "General"

    def look_target(self):
        "Hook method for when an argument is given."
        player = self.player
        key = self.args.lower()
        chars = dict((utils.to_str(char.key.lower()), char)
                       for char in player.db._playable_characters)
        looktarget = chars.get(key)
        if looktarget:
            self.msg(looktarget.return_appearance(player))
        else:
            self.msg("No such character.")
        return

    def no_look_target(self):
        "Hook method for default look without a specified target"
        # caller is always a player at this point.
        player = self.player
        sessid = self.sessid
        # get all our characters and sessions
        characters = player.db._playable_characters
        if None in characters:
            # clean up list if character object was deleted in between
            characters = [character for character in characters if character]
            player.db._playable_characters = characters

        sessions = player.get_all_sessions()
        is_su = player.is_superuser

        # text shown when looking in the ooc area
        string = "Account {g%s{n (you are Out-of-Character)" % (player.key)

        nsess = len(sessions)
        string += nsess == 1 and "\n\n{wConnected session:{n" or "\n\n{wConnected sessions (%i):{n" % nsess
        for isess, sess in enumerate(sessions):
            csessid = sess.sessid
            addr = "%s (%s)" % (sess.protocol_key, isinstance(sess.address, tuple) and str(sess.address[0]) or str(sess.address))
            string += "\n %s %s" % (sessid == csessid and "{w%s{n" % (isess + 1) or (isess + 1), addr)
        string += "\n\n {whelp{n - more commands"
        string += "\n {wooc <Text>{n - talk on public channel"

        if is_su or len(characters) < MAX_NR_CHARACTERS:
            if not characters:
                string += "\n\n You don't have any characters yet. See {whelp @charcreate{n for creating one."
            else:
                string += "\n {w@charcreate <name> [=description]{n - create new character"

        if characters:
            string_s_ending = len(characters) > 1 and "s" or ""
            string += "\n {w@ic <character>{n - enter the game ({w@ooc{n to get back here)"
            if is_su:
                string += "\n\nAvailable character%s (%i/unlimited):" % (string_s_ending, len(characters))
            else:
                string += "\n\nAvailable character%s%s:"  % (string_s_ending,
                         MAX_NR_CHARACTERS > 1 and " (%i/%i)" % (len(characters), MAX_NR_CHARACTERS) or "")

            for char in characters:
                csessid = char.sessid
                if csessid:
                    # character is already puppeted
                    sess = player.get_session(csessid)
                    sid = sess in sessions and sessions.index(sess) + 1
                    if sess and sid:
                        string += "\n - {G%s{n [%s] (played by you in session %i)" % (char.key, ", ".join(char.permissions.all()), sid)
                    else:
                        string += "\n - {R%s{n [%s] (played by someone else)" % (char.key, ", ".join(char.permissions.all()))
                else:
                    # character is "free to puppet"
                    string += "\n - %s [%s]" % (char.key, ", ".join(char.permissions.all()))
        string = ("-" * 68) + "\n" + string + "\n" + ("-" * 68)
        self.msg(string)

    def func(self):
        "implement the ooc look command"
        if MULTISESSION_MODE < 2:
            # only one character allowed
            string = "You are out-of-character (OOC).\nUse {w@ic{n to get back into the game."
            self.msg(string)
            return
        if utils.inherits_from(self.caller, "src.objects.objects.Object"):
            # An object of some type is calling. Use default look instead.
            super(CmdOOCLook, self).func()
        elif self.args:
            self.look_target()
        else:
            self.no_look_target()


class CmdCharCreate(MuxPlayerCommand):
    """
    create a new character

    Usage:
      @charcreate <charname> [= desc]

    Create a new character, optionally giving it a description. You
    may use upper-case letters in the name - you will nevertheless
    always be able to access your character using lower-case letters
    if you want.
    """
    key = "@charcreate"
    locks = "cmd:all()"
    help_category = "General"

    def func(self):
        "create the new character"
        player = self.player
        if not self.args:
            self.msg("Usage: @charcreate <charname> [= description]")
            return
        key = self.lhs
        desc = self.rhs
        if not player.is_superuser and \
            (player.db._playable_characters and
                len(player.db._playable_characters) >= MAX_NR_CHARACTERS):
            self.msg("You may only create a maximum of %i characters." % MAX_NR_CHARACTERS)
            return
        # create the character
        from src.objects.models import ObjectDB

        start_location = ObjectDB.objects.get_id(settings.START_LOCATION)
        default_home = ObjectDB.objects.get_id(settings.DEFAULT_HOME)
        typeclass = settings.BASE_CHARACTER_TYPECLASS
        permissions = settings.PERMISSION_PLAYER_DEFAULT

        new_character = create.create_object(typeclass, key=key,
                                             location=start_location,
                                             home=default_home,
                                             permissions=permissions)
        # only allow creator (and immortals) to puppet this char
        new_character.locks.add("puppet:id(%i) or pid(%i) or perm(Immortals) or pperm(Immortals)" %
                                (new_character.id, player.id))
        player.db._playable_characters.append(new_character)
        if desc:
            new_character.db.desc = desc
        else:
            new_character.db.desc = "This is a Player."
        self.msg("Created new character %s. Use {w@ic %s{n to enter the game as this character." % (new_character.key, new_character.key))


class CmdIC(MuxPlayerCommand):
    """
    control an object you have permission to puppet

    Usage:
      @ic <character>

    Go in-character (IC) as a given Character.

    This will attempt to "become" a different object assuming you have
    the right to do so. Note that it's the PLAYER character that puppets
    characters/objects and which needs to have the correct permission!

    You cannot become an object that is already controlled by another
    player. In principle <character> can be any in-game object as long
    as you the player have access right to puppet it.
    """

    key = "@ic"
    # lockmust be all() for different puppeted objects to access it.
    locks = "cmd:all()"
    aliases = "@puppet"
    help_category = "General"

    def func(self):
        """
        Main puppet method
        """
        player = self.player
        sessid = self.sessid

        new_character = None
        if not self.args:
            new_character = player.db._last_puppet
            if not new_character:
                self.msg("Usage: @ic <character>")
                return
        if not new_character:
            # search for a matching character
            new_character = search.object_search(self.args)
            if new_character:
                new_character = new_character[0]
            else:
                self.msg("That is not a valid character choice.")
                return
        # permission checks
        if player.get_puppet(sessid) == new_character:
            self.msg("{RYou already act as {c%s{n." % new_character.name)
            return
        if new_character.player:
            # may not puppet an already puppeted character
            if new_character.sessid and new_character.player == player:
                # as a safeguard we allow "taking over chars from
                # your own sessions.
                player.msg("{c%s{n{R is now acted from another of your sessions.{n" % (new_character.name), sessid=new_character.sessid)
                player.unpuppet_object(new_character.sessid)
                self.msg("Taking over {c%s{n from another of your sessions." % new_character.name)
            elif new_character.player != player and new_character.player.is_connected:
                self.msg("{c%s{r is already acted by another player.{n" % new_character.name)
                return
        if not new_character.access(player, "puppet"):
            # main acccess check
            self.msg("{rYou may not become %s.{n" % new_character.name)
            return
        if player.puppet_object(sessid, new_character):
            player.db._last_puppet = new_character
        else:
            self.msg("{rYou cannot become {C%s{n." % new_character.name)


class CmdOOC(MuxPlayerCommand):
    """
    stop puppeting and go ooc

    Usage:
      @ooc

    Go out-of-character (OOC).

    This will leave your current character and put you in a incorporeal OOC state.
    """

    key = "@ooc"
    # lock must be all(), for different puppeted objects to access it.
    locks = "cmd:all()"
    aliases = "@unpuppet"
    help_category = "General"

    def func(self):
        "Implement function"

        player = self.player
        sessid = self.sessid

        old_char = player.get_puppet(sessid)
        if not old_char:
            string = "You are already OOC."
            self.msg(string)
            return

        player.db._last_puppet = old_char

        # disconnect
        if player.unpuppet_object(sessid):
            self.msg("\n{GYou go OOC.{n\n")
            player.execute_cmd("look", sessid=sessid)
        else:
            raise RuntimeError("Could not unpuppet!")

class CmdSessions(MuxPlayerCommand):
    """
    check your connected session(s)

    Usage:
      @sessions

    Lists the sessions currently connected to your account.

    """
    key = "@sessions"
    locks = "cmd:all()"
    help_category = "General"

    def func(self):
        "Implement function"
        player = self.player
        sessions = player.get_all_sessions()

        table = prettytable.PrettyTable(["{wsessid",
                                         "{wprotocol",
                                         "{whost",
                                         "{wpuppet/character",
                                         "{wlocation"])
        for sess in sorted(sessions, key=lambda x: x.sessid):
            sessid = sess.sessid
            char = player.get_puppet(sessid)
            table.add_row([str(sessid), str(sess.protocol_key),
                           type(sess.address) == tuple and sess.address[0] or sess.address,
                           char and str(char) or "None",
                           char and str(char.location) or "N/A"])
        string = "{wYour current session(s):{n\n%s" % table
        self.msg(string)


class CmdWho(MuxPlayerCommand):
    """
    list who is currently online

    Usage:
      who
      doing

    Shows who is currently online. Doing is an alias that limits info
    also for those with all permissions.
    """

    key = "who"
    aliases = "doing"
    locks = "cmd:all()"

    def func(self):
        """
        Get all connected players by polling session.
        """

        player = self.player
        session_list = SESSIONS.get_sessions()

        session_list = sorted(session_list, key=lambda o: o.player.key)

        if self.cmdstring == "doing":
            show_session_data = False
        else:
            show_session_data = player.check_permstring("Immortals") or player.check_permstring("Wizards")

        nplayers = (SESSIONS.player_count())
        if show_session_data:
            table = prettytable.PrettyTable(["{wPlayer Name",
                                             "{wOn for",
                                             "{wIdle",
                                             "{wRoom",
                                             "{wCmds",
                                             "{wProtocol",
                                             "{wHost"])
            for session in session_list:
                if not session.logged_in: continue
                delta_cmd = time.time() - session.cmd_last_visible
                delta_conn = time.time() - session.conn_time
                plr_pobject = session.get_puppet()
                plr_pobject = plr_pobject or session.get_player()
                table.add_row([utils.crop(plr_pobject.name, width=25),
                               utils.time_format(delta_conn, 0),
                               utils.time_format(delta_cmd, 1),
                               hasattr(plr_pobject, "location") and plr_pobject.location and plr_pobject.location.key or "None",
                               session.cmd_total,
                               session.protocol_key,
                               isinstance(session.address, tuple) and session.address[0] or session.address])
        else:
            table = prettytable.PrettyTable(["{wPlayer name", "{wOn for", "{wIdle"])
            for session in session_list:
                if not session.logged_in:
                    continue
                delta_cmd = time.time() - session.cmd_last_visible
                delta_conn = time.time() - session.conn_time
                plr_pobject = session.get_puppet()
                plr_pobject = plr_pobject or session.get_player()
                table.add_row([utils.crop(plr_pobject.name, width=25),
                               utils.time_format(delta_conn, 0),
                               utils.time_format(delta_cmd, 1)])

        isone = nplayers == 1
        string = "{wPlayers:{n\n%s\n%s unique account%s logged in." % (table, "One" if isone else nplayers, "" if isone else "s")
        self.msg(string)


class CmdEncoding(MuxPlayerCommand):
    """
    set which text encoding to use

    Usage:
      @encoding/switches [<encoding>]

    Switches:
      clear - clear your custom encoding


    This sets the text encoding for communicating with Evennia. This is mostly
    an issue only if you want to use non-ASCII characters (i.e. letters/symbols
    not found in English). If you see that your characters look strange (or you
    get encoding errors), you should use this command to set the server
    encoding to be the same used in your client program.

    Common encodings are utf-8 (default), latin-1, ISO-8859-1 etc.

    If you don't submit an encoding, the current encoding will be displayed
    instead.
  """

    key = "@encoding"
    aliases = "@encode"
    locks = "cmd:all()"

    def func(self):
        """
        Sets the encoding.
        """
        player = self.player

        if 'clear' in self.switches:
            # remove customization
            old_encoding = player.db.encoding
            if old_encoding:
                string = "Your custom text encoding ('%s') was cleared." % old_encoding
            else:
                string = "No custom encoding was set."
            del player.db.encoding
        elif not self.args:
            # just list the encodings supported
            pencoding = player.db.encoding
            string = ""
            if pencoding:
                string += "Default encoding: {g%s{n (change with {w@encoding <encoding>{n)" % pencoding
            encodings = settings.ENCODINGS
            if encodings:
                string += "\nServer's alternative encodings (tested in this order):\n   {g%s{n" % ", ".join(encodings)
            if not string:
                string = "No encodings found."
        else:
            # change encoding
            old_encoding = player.db.encoding
            encoding = self.args
            player.db.encoding = encoding
            string = "Your custom text encoding was changed from '%s' to '%s'." % (old_encoding, encoding)
        self.msg(string.strip())


class CmdPassword(MuxPlayerCommand):
    """
    change your password

    Usage:
      @password <old password> = <new password>

    Changes your password. Make sure to pick a safe one.
    """
    key = "@password"
    locks = "cmd:all()"

    def func(self):
        "hook function."

        player = self.player
        if not self.rhs:
            self.msg("Usage: @password <oldpass> = <newpass>")
            return
        oldpass = self.lhslist[0]  # this is already stripped by parse()
        newpass = self.rhslist[0]  #               ''
        if not player.check_password(oldpass):
            self.msg("The specified old password isn't correct.")
        elif len(newpass) < 3:
            self.msg("Passwords must be at least three characters long.")
        else:
            player.set_password(newpass)
            player.save()
            self.msg("Password changed.")


class CmdQuit(MuxPlayerCommand):
    """
    quit the game

    Usage:
      @quit

    Switch:
      all - disconnect all connected sessions

    Gracefully disconnect your current session from the
    game. Use the /all switch to disconnect from all sessions.
    """
    key = "@quit"
    locks = "cmd:all()"

    def func(self):
        "hook function"
        player = self.player

        if 'all' in self.switches:
            player.msg("{RQuitting{n all sessions. Hope to see you soon again.", sessid=self.sessid)
            for session in player.get_all_sessions():
                player.disconnect_session_from_player(session.sessid)
        else:
            nsess = len(player.get_all_sessions())
            if nsess == 2:
                player.msg("{RQuitting{n. One session is still connected.", sessid=self.sessid)
            elif nsess > 2:
                player.msg("{RQuitting{n. %i session are still connected." % (nsess-1), sessid=self.sessid)
            else:
                # we are quitting the last available session
                player.msg("{RQuitting{n. Hope to see you soon again.", sessid=self.sessid)
            player.disconnect_session_from_player(self.sessid)



class CmdColorTest(MuxPlayerCommand):
    """
    testing which colors your client support

    Usage:
      @color ansi|xterm256

    Prints a color map along with in-mud color codes to use to produce
    them.  It also tests what is supported in your client. Choices are
    16-color ansi (supported in most muds) or the 256-color xterm256
    standard. No checking is done to determine your client supports
    color - if not you will see rubbish appear.
    """
    key = "@color"
    aliases = "color"
    locks = "cmd:all()"
    help_category = "General"

    def table_format(self, table):
       """
       Helper method to format the ansi/xterm256 tables.
       Takes a table of columns [[val,val,...],[val,val,...],...]
       """
       if not table:
           return [[]]

       extra_space = 1
       max_widths = [max([len(str(val)) for val in col]) for col in table]
       ftable = []
       for irow in range(len(table[0])):
           ftable.append([str(col[irow]).ljust(max_widths[icol]) + " " * extra_space
                          for icol, col in enumerate(table)])
       return ftable

    def func(self):
        "Show color tables"

        if self.args.startswith("a"):
            # show ansi 16-color table
            from src.utils import ansi
            ap = ansi.ANSI_PARSER
            # ansi colors
            # show all ansi color-related codes
            col1 = ["%s%s{n" % (code, code.replace("{", "{{")) for code, _ in ap.ext_ansi_map[6:14]]
            col2 = ["%s%s{n" % (code, code.replace("{", "{{")) for code, _ in ap.ext_ansi_map[14:22]]
            col3 = ["%s%s{n" % (code.replace("\\",""), code.replace("{", "{{").replace("\\", "")) for code, _ in ap.ext_ansi_map[-8:]]
            col2.extend(["" for i in range(len(col1)-len(col2))])
            #hi = "%ch"
            #col2 = ["%s%s{n" % (code, code.replace("%", "%%")) for code, _ in ap.mux_ansi_map[6:]]
            #col3 = ["%s%s{n" % (hi + code, (hi + code).replace("%", "%%")) for code, _ in ap.mux_ansi_map[3:-2]]
            table = utils.format_table([col1, col2, col3])
            string = "ANSI colors:"
            for row in table:
                string += "\n " + " ".join(row)
            #print string
            self.msg(string)
            self.msg("{{X : black. {{\ : return, {{- : tab, {{_ : space, {{* : invert")
            self.msg("To combine background and foreground, add background marker last, e.g. {{r{{[b.")

        elif self.args.startswith("x"):
            # show xterm256 table
            table = [[], [], [], [], [], [], [], [], [], [], [], []]
            for ir in range(6):
                for ig in range(6):
                    for ib in range(6):
                        # foreground table
                        table[ir].append("{%i%i%i%s{n" % (ir, ig, ib, "{{%i%i%i" % (ir, ig, ib)))
                        # background table
                        table[6+ir].append("{[%i%i%i{%i%i%i%s{n" % (ir, ig, ib,
                                                            5 - ir, 5 - ig, 5 - ib,
                                                        "{{[%i%i%i" % (ir, ig, ib)))
            table = self.table_format(table)
            string = "Xterm256 colors (if not all hues show, your client might not report that it can handle xterm256):"
            for row in table:
                string += "\n" + "".join(row)
            self.msg(string)
            #self.msg("(e.g. %%123 and %%[123 also work)")
        else:
            # malformed input
            self.msg("Usage: @color ansi|xterm256")


class CmdQuell(MuxPlayerCommand):
    """
    use character's permissions instead of player's

    Usage:
      quell
      unquell

    Normally the permission level of the Player is used when puppeting a
    Character/Object to determine access. This command will switch the lock
    system to make use of the puppeted Object's permissions instead. This is
    useful mainly for testing.
    Hierarchical permission quelling only work downwards, thus a Player cannot
    use a higher-permission Character to escalate their permission level.
    Use the unquell command to revert back to normal operation.
    """

    key = "@quell"
    aliases = ["@unquell"]
    locks = "cmd:all()"
    help_category = "General"

    def _recache_locks(self, player):
        "Helper method to reset the lockhandler on an already puppeted object"
        if self.sessid:
            char = player.get_puppet(self.sessid)
            if char:
                # we are already puppeting an object. We need to reset
                # the lock caches (otherwise the superuser status change
                # won't be visible until repuppet)
                char.locks.reset()
        player.locks.reset()

    def func(self):
        "Perform the command"
        player = self.player
        permstr = player.is_superuser and " (superuser)" or " (%s)" % (", ".join(player.permissions.all()))
        if self.cmdstring == '@unquell':
            if not player.attributes.get('_quell'):
                self.msg("Already using normal Player permissions%s." % permstr)
            else:
                player.attributes.remove('_quell')
                self.msg("Player permissions%s restored." % permstr)
        else:
            if player.attributes.get('_quell'):
                self.msg("Already quelling Player%s permissions." % permstr)
                return
            player.attributes.add('_quell', True)
            puppet = player.get_puppet(self.sessid)
            if puppet:
                cpermstr = " (%s)" % ", ".join(puppet.permissions.all())
                cpermstr = "Quelling to current puppet's permissions%s." % cpermstr
                cpermstr += "\n(Note: If this is higher than Player permissions%s, the lowest of the two will be used.)" % permstr
                cpermstr += "\nUse @unquell to return to normal permission usage."
                self.msg(cpermstr)
            else:
                self.msg("Quelling Player permissions%s. Use @unquell to get them back." % permstr)
        self._recache_locks(player)


########NEW FILE########
__FILENAME__ = syscommands
"""
System commands

These are the default commands called by the system commandhandler
when various exceptions occur. If one of these commands are not
implemented and part of the current cmdset, the engine falls back
to a default solution instead.

Some system commands are shown in this module
as a REFERENCE only (they are not all added to Evennia's
default cmdset since they don't currently do anything differently from the
default backup systems hard-wired in the engine).

Overloading these commands in a cmdset can be used to create
interesting effects. An example is using the NoMatch system command
to implement a line-editor where you don't have to start each
line with a command (if there is no match to a known command,
the line is just added to the editor buffer).
"""

from src.comms.models import ChannelDB
from src.utils import create

# The command keys the engine is calling
# (the actual names all start with __)
from src.commands.cmdhandler import CMD_NOINPUT
from src.commands.cmdhandler import CMD_NOMATCH
from src.commands.cmdhandler import CMD_MULTIMATCH
from src.commands.cmdhandler import CMD_CHANNEL

from src.commands.default.muxcommand import MuxCommand

# Command called when there is no input at line
# (i.e. an lone return key)


class SystemNoInput(MuxCommand):
    """
    This is called when there is no input given
    """
    key = CMD_NOINPUT
    locks = "cmd:all()"

    def func(self):
        "Do nothing."
        pass


#
# Command called when there was no match to the
# command name
#
class SystemNoMatch(MuxCommand):
    """
    No command was found matching the given input.
    """
    key = CMD_NOMATCH
    locks = "cmd:all()"

    def func(self):
        """
        This is given the failed raw string as input.
        """
        self.caller.msg("Huh?")


#
# Command called when there were mulitple matches to the command.
#
class SystemMultimatch(MuxCommand):
    """
    Multiple command matches.

    The cmdhandler adds a special attribute 'matches' to this
    system command.

      matches = [(candidate, cmd) , (candidate, cmd), ...],

    where candidate is an instance of src.commands.cmdparser.CommandCandidate
    and cmd is an an instantiated Command object matching the candidate.
    """
    key = CMD_MULTIMATCH
    locks = "cmd:all()"

    def format_multimatches(self, caller, matches):
        """
        Format multiple command matches to a useful error.

        This is copied directly from the default method in
        src.commands.cmdhandler.

        """
        string = "There were multiple matches:"
        for num, match in enumerate(matches):
            # each match is a tuple (candidate, cmd)
            candidate, cmd = match

            is_channel = hasattr(cmd, "is_channel") and cmd.is_channel
            if is_channel:
                is_channel = " (channel)"
            else:
                is_channel = ""
            is_exit = hasattr(cmd, "is_exit") and cmd.is_exit
            if is_exit and cmd.destination:
                is_exit = " (exit to %s)" % cmd.destination
            else:
                is_exit = ""

            id1 = ""
            id2 = ""
            if not (is_channel or is_exit) and (hasattr(cmd, 'obj') and cmd.obj != caller):
                # the command is defined on some other object
                id1 = "%s-" % cmd.obj.name
                id2 = " (%s-%s)" % (num + 1, candidate.cmdname)
            else:
                id1 = "%s-" % (num + 1)
                id2 = ""
            string += "\n  %s%s%s%s%s" % (id1, candidate.cmdname, id2, is_channel, is_exit)
        return string

    def func(self):
        """
        argument to cmd is a comma-separated string of
        all the clashing matches.
        """
        string = self.format_multimatches(self.caller, self.matches)
        self.caller.msg(string)


# Command called when the command given at the command line
# was identified as a channel name, like there existing a
# channel named 'ooc' and the user wrote
#  > ooc Hello!

class SystemSendToChannel(MuxCommand):
    """
    This is a special command that the cmdhandler calls
    when it detects that the command given matches
    an existing Channel object key (or alias).
    """

    key = CMD_CHANNEL
    locks = "cmd:all()"

    def parse(self):
        channelname, msg = self.args.split(':', 1)
        self.args = channelname.strip(), msg.strip()

    def func(self):
        """
        Create a new message and send it to channel, using
        the already formatted input.
        """
        caller = self.caller
        channelkey, msg = self.args
        if not msg:
            caller.msg("Say what?")
            return
        channel = ChannelDB.objects.get_channel(channelkey)
        if not channel:
            caller.msg("Channel '%s' not found." % channelkey)
            return
        if not channel.has_connection(caller):
            string = "You are not connected to channel '%s'."
            caller.msg(string % channelkey)
            return
        if not channel.access(caller, 'send'):
            string = "You are not permitted to send to channel '%s'."
            caller.msg(string % channelkey)
            return
        msg = "[%s] %s: %s" % (channel.key, caller.name, msg)
        msgobj = create.create_message(caller, msg, channels=[channel])
        channel.msg(msgobj)
########NEW FILE########
__FILENAME__ = system
"""

System commands

"""

import traceback
import os
import datetime
import sys
import django
import twisted
from time import time as timemeasure

from django.conf import settings
from src.server.caches import get_cache_sizes
from src.server.sessionhandler import SESSIONS
from src.scripts.models import ScriptDB
from src.objects.models import ObjectDB
from src.players.models import PlayerDB
from src.utils import logger, utils, gametime, create, is_pypy, prettytable
from src.utils.evtable import EvTable
from src.utils.utils import crop
from src.commands.default.muxcommand import MuxCommand

# delayed imports
_resource = None
_idmapper = None
_attribute_cache = None

# limit symbol import for API
__all__ = ("CmdReload", "CmdReset", "CmdShutdown", "CmdPy",
           "CmdScripts", "CmdObjects", "CmdService", "CmdAbout",
           "CmdTime", "CmdServerLoad")


class CmdReload(MuxCommand):
    """
    reload the server

    Usage:
      @reload [reason]

    This restarts the server. The Portal is not
    affected. Non-persistent scripts will survive a @reload (use
    @reset to purge) and at_reload() hooks will be called.
    """
    key = "@reload"
    locks = "cmd:perm(reload) or perm(Immortals)"
    help_category = "System"

    def func(self):
        """
        Reload the system.
        """
        reason = ""
        if self.args:
            reason = "(Reason: %s) " % self.args.rstrip(".")
        SESSIONS.announce_all(" Server restarting %s..." % reason)
        SESSIONS.server.shutdown(mode='reload')


class CmdReset(MuxCommand):
    """
    reset and reboot the server

    Usage:
      @reset

    A cold reboot. This works like a mixture of @reload and @shutdown,
    - all shutdown hooks will be called and non-persistent scrips will
    be purged. But the Portal will not be affected and the server will
    automatically restart again.
    """
    key = "@reset"
    aliases = ['@reboot']
    locks = "cmd:perm(reload) or perm(Immortals)"
    help_category = "System"

    def func(self):
        """
        Reload the system.
        """
        SESSIONS.announce_all(" Server resetting/restarting ...")
        SESSIONS.server.shutdown(mode='reset')


class CmdShutdown(MuxCommand):

    """
    stop the server completely

    Usage:
      @shutdown [announcement]

    Gracefully shut down both Server and Portal.
    """
    key = "@shutdown"
    locks = "cmd:perm(shutdown) or perm(Immortals)"
    help_category = "System"

    def func(self):
        "Define function"
        try:
            # Only allow shutdown if caller has session
            self.caller.sessions[0]
        except Exception:
            return
        self.msg('Shutting down server ...')
        announcement = "\nServer is being SHUT DOWN!\n"
        if self.args:
            announcement += "%s\n" % self.args
        logger.log_infomsg('Server shutdown by %s.' % self.caller.name)
        SESSIONS.announce_all(announcement)
        SESSIONS.portal_shutdown()
        SESSIONS.server.shutdown(mode='shutdown')


class CmdPy(MuxCommand):
    """
    execute a snippet of python code

    Usage:
      @py <cmd>

    Switch:
      time - output an approximate execution time for <cmd>

    Separate multiple commands by ';'.  A few variables are made
    available for convenience in order to offer access to the system
    (you can import more at execution time).

    Available variables in @py environment:
      self, me                   : caller
      here                       : caller.location
      ev                         : the evennia API
      inherits_from(obj, parent) : check object inheritance

    You can explore The evennia API from inside the game by calling
    ev.help(), ev.managers.help() etc.

    {rNote: In the wrong hands this command is a severe security risk.
    It should only be accessible by trusted server admins/superusers.{n

    """
    key = "@py"
    aliases = ["!"]
    locks = "cmd:perm(py) or perm(Immortals)"
    help_category = "System"

    def func(self):
        "hook function"

        caller = self.caller
        pycode = self.args

        if not pycode:
            string = "Usage: @py <code>"
            self.msg(string)
            return

        # check if caller is a player

        # import useful variables
        import ev
        available_vars = {'self': caller,
                          'me': caller,
                          'here': hasattr(caller, "location") and caller.location or None,
                          'ev': ev,
                          'inherits_from': utils.inherits_from}

        try:
            self.msg(">>> %s" % pycode, raw=True, sessid=self.sessid)
        except TypeError:
            self.msg(">>> %s" % pycode, raw=True)

        mode = "eval"
        try:
            try:
                pycode_compiled = compile(pycode, "", mode)
            except Exception:
                mode = "exec"
                pycode_compiled = compile(pycode, "", mode)

            duration = ""
            if "time" in self.switches:
                t0 = timemeasure()
                ret = eval(pycode_compiled, {}, available_vars)
                t1 = timemeasure()
                duration = " (%.4f ms)" % ((t1 - t0) * 1000)
            else:
                ret = eval(pycode_compiled, {}, available_vars)
            if mode == "eval":
                ret = "{n<<< %s%s" % (str(ret), duration)
            else:
                ret = "{n<<< Done.%s" % duration
        except Exception:
            errlist = traceback.format_exc().split('\n')
            if len(errlist) > 4:
                errlist = errlist[4:]
            ret = "\n".join("{n<<< %s" % line for line in errlist if line)

        if ret is not None:
            try:
                self.msg(ret, sessid=self.sessid)
            except TypeError:
                self.msg(ret)


# helper function. Kept outside so it can be imported and run
# by other commands.

def format_script_list(scripts):
    "Takes a list of scripts and formats the output."
    if not scripts:
        return "<No scripts>"

    table = EvTable("{wdbref{n", "{wobj{n", "{wkey{n", "{wintval{n", "{wnext{n",
                    "{wrept{n", "{wdb", "{wtypeclass{n", "{wdesc{n",
                    align='r', border="tablecols")
    for script in scripts:
        nextrep = script.time_until_next_repeat()
        if nextrep is None:
            nextrep = "PAUS" if script.db._paused_time else "--"
        else:
            nextrep = "%ss" % nextrep

        maxrepeat = script.repeats
        if maxrepeat:
            rept = "%i/%i" % (maxrepeat - script.remaining_repeats(), maxrepeat)
        else:
            rept = "-/-"

        table.add_row(script.id,
                      script.obj.key if (hasattr(script, 'obj') and script.obj) else "<Global>",
                      script.key,
                      script.interval if script.interval > 0 else "--",
                      nextrep,
                      rept,
                      "*" if script.persistent else "-",
                      script.typeclass_path.rsplit('.', 1)[-1],
                      crop(script.desc, width=20))
    return "%s" % table


class CmdScripts(MuxCommand):
    """
    list and manage all running scripts

    Usage:
      @scripts[/switches] [#dbref, key, script.path or <obj>]

    Switches:
      start - start a script (must supply a script path)
      stop - stops an existing script
      kill - kills a script - without running its cleanup hooks
      validate - run a validation on the script(s)

    If no switches are given, this command just views all active
    scripts. The argument can be either an object, at which point it
    will be searched for all scripts defined on it, or an script name
    or #dbref. For using the /stop switch, a unique script #dbref is
    required since whole classes of scripts often have the same name.

    Use @script for managing commands on objects.
    """
    key = "@scripts"
    aliases = ["@globalscript", "@listscripts"]
    locks = "cmd:perm(listscripts) or perm(Wizards)"
    help_category = "System"

    def func(self):
        "implement method"

        caller = self.caller
        args = self.args

        string = ""
        if args:
            if "start" in self.switches:
                # global script-start mode
                new_script = create.create_script(args)
                if new_script:
                    caller.msg("Global script %s was started successfully." % args)
                else:
                    caller.msg("Global script %s could not start correctly. See logs." % args)
                return

            # test first if this is a script match
            scripts = ScriptDB.objects.get_all_scripts(key=args)
            if not scripts:
                # try to find an object instead.
                objects = ObjectDB.objects.object_search(args)
                if objects:
                    scripts = []
                    for obj in objects:
                        # get all scripts on the object(s)
                        scripts.extend(ScriptDB.objects.get_all_scripts_on_obj(obj))
        else:
            # we want all scripts.
            scripts = ScriptDB.objects.get_all_scripts()
            if not scripts:
                caller.msg("No scripts are running.")
                return

        if not scripts:
            string = "No scripts found with a key '%s', or on an object named '%s'." % (args, args)
            caller.msg(string)
            return

        if self.switches and self.switches[0] in ('stop', 'del', 'delete', 'kill'):
            # we want to delete something
            if not scripts:
                string = "No scripts/objects matching '%s'. " % args
                string += "Be more specific."
            elif len(scripts) == 1:
                # we have a unique match!
                if 'kill' in self.switches:
                    string = "Killing script '%s'" % scripts[0].key
                    scripts[0].stop(kill=True)
                else:
                    string = "Stopping script '%s'." % scripts[0].key
                    scripts[0].stop()
                #import pdb
                #pdb.set_trace()
                ScriptDB.objects.validate() #just to be sure all is synced
            else:
                # multiple matches.
                string = "Multiple script matches. Please refine your search:\n"
                string += format_script_list(scripts)
        elif self.switches and self.switches[0] in ("validate", "valid", "val"):
            # run validation on all found scripts
            nr_started, nr_stopped = ScriptDB.objects.validate(scripts=scripts)
            string = "Validated %s scripts. " % ScriptDB.objects.all().count()
            string += "Started %s and stopped %s scripts." % (nr_started, nr_stopped)
        else:
            # No stopping or validation. We just want to view things.
            string = format_script_list(scripts)
        caller.msg(string)


class CmdObjects(MuxCommand):
    """
    statistics on objects in the database

    Usage:
      @objects [<nr>]

    Gives statictics on objects in database as well as
    a list of <nr> latest objects in database. If not
    given, <nr> defaults to 10.
    """
    key = "@objects"
    aliases = ["@listobjects", "@listobjs", '@stats', '@db']
    locks = "cmd:perm(listobjects) or perm(Builders)"
    help_category = "System"

    def func(self):
        "Implement the command"

        caller = self.caller

        if self.args and self.args.isdigit():
            nlim = int(self.args)
        else:
            nlim = 10

        nobjs = ObjectDB.objects.count()
        base_char_typeclass = settings.BASE_CHARACTER_TYPECLASS
        nchars = ObjectDB.objects.filter(db_typeclass_path=base_char_typeclass).count()
        nrooms = ObjectDB.objects.filter(db_location__isnull=True).exclude(db_typeclass_path=base_char_typeclass).count()
        nexits = ObjectDB.objects.filter(db_location__isnull=False, db_destination__isnull=False).count()
        nother = nobjs - nchars - nrooms - nexits

        nobjs = nobjs or 1 # fix zero-div error with empty database

        # total object sum table
        totaltable = EvTable("{wtype{n", "{wcomment{n", "{wcount{n", "{w%%{n", border="table", align="l")
        totaltable.align = 'l'
        totaltable.add_row("Characters", "(BASE_CHARACTER_TYPECLASS)", nchars, "%.2f" % ((float(nchars) / nobjs) * 100))
        totaltable.add_row("Rooms", "(location=None)", nrooms, "%.2f" % ((float(nrooms) / nobjs) * 100))
        totaltable.add_row("Exits", "(destination!=None)", nexits, "%.2f" % ((float(nexits) / nobjs) * 100))
        totaltable.add_row("Other", "", nother, "%.2f" % ((float(nother) / nobjs) * 100))

        # typeclass table
        typetable = EvTable("{wtypeclass{n", "{wcount{n", "{w%%{n", border="table", align="l")
        typetable.align = 'l'
        dbtotals = ObjectDB.objects.object_totals()
        for path, count in dbtotals.items():
            typetable.add_row(path, count, "%.2f" % ((float(count) / nobjs) * 100))

        # last N table
        objs = ObjectDB.objects.all().order_by("db_date_created")[max(0, nobjs - nlim):]
        latesttable = EvTable("{wcreated{n", "{wdbref{n", "{wname{n", "{wtypeclass{n", align="l", border="table")
        latesttable.align = 'l'
        for obj in objs:
            latesttable.add_row(utils.datetime_format(obj.date_created),
                                obj.dbref, obj.key, obj.typeclass.path)

        string = "\n{wObject subtype totals (out of %i Objects):{n\n%s" % (nobjs, totaltable)
        string += "\n{wObject typeclass distribution:{n\n%s" % typetable
        string += "\n{wLast %s Objects created:{n\n%s" % (min(nobjs, nlim), latesttable)
        caller.msg(string)


class CmdPlayers(MuxCommand):
    """
    list all registered players

    Usage:
      @players [nr]

    Lists statistics about the Players registered with the game.
    It will list the <nr> amount of latest registered players
    If not given, <nr> defaults to 10.
    """
    key = "@players"
    aliases = ["@listplayers"]
    locks = "cmd:perm(listplayers) or perm(Wizards)"

    def func(self):
        "List the players"

        caller = self.caller
        if self.args and self.args.is_digit():
            nlim = int(self.args)
        else:
            nlim = 10

        nplayers = PlayerDB.objects.count()

        # typeclass table
        dbtotals = PlayerDB.objects.object_totals()
        typetable = EvTable("{wtypeclass{n", "{wcount{n", "{w%%{n", border="cells", align="l")
        for path, count in dbtotals.items():
            typetable.add_row(path, count, "%.2f" % ((float(count) / nplayers) * 100))
        # last N table
        plyrs = PlayerDB.objects.all().order_by("db_date_created")[max(0, nplayers - nlim):]
        latesttable = EvTable("{wcreated{n", "{wdbref{n", "{wname{n", "{wtypeclass{n", border="cells", align="l")
        for ply in plyrs:
            latesttable.add_row(utils.datetime_format(ply.date_created), ply.dbref, ply.key, ply.typeclass.path)

        string = "\n{wPlayer typeclass distribution:{n\n%s" % typetable
        string += "\n{wLast %s Players created:{n\n%s" % (min(nplayers, nlim), latesttable)
        caller.msg(string)


class CmdService(MuxCommand):
    """
    manage system services

    Usage:
      @service[/switch] <service>

    Switches:
      list   - shows all available services (default)
      start  - activates or reactivate a service
      stop   - stops/inactivate a service (can often be restarted)
      delete - tries to permanently remove a service

    Service management system. Allows for the listing,
    starting, and stopping of services. If no switches
    are given, services will be listed. Note that to operate on the
    service you have to supply the full (green or red) name as given
    in the list.
    """

    key = "@service"
    aliases = ["@services"]
    locks = "cmd:perm(service) or perm(Immortals)"
    help_category = "System"

    def func(self):
        "Implement command"

        caller = self.caller
        switches = self.switches

        if switches and switches[0] not in ("list", "start", "stop", "delete"):
            caller.msg("Usage: @service/<list|start|stop|delete> [servicename]")
            return

        # get all services
        sessions = caller.sessions
        if not sessions:
            return
        service_collection = SESSIONS.server.services

        if not switches or switches[0] == "list":
            # Just display the list of installed services and their
            # status, then exit.
            table = prettytable.PrettyTable(["{wService{n (use @services/start|stop|delete)", "{wstatus"])
            table.align = 'l'
            for service in service_collection.services:
                table.add_row([service.name, service.running and "{gRunning" or "{rNot Running"])
            caller.msg(str(table))
            return

        # Get the service to start / stop

        try:
            service = service_collection.getServiceNamed(self.args)
        except Exception:
            string = 'Invalid service name. This command is case-sensitive. '
            string += 'See @service/list for valid service name (enter the full name exactly).'
            caller.msg(string)
            return

        if switches[0] in ("stop", "delete"):
            # Stopping/killing a service gracefully closes it and disconnects
            # any connections (if applicable).

            delmode = switches[0] == "delete"
            if not service.running:
                caller.msg('That service is not currently running.')
                return
            if service.name[:7] == 'Evennia':
                if delmode:
                    caller.msg("You cannot remove a core Evennia service (named 'Evennia***').")
                    return
                string = "You seem to be shutting down a core Evennia service (named 'Evennia***'). Note that"
                string += "stopping some TCP port services will *not* disconnect users *already*"
                string += "connected on those ports, but *may* instead cause spurious errors for them. To "
                string += "safely and permanently remove ports, change settings file and restart the server."
                caller.msg(string)

            if delmode:
                service.stopService()
                service_collection.removeService(service)
                caller.msg("Stopped and removed service '%s'." % self.args)
            else:
                service.stopService()
                caller.msg("Stopped service '%s'." % self.args)
            return

        if switches[0] == "start":
            #Starts a service.
            if service.running:
                caller.msg('That service is already running.')
                return
            caller.msg("Starting service '%s'." % self.args)
            service.startService()


class CmdAbout(MuxCommand):
    """
    show Evennia info

    Usage:
      @about

    Display info about the game engine.
    """

    key = "@about"
    aliases = "@version"
    locks = "cmd:all()"
    help_category = "System"

    def func(self):
        "Show the version"
        try:
            import south
            sversion = "{wSouth{n %s" % south.__version__
        except ImportError:
            sversion = "{wSouth{n <not installed>"

        string = """
         {cEvennia{n %s{n
         MUD/MUX/MU* development system

         {wLicence{n BSD 3-Clause Licence
         {wWeb{n http://www.evennia.com
         {wIrc{n #evennia on FreeNode
         {wForum{n http://www.evennia.com/discussions
         {wMaintainer{n (2010-)   Griatch (griatch AT gmail DOT com)
         {wMaintainer{n (2006-10) Greg Taylor

         {wOS{n %s
         {wPython{n %s
         {wTwisted{n %s
         {wDjango{n %s
         %s
        """ % (utils.get_evennia_version(),
               os.name,
               sys.version.split()[0],
               twisted.version.short(),
               django.get_version(),
               sversion)
        self.caller.msg(string)


class CmdTime(MuxCommand):
    """
    show server time statistics

    Usage:
      @time

    List Server time statistics such as uptime
    and the current time stamp.
    """
    key = "@time"
    aliases = "@uptime"
    locks = "cmd:perm(time) or perm(Players)"
    help_category = "System"

    def func(self):
        "Show server time data in a table."
        table = prettytable.PrettyTable(["{wserver time statistic","{wtime"])
        table.align = 'l'
        table.add_row(["Current server uptime", utils.time_format(gametime.uptime(), 3)])
        table.add_row(["Total server running time", utils.time_format(gametime.runtime(), 2)])
        table.add_row(["Total in-game time (realtime x %g" % (gametime.TIMEFACTOR), utils.time_format(gametime.gametime(), 2)])
        table.add_row(["Server time stamp", datetime.datetime.now()])
        self.caller.msg(str(table))


class CmdServerLoad(MuxCommand):
    """
    show server load and memory statistics

    Usage:
       @serverload

    This command shows server load statistics and dynamic memory
    usage.

    Some Important statistics in the table:

    {wServer load{n is an average of processor usage. It's usually
    between 0 (no usage) and 1 (100% usage), but may also be
    temporarily higher if your computer has multiple CPU cores.

    The {wResident/Virtual memory{n displays the total memory used by
    the server process.

    Evennia {wcaches{n all retrieved database entities when they are
    loaded by use of the idmapper functionality. This allows Evennia
    to maintain the same instances of an entity and allowing
    non-persistent storage schemes. The total amount of cached objects
    are displayed plus a breakdown of database object types. Finally,
    {wAttributes{n are cached on-demand for speed. The total amount of
    memory used for this type of cache is also displayed.

    """
    key = "@server"
    aliases = ["@serverload", "@serverprocess"]
    locks = "cmd:perm(list) or perm(Immortals)"
    help_category = "System"

    def func(self):
        "Show list."

        caller = self.caller

        # display active processes

        if not utils.host_os_is('posix'):
            string = "Process listings are only available under Linux/Unix."
            caller.msg(string)
            return

        global _resource, _idmapper
        if not _resource:
            import resource as _resource
        if not _idmapper:
            from src.utils.idmapper import base as _idmapper

        import resource
        loadavg = os.getloadavg()
        psize = _resource.getpagesize()
        pid = os.getpid()
        rmem = float(os.popen('ps -p %d -o %s | tail -1' % (pid, "rss")).read()) / 1024.0  # resident memory
        vmem = float(os.popen('ps -p %d -o %s | tail -1' % (pid, "vsz")).read()) / 1024.0  # virtual memory
        pmem = float(os.popen('ps -p %d -o %s | tail -1' % (pid, "%mem")).read())  # percent of resident memory to total
        rusage = resource.getrusage(resource.RUSAGE_SELF)

        # load table
        loadtable = prettytable.PrettyTable(["property", "statistic"])
        loadtable.align = 'l'
        loadtable.add_row(["Server load (1 min)", "%g" % loadavg[0]])
        loadtable.add_row(["Process ID", "%g" % pid]),
        loadtable.add_row(["Bytes per page", "%g " % psize])
        loadtable.add_row(["CPU time used (total)", "%s (%gs)" % (utils.time_format(rusage.ru_utime), rusage.ru_utime)])
        loadtable.add_row(["CPU time used (user)", "%s (%gs)" % (utils.time_format(rusage.ru_stime), rusage.ru_stime)])
        loadtable.add_row(["Memory usage","%g MB (%g%%)" % (rmem, pmem)])
        loadtable.add_row(["Virtual address space\n {x(resident+swap+caching){n", "%g MB" % vmem])
        loadtable.add_row(["Page faults", "%g hard,  %g soft, %g swapouts" % (rusage.ru_majflt, rusage.ru_minflt, rusage.ru_nswap)])
        loadtable.add_row(["Disk I/O", "%g reads, %g writes" % (rusage.ru_inblock, rusage.ru_oublock)])
        loadtable.add_row(["Network I/O", "%g in, %g out" % (rusage.ru_msgrcv, rusage.ru_msgsnd)])
        loadtable.add_row(["Context switching", "%g vol, %g forced, %g signals" % (rusage.ru_nvcsw, rusage.ru_nivcsw, rusage.ru_nsignals)])

        string = "{wServer CPU and Memory load:{n\n%s" % loadtable

        if not is_pypy:
            # Cache size measurements are not available on PyPy
            # because it lacks sys.getsizeof

            # object cache size
            cachedict = _idmapper.cache_size()
            totcache = cachedict["_total"]
            sorted_cache = sorted([(key, tup[0], tup[1]) for key, tup in cachedict.items() if key !="_total" and tup[0] > 0],
                                    key=lambda tup: tup[2], reverse=True)
            memtable = prettytable.PrettyTable(["entity name",
                                                "number",
                                                "cache (MB)",
                                                "idmapper %%"])
            memtable.align = 'l'
            for tup in sorted_cache:
                memtable.add_row([tup[0],
                                 "%i" % tup[1],
                                 "%5.2f" % tup[2],
                                 "%.2f" % (float(tup[2] / totcache[1]) * 100)])

            # get sizes of other caches
            attr_cache_info, prop_cache_info = get_cache_sizes()
            string += "\n{w Entity idmapper cache usage:{n %5.2f MB (%i items)\n%s" % (totcache[1], totcache[0], memtable)
            string += "\n{w On-entity Attribute cache usage:{n %5.2f MB (%i attrs)" % (attr_cache_info[1], attr_cache_info[0])
            string += "\n{w On-entity Property cache usage:{n %5.2f MB (%i props)" % (prop_cache_info[1], prop_cache_info[0])
            base_mem = vmem - totcache[1] - attr_cache_info[1] - prop_cache_info[1]
            string += "\n{w Base Server usage (virtmem-idmapper-attrcache-propcache):{n %5.2f MB" % base_mem

        caller.msg(string)


########NEW FILE########
__FILENAME__ = tests
# -*- coding: utf-8 -*-
"""
 ** OBS - this is not a normal command module! **
 ** You cannot import anything in this module as a command! **

This is part of the Evennia unittest framework, for testing the
stability and integrity of the codebase during updates. This module
test the default command set. It is instantiated by the
src/objects/tests.py module, which in turn is run by as part of the
main test suite started with
 > python game/manage.py test.

"""

import re
from django.conf import settings
from django.utils.unittest import TestCase
from src.server.serversession import ServerSession
from src.objects.objects import Object, Character
from src.players.player import Player
from src.utils import create, ansi
from src.server.sessionhandler import SESSIONS

from django.db.models.signals import pre_save
from src.server.caches import field_pre_save
pre_save.connect(field_pre_save, dispatch_uid="fieldcache")

# set up signal here since we are not starting the server

_RE = re.compile(r"^\+|-+\+|\+-+|--*|\|", re.MULTILINE)

#------------------------------------------------------------
# Command testing
# ------------------------------------------------------------


def dummy(self, *args, **kwargs):
    pass

SESSIONS.data_out = dummy
SESSIONS.disconnect = dummy


class TestObjectClass(Object):
    def msg(self, text="", **kwargs):
        "test message"
        pass


class TestCharacterClass(Character):
    def msg(self, text="", **kwargs):
        "test message"
        if self.player:
            self.player.msg(text=text, **kwargs)
        else:
            if not self.ndb.stored_msg:
                self.ndb.stored_msg = []
            self.ndb.stored_msg.append(text)


class TestPlayerClass(Player):
    def msg(self, text="", **kwargs):
        "test message"
        if not self.ndb.stored_msg:
            self.ndb.stored_msg = []
        self.ndb.stored_msg.append(text)

    def _get_superuser(self):
        "test with superuser flag"
        return self.ndb.is_superuser
    is_superuser = property(_get_superuser)


class CommandTest(TestCase):
    """
    Tests a command
    """
    CID = 0 # we must set a different CID in every test to avoid unique-name collisions creating the objects
    def setUp(self):
        "sets up testing environment"
        settings.DEFAULT_HOME = "#2"
        #print "creating player %i: %s" % (self.CID, self.__class__.__name__)
        self.player = create.create_player("TestPlayer%i" % self.CID, "test@test.com", "testpassword", typeclass=TestPlayerClass)
        self.player2 = create.create_player("TestPlayer%ib" % self.CID, "test@test.com", "testpassword", typeclass=TestPlayerClass)
        self.room1 = create.create_object("src.objects.objects.Room", key="Room%i"%self.CID, nohome=True)
        self.room1.db.desc = "room_desc"
        self.room2 = create.create_object("src.objects.objects.Room", key="Room%ib" % self.CID)
        self.obj1 = create.create_object(TestObjectClass, key="Obj%i" % self.CID, location=self.room1, home=self.room1)
        self.obj2 = create.create_object(TestObjectClass, key="Obj%ib" % self.CID, location=self.room1, home=self.room1)
        self.char1 = create.create_object(TestCharacterClass, key="Char%i" % self.CID, location=self.room1, home=self.room1)
        self.char1.permissions.add("Immortals")
        self.char2 = create.create_object(TestCharacterClass, key="Char%ib" % self.CID, location=self.room1, home=self.room1)
        self.char1.player = self.player
        self.char2.player = self.player2
        self.script = create.create_script("src.scripts.scripts.Script", key="Script%i" % self.CID)
        self.player.permissions.add("Immortals")

        # set up a fake session

        global SESSIONS
        session = ServerSession()
        session.init_session("telnet", ("localhost", "testmode"), SESSIONS)
        session.sessid = self.CID
        SESSIONS.portal_connect(session.get_sync_data())
        SESSIONS.login(SESSIONS.session_from_sessid(self.CID), self.player, testmode=True)


    def call(self, cmdobj, args, msg=None, cmdset=None, noansi=True, caller=None):
        """
        Test a command by assigning all the needed
        properties to cmdobj and  running
            cmdobj.at_pre_cmd()
            cmdobj.parse()
            cmdobj.func()
            cmdobj.at_post_cmd()
        The msgreturn value is compared to eventual
        output sent to caller.msg in the game
        """
        cmdobj.caller = caller if caller else self.char1
        #print "call:", cmdobj.key, cmdobj.caller, caller if caller else cmdobj.caller.player
        #print "perms:", cmdobj.caller.permissions.all()
        cmdobj.cmdstring = cmdobj.key
        cmdobj.args = args
        cmdobj.cmdset = cmdset
        cmdobj.sessid = self.CID
        cmdobj.session = SESSIONS.session_from_sessid(self.CID)
        cmdobj.player = self.player
        cmdobj.raw_string = cmdobj.key + " " + args
        cmdobj.obj = caller if caller else self.char1
        # test
        self.char1.player.ndb.stored_msg = []
        cmdobj.at_pre_cmd()
        cmdobj.parse()
        cmdobj.func()
        cmdobj.at_post_cmd()
        # clean out prettytable sugar
        stored_msg = self.char1.player.ndb.stored_msg if self.char1.player else self.char1.ndb.stored_msg
        returned_msg = "|".join(_RE.sub("", mess) for mess in stored_msg)
        #returned_msg = "|".join(self.char1.player.ndb.stored_msg)
        returned_msg = ansi.parse_ansi(returned_msg, strip_ansi=noansi).strip()
        if msg != None:
            if msg == "" and returned_msg or not returned_msg.startswith(msg.strip()):
                sep1 = "\n" + "="*30 + "Wanted message" + "="*34 + "\n"
                sep2 = "\n" + "="*30 + "Returned message" + "="*32 + "\n"
                sep3 = "\n" + "="*78
                retval = sep1 + msg.strip() + sep2 + returned_msg + sep3
                raise AssertionError(retval)

#------------------------------------------------------------
# Individual module Tests
#------------------------------------------------------------

from src.commands.default import general
class TestGeneral(CommandTest):
    CID = 1

    def test_cmds(self):
        self.call(general.CmdLook(), "here", "Room1\n room_desc")
        self.call(general.CmdHome(), "", "You are already home")
        self.call(general.CmdInventory(), "", "You are not carrying anything.")
        self.call(general.CmdPose(), "looks around", "Char1 looks around")
        self.call(general.CmdHome(), "", "You are already home")
        self.call(general.CmdNick(), "testalias = testaliasedstring1", "Nick set:")
        self.call(general.CmdNick(), "/player testalias = testaliasedstring2", "Nick set:")
        self.call(general.CmdNick(), "/object testalias = testaliasedstring3", "Nick set:")
        self.assertEqual(u"testaliasedstring1", self.char1.nicks.get("testalias"))
        self.assertEqual(u"testaliasedstring2", self.char1.nicks.get("testalias", category="player"))
        self.assertEqual(u"testaliasedstring3", self.char1.nicks.get("testalias", category="object"))
        self.call(general.CmdGet(), "Obj1", "You pick up Obj1.")
        self.call(general.CmdDrop(), "Obj1", "You drop Obj1.")
        self.call(general.CmdSay(), "Testing", "You say, \"Testing\"")
        self.call(general.CmdAccess(), "", "Permission Hierarchy (climbing):")


from src.commands.default import help
from src.commands.default.cmdset_character import CharacterCmdSet
class TestHelp(CommandTest):
    CID = 2
    def test_cmds(self):
        self.call(help.CmdHelp(), "", "Command help entries", cmdset=CharacterCmdSet())
        self.call(help.CmdSetHelp(), "testhelp, General = This is a test", "Topic 'testhelp' was successfully created.")
        self.call(help.CmdHelp(), "testhelp", "Help topic for testhelp", cmdset=CharacterCmdSet())


from src.commands.default import system
class TestSystem(CommandTest):
    CID = 3
    def test_cmds(self):
        # we are not testing CmdReload, CmdReset and CmdShutdown, CmdService or CmdTime
        # since the server is not running during these tests.
        self.call(system.CmdPy(), "1+2", ">>> 1+2|<<< 3")
        self.call(system.CmdScripts(), "", "dbref ")
        self.call(system.CmdObjects(), "", "Object subtype totals")
        self.call(system.CmdAbout(), "", None)
        self.call(system.CmdServerLoad(), "", "Server CPU and Memory load:")


from src.commands.default import admin
class TestAdmin(CommandTest):
    CID = 4
    def test_cmds(self):
        # not testing CmdBoot, CmdDelPlayer, CmdNewPassword
        self.call(admin.CmdEmit(), "Char4b = Test", "Emitted to Char4b:\nTest")
        self.call(admin.CmdPerm(), "Obj4 = Builders", "Permission 'Builders' given to Obj4 (the Object/Character).")
        self.call(admin.CmdWall(), "Test", "Announcing to all connected players ...")
        self.call(admin.CmdPerm(), "Char4b = Builders","Permission 'Builders' given to Char4b (the Object/Character).")
        self.call(admin.CmdBan(), "Char4", "NameBan char4 was added.")


from src.commands.default import player
class TestPlayer(CommandTest):
   CID = 5
   def test_cmds(self):
        if settings.MULTISESSION_MODE < 2:
            self.call(player.CmdOOCLook(), "", "You are outofcharacter (OOC).", caller=self.player)
        if settings.MULTISESSION_MODE == 2:
            self.call(player.CmdOOCLook(), "", "Account TestPlayer5 (you are OutofCharacter)", caller=self.player)
        self.call(player.CmdOOC(), "", "You are already", caller=self.player)
        self.call(player.CmdIC(), "Char5","You become Char5.", caller=self.player)
        self.call(player.CmdPassword(), "testpassword = testpassword", "Password changed.", caller=self.player)
        self.call(player.CmdEncoding(), "", "Default encoding:", caller=self.player)
        self.call(player.CmdWho(), "", "Players:", caller=self.player)
        self.call(player.CmdQuit(), "", "Quitting. Hope to see you soon again.", caller=self.player)
        self.call(player.CmdSessions(), "", "Your current session(s):", caller=self.player)
        self.call(player.CmdColorTest(), "ansi", "ANSI colors:", caller=self.player)
        self.call(player.CmdCharCreate(), "Test1=Test char","Created new character Test1. Use @ic Test1 to enter the game", caller=self.player)
        self.call(player.CmdQuell(), "", "Quelling to current puppet's permissions (immortals).", caller=self.player)


from src.commands.default import building
class TestBuilding(CommandTest):
    CID = 6
    def test_cmds(self):
        self.call(building.CmdCreate(), "/drop TestObj1", "You create a new Object: TestObj1.")
        self.call(building.CmdExamine(), "TestObj1", "Name/key: TestObj1")
        self.call(building.CmdSetObjAlias(), "TestObj1 = TestObj1b","Alias(es) for 'TestObj1' set to testobj1b.")
        self.call(building.CmdCopy(), "TestObj1 = TestObj2;TestObj2b, TestObj3;TestObj3b", "Copied TestObj1 to 'TestObj3' (aliases: ['TestObj3b']")
        self.call(building.CmdSetAttribute(), "Obj6/test1=\"value1\"", "Created attribute Obj6/test1 = \"value1\"")
        self.call(building.CmdSetAttribute(), "Obj6b/test2=\"value2\"", "Created attribute Obj6b/test2 = \"value2\"")
        self.call(building.CmdMvAttr(), "Obj6b/test2 = Obj6/test3", "Moving Obj6b/test2 (with value value2) ...\nMoved Obj6b.test2")
        self.call(building.CmdCpAttr(), "Obj6/test1 = Obj6b/test3", "Copying Obj6/test1 (with value value1) ...\nCopied Obj6.test1")
        self.call(building.CmdName(), "Obj6b=Obj6c", "Object's name changed to 'Obj6c'.")
        self.call(building.CmdDesc(), "Obj6c=TestDesc", "The description was set on Obj6c.")
        self.call(building.CmdWipe(), "Obj6c/test2/test3", "Wiped attributes test2,test3 on Obj6c.")
        self.call(building.CmdDestroy(), "TestObj1","TestObj1 was destroyed.")
        self.call(building.CmdDig(), "TestRoom1=testroom;tr,back;b", "Created room TestRoom1")
        self.call(building.CmdTunnel(), "n = TestRoom2;test2", "Created room TestRoom2")
        self.call(building.CmdOpen(), "TestExit1=Room6b", "Created new Exit 'TestExit1' from Room6 to Room6b")
        self.call(building.CmdLink(),"TestExit1 = TestRoom1","Link created TestExit1 > TestRoom1 (one way).")
        self.call(building.CmdUnLink(), "TestExit1", "Former exit TestExit1 no longer links anywhere.")
        self.call(building.CmdSetHome(), "Obj6 = Room6b", "Obj6's home location was changed from Room6")
        self.call(building.CmdListCmdSets(), "", "<DefaultCharacter (Union, prio 0, perm)>:")
        self.call(building.CmdTypeclass(), "Obj6 = src.objects.objects.Exit",
                "Obj6 changed typeclass from src.commands.default.tests.TestObjectClass to src.objects.objects.Exit")
        self.call(building.CmdLock(), "Obj6 = test:perm(Immortals)", "Added lock 'test:perm(Immortals)' to Obj6.")
        self.call(building.CmdFind(), "TestRoom1", "One Match")
        self.call(building.CmdScript(), "Obj6 = src.scripts.scripts.Script", "Script src.scripts.scripts.Script successfully added")
        self.call(building.CmdTeleport(), "TestRoom1", "TestRoom1\nExits: back|Teleported to TestRoom1.")


from src.commands.default import comms
class TestComms(CommandTest):
    CID = 7
    def test_cmds(self):
        # not testing the irc/imc2/rss commands here since testing happens offline
        self.call(comms.CmdChannelCreate(), "testchan;test=Test Channel", "Created channel testchan and connected to it.")
        self.call(comms.CmdAddCom(), "tc = testchan", "You are already connected to channel testchan. You can now")
        self.call(comms.CmdDelCom(), "tc",  "Your alias 'tc' for channel testchan was cleared.")
        self.call(comms.CmdChannels(), "" ,"Available channels (use comlist,addcom and delcom to manage")
        self.call(comms.CmdAllCom(), "", "Available channels (use comlist,addcom and delcom to manage")
        self.call(comms.CmdClock(), "testchan=send:all()", "Lock(s) applied. Current locks on testchan:")
        self.call(comms.CmdCdesc(), "testchan = Test Channel", "Description of channel 'testchan' set to 'Test Channel'.")
        self.call(comms.CmdCemit(), "testchan = Test Message", "[testchan] Test Message|Sent to channel testchan: Test Message")
        self.call(comms.CmdCWho(), "testchan", "Channel subscriptions\ntestchan:\n  TestPlayer7")
        self.call(comms.CmdPage(), "TestPlayer7b = Test", "You paged TestPlayer7b with: 'Test'.")
        self.call(comms.CmdCBoot(), "", "Usage: @cboot[/quiet] <channel> = <player> [:reason]") # noone else connected to boot
        self.call(comms.CmdCdestroy(), "testchan" ,"[testchan] TestPlayer7: testchan is being destroyed. Make sure to change your aliases.|Channel 'testchan' was destroyed.")


from src.commands.default import batchprocess
class TestBatchProcess(CommandTest):
    CID = 8
    def test_cmds(self):
        # cannot test batchcode here, it must run inside the server process
        self.call(batchprocess.CmdBatchCommands(), "examples.batch_cmds", "Running Batchcommand processor  Automatic mode for examples.batch_cmds")
        #self.call(batchprocess.CmdBatchCode(), "examples.batch_code", "")

########NEW FILE########
__FILENAME__ = unloggedin
"""
Commands that are available from the connect screen.
"""
import re
import traceback
from django.conf import settings
from src.players.models import PlayerDB
from src.objects.models import ObjectDB
from src.server.models import ServerConfig
from src.comms.models import ChannelDB

from src.utils import create, logger, utils, ansi
from src.commands.default.muxcommand import MuxCommand
from src.commands.cmdhandler import CMD_LOGINSTART

# limit symbol import for API
__all__ = ("CmdUnconnectedConnect", "CmdUnconnectedCreate",
           "CmdUnconnectedQuit", "CmdUnconnectedLook", "CmdUnconnectedHelp")

MULTISESSION_MODE = settings.MULTISESSION_MODE
CONNECTION_SCREEN_MODULE = settings.CONNECTION_SCREEN_MODULE
CONNECTION_SCREEN = ""
try:
    CONNECTION_SCREEN = ansi.parse_ansi(utils.random_string_from_module(CONNECTION_SCREEN_MODULE))
except Exception:
    pass
if not CONNECTION_SCREEN:
    CONNECTION_SCREEN = "\nEvennia: Error in CONNECTION_SCREEN MODULE (randomly picked connection screen variable is not a string). \nEnter 'help' for aid."


class CmdUnconnectedConnect(MuxCommand):
    """
    connect to the game

    Usage (at login screen):
      connect playername password
      connect "player name" "pass word"

    Use the create command to first create an account before logging in.

    If you have spaces in your name, enclose it in quotes.
    """
    key = "connect"
    aliases = ["conn", "con", "co"]
    locks = "cmd:all()"  # not really needed
    arg_regex = r"\s.*?|$"

    def func(self):
        """
        Uses the Django admin api. Note that unlogged-in commands
        have a unique position in that their func() receives
        a session object instead of a source_object like all
        other types of logged-in commands (this is because
        there is no object yet before the player has logged in)
        """

        session = self.caller
        args = self.args
        # extract quoted parts
        parts = [part.strip() for part in re.split(r"\"|\'", args) if part.strip()]
        if len(parts) == 1:
            # this was (hopefully) due to no quotes being found
            parts = parts[0].split(None, 1)
        if len(parts) != 2:
            session.msg("\n\r Usage (without <>): connect <name> <password>")
            return
        playername, password = parts

        # Match account name and check password
        player = PlayerDB.objects.get_player_from_name(playername)
        pswd = None
        if player:
            pswd = player.check_password(password)

        if not (player and pswd):
        # No playername or password match
            string = "Wrong login information given.\nIf you have spaces in your name or "
            string += "password, don't forget to enclose it in quotes. Also capitalization matters."
            string += "\nIf you are new you should first create a new account "
            string += "using the 'create' command."
            session.msg(string)
            return

        # Check IP and/or name bans
        bans = ServerConfig.objects.conf("server_bans")
        if bans and (any(tup[0]==player.name.lower() for tup in bans)
                     or
                     any(tup[2].match(session.address) for tup in bans if tup[2])):
            # this is a banned IP or name!
            string = "{rYou have been banned and cannot continue from here."
            string += "\nIf you feel this ban is in error, please email an admin.{x"
            session.msg(string)
            session.execute_cmd("quit")
            return

        # actually do the login. This will call all other hooks:
        #   session.at_login()
        #   player.at_init()  # always called when object is loaded from disk
        #   player.at_pre_login()
        #   player.at_first_login()  # only once
        #   player.at_post_login(sessid=sessid)
        session.sessionhandler.login(session, player)


class CmdUnconnectedCreate(MuxCommand):
    """
    create a new player account

    Usage (at login screen):
      create <playername> <password>
      create "player name" "pass word"

    This creates a new player account.

    If you have spaces in your name, enclose it in quotes.
    """
    key = "create"
    aliases = ["cre", "cr"]
    locks = "cmd:all()"
    arg_regex = r"\s.*?|$"

    def func(self):
        "Do checks and create account"

        session = self.caller
        args = self.args.strip()

        # extract quoted parts
        parts = [part.strip() for part in re.split(r"\"|\'", args) if part.strip()]
        if len(parts) == 1:
            # this was (hopefully) due to no quotes being found
            parts = parts[0].split(None, 1)
        if len(parts) != 2:
            string = "\n Usage (without <>): create <name> <password>"
            string += "\nIf <name> or <password> contains spaces, enclose it in quotes."
            session.msg(string)
            return
        playername, password = parts

        # sanity checks
        if not re.findall('^[\w. @+-]+$', playername) or not (0 < len(playername) <= 30):
            # this echoes the restrictions made by django's auth
            # module (except not allowing spaces, for convenience of
            # logging in).
            string = "\n\r Playername can max be 30 characters or fewer. Letters, spaces, digits and @/./+/-/_ only."
            session.msg(string)
            return
        # strip excessive spaces in playername
        playername = re.sub(r"\s+", " ", playername).strip()
        if PlayerDB.objects.filter(username__iexact=playername):
            # player already exists (we also ignore capitalization here)
            session.msg("Sorry, there is already a player with the name '%s'." % playername)
            return
        if not re.findall('^[\w. @+-]+$', password) or not (3 < len(password)):
            string = "\n\r Password should be longer than 3 characers. Letters, spaces, digits and @\.\+\-\_ only."
            string += "\nFor best security, make it longer than 8 characters. You can also use a phrase of"
            string += "\nmany words if you enclose the password in quotes."
            session.msg(string)
            return

        # everything's ok. Create the new player account.
        try:
            default_home = ObjectDB.objects.get_id(settings.DEFAULT_HOME)

            typeclass = settings.BASE_CHARACTER_TYPECLASS
            permissions = settings.PERMISSION_PLAYER_DEFAULT

            try:
                new_player = create.create_player(playername, None, password,
                                                     permissions=permissions)

            except Exception, e:
                session.msg("There was an error creating the default Player/Character:\n%s\n If this problem persists, contact an admin." % e)
                logger.log_trace()
                return

            # This needs to be called so the engine knows this player is
            # logging in for the first time. (so it knows to call the right
            # hooks during login later)
            utils.init_new_player(new_player)

            # join the new player to the public channel
            pchanneldef = settings.CHANNEL_PUBLIC
            if pchanneldef:
                pchannel = ChannelDB.objects.get_channel(pchanneldef[0])
                if not pchannel.connect(new_player):
                    string = "New player '%s' could not connect to public channel!" % new_player.key
                    logger.log_errmsg(string)

            if MULTISESSION_MODE < 2:
                # if we only allow one character, create one with the same name as Player
                # (in mode 2, the character must be created manually once logging in)
                start_location = ObjectDB.objects.get_id(settings.START_LOCATION)
                if not start_location:
                    start_location = default_home # fallback

                new_character = create.create_object(typeclass, key=playername,
                                          location=start_location, home=default_home,
                                          permissions=permissions)
                # set playable character list
                new_player.db._playable_characters.append(new_character)

                # allow only the character itself and the player to puppet this character (and Immortals).
                new_character.locks.add("puppet:id(%i) or pid(%i) or perm(Immortals) or pperm(Immortals)" %
                                        (new_character.id, new_player.id))

                # If no description is set, set a default description
                if not new_character.db.desc:
                    new_character.db.desc = "This is a Player."
                # We need to set this to have @ic auto-connect to this character
                new_player.db._last_puppet = new_character

            # tell the caller everything went well.
            string = "A new account '%s' was created. Welcome!"
            if " " in playername:
                string += "\n\nYou can now log in with the command 'connect \"%s\" <your password>'."
            else:
                string += "\n\nYou can now log with the command 'connect %s <your password>'."
            session.msg(string % (playername, playername))

        except Exception:
            # We are in the middle between logged in and -not, so we have
            # to handle tracebacks ourselves at this point. If we don't,
            # we won't see any errors at all.
            string = "%s\nThis is a bug. Please e-mail an admin if the problem persists."
            session.msg(string % (traceback.format_exc()))
            logger.log_errmsg(traceback.format_exc())


class CmdUnconnectedQuit(MuxCommand):
    """
    quit when in unlogged-in state

    Usage:
      quit

    We maintain a different version of the quit command
    here for unconnected players for the sake of simplicity. The logged in
    version is a bit more complicated.
    """
    key = "quit"
    aliases = ["q", "qu"]
    locks = "cmd:all()"

    def func(self):
        "Simply close the connection."
        session = self.caller
        #session.msg("Good bye! Disconnecting ...")
        session.sessionhandler.disconnect(session, "Good bye! Disconnecting.")


class CmdUnconnectedLook(MuxCommand):
    """
    look when in unlogged-in state

    Usage:
      look

    This is an unconnected version of the look command for simplicity.

    This is called by the server and kicks everything in gear.
    All it does is display the connect screen.
    """
    key = CMD_LOGINSTART
    aliases = ["look", "l"]
    locks = "cmd:all()"

    def func(self):
        "Show the connect screen."
        self.caller.msg(CONNECTION_SCREEN)


class CmdUnconnectedHelp(MuxCommand):
    """
    get help when in unconnected-in state

    Usage:
      help

    This is an unconnected version of the help command,
    for simplicity. It shows a pane of info.
    """
    key = "help"
    aliases = ["h", "?"]
    locks = "cmd:all()"

    def func(self):
        "Shows help"

        string = \
            """
You are not yet logged into the game. Commands available at this point:
  {wcreate, connect, look, help, quit{n

To login to the system, you need to do one of the following:

{w1){n If you have no previous account, you need to use the 'create'
   command.

     {wcreate Anna c67jHL8p{n

   Note that if you use spaces in your name, you have to enclose in quotes.

     {wcreate "Anna the Barbarian"  c67jHL8p{n

   It's always a good idea (not only here, but everywhere on the net)
   to not use a regular word for your password. Make it longer than
   6 characters or write a passphrase.

{w2){n If you have an account already, either because you just created
   one in {w1){n above or you are returning, use the 'connect' command:

     {wconnect Anna c67jHL8p{n

   (Again, if there are spaces in the name you have to enclose it in quotes).
   This should log you in. Run {whelp{n again once you're logged in
   to get more aid. Hope you enjoy your stay!

You can use the {wlook{n command if you want to see the connect screen again.
"""
        self.caller.msg(string)

########NEW FILE########
__FILENAME__ = admin
#
# This sets up how models are displayed
# in the web admin interface.
#

from django.contrib import admin
from src.comms.models import ChannelDB


class MsgAdmin(admin.ModelAdmin):
    list_display = ('id', 'db_date_sent', 'db_sender', 'db_receivers',
                    'db_channels', 'db_message', 'db_lock_storage')
    list_display_links = ("id",)
    ordering = ["db_date_sent", 'db_sender', 'db_receivers', 'db_channels']
    #readonly_fields = ['db_message', 'db_sender', 'db_receivers', 'db_channels']
    search_fields = ['id', '^db_date_sent', '^db_message']
    save_as = True
    save_on_top = True
    list_select_related = True
#admin.site.register(Msg, MsgAdmin)


class ChannelAdmin(admin.ModelAdmin):
    list_display = ('id', 'db_key', 'db_lock_storage', "subscriptions")
    list_display_links = ("id", 'db_key')
    ordering = ["db_key"]
    search_fields = ['id', 'db_key', 'db_aliases']
    save_as = True
    save_on_top = True
    list_select_related = True
    fieldsets = (
        (None, {'fields': (('db_key',), 'db_lock_storage', 'db_subscriptions')}),
        )

    def subscriptions(self, obj):
        "Helper method to get subs from a channel"
        return ", ".join([str(sub) for sub in obj.db_subscriptions.all()])

admin.site.register(ChannelDB, ChannelAdmin)

########NEW FILE########
__FILENAME__ = channelhandler
"""
The channel handler handles the stored set of channels
and how they are represented against the cmdhandler.

If there is a channel named 'newbie', we want to be able
to just write

> newbie Hello!

For this to work, 'newbie', the name of the channel, must
be identified by the cmdhandler as a command name. The
channelhandler stores all channels as custom 'commands'
that the cmdhandler can import and look through.

Warning - channel names take precedence over command names,
so make sure to not pick clashing channel names.

Unless deleting a channel you normally don't need to bother about
the channelhandler at all - the create_channel method handles the update.

To delete a channel cleanly, delete the channel object, then call
update() on the channelhandler. Or use Channel.objects.delete() which
does this for you.

"""
from src.comms.models import ChannelDB
from src.commands import cmdset, command


class ChannelCommand(command.Command):
    """
    Channel

    Usage:
       <channel name or alias>  <message>

    This is a channel. If you have subscribed to it, you can send to
    it by entering its name or alias, followed by the text you want to
    send.
    """
    # this flag is what identifies this cmd as a channel cmd
    # and branches off to the system send-to-channel command
    # (which is customizable by admin)
    is_channel = True
    key = "general"
    help_category = "Channel Names"
    obj = None

    def parse(self):
        """
        Simple parser
        """
        # cmdhandler sends channame:msg here.
        channelname, msg = self.args.split(":", 1)
        self.args = (channelname.strip(), msg.strip())

    def func(self):
        """
        Create a new message and send it to channel, using
        the already formatted input.
        """
        channelkey, msg = self.args
        caller = self.caller
        if not msg:
            self.msg("Say what?")
            return
        channel = ChannelDB.objects.get_channel(channelkey)

        if not channel:
            self.msg("Channel '%s' not found." % channelkey)
            return
        if not channel.has_connection(caller):
            string = "You are not connected to channel '%s'."
            self.msg(string % channelkey)
            return
        if not channel.access(caller, 'send'):
            string = "You are not permitted to send to channel '%s'."
            self.msg(string % channelkey)
            return
        channel.msg(msg, senders=self.caller, online=True)


class ChannelHandler(object):
    """
    Handles the set of commands related to channels.
    """
    def __init__(self):
        self.cached_channel_cmds = []
        self.cached_cmdsets = {}

    def __str__(self):
        return ", ".join(str(cmd) for cmd in self.cached_channel_cmds)

    def clear(self):
        """
        Reset the cache storage.
        """
        self.cached_channel_cmds = []

    def _format_help(self, channel):
        "builds a doc string"
        key = channel.key
        aliases = channel.aliases.all()
        ustring = "%s <message>" % key.lower() + "".join(["\n           %s <message>" % alias.lower() for alias in aliases])
        desc = channel.db.desc
        string = \
        """
        Channel '%s'

        Usage (not including your personal aliases):
           %s

        %s
        """ % (key, ustring, desc)
        return string

    def add_channel(self, channel):
        """
        Add an individual channel to the handler. This should be
        called whenever a new channel is created. To
        remove a channel, simply delete the channel object
        and run self.update on the handler.
        """
        # map the channel to a searchable command
        cmd = ChannelCommand(key=channel.key.strip().lower(),
                             aliases=channel.aliases.all(),
                             locks="cmd:all();%s" % channel.locks,
                             help_category="Channel names",
                             obj=channel,
                             is_channel=True)
        self.cached_channel_cmds.append(cmd)
        self.cached_cmdsets = {}

    def update(self):
        "Updates the handler completely."
        self.cached_channel_cmds = []
        self.cached_cmdsets = {}
        for channel in ChannelDB.objects.get_all_channels():
            self.add_channel(channel)

    def get_cmdset(self, source_object):
        """
        Retrieve cmdset for channels this source_object has
        access to send to.
        """
        if source_object in self.cached_cmdsets:
            return self.cached_cmdsets[source_object]
        else:
            # create a new cmdset holding all channels
            chan_cmdset = cmdset.CmdSet()
            chan_cmdset.key = '_channelset'
            chan_cmdset.priority = 120
            chan_cmdset.duplicates = True
            for cmd in [cmd for cmd in self.cached_channel_cmds
                        if cmd.access(source_object, 'send')]:
                chan_cmdset.add(cmd)
            self.cached_cmdsets[source_object] = chan_cmdset
            return chan_cmdset

CHANNELHANDLER = ChannelHandler()

########NEW FILE########
__FILENAME__ = comms
"""
Default Typeclass for Comms.

See objects.objects for more information on Typeclassing.
"""
from src.comms import Msg, TempMsg
from src.typeclasses.typeclass import TypeClass
from src.utils import logger
from src.utils.utils import make_iter


class Channel(TypeClass):
    """
    This is the base class for all Comms. Inherit from this to create different
    types of communication channels.
    """

    # helper methods, for easy overloading

    def channel_prefix(self, msg=None, emit=False):
        """
        How the channel should prefix itself for users. Return a string.
        """
        return '[%s] ' % self.key

    def format_senders(self, senders=None):
        """
        Function used to format a list of sender names.

        This function exists separately so that external sources can use
        it to format source names in the same manner as normal object/player
        names.
        """
        if not senders:
            return ''
        return ', '.join(senders)

    def pose_transform(self, msg, sender_string):
        """
        Detects if the sender is posing, and modifies the message accordingly.
        """
        pose = False
        message = msg.message
        message_start = message.lstrip()
        if message_start.startswith((':', ';')):
            pose = True
            message = message[1:]
            if not message.startswith((':', "'", ',')):
                if not message.startswith(' '):
                    message = ' ' + message
        if pose:
            return '%s%s' % (sender_string, message)
        else:
            return '%s: %s' % (sender_string, message)

    def format_external(self, msg, senders, emit=False):
        """
        Used for formatting external messages. This is needed as a separate
        operation because the senders of external messages may not be in-game
        objects/players, and so cannot have things like custom user
        preferences.

        senders should be a list of strings, each containing a sender.
        msg should contain the body of the message to be sent.
        """
        if not senders:
            emit = True
        if emit:
            return msg.message
        senders = ', '.join(senders)
        return self.pose_transform(msg, senders)

    def format_message(self, msg, emit=False):
        """
        Formats a message body for display.

        If emit is True, it means the message is intended to be posted detached
        from an identity.
        """
        # We don't want to count things like external sources as senders for
        # the purpose of constructing the message string.
        senders = [sender for sender in msg.senders if hasattr(sender, 'key')]
        if not senders:
            emit = True
        if emit:
            return msg.message
        else:
            senders = [sender.key for sender in msg.senders]
            senders = ', '.join(senders)
            return self.pose_transform(msg, senders)

    def message_transform(self, msg, emit=False, prefix=True,
                          sender_strings=None, external=False):
        """
        Generates the formatted string sent to listeners on a channel.
        """
        if sender_strings or external:
            body = self.format_external(msg, sender_strings, emit=emit)
        else:
            body = self.format_message(msg, emit=emit)
        if prefix:
            body = "%s%s" % (self.channel_prefix(msg, emit=emit), body)
        msg.message = body
        return msg

    def at_channel_create(self):
        """
        Run at channel creation.
        """
        pass

    def pre_join_channel(self, joiner):
        """
        Run right before a channel is joined. If this returns a false value,
        channel joining is aborted.
        """
        return True

    def post_join_channel(self, joiner):
        """
        Run right after an object or player joins a channel.
        """
        return True

    def pre_leave_channel(self, leaver):
        """
        Run right before a user leaves a channel. If this returns a false
        value, leaving the channel will be aborted.
        """
        return True

    def post_leave_channel(self, leaver):
        """
        Run right after an object or player leaves a channel.
        """
        pass

    def pre_send_message(self, msg):
        """
        Run before a message is sent to the channel.

        This should return the message object, after any transformations.
        If the message is to be discarded, return a false value.
        """
        return msg

    def post_send_message(self, msg):
        """
        Run after a message is sent to the channel.
        """
        pass

    def at_init(self):
        """
        This is always called whenever this channel is initiated --
        that is, whenever it its typeclass is cached from memory. This
        happens on-demand first time the channel is used or activated
        in some way after being created but also after each server
        restart or reload.
        """
        pass

    def distribute_message(self, msg, online=False):
        """
        Method for grabbing all listeners that a message should be sent to on
        this channel, and sending them a message.
        """
        # get all players connected to this channel and send to them
        for player in self.dbobj.db_subscriptions.all():
            player = player.typeclass
            try:
                # note our addition of the from_channel keyword here. This could be checked
                # by a custom player.msg() to treat channel-receives differently.
                player.msg(msg.message, from_obj=msg.senders, from_channel=self.id)
            except AttributeError, e:
                logger.log_trace("%s\nCannot send msg to player '%s'." % (e, player))

    def msg(self, msgobj, header=None, senders=None, sender_strings=None,
            persistent=False, online=False, emit=False, external=False):
        """
        Send the given message to all players connected to channel. Note that
        no permission-checking is done here; it is assumed to have been
        done before calling this method. The optional keywords are not used if
        persistent is False.

        msgobj - a Msg/TempMsg instance or a message string. If one of the
                 former, the remaining keywords will be ignored. If a string,
                 this will either be sent as-is (if persistent=False) or it
                 will be used together with header and senders keywords to
                 create a Msg instance on the fly.
        senders - an object, player or a list of objects or players.
                 Optional if persistent=False.
        sender_strings - Name strings of senders. Used for external
                connections where the sender is not a player or object. When
                this is defined, external will be assumed.
        external - Treat this message agnostic of its sender.
        persistent (default False) - ignored if msgobj is a Msg or TempMsg.
                If True, a Msg will be created, using header and senders
                keywords. If False, other keywords will be ignored.
        online (bool) - If this is set true, only messages people who are
                online. Otherwise, messages all players connected. This can
                make things faster, but may not trigger listeners on players
                that are offline.
        emit (bool) - Signals to the message formatter that this message is
                not to be directly associated with a name.
        """
        if senders:
            senders = make_iter(senders)
        else:
            senders = []
        if isinstance(msgobj, basestring):
            # given msgobj is a string
            msg = msgobj
            if persistent and self.db.keep_log:
                msgobj = Msg()
                msgobj.save()
            else:
                # Use TempMsg, so this message is not stored.
                msgobj = TempMsg()
            msgobj.header = header
            msgobj.message = msg
            msgobj.channels = [self.dbobj]  # add this channel

        if not msgobj.senders:
            msgobj.senders = senders
        msgobj = self.pre_send_message(msgobj)
        if not msgobj:
            return False
        msgobj = self.message_transform(msgobj, emit=emit,
                                        sender_strings=sender_strings,
                                        external=external)
        self.distribute_message(msgobj, online=online)
        self.post_send_message(msgobj)
        return True

    def tempmsg(self, message, header=None, senders=None):
        """
        A wrapper for sending non-persistent messages.
        """
        self.msg(message, senders=senders, header=header, persistent=False)


########NEW FILE########
__FILENAME__ = managers
"""
These managers handles the
"""

from django.db import models
from django.db.models import Q
from src.typeclasses.managers import returns_typeclass_list, returns_typeclass

_GA = object.__getattribute__
_PlayerDB = None
_ObjectDB = None
_ChannelDB = None
_SESSIONS = None

# error class


class CommError(Exception):
    "Raise by comm system, to allow feedback to player when caught."
    pass


#
# helper functions
#

def dbref(dbref, reqhash=True):
    """
    Valid forms of dbref (database reference number)
    are either a string '#N' or an integer N.
    Output is the integer part.
    """
    if reqhash and not (isinstance(dbref, basestring) and dbref.startswith("#")):
        return None
    if isinstance(dbref, basestring):
        dbref = dbref.lstrip('#')
    try:
        if int(dbref) < 0:
            return None
    except Exception:
        return None
    return dbref


def identify_object(inp):
    "identify if an object is a player or an object; return its database model"
    # load global stores
    global _PlayerDB, _ObjectDB, _ChannelDB
    if not _PlayerDB:
        from src.players.models import PlayerDB as _PlayerDB
    if not _ObjectDB:
        from src.objects.models import ObjectDB as _ObjectDB
    if not _ChannelDB:
        from src.comms.models import ChannelDB as _ChannelDB
    if not inp:
        return inp, None
    # try to identify the type
    try:
        obj = _GA(inp, "dbobj")  # this works for all typeclassed entities
    except AttributeError:
        obj = inp
    typ = type(obj)
    if typ == _PlayerDB:
        return obj, "player"
    elif typ == _ObjectDB:
        return obj, "object"
    elif typ == _ChannelDB:
        return obj, "channel"
    elif dbref(obj):
        return dbref(obj), "dbref"
    elif typ == basestring:
        return obj, "string"
    return obj, None   # Something else


def to_object(inp, objtype='player'):
    """
    Locates the object related to the given
    playername or channel key. If input was already
    the correct object, return it.
    inp - the input object/string
    objtype - 'player' or 'channel'
    """
    obj, typ = identify_object(inp)
    if typ == objtype:
        return obj
    if objtype == 'player':
        if typ == 'object':
            return obj.player
        if typ == 'string':
            return _PlayerDB.objects.get(user_username__iexact=obj)
        if typ == 'dbref':
            return _PlayerDB.objects.get(id=obj)
        print objtype, inp, obj, typ, type(inp)
        raise CommError()
    elif objtype == 'object':
        if typ == 'player':
            return obj.obj
        if typ == 'string':
            return _ObjectDB.objects.get(db_key__iexact=obj)
        if typ == 'dbref':
            return _ObjectDB.objects.get(id=obj)
        print objtype, inp, obj, typ, type(inp)
        raise CommError()
    elif objtype == 'channel':
        if typ == 'string':
            return _ChannelDB.objects.get(db_key__iexact=obj)
        if typ == 'dbref':
            return _ChannelDB.objects.get(id=obj)
        print objtype, inp, obj, typ, type(inp)
        raise CommError()

#
# Msg manager
#

class MsgManager(models.Manager):
    """
    This MsgManager implements methods for searching
    and manipulating Messages directly from the database.

    These methods will all return database objects
    (or QuerySets) directly.

    A Message represents one unit of communication, be it over a
    Channel or via some form of in-game mail system. Like an e-mail,
    it always has a sender and can have any number of receivers (some
    of which may be Channels).

    Evennia-specific:
     get_message_by_id
     get_messages_by_sender
     get_messages_by_receiver
     get_messages_by_channel
     text_search
     message_search (equivalent to ev.search_messages)
    """

    def identify_object(self, obj):
        "method version for easy access"
        return identify_object(obj)

    def get_message_by_id(self, idnum):
        "Retrieve message by its id."
        try:
            return self.get(id=self.dbref(idnum, reqhash=False))
        except Exception:
            return None

    def get_messages_by_sender(self, obj, exclude_channel_messages=False):
        """
        Get all messages sent by one entity - this could be either a
        player or an object

        only_non_channel: only return messages -not- aimed at a channel
        (e.g. private tells)
        """
        obj, typ = identify_object(obj)
        if exclude_channel_messages:
            # explicitly exclude channel recipients
            if typ == 'player':
                return list(self.filter(db_sender_players=obj,
                            db_receivers_channels__isnull=True).exclude(db_hide_from_players=obj))
            elif typ == 'object':
                return list(self.filter(db_sender_objects=obj,
                            db_receivers_channels__isnull=True).exclude(db_hide_from_objects=obj))
            else:
                raise CommError
        else:
            # get everything, channel or not
            if typ == 'player':
                return list(self.filter(db_sender_players=obj).exclude(db_hide_from_players=obj))
            elif typ == 'object':
                return list(self.filter(db_sender_objects=obj).exclude(db_hide_from_objects=obj))
            else:
                raise CommError

    def get_messages_by_receiver(self, obj):
        """
        Get all messages sent to one give recipient
        """
        obj, typ = identify_object(obj)
        if typ == 'player':
            return list(self.filter(db_receivers_players=obj).exclude(db_hide_from_players=obj))
        elif typ == 'object':
            return list(self.filter(db_receivers_objects=obj).exclude(db_hide_from_objects=obj))
        elif typ == 'channel':
            return list(self.filter(db_receivers_channels=obj).exclude(db_hide_from_channels=obj))
        else:
            raise CommError

    def get_messages_by_channel(self, channel):
        """
        Get all messages sent to one channel
        """
        return self.filter(db_receivers_channels=channel).exclude(db_hide_from_channels=channel)

    def message_search(self, sender=None, receiver=None, freetext=None, dbref=None):
        """
        Search the message database for particular messages. At least one
        of the arguments must be given to do a search.

        sender - get messages sent by a particular player or object
        receiver - get messages received by a certain player,object or channel
        freetext - Search for a text string in a message.
                   NOTE: This can potentially be slow, so make sure to supply
                   one of the other arguments to limit the search.
        dbref - (int) the exact database id of the message. This will override
                all other search criteria since it's unique and
                always gives a list with only one match.
        """
        # unique msg id
        if dbref:
            msg = self.objects.filter(id=dbref)
            if msg:
                return msg[0]

        # We use Q objects to gradually build up the query - this way we only
        # need to do one database lookup at the end rather than gradually
        # refining with multiple filter:s. Django Note: Q objects can be
        # combined with & and | (=AND,OR). ~ negates the queryset

        # filter by sender
        sender, styp = identify_object(sender)
        if styp == 'player':
            sender_restrict = Q(db_sender_players=sender) & ~Q(db_hide_from_players=sender)
        elif styp == 'object':
            sender_restrict = Q(db_sender_objects=sender) & ~Q(db_hide_from_objects=sender)
        else:
            sender_restrict = Q()
        # filter by receiver
        receiver, rtyp = identify_object(receiver)
        if rtyp == 'player':
            receiver_restrict = Q(db_receivers_players=receiver) & ~Q(db_hide_from_players=receiver)
        elif rtyp == 'object':
            receiver_restrict = Q(db_receivers_objects=receiver) & ~Q(db_hide_from_objects=receiver)
        elif rtyp == 'channel':
            receiver_restrict = Q(db_receivers_channels=receiver) & ~Q(db_hide_from_channels=receiver)
        else:
            receiver_restrict = Q()
        # filter by full text
        if freetext:
            fulltext_restrict = Q(db_header__icontains=freetext) | Q(db_message__icontains=freetext)
        else:
            fulltext_restrict = Q()
        # execute the query
        return list(self.filter(sender_restrict & receiver_restrict & fulltext_restrict))


#
# Channel manager
#

class ChannelManager(models.Manager):
    """
    This ChannelManager implements methods for searching
    and manipulating Channels directly from the database.

    These methods will all return database objects
    (or QuerySets) directly.

    A Channel is an in-game venue for communication. It's
    essentially representation of a re-sender: Users sends
    Messages to the Channel, and the Channel re-sends those
    messages to all users subscribed to the Channel.

    Evennia-specific:
    get_all_channels
    get_channel(channel)
    get_subscriptions(player)
    channel_search (equivalent to ev.search_channel)

    """
    @returns_typeclass_list
    def get_all_channels(self):
        """
        Returns all channels in game.
        """
        return self.all()

    @returns_typeclass
    def get_channel(self, channelkey):
        """
        Return the channel object if given its key.
        Also searches its aliases.
        """
        # first check the channel key
        channels = self.filter(db_key__iexact=channelkey)
        if not channels:
            # also check aliases
            channels = [channel for channel in self.all()
                        if channelkey in channel.aliases.all()]
        if channels:
            return channels[0]
        return None

    @returns_typeclass_list
    def get_subscriptions(self, player):
        """
        Return all channels a given player is subscribed to
        """
        return player.dbobj.subscription_set.all()


#    def del_channel(self, channelkey):
#        """
#        Delete channel matching channelkey.
#        Also cleans up channelhandler.
#        """
#        channels = self.filter(db_key__iexact=channelkey)
#        if not channels:
#            # no aliases allowed for deletion.
#            return False
#        for channel in channels:
#            channel.delete()
#        from src.comms.channelhandler import CHANNELHANDLER
#        CHANNELHANDLER.update()
#        return None

#    def get_all_connections(self, channel, online=False):
#        """
#        Return the connections of all players listening
#        to this channel. If Online is true, it only returns
#        connected players.
#        """
#        global _SESSIONS
#        if not _SESSIONS:
#            from src.server.sessionhandler import SESSIONS as _SESSIONS
#
#        PlayerChannelConnection = ContentType.objects.get(app_label="comms",
#                                                          model="playerchannelconnection").model_class()
#        players = []
#        if online:
#            session_list = _SESSIONS.get_sessions()
#            unique_online_users = set(sess.uid for sess in session_list if sess.logged_in)
#            online_players = (sess.get_player() for sess in session_list if sess.uid in unique_online_users)
#            for player in online_players:
#                players.extend(PlayerChannelConnection.objects.filter(
#                    db_player=player.dbobj, db_channel=channel.dbobj))
#        else:
#            players.extend(PlayerChannelConnection.objects.get_all_connections(channel))
#
#        external_connections = ExternalChannelConnection.objects.get_all_connections(channel)
#
#        return itertools.chain(players, external_connections)

    @returns_typeclass_list
    def channel_search(self, ostring, exact=True):
        """
        Search the channel database for a particular channel.

        ostring - the key or database id of the channel.
        exact - require an exact key match (still not case sensitive)
        """
        channels = []
        if not ostring: return channels
        try:
            # try an id match first
            dbref = int(ostring.strip('#'))
            channels = self.filter(id=dbref)
        except Exception:
            pass
        if not channels:
            # no id match. Search on the key.
            if exact:
                channels = self.filter(db_key__iexact=ostring)
            else:
                channels = self.filter(db_key__icontains=ostring)
        if not channels:
            # still no match. Search by alias.
            channels = [channel for channel in self.all()
                        if ostring.lower() in [a.lower
                            for a in channel.aliases.all()]]
        return channels


#
# PlayerChannelConnection manager
#
class PlayerChannelConnectionManager(models.Manager):
    """
    This PlayerChannelConnectionManager implements methods for searching
    and manipulating PlayerChannelConnections directly from the database.

    These methods will all return database objects
    (or QuerySets) directly.

    A PlayerChannelConnection defines a user's subscription to an in-game
    channel - deleting the connection object will disconnect the player
    from the channel.

    Evennia-specific:
    get_all_player_connections
    has_connection
    get_all_connections
    create_connection
    break_connection

    """
    @returns_typeclass_list
    def get_all_player_connections(self, player):
        "Get all connections that the given player has."
        player = to_object(player)
        return self.filter(db_player=player)

    def has_player_connection(self, player, channel):
        "Checks so a connection exists player<->channel"
        if player and channel:
            return self.filter(db_player=player.dbobj).filter(
                db_channel=channel.dbobj).count() > 0
        return False

    def get_all_connections(self, channel):
        """
        Get all connections for a channel
        """
        channel = to_object(channel, objtype='channel')
        return self.filter(db_channel=channel)

    def create_connection(self, player, channel):
        """
        Connect a player to a channel. player and channel
        can be actual objects or keystrings.
        """
        player = to_object(player)
        channel = to_object(channel, objtype='channel')
        if not player or not channel:
            raise CommError("NOTFOUND")
        new_connection = self.model(db_player=player, db_channel=channel)
        new_connection.save()
        return new_connection

    def break_connection(self, player, channel):
        "Remove link between player and channel"
        player = to_object(player)
        channel = to_object(channel, objtype='channel')
        if not player or not channel:
            raise CommError("NOTFOUND")
        conns = self.filter(db_player=player).filter(db_channel=channel)
        for conn in conns:
            conn.delete()



########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    #depends_on = (
    #    ("players", "0001_initial"),
    #    ("comms", "0001_initial"),
    #)

    def forwards(self, orm):

        # Adding model 'Msg'
        db.create_table('comms_msg', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_sender', self.gf('django.db.models.fields.related.ForeignKey')(related_name='sender_set', to=orm['players.PlayerDB'])),
            ('db_receivers', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('db_channels', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('db_message', self.gf('django.db.models.fields.TextField')()),
            ('db_date_sent', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_hide_from_sender', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('db_hide_from_receivers', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('db_hide_from_channels', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(null=True)),
        ))
        db.send_create_signal('comms', ['Msg'])

        # Adding model 'Channel'
        db.create_table('comms_channel', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('db_desc', self.gf('django.db.models.fields.CharField')(max_length=80, null=True, blank=True)),
            ('db_aliases', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_keep_log', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal('comms', ['Channel'])

        # Adding model 'ChannelConnection'
        db.create_table('comms_channelconnection', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_player', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
            ('db_channel', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.Channel'])),
        ))
        db.send_create_signal('comms', ['ChannelConnection'])


    def backwards(self, orm):

        # Deleting model 'Msg'
        db.delete_table('comms_msg')

        # Deleting model 'Channel'
        db.delete_table('comms_channel')

        # Deleting model 'ChannelConnection'
        db.delete_table('comms_channelconnection')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.channelconnection': {
            'Meta': {'object_name': 'ChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_sender': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sender_set'", 'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0002_auto__del_channelconnection__add_externalchannelconnection__add_player
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ExternalChannelConnection'
        db.create_table('comms_externalchannelconnection', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_channel', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.Channel'])),
            ('db_external_key', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('db_external_path', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('db_external_config', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_is_enabled', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('comms', ['ExternalChannelConnection'])

        db.rename_table('comms_channelconnection', 'comms_playerchannelconnection')
        
        # # Adding model 'PlayerChannelConnection'
        # db.create_table('comms_playerchannelconnection', (
        #     ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        #     ('db_player', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
        #     ('db_channel', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.Channel'])),
        # ))
        # db.send_create_signal('comms', ['PlayerChannelConnection'])

        # # move channelconnections to playerchannelconnections        
        # for conn in orm.ChannelConnection.objects.all():
        #     ncon = orm.PlayerChannelConnection(db_player=conn.db_player, db_channel=conn.db_channel)
        #     ncon.save()

        # db
        # # Deleting model 'ChannelConnection'
        # db.delete_table('comms_channelconnection')

        # Adding field 'Msg.db_sender_external'
        db.add_column('comms_msg', 'db_sender_external', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True), keep_default=False)

        # Changing field 'Msg.db_sender'
        db.alter_column('comms_msg', 'db_sender_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['players.PlayerDB']))


    def backwards(self, orm):
        
        # # Adding model 'ChannelConnection'
        # db.create_table('comms_channelconnection', (
        #     ('db_channel', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.Channel'])),
        #     ('db_player', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
        #     ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        # ))
        # db.send_create_signal('comms', ['ChannelConnection'])

        # 
        db.rename_table('comms_playerchannelconnection', 'comms_channelconnection')

        # Deleting model 'ExternalChannelConnection'
        db.delete_table('comms_externalchannelconnection')

        # # Deleting model 'PlayerChannelConnection'
        # db.delete_table('comms_playerchannelconnection')

        # Deleting field 'Msg.db_sender_external'
        db.delete_column('comms_msg', 'db_sender_external')

        # User chose to not deal with backwards NULL issues for 'Msg.db_sender'
        raise RuntimeError("Cannot reverse this migration. 'Msg.db_sender' and its values cannot be restored.")


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_path': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_sender': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sender_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0003_auto__del_field_externalchannelconnection_db_external_path__add_field_
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'ExternalChannelConnection.db_external_path'
        db.delete_column('comms_externalchannelconnection', 'db_external_path')

        # Adding field 'ExternalChannelConnection.db_external_send_code'
        db.add_column('comms_externalchannelconnection', 'db_external_send_code', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)


    def backwards(self, orm):
        
        # User chose to not deal with backwards NULL issues for 'ExternalChannelConnection.db_external_path'
        raise RuntimeError("Cannot reverse this migration. 'ExternalChannelConnection.db_external_path' and its values cannot be restored.")

        # Deleting field 'ExternalChannelConnection.db_external_send_code'
        db.delete_column('comms_externalchannelconnection', 'db_external_send_code')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_sender': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sender_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0004_changing_lock_comm_admin2control
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    # fixes a changed syntax in the locks.

    def forwards(self, orm):
        "Write your forwards methods here."
        for channel in orm.Channel.objects.all():
            lockstring = channel.db_lock_storage
            lockstring = lockstring.replace("admin:", "control:")
            channel.db_lock_storage = lockstring
            channel.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        for channel in orm.Channel.objects.all():
            lockstring = channel.db_lock_storage
            lockstring = lockstring.replace("control:", "admin:")
            channel.db_lock_storage = lockstring
            channel.save()

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_sender': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sender_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0005_auto__chg_field_channel_db_lock_storage__chg_field_msg_db_lock_storage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'Channel.db_lock_storage'
        db.alter_column('comms_channel', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'Msg.db_lock_storage'
        db.alter_column('comms_msg', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(default='', max_length=512))


    def backwards(self, orm):
        
        # Changing field 'Channel.db_lock_storage'
        db.alter_column('comms_channel', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

        # Changing field 'Msg.db_lock_storage'
        db.alter_column('comms_msg', 'db_lock_storage', self.gf('django.db.models.fields.TextField')(null=True))


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_sender': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sender_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0006_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding index on 'Channel', fields ['db_key']
        db.create_index('comms_channel', ['db_key'])


    def backwards(self, orm):

        # Removing index on 'Channel', fields ['db_key']
        db.delete_index('comms_channel', ['db_key'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_sender': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_sender': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'sender_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0007_upgrading_msgs
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from south import orm

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'Msg.db_hide_from_channels'
        db.delete_column('comms_msg', 'db_hide_from_channels')

        # Deleting field 'Msg.db_hide_from_receivers'
        db.delete_column('comms_msg', 'db_hide_from_receivers')

        # Deleting field 'Msg.db_receivers'
        db.delete_column('comms_msg', 'db_receivers')

        # Deleting field 'Msg.db_channels'
        db.delete_column('comms_msg', 'db_channels')

        # Deleting field 'Msg.db_hide_from_sender'
        db.delete_column('comms_msg', 'db_hide_from_sender')

        # Deleting field 'Msg.db_sender'
        db.delete_column('comms_msg', 'db_sender_id')

        # Adding field 'Msg.db_title'
        db.add_column('comms_msg', 'db_title',
                      self.gf('django.db.models.fields.CharField')(max_length=512, null=True, blank=True),
                      keep_default=False)

        # Adding M2M table for field db_sender_players on 'Msg'
        db.create_table('comms_msg_db_sender_players', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('playerdb', models.ForeignKey(orm['players.playerdb'], null=False))
        ))
        db.create_unique('comms_msg_db_sender_players', ['msg_id', 'playerdb_id'])

        # Adding M2M table for field db_sender_objects on 'Msg'
        db.create_table('comms_msg_db_sender_objects', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('objectdb', models.ForeignKey(orm['objects.objectdb'], null=False))
        ))
        db.create_unique('comms_msg_db_sender_objects', ['msg_id', 'objectdb_id'])

        # Adding M2M table for field db_receivers_players on 'Msg'
        db.create_table('comms_msg_db_receivers_players', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('playerdb', models.ForeignKey(orm['players.playerdb'], null=False))
        ))
        db.create_unique('comms_msg_db_receivers_players', ['msg_id', 'playerdb_id'])

        # Adding M2M table for field db_receivers_objects on 'Msg'
        db.create_table('comms_msg_db_receivers_objects', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('objectdb', models.ForeignKey(orm['objects.objectdb'], null=False))
        ))
        db.create_unique('comms_msg_db_receivers_objects', ['msg_id', 'objectdb_id'])

        # Adding M2M table for field db_receivers_channels on 'Msg'
        db.create_table('comms_msg_db_receivers_channels', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('channel', models.ForeignKey(orm['comms.channel'], null=False))
        ))
        db.create_unique('comms_msg_db_receivers_channels', ['msg_id', 'channel_id'])

        # Adding M2M table for field db_hide_from_players on 'Msg'
        db.create_table('comms_msg_db_hide_from_players', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('playerdb', models.ForeignKey(orm['players.playerdb'], null=False))
        ))
        db.create_unique('comms_msg_db_hide_from_players', ['msg_id', 'playerdb_id'])

        # Adding M2M table for field db_hide_from_objects on 'Msg'
        db.create_table('comms_msg_db_hide_from_objects', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('objectdb', models.ForeignKey(orm['objects.objectdb'], null=False))
        ))
        db.create_unique('comms_msg_db_hide_from_objects', ['msg_id', 'objectdb_id'])

        # Adding M2M table for field db_hide_from_channles on 'Msg'
        db.create_table('comms_msg_db_hide_from_channles', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('msg', models.ForeignKey(orm['comms.msg'], null=False)),
            ('channel', models.ForeignKey(orm['comms.channel'], null=False))
        ))
        db.create_unique('comms_msg_db_hide_from_channles', ['msg_id', 'channel_id'])

        # Adding index on 'Msg', fields ['db_date_sent']
        db.create_index('comms_msg', ['db_date_sent'])

        # Adding index on 'Msg', fields ['db_sender_external']
        db.create_index('comms_msg', ['db_sender_external'])

        # moving data to new fields

        if not db.dry_run:
            if orm["comms.Msg"].objects.count():
                print "deleting old Msgs before migrating ..."
            for msg in orm["comms.Msg"].objects.all():
                msg.delete()

    def backwards(self, orm):
        # Removing index on 'Msg', fields ['db_sender_external']
        db.delete_index('comms_msg', ['db_sender_external'])

        # Removing index on 'Msg', fields ['db_date_sent']
        db.delete_index('comms_msg', ['db_date_sent'])

        # Adding field 'Msg.db_hide_from_channels'
        db.add_column('comms_msg', 'db_hide_from_channels',
                      self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Msg.db_hide_from_receivers'
        db.add_column('comms_msg', 'db_hide_from_receivers',
                      self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Msg.db_receivers'
        db.add_column('comms_msg', 'db_receivers',
                      self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Msg.db_channels'
        db.add_column('comms_msg', 'db_channels',
                      self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Msg.db_hide_from_sender'
        db.add_column('comms_msg', 'db_hide_from_sender',
                      self.gf('django.db.models.fields.BooleanField')(default=False),
                      keep_default=False)

        # Adding field 'Msg.db_sender'
        db.add_column('comms_msg', 'db_sender',
                      self.gf('django.db.models.fields.related.ForeignKey')(related_name='sender_set', null=True, to=orm['players.PlayerDB']),
                      keep_default=False)

        # Deleting field 'Msg.db_title'
        db.delete_column('comms_msg', 'db_title')

        # Removing M2M table for field db_sender_players on 'Msg'
        db.delete_table('comms_msg_db_sender_players')

        # Removing M2M table for field db_sender_objects on 'Msg'
        db.delete_table('comms_msg_db_sender_objects')

        # Removing M2M table for field db_receivers_players on 'Msg'
        db.delete_table('comms_msg_db_receivers_players')

        # Removing M2M table for field db_receivers_objects on 'Msg'
        db.delete_table('comms_msg_db_receivers_objects')

        # Removing M2M table for field db_receivers_channels on 'Msg'
        db.delete_table('comms_msg_db_receivers_channels')

        # Removing M2M table for field db_hide_from_players on 'Msg'
        db.delete_table('comms_msg_db_hide_from_players')

        # Removing M2M table for field db_hide_from_objects on 'Msg'
        db.delete_table('comms_msg_db_hide_from_objects')

        # Removing M2M table for field db_hide_from_channles on 'Msg'
        db.delete_table('comms_msg_db_hide_from_channles')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_hide_from_channles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_title': ('django.db.models.fields.CharField', [], {'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0008_renamed_title_to_header
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Renaming field 'Msg.db_title' to 'Msg.db_header'
        db.rename_column('comms_msg', 'db_title', 'db_header')

    def backwards(self, orm):
        # Adding field 'Msg.db_title'
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.CharField', [], {'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_hide_from_channles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0009_auto__chg_field_channel_db_lock_storage__chg_field_msg_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Channel.db_lock_storage'
        db.alter_column('comms_channel', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

        # Changing field 'Msg.db_lock_storage'
        db.alter_column('comms_msg', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'Channel.db_lock_storage'
        db.alter_column('comms_channel', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'Msg.db_lock_storage'
        db.alter_column('comms_msg', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.CharField', [], {'max_length': 128, 'null': 'True', 'blank': 'True'}),
            'db_hide_from_channles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0010_auto__chg_field_msg_db_header
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Msg.db_header'
        db.alter_column('comms_msg', 'db_header', self.gf('django.db.models.fields.TextField')(null=True))


    def backwards(self, orm):

        # Changing field 'Msg.db_header'
        db.alter_column('comms_msg', 'db_header', self.gf('django.db.models.fields.CharField')(max_length=128, null=True))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': "orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': "orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0011_renaming_channles_to_channels
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Renaming M2M table for field db_hide_from_channles on 'Msg'
        db.rename_table('comms_msg_db_hide_from_channles', 'comms_msg_db_hide_from_channels')

    def backwards(self, orm):
        raise RuntimeException("Cannot revert this migration.")


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0012_auto__add_interimchannel
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'InterimChannel'
        db.create_table(u'comms_interimchannel', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_typeclass_path', self.gf('django.db.models.fields.CharField')(max_length=255, null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal(u'comms', ['InterimChannel'])

        # Adding M2M table for field db_attributes on 'InterimChannel'
        m2m_table_name = db.shorten_name(u'comms_interimchannel_db_attributes')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('interimchannel', models.ForeignKey(orm[u'comms.interimchannel'], null=False)),
            ('attribute', models.ForeignKey(orm[u'typeclasses.attribute'], null=False))
        ))
        db.create_unique(m2m_table_name, ['interimchannel_id', 'attribute_id'])

        # Adding M2M table for field db_tags on 'InterimChannel'
        m2m_table_name = db.shorten_name(u'comms_interimchannel_db_tags')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('interimchannel', models.ForeignKey(orm[u'comms.interimchannel'], null=False)),
            ('tag', models.ForeignKey(orm[u'typeclasses.tag'], null=False))
        ))
        db.create_unique(m2m_table_name, ['interimchannel_id', 'tag_id'])


    def backwards(self, orm):
        # Deleting model 'InterimChannel'
        db.delete_table(u'comms_interimchannel')

        # Removing M2M table for field db_attributes on 'InterimChannel'
        db.delete_table(db.shorten_name(u'comms_interimchannel_db_attributes'))

        # Removing M2M table for field db_tags on 'InterimChannel'
        db.delete_table(db.shorten_name(u'comms_interimchannel_db_tags'))


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.interimchannel': {
            'Meta': {'ordering': "['-db_date_created', 'id', 'db_typeclass_path', 'db_key']", 'object_name': 'InterimChannel'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
########NEW FILE########
__FILENAME__ = 0013_rename_channel
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        db.rename_table('comms_channel', 'comms_channeldb')
        db.rename_column('comms_msg_db_hide_from_channels', 'channel_id', 'channeldb_id')
        db.rename_column('comms_msg_db_receivers_channels', 'channel_id', 'channeldb_id')

    def backwards(self, orm):
        db.rename_table('comms_channeldb', 'comms_channel')
        db.rename_column('comms_msg_db_hide_from_channels', 'channeldb_id', 'channel_id')
        db.rename_column('comms_msg_db_receivers_channels', 'channeldb_id', 'channel_id')

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channel': {
            'Meta': {'object_name': 'Channel'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.Channel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.Channel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.Channel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.Channel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
########NEW FILE########
__FILENAME__ = 0014_transfer_channels
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        ChannelDB = orm['comms.ChannelDB']
        InterimChannel = orm['comms.InterimChannel']
        Attribute = orm['typeclasses.Attribute']
        Tag = orm['typeclasses.Tag']
        for channel in ChannelDB.objects.all():
            new_channel = InterimChannel(id=channel.id, db_key=channel.db_key,
                db_lock_storage=channel.db_lock_storage)
            new_channel.save()
            desc = Attribute(db_key='desc', db_value=channel.db_desc)
            desc.save()
            keep_log = Attribute(db_key='keep_log',
                db_value=channel.db_keep_log)
            keep_log.save()
            new_channel.db_attributes.add(desc)
            new_channel.db_attributes.add(keep_log)
            for name in [alias.strip() for alias in
                    channel.db_aliases.split(',')]:
                tag = Tag.objects.filter(db_key=name.lower().strip(), db_category='comm_alias')
                if tag:
                    tag = tag[0]
                else:
                   tag = Tag(db_key=name.lower().strip(), db_category='comm_alias')
                   tag.save()
                new_channel.db_tags.add(tag)
            new_channel.save()
        orm['contenttypes.ContentType'].objects.filter(
            app_label='comms', model='channel').update(model='channeldb', name='ChannelDB')

    def backwards(self, orm):
        "Remove all InterimChannels."
        orm['comms.InterimChannel'].objects.all().delete()

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_aliases': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '80', 'null': 'True', 'blank': 'True'}),
            'db_keep_log': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.interimchannel': {
            'Meta': {'ordering': "['-db_date_created', 'id', 'db_typeclass_path', 'db_key']", 'object_name': 'InterimChannel'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0015_update_foreign_keys_remove_old_channels
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Changing field 'ExternalChannelConnection.db_channel'
        db.alter_column(u'comms_externalchannelconnection', 'db_channel_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.InterimChannel']))

        # Changing field 'PlayerChannelConnection.db_channel'
        db.alter_column(u'comms_playerchannelconnection', 'db_channel_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.InterimChannel']))

        # Deleting model 'ChannelDB'
        db.delete_table(u'comms_channeldb')

    def backwards(self, orm):
        # Adding model 'ChannelDB'
        db.create_table(u'comms_channeldb', (
            ('db_desc', self.gf('django.db.models.fields.CharField')(max_length=80, null=True, blank=True)),
            ('db_aliases', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, unique=True, db_index=True)),
            ('db_keep_log', self.gf('django.db.models.fields.BooleanField')(default=True)),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal(u'comms', ['ChannelDB'])

        InterimChannel = orm['comms.InterimTable']
        Attribute = orm['typeclasses.Attribute']
        ChannelDB = orm['comms.ChannelDB']

        for channel in InterimChannel.objects.all():
            try:
                desc = channel.db_attributes.objects.get(db_key='desc').db_value
            except Attribute.DoesNotExist:
                desc = ''
            try:
                keep_log = channel.db_attributes.objects.get(
                    db_key='keep_log').db_value
            except Attribute.DoesNotExist:
                keep_log = False
            aliases = [alias.db_key for alias in
                       channel.db_tags.filter('comm_alias')]
            aliases = ','.join(aliases)
            new_channel = ChannelDB(db_desc=desc, db_keep_log=False, id=channel.id,
                db_key=channel.db_key, db_lock_storage=channel.db_lock_storage,
                db_aliases=aliases)
            new_channel.save()


        # Changing field 'ExternalChannelConnection.db_channel'
        db.alter_column(u'comms_externalchannelconnection', 'db_channel_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.ChannelDB']))

        # Changing field 'PlayerChannelConnection.db_channel'
        db.alter_column(u'comms_playerchannelconnection', 'db_channel_id', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.ChannelDB']))

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.InterimChannel']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.interimchannel': {
            'Meta': {'object_name': 'InterimChannel'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.InterimChannel']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.InterimChannel']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.InterimChannel']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
########NEW FILE########
__FILENAME__ = 0016_finalize_tables
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName". 
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        db.rename_table('comms_interimchannel', 'comms_channeldb')
        db.rename_table('comms_interimchannel_db_attributes', 'comms_channeldb_db_attributes')
        db.rename_table('comms_interimchannel_db_tags', 'comms_channeldb_db_tags')
        db.rename_column('comms_channeldb_db_attributes', 'interimchannel_id', 'channeldb_id')
        db.rename_column('comms_channeldb_db_tags', 'interimchannel_id', 'channeldb_id')


    def backwards(self, orm):
        "Write your backwards methods here."
        db.rename_column('comms_channeldb_db_attributes', 'channeldb_id', 'interimchannel_id')
        db.rename_column('comms_channeldb_db_tags', 'channeldb_id', 'interimchannel_id')
        db.rename_table('comms_channeldb', 'comms_interimchannel')
        db.rename_table('comms_channeldb_db_attributes', 'comms_interimchannel_db_attributes')
        db.rename_table('comms_channeldb_db_tags', 'comms_interimchannel_db_tags')

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.interimchannel': {
            'Meta': {'object_name': 'InterimChannel'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0017_renaming_typeclass_from_comm_to_channel
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        for ch in orm.ChannelDB.objects.all():
            if ch.db_typeclass_path == u"src.comms.comms.Comm":
                ch.db_typeclass_path = "src.comms.comms.Channel"
                ch.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration.")

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0018_add_subscribers_m2mfield
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding M2M table for field db_subscriptions on 'ChannelDB'
        m2m_table_name = db.shorten_name(u'comms_channeldb_db_subscriptions')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('channeldb', models.ForeignKey(orm[u'comms.channeldb'], null=False)),
            ('playerdb', models.ForeignKey(orm[u'players.playerdb'], null=False))
        ))
        db.create_unique(m2m_table_name, ['channeldb_id', 'playerdb_id'])


    def backwards(self, orm):
        # Removing M2M table for field db_subscriptions on 'ChannelDB'
        db.delete_table(db.shorten_name(u'comms_channeldb_db_subscriptions'))


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subscriber_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']

########NEW FILE########
__FILENAME__ = 0019_converting_playerconnection_to_m2m
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.

        for connection in orm['comms.PlayerChannelConnection'].objects.all():
            channel, player = connection.db_channel, connection.db_player
            channel.db_subscriptions.add(player)

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration.")

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subscriber_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0020_auto__del_playerchannelconnection
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'PlayerChannelConnection'
        db.delete_table(u'comms_playerchannelconnection')


    def backwards(self, orm):
        # Adding model 'PlayerChannelConnection'
        db.create_table(u'comms_playerchannelconnection', (
            ('db_channel', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.ChannelDB'])),
            ('db_player', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal(u'comms', ['PlayerChannelConnection'])


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subscription_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
########NEW FILE########
__FILENAME__ = 0021_auto__del_externalchannelconnection
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'ExternalChannelConnection'
        db.delete_table(u'comms_externalchannelconnection')


    def backwards(self, orm):
        # Adding model 'ExternalChannelConnection'
        db.create_table(u'comms_externalchannelconnection', (
            ('db_external_config', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_external_key', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('db_channel', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['comms.ChannelDB'])),
            ('db_is_enabled', self.gf('django.db.models.fields.BooleanField')(default=True)),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_external_send_code', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal(u'comms', ['ExternalChannelConnection'])


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_subscriptions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subscription_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_bot': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['comms']
########NEW FILE########
__FILENAME__ = models
"""
Models for the comsystem. The Commsystem is intended to be
used by Players (thematic IC communication is probably
best handled by custom commands instead).

The comm system could take the form of channels, but can also
be adopted for storing tells or in-game mail.

The comsystem's main component is the Message (Msg), which
carries the actual information between two parties.
Msgs are stored in the database and usually not
deleted.
A Msg always have one sender (a user), but can have
any number targets, both users and channels.

Channels are central objects that act as targets for
Msgs. Players can connect to channels by use of a
ChannelConnect object (this object is necessary to easily
be able to delete connections on the fly).
"""

from datetime import datetime
from django.conf import settings
from django.db import models
from src.typeclasses.models import TypedObject, TagHandler, AttributeHandler, AliasHandler
from src.utils.idmapper.models import SharedMemoryModel
from src.comms import managers
from src.comms.managers import identify_object
from src.locks.lockhandler import LockHandler
from src.utils.utils import crop, make_iter

__all__ = ("Msg", "TempMsg", "ChannelDB")


_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__


#------------------------------------------------------------
#
# Msg
#
#------------------------------------------------------------

class Msg(SharedMemoryModel):
    """
    A single message. This model describes all ooc messages
    sent in-game, both to channels and between players.

    The Msg class defines the following properties:
      sender - sender of message
      receivers - list of target objects for message
      channels - list of channels message was sent to
      message - the text being sent
      date_sent - time message was sent
      hide_from_sender - bool if message should be hidden from sender
      hide_from_receivers - list of receiver objects to hide message from
      hide_from_channels - list of channels objects to hide message from
      permissions - perm strings

    """
    #
    # Msg database model setup
    #
    #
    # These databse fields are all set using their corresponding properties,
    # named same as the field, but withtout the db_* prefix.

    # Sender is either a player, an object or an external sender, like
    # an IRC channel; normally there is only one, but if co-modification of
    # a message is allowed, there may be more than one "author"
    db_sender_players = models.ManyToManyField("players.PlayerDB", related_name='sender_player_set', null=True, verbose_name='sender(player)', db_index=True)
    db_sender_objects = models.ManyToManyField("objects.ObjectDB", related_name='sender_object_set', null=True, verbose_name='sender(object)', db_index=True)
    db_sender_external = models.CharField('external sender', max_length=255, null=True, db_index=True,
          help_text="identifier for external sender, for example a sender over an IRC connection (i.e. someone who doesn't have an exixtence in-game).")
    # The destination objects of this message. Stored as a
    # comma-separated string of object dbrefs. Can be defined along
    # with channels below.
    db_receivers_players = models.ManyToManyField('players.PlayerDB', related_name='receiver_player_set', null=True, help_text="player receivers")
    db_receivers_objects = models.ManyToManyField('objects.ObjectDB', related_name='receiver_object_set', null=True, help_text="object receivers")
    db_receivers_channels = models.ManyToManyField("ChannelDB", related_name='channel_set', null=True, help_text="channel recievers")

    # header could be used for meta-info about the message if your system needs
    # it, or as a separate store for the mail subject line maybe.
    db_header = models.TextField('header', null=True, blank=True)
    # the message body itself
    db_message = models.TextField('messsage')
    # send date
    db_date_sent = models.DateTimeField('date sent', editable=False, auto_now_add=True, db_index=True)
    # lock storage
    db_lock_storage = models.TextField('locks', blank=True,
                                       help_text='access locks on this message.')

    # these can be used to filter/hide a given message from supplied objects/players/channels
    db_hide_from_players = models.ManyToManyField("players.PlayerDB", related_name='hide_from_players_set', null=True)
    db_hide_from_objects = models.ManyToManyField("objects.ObjectDB", related_name='hide_from_objects_set', null=True)
    db_hide_from_channels = models.ManyToManyField("ChannelDB", related_name='hide_from_channels_set', null=True)

    # Database manager
    objects = managers.MsgManager()

    def __init__(self, *args, **kwargs):
        SharedMemoryModel.__init__(self, *args, **kwargs)
        self.locks = LockHandler(self)
        self.extra_senders = []

    class Meta:
        "Define Django meta options"
        verbose_name = "Message"

    # Wrapper properties to easily set database fields. These are
    # @property decorators that allows to access these fields using
    # normal python operations (without having to remember to save()
    # etc). So e.g. a property 'attr' has a get/set/del decorator
    # defined that allows the user to do self.attr = value,
    # value = self.attr and del self.attr respectively (where self
    # is the object in question).

    # sender property (wraps db_sender_*)
    #@property
    def __senders_get(self):
        "Getter. Allows for value = self.sender"
        return [hasattr(o, "typeclass") and o.typeclass or o for o in
                list(self.db_sender_players.all()) +
                list(self.db_sender_objects.all()) +
                self.extra_senders]

    #@sender.setter
    def __senders_set(self, value):
        "Setter. Allows for self.sender = value"
        for val in (v for v in make_iter(value) if v):
            obj, typ = identify_object(val)
            if typ == 'player':
                self.db_sender_players.add(obj)
            elif typ == 'object':
                self.db_sender_objects.add(obj)
            elif isinstance(typ, basestring):
                self.db_sender_external = obj
            elif not obj:
                return
            else:
                raise ValueError(obj)
            self.save()

    #@sender.deleter
    def __senders_del(self):
        "Deleter. Clears all senders"
        self.db_sender_players.clear()
        self.db_sender_objects.clear()
        self.db_sender_external = ""
        self.extra_senders = []
        self.save()
    senders = property(__senders_get, __senders_set, __senders_del)

    def remove_sender(self, value):
        "Remove a single sender or a list of senders"
        for val in make_iter(value):
            obj, typ = identify_object(val)
            if typ == 'player':
                self.db_sender_players.remove(obj)
            elif typ == 'object':
                self.db_sender_objects.remove(obj)
            elif isinstance(obj, basestring):
                self.db_sender_external = obj
            else:
                raise ValueError(obj)
            self.save()

    # receivers property
    #@property
    def __receivers_get(self):
        """
        Getter. Allows for value = self.receivers.
        Returns three lists of receivers: players, objects and channels.
        """
        return [hasattr(o, "typeclass") and o.typeclass or o for o in
                list(self.db_receivers_players.all()) + list(self.db_receivers_objects.all())]

    #@receivers.setter
    def __receivers_set(self, value):
        """
        Setter. Allows for self.receivers = value.
        This appends a new receiver to the message.
        """
        for val in (v for v in make_iter(value) if v):
            obj, typ = identify_object(val)
            if typ == 'player':
                self.db_receivers_players.add(obj)
            elif typ == 'object':
                self.db_receivers_objects.add(obj)
            elif not obj:
                return
            else:
                raise ValueError
            self.save()

    #@receivers.deleter
    def __receivers_del(self):
        "Deleter. Clears all receivers"
        self.db_receivers_players.clear()
        self.db_receivers_objects.clear()
        self.extra_senders = []
        self.save()
    receivers = property(__receivers_get, __receivers_set, __receivers_del)

    def remove_receiver(self, obj):
        "Remove a single recevier"
        obj, typ = identify_object(obj)
        if typ == 'player':
            self.db_receivers_players.remove(obj)
        elif typ == 'object':
            self.db_receivers_objects.remove(obj)
        else:
            raise ValueError
        self.save()

    # channels property
    #@property
    def __channels_get(self):
        "Getter. Allows for value = self.channels. Returns a list of channels."
        return self.db_receivers_channels.all()

    #@channels.setter
    def __channels_set(self, value):
        """
        Setter. Allows for self.channels = value.
        Requires a channel to be added."""
        for val in (v.dbobj for v in make_iter(value) if v):
            self.db_receivers_channels.add(val)

    #@channels.deleter
    def __channels_del(self):
        "Deleter. Allows for del self.channels"
        self.db_receivers_channels.clear()
        self.save()
    channels = property(__channels_get, __channels_set, __channels_del)

    def __hide_from_get(self):
        """
        Getter. Allows for value = self.hide_from.
        Returns 3 lists of players, objects and channels
        """
        return self.db_hide_from_players.all(), self.db_hide_from_objects.all(), self.db_hide_from_channels.all()

    #@hide_from_sender.setter
    def __hide_from_set(self, value):
        "Setter. Allows for self.hide_from = value. Will append to hiders"
        obj, typ = identify_object(value)
        if typ == "player":
            self.db_hide_from_players.add(obj)
        elif typ == "object":
            self.db_hide_from_objects.add(obj)
        elif typ == "channel":
            self.db_hide_from_channels.add(obj)
        else:
            raise ValueError
        self.save()

    #@hide_from_sender.deleter
    def __hide_from_del(self):
        "Deleter. Allows for del self.hide_from_senders"
        self.db_hide_from_players.clear()
        self.db_hide_from_objects.clear()
        self.db_hide_from_channels.clear()
        self.save()
    hide_from = property(__hide_from_get, __hide_from_set, __hide_from_del)

    #
    # Msg class methods
    #

    def __str__(self):
        "This handles what is shown when e.g. printing the message"
        senders = ",".join(obj.key for obj in self.senders)
        receivers = ",".join(["[%s]" % obj.key for obj in self.channels] + [obj.key for obj in self.receivers])
        return "%s->%s: %s" % (senders, receivers, crop(self.message, width=40))


#------------------------------------------------------------
#
# TempMsg
#
#------------------------------------------------------------

class TempMsg(object):
    """
    This is a non-persistent object for sending
    temporary messages that will not be stored.
    It mimics the "real" Msg object, but don't require
    sender to be given.
    """
    def __init__(self, senders=None, receivers=None, channels=None, message="", header="", type="", lockstring="", hide_from=None):
        self.senders = senders and make_iter(senders) or []
        self.receivers = receivers and make_iter(receivers) or []
        self.channels = channels and make_iter(channels) or []
        self.type = type
        self.header = header
        self.message = message
        self.lock_storage = lockstring
        self.locks = LockHandler(self)
        self.hide_from = hide_from and make_iter(hide_from) or []
        self.date_sent = datetime.now()

    def __str__(self):
        "This handles what is shown when e.g. printing the message"
        senders = ",".join(obj.key for obj in self.senders)
        receivers = ",".join(["[%s]" % obj.key for obj in self.channels] + [obj.key for obj in self.receivers])
        return "%s->%s: %s" % (senders, receivers, crop(self.message, width=40))

    def remove_sender(self, obj):
        "Remove a sender or a list of senders"
        for o in make_iter(obj):
            try:
                self.senders.remove(o)
            except ValueError:
                pass  # nothing to remove

    def remove_receiver(self, obj):
        "Remove a sender or a list of senders"
        for o in make_iter(obj):
            try:
                self.senders.remove(o)
            except ValueError:
                pass  # nothing to remove

    def access(self, accessing_obj, access_type='read', default=False):
        "checks lock access"
        return self.locks.check(accessing_obj,
                                access_type=access_type, default=default)


#------------------------------------------------------------
#
# Channel
#
#------------------------------------------------------------

class ChannelDB(TypedObject):
    """
    This is the basis of a comm channel, only implementing
    the very basics of distributing messages.

    The Channel class defines the following properties:
      key - main name for channel
      desc - optional description of channel
      aliases - alternative names for the channel
      keep_log - bool if the channel should remember messages
      permissions - perm strings

    """
    db_subscriptions = models.ManyToManyField("players.PlayerDB",
                       related_name="subscription_set", null=True, verbose_name='subscriptions', db_index=True)

    # Database manager
    objects = managers.ChannelManager()

    _typeclass_paths = settings.CHANNEL_TYPECLASS_PATHS
    _default_typeclass_path = settings.BASE_CHANNEL_TYPECLASS or "src.comms.comms.Channel"

    def __init__(self, *args, **kwargs):
        TypedObject.__init__(self, *args, **kwargs)
        _SA(self, "tags", TagHandler(self))
        _SA(self, "attributes", AttributeHandler(self))
        _SA(self, "aliases", AliasHandler(self))

    class Meta:
        "Define Django meta options"
        verbose_name = "Channel"
        verbose_name_plural = "Channels"

    #
    # Channel class methods
    #

    def __str__(self):
        return "Channel '%s' (%s)" % (self.key, self.typeclass.db.desc)

    def has_connection(self, player):
        """
        Checks so this player is actually listening
        to this channel.
        """
        if hasattr(player, "player"):
            player = player.player
        player = player.dbobj
        return player in self.db_subscriptions.all()

    def connect(self, player):
        "Connect the user to this channel. This checks access."
        if hasattr(player, "player"):
            player = player.player
        player = player.typeclass
        # check access
        if not self.access(player, 'listen'):
            return False
        # pre-join hook
        connect = self.typeclass.pre_join_channel(player)
        if not connect:
            return False
        # subscribe
        self.db_subscriptions.add(player.dbobj)
        # post-join hook
        self.typeclass.post_join_channel(player)
        return True

    def disconnect(self, player):
        "Disconnect user from this channel."
        if hasattr(player, "player"):
            player = player.player
        player = player.typeclass
        # pre-disconnect hook
        disconnect = self.typeclass.pre_leave_channel(player)
        if not disconnect:
            return False
        # disconnect
        self.db_subscriptions.remove(player)
        # post-disconnect hook
        self.typeclass.post_leave_channel(player.dbobj)
        return True

    def access(self, accessing_obj, access_type='listen', default=False):
        """
        Determines if another object has permission to access.
        accessing_obj - object trying to access this one
        access_type - type of access sought
        default - what to return if no lock of access_type was found
        """
        return self.locks.check(accessing_obj, access_type=access_type, default=default)

    def delete(self):
        """
        Deletes channel while also cleaning up channelhandler
        """
        _GA(self, "attributes").clear()
        _GA(self, "aliases").clear()
        super(ChannelDB, self).delete()
        from src.comms.channelhandler import CHANNELHANDLER
        CHANNELHANDLER.update()

########NEW FILE########
__FILENAME__ = admin
"""
This defines how to edit help entries in Admin.
"""
from django import forms
from django.contrib import admin
from src.help.models import HelpEntry



class HelpEntryForm(forms.ModelForm):
    "Defines how to display the help entry"
    class Meta:
        model = HelpEntry
    db_help_category = forms.CharField(label="Help category", initial='General',
                                       help_text="organizes help entries in lists")
    db_lock_storage = forms.CharField(label="Locks", initial='view:all()',required=False,
                                      widget=forms.TextInput(attrs={'size':'40'}),)

class HelpEntryAdmin(admin.ModelAdmin):
    "Sets up the admin manaager for help entries"

    list_display = ('id', 'db_key', 'db_help_category', 'db_lock_storage')
    list_display_links = ('id', 'db_key')
    search_fields = ['^db_key', 'db_entrytext']
    ordering = ['db_help_category', 'db_key']
    save_as = True
    save_on_top = True
    list_select_related = True

    form = HelpEntryForm
    fieldsets = (
        (None, {'fields':(('db_key', 'db_help_category'),
                           'db_entrytext', 'db_lock_storage'),
                'description':"Sets a Help entry. Set lock to <i>view:all()</I> unless you want to restrict it."}),)


admin.site.register(HelpEntry, HelpEntryAdmin)

########NEW FILE########
__FILENAME__ = manager
"""
Custom manager for HelpEntry objects.
"""
from django.db import models
from src.utils import logger, utils
__all__ = ("HelpEntryManager",)


class HelpEntryManager(models.Manager):
    """
    This HelpEntryManager implements methods for searching
    and manipulating HelpEntries directly from the database.

    These methods will all return database objects
    (or QuerySets) directly.

    Evennia-specific:
    find_topicmatch
    find_apropos
    find_topicsuggestions
    find_topics_with_category
    all_to_category
    search_help (equivalent to ev.search_helpentry)

    """
    def find_topicmatch(self, topicstr, exact=False):
        """
        Searches for matching topics based on player's input.
        """
        dbref = utils.dbref(topicstr)
        if dbref:
            return self.filter(id=dbref)
        topics = self.filter(db_key__iexact=topicstr)
        if not topics and not exact:
            topics = self.filter(db_key__istartswith=topicstr)
            if not topics:
                topics = self.filter(db_key__icontains=topicstr)
        return topics

    def find_apropos(self, topicstr):
        """
        Do a very loose search, returning all help entries containing
        the search criterion in their titles.
        """
        return self.filter(db_key__icontains=topicstr)

    def find_topicsuggestions(self, topicstr):
        """
        Do a fuzzy match, preferably within the category of the
        current topic.
        """
        return self.filter(db_key__icontains=topicstr).exclude(db_key__iexact=topicstr)

    def find_topics_with_category(self, help_category):
        """
        Search topics having a particular category
        """
        return self.filter(db_help_category__iexact=help_category)

    def get_all_topics(self):
        """
        Return all topics.
        """
        return self.all()

    def get_all_categories(self, pobject):
        """
        Return all defined category names with at least one
        topic in them.
        """
        return list(set(topic.help_category for topic in self.all()))

    def all_to_category(self, default_category):
        """
        Shifts all help entries in database to default_category.
        This action cannot be reverted. It is used primarily by
        the engine when importing a default help database, making
        sure this ends up in one easily separated category.
        """
        topics = self.all()
        for topic in topics:
            topic.help_category = default_category
            topic.save()
        string = "Help database moved to category %s" % default_category
        logger.log_infomsg(string)

    def search_help(self, ostring, help_category=None):
        """
        Retrieve a search entry object.

        ostring - the help topic to look for
        category - limit the search to a particular help topic
        """
        ostring = ostring.strip().lower()
        if help_category:
            return self.filter(db_key__iexact=ostring,
                               db_help_category__iexact=help_category)
        else:
            return self.filter(db_key__iexact=ostring)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'HelpEntry'
        db.create_table('help_helpentry', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('db_help_category', self.gf('django.db.models.fields.CharField')(default='General', max_length=255)),
            ('db_entrytext', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_permissions', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_staff_only', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('help', ['HelpEntry'])


    def backwards(self, orm):
        
        # Deleting model 'HelpEntry'
        db.delete_table('help_helpentry')


    models = {
        'help.helpentry': {
            'Meta': {'object_name': 'HelpEntry'},
            'db_entrytext': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_help_category': ('django.db.models.fields.CharField', [], {'default': "'General'", 'max_length': '255'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_staff_only': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['help']

########NEW FILE########
__FILENAME__ = 0002_auto__chg_field_helpentry_db_lock_storage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'HelpEntry.db_lock_storage'
        db.alter_column('help_helpentry', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))


    def backwards(self, orm):
        
        # Changing field 'HelpEntry.db_lock_storage'
        db.alter_column('help_helpentry', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())


    models = {
        'help.helpentry': {
            'Meta': {'object_name': 'HelpEntry'},
            'db_entrytext': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_help_category': ('django.db.models.fields.CharField', [], {'default': "'General'", 'max_length': '255'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_staff_only': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['help']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_helpentry_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'HelpEntry.db_lock_storage'
        db.alter_column('help_helpentry', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'HelpEntry.db_lock_storage'
        db.alter_column('help_helpentry', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'help.helpentry': {
            'Meta': {'object_name': 'HelpEntry'},
            'db_entrytext': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_help_category': ('django.db.models.fields.CharField', [], {'default': "'General'", 'max_length': '255'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_staff_only': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['help']
########NEW FILE########
__FILENAME__ = 0004_auto__del_field_helpentry_db_permissions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'HelpEntry.db_permissions'
        db.delete_column(u'help_helpentry', 'db_permissions')

        # Adding M2M table for field db_tags on 'HelpEntry'
        m2m_table_name = db.shorten_name(u'help_helpentry_db_tags')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('helpentry', models.ForeignKey(orm[u'help.helpentry'], null=False)),
            ('tag', models.ForeignKey(orm[u'typeclasses.tag'], null=False))
        ))
        db.create_unique(m2m_table_name, ['helpentry_id', 'tag_id'])


    def backwards(self, orm):
        # Adding field 'HelpEntry.db_permissions'
        db.add_column(u'help_helpentry', 'db_permissions',
                      self.gf('django.db.models.fields.CharField')(default='', max_length=255, blank=True),
                      keep_default=False)

        # Removing M2M table for field db_tags on 'HelpEntry'
        db.delete_table(db.shorten_name(u'help_helpentry_db_tags'))


    models = {
        u'help.helpentry': {
            'Meta': {'object_name': 'HelpEntry'},
            'db_entrytext': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_help_category': ('django.db.models.fields.CharField', [], {'default': "'General'", 'max_length': '255'}),
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_staff_only': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['help']
########NEW FILE########
__FILENAME__ = models
"""
Models for the help system.

The database-tied help system is only half of Evennia's help
functionality, the other one being the auto-generated command help
that is created on the fly from each command's __doc__ string. The
persistent database system defined here is intended for all other
forms of help that do not concern commands, like information about the
game world, policy info, rules and similar.

"""
from django.db import models
from src.utils.idmapper.models import SharedMemoryModel
from src.help.manager import HelpEntryManager
from src.typeclasses.models import Tag, TagHandler
from src.locks.lockhandler import LockHandler
__all__ = ("HelpEntry",)


#------------------------------------------------------------
#
# HelpEntry
#
#------------------------------------------------------------

class HelpEntry(SharedMemoryModel):
    """
    A generic help entry.

    An HelpEntry object has the following properties defined:
      key - main name of entry
      help_category - which category entry belongs to (defaults to General)
      entrytext - the actual help text
      permissions - perm strings

    Method:
      access

    """

    #
    # HelpEntry Database Model setup
    #
    #
    # These database fields are all set using their corresponding properties,
    # named same as the field, but withtout the db_* prefix.

    # title of the help entry
    db_key = models.CharField('help key', max_length=255, unique=True, help_text='key to search for')
    # help category
    db_help_category = models.CharField("help category", max_length=255, default="General",
        help_text='organizes help entries in lists')
    # the actual help entry text, in any formatting.
    db_entrytext = models.TextField('help entry', blank=True, help_text='the main body of help text')
    # lock string storage
    db_lock_storage = models.TextField('locks', blank=True, help_text='normally view:all().')
    # tags are primarily used for permissions
    db_tags = models.ManyToManyField(Tag, null=True,
            help_text='tags on this object. Tags are simple string markers to identify, group and alias objects.')
    # (deprecated, only here to allow MUX helpfile load (don't use otherwise)).
    # TODO: remove this when not needed anymore.
    db_staff_only = models.BooleanField(default=False)

    # Database manager
    objects = HelpEntryManager()

    def __init__(self, *args, **kwargs):
        SharedMemoryModel.__init__(self, *args, **kwargs)
        self.locks = LockHandler(self)
        self.tags = TagHandler(self)

    class Meta:
        "Define Django meta options"
        verbose_name = "Help Entry"
        verbose_name_plural = "Help Entries"

    # Wrapper properties to easily set database fields. These are
    # @property decorators that allows to access these fields using
    # normal python operations (without having to remember to save()
    # etc). So e.g. a property 'attr' has a get/set/del decorator
    # defined that allows the user to do self.attr = value,
    # value = self.attr and del self.attr respectively (where self
    # is the object in question).

    # key property (wraps db_key)
    #@property
    #def __key_get(self):
    #    "Getter. Allows for value = self.key"
    #    return self.db_key
    ##@key.setter
    #def __key_set(self, value):
    #    "Setter. Allows for self.key = value"
    #    self.db_key = value
    #    self.save()
    ##@key.deleter
    #def __key_del(self):
    #    "Deleter. Allows for del self.key. Deletes entry."
    #    self.delete()
    #key = property(__key_get, __key_set, __key_del)

    ## help_category property (wraps db_help_category)
    ##@property
    #def __help_category_get(self):
    #    "Getter. Allows for value = self.help_category"
    #    return self.db_help_category
    ##@help_category.setter
    #def __help_category_set(self, value):
    #    "Setter. Allows for self.help_category = value"
    #    self.db_help_category = value
    #    self.save()
    ##@help_category.deleter
    #def __help_category_del(self):
    #    "Deleter. Allows for del self.help_category"
    #    self.db_help_category = "General"
    #    self.save()
    #help_category = property(__help_category_get, __help_category_set, __help_category_del)

    ## entrytext property (wraps db_entrytext)
    ##@property
    #def __entrytext_get(self):
    #    "Getter. Allows for value = self.entrytext"
    #    return self.db_entrytext
    ##@entrytext.setter
    #def __entrytext_set(self, value):
    #    "Setter. Allows for self.entrytext = value"
    #    self.db_entrytext = value
    #    self.save()
    ##@entrytext.deleter
    #def __entrytext_del(self):
    #    "Deleter. Allows for del self.entrytext"
    #    self.db_entrytext = ""
    #    self.save()
    #entrytext = property(__entrytext_get, __entrytext_set, __entrytext_del)

    ## permissions property
    ##@property
    #def __permissions_get(self):
    #    "Getter. Allows for value = self.permissions. Returns a list of permissions."
    #    return [perm.strip() for perm in self.db_permissions.split(',')]
    ##@permissions.setter
    #def __permissions_set(self, value):
    #    "Setter. Allows for self.permissions = value. Stores as a comma-separated string."
    #    if is_iter(value):
    #        value = ",".join([str(val).strip().lower() for val in value])
    #    self.db_permissions = value
    #    self.save()
    ##@permissions.deleter
    #def __permissions_del(self):
    #    "Deleter. Allows for del self.permissions"
    #    self.db_permissions = ""
    #    self.save()
    #permissions = property(__permissions_get, __permissions_set, __permissions_del)

        # lock_storage property (wraps db_lock_storage)
    ##@property
    #def __lock_storage_get(self):
    #    "Getter. Allows for value = self.lock_storage"
    #    return self.db_lock_storage
    ##@nick.setter
    #def __lock_storage_set(self, value):
    #    """Saves the lock_storagetodate. This is usually not called directly, but through self.lock()"""
    #    self.db_lock_storage = value
    #    self.save()
    ##@nick.deleter
    #def __lock_storage_del(self):
    #    "Deleter is disabled. Use the lockhandler.delete (self.lock.delete) instead"""
    #    logger.log_errmsg("Lock_Storage (on %s) cannot be deleted. Use obj.lock.delete() instead." % self)
    #lock_storage = property(__lock_storage_get, __lock_storage_set, __lock_storage_del)


    #
    #
    # HelpEntry main class methods
    #
    #

    def __str__(self):
        return self.key

    def __unicode__(self):
        return u'%s' % self.key

    def access(self, accessing_obj, access_type='read', default=False):
        """
        Determines if another object has permission to access.
        accessing_obj - object trying to access this one
        access_type - type of access sought
        default - what to return if no lock of access_type was found
        """
        return self.locks.check(accessing_obj, access_type=access_type, default=default)

########NEW FILE########
__FILENAME__ = lockfuncs
"""
This module provides a set of permission lock functions for use
with Evennia's permissions system.

To call these locks, make sure this module is included in the
settings tuple PERMISSION_FUNC_MODULES then define a lock on the form
'<access_type>:func(args)' and add it to the object's lockhandler.
Run the access() method of the handler to execute the lock check.

Note that accessing_obj and accessed_obj can be any object type
with a lock variable/field, so be careful to not expect
a certain object type.


Appendix: MUX locks

Below is a list nicked from the MUX help file on the locks available
in standard MUX. Most of these are not relevant to core Evennia since
locks in Evennia are considerably more flexible and can be implemented
on an individual command/typeclass basis rather than as globally
available like the MUX ones. So many of these are not available in
basic Evennia, but could all be implemented easily if needed for the
individual game.

MUX Name:      Affects:        Effect:
-------------------------------------------------------------------------------
DefaultLock:   Exits:          controls who may traverse the exit to
                               its destination.
                                 Evennia: "traverse:<lockfunc()>"
               Rooms:          controls whether the player sees the SUCC
                               or FAIL message for the room following the
                               room description when looking at the room.
                                 Evennia: Custom typeclass
               Players/Things: controls who may GET the object.
                                 Evennia: "get:<lockfunc()"
 EnterLock:    Players/Things: controls who may ENTER the object
                                 Evennia:
 GetFromLock:  All but Exits:  controls who may gets things from a given
                               location.
                                 Evennia:
 GiveLock:     Players/Things: controls who may give the object.
                                 Evennia:
 LeaveLock:    Players/Things: controls who may LEAVE the object.
                                 Evennia:
 LinkLock:     All but Exits:  controls who may link to the location if the
                               location is LINK_OK (for linking exits or
                               setting drop-tos) or ABODE (for setting
                               homes)
                                 Evennia:
 MailLock:     Players:        controls who may @mail the player.
                               Evennia:
 OpenLock:     All but Exits:  controls who may open an exit.
                                 Evennia:
 PageLock:     Players:        controls who may page the player.
                                 Evennia: "send:<lockfunc()>"
 ParentLock:   All:            controls who may make @parent links to the
                               object.
                                 Evennia: Typeclasses and "puppet:<lockstring()>"
 ReceiveLock:  Players/Things: controls who may give things to the object.
                                 Evennia:
 SpeechLock:   All but Exits:  controls who may speak in that location
                                 Evennia:
 TeloutLock:   All but Exits:  controls who may teleport out of the
                               location.
                                 Evennia:
 TportLock:    Rooms/Things:   controls who may teleport there
                                 Evennia:
 UseLock:      All but Exits:  controls who may USE the object, GIVE the
                               object money and have the PAY attributes
                               run, have their messages heard and possibly
                               acted on by LISTEN and AxHEAR, and invoke
                               $-commands stored on the object.
                                 Evennia: Commands and Cmdsets.
 DropLock:     All but rooms:  controls who may drop that object.
                                 Evennia:
 VisibleLock:  All:            Controls object visibility when the object
                               is not dark and the looker passes the lock.
                               In DARK locations, the object must also be
                               set LIGHT and the viewer must pass the
                               VisibleLock.
                                 Evennia: Room typeclass with Dark/light script
"""

from django.conf import settings
from src.utils import utils

_PERMISSION_HIERARCHY = [p.lower() for p in settings.PERMISSION_HIERARCHY]


def _to_player(accessing_obj):
    "Helper function. Makes sure an accessing object is a player object"
    if utils.inherits_from(accessing_obj, "src.objects.objects.Object"):
        # an object. Convert to player.
        accessing_obj = accessing_obj.player
    return accessing_obj


# lock functions

def true(*args, **kwargs):
    "Always returns True."
    return True


def all(*args, **kwargs):
    return True


def false(*args, **kwargs):
    "Always returns False"
    return False


def none(*args, **kwargs):
    return False


def self(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Check if accessing_obj is the same as accessed_obj

    Usage:
       self()

    This can be used to lock specifically only to
    the same object that the lock is defined on.
    """
    return accessing_obj.typeclass == accessed_obj.typeclass


def perm(accessing_obj, accessed_obj, *args, **kwargs):
    """
    The basic permission-checker. Ignores case.

    Usage:
       perm(<permission>)

    where <permission> is the permission accessing_obj must
    have in order to pass the lock.

    If the given permission is part of settings.PERMISSION_HIERARCHY,
    permission is also granted to all ranks higher up in the hierarchy.

    If accessing_object is an Object controlled by a Player, the
    permissions of the Player is used unless the Attribute _quell
    is set to True on the Object. In this case however, the
    LOWEST hieararcy-permission of the Player/Object-pair will be used
    (this is order to avoid Players potentially escalating their own permissions
    by use of a higher-level Object)

    """
    # this allows the perm_above lockfunc to make use of this function too
    gtmode = kwargs.pop("_greater_than", False)

    try:
        perm = args[0].lower()
        perms_object = [p.lower() for p in accessing_obj.permissions.all()]
    except (AttributeError, IndexError):
        return False

    if utils.inherits_from(accessing_obj, "src.objects.objects.Object") and accessing_obj.player:
        player = accessing_obj.player
        perms_player = [p.lower() for p in player.permissions.all()]
        is_quell = player.attributes.get("_quell")

        if perm in _PERMISSION_HIERARCHY:
            # check hierarchy without allowing escalation obj->player
            hpos_target = _PERMISSION_HIERARCHY.index(perm)
            hpos_player = [hpos for hpos, hperm in enumerate(_PERMISSION_HIERARCHY) if hperm in perms_player]
            hpos_player = hpos_player and hpos_player[-1] or -1
            if is_quell:
                hpos_object = [hpos for hpos, hperm in enumerate(_PERMISSION_HIERARCHY) if hperm in perms_object]
                hpos_object = hpos_object and hpos_object[-1] or -1
                if gtmode:
                    return hpos_target < min(hpos_player, hpos_object)
                else:
                    return hpos_target <= min(hpos_player, hpos_object)
            elif gtmode:
                return gtmode and hpos_target < hpos_player
            else:
                return hpos_target <= hpos_player
        elif not is_quell and perm in perms_player:
            # if we get here, check player perms first, otherwise
            # continue as normal
            return True

    if perm in perms_object:
        # simplest case - we have direct match
        return True
    if perm in _PERMISSION_HIERARCHY:
        # check if we have a higher hierarchy position
        hpos_target = _PERMISSION_HIERARCHY.index(perm)
        return any(1 for hpos, hperm in enumerate(_PERMISSION_HIERARCHY)
                   if hperm in perms_object and hpos_target < hpos)
    return False


def perm_above(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Only allow objects with a permission *higher* in the permission
    hierarchy than the one given. If there is no such higher rank,
    it's assumed we refer to superuser. If no hierarchy is defined,
    this function has no meaning and returns False.
    """
    kwargs["_greater_than"] = True
    return perm(accessing_obj, accessed_obj, *args, **kwargs)


def pperm(accessing_obj, accessed_obj, *args, **kwargs):
    """
    The basic permission-checker only for Player objects. Ignores case.

    Usage:
       pperm(<permission>)

    where <permission> is the permission accessing_obj must
    have in order to pass the lock. If the given permission
    is part of _PERMISSION_HIERARCHY, permission is also granted
    to all ranks higher up in the hierarchy.
    """
    return perm(_to_player(accessing_obj), accessed_obj, *args, **kwargs)


def pperm_above(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Only allow Player objects with a permission *higher* in the permission
    hierarchy than the one given. If there is no such higher rank,
    it's assumed we refer to superuser. If no hierarchy is defined,
    this function has no meaning and returns False.
    """
    return perm_above(_to_player(accessing_obj), accessed_obj, *args, **kwargs)


def dbref(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
      dbref(3)

    This lock type checks if the checking object
    has a particular dbref. Note that this only
    works for checking objects that are stored
    in the database (e.g. not for commands)
    """
    if not args:
        return False
    try:
        dbref = int(args[0].strip().strip('#'))
    except ValueError:
        return False
    if hasattr(accessing_obj, 'dbid'):
        return dbref == accessing_obj.dbid
    return False


def pdbref(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Same as dbref, but making sure accessing_obj is a player.
    """
    return dbref(_to_player(accessing_obj), accessed_obj, *args, **kwargs)


def id(accessing_obj, accessed_obj, *args, **kwargs):
    "Alias to dbref"
    return dbref(accessing_obj, accessed_obj, *args, **kwargs)


def pid(accessing_obj, accessed_obj, *args, **kwargs):
    "Alias to dbref, for Players"
    return dbref(_to_player(accessing_obj), accessed_obj, *args, **kwargs)


# this is more efficient than multiple if ... elif statments
CF_MAPPING = {'eq': lambda val1, val2: val1 == val2 or int(val1) == int(val2),
              'gt': lambda val1, val2: int(val1) > int(val2),
              'lt': lambda val1, val2: int(val1) < int(val2),
              'ge': lambda val1, val2: int(val1) >= int(val2),
              'le': lambda val1, val2: int(val1) <= int(val2),
              'ne': lambda val1, val2: int(val1) != int(val2),
              'default': lambda val1, val2: False}


def attr(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
      attr(attrname)
      attr(attrname, value)
      attr(attrname, value, compare=type)

    where compare's type is one of (eq,gt,lt,ge,le,ne) and signifies
    how the value should be compared with one on accessing_obj (so
    compare=gt means the accessing_obj must have a value greater than
    the one given).

    Searches attributes *and* properties stored on the checking
    object. The first form works like a flag - if the
    attribute/property exists on the object, the value is checked for
    True/False. The second form also requires that the value of the
    attribute/property matches. Note that all retrieved values will be
    converted to strings before doing the comparison.
    """
    # deal with arguments
    if not args:
        return False
    attrname = args[0].strip()
    value = None
    if len(args) > 1:
        value = args[1].strip()
    compare = 'eq'
    if kwargs:
        compare = kwargs.get('compare', 'eq')

    def valcompare(val1, val2, typ='eq'):
        "compare based on type"
        try:
            return CF_MAPPING.get(typ, 'default')(val1, val2)
        except Exception:
            # this might happen if we try to compare two things
            # that cannot be compared
            return False

    # first, look for normal properties on the object trying to gain access
    if hasattr(accessing_obj, attrname):
        if value:
            return valcompare(str(getattr(accessing_obj, attrname)), value, compare)
        # will return Fail on False value etc
        return bool(getattr(accessing_obj, attrname))
    # check attributes, if they exist
    if (hasattr(accessing_obj, 'attributes') and accessing_obj.attributes.has(attrname)):
        if value:
            return (hasattr(accessing_obj, 'attributes')
                    and valcompare(accessing_obj.attributes.get(attrname), value, compare))
        # fails on False/None values
        return bool(accessing_obj.attributes.get(attrname))
    return False


def objattr(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
      objattr(attrname)
      objattr(attrname, value)
      objattr(attrname, value, compare=type)

    Works like attr, except it looks for an attribute on
    accessing_obj.obj, if such an entity exists. Suitable
    for commands.

    """
    if hasattr(accessing_obj, "obj"):
        return attr(accessing_obj.obj, accessed_obj, *args, **kwargs)


def locattr(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
      locattr(attrname)
      locattr(attrname, value)
      locattr(attrname, value, compare=type)

    Works like attr, except it looks for an attribute on
    accessing_obj.location, if such an entity exists.

    """
    if hasattr(accessing_obj, "location"):
        return attr(accessing_obj.location, accessed_obj, *args, **kwargs)


def attr_eq(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
       attr_gt(attrname, 54)
    """
    return attr(accessing_obj, accessed_obj, *args, **kwargs)


def attr_gt(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
       attr_gt(attrname, 54)

    Only true if access_obj's attribute > the value given.
    """
    return attr(accessing_obj, accessed_obj, *args, **{'compare': 'gt'})


def attr_ge(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
       attr_gt(attrname, 54)

    Only true if access_obj's attribute >= the value given.
    """
    return attr(accessing_obj, accessed_obj, *args, **{'compare': 'ge'})


def attr_lt(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
       attr_gt(attrname, 54)

    Only true if access_obj's attribute < the value given.
    """
    return attr(accessing_obj, accessed_obj, *args, **{'compare': 'lt'})


def attr_le(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
       attr_gt(attrname, 54)

    Only true if access_obj's attribute <= the value given.
    """
    return attr(accessing_obj, accessed_obj, *args, **{'compare': 'le'})


def attr_ne(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
       attr_gt(attrname, 54)

    Only true if access_obj's attribute != the value given.
    """
    return attr(accessing_obj, accessed_obj, *args, **{'compare': 'ne'})


def holds(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Usage:
      holds()            checks if accessed_obj or accessed_obj.obj
                         is held by accessing_obj
      holds(key/dbref)   checks if accessing_obj holds an object
                          with given key/dbref
      holds(attrname, value)   checks if accessing_obj holds an
                               object with the given attrname and value

    This is passed if accessed_obj is carried by accessing_obj (that is,
    accessed_obj.location == accessing_obj), or if accessing_obj itself holds
    an object matching the given key.
    """
    try:
        # commands and scripts don't have contents, so we are usually looking
        # for the contents of their .obj property instead (i.e. the object the
        # command/script is attached to).
        contents = accessing_obj.contents
    except AttributeError:
        try:
            contents = accessing_obj.obj.contents
        except AttributeError:
            return False

    def check_holds(objid):
        # helper function. Compares both dbrefs and keys/aliases.
        objid = str(objid)
        dbref = utils.dbref(objid, reqhash=False)
        if dbref and any((True for obj in contents if obj.dbid == dbref)):
            return True
        objid = objid.lower()
        return any((True for obj in contents
                    if obj.key.lower() == objid or objid in [al.lower() for al in obj.aliases.all()]))
    if not args:
        # holds() - check if accessed_obj or accessed_obj.obj is held by accessing_obj
        try:
            if check_holds(accessed_obj.dbid):
                return True
        except Exception:
            pass
        return hasattr(accessed_obj, "obj") and check_holds(accessed_obj.obj.dbid)
    if len(args) == 1:
        # command is holds(dbref/key) - check if given objname/dbref is held by accessing_ob
        return check_holds(args[0])
    elif len(args = 2):
        # command is holds(attrname, value) check if any held object has the given attribute and value
        for obj in contents:
            if obj.attributes.get(args[0]) == args[1]:
                return True


def superuser(*args, **kwargs):
    """
    Only accepts an accesing_obj that is superuser (e.g. user #1)

    Since a superuser would not ever reach this check (superusers
    bypass the lock entirely), any user who gets this far cannot be a
    superuser, hence we just return False. :)
    """
    return False


def serversetting(accessing_obj, accessed_obj, *args, **kwargs):
    """
    Only returns true if the Evennia settings exists, alternatively has
    a certain value.

    Usage:
      serversetting(IRC_ENABLED)
      serversetting(BASE_SCRIPT_PATH, [game.gamesrc.scripts])

    A given True/False or integers will be converted properly.
    """
    if not args or not args[0]:
        return False
    if len(args) < 2:
        setting = args[0]
        val = "True"
    else:
        setting, val = args[0], args[1]
    # convert
    if val == 'True':
        val = True
    elif val == 'False':
        val = False
    elif val.isdigit():
        val = int(val)
    if setting in settings._wrapped.__dict__:
        return settings._wrapped.__dict__[setting] == val
    return False

########NEW FILE########
__FILENAME__ = lockhandler
"""
Locks

A lock defines access to a particular subsystem or property of
Evennia. For example, the "owner" property can be impmemented as a
lock. Or the disability to lift an object or to ban users.

A lock consists of three parts:

 - access_type - this defines what kind of access this lock regulates. This
   just a string.
 - function call - this is one or many calls to functions that will determine
   if the lock is passed or not.
 - lock function(s). These are regular python functions with a special
   set of allowed arguments. They should always return a boolean depending
   on if they allow access or not.

# Lock function

A lock function is defined by existing in one of the modules
listed by settings.LOCK_FUNC_MODULES. It should also always
take four arguments looking like this:

   funcname(accessing_obj, accessed_obj, *args, **kwargs):
        [...]

The accessing object is the object wanting to gain access.
The accessed object is the object this lock resides on
args and kwargs will hold optional arguments and/or keyword arguments
to the function as a list and a dictionary respectively.

Example:

   perm(accessing_obj, accessed_obj, *args, **kwargs):
       "Checking if the object has a particular, desired permission"
       if args:
           desired_perm = args[0]
           return desired_perm in accessing_obj.permissions.all()
       return False

Lock functions should most often be pretty general and ideally possible to
re-use and combine in various ways to build clever locks.


# Lock definition ("Lock string")

A lock definition is a string with a special syntax. It is added to
each object's lockhandler, making that lock available from then on.

The lock definition looks like this:

 'access_type:[NOT] func1(args)[ AND|OR][NOT] func2() ...'

That is, the access_type, a colon followed by calls to lock functions
combined with AND or OR. NOT negates the result of the following call.

Example:

 We want to limit who may edit a particular object (let's call this access_type
for 'edit', it depends on what the command is looking for). We want this to
only work for those with the Permission 'Builders'. So we use our lock
function above and define it like this:

  'edit:perm(Builders)'

Here, the lock-function perm() will be called with the string
'Builders' (accessing_obj and accessed_obj are added automatically,
you only need to add the args/kwargs, if any).

If we wanted to make sure the accessing object was BOTH a Builders and a
GoodGuy, we could use AND:

  'edit:perm(Builders) AND perm(GoodGuy)'

To allow EITHER Builders and GoodGuys, we replace AND with OR. perm() is just
one example, the lock function can do anything and compare any properties of
the calling object to decide if the lock is passed or not.

  'lift:attrib(very_strong) AND NOT attrib(bad_back)'

To make these work, add the string to the lockhandler of the object you want
to apply the lock to:

  obj.lockhandler.add('edit:perm(Builders)')

From then on, a command that wants to check for 'edit' access on this
object would do something like this:

  if not target_obj.lockhandler.has_perm(caller, 'edit'):
      caller.msg("Sorry, you cannot edit that.")

All objects also has a shortcut called 'access' that is recommended to
use instead:

  if not target_obj.access(caller, 'edit'):
      caller.msg("Sorry, you cannot edit that.")

# Permissions

Permissions are just text strings stored in a comma-separated list on
typeclassed objects. The default perm() lock function uses them,
taking into account settings.PERMISSION_HIERARCHY. Also, the
restricted @perm command sets them, but otherwise they are identical
to any other identifier you can use.

"""

import re
import inspect
from django.conf import settings
from src.utils import logger, utils
from django.utils.translation import ugettext as _

__all__ = ("LockHandler", "LockException")


#
# Exception class. This will be raised
# by errors in lock definitions.
#

class LockException(Exception):
    "raised during an error in a lock."
    pass


#
# Cached lock functions
#

_LOCKFUNCS = {}
def _cache_lockfuncs():
    "Updates the cache."
    global _LOCKFUNCS
    _LOCKFUNCS = {}
    for modulepath in settings.LOCK_FUNC_MODULES:
        modulepath = utils.pypath_to_realpath(modulepath)
        mod = utils.mod_import(modulepath)
        if mod:
            for tup in (tup for tup in inspect.getmembers(mod) if callable(tup[1])):
                _LOCKFUNCS[tup[0]] = tup[1]
        else:
            logger.log_errmsg("Couldn't load %s from PERMISSION_FUNC_MODULES." % modulepath)

#
# pre-compiled regular expressions
#

_RE_FUNCS = re.compile(r"\w+\([^)]*\)")
_RE_SEPS = re.compile(r"(?<=[ )])AND(?=\s)|(?<=[ )])OR(?=\s)|(?<=[ )])NOT(?=\s)")
_RE_OK = re.compile(r"%s|and|or|not")


#
#
# Lock handler
#
#

class LockHandler(object):
    """
    This handler should be attached to all objects implementing
    permission checks, under the property 'lockhandler'.
    """

    def __init__(self, obj):
        """
        Loads and pre-caches all relevant locks and their
        functions.
        """
        if not _LOCKFUNCS:
            _cache_lockfuncs()
        self.obj = obj
        self.locks = {}
        self.reset()

    def __str__(self):
        return ";".join(self.locks[key][2] for key in sorted(self.locks))

    def _log_error(self, message):
        "Try to log errors back to object"
        raise LockException(message)

    def _parse_lockstring(self, storage_lockstring):
        """
        Helper function. This is normally only called when the
        lockstring is cached and does preliminary checking.  locks are
        stored as a string
               'atype:[NOT] lock()[[ AND|OR [NOT] lock()[...]];atype...

        """
        locks = {}
        if not storage_lockstring:
            return locks
        duplicates = 0
        elist = []  # errors
        wlist = []  # warnings
        for raw_lockstring in storage_lockstring.split(';'):
            if not raw_lockstring:
                continue
            lock_funcs = []
            try:
                access_type, rhs = (part.strip() for part in raw_lockstring.split(':', 1))
            except ValueError:
                logger.log_trace()
                return locks

            # parse the lock functions and separators
            funclist = _RE_FUNCS.findall(rhs)
            evalstring = rhs
            for pattern in ('AND', 'OR', 'NOT'):
                evalstring = re.sub(r"\b%s\b" % pattern, pattern.lower(), evalstring)
            nfuncs = len(funclist)
            for funcstring in funclist:
                funcname, rest = (part.strip().strip(')') for part in funcstring.split('(', 1))
                func = _LOCKFUNCS.get(funcname, None)
                if not callable(func):
                    elist.append(_("Lock: function '%s' is not available.") % funcstring)
                    continue
                args = list(arg.strip() for arg in rest.split(',') if arg and not '=' in arg)
                kwargs = dict([arg.split('=', 1) for arg in rest.split(',') if arg and '=' in arg])
                lock_funcs.append((func, args, kwargs))
                evalstring = evalstring.replace(funcstring, '%s')
            if len(lock_funcs) < nfuncs:
                continue
            try:
                # purge the eval string of any superfluous items, then test it
                evalstring = " ".join(_RE_OK.findall(evalstring))
                eval(evalstring % tuple(True for func in funclist), {}, {})
            except Exception:
                elist.append(_("Lock: definition '%s' has syntax errors.") % raw_lockstring)
                continue
            if access_type in locks:
                duplicates += 1
                wlist.append(_("Lock: access type '%(access_type)s' changed from '%(source)s' to '%(goal)s' " % \
                                 {"access_type":access_type, "source":locks[access_type][2], "goal":raw_lockstring}))
            locks[access_type] = (evalstring, tuple(lock_funcs), raw_lockstring)
        if wlist:
            # a warning text was set, it's not an error, so only report
            logger.log_warn("\n".join(wlist))
        if elist:
            # an error text was set, raise exception.
            raise LockException("\n".join(elist))
        # return the gathered locks in an easily executable form
        return locks

    def _cache_locks(self, storage_lockstring):
        """Store data"""
        self.locks = self._parse_lockstring(storage_lockstring)

    def _save_locks(self):
        "Store locks to obj"
        self.obj.lock_storage = ";".join([tup[2] for tup in self.locks.values()])

    def cache_lock_bypass(self, obj):
        """
        We cache superuser bypass checks here for efficiency. This needs to
        be re-run when a player is assigned to a character.
        We need to grant access to superusers. We need to check both directly
        on the object (players), through obj.player and using the get_player()
        method (this sits on serversessions, in some rare cases where a
        check is done before the login process has yet been fully finalized)
        """
        self.lock_bypass = hasattr(obj, "is_superuser") and obj.is_superuser

    def add(self, lockstring):
        """
        Add a new lockstring on the form '<access_type>:<functions>'. Multiple
        access types should be separated by semicolon (;).

        """
        # sanity checks
        for lockdef in lockstring.split(';'):
            if not ':' in lockstring:
                self._log_error(_("Lock: '%s' contains no colon (:).") % lockdef)
                return False
            access_type, rhs = [part.strip() for part in lockdef.split(':', 1)]
            if not access_type:
                self._log_error(_("Lock: '%s' has no access_type (left-side of colon is empty).") % lockdef)
                return False
            if rhs.count('(') != rhs.count(')'):
                self._log_error(_("Lock: '%s' has mismatched parentheses.") % lockdef)
                return False
            if not _RE_FUNCS.findall(rhs):
                self._log_error(_("Lock: '%s' has no valid lock functions.") % lockdef)
                return False
        # get the lock string
        storage_lockstring = self.obj.lock_storage
        if storage_lockstring:
            storage_lockstring = storage_lockstring + ";" + lockstring
        else:
            storage_lockstring = lockstring
        # cache the locks will get rid of eventual doublets
        self._cache_locks(storage_lockstring)
        self._save_locks()
        return True

    def replace(self, lockstring):
        "Replaces the lockstring entirely."
        old_lockstring = str(self)
        self.clear()
        try:
            return self.add(lockstring)
        except LockException:
            self.add(old_lockstring)
            raise

    def get(self, access_type=None):
        "get the full lockstring or the lockstring of a particular access type."
        if access_type:
            return self.locks.get(access_type, ["", "", ""])[2]
        return str(self)

    def delete(self, access_type):
        "Remove a lock from the handler"
        if access_type in self.locks:
            del self.locks[access_type]
            self._save_locks()
            return True
        return False

    def clear(self):
        "Remove all locks"
        self.locks = {}
        self.lock_storage = ""
        self._save_locks()

    def reset(self):
        """
        Set the reset flag, so the the lock will be re-cached at next checking.
        This is usually set by @reload.
        """
        self._cache_locks(self.obj.lock_storage)
        self.cache_lock_bypass(self.obj)

    def check(self, accessing_obj, access_type, default=False, no_superuser_bypass=False):
        """
        Checks a lock of the correct type by passing execution
        off to the lock function(s).

        accessing_obj - the object seeking access
        access_type - the type of access wanted
        default - if no suitable lock type is found, use this
        no_superuser_bypass - don't use this unless you really, really need to,
                             it makes supersusers susceptible to the lock check.

        A lock is executed in the follwoing way:

        Parsing the lockstring, we (during cache) extract the valid
        lock functions and store their function objects in the right
        order along with their args/kwargs. These are now executed in
        sequence, creating a list of True/False values. This is put
        into the evalstring, which is a string of AND/OR/NOT entries
        separated by placeholders where each function result should
        go. We just put those results in and evaluate the string to
        get a final, combined True/False value for the lockstring.

        The important bit with this solution is that the full
        lockstring is never blindly evaluated, and thus there (should
        be) no way to sneak in malign code in it. Only "safe" lock
        functions (as defined by your settings) are executed.

        """
        try:
            # check if the lock should be bypassed (e.g. superuser status)
            if accessing_obj.locks.lock_bypass and not no_superuser_bypass:
                return True
        except AttributeError:
            # happens before session is initiated.
            if not no_superuser_bypass and ((hasattr(accessing_obj, 'is_superuser') and accessing_obj.is_superuser)
             or (hasattr(accessing_obj, 'player') and hasattr(accessing_obj.player, 'is_superuser') and accessing_obj.player.is_superuser)
             or (hasattr(accessing_obj, 'get_player') and (not accessing_obj.get_player() or accessing_obj.get_player().is_superuser))):
                return True

        # no superuser or bypass -> normal lock operation
        if access_type in self.locks:
            # we have a lock, test it.
            evalstring, func_tup, raw_string = self.locks[access_type]
            # execute all lock funcs in the correct order, producing a tuple of True/False results.
            true_false = tuple(bool(tup[0](accessing_obj, self.obj, *tup[1], **tup[2])) for tup in func_tup)
            # the True/False tuple goes into evalstring, which combines them
            # with AND/OR/NOT in order to get the final result.
            return eval(evalstring % true_false)
        else:
            return default

    def check_lockstring(self, accessing_obj, lockstring, no_superuser_bypass=False):
        """
        Do a direct check against a lockstring ('atype:func()..'), without any
        intermediary storage on the accessed object (this can be left
        to None if the lock functions called don't access it). atype can also be
        put to a dummy value since no lock selection is made.
        """
        try:
            if accessing_obj.locks.lock_bypass and not no_superuser_bypass:
                return True
        except AttributeError:
            if no_superuser_bypass and ((hasattr(accessing_obj, 'is_superuser') and accessing_obj.is_superuser)
             or (hasattr(accessing_obj, 'player') and hasattr(accessing_obj.player, 'is_superuser') and accessing_obj.player.is_superuser)
             or (hasattr(accessing_obj, 'get_player') and (not accessing_obj.get_player() or accessing_obj.get_player().is_superuser))):
                return True

        locks = self._parse_lockstring(lockstring)
        for access_type in locks:
            evalstring, func_tup, raw_string = locks[access_type]
            true_false = tuple(tup[0](accessing_obj, self.obj, *tup[1],**tup[2])
                                      for tup in func_tup)
            return eval(evalstring % true_false)


def _test():
    # testing

    class TestObj(object):
        pass

    import pdb
    obj1 = TestObj()
    obj2 = TestObj()

    #obj1.lock_storage = "owner:dbref(#4);edit:dbref(#5) or perm(Wizards);examine:perm(Builders);delete:perm(Wizards);get:all()"
    #obj1.lock_storage = "cmd:all();admin:id(1);listen:all();send:all()"
    obj1.lock_storage = "listen:perm(Immortals)"

    pdb.set_trace()
    obj1.locks = LockHandler(obj1)
    obj2.permissions.add("Immortals")
    obj2.id = 4

    #obj1.locks.add("edit:attr(test)")

    print "comparing obj2.permissions (%s) vs obj1.locks (%s)" % (obj2.permissions, obj1.locks)
    print obj1.locks.check(obj2, 'owner')
    print obj1.locks.check(obj2, 'edit')
    print obj1.locks.check(obj2, 'examine')
    print obj1.locks.check(obj2, 'delete')
    print obj1.locks.check(obj2, 'get')
    print obj1.locks.check(obj2, 'listen')

########NEW FILE########
__FILENAME__ = tests
# -*- coding: utf-8 -*-

"""
This is part of Evennia's unittest framework, for testing
the stability and integrrity of the codebase during updates.

This module tests the lock functionality of Evennia.

"""

try:
    # this is a special optimized Django version, only available in current Django devel
    from django.utils.unittest import TestCase
except ImportError:
    from django.test import TestCase

from django.conf import settings
from src.locks import lockfuncs
from src.utils import create

#------------------------------------------------------------
#
# Lock testing
#
#------------------------------------------------------------

class LockTest(TestCase):
    "Defines the lock test base"
    def setUp(self):
        "sets up the testing environment"

        self.obj1 = create.create_object(settings.BASE_OBJECT_TYPECLASS, key="obj1")
        self.obj2 = create.create_object(settings.BASE_OBJECT_TYPECLASS, key="obj2")

class TestLockCheck(LockTest):
    def testrun(self):
        dbref = self.obj2.dbref
        self.obj1.locks.add("owner:dbref(%s);edit:dbref(%s) or perm(Wizards);examine:perm(Builders) and id(%s);delete:perm(Wizards);get:all()" % (dbref, dbref, dbref))
        self.obj2.permissions.add('Wizards')
        self.assertEquals(True, self.obj1.locks.check(self.obj2, 'owner'))
        self.assertEquals(True, self.obj1.locks.check(self.obj2, 'edit'))
        self.assertEquals(True, self.obj1.locks.check(self.obj2, 'examine'))
        self.assertEquals(True, self.obj1.locks.check(self.obj2, 'delete'))
        self.assertEquals(True, self.obj1.locks.check(self.obj2, 'get'))
        self.obj1.locks.add("get:false()")
        self.assertEquals(False, self.obj1.locks.check(self.obj2, 'get'))
        self.assertEquals(True, self.obj1.locks.check(self.obj2, 'not_exist', default=True))
class TestLockfuncs(LockTest):
    def testrun(self):
        self.obj2.permissions.add('Wizards')
        self.assertEquals(True, lockfuncs.true(self.obj2, self.obj1))
        self.assertEquals(False, lockfuncs.false(self.obj2, self.obj1))
        self.assertEquals(True, lockfuncs.perm(self.obj2, self.obj1, 'Wizards'))
        self.assertEquals(True, lockfuncs.perm_above(self.obj2, self.obj1, 'Builders'))
        dbref = self.obj2.dbref
        self.assertEquals(True, lockfuncs.dbref(self.obj2, self.obj1, '%s' % dbref))
        self.obj2.db.testattr = 45
        self.assertEquals(True, lockfuncs.attr(self.obj2, self.obj1, 'testattr', '45'))
        self.assertEquals(False, lockfuncs.attr_gt(self.obj2, self.obj1, 'testattr', '45'))
        self.assertEquals(True, lockfuncs.attr_ge(self.obj2, self.obj1, 'testattr', '45'))
        self.assertEquals(False, lockfuncs.attr_lt(self.obj2, self.obj1, 'testattr', '45'))
        self.assertEquals(True, lockfuncs.attr_le(self.obj2, self.obj1, 'testattr', '45'))
        self.assertEquals(False, lockfuncs.attr_ne(self.obj2, self.obj1, 'testattr', '45'))

########NEW FILE########
__FILENAME__ = admin
#
# This sets up how models are displayed
# in the web admin interface.
#

from django import forms
from django.conf import settings
from django.contrib import admin
from src.typeclasses.models import Attribute, Tag
from src.objects.models import ObjectDB


class AttributeInline(admin.TabularInline):
    # This class is currently not used, because PickleField objects are
    # not editable. It's here for us to ponder making a way that allows
    # them to be edited.
    model = Attribute
    fields = ('db_key', 'db_value')
    extra = 0


class TagInline(admin.TabularInline):
    model = ObjectDB.db_tags.through
    raw_id_fields = ('tag',)
    extra = 0


class TagAdmin(admin.ModelAdmin):
    fields = ('db_key', 'db_category', 'db_data')


class ObjectCreateForm(forms.ModelForm):
    "This form details the look of the fields"
    class Meta:
        model = ObjectDB
    db_key = forms.CharField(label="Name/Key",
                             widget=forms.TextInput(attrs={'size': '78'}),
                             help_text="Main identifier, like 'apple', 'strong guy', 'Elizabeth' etc. If creating a Character, check so the name is unique among characters!",)
    db_typeclass_path = forms.CharField(label="Typeclass",
                                        initial=settings.BASE_OBJECT_TYPECLASS,
                                        widget=forms.TextInput(attrs={'size': '78'}),
                                        help_text="This defines what 'type' of entity this is. This variable holds a Python path to a module with a valid Evennia Typeclass. If you are creating a Character you should use the typeclass defined by settings.BASE_CHARACTER_TYPECLASS or one derived from that.")
    db_cmdset_storage = forms.CharField(label="CmdSet",
                                        initial="",
                                        required=False,
                                        widget=forms.TextInput(attrs={'size': '78'}),
                                        help_text="Most non-character objects don't need a cmdset and can leave this field blank.")
    raw_id_fields = ('db_destination', 'db_location', 'db_home')


class ObjectEditForm(ObjectCreateForm):
    "Form used for editing. Extends the create one with more fields"

    db_lock_storage = forms.CharField(label="Locks",
                                      required=False,
                                      widget=forms.Textarea(attrs={'cols':'100', 'rows':'2'}),
                                      help_text="In-game lock definition string. If not given, defaults will be used. This string should be on the form <i>type:lockfunction(args);type2:lockfunction2(args);...")


class ObjectDBAdmin(admin.ModelAdmin):

    list_display = ('id', 'db_key', 'db_player', 'db_typeclass_path')
    list_display_links = ('id', 'db_key')
    ordering = ['db_player', 'db_typeclass_path', 'id']
    search_fields = ['^db_key', 'db_typeclass_path']
    raw_id_fields = ('db_destination', 'db_location', 'db_home')

    save_as = True
    save_on_top = True
    list_select_related = True
    list_filter = ('db_typeclass_path',)
    #list_filter = ('db_permissions', 'db_typeclass_path')

    # editing fields setup

    form = ObjectEditForm
    fieldsets = (
        (None, {
                'fields': (('db_key','db_typeclass_path'), ('db_lock_storage', ),
                           ('db_location', 'db_home'), 'db_destination','db_cmdset_storage'
                           )}),
        )
    #fieldsets = (
    #    (None, {
    #            'fields': (('db_key','db_typeclass_path'), ('db_permissions', 'db_lock_storage'),
    #                       ('db_location', 'db_home'), 'db_destination','db_cmdset_storage'
    #                       )}),
    #    )

    #deactivated temporarily, they cause empty objects to be created in admin
    inlines = [TagInline]

    # Custom modification to give two different forms wether adding or not.
    add_form = ObjectCreateForm
    add_fieldsets = (
        (None, {
                'fields': (('db_key','db_typeclass_path'),
                           ('db_location', 'db_home'), 'db_destination', 'db_cmdset_storage'
                           )}),
        )

    #add_fieldsets = (
    #    (None, {
    #            'fields': (('db_key','db_typeclass_path'), 'db_permissions',
    #                       ('db_location', 'db_home'), 'db_destination', 'db_cmdset_storage'
    #                       )}),
    #    )
    def get_fieldsets(self, request, obj=None):
        if not obj:
            return self.add_fieldsets
        return super(ObjectDBAdmin, self).get_fieldsets(request, obj)

    def get_form(self, request, obj=None, **kwargs):
        """
        Use special form during creation
        """
        defaults = {}
        if obj is None:
            defaults.update({
                    'form': self.add_form,
                    'fields': admin.util.flatten_fieldsets(self.add_fieldsets),
                    })
            defaults.update(kwargs)
        return super(ObjectDBAdmin, self).get_form(request, obj, **defaults)

    def save_model(self, request, obj, form, change):
        obj.save()
        if not change:
            # adding a new object
            obj = obj.typeclass
            obj.basetype_setup()
            obj.basetype_posthook_setup()
            obj.at_object_creation()
        obj.at_init()


admin.site.register(ObjectDB, ObjectDBAdmin)
admin.site.register(Tag, TagAdmin)

########NEW FILE########
__FILENAME__ = manager
"""
Custom manager for Objects.
"""
from itertools import chain
from django.db.models import Q
from django.conf import settings
from django.db.models.fields import exceptions
from src.typeclasses.managers import TypedObjectManager
from src.typeclasses.managers import returns_typeclass, returns_typeclass_list
from src.utils import utils
from src.utils.utils import to_unicode, is_iter, make_iter, string_partial_matching

__all__ = ("ObjectManager",)
_GA = object.__getattribute__

# delayed import
_ATTR = None


# Try to use a custom way to parse id-tagged multimatches.

_AT_MULTIMATCH_INPUT = utils.variable_from_module(*settings.SEARCH_AT_MULTIMATCH_INPUT.rsplit('.', 1))


class ObjectManager(TypedObjectManager):
    """
    This ObjectManager implementes methods for searching
    and manipulating Objects directly from the database.

    Evennia-specific search methods (will return Typeclasses or
    lists of Typeclasses, whereas Django-general methods will return
    Querysets or database objects).

    dbref (converter)
    get_id (alias: dbref_search)
    get_dbref_range
    object_totals
    typeclass_search
    get_object_with_player
    get_objs_with_key_and_typeclass
    get_objs_with_attr
    get_objs_with_attr_match
    get_objs_with_db_property
    get_objs_with_db_property_match
    get_objs_with_key_or_alias
    get_contents
    object_search (interface to many of the above methods,
                   equivalent to ev.search_object)
    copy_object

    """

    #
    # ObjectManager Get methods
    #

    # player related

    @returns_typeclass
    def get_object_with_player(self, ostring, exact=True, candidates=None):
        """
        Search for an object based on its player's name or dbref.
        This search
        is sometimes initiated by appending a * to the beginning of
        the search criterion (e.g. in local_and_global_search).
        search_string:  (string) The name or dbref to search for.
        """
        ostring = to_unicode(ostring).lstrip('*')
        # simplest case - search by dbref
        dbref = self.dbref(ostring)
        if dbref:
            return dbref
        # not a dbref. Search by name.
        cand_restriction = candidates != None and Q(pk__in=[_GA(obj, "id") for obj in make_iter(candidates) if obj]) or Q()
        if exact:
            return self.filter(cand_restriction & Q(db_player__username__iexact=ostring))
        else: # fuzzy matching
            ply_cands = self.filter(cand_restriction & Q(playerdb__username__istartswith=ostring)).values_list("db_key", flat=True)
            if candidates:
                index_matches = string_partial_matching(ply_cands, ostring, ret_index=True)
                return [obj for ind, obj in enumerate(make_iter(candidates)) if ind in index_matches]
            else:
                return string_partial_matching(ply_cands, ostring, ret_index=False)

    @returns_typeclass_list
    def get_objs_with_key_and_typeclass(self, oname, otypeclass_path, candidates=None):
        """
        Returns objects based on simultaneous key and typeclass match.
        """
        cand_restriction = candidates != None and Q(pk__in=[_GA(obj, "id") for obj in make_iter(candidates) if obj]) or Q()
        return self.filter(cand_restriction & Q(db_key__iexact=oname, db_typeclass_path__exact=otypeclass_path))

    # attr/property related

    @returns_typeclass_list
    def get_objs_with_attr(self, attribute_name, candidates=None):
        """
        Returns all objects having the given attribute_name defined at all.
        Location should be a valid location object.
        """
        cand_restriction = candidates != None and Q(db_attributes__db_obj__pk__in=[_GA(obj, "id") for obj in make_iter(candidates) if obj]) or Q()
        return list(self.filter(cand_restriction & Q(db_attributes__db_key=attribute_name)))

    @returns_typeclass_list
    def get_objs_with_attr_value(self, attribute_name, attribute_value, candidates=None, typeclasses=None):
        """
        Returns all objects having the valid attrname set to the given value.

        candidates - list of candidate objects to search
        typeclasses - list of typeclass-path strings to restrict matches with

        This uses the Attribute's PickledField to transparently search the database by matching
        the internal representation. This is reasonably effective but since Attribute values
        cannot be indexed, searching by Attribute key is to be preferred whenever possible.
        """
        cand_restriction = candidates != None and Q(pk__in=[_GA(obj, "id") for obj in make_iter(candidates) if obj]) or Q()
        type_restriction = typeclasses and Q(db_typeclass_path__in=make_iter(typeclasses)) or Q()

        ## This doesn't work if attribute_value is an object. Workaround below

        if isinstance(attribute_value, (basestring, int, float, bool, long)):
            return self.filter(cand_restriction & type_restriction & Q(db_attributes__db_key=attribute_name, db_attributes__db_value=attribute_value))
        else:
            # We have to loop for safety since the referenced lookup gives deepcopy error if attribute value is an object.
            global _ATTR
            if not _ATTR:
                from src.typeclasses.models import Attribute as _ATTR
            cands = list(self.filter(cand_restriction & type_restriction & Q(db_attributes__db_key=attribute_name)))
            results = [attr.objectdb_set.all() for attr in _ATTR.objects.filter(objectdb__in=cands, db_value=attribute_value)]
            return chain(*results)

    @returns_typeclass_list
    def get_objs_with_db_property(self, property_name, candidates=None):
        """
        Returns all objects having a given db field property.
        property_name = search string
        candidates - list of candidate objects to search
        """
        property_name = "db_%s" % property_name.lstrip('db_')
        cand_restriction = candidates != None and Q(pk__in=[_GA(obj, "id") for obj in make_iter(candidates) if obj]) or Q()
        querykwargs = {property_name:None}
        try:
            return list(self.filter(cand_restriction).exclude(Q(**querykwargs)))
        except exceptions.FieldError:
            return []

    @returns_typeclass_list
    def get_objs_with_db_property_value(self, property_name, property_value, candidates=None, typeclasses=None):
        """
        Returns all objects having a given db field property.
        candidates - list of objects to search
        typeclasses - list of typeclass-path strings to restrict matches with
        """
        if isinstance(property_value, basestring):
            property_value = to_unicode(property_value)
        if isinstance(property_name, basestring):
            if not property_name.startswith('db_'):
                property_name = "db_%s" % property_name
        if hasattr(property_value, 'dbobj'):
            property_value = property_value.dbobj
        querykwargs = {property_name:property_value}
        cand_restriction = candidates != None and Q(pk__in=[_GA(obj, "id") for obj in make_iter(candidates) if obj]) or Q()
        type_restriction = typeclasses and Q(db_typeclass_path__in=make_iter(typeclasses)) or Q()
        try:
            return list(self.filter(cand_restriction & type_restriction & Q(**querykwargs)))
        except exceptions.FieldError:
            return []
        except ValueError:
            from src.utils import logger
            logger.log_errmsg("The property '%s' does not support search criteria of the type %s." % (property_name, type(property_value)))
            return []

    @returns_typeclass_list
    def get_contents(self, location, excludeobj=None):
        """
        Get all objects that has a location
        set to this one.

        excludeobj - one or more object keys to exclude from the match
        """
        exclude_restriction = Q(pk__in=[_GA(obj, "id") for obj in make_iter(excludeobj)]) if excludeobj else Q()
        return self.filter(db_location=location).exclude(exclude_restriction)

    @returns_typeclass_list
    def get_objs_with_key_or_alias(self, ostring, exact=True,
                                         candidates=None, typeclasses=None):
        """
        Returns objects based on key or alias match. Will also do fuzzy
        matching based on the utils.string_partial_matching function.
        candidates - list of candidate objects to restrict on
        typeclasses - list of typeclass path strings to restrict on
        """
        if not isinstance(ostring, basestring):
            if hasattr(ostring, "key"):
                ostring = ostring.key
            else:
                return []
        if is_iter(candidates) and not len(candidates):
            # if candidates is an empty iterable there can be no matches
            # Exit early.
            return []

        # build query objects
        candidates_id = [_GA(obj, "id") for obj in make_iter(candidates) if obj]
        cand_restriction = candidates != None and Q(pk__in=make_iter(candidates_id)) or Q()
        type_restriction = typeclasses and Q(db_typeclass_path__in=make_iter(typeclasses)) or Q()
        if exact:
            # exact match - do direct search
            return self.filter(cand_restriction & type_restriction & (Q(db_key__iexact=ostring) |
                               Q(db_tags__db_key__iexact=ostring) & Q(db_tags__db_tagtype__iexact="alias"))).distinct()
        elif candidates:
            # fuzzy with candidates
            key_candidates = self.filter(cand_restriction & type_restriction)
        else:
            # fuzzy without supplied candidates - we select our own candidates
            key_candidates = self.filter(type_restriction & (Q(db_key__istartswith=ostring) | Q(db_tags__db_key__istartswith=ostring))).distinct()
            candidates_id = [_GA(obj, "id") for obj in key_candidates]
        # fuzzy matching
        key_strings = key_candidates.values_list("db_key", flat=True)
        index_matches = string_partial_matching(key_strings, ostring, ret_index=True)
        if index_matches:
            return [obj for ind, obj in enumerate(key_candidates) if ind in index_matches]
        else:
            alias_candidates = self.filter(id__in=candidates_id, db_tags__db_tagtype__iexact="alias")
            alias_strings = alias_candidates.values_list("db_key", flat=True)
            index_matches = string_partial_matching(alias_strings, ostring, ret_index=True)
            if index_matches:
                return [alias.db_obj for ind, alias in enumerate(alias_candidates) if ind in index_matches]
            return []

    # main search methods and helper functions

    @returns_typeclass_list
    def object_search(self, searchdata,
                      attribute_name=None,
                      typeclass=None,
                      candidates=None,
                      exact=True):
        """
        Search as an object globally or in a list of candidates and return
        results. The result is always an Object. Always returns a list.

        Arguments:
        searchdata: (str or obj) The entity to match for. This is usually a
                  key string but may also be an object itself. By default (if
                  not attribute_name is set), this will search object.key and
                  object.aliases in order. Can also be on the form #dbref,
                  which will, if exact=True be matched against primary key.
        attribute_name: (str): Use this named ObjectAttribute to match
                  searchdata against, instead of the defaults. If this is
                  the name of a database field (with or without the db_ prefix),
                  that will be matched too.
        typeclass (str or TypeClass): restrict matches to objects having this
                  typeclass. This will help speed up global searches.
        candidates (list obj ObjectDBs): If supplied, search will only be
                  performed among the candidates in this list. A common list
                  of candidates is the contents of the current location
                  searched.
        exact (bool): Match names/aliases exactly or partially. Partial
                  matching matches the beginning of words in the names/aliases,
                  using a matching routine to separate multiple matches in
                  names with multiple components (so "bi sw" will match
                  "Big sword"). Since this is more expensive than exact
                  matching, it is recommended to be used together with the
                  objlist keyword to limit the number of possibilities. This
                  value has no meaning if searching for attributes/properties.

        Returns:
        A list of matching objects (or a list with one unique match)
        """
        def _searcher(searchdata, candidates, typeclass, exact=False):
            """
            Helper method for searching objects. typeclass is only used
            for global searching (no candidates)
            """
            if attribute_name:
                # attribute/property search (always exact).
                matches = self.get_objs_with_db_property_value(attribute_name, searchdata, candidates=candidates, typeclasses=typeclass)
                if matches:
                    return matches
                return self.get_objs_with_attr_value(attribute_name, searchdata, candidates=candidates, typeclasses=typeclass)
            else:
                # normal key/alias search
                return self.get_objs_with_key_or_alias(searchdata, exact=exact, candidates=candidates, typeclasses=typeclass)

        if not searchdata and searchdata != 0:
            return []

        if typeclass:
            # typeclass may also be a list
            typeclasses = make_iter(typeclass)
            for i, typeclass in enumerate(make_iter(typeclasses)):
                if callable(typeclass):
                    typeclasses[i] = u"%s.%s" % (typeclass.__module__, typeclass.__name__)
                else:
                    typeclasses[i] = u"%s" % typeclass
            typeclass = typeclasses

        if candidates:
            # Convenience check to make sure candidates are really dbobjs
            candidates = [cand.dbobj for cand in make_iter(candidates) if cand]
            if typeclass:
                candidates = [cand for cand in candidates
                                if _GA(cand, "db_typeclass_path") in typeclass]

        dbref = not attribute_name and exact and self.dbref(searchdata)
        if dbref is not None:
            # Easiest case - dbref matching (always exact)
            dbref_match = self.dbref_search(dbref)
            if dbref_match:
                if not candidates or dbref_match.dbobj in candidates:
                    return [dbref_match]
                else:
                    return []

        # Search through all possibilities.
        match_number = None
        # always run first check exact - we don't want partial matches
        # if on the form of 1-keyword etc.
        matches = _searcher(searchdata, candidates, typeclass, exact=True)
        if not matches:
            # no matches found - check if we are dealing with N-keyword
            # query - if so, strip it.
            match_number, searchdata = _AT_MULTIMATCH_INPUT(searchdata)
            # run search again, with the exactness set by call
            if match_number is not None or not exact:
                matches = _searcher(searchdata, candidates, typeclass, exact=exact)

        # deal with result
        if len(matches) > 1 and match_number is not None:
            # multiple matches, but a number was given to separate them
            try:
                matches = [matches[match_number]]
            except IndexError:
                pass
        # return a list (possibly empty)
        return matches

    #
    # ObjectManager Copy method
    #

    def copy_object(self, original_object, new_key=None,
                    new_location=None, new_home=None,
                    new_permissions=None, new_locks=None,
                    new_aliases=None, new_destination=None):
        """
        Create and return a new object as a copy of the original object. All
        will be identical to the original except for the arguments given
        specifically to this method.

        original_object (obj) - the object to make a copy from
        new_key (str) - name the copy differently from the original.
        new_location (obj) - if not None, change the location
        new_home (obj) - if not None, change the Home
        new_aliases (list of strings) - if not None, change object aliases.
        new_destination (obj) - if not None, change destination
        """

        # get all the object's stats
        typeclass_path = original_object.typeclass_path
        if not new_key:
            new_key = original_object.key
        if not new_location:
            new_location = original_object.location
        if not new_home:
            new_home = original_object.home
        if not new_aliases:
            new_aliases = original_object.aliases.all()
        if not new_locks:
            new_locks = original_object.db_lock_storage
        if not new_permissions:
            new_permissions = original_object.permissions.all()
        if not new_destination:
            new_destination = original_object.destination

        # create new object
        from src.utils import create
        from src.scripts.models import ScriptDB
        new_object = create.create_object(typeclass_path,
                                          key=new_key,
                                          location=new_location,
                                          home=new_home,
                                          permissions=new_permissions,
                                          locks=new_locks,
                                          aliases=new_aliases,
                                          destination=new_destination)
        if not new_object:
            return None

        # copy over all attributes from old to new.
        for attr in original_object.get_all_attributes():
            new_object.attributes.add(attr.key, attr.value)

        # copy over all cmdsets, if any
        for icmdset, cmdset in enumerate(original_object.cmdset.all()):
            if icmdset == 0:
                new_object.cmdset.add_default(cmdset)
            else:
                new_object.cmdset.add(cmdset)

        # copy over all scripts, if any
        for script in original_object.scripts.all():
            ScriptDB.objects.copy_script(script, new_obj=new_object.dbobj)

        return new_object

    def clear_all_sessids(self):
        """
        Clear the db_sessid field of all objects having also the db_player field
        set.
        """
        self.filter(db_sessid__isnull=False).update(db_sessid=None)


########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding model 'ObjAttribute'
        db.create_table('objects_objattribute', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_value', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('db_mode', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
        ))
        db.send_create_signal('objects', ['ObjAttribute'])

        # Adding model 'Alias'
        db.create_table('objects_alias', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
        ))
        db.send_create_signal('objects', ['Alias'])

        # Adding model 'Nick'
        db.create_table('objects_nick', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_nick', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_real', self.gf('django.db.models.fields.TextField')()),
            ('db_type', self.gf('django.db.models.fields.CharField')(default='inputline', max_length=16, null=True, blank=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
        ))
        db.send_create_signal('objects', ['Nick'])

        # Adding unique constraint on 'Nick', fields ['db_nick', 'db_type', 'db_obj']
        db.create_unique('objects_nick', ['db_nick', 'db_type', 'db_obj_id'])

        # Adding model 'ObjectDB'
        db.create_table('objects_objectdb', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_typeclass_path', self.gf('django.db.models.fields.CharField')(max_length=255, null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_permissions', self.gf('django.db.models.fields.CharField')(max_length=512, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            # Moved to player migration
            #('db_player', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'], null=True, blank=True)),
            ('db_location', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='locations_set', null=True, to=orm['objects.ObjectDB'])),
            ('db_home', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='homes_set', null=True, to=orm['objects.ObjectDB'])),
            ('db_cmdset_storage', self.gf('django.db.models.fields.TextField')(null=True)),
        ))
        db.send_create_signal('objects', ['ObjectDB'])


    def backwards(self, orm):

        # Removing unique constraint on 'Nick', fields ['db_nick', 'db_type', 'db_obj']
        db.delete_unique('objects_nick', ['db_nick', 'db_type', 'db_obj_id'])

        # Deleting model 'ObjAttribute'
        db.delete_table('objects_objattribute')

        # Deleting model 'Alias'
        db.delete_table('objects_alias')

        # Deleting model 'Nick'
        db.delete_table('objects_nick')

        # Deleting model 'ObjectDB'
        db.delete_table('objects_objectdb')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.nick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'Nick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_mode': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_objattribute_db_mode
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

# overloading pickle to have it find the PackedDBobj in this module
import pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

renametable = {
        'src.typeclasses.models': 'src.objects.migrations.0019_convert_attrdata',
        'PackedDBobject': 'PackedDBobject',
}

def mapname(name):
    if name in renametable:
        return renametable[name]
    return name

def mapped_load_global(self):
    module = mapname(self.readline()[:-1])
    name = mapname(self.readline()[:-1])
    klass = self.find_class(module, name)
    self.append(klass)

def loads(str):
    file = StringIO(str)
    unpickler = pickle.Unpickler(file)
    unpickler.dispatch[pickle.GLOBAL] = mapped_load_global
    return unpickler.load()

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Deleting field 'ObjAttribute.db_mode'

        if not db.dry_run:
            for attr in orm["objects.ObjAttribute"].objects.all():
                # resave attributes
                db_mode = attr.db_mode
                if db_mode and db_mode != 'pickle':
                    # an object. We need to resave this.
                    if db_mode == 'object':
                        val = PackedDBobject(attr.db_value, "objectdb")
                    elif db_mode == 'player':
                        val = PackedDBobject(attr.db_value, "playerdb")
                    elif db_mode == 'script':
                        val = PackedDBobject(attr.db_value, "scriptdb")
                    elif db_mode == 'help':
                        val = PackedDBobject(attr.db_value, "helpentry")
                    else:
                        val = PackedDBobject(attr.db_value, db_mode) # channel, msg
                    attr.value = val

        db.delete_column('objects_objattribute', 'db_mode')


    def backwards(self, orm):

        # Adding field 'ObjAttribute.db_mode'
        db.add_column('objects_objattribute', 'db_mode', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True), keep_default=False)


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.nick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'Nick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_objectdb_db_destination
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from src.objects.models import ObjectDB
from south import orm

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'ObjectDB.db_destination'
        db.add_column('objects_objectdb', 'db_destination', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='destinations_set', null=True, to=orm['objects.ObjectDB']), keep_default=False)

        #move all exits to the new property
        if not db.dry_run:
            #for exi in ObjectDB.objects.get_objs_with_attr('_destination'):
            #for exi in orm["objects.ObjAttribute"].objects.get_objs_with_attr('_destination'):
            for exi in orm["objects.ObjAttribute"].objects.select_related("db_obj").filter(db_key="_destination").values_list('db_obj'):
                exi.destination = exi.db._destination
                exi.del_attribute('_destination')

    def backwards(self, orm):

        # Deleting field 'ObjectDB.db_destination'
        db.delete_column('objects_objectdb', 'db_destination_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.nick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'Nick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0004_rename_nick_to_objectnick
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models, utils

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        try:
            # if we migrate, we just rename the table. This will move over all values too.
            db.rename_table("objects_nick", "objects_objectnick")
        except utils.DatabaseError:
            # this happens if we start from scratch. In that case the old
            # database table doesn't exist, so we just create the new one.
        
            # Adding model 'ObjectNick'
            db.create_table('objects_objectnick', (
                ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                ('db_nick', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
                ('db_real', self.gf('django.db.models.fields.TextField')()),
                ('db_type', self.gf('django.db.models.fields.CharField')(default='inputline', max_length=16, null=True, blank=True)),
                ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
            ))
            db.send_create_signal('objects', ['ObjectNick'])

            # Adding unique constraint on 'ObjectNick', fields ['db_nick', 'db_type', 'db_obj']
            db.create_unique('objects_objectnick', ['db_nick', 'db_type', 'db_obj_id'])


    def backwards(self, orm):
        raise RuntimeError("This migration cannot be reversed.")


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0005_add_object_default_locks
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."

        # we need to add a default lock string to all objects, then a separate set to Characters.

        lockstring1 = 'control:id(1);get:all();edit:perm(Wizards);examine:perm(Builders);call:true();puppet:id(#4) or perm(Immortals) or pperm(Immortals);delete:id(1) or perm(Wizards)'
        lockstring2 = 'control:id(#3) or perm(Immortals);get:perm(Wizards);edit:perm(Wizards);examine:perm(Builders);call:false();puppet:id(%i) or pid(%i) or perm(Immortals) or pperm(Immortals);delete:perm(Wizards)'

        try:
            for obj in orm.ObjectDB.objects.all().exclude(db_player__isnull=False):
                obj.db_lock_storage = lockstring1
                obj.save()
            for obj in orm.ObjectDB.objects.filter(db_player__isnull=False):
                obj.db_lock_storage = lockstring2 % (obj.id, obj.db_player.id)
                obj.save()

        except utils.DatabaseError:
            # running from scatch. In this case we just ignore this.
            pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("You cannot reverse this migration.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0006_add_view_lock
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."

        lockstring1 = 'control:id(1);get:all();edit:perm(Wizards);view:all();examine:perm(Builders);call:true();puppet:id(#4) or perm(Immortals) or pperm(Immortals);delete:id(1) or perm(Wizards)'
        lockstring2 = 'control:id(#3) or perm(Immortals);get:perm(Wizards);edit:perm(Wizards);view:all();examine:perm(Builders);call:false();puppet:id(%i) or pid(%i) or perm(Immortals) or pperm(Immortals);delete:perm(Wizards)'

        try:
            for obj in orm.ObjectDB.objects.all().exclude(db_player__isnull=False):
                obj.db_lock_storage = lockstring1
                obj.save()
            for obj in orm.ObjectDB.objects.filter(db_player__isnull=False):
                obj.db_lock_storage = lockstring2 % (obj.id, obj.db_player.id)
                obj.save()
        
        except utils.DatabaseError:
            # running from scatch. In this case we just ignore this.
            pass 

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("You cannot reverse this migration.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0007_auto__chg_field_objectdb_db_cmdset_storage__chg_field_objectdb_db_lock
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'ObjectDB.db_cmdset_storage'
        db.alter_column('objects_objectdb', 'db_cmdset_storage', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

        # Changing field 'ObjectDB.db_lock_storage'
        db.alter_column('objects_objectdb', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'ObjectDB.db_permissions'
        db.alter_column('objects_objectdb', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=255))

        # Changing field 'ObjAttribute.db_lock_storage'
        db.alter_column('objects_objattribute', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))


    def backwards(self, orm):
        
        # Changing field 'ObjectDB.db_cmdset_storage'
        db.alter_column('objects_objectdb', 'db_cmdset_storage', self.gf('django.db.models.fields.TextField')(null=True))

        # Changing field 'ObjectDB.db_lock_storage'
        db.alter_column('objects_objectdb', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

        # Changing field 'ObjectDB.db_permissions'
        db.alter_column('objects_objectdb', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'ObjAttribute.db_lock_storage'
        db.alter_column('objects_objattribute', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0008_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding index on 'ObjectDB', fields ['db_key']
        db.create_index('objects_objectdb', ['db_key'])

        # Adding index on 'Alias', fields ['db_key']
        db.create_index('objects_alias', ['db_key'])

        # Adding index on 'ObjAttribute', fields ['db_key']
        db.create_index('objects_objattribute', ['db_key'])


    def backwards(self, orm):

        # Removing index on 'ObjAttribute', fields ['db_key']
        db.delete_index('objects_objattribute', ['db_key'])

        # Removing index on 'Alias', fields ['db_key']
        db.delete_index('objects_alias', ['db_key'])

        # Removing index on 'ObjectDB', fields ['db_key']
        db.delete_index('objects_objectdb', ['db_key'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0009_converting_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    import cPickle as pickle
except ImportError:
    import pickle
from src.utils.utils import to_str, to_unicode
from django.contrib.contenttypes.models import ContentType
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()
def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

def from_attr(attr, datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.dbref_search(data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject:
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return PackedDict(attr, dict(zip([key for key in item.keys()],
                                             [iter_id2db(val) for val in item.values()])))
        elif hasattr(item, '__iter__'):
            return PackedList(attr, list(iter_id2db(val) for val in item))
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."

        if not db.dry_run:
            for attr in orm.ObjAttribute.objects.all():
                # repack attr into new format, and reimport
                try:
                    val = pickle.loads(to_str(attr.db_value))
                    if hasattr(val, '__iter__'):
                        val = ("iter", val)
                    elif type(val) == PackedDBobject:
                        val = ("dbobj", val)
                    else:
                        val = ("simple", val)
                    attr.db_value = to_unicode(pickle.dumps(to_str(to_attr(from_attr(attr, val)))))
                    attr.save()
                except TypeError, RuntimeError:
                    pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0010_converting_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    import cPickle as pickle
except ImportError:
    import pickle
from src.utils.utils import to_str, to_unicode
#from src.typeclasses.models import PackedDBobject

from django.contrib.contenttypes.models import ContentType
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)


class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

        """
        self.db_obj = db_obj
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.db_obj.value = self
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.db_obj.value = self
    def pop(self, *args, **kwargs):
        "Custom pop"
        super(PackedDict, self).pop(*args, **kwargs)
        self.db_obj.value = self
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        super(PackedDict, self).popitem(*args, **kwargs)
        self.db_obj.value = self
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.db_obj.value = self

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing list.
         db_obj - the Attribute object storing this dict.
        """
        self.db_obj = db_obj
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.db_obj.value = self
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.db_obj.value = self
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.db_obj.value = self
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.db_obj.value = self
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.db_obj.value = self
    def pop(self, *args, **kwargs):
        "Custom pop"
        super(PackedList, self).pop(*args, **kwargs)
        self.db_obj.value = self
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.db_obj.value = self
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.db_obj.value = self


def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

def from_attr(attr, datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.dbref_search(data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject:
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return dict(zip([key for key in item.keys()],
                            [iter_id2db(val) for val in item.values()]))
        elif hasattr(item, '__iter__'):
            return list(iter_id2db(val) for val in item)
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."

        for attr in orm.ObjAttribute.objects.all():
            # repack attr into new format, and reimport
            try:
                val = pickle.loads(to_str(attr.db_value))
                attr.db_value = to_unicode(pickle.dumps(to_str(to_attr(from_attr(attr, val)))))
                attr.save()
            except TypeError, RuntimeError:
                pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0011_typeclass_and_cmdset_to_new_api_default
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            for obj in orm.ObjectDB.objects.all():
                if obj.db_cmdset_storage == "game.gamesrc.commands.basecmdset.DefaultCmdSet":
                    obj.db_cmdset_storage = "src.commands.default.cmdset_default.DefaultCmdSet"
                    obj.save()
                if obj.db_typeclass_path == "game.gamesrc.objects.baseobjects.Character":
                    obj.db_typeclass_path = "src.objects.objects.Character"
                    obj.save()
                if obj.db_typeclass_path == "game.gamesrc.objects.baseobjects.Object":
                    obj.db_typeclass_path = "src.objects.objects.Object"
                    obj.save()
                if obj.db_typeclass_path == "game.gamesrc.objects.baseobjects.Room":
                    obj.db_typeclass_path = "src.objects.objects.Room"
                    obj.save()
                if obj.db_typeclass_path == "game.gamesrc.objects.baseobjects.Exit":
                    obj.db_typeclass_path = "src.objects.objects.Exit"
                    obj.save()

        except utils.DatabaseError:
            "We are starting from scratch. Ignore."
            pass



    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0012_index_objattr_values
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding index on 'ObjAttribute', fields ['db_value']
        # removing this migration completely.
        pass

    def backwards(self, orm):
        # Removing index on 'ObjAttribute', fields ['db_value']
        raise RuntimeError


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0013_revert_objattr_index
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Removing index on 'ObjAttribute', fields ['db_value']
        if orm.ObjAttribute._meta.get_field_by_name("db_value")[0].db_index:
            db.delete_index('objects_objattribute', ['db_value'])

    def backwards(self, orm):
        # Adding index on 'ObjAttribute', fields ['db_value']
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0014_auto__chg_field_objectdb_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ObjectDB.db_lock_storage'
        db.alter_column('objects_objectdb', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'ObjectDB.db_lock_storage'
        db.alter_column('objects_objectdb', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']
########NEW FILE########
__FILENAME__ = 0015_auto__chg_field_objattribute_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ObjAttribute.db_lock_storage'
        db.alter_column('objects_objattribute', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'ObjAttribute.db_lock_storage'
        db.alter_column('objects_objattribute', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']
########NEW FILE########
__FILENAME__ = 0016_add_sessid
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'ObjectDB.db_sessid'
        db.add_column('objects_objectdb', 'db_sessid',
                      self.gf('django.db.models.fields.IntegerField')(null=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'ObjectDB.db_sessid'
        db.delete_column('objects_objectdb', 'db_sessid')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']
########NEW FILE########
__FILENAME__ = 0017_rename_default_cmdsets
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    depends_on = (('players', '0014_add_attr__playable_characters'),)
    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."
        if not db.dry_run:
            for obj in orm['objects.ObjectDB'].objects.filter(db_cmdset_storage=u'src.commands.default.cmdset_default.DefaultCmdSet'):
                obj.db_cmdset_storage=u'src.commands.default.cmdset_character.CharacterCmdSet'
                obj.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("You cannot revert this migration.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0018_add_picklefield
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'ObjAttribute.db_value2'
        db.add_column('objects_objattribute', 'db_value2',
                      self.gf('src.utils.picklefield.PickledObjectField')(null=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'ObjAttribute.db_value2'
        db.delete_column('objects_objattribute', 'db_value2')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']
########NEW FILE########
__FILENAME__ = 0019_convert_attrdata
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.contrib.contenttypes.models import ContentType

from src.utils.utils import to_str
from src.utils.dbserialize import to_pickle
try:
    import cPickle as pickle
except ImportError:
    import pickle
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__


# overloading pickle to have it find the PackedDBobj in this module
import pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

renametable = {
        'src.typeclasses.models': 'src.objects.migrations.0019_convert_attrdata',
        'PackedDBobject': 'PackedDBobject',
}

def mapname(name):
    if name in renametable:
        return renametable[name]
    return name

def mapped_load_global(self):
    module = mapname(self.readline()[:-1])
    name = mapname(self.readline()[:-1])
    klass = self.find_class(module, name)
    self.append(klass)

def loads(str):
    file = StringIO(str)
    unpickler = pickle.Unpickler(file)
    unpickler.dispatch[pickle.GLOBAL] = mapped_load_global
    return unpickler.load()



class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()

def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        # modified for migration - converts to plain python properties
        def from_attr(datatuple):
            """
            Retrieve data from a previously stored attribute. This
            is always a dict with keys type and data.

            datatuple comes from the database storage and has
            the following format:
               (simple|dbobj|iter, <data>)
            where
                simple - a single non-db object, like a string. is returned as-is.
                dbobj - a single dbobj-id. This id is retrieved back from the database.
                iter - an iterable. This is traversed iteratively, converting all found
                       dbobj-ids back to objects. Also, all lists and dictionaries are
                       returned as their PackedList/PackedDict counterparts in order to
                       allow in-place assignment such as obj.db.mylist[3] = val. Mylist
                       is then a PackedList that saves the data on the fly.
            """
            # nested functions
            def id2db(data):
                """
                Convert db-stored dbref back to object
                """
                #app_map = {'objectdb':".objects.objectdb", "scriptdb":"scripts.scriptdb", "playerdb":"players.playerdb"}
                #print "data.db_model:", data.db_model
                #mclass = orm[data.db_model].model_class()
                mclass = CTYPEGET(model=data.db_model).model_class()
                try:
                    return mclass.objects.get(id=data.id)
                except AttributeError:
                    try:
                        return mclass.objects.get(id=data.id)
                    except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                        return None
                except TypeError, e:
                    print e

            def iter_id2db(item):
                """
                Recursively looping through stored iterables, replacing ids with actual objects.
                We return PackedDict and PackedLists instead of normal lists; this is needed in order for
                the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
                stored in the database are however always normal python primitives.
                """
                dtype = type(item)
                if dtype in (basestring, int, float, long, bool): # check the most common types first, for speed
                    return item
                elif dtype == PackedDBobject or hasattr(item, '__class__') and item.__class__.__name__ == "PackedDBobject":
                    return id2db(item)
                elif dtype == tuple:
                    return tuple([iter_id2db(val) for val in item])
                elif dtype in (dict, PackedDict):
                    return dict(zip([key for key in item.keys()],
                                                     [iter_id2db(val) for val in item.values()]))
                elif hasattr(item, '__iter__'):
                    return list(iter_id2db(val) for val in item)
                else:
                    return item

            typ, data = datatuple

            if typ == 'simple':
                # single non-db objects
                return data
            elif typ == 'dbobj':
                # a single stored dbobj
                return id2db(data)
            elif typ == 'iter':
                # all types of iterables
                return iter_id2db(data)

        if not db.dry_run:
            for attr in orm['objects.ObjAttribute'].objects.all():
                # repack attr into new format and reimport
                datatuple = loads(to_str(attr.db_value))
                python_data = from_attr(datatuple)
                new_data = to_pickle(python_data)
                attr.db_value2 = new_data # new pickleObjectField
                attr.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("This migration cannot be reversed.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0020_remove_old_attr_value_field
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'ObjAttribute.db_value'
        db.delete_column('objects_objattribute', 'db_value')
        db.rename_column('objects_objattribute', 'db_value2', 'db_value')


    def backwards(self, orm):
        # Adding field 'ObjAttribute.db_value'
        db.add_column('objects_objattribute', 'db_value',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)
        db.rename_column('objects_objattribute', 'db_value', 'db_value2')



    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0021_auto__del_objattribute
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'ObjAttribute'
        db.delete_table(u'objects_objattribute')

        # Adding M2M table for field db_attributes on 'ObjectDB'
        db.create_table(u'objects_objectdb_db_attributes', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('objectdb', models.ForeignKey(orm[u'objects.objectdb'], null=False)),
            ('attribute', models.ForeignKey(orm[u'typeclasses.attribute'], null=False))
        ))
        db.create_unique(u'objects_objectdb_db_attributes', ['objectdb_id', 'attribute_id'])


    def backwards(self, orm):
        # Adding model 'ObjAttribute'
        db.create_table(u'objects_objattribute', (
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_value2', self.gf('src.utils.picklefield.PickledObjectField')(null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('objects', ['ObjAttribute'])

        # Removing M2M table for field db_attributes on 'ObjectDB'
        db.delete_table('objects_objectdb_db_attributes')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects']
########NEW FILE########
__FILENAME__ = 0022_add_db_liteattributes_db_tags
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding M2M table for field db_liteattributes on 'ObjectDB'
        m2m_table_name = db.shorten_name(u'objects_objectdb_db_liteattributes')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('objectdb', models.ForeignKey(orm[u'objects.objectdb'], null=False)),
            ('liteattribute', models.ForeignKey(orm[u'typeclasses.liteattribute'], null=False))
        ))
        db.create_unique(m2m_table_name, ['objectdb_id', 'liteattribute_id'])

        # Adding M2M table for field db_tags on 'ObjectDB'
        m2m_table_name = db.shorten_name(u'objects_objectdb_db_tags')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('objectdb', models.ForeignKey(orm[u'objects.objectdb'], null=False)),
            ('tag', models.ForeignKey(orm[u'typeclasses.tag'], null=False))
        ))
        db.create_unique(m2m_table_name, ['objectdb_id', 'tag_id'])


    def backwards(self, orm):
        # Removing M2M table for field db_liteattributes on 'ObjectDB'
        db.delete_table(db.shorten_name(u'objects_objectdb_db_liteattributes'))

        # Removing M2M table for field db_tags on 'ObjectDB'
        db.delete_table(db.shorten_name(u'objects_objectdb_db_tags'))


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0023_auto__del_objectnick__del_unique_objectnick_db_nick_db_type_db_obj__de
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    depends_on = (('typeclasses', '0004_copy_nicks_to_liteattrs_aliases_to_tags'),)

    def forwards(self, orm):
        # Removing unique constraint on 'ObjectNick', fields ['db_nick', 'db_type', 'db_obj']
        db.delete_unique(u'objects_objectnick', ['db_nick', 'db_type', 'db_obj_id'])

        # Deleting model 'ObjectNick'
        db.delete_table(u'objects_objectnick')

        # Deleting model 'Alias'
        db.delete_table(u'objects_alias')


    def backwards(self, orm):
        # Adding model 'ObjectNick'
        db.create_table(u'objects_objectnick', (
            ('db_type', self.gf('django.db.models.fields.CharField')(default='inputline', max_length=16, null=True, blank=True)),
            ('db_nick', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_real', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'objects', ['ObjectNick'])

        # Adding unique constraint on 'ObjectNick', fields ['db_nick', 'db_type', 'db_obj']
        db.create_unique(u'objects_objectnick', ['db_nick', 'db_type', 'db_obj_id'])

        # Adding model 'Alias'
        db.create_table(u'objects_alias', (
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'])),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal(u'objects', ['Alias'])


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects']

########NEW FILE########
__FILENAME__ = 0024_move_permissions_to_handler
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        Tag = orm['typeclasses.Tag']
        for obj in orm.ObjectDB.objects.all():
            if obj.db_permissions:
                for perm in [perm.strip() for perm in obj.db_permissions.split(",")]:
                    tag = Tag.objects.filter(db_key=perm.lower().strip(), db_category="permissions")
                    if tag:
                        tag = tag[0]
                    else:
                        tag = Tag(db_key=perm.lower().strip(), db_category="permissions")
                        tag.save()
                    obj.db_tags.add(tag)

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0025_auto__del_field_objectdb_db_permissions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'ObjectDB.db_permissions'
        db.delete_column(u'objects_objectdb', 'db_permissions')


    def backwards(self, orm):
        # Adding field 'ObjectDB.db_permissions'
        db.add_column(u'objects_objectdb', 'db_permissions',
                      self.gf('django.db.models.fields.CharField')(default='', max_length=255, blank=True),
                      keep_default=False)


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects']
########NEW FILE########
__FILENAME__ = models
"""
This module defines the database models for all in-game objects, that
is, all objects that has an actual existence in-game.

Each database object is 'decorated' with a 'typeclass', a normal
python class that implements all the various logics needed by the game
in question. Objects created of this class transparently communicate
with its related database object for storing all attributes. The
admin should usually not have to deal directly with this database
object layer.

Attributes are separate objects that store values persistently onto
the database object. Like everything else, they can be accessed
transparently through the decorating TypeClass.
"""

import traceback
from django.db import models
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist

from src.typeclasses.models import (TypedObject, TagHandler, NickHandler,
                                    AliasHandler, AttributeHandler)
from src.objects.manager import ObjectManager
from src.players.models import PlayerDB
from src.commands.cmdsethandler import CmdSetHandler
from src.commands import cmdhandler
from src.scripts.scripthandler import ScriptHandler
from src.utils import logger
from src.utils.utils import (make_iter, to_str, to_unicode,
                             variable_from_module, dbref)

from django.utils.translation import ugettext as _

#__all__ = ("ObjectDB", )

_ScriptDB = None
_AT_SEARCH_RESULT = variable_from_module(*settings.SEARCH_AT_RESULT.rsplit('.', 1))
_SESSIONS = None

_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__


#------------------------------------------------------------
#
# ObjectDB
#
#------------------------------------------------------------

class ObjectDB(TypedObject):
    """
    All objects in the game use the ObjectDB model to store
    data in the database. This is handled transparently through
    the typeclass system.

    Note that the base objectdb is very simple, with
    few defined fields. Use attributes to extend your
    type class with new database-stored variables.

    The TypedObject supplies the following (inherited) properties:
      key - main name
      name - alias for key
      typeclass_path - the path to the decorating typeclass
      typeclass - auto-linked typeclass
      date_created - time stamp of object creation
      permissions - perm strings
      locks - lock definitions (handler)
      dbref - #id of object
      db - persistent attribute storage
      ndb - non-persistent attribute storage

    The ObjectDB adds the following properties:
      player - optional connected player (always together with sessid)
      sessid - optional connection session id (always together with player)
      location - in-game location of object
      home - safety location for object (handler)

      scripts - scripts assigned to object (handler from typeclass)
      cmdset - active cmdset on object (handler from typeclass)
      aliases - aliases for this object (property)
      nicks - nicknames for *other* things in Evennia (handler)
      sessions - sessions connected to this object (see also player)
      has_player - bool if an active player is currently connected
      contents - other objects having this object as location
      exits - exits from this object
    """

    #
    # ObjectDB Database model setup
    #
    #
    # inherited fields (from TypedObject):
    # db_key (also 'name' works), db_typeclass_path, db_date_created,
    # db_permissions
    #
    # These databse fields (including the inherited ones) should normally be
    # managed by their corresponding wrapper properties, named same as the
    # field, but without the db_* prefix (e.g. the db_key field is set with
    # self.key instead). The wrappers are created at the metaclass level and
    # will automatically save and cache the data more efficiently.

    # If this is a character object, the player is connected here.
    db_player = models.ForeignKey("players.PlayerDB", blank=True, null=True, verbose_name='player', on_delete=models.SET_NULL,
                                  help_text='a Player connected to this object, if any.')
    # the session id associated with this player, if any
    db_sessid = models.IntegerField(null=True, verbose_name="session id",
                                    help_text="unique session id of connected Player, if any.")
    # The location in the game world. Since this one is likely
    # to change often, we set this with the 'location' property
    # to transparently handle Typeclassing.
    db_location = models.ForeignKey('self', related_name="locations_set", db_index=True, on_delete=models.SET_NULL,
                                     blank=True, null=True, verbose_name='game location')
    # a safety location, this usually don't change much.
    db_home = models.ForeignKey('self', related_name="homes_set", on_delete=models.SET_NULL,
                                 blank=True, null=True, verbose_name='home location')
    # destination of this object - primarily used by exits.
    db_destination = models.ForeignKey('self', related_name="destinations_set", db_index=True, on_delete=models.SET_NULL,
                                       blank=True, null=True, verbose_name='destination',
                                       help_text='a destination, used only by exit objects.')
    # database storage of persistant cmdsets.
    db_cmdset_storage = models.CharField('cmdset', max_length=255, null=True, blank=True,
                                         help_text="optional python path to a cmdset class.")

    # Database manager
    objects = ObjectManager()

    # caches for quick lookups of typeclass loading.
    _typeclass_paths = settings.OBJECT_TYPECLASS_PATHS
    _default_typeclass_path = settings.BASE_OBJECT_TYPECLASS or "src.objects.objects.Object"

    # Add the object-specific handlers
    def __init__(self, *args, **kwargs):
        "Parent must be initialized first."
        TypedObject.__init__(self, *args, **kwargs)
        # handlers
        _SA(self, "cmdset", CmdSetHandler(self))
        _GA(self, "cmdset").update(init_mode=True)
        _SA(self, "scripts", ScriptHandler(self))
        _SA(self, "attributes", AttributeHandler(self))
        _SA(self, "nicks", NickHandler(self))
        _SA(self, "tags", TagHandler(self))
        _SA(self, "aliases", AliasHandler(self))
        # make sure to sync the contents cache when initializing
        #_GA(self, "contents_update")()

    def _at_db_player_presave(self):
        """
        This hook is called automatically just before the player field is saved.
        """
        # we need to re-cache this for superusers to bypass.
        self.locks.cache_lock_bypass(self)

    # cmdset_storage property. We use a custom wrapper to manage this. This also
    # seems very sensitive to caching, so leaving it be for now. /Griatch
    #@property
    def __cmdset_storage_get(self):
        """
        Getter. Allows for value = self.name.
        Returns a list of cmdset_storage.
        """
        storage = _GA(self, "db_cmdset_storage")
        # we need to check so storage is not None
        return [path.strip() for path in storage.split(',')] if storage else []
    #@cmdset_storage.setter
    def __cmdset_storage_set(self, value):
        """
        Setter. Allows for self.name = value.
        Stores as a comma-separated string.
        """
        _SA(self, "db_cmdset_storage", ",".join(str(val).strip() for val in make_iter(value)))
        _GA(self, "save")()
    #@cmdset_storage.deleter
    def __cmdset_storage_del(self):
        "Deleter. Allows for del self.name"
        _SA(self, "db_cmdset_storage", None)
        _GA(self, "save")()
    cmdset_storage = property(__cmdset_storage_get, __cmdset_storage_set, __cmdset_storage_del)

    # location getsetter
    def __location_get(self):
        "Get location"
        loc = _GA(_GA(self, "dbobj"), "db_location")
        return _GA(loc, "typeclass") if loc else loc

    def __location_set(self, location):
        "Set location, checking for loops and allowing dbref"
        if isinstance(location, (basestring, int)):
            # allow setting of #dbref
            dbid = dbref(location, reqhash=False)
            if dbid:
                try:
                    location = ObjectDB.objects.get(id=dbid)
                except ObjectDoesNotExist:
                    # maybe it is just a name that happens to look like a dbid
                    pass
        try:
            def is_loc_loop(loc, depth=0):
                "Recursively traverse target location, trying to catch a loop."
                if depth > 10:
                    return
                elif loc == self:
                    raise RuntimeError
                elif loc == None:
                    raise RuntimeWarning
                return is_loc_loop(_GA(_GA(loc, "dbobj"), "db_location"), depth + 1)
            try:
                is_loc_loop(location)
            except RuntimeWarning:
                pass
            # actually set the field
            _SA(_GA(self, "dbobj"), "db_location", _GA(location, "dbobj") if location else location)
            _GA(_GA(self, "dbobj"), "save")(update_fields=["db_location"])
        except RuntimeError:
            errmsg = "Error: %s.location = %s creates a location loop." % (self.key, location)
            logger.log_errmsg(errmsg)
            raise RuntimeError(errmsg)
        except Exception, e:
            errmsg = "Error (%s): %s is not a valid location." % (str(e), location)
            logger.log_errmsg(errmsg)
            raise Exception(errmsg)

    def __location_del(self):
        "Cleably delete the location reference"
        _SA(_GA(self, "dbobj"), "db_location", None)
        _GA(_GA(self, "dbobj"), "save")(upate_fields=["db_location"])
    location = property(__location_get, __location_set, __location_del)


    class Meta:
        "Define Django meta options"
        verbose_name = "Object"
        verbose_name_plural = "Objects"

    #
    # ObjectDB class access methods/properties
    #

    #@property
    def __sessions_get(self):
        """
        Retrieve sessions connected to this object.
        """
        # if the player is not connected, this will simply be an empty list.
        if _GA(self, "db_player"):
            return _GA(_GA(self, "db_player"), "get_all_sessions")()
        return []
    sessions = property(__sessions_get)

    #@property
    def __has_player_get(self):
        """
        Convenience function for checking if an active player is
        currently connected to this object
        """
        return any(_GA(self, "sessions"))
    has_player = property(__has_player_get)
    is_player = property(__has_player_get)

    #@property
    def __is_superuser_get(self):
        "Check if user has a player, and if so, if it is a superuser."
        return (_GA(self, "db_player") and _GA(_GA(self, "db_player"), "is_superuser")
                and not _GA(_GA(self, "db_player"), "attributes").get("_quell"))
    is_superuser = property(__is_superuser_get)

    # contents

    def contents_get(self, exclude=None):
        """
        Returns the contents of this object, i.e. all
        objects that has this object set as its location.
        This should be publically available.

        exclude is one or more objects to not return
        """
        if exclude:
            return ObjectDB.objects.get_contents(self, excludeobj=exclude)
        return ObjectDB.objects.get_contents(self)
    contents = property(contents_get)

    #@property
    def __exits_get(self):
        """
        Returns all exits from this object, i.e. all objects
        at this location having the property destination != None.
        """
        return [exi for exi in _GA(self, "contents")
                if exi.destination]
    exits = property(__exits_get)

    #
    # Main Search method
    #

    def search(self, searchdata,
               global_search=False,
               use_nicks=True,  # should this default to off?
               typeclass=None,
               location=None,
               attribute_name=None,
               quiet=False,
               exact=False):
        """
        Returns the typeclass of an Object matching a search string/condition

        Perform a standard object search in the database, handling
        multiple results and lack thereof gracefully. By default, only
        objects in self's current location or inventory is searched.
        Note: to find Players, use eg. ev.player_search.

        Inputs:

        searchdata (str or obj): Primary search criterion. Will be matched
                    against object.key (with object.aliases second) unless
                    the keyword attribute_name specifies otherwise.
                    Special strings:
                        #<num> - search by unique dbref. This is always
                                 a global search.
                        me,self - self-reference to this object
                        <num>-<string> - can be used to differentiate
                                         between multiple same-named matches
        global_search (bool): Search all objects globally. This is overruled
                              by "location" keyword.
        use_nicks (bool): Use nickname-replace (nicktype "object") on the
                          search string
        typeclass (str or Typeclass, or list of either): Limit search only
                   to Objects with this typeclass. May be a list of typeclasses
                   for a broader search.
        location (Object): Specify a location to search, if different from the
                     self's given location plus its contents. This can also
                     be a list of locations.
        attribute_name (str): Define which property to search. If set, no
                      key+alias search will be performed. This can be used to
                      search database fields (db_ will be automatically
                      appended), and if that fails, it will try to return
                      objects having Attributes with this name and value
                      equal to searchdata. A special use is to search for
                      "key" here if you want to do a key-search without
                      including aliases.
        quiet (bool) - don't display default error messages - return multiple
                      matches as a list and no matches as None. If not
                      set (default), will echo error messages and return None.
        exact (bool) - if unset (default) - prefers to match to beginning of
                      string rather than not matching at all. If set, requires
                      exact mathing of entire string.

        Returns:
            quiet=False (default):
                no match or multimatch:
                auto-echoes errors to self.msg, then returns None
                    (results are handled by settings.SEARCH_AT_RESULT
                               and settings.SEARCH_AT_MULTIMATCH_INPUT)
                match:
                    a unique object match
            quiet=True:
                no match or multimatch:
                    returns None or list of multi-matches
                match:
                    a unique object match

        """
        is_string = isinstance(searchdata, basestring)

        if use_nicks:
            # do nick-replacement on search
            searchdata = self.nicks.nickreplace(searchdata, categories=("object", "player"), include_player=True)

        candidates=None
        if(global_search or (is_string and searchdata.startswith("#") and
                    len(searchdata) > 1 and searchdata[1:].isdigit())):
            # only allow exact matching if searching the entire database
            # or unique #dbrefs
            exact = True
        elif location:
            # location(s) were given
            candidates = []
            for obj in make_iter(location):
                candidates.extend([o.dbobj for o in obj.contents])
        else:
            # local search. Candidates are self.contents, self.location
            # and self.location.contents
            location = self.location
            candidates = self.contents
            if location:
                candidates = candidates + [location] + location.contents
            else:
                # normally we are included in location.contents
                candidates.append(self)
            # db manager expects database objects
            candidates = [obj.dbobj for obj in candidates]

        results = ObjectDB.objects.object_search(searchdata,
                                                 attribute_name=attribute_name,
                                                 typeclass=typeclass,
                                                 candidates=candidates,
                                                 exact=exact)
        if quiet:
            return results
        return  _AT_SEARCH_RESULT(self, searchdata, results, global_search)

    def search_player(self, searchdata, quiet=False):
        """
        Simple shortcut wrapper to search for players, not characters.

        searchdata - search criterion - the key or dbref of the player
                     to search for. If this is "here" or "me", search
                     for the player connected to this object.
        quiet - return the results as a list rather than echo eventual
                standard error messages.

        Returns:
            quiet=False (default):
                no match or multimatch:
                    auto-echoes errors to self.msg, then returns None
                    (results are handled by settings.SEARCH_AT_RESULT
                                 and settings.SEARCH_AT_MULTIMATCH_INPUT)
                match:
                    a unique player match
            quiet=True:
                no match or multimatch:
                    returns None or list of multi-matches
                match:
                    a unique object match
        """
        results = PlayerDB.objects.player_search(searchdata)
        if quiet:
            return results
        return _AT_SEARCH_RESULT(self, searchdata, results, global_search=True)

    #
    # Execution/action methods
    #

    def execute_cmd(self, raw_string, sessid=None):
        """
        Do something as this object. This method is a copy of the execute_
        cmd method on the session. This is never called normally, it's only
        used when wanting specifically to let an object be the caller of a
        command. It makes use of nicks of eventual connected players as well.

        Argument:
        raw_string (string) - raw command input
        sessid (int) - optional session id to return results to

        Returns Deferred - this is an asynchronous Twisted object that will
            not fire until the command has actually finished executing. To
            overload this one needs to attach callback functions to it, with
            addCallback(function). This function will be called with an
            eventual return value from the command execution.

            This return is not used at all by Evennia by default, but might
            be useful for coders intending to implement some sort of nested
            command structure.
        """
        # nick replacement - we require full-word matching.

        # do text encoding conversion
        raw_string = to_unicode(raw_string)
        raw_string = self.nicks.nickreplace(raw_string,
                     categories=("inputline", "channel"), include_player=True)
        return cmdhandler.cmdhandler(_GA(self, "typeclass"), raw_string, callertype="object", sessid=sessid)

    def msg(self, text=None, from_obj=None, sessid=0, **kwargs):
        """
        Emits something to a session attached to the object.

        message (str): The message to send
        from_obj (obj): object that is sending.
        data (object): an optional data object that may or may not
                       be used by the protocol.
        sessid (int): sessid to relay to, if any.
                      If set to 0 (default), use either from_obj.sessid (if set) or self.sessid automatically
                      If None, echo to all connected sessions

        When this message is called, from_obj.at_msg_send and self.at_msg_receive are called.

        """
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS

        text = to_str(text, force_string=True) if text else ""

        if "data" in kwargs:
            # deprecation warning
            logger.log_depmsg("ObjectDB.msg(): 'data'-dict keyword is deprecated. Use **kwargs instead.")
            data = kwargs.pop("data")
            if isinstance(data, dict):
                kwargs.update(data)

        if from_obj:
            # call hook
            try:
                _GA(from_obj, "at_msg_send")(text=text, to_obj=_GA(self, "typeclass"), **kwargs)
            except Exception:
                logger.log_trace()
        try:
            if not _GA(_GA(self, "typeclass"), "at_msg_receive")(text=text, **kwargs):
                # if at_msg_receive returns false, we abort message to this object
                return
        except Exception:
            logger.log_trace()

        session = _SESSIONS.session_from_sessid(sessid if sessid else _GA(self, "sessid"))
        if session:
            session.msg(text=text, **kwargs)

    def msg_contents(self, message, exclude=None, from_obj=None, **kwargs):
        """
        Emits something to all objects inside an object.

        exclude is a list of objects not to send to. See self.msg() for
                more info.
        """
        contents = _GA(self, "contents")
        if exclude:
            exclude = make_iter(exclude)
            contents = [obj for obj in contents if obj not in exclude]
        for obj in contents:
            obj.msg(message, from_obj=from_obj, **kwargs)

    def move_to(self, destination, quiet=False,
                emit_to_obj=None, use_destination=True, to_none=False):
        """
        Moves this object to a new location.

        Moves this object to a new location. Note that if <destination> is an
        exit object (i.e. it has "destination"!=None), the move_to will
        happen to this destination and -not- into the exit object itself, unless
        use_destination=False. Note that no lock checks are done by this
        function, such things are assumed to have been handled before calling
        move_to.

        destination: (Object) Reference to the object to move to. This
                     can also be an exit object, in which case the destination
                     property is used as destination.
        quiet:  (bool)    If true, don't emit left/arrived messages.
        emit_to_obj: (Object) object to receive error messages
        use_destination (bool): Default is for objects to use the "destination"
                             property of destinations as the target to move to.
                             Turning off this keyword allows objects to move
                             "inside" exit objects.
        to_none - allow destination to be None. Note that no hooks are run when
                     moving to a None location. If you want to run hooks,
                     run them manually (and make sure they can manage None
                     locations).

        Returns True/False depending on if there were problems with the move.
                This method may also return various error messages to the
                emit_to_obj.
        """
        def logerr(string=""):
            trc = traceback.format_exc()
            errstring = "%s%s" % (trc, string)
            logger.log_trace()
            _GA(self, "msg")(errstring)

        errtxt = _("Couldn't perform move ('%s'). Contact an admin.")
        if not emit_to_obj:
            emit_to_obj = self

        if not destination:
            if to_none:
                # immediately move to None. There can be no hooks called since
                # there is no destination to call them with.
                self.location = None
                return True
            emit_to_obj.msg(_("The destination doesn't exist."))
            return
        if destination.destination and use_destination:
            # traverse exits
            destination = destination.destination

        # Before the move, call eventual pre-commands.
        try:
            if not self.at_before_move(_GA(destination, "typeclass")):
                return
        except Exception:
            logerr(errtxt % "at_before_move()")
            #emit_to_obj.msg(errtxt % "at_before_move()")
            #logger.log_trace()
            return False

        # Save the old location
        source_location = _GA(self, "location")
        if not source_location:
            # there was some error in placing this room.
            # we have to set one or we won't be able to continue
            if _GA(self, "home"):
                source_location = _GA(self, "home")
            else:
                default_home = ObjectDB.objects.get_id(settings.DEFAULT_HOME)
                source_location = default_home

        # Call hook on source location
        try:
            source_location.at_object_leave(_GA(self, "typeclass"), _GA(destination, "typeclass"))
        except Exception:
            logerr(errtxt % "at_object_leave()")
            #emit_to_obj.msg(errtxt % "at_object_leave()")
            #logger.log_trace()
            return False

        if not quiet:
            #tell the old room we are leaving
            try:
                self.announce_move_from(_GA(destination, "typeclass"))
            except Exception:
                logerr(errtxt % "at_announce_move()")
                #emit_to_obj.msg(errtxt % "at_announce_move()" )
                #logger.log_trace()
                return False

        # Perform move
        try:
            #print "move_to location:", destination
            _SA(self, "location", destination)
        except Exception:
            emit_to_obj.msg(errtxt % "location change")
            logger.log_trace()
            return False

        if not quiet:
            # Tell the new room we are there.
            try:
                self.announce_move_to(_GA(source_location, "typeclass"))
            except Exception:
                logerr(errtxt % "announce_move_to()")
                #emit_to_obj.msg(errtxt % "announce_move_to()")
                #logger.log_trace()
                return  False

        # Perform eventual extra commands on the receiving location
        # (the object has already arrived at this point)
        try:
            destination.at_object_receive(_GA(self, "typeclass"), _GA(source_location, "typeclass"))
        except Exception:
            logerr(errtxt % "at_object_receive()")
            #emit_to_obj.msg(errtxt % "at_object_receive()")
            #logger.log_trace()
            return False

        # Execute eventual extra commands on this object after moving it
        # (usually calling 'look')
        try:
            self.at_after_move(_GA(source_location, "typeclass"))
        except Exception:
            logerr(errtxt % "at_after_move")
            #emit_to_obj.msg(errtxt % "at_after_move()")
            #logger.log_trace()
            return False
        return True

    #
    # Object Swap, Delete and Cleanup methods
    #

    def clear_exits(self):
        """
        Destroys all of the exits and any exits pointing to this
        object as a destination.
        """
        for out_exit in [exi for exi in ObjectDB.objects.get_contents(self) if exi.db_destination]:
            out_exit.delete()
        for in_exit in ObjectDB.objects.filter(db_destination=self):
            in_exit.delete()

    def clear_contents(self):
        """
        Moves all objects (players/things) to their home
        location or to default home.
        """
        # Gather up everything that thinks this is its location.
        objs = ObjectDB.objects.filter(db_location=self)
        default_home_id = int(settings.DEFAULT_HOME.lstrip("#"))
        try:
            default_home = ObjectDB.objects.get(id=default_home_id)
            if default_home.dbid == _GA(self, "dbid"):
                # we are deleting default home!
                default_home = None
        except Exception:
            string = _("Could not find default home '(#%d)'.")
            logger.log_errmsg(string % default_home_id)
            default_home = None

        for obj in objs:
            home = obj.home
            # Obviously, we can't send it back to here.
            if not home or (home and home.dbid == _GA(self, "dbid")):
                obj.home = default_home
                home = default_home

            # If for some reason it's still None...
            if not home:
                string = "Missing default home, '%s(#%d)' "
                string += "now has a null location."
                obj.location = None
                obj.msg(_("Something went wrong! You are dumped into nowhere. Contact an admin."))
                logger.log_errmsg(string % (obj.name, obj.dbid))
                return

            if obj.has_player:
                if home:
                    string = "Your current location has ceased to exist,"
                    string += " moving you to %s(#%d)."
                    obj.msg(_(string) % (home.name, home.dbid))
                else:
                    # Famous last words: The player should never see this.
                    string = "This place should not exist ... contact an admin."
                    obj.msg(_(string))
            obj.move_to(home)

    def copy(self, new_key=None):
        """
        Makes an identical copy of this object. If you want to customize the
        copy by changing some settings, use ObjectDB.object.copy_object()
        directly.

        new_key (string) - new key/name of copied object. If new_key is not
                            specified, the copy will be named <old_key>_copy
                            by default.
        Returns: Object (copy of this one)
        """
        def find_clone_key():
            """
            Append 01, 02 etc to obj.key. Checks next higher number in the
            same location, then adds the next number available

            returns the new clone name on the form keyXX
            """
            key = _GA(self, "key")
            num = 1
            for obj in (obj for obj in self.location.contents
                        if obj.key.startswith(key) and
                            obj.key.lstrip(key).isdigit()):
                num += 1
            return "%s%03i" % (key, num)
        new_key = new_key or find_clone_key()
        return ObjectDB.objects.copy_object(self, new_key=new_key)

    delete_iter = 0
    def delete(self):
        """
        Deletes this object.
        Before deletion, this method makes sure to move all contained
        objects to their respective home locations, as well as clean
        up all exits to/from the object.
        """
        global _ScriptDB
        if not _ScriptDB:
            from src.scripts.models import ScriptDB as _ScriptDB

        if _GA(self, "delete_iter") > 0:
            # make sure to only call delete once on this object
            # (avoid recursive loops)
            return False

        if not self.at_object_delete():
            # this is an extra pre-check
            # run before deletion mechanism
            # is kicked into gear.
            _SA(self, "delete_iter", 0)
            return False

        self.delete_iter += 1

        # See if we need to kick the player off.

        for session in _GA(self, "sessions"):
            session.msg(_("Your character %s has been destroyed.") % _GA(self, "key"))
            # no need to disconnect, Player just jumps to OOC mode.
        # sever the connection (important!)
        if _GA(self, 'player'):
            _SA(_GA(self, "player"), "character", None)
        _SA(self, "player", None)

        for script in _ScriptDB.objects.get_all_scripts_on_obj(self):
            script.stop()
        #for script in _GA(self, "scripts").all():
        #    script.stop()

        # if self.player:
        #     self.player.user.is_active = False
        #     self.player.user.save(

        # Destroy any exits to and from this room, if any
        _GA(self, "clear_exits")()
        # Clear out any non-exit objects located within the object
        _GA(self, "clear_contents")()
        _GA(self, "attributes").clear()
        _GA(self, "nicks").clear()
        _GA(self, "aliases").clear()

        # Perform the deletion of the object
        super(ObjectDB, self).delete()
        return True

########NEW FILE########
__FILENAME__ = objects
"""
This is the basis of the typeclass system.

The idea is have the object as a normal class with the
database-connection tied to itself through a property.

The instances of all the different object types are all tied to their
own database object stored in the 'dbobj' property.  All attribute
get/set operations are channeled transparently to the database object
as desired. You should normally never have to worry about the database
abstraction, just do everything on the TypeClass object.

That an object is controlled by a player/user is just defined by its
'user' property being set.  This means a user may switch which object
they control by simply linking to a new object's user property.
"""

from django.conf import settings
from src.typeclasses.typeclass import TypeClass
from src.commands import cmdset, command
from src.utils.logger import log_depmsg

__all__ = ("Object", "Character", "Room", "Exit")

_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__


#
# Base class to inherit from.
#

class Object(TypeClass):
    """
    This is the base class for all in-game objects.  Inherit from this
    to create different types of objects in the game.
    """
    # __init__ is only defined here in order to present docstring to API.
    def __init__(self, dbobj):
        """
        This is the root typeclass object, representing all entities
        that have an actual presence in-game. Objects generally have a
        location. They can also be manipulated and looked at. Most
        game entities you define should inherit from Object at some distance.
        Evennia defines some important subclasses of Object by default, namely
        Characters, Exits and Rooms (see the bottom of this module).

        Note that all new Objects and their subclasses *must* always be
        created using the ev.create_object() function. This is so the
        typeclass system can be correctly initiated behind the scenes.


        Object Typeclass API:

        * Available properties (only available on *initiated* typeclass objects)

         key (string) - name of object
         name (string) - same as key
         aliases (list of strings) - aliases to the object. Will be saved to
                     database as AliasDB entries but returned as strings.
         dbref (int, read-only) - unique #id-number. Also "id" can be used.
         dbobj (Object, read-only) - link to database model. dbobj.typeclass
                     points back to this class
         typeclass (Object, read-only) - this links back to this class as an
                     identified only. Use self.swap_typeclass() to switch.
         date_created (string) - time stamp of object creation
         permissions (list of strings) - list of permission strings

         player (Player) - controlling player (if any, only set together with
                          sessid below)
         sessid (int, read-only) - session id (if any, only set together with
                          player above)
         location (Object) - current location. Is None if this is a room
         home (Object) - safety start-location
         sessions (list of Sessions, read-only) - returns all sessions
                     connected to this object
         has_player (bool, read-only)- will only return *connected* players
         contents (list of Objects, read-only) - returns all objects inside
                         this object (including exits)
         exits (list of Objects, read-only) - returns all exits from this
                     object, if any
         destination (Object) - only set if this object is an exit.
         is_superuser (bool, read-only) - True/False if this user is a superuser

        * Handlers available

         locks - lock-handler: use locks.add() to add new lock strings
         db - attribute-handler: store/retrieve database attributes on this
                                 self.db.myattr=val, val=self.db.myattr
         ndb - non-persistent attribute handler: same as db but does not
                                 create a database entry when storing data
         scripts - script-handler. Add new scripts to object with scripts.add()
         cmdset - cmdset-handler. Use cmdset.add() to add new cmdsets to object
         nicks - nick-handler. New nicks with nicks.add().

        * Helper methods (see src.objects.objects.py for full headers)

         search(ostring, global_search=False, use_nicks=True,
                typeclass=None,
                attribute_name=None, use_nicks=True, location=None,
                quiet=False, exact=False)
         execute_cmd(raw_string)
         msg(message, **kwargs)
         msg_contents(message, exclude=None, from_obj=None, **kwargs)
         move_to(destination, quiet=False, emit_to_obj=None,
                 use_destination=True, to_none=False)
         copy(new_key=None)
         delete()
         is_typeclass(typeclass, exact=False)
         swap_typeclass(new_typeclass, clean_attributes=False, no_default=True)
         access(accessing_obj, access_type='read', default=False)
         check_permstring(permstring)

        * Hook methods

         basetype_setup()     - only called once, used for behind-the-scenes
                                setup. Normally not modified.
         basetype_posthook_setup() - customization in basetype, after the
                                 object has been created; Normally not modified.

         at_object_creation() - only called once, when object is first created.
                                Object customizations go here.
         at_object_delete() - called just before deleting an object. If
                              returning False, deletion is aborted. Note that
                              all objects inside a deleted object are
                              automatically moved to their <home>, they don't
                              need to be removed here.

         at_init()            called whenever typeclass is cached from
                              memory, at least once every server restart/reload
         at_cmdset_get()      - this is called just before the command
                                handler requests a cmdset from this objecth
         at_pre_puppet(player)- (player-controlled objects only) called just
                                 before puppeting
         at_post_puppet()     - (player-controlled objects only) called just
                                 after completing connection player<->object
         at_pre_unpuppet()    - (player-controlled objects only) called just
                                 before un-puppeting
         at_post_unpuppet(player) (player-controlled objects only) called
                                  just after disconnecting player<->object link
         at_server_reload()   - called before server is reloaded
         at_server_shutdown() - called just before server is fully shut down

         at_before_move(destination)    called just before moving
                                        object to the destination. If returns
                                        False, move is cancelled.
         announce_move_from(destination)  - called in old location, just before
                                            move, if obj.move_to() has
                                            quiet=False
         announce_move_to(source_location) - called in new location,
                                             just after move, if obj.move_to()
                                             has quiet=False
         at_after_move(source_location)    - always called after a move
                                             has been successfully performed.
         at_object_leave(obj, target_location)   - called when an object leaves
                                                   this object in any fashion
         at_object_receive(obj, source_location) - called when this object
                                                   receives another object
         at_access(result, **kwargs) - this is called with the result of an
                                       access call, along with any kwargs used
                                       for that call. The return of this
                                       method does not affect the result of the
                                       lock check.
         at_before_traverse(traversing_object) - (exit-objects only) called
                                                  just before an object
                                                  traverses this object
         at_after_traverse(traversing_object, source_location) - (exit-objects
                              only) called just after a traversal has happened.
         at_failed_traverse(traversing_object)      - (exit-objects only) called
                    if traversal fails and property err_traverse is not defined.

         at_msg_receive(self, msg, from_obj=None, data=None) - called when a
                                 message (via self.msg()) is sent to this obj.
                                 If returns false, aborts send.
         at_msg_send(self, msg, to_obj=None, data=None) - called when this
                             objects sends a message to someone via self.msg().

         return_appearance(looker) - describes this object. Used by "look"
                                     command by default
         at_desc(looker=None)      - called by 'look' whenever the appearance
                                     is requested.
         at_get(getter)            - called after object has been picked up.
                                     Does not stop pickup.
         at_drop(dropper)          - called when this object has been dropped.
         at_say(speaker, message)  - by default, called if an object inside
                                     this object speaks

         """
        super(Object, self).__init__(dbobj)

    ## methods inherited from the database object (overload them here)

    def search(self, searchdata,
               global_search=False,
               use_nicks=True,
               typeclass=None,
               location=None,
               attribute_name=None,
               quiet=False,
               exact=False):
        """
        Returns the typeclass of an Object matching a search string/condition

        Perform a standard object search in the database, handling
        multiple results and lack thereof gracefully. By default, only
        objects in self's current location or inventory is searched.
        Note: to find Players, use eg. ev.player_search.

        Inputs:

        searchdata (str): Primary search criterion. Will be matched against
                      object.key (with object.aliases second)
                       unless the keyword attribute_name specifies otherwise.
                       Special strings:
                        #<num> - search by unique dbref. This is always a
                                 global search.
                        me,self - self-reference to this object
                        here - current location
                        <num>-<string> - can be used to differentiate between
                                         multiple same-named matches
        global_search (bool): Search all objects globally. This is overruled
                              by "location" keyword.
        use_nicks (bool): Use nickname-replace (nicktype "object") on the
                          search string
        typeclass (str or Typeclass): Limit search only to Objects with this
                          typeclass. May be a list of typeclasses for a
                          broader search.
        location (Object): Specify a location to search, if different from the
                          self's given location
                   plus its contents. This can also be a list of locations.
        attribute_name (str): Use this named Attribute to match ostring against,
                        instead of object.key.
        quiet (bool) - don't display default error messages - return multiple
                        matches as a list and no matches as None. If not
                        set (default), will echo error messages and return None.
        exact (bool) - if unset (default) - prefers to match to beginning of
                       string rather than not matching at all. If set,
                       requires exact mathing of entire string.

        Returns:

            quiet=False (default):
                no match or multimatch:
                    auto-echoes errors to self.msg, then returns None
                    (results are handled by settings.SEARCH_AT_RESULT
                                 and settings.SEARCH_AT_MULTIMATCH_INPUT)
                match:
                    a unique object match
            quiet=True:
                no match or multimatch:
                    returns None or list of multi-matches
                match:
                    a unique object match

        """
        if isinstance(searchdata, basestring):
            # searchdata is a string; wrap some common self-references
            if searchdata.lower() in ("here", ):
                return self.location
            if searchdata.lower() in ("me", "self",):
                return self

        return self.dbobj.search(searchdata,
               global_search=global_search,
               use_nicks=use_nicks,
               typeclass=typeclass,
               location=location,
               attribute_name=attribute_name,
               quiet=quiet,
               exact=exact)

    def search_player(self, searchdata, quiet=False):
        """
        Simple shortcut wrapper to search for players, not characters.

        searchdata - search criterion - the key or dbref of the player
                     to search for. If this is "here" or "me", search
                     for the player connected to this object.
        quiet - return the results as a list rather than echo eventual
                standard error messages.

        Returns:
            quiet=False (default):
                no match or multimatch:
                    auto-echoes errors to self.msg, then returns None
                    (results are handled by settings.SEARCH_AT_RESULT
                                 and settings.SEARCH_AT_MULTIMATCH_INPUT)
                match:
                    a unique player match
            quiet=True:
                no match or multimatch:
                    returns None or list of multi-matches
                match:
                    a unique object match
        """
        if isinstance(searchdata, basestring):
            # searchdata is a string; wrap some common self-references
            if searchdata.lower() in ("me", "self",):
                return self.player
        return self.dbobj.search_player(searchdata, quiet=quiet)

    def execute_cmd(self, raw_string, sessid=None):
        """
        Do something as this object. This command transparently
        lets its typeclass execute the command. This method is
        never called normally, it is only called explicitly in
        code.

        Argument:
        raw_string (string) - raw command input
        sessid (int) - id of session executing the command. This sets the
                     sessid property on the command.

        Returns Deferred - this is an asynchronous Twisted object that will
            not fire until the command has actually finished executing. To
            overload this one needs to attach callback functions to it, with
            addCallback(function). This function will be called with an
            eventual return value from the command execution.

            This return is not used at all by Evennia by default, but might be
            useful for coders intending to implement some sort of nested
            command structure.
        """
        return self.dbobj.execute_cmd(raw_string, sessid=sessid)

    def msg(self, text=None, from_obj=None, sessid=None, **kwargs):
        """
        Emits something to any sessions attached to the object.

        message (str): The message to send
        from_obj (obj): object that is sending.
        data (object): an optional data object that may or may not
                       be used by the protocol.
        sessid: optional session target. If sessid=0, the session will
                default to self.sessid or from_obj.sessid.
        """

        self.dbobj.msg(text=text, **kwargs)

    def msg_contents(self, text=None, exclude=None, from_obj=None, **kwargs):
        """
        Emits something to all objects inside an object.

        exclude is a list of objects not to send to. See self.msg() for
                more info.
        """
        self.dbobj.msg_contents(text, exclude=exclude,
                                from_obj=from_obj, **kwargs)

    def move_to(self, destination, quiet=False,
                emit_to_obj=None, use_destination=True, to_none=False):
        """
        Moves this object to a new location. Note that if <destination> is an
        exit object (i.e. it has "destination"!=None), the move_to will
        happen to this destination and -not- into the exit object itself,
        unless use_destination=False. Note that no lock checks are done by
        this function, such things are assumed to have been handled before
        calling move_to.

        destination: (Object) Reference to the object to move to. This
                     can also be an exit object, in which case the destination
                     property is used as destination.
        quiet:  (bool)    If true, don't emit left/arrived messages.
        emit_to_obj: (Object) object to receive error messages
        use_destination (bool): Default is for objects to use the "destination"
                              property of destinations as the target to move to.
                              Turning off this keyword allows objects to move
                              "inside" exit objects.
        to_none - allow destination to be None. Note that no hooks are run
                  when moving to a None location. If you want to run hooks, run
                  them manually (and make sure the hooks can handle a None
                  location).
        Returns True/False depending on if there were problems with the move.
               This method may also return various error messages to the
               emit_to_obj.

        """
        return self.dbobj.move_to(destination, quiet=quiet,
                                  emit_to_obj=emit_to_obj,
                                  use_destination=use_destination)

    def copy(self, new_key=None):
        """
        Makes an identical copy of this object. If you want to customize the
        copy by changing some settings, use ObjectDB.object.copy_object()
        directly.

        new_key (string) - new key/name of copied object. If new_key is not
                           specified, the copy will be named
                           <old_key>_copy by default.
        Returns: Object (copy of this one)
        """
        return self.dbobj.copy(new_key=new_key)

    def delete(self):
        """
        Deletes this object.
        Before deletion, this method makes sure to move all contained
        objects to their respective home locations, as well as clean
        up all exits to/from the object.

        Returns: boolean True if deletion succeded, False if there
                 were errors during deletion or deletion otherwise
                 failed.
        """
        return self.dbobj.delete()

    # methods inherited from the typeclass system

    def is_typeclass(self, typeclass, exact=False):
        """
        Returns true if this object has this type
          OR has a typeclass which is an subclass of
          the given typeclass.

        typeclass - can be a class object or the
                python path to such an object to match against.

        exact - returns true only if the object's
               type is exactly this typeclass, ignoring
               parents.

        Returns: Boolean
        """
        return self.dbobj.is_typeclass(typeclass, exact=exact)

    def swap_typeclass(self, new_typeclass, clean_attributes=False, no_default=True):
        """
        This performs an in-situ swap of the typeclass. This means
        that in-game, this object will suddenly be something else.
        Player will not be affected. To 'move' a player to a different
        object entirely (while retaining this object's type), use
        self.player.swap_object().

        Note that this might be an error prone operation if the
        old/new typeclass was heavily customized - your code
        might expect one and not the other, so be careful to
        bug test your code if using this feature! Often its easiest
        to create a new object and just swap the player over to
        that one instead.

        Arguments:
        new_typeclass (path/classobj) - type to switch to
        clean_attributes (bool/list) - will delete all attributes
                           stored on this object (but not any
                           of the database fields such as name or
                           location). You can't get attributes back,
                           but this is often the safest bet to make
                           sure nothing in the new typeclass clashes
                           with the old one. If you supply a list,
                           only those named attributes will be cleared.
        no_default - if this is active, the swapper will not allow for
                     swapping to a default typeclass in case the given
                     one fails for some reason. Instead the old one
                     will be preserved.
        Returns:
          boolean True/False depending on if the swap worked or not.


        """
        return self.dbobj.swap_typeclass(new_typeclass,
                       clean_attributes=clean_attributes, no_default=no_default)

    def access(self, accessing_obj, access_type='read', default=False, **kwargs):
        """
        Determines if another object has permission to access this object in
          whatever way.

          accessing_obj (Object)- object trying to access this one
          access_type (string) - type of access sought
          default (bool) - what to return if no lock of access_type was found
          **kwargs - passed to at_access hook along with result,accessing_obj and access_type
        """
        result = self.dbobj.access(accessing_obj, access_type=access_type, default=default)
        self.at_access(result, accessing_obj, access_type, **kwargs)
        return result

        # OBS: DEPRECATED!
        if result:
            self.at_access_success(accessing_obj, access_type)
            return True
        else:
            self.at_access_failure(accessing_obj, access_type)
            return False

    def check_permstring(self, permstring):
        """
        This explicitly checks the given string against this object's
        'permissions' property without involving any locks.

        permstring (string) - permission string that need to match a
                              permission on the object.
                              (example: 'Builders')
        """
        return self.dbobj.check_permstring(permstring)

    def __eq__(self, other):
        """
        Checks for equality against an id string or another object or user.

        This has be located at this level, having it in the
        parent doesn't work.
        """
        try:
                return _GA(_GA(self, "dbobj"), "dbid") == _GA(_GA(other, "dbobj"), "dbid")
        except AttributeError:
           # compare players instead
            try:
                return _GA(_GA(_GA(self, "dbobj"), "player"), "uid") == _GA(_GA(other, "player"), "uid")
            except AttributeError:
                return False

    ## hooks called by the game engine

    def basetype_setup(self):
        """
        This sets up the default properties of an Object,
        just before the more general at_object_creation.

        You normally don't need to change this unless you change some
        fundamental things like names of permission groups.
        """
        # the default security setup fallback for a generic
        # object. Overload in child for a custom setup. Also creation
        # commands may set this (create an item and you should be its
        # controller, for example)

        dbref = self.dbobj.dbref
        self.locks.add(";".join([
            "control:perm(Immortals)",  # edit locks/permissions, delete
            "examine:perm(Builders)",   # examine properties
            "view:all()",               # look at object (visibility)
            "edit:perm(Wizards)",       # edit properties/attributes
            "delete:perm(Wizards)",     # delete object
            "get:all()",                # pick up object
            "call:true()",              # allow to call commands on this object
            "tell:perm(Wizards)",        # allow emits to this object
             # restricts puppeting of this object
            "puppet:pid(%s) or perm(Immortals) or pperm(Immortals)" % dbref]))

    def basetype_posthook_setup(self):
        """
        Called once, after basetype_setup and at_object_creation. This should
        generally not be overloaded unless you are redefining how a
        room/exit/object works. It allows for basetype-like setup after the
        object is created. An example of this is EXITs, who need to know keys,
        aliases, locks etc to set up their exit-cmdsets.
        """
        pass

    def at_object_creation(self):
        """
        Called once, when this object is first created.
        """
        pass

    def at_object_delete(self):
        """
        Called just before the database object is
        permanently delete()d from the database. If
        this method returns False, deletion is aborted.
        """
        return True

    def at_init(self):
        """
        This is always called whenever this object is initiated --
        that is, whenever it its typeclass is cached from memory. This
        happens on-demand first time the object is used or activated
        in some way after being created but also after each server
        restart or reload.
        """
        pass


    def at_cmdset_get(self):
        """
        Called just before cmdsets on this object are requested by the
        command handler. If changes need to be done on the fly to the cmdset
        before passing them on to the cmdhandler, this is the place to do it.
        This is called also if the object currently have no cmdsets.
        """
        pass

    def at_pre_puppet(self, player, sessid=None):
        """
        Called just before a Player connects to this object
        to puppet it.

        player - connecting player object
        sessid - session id controlling the connection
        """
        pass

    def at_post_puppet(self):
        """
        Called just after puppeting has been completed and
        all Player<->Object links have been established.
        """
        pass

    def at_pre_unpuppet(self):
        """
        Called just before beginning to un-connect a puppeting
        from this Player.
        """
        pass

    def at_post_unpuppet(self, player, sessid=None):
        """
        Called just after the Player successfully disconnected
        from this object, severing all connections.

        player - the player object that just disconnected from
                 this object.
        sessid - session id controlling the connection
        """
        pass

    def at_server_reload(self):
        """
        This hook is called whenever the server is shutting down for
        restart/reboot. If you want to, for example, save non-persistent
        properties across a restart, this is the place to do it.
        """
        pass

    def at_server_shutdown(self):
        """
        This hook is called whenever the server is shutting down fully
        (i.e. not for a restart).
        """
        pass

    def at_access(self, result, accessing_obj, access_type, **kwargs):
        """
        This is called with the result of an access call, along with
        any kwargs used for that call. The return of this method does
        not affect the result of the lock check. It can be used e.g. to
        customize error messages in a central location or other effects
        based on the access result.
        """
        pass

    def at_access_success(self, accessing_obj, access_type):
        """
        OBS: DEPRECATED. Use at_access instead

        This hook is called whenever accessing_obj succeed a lock check of
        type access_type on this object, for whatever reason. The return value
        of this hook is not used, the lock will still pass regardless of what
        this hook does (use lockstring/funcs to tweak the lock result).
        """
        log_depmsg("at_access_success is deprecated. Use at_access(result,**kwargs) instead.")
        pass

    def at_access_failure(self, accessing_obj, access_type):
        """
        OBS: DEPRECATED. Use at_access instead

        This hook is called whenever accessing_obj fails a lock check of type
        access_type on this object, for whatever reason. The return value of
        this hook is not used, the lock will still fail regardless of what
        this hook does (use lockstring/funcs to tweak the lock result).
        """
        log_depmsg("at_access_failure is deprecated. Use at_access(result,**kwargs) instead.")
        pass

    # hooks called when moving the object

    def at_before_move(self, destination):
        """
        Called just before starting to move
        this object to destination.

        destination - the object we are moving to

        If this method returns False/None, the move
        is cancelled before it is even started.
        """
        #return has_perm(self, destination, "can_move")
        return True

    def announce_move_from(self, destination):
        """
        Called if the move is to be announced. This is
        called while we are still standing in the old
        location.

        destination - the place we are going to.
        """
        if not self.location:
            return
        name = self.name
        loc_name = ""
        loc_name = self.location.name
        dest_name = destination.name
        string = "%s is leaving %s, heading for %s."
        self.location.msg_contents(string % (name, loc_name, dest_name), exclude=self)

    def announce_move_to(self, source_location):
        """
        Called after the move if the move was not quiet. At this
        point we are standing in the new location.

        source_location - the place we came from
        """

        name = self.name
        if not source_location and self.location.has_player:
            # This was created from nowhere and added to a player's
            # inventory; it's probably the result of a create command.
            string = "You now have %s in your possession." % name
            self.location.msg(string)
            return

        src_name = "nowhere"
        loc_name = self.location.name
        if source_location:
            src_name = source_location.name
        string = "%s arrives to %s from %s."
        self.location.msg_contents(string % (name, loc_name, src_name), exclude=self)

    def at_after_move(self, source_location):
        """
        Called after move has completed, regardless of quiet mode or not.
        Allows changes to the object due to the location it is now in.

        source_location - where we came from
        """
        pass

    def at_object_leave(self, moved_obj, target_location):
        """
        Called just before an object leaves from inside this object

        moved_obj - the object leaving
        target_location - where the object is going.
        """
        pass

    def at_object_receive(self, moved_obj, source_location):
        """
        Called after an object has been moved into this object.

        moved_obj - the object moved into this one
        source_location - where moved_object came from.
        """
        pass

    def at_before_traverse(self, traversing_object):
        """
        Called just before an object uses this object to
        traverse to another object (i.e. this object is a type of Exit)

        The target location should normally be available as self.destination.
        """
        pass

    def at_traverse(self, traversing_object, target_location):
        """
        This hook is responsible for handling the actual traversal, normally
        by calling traversing_object.move_to(target_location). It is normally
        only implemented by Exit objects. If it returns False (usually because
        move_to returned False), at_after_traverse below should not be called
        and instead at_failed_traverse should be called.
        """
        pass

    def at_after_traverse(self, traversing_object, source_location):
        """
        Called just after an object successfully used this object to
        traverse to another object (i.e. this object is a type of Exit)

        The target location should normally be available as self.destination.
        """
        pass

    def at_failed_traverse(self, traversing_object):
        """
        This is called if an object fails to traverse this object for some
        reason. It will not be called if the attribute err_traverse is defined,
        that attribute will then be echoed back instead.
        """
        pass

    def at_msg_receive(self, text=None, **kwargs):
        """
        This hook is called whenever someone
        sends a message to this object.

        Note that from_obj may be None if the sender did
        not include itself as an argument to the obj.msg()
        call - so you have to check for this. .

        Consider this a pre-processing method before
        msg is passed on to the user sesssion. If this
        method returns False, the msg will not be
        passed on.
        Input:
            msg = the message received
            from_obj = the one sending the message
        Output:
            boolean True/False
        """
        return True

    def at_msg_send(self, text=None, to_obj=None, **kwargs):
        """
        This is a hook that is called when /this/ object
        sends a message to another object with obj.msg()
        while also specifying that it is the one sending.

        Note that this method is executed on the object
        passed along with the msg() function (i.e. using
        obj.msg(msg, from_obj=caller) will then launch caller.at_msg())
        and if no object was passed, it will never be called.
        """
        pass

    # hooks called by the default cmdset.

    def return_appearance(self, pobject):
        """
        This is a convenient hook for a 'look'
        command to call.
        """
        if not pobject:
            return
        # get and identify all objects
        visible = (con for con in self.contents if con != pobject and
                                                    con.access(pobject, "view"))
        exits, users, things = [], [], []
        for con in visible:
            key = con.key
            if con.destination:
                exits.append(key)
            elif con.has_player:
                users.append("{c%s{n" % key)
            else:
                things.append(key)
        # get description, build string
        string = "{c%s{n" % self.key
        desc = self.db.desc
        if desc:
            string += "\n %s" % desc
        if exits:
            string += "\n{wExits:{n " + ", ".join(exits)
        if users or things:
            string += "\n{wYou see:{n " + ", ".join(users + things)
        return string

    def at_desc(self, looker=None):
        """
        This is called whenever someone looks
        at this object. Looker is the looking
        object.
        """
        pass

    def at_get(self, getter):
        """
        Called when this object has been picked up. Obs-
        this method cannot stop the pickup - use permissions
        for that!

        getter - the object getting this object.
        """
        pass

    def at_drop(self, dropper):
        """
        Called when this object has been dropped.

        dropper - the object which just dropped this object.
        """
        pass

    def at_say(self, speaker, message):
        """
        Called on this object if an object inside this object speaks.
        The string returned from this method is the final form
        of the speech. Obs - you don't have to add things like
        'you say: ' or similar, that is handled by the say command.

        speaker - the object speaking
        message - the words spoken.
        """
        return message

#
# Base Character object
#

class Character(Object):
    """
    This is just like the Object except it implements its own
    version of the at_object_creation to set up the script
    that adds the default cmdset to the object.
    """

    def basetype_setup(self):
        """
        Setup character-specific security

        You should normally not need to overload this, but if you do, make
        sure to reproduce at least the two last commands in this method (unless
        you want to fundamentally change how a Character object works).

        """
        super(Character, self).basetype_setup()
        self.locks.add(";".join(["get:false()",  # noone can pick up the character
                                 "call:false()"])) # no commands can be called on character from outside
        # add the default cmdset
        self.cmdset.add_default(settings.CMDSET_CHARACTER, permanent=True)

    def at_object_creation(self):
        """
        All this does (for now) is to add the default cmdset. Since
        the script is permanently stored to this object (the permanent
        keyword creates a script to do this), we should never need to
        do this again for as long as this object exists.
        """
        pass

    def at_after_move(self, source_location):
        "Default is to look around after a move."
        self.execute_cmd('look')

    def at_pre_puppet(self, player, sessid=None):
        """
        This recovers the character again after having been "stoved away"
        at the unpuppet
        """
        if self.db.prelogout_location:
            # try to recover
            self.location = self.db.prelogout_location
        if self.location is None:
            # make sure location is never None (home should always exist)
            self.location = self.home
        if self.location:
            # save location again to be sure
            self.db.prelogout_location = self.location
            self.location.at_object_receive(self, self.location)
        else:
            player.msg("{r%s has no location and no home is set.{n" % self, sessid=sessid)

    def at_post_puppet(self):
        """
        Called just after puppeting has completed.
        """
        self.msg("\nYou become {c%s{n.\n" % self.name)
        self.execute_cmd("look")
        if self.location:
            self.location.msg_contents("%s has entered the game." % self.name, exclude=[self])

    def at_post_unpuppet(self, player, sessid=None):
        """
        We stove away the character when the player goes ooc/logs off,
        otherwise the character object will remain in the room also after the
        player logged off ("headless", so to say).
        """
        if self.location: # have to check, in case of multiple connections closing
            self.location.msg_contents("%s has left the game." % self.name, exclude=[self])
            self.db.prelogout_location = self.location
            self.location = None

#
# Base Room object
#

class Room(Object):
    """
    This is the base room object. It's just like any Object except its
    location is None.
    """
    def basetype_setup(self):
        """
        Simple setup, shown as an example
        (since default is None anyway)
        """

        super(Room, self).basetype_setup()
        self.locks.add(";".join(["get:false()",
                                 "puppet:false()"])) # would be weird to puppet a room ...
        self.location = None


#
# Base Exit object
#

class Exit(Object):
    """
    This is the base exit object - it connects a location to another.
    This is done by the exit assigning a "command" on itself with the
    same name as the exit object (to do this we need to remember to
    re-create the command when the object is cached since it must be
    created dynamically depending on what the exit is called). This
    command (which has a high priority) will thus allow us to traverse
    exits simply by giving the exit-object's name on its own.
    """

    # Helper classes and methods to implement the Exit. These need not
    # be overloaded unless one want to change the foundation for how
    # Exits work. See the end of the class for hook methods to overload.

    def create_exit_cmdset(self, exidbobj):
        """
        Helper function for creating an exit command set + command.

        The command of this cmdset has the same name as the Exit object
        and allows the exit to react when the player enter the exit's name,
        triggering the movement between rooms.

        Note that exitdbobj is an ObjectDB instance. This is necessary
        for handling reloads and avoid tracebacks if this is called while
        the typeclass system is rebooting.
        """
        class ExitCommand(command.Command):
            """
            This is a command that simply cause the caller
            to traverse the object it is attached to.
            """
            obj = None

            def func(self):
                "Default exit traverse if no syscommand is defined."

                if self.obj.access(self.caller, 'traverse'):
                    # we may traverse the exit.
                    self.obj.at_traverse(self.caller, self.obj.destination)
                else:
                    # exit is locked
                    if self.obj.db.err_traverse:
                        # if exit has a better error message, let's use it.
                        self.caller.msg(self.obj.db.err_traverse)
                    else:
                        # No shorthand error message. Call hook.
                        self.obj.at_failed_traverse(self.caller)

        # create an exit command. We give the properties here,
        # to always trigger metaclass preparations
        cmd = ExitCommand(key=exidbobj.db_key.strip().lower(),
                          aliases=exidbobj.aliases.all(),
                          locks=str(exidbobj.locks),
                          auto_help=False,
                          destination=exidbobj.db_destination,
                          arg_regex=r"$",
                          is_exit=True,
                          obj=exidbobj)
        # create a cmdset
        exit_cmdset = cmdset.CmdSet(None)
        exit_cmdset.key = '_exitset'
        exit_cmdset.priority = 101
        exit_cmdset.duplicates = True
        # add command to cmdset
        exit_cmdset.add(cmd)
        return exit_cmdset

    # Command hooks
    def basetype_setup(self):
        """
        Setup exit-security

        You should normally not need to overload this - if you do make sure you
        include all the functionality in this method.
        """
        super(Exit, self).basetype_setup()

        # setting default locks (overload these in at_object_creation()
        self.locks.add(";".join(["puppet:false()", # would be weird to puppet an exit ...
                                 "traverse:all()", # who can pass through exit by default
                                 "get:false()"]))   # noone can pick up the exit

        # an exit should have a destination (this is replaced at creation time)
        if self.dbobj.location:
            self.destination = self.dbobj.location

    def at_cmdset_get(self):
        """
        Called when the cmdset is requested from this object, just before the
        cmdset is actually extracted. If no Exit-cmdset is cached, create
        it now.
        """

        if self.ndb.exit_reset or not self.cmdset.has_cmdset("_exitset", must_be_default=True):
            # we are resetting, or no exit-cmdset was set. Create one dynamically.
            self.cmdset.add_default(self.create_exit_cmdset(self.dbobj), permanent=False)
            self.ndb.exit_reset = False

    # this and other hooks are what usually can be modified safely.

    def at_object_creation(self):
        "Called once, when object is first created (after basetype_setup)."
        pass

    def at_traverse(self, traversing_object, target_location):
        """
        This implements the actual traversal. The traverse lock has already been
        checked (in the Exit command) at this point.
        """
        source_location = traversing_object.location
        if traversing_object.move_to(target_location):
            self.at_after_traverse(traversing_object, source_location)
        else:
            if self.db.err_traverse:
                # if exit has a better error message, let's use it.
                self.caller.msg(self.db.err_traverse)
            else:
                # No shorthand error message. Call hook.
                self.at_failed_traverse(traversing_object)

    def at_after_traverse(self, traversing_object, source_location):
        """
        Called after a successful traverse.
        """
        pass

    def at_failed_traverse(self, traversing_object):
        """
        This is called if an object fails to traverse this object for some
        reason. It will not be called if the attribute "err_traverse" is
        defined, that attribute will then be echoed back instead as a
        convenient shortcut.

        (See also hooks at_before_traverse and at_after_traverse).
        """
        traversing_object.msg("You cannot go there.")

########NEW FILE########
__FILENAME__ = admin
#
# This sets up how models are displayed
# in the web admin interface.
#

from django import forms
#from django.db import models
from django.conf import settings
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
#from django.contrib.admin import widgets
from django.contrib.auth.forms import UserChangeForm, UserCreationForm
#from django.contrib.auth.models import User
from src.players.models import PlayerDB
#from src.typeclasses.models import Attribute
from src.utils import create


# handle the custom User editor
class PlayerDBChangeForm(UserChangeForm):

    class Meta:
        model = PlayerDB

    username = forms.RegexField(label="Username",
                                max_length=30,
                                regex=r'^[\w. @+-]+$',
                                widget=forms.TextInput(attrs={'size':'30'}),
                                error_messages = {'invalid': "This value may contain only letters, spaces, numbers and @/./+/-/_ characters."},
                                help_text = "30 characters or fewer. Letters, spaces, digits and @/./+/-/_ only.")

    def clean_username(self):
        username = self.cleaned_data['username']
        if username.upper() == self.instance.username.upper():
            return username
        elif PlayerDB.objects.filter(username__iexact=username):
            raise forms.ValidationError('A player with that name already exists.')
        return self.cleaned_data['username']


class PlayerDBCreationForm(UserCreationForm):

    class Meta:
        model = PlayerDB

    username = forms.RegexField(label="Username",
                                max_length=30,
                                regex=r'^[\w. @+-]+$',
                                widget=forms.TextInput(attrs={'size':'30'}),
                                error_messages = {'invalid': "This value may contain only letters, spaces, numbers and @/./+/-/_ characters."},
                                help_text = "30 characters or fewer. Letters, spaces, digits and @/./+/-/_ only.")

    def clean_username(self):
        username = self.cleaned_data['username']
        if PlayerDB.objects.filter(username__iexact=username):
            raise forms.ValidationError('A player with that name already exists.')
        return username


# # The Player editor
# class AttributeForm(forms.ModelForm):
#     "Defines how to display the atttributes"
#     class Meta:
#         model = Attribute
#     db_key = forms.CharField(label="Key",
#                              widget=forms.TextInput(attrs={'size':'15'}))
#     db_value = forms.CharField(label="Value",
#                                widget=forms.Textarea(attrs={'rows':'2'}))

# class AttributeInline(admin.TabularInline):
#     "Inline creation of player attributes"
#     model = Attribute
#     extra = 0
#     form = AttributeForm
#     fieldsets = (
#         (None, {'fields'  : (('db_key', 'db_value'))}),)

class PlayerForm(forms.ModelForm):
    "Defines how to display Players"

    class Meta:
        model = PlayerDB

    db_key = forms.RegexField(label="Username",
                              initial="PlayerDummy",
                              max_length=30,
                              regex=r'^[\w. @+-]+$',
                              required=False,
                              widget=forms.TextInput(attrs={'size':'30'}),
                              error_messages = {'invalid': "This value may contain only letters, spaces, numbers and @/./+/-/_ characters."},
                              help_text = "This should be the same as the connected Player's key name. 30 characters or fewer. Letters, spaces, digits and @/./+/-/_ only.")

    db_typeclass_path = forms.CharField(label="Typeclass",
                                        initial=settings.BASE_PLAYER_TYPECLASS,
                                        widget=forms.TextInput(attrs={'size':'78'}),
                                        help_text="Required. Defines what 'type' of entity this is. This variable holds a Python path to a module with a valid Evennia Typeclass. Defaults to settings.BASE_PLAYER_TYPECLASS.")
    #db_permissions = forms.CharField(label="Permissions",
    #                                 initial=settings.PERMISSION_PLAYER_DEFAULT,
    #                                 required=False,
    #                                 widget=forms.TextInput(attrs={'size':'78'}),
    #                                 help_text="In-game permissions. A comma-separated list of text strings checked by certain locks. They are often used for hierarchies, such as letting a Player have permission 'Wizards', 'Builders' etc. A Player permission can be overloaded by the permissions of a controlled Character. Normal players use 'Players' by default.")
    db_lock_storage = forms.CharField(label="Locks",
                                      widget=forms.Textarea(attrs={'cols':'100', 'rows':'2'}),
                                      required=False,
                                      help_text="In-game lock definition string. If not given, defaults will be used. This string should be on the form <i>type:lockfunction(args);type2:lockfunction2(args);...")
    db_cmdset_storage = forms.CharField(label="cmdset",
                                        initial=settings.CMDSET_PLAYER,
                                        widget=forms.TextInput(attrs={'size':'78'}),
                                        required=False,
                                        help_text="python path to player cmdset class (set in settings.CMDSET_PLAYER by default)")


class PlayerInline(admin.StackedInline):
    "Inline creation of Player"
    model = PlayerDB
    template = "admin/players/stacked.html"
    form = PlayerForm
    fieldsets = (
        ("In-game Permissions and Locks",
         {'fields': ('db_lock_storage',),
         #{'fields': ('db_permissions', 'db_lock_storage'),
          'description':"<i>These are permissions/locks for in-game use. They are unrelated to website access rights.</i>"}),
        ("In-game Player data",
         {'fields':('db_typeclass_path', 'db_cmdset_storage'),
          'description':"<i>These fields define in-game-specific properties for the Player object in-game.</i>"}),
        )

    extra = 1
    max_num = 1


class PlayerDBAdmin(BaseUserAdmin):
    "This is the main creation screen for Users/players"

    list_display = ('username', 'email', 'is_staff', 'is_superuser')
    form = PlayerDBChangeForm
    add_form = PlayerDBCreationForm
    fieldsets = (
        (None, {'fields': ('username', 'password', 'email')}),
        ('Website profile', {'fields': ('first_name', 'last_name'),
                           'description': "<i>These are not used in the default system.</i>"}),
        ('Website dates', {'fields': ('last_login', 'date_joined'),
                             'description': '<i>Relevant only to the website.</i>'}),
        ('Website Permissions', {'fields': ('is_active', 'is_staff', 'is_superuser',
                                 'user_permissions', 'groups'),
                                 'description': "<i>These are permissions/permission groups for accessing the admin site. They are unrelated to in-game access rights.</i>"}),
        ('Game Options', {'fields': ('db_typeclass_path', 'db_cmdset_storage', 'db_lock_storage'),
                          'description': '<i>These are attributes that are more relevant to gameplay.</i>'}))
        #('Game Options', {'fields': ('db_typeclass_path', 'db_cmdset_storage', 'db_permissions', 'db_lock_storage'),
        #                  'description': '<i>These are attributes that are more relevant to gameplay.</i>'}))

    add_fieldsets = (
        (None,
         {'fields': ('username', 'password1', 'password2', 'email'),
          'description':"<i>These account details are shared by the admin system and the game.</i>"},),)

    # TODO! Remove User reference!
    def save_formset(self, request, form, formset, change):
        "Run all hooks on the player object"
        super(PlayerDBAdmin, self).save_formset(request, form, formset, change)
        userobj = form.instance
        userobj.name = userobj.username
        if not change:
            #uname, passwd, email = str(request.POST.get(u"username")), \
            #        str(request.POST.get(u"password1")), str(request.POST.get(u"email"))
            typeclass = str(request.POST.get(u"playerdb_set-0-db_typeclass_path"))
            create.create_player("", "", "",
                                 user=userobj,
                                 typeclass=typeclass,
                                 player_dbobj=userobj)

admin.site.register(PlayerDB, PlayerDBAdmin)

########NEW FILE########
__FILENAME__ = bots
"""
Bots are a special child typeclasses of
Player that are  controlled by the server.

"""

from django.conf import settings
from src.players.player import Player
from src.scripts.scripts import Script
from src.commands.command import Command
from src.commands.cmdset import CmdSet
from src.utils import search

_IDLE_TIMEOUT = settings.IDLE_TIMEOUT

_SESSIONS = None


# Bot helper utilities

class BotStarter(Script):
    """
    This non-repeating script has the
    sole purpose of kicking its bot
    into gear when it is initialized.
    """
    def at_script_creation(self):
        self.key = "botstarter"
        self.desc = "bot start/keepalive"
        self.persistent = True
        self.db.started = False
        if _IDLE_TIMEOUT > 0:
            # call before idle_timeout triggers
            self.interval = int(max(60, _IDLE_TIMEOUT * 0.90))
            self.start_delay = True

    def at_start(self):
        "Kick bot into gear"
        if not self.db.started:
            self.player.start()
            self.db.started = True

    def at_repeat(self):
        """
        Called self.interval seconds to keep connection. We cannot use
        the IDLE command from inside the game since the system will
        not catch it (commands executed from the server side usually
        has no sessions). So we update the idle counter manually here
        instead. This keeps the bot getting hit by IDLE_TIMEOUT.
        """
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS
        for session in _SESSIONS.sessions_from_player(self.player):
            session.update_session_counters(idle=True)

    def at_server_reload(self):
        """
        If server reloads we don't need to reconnect the protocol
        again, this is handled by the portal reconnect mechanism.
        """
        self.db.started = True

    def at_server_shutdown(self):
        "Make sure we are shutdown"
        self.db.started = False


class CmdBotListen(Command):
    """
    This is a command that absorbs input
    aimed specifically at the bot. The session
    must prepend its data with bot_data_in for
    this to trigger.
    """
    key = "bot_data_in"
    def func(self):
        "Relay to typeclass"
        self.obj.typeclass.execute_cmd(self.args.strip(), sessid=self.sessid)

class BotCmdSet(CmdSet):
    "Holds the BotListen command"
    key = "botcmdset"
    def at_cmdset_creation(self):
        self.add(CmdBotListen())


# Bot base class

class Bot(Player):
    """
    A Bot will start itself when the server
    starts (it will generally not do so
    on a reload - that will be handled by the
    normal Portal session resync)
    """

    def basetype_setup(self):
        """
        This sets up the basic properties for the bot.
        """
        # the text encoding to use.
        self.db.encoding = "utf-8"
        # A basic security setup
        lockstring = "examine:perm(Wizards);edit:perm(Wizards);delete:perm(Wizards);boot:perm(Wizards);msg:false()"
        self.locks.add(lockstring)
        # set the basics of being a bot
        self.cmdset.add_default(BotCmdSet)
        script_key = "%s" % self.key
        self.scripts.add(BotStarter, key=script_key)
        self.is_bot = True

    def start(self, **kwargs):
        """
        This starts the bot, whatever that may mean.
        """
        pass

    def msg(self, text=None, from_obj=None, sessid=None, **kwargs):
        """
        Evennia -> outgoing protocol
        """
        pass

    def execute_cmd(self, raw_string, sessid=None):
        """
        Incoming protocol -> Evennia
        """
        pass

    def at_server_shutdown(self):
        "We need to handle this case manually since the shutdown may be a reset"
        print "bots at_server_shutdown called"
        for session in self.get_all_sessions():
            session.sessionhandler.disconnect(session)


# Bot implementations

# IRC

class IRCBot(Bot):
    """
    Bot for handling IRC connections.
    """
    def start(self, ev_channel=None, irc_botname=None, irc_channel=None, irc_network=None, irc_port=None):
        """
        Start by telling the portal to start a new session.

        ev_channel - key of the Evennia channel to connect to
        irc_botname - name of bot to connect to irc channel. If not set, use self.key
        irc_channel - name of channel on the form #channelname
        irc_network - url of network, like irc.freenode.net
        irc_port - port number of irc network, like 6667
        """
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS

        # if keywords are given, store (the BotStarter script
        # will not give any keywords, so this should normally only
        # happen at initialization)
        if irc_botname:
            self.db.irc_botname = irc_botname
        elif not self.db.irc_botname:
            self.db.irc_botname = self.key
        if ev_channel:
            # connect to Evennia channel
            channel = search.channel_search(ev_channel)
            if not channel:
                raise RuntimeError("Evennia Channel '%s' not found." % ev_channel)
            channel = channel[0]
            channel.connect(self)
            self.db.ev_channel = channel
        if irc_channel:
            self.db.irc_channel = irc_channel
        if irc_network:
            self.db.irc_network = irc_network
        if irc_port:
            self.db.irc_port = irc_port

        # instruct the server and portal to create a new session with
        # the stored configuration
        configdict = {"uid":self.dbid,
                      "botname": self.db.irc_botname,
                      "channel": self.db.irc_channel ,
                      "network": self.db.irc_network,
                      "port": self.db.irc_port}
        _SESSIONS.start_bot_session("src.server.portal.irc.IRCBotFactory", configdict)

    def msg(self, text=None, **kwargs):
        """
        Takes text from connected channel (only)
        """
        if not self.ndb.ev_channel and self.db.ev_channel:
            # cache channel lookup
            self.ndb.ev_channel = self.db.ev_channel
        if "from_channel" in kwargs and text and self.ndb.ev_channel.dbid == kwargs["from_channel"]:
            if "from_obj" not in kwargs or kwargs["from_obj"] != [self.dbobj.id]:
                text = "bot_data_out %s" % text
                self.dbobj.msg(text=text)

    def execute_cmd(self, text=None, sessid=None):
        """
        Take incoming data and send it to connected channel. This is triggered
        by the CmdListen command in the BotCmdSet.
        """
        if not self.ndb.ev_channel and self.db.ev_channel:
            # cache channel lookup
            self.ndb.ev_channel = self.db.ev_channel
        if self.ndb.ev_channel:
            self.ndb.ev_channel.msg(text, senders=self.dbobj.id)


# RSS

class RSSBot(Bot):
    """
    An RSS relayer. The RSS protocol itself runs a ticker to update its feed at regular
    intervals.
    """
    def start(self, ev_channel=None, rss_url=None, rss_rate=None):
        """
        Start by telling the portal to start a new RSS session

        ev_channel - key of the Evennia channel to connect to
        rss_url - full URL to the RSS feed to subscribe to
        rss_update_rate - how often for the feedreader to update
        """
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS

        if ev_channel:
            # connect to Evennia channel
            channel = search.channel_search(ev_channel)
            if not channel:
                raise RuntimeError("Evennia Channel '%s' not found." % ev_channel)
            channel = channel[0]
            self.db.ev_channel = channel
        if rss_url:
            self.db.rss_url = rss_url
        if rss_rate:
            self.db.rss_rate = rss_rate
        # instruct the server and portal to create a new session with
        # the stored configuration
        configdict = {"uid": self.dbid,
                      "url": self.db.rss_url,
                      "rate": self.db.rss_rate}
        _SESSIONS.start_bot_session("src.server.portal.rss.RSSBotFactory", configdict)

    def execute_cmd(self, text=None, sessid=None):
        """
        Echo RSS input to connected channel
        """
        print "execute_cmd rss:", text
        if not self.ndb.ev_channel and self.db.ev_channel:
            # cache channel lookup
            self.ndb.ev_channel = self.db.ev_channel
        if self.ndb.ev_channel:
            self.ndb.ev_channel.msg(text, senders=self.dbobj.id)

class IMC2Bot(Bot):
    """
    IMC2 Bot
    """
    def start(self, ev_channel=None, imc2_network=None, imc2_mudname=None,
              imc2_port=None, imc2_client_pwd=None, imc2_server_pwd=None):
        """
        Start by telling the portal to start a new session
        ev_channel - key of the Evennia channel to connect to
        imc2_network - IMC2 network name
        imc2_mudname - registered mudname (if not given, use settings.SERVERNAME)
        imc2_port - port number of IMC2 network
        imc2_client_pwd - client password registered with IMC2 network
        imc2_server_pwd - server password registered with IMC2 network
        """
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS
        if ev_channel:
            # connect to Evennia channel
            channel = search.channel_search(ev_channel)
            if not channel:
                raise RuntimeError("Evennia Channel '%s' not found." % ev_channel)
            channel = channel[0]
            channel.connect(self)
            self.db.ev_channel = channel
        if imc2_network:
            self.db.imc2_network = imc2_network
        if imc2_port:
            self.db.imc2_port = imc2_port
        if imc2_mudname:
            self.db.imc2_mudname = imc2_mudname
        elif not self.db.imc2_mudname:
            self.db.imc2_mudname = settings.SERVERNAME
        # storing imc2 passwords in attributes - a possible
        # security issue?
        if imc2_server_pwd:
            self.db.imc2_server_pwd = imc2_server_pwd
        if imc2_client_pwd:
            self.db.imc2_client_pwd = imc2_client_pwd

        configdict = {"uid": self.dbid,
                      "mudname": self.db.imc2_mudname,
                      "network": self.db.imc2_network,
                      "port": self.db.imc2_port,
                      "client_pwd": self.db.client_pwd,
                      "server_pwd": self.db.server_pwd}

        _SESSIONS.start_bot_session("src.server.portal.imc2.IMC2BotFactory", configdict)

    def msg(self, text=None, **kwargs):
        """
        Takes text from connected channel (only)
        """
        if not self.ndb.ev_channel and self.db.ev_channel:
            # cache channel lookup
            self.ndb.ev_channel = self.db.ev_channel
        if "from_channel" in kwargs and text and self.ndb.ev_channel.dbid == kwargs["from_channel"]:
            if "from_obj" not in kwargs or kwargs["from_obj"] != [self.dbobj.id]:
                text = "bot_data_out %s" % text
                self.dbobj.msg(text=text)

    def execute_cmd(self, text=None, sessid=None):
        """
        Relay incoming data to connected channel.
        """
        if not self.ndb.ev_channel and self.db.ev_channel:
            # cache channel lookup
            self.ndb.ev_channel = self.db.ev_channel
        if self.ndb.ev_channel:
            self.ndb.ev_channel.msg(text, senders=self.dbobj.id)


########NEW FILE########
__FILENAME__ = manager
"""
The managers for the custom Player object and permissions.
"""

import datetime
from django.contrib.auth.models import UserManager
#from functools import update_wrapper
from src.typeclasses.managers import returns_typeclass_list, returns_typeclass, TypedObjectManager
#from src.utils import logger
__all__ = ("PlayerManager",)


#
# Player Manager
#

class PlayerManager(TypedObjectManager, UserManager):
    """
    This PlayerManager implements methods for searching
    and manipulating Players directly from the database.

    Evennia-specific search methods (will return Characters if
    possible or a Typeclass/list of Typeclassed objects, whereas
    Django-general methods will return Querysets or database objects):

    dbref (converter)
    dbref_search
    get_dbref_range
    object_totals
    typeclass_search
    num_total_players
    get_connected_players
    get_recently_created_players
    get_recently_connected_players
    get_player_from_email
    get_player_from_uid
    get_player_from_name
    player_search (equivalent to ev.search_player)
    swap_character

    """
    def num_total_players(self):
        """
        Returns the total number of registered players.
        """
        return self.count()

    @returns_typeclass_list
    def get_connected_players(self):
        """
        Returns a list of player objects with currently connected users/players.
        """
        return self.filter(db_is_connected=True)

    @returns_typeclass_list
    def get_recently_created_players(self, days=7):
        """
        Returns a QuerySet containing the player User accounts that have been
        connected within the last <days> days.
        """
        end_date = datetime.datetime.now()
        tdelta = datetime.timedelta(days)
        start_date = end_date - tdelta
        return self.filter(date_joined__range=(start_date, end_date))

    @returns_typeclass_list
    def get_recently_connected_players(self, days=7):
        """
        Returns a QuerySet containing the player accounts that have been
        connected within the last <days> days.

        days - number of days backwards to check
        """
        end_date = datetime.datetime.now()
        tdelta = datetime.timedelta(days)
        start_date = end_date - tdelta
        return self.filter(last_login__range=(
                start_date, end_date)).order_by('-last_login')

    @returns_typeclass
    def get_player_from_email(self, uemail):
        """
        Returns a player object when given an email address.
        """
        return self.filter(email__iexact=uemail)

    @returns_typeclass
    def get_player_from_uid(self, uid):
        """
        Returns a player object based on User id.
        """
        try:
            return self.get(id=uid)
        except self.model.DoesNotExist:
            return None

    @returns_typeclass
    def get_player_from_name(self, uname):
        "Get player object based on name"
        try:
            return self.get(username__iexact=uname)
        except self.model.DoesNotExist:
            return None

    @returns_typeclass_list
    def player_search(self, ostring, exact=True):
        """
        Searches for a particular player by name or
        database id.

        ostring - a string or database id.
        exact - allow for a partial match
        """
        dbref = self.dbref(ostring)
        if dbref or dbref == 0:
            # bref search is always exact
            matches = self.filter(id=dbref)
            if matches:
                return matches
        if exact:
            return self.filter(username__iexact=ostring)
        else:
            return self.filter(username__icontains=ostring)

    def swap_character(self, player, new_character, delete_old_character=False):
        """
        This disconnects a player from the current character (if any) and
        connects to a new character object.

        """

        if new_character.player:
            # the new character is already linked to a player!
            return False

        # do the swap
        old_character = player.character
        if old_character:
            old_character.player = None
        try:
            player.character = new_character
            new_character.player = player
        except Exception:
            # recover old setup
            if old_character:
                old_character.player = player
                player.character = old_character
            return False
        if old_character and delete_old_character:
            old_character.delete()
        return True

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    depends_on = (
        ("objects", "0001_initial"),
    )

    def forwards(self, orm):

        # Adding model 'PlayerAttribute'
        db.create_table('players_playerattribute', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_value', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('db_mode', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
        ))
        db.send_create_signal('players', ['PlayerAttribute'])

        # Adding model 'PlayerDB'
        db.create_table('players_playerdb', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_typeclass_path', self.gf('django.db.models.fields.CharField')(max_length=255, null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_permissions', self.gf('django.db.models.fields.CharField')(max_length=512, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm[user_orm_label], unique=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'], null=True)),
        ))
        db.send_create_signal('players', ['PlayerDB'])

        # Hack to get around circular table creation.
        db.add_column('objects_objectdb', 'db_player', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'], null=True, blank=True))


    def backwards(self, orm):

        # Deleting model 'PlayerAttribute'
        db.delete_table('players_playerattribute')

        # Deleting model 'PlayerDB'
        db.delete_table('players_playerdb')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_mode': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_playerattribute_db_mode
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

# overloading pickle to have it find the PackedDBobj in this module
import pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

renametable = {
        'src.typeclasses.models': 'src.players.migrations.0018_convert_attrdata',
        'PackedDBobject': 'PackedDBobject',
}

def mapname(name):
    if name in renametable:
        return renametable[name]
    return name

def mapped_load_global(self):
    module = mapname(self.readline()[:-1])
    name = mapname(self.readline()[:-1])
    klass = self.find_class(module, name)
    self.append(klass)

def loads(str):
    file = StringIO(str)
    unpickler = pickle.Unpickler(file)
    unpickler.dispatch[pickle.GLOBAL] = mapped_load_global
    return unpickler.load()



class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()

def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

# modified for migration - converts to plain python properties
def from_attr(datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.get(id=data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float, long, bool): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject or hasattr(item, '__class__') and item.__class__.__name__ == "PackedDBobject":
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return dict(zip([key for key in item.keys()],
                                             [iter_id2db(val) for val in item.values()]))
        elif hasattr(item, '__iter__'):
            return list(iter_id2db(val) for val in item)
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)
try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Deleting field 'PlayerAttribute.db_mode'

        if not db.dry_run:
            for attr in orm["players.PlayerAttribute"].objects.all():
                # resave attributes
                db_mode = attr.db_mode
                if db_mode and db_mode != 'pickle':
                    # an object. We need to resave this.
                    if db_mode == 'object':
                        val = PackedDBobject(attr.db_value, "objectdb")
                    elif db_mode == 'player':
                        val = PackedDBobject(attr.db_value, "playerdb")
                    elif db_mode == 'script':
                        val = PackedDBobject(attr.db_value, "scriptdb")
                    elif db_mode == 'help':
                        val = PackedDBobject(attr.db_value, "helpentry")
                    else:
                        val = PackedDBobject(attr.db_value, db_mode) # channel, msg
                    val = to_attr(val)
                    attr.db_value = val
                    attr.save()

            db.delete_column('players_playerattribute', 'db_mode')


    def backwards(self, orm):

        # Adding field 'PlayerAttribute.db_mode'
        db.add_column('players_playerattribute', 'db_mode', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True), keep_default=False)


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_playerdb_db_cmdset_storage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'PlayerDB.db_cmdset_storage'
        db.add_column('players_playerdb', 'db_cmdset_storage', self.gf('django.db.models.fields.TextField')(null=True), keep_default=False)


    def backwards(self, orm):

        # Deleting field 'PlayerDB.db_cmdset_storage'
        db.delete_column('players_playerdb', 'db_cmdset_storage')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0004_auto__add_playernick__add_unique_playernick_db_nick_db_type_db_obj
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'PlayerNick'
        db.create_table('players_playernick', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_nick', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_real', self.gf('django.db.models.fields.TextField')()),
            ('db_type', self.gf('django.db.models.fields.CharField')(default='inputline', max_length=16, null=True, blank=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
        ))
        db.send_create_signal('players', ['PlayerNick'])

        # Adding unique constraint on 'PlayerNick', fields ['db_nick', 'db_type', 'db_obj']
        db.create_unique('players_playernick', ['db_nick', 'db_type', 'db_obj_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'PlayerNick', fields ['db_nick', 'db_type', 'db_obj']
        db.delete_unique('players_playernick', ['db_nick', 'db_type', 'db_obj_id'])

        # Deleting model 'PlayerNick'
        db.delete_table('players_playernick')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0005_adding_player_cmdset
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils
from django.conf import settings


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            for player in orm.PlayerDB.objects.all():
                if not player.db_cmdset_storage:
                    player.db_cmdset_storage = settings.CMDSET_PLAYER
                    player.save()
        except utils.DatabaseError:
            # this will happen if we start db from scratch (ignore in that case)
            pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("This migration cannot be reverted.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0006_auto__chg_field_playerdb_db_cmdset_storage__chg_field_playerdb_db_lock
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'PlayerDB.db_cmdset_storage'
        db.alter_column('players_playerdb', 'db_cmdset_storage', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

        # Changing field 'PlayerDB.db_lock_storage'
        db.alter_column('players_playerdb', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'PlayerDB.db_permissions'
        db.alter_column('players_playerdb', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=255))

        # Changing field 'PlayerAttribute.db_lock_storage'
        db.alter_column('players_playerattribute', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))


    def backwards(self, orm):
        
        # Changing field 'PlayerDB.db_cmdset_storage'
        db.alter_column('players_playerdb', 'db_cmdset_storage', self.gf('django.db.models.fields.TextField')(null=True))

        # Changing field 'PlayerDB.db_lock_storage'
        db.alter_column('players_playerdb', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

        # Changing field 'PlayerDB.db_permissions'
        db.alter_column('players_playerdb', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'PlayerAttribute.db_lock_storage'
        db.alter_column('players_playerattribute', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0007_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'PlayerDB', fields ['db_key']
        db.create_index('players_playerdb', ['db_key'])

        # Adding index on 'PlayerAttribute', fields ['db_key']
        db.create_index('players_playerattribute', ['db_key'])


    def backwards(self, orm):
        
        # Removing index on 'PlayerAttribute', fields ['db_key']
        db.delete_index('players_playerattribute', ['db_key'])

        # Removing index on 'PlayerDB', fields ['db_key']
        db.delete_index('players_playerdb', ['db_key'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0008_converting_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    import cPickle as pickle
except ImportError:
    import pickle
from src.utils.utils import to_str, to_unicode
#from src.typeclasses.models import PackedDBobject,PackedDict,PackedList

from django.contrib.contenttypes.models import ContentType
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()

def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

def from_attr(attr, datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.dbref_search(data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject:
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return PackedDict(attr, dict(zip([key for key in item.keys()],
                                             [iter_id2db(val) for val in item.values()])))
        elif hasattr(item, '__iter__'):
            return PackedList(attr, list(iter_id2db(val) for val in item))
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for attr in orm['players.PlayerAttribute'].objects.all():
            try:
                # repack attr into new format, and reimport
                val = pickle.loads(to_str(attr.db_value))
                if hasattr(val, '__iter__'):
                    val = ("iter", val)
                elif type(val) == PackedDBobject:
                    val = ("dbobj", val)
                else:
                    val = ("simple", val)
                attr.db_value = to_unicode(pickle.dumps(to_str(to_attr(from_attr(attr, val)))))
                attr.save()
            except TypeError, RuntimeError:
                pass


    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0009_converting_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    import cPickle as pickle
except ImportError:
    import pickle
from src.utils.utils import to_str, to_unicode
#from src.typeclasses.models import PackedDBobject

from django.contrib.contenttypes.models import ContentType
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

        """
        self.db_obj = db_obj
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.db_obj.value = self
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.db_obj.value = self
    def pop(self, *args, **kwargs):
        "Custom pop"
        super(PackedDict, self).pop(*args, **kwargs)
        self.db_obj.value = self
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        super(PackedDict, self).popitem(*args, **kwargs)
        self.db_obj.value = self
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.db_obj.value = self

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing list.
         db_obj - the Attribute object storing this dict.
        """
        self.db_obj = db_obj
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.db_obj.value = self
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.db_obj.value = self
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.db_obj.value = self
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.db_obj.value = self
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.db_obj.value = self
    def pop(self, *args, **kwargs):
        "Custom pop"
        super(PackedList, self).pop(*args, **kwargs)
        self.db_obj.value = self
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.db_obj.value = self
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.db_obj.value = self


def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

def from_attr(attr, datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.dbref_search(data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject:
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return dict(zip([key for key in item.keys()],
                                             [iter_id2db(val) for val in item.values()]))
        elif hasattr(item, '__iter__'):
            return list(iter_id2db(val) for val in item)
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for attr in orm['players.PlayerAttribute'].objects.all():
            try:
                # repack attr into new format, and reimport
                val = pickle.loads(to_str(attr.db_value))
                attr.db_value = to_unicode(pickle.dumps(to_str(to_attr(from_attr(attr, val)))))
                attr.save()
            except TypeError, RuntimeError:
                pass


    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0010_typeclass_and_cmdset_to_new_api_default
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            for obj in orm.PlayerDB.objects.all():
                if obj.db_cmdset_storage == "game.gamesrc.commands.basecmdset.OOCCmdSet":
                    obj.db_cmdset_storage = "src.commands.default.cmdset_ooc.OOCCmdSet"
                    obj.save() 
                if obj.db_typeclass_path == "game.gamesrc.objects.baseobjects.Player":
                    obj.db_typeclass_path = "src.players.player.Player"
                    obj.save()
        except utils.DatabaseError:
            "We are starting from scratch. Ignore."
            pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0011_addin_is_connected_field
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'PlayerDB.db_is_connected'
        db.add_column('players_playerdb', 'db_is_connected',
                      self.gf('django.db.models.fields.BooleanField')(default=False),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'PlayerDB.db_is_connected'
        db.delete_column('players_playerdb', 'db_is_connected')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
########NEW FILE########
__FILENAME__ = 0012_auto__chg_field_playerdb_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'PlayerDB.db_lock_storage'
        db.alter_column('players_playerdb', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'PlayerDB.db_lock_storage'
        db.alter_column('players_playerdb', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
########NEW FILE########
__FILENAME__ = 0013_auto__chg_field_playerattribute_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'PlayerAttribute.db_lock_storage'
        db.alter_column('players_playerattribute', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'PlayerAttribute.db_lock_storage'
        db.alter_column('players_playerattribute', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
########NEW FILE########
__FILENAME__ = 0014_add_attr__playable_characters
# -*- coding: utf-8 -*-
import datetime, pickle
from south.db import db
from south.v2 import DataMigration
from django.db import models
#from src.typeclasses.models import PackedDBobject

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        lockstring = "attrread:perm(Admins);attredit:perm(Admins);attrcreate:perm(Admins)"
        #lockstring2 = "attrread:false();attredit:false();attrcreate:false()"
        if not db.dry_run:
            for player in orm['players.PlayerDB'].objects.all():
                char = player.db_obj
                if char:
                    val = pickle.dumps(("iter", [PackedDBobject(char.id, "objectdb", char.db_key)]))
                else:
                    val = pickle.dumps(("iter", []))
                orm['players.PlayerAttribute'].objects.create(db_key="_playable_characters",
                                                              db_obj=player,
                                                              db_lock_storage=lockstring,
                                                              db_value=val)
                if char:
                    val = pickle.dumps(("dbobj", PackedDBobject(char.id, "objectdb", char.db_key)))
                    orm['players.PlayerAttribute'].objects.create(db_key="_last_puppet",
                                                                  db_obj=player,
                                                                  db_value=val)

                suser = char and char.id == 1
                #if suser:
                #    # REMOVED - this is not needed - Griatch
                #    # the superuser unmask attribute for the superuser (note that this
                #    # is not a security risk, it only works if player's superuser bit is set too)
                #    val = pickle.dumps(("simple", suser))
                #    orm['objects.ObjAttribute'].objects.create(db_key="_superuser_character",
                #                                                  db_obj=char,
                #                                                  db_lock_storage=lockstring2,
                #                                                  db_value=val)


    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("This migration cannot be reverted.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0015_removing_obj
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'PlayerDB.db_obj'
        if not db.dry_run:
            db.delete_column('players_playerdb', 'db_obj_id')


    def backwards(self, orm):
        # Adding field 'PlayerDB.db_obj'
        db.add_column('players_playerdb', 'db_obj',
                      self.gf('django.db.models.fields.related.ForeignKey')(related_name='obj_set', null=True, to=orm['objects.ObjectDB'], blank=True),
                      keep_default=False)


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_objs': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'objs_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0016_rename_default_cmdsets
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        if not db.dry_run:
            for obj in orm['players.PlayerDB'].objects.filter(db_cmdset_storage=u'src.commands.default.cmdset_ooc.OOCCmdSet'):
                obj.db_cmdset_storage=u'src.commands.default.cmdset_player.PlayerCmdSet'
                obj.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration")
    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0017_add_picklefield
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'PlayerAttribute.db_value2'
        db.add_column('players_playerattribute', 'db_value2',
                      self.gf('src.utils.picklefield.PickledObjectField')(null=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'PlayerAttribute.db_value2'
        db.delete_column('players_playerattribute', 'db_value2')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
########NEW FILE########
__FILENAME__ = 0018_convert_attrdata
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

from django.contrib.contenttypes.models import ContentType

from src.utils.utils import to_str
from src.utils.dbserialize import to_pickle
try:
    import cPickle as pickle
except ImportError:
    import pickle
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__


# overloading pickle to have it find the PackedDBobj in this module
import pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

renametable = {
        'src.typeclasses.models': 'src.players.migrations.0018_convert_attrdata',
        'PackedDBobject': 'PackedDBobject',
}

def mapname(name):
    if name in renametable:
        return renametable[name]
    return name

def mapped_load_global(self):
    module = mapname(self.readline()[:-1])
    name = mapname(self.readline()[:-1])
    klass = self.find_class(module, name)
    self.append(klass)

def loads(str):
    file = StringIO(str)
    unpickler = pickle.Unpickler(file)
    unpickler.dispatch[pickle.GLOBAL] = mapped_load_global
    return unpickler.load()



class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()



try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):
    depends_on = (
                 ("objects", "0018_add_picklefield"),
                    )
    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        # modified for migration - converts to plain python properties
        def from_attr(datatuple):
            """
            Retrieve data from a previously stored attribute. This
            is always a dict with keys type and data.

            datatuple comes from the database storage and has
            the following format:
               (simple|dbobj|iter, <data>)
            where
                simple - a single non-db object, like a string. is returned as-is.
                dbobj - a single dbobj-id. This id is retrieved back from the database.
                iter - an iterable. This is traversed iteratively, converting all found
                       dbobj-ids back to objects. Also, all lists and dictionaries are
                       returned as their PackedList/PackedDict counterparts in order to
                       allow in-place assignment such as obj.db.mylist[3] = val. Mylist
                       is then a PackedList that saves the data on the fly.
            """
            # nested functions
            def id2db(data):
                """
                Convert db-stored dbref back to object
                """
                mclass = CTYPEGET(model=data.db_model).model_class()
                try:
                    return mclass.objects.get(id=data.id)

                except AttributeError:
                    try:
                        return mclass.objects.get(id=data.id)
                    except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                        return None

            def iter_id2db(item):
                """
                Recursively looping through stored iterables, replacing ids with actual objects.
                We return PackedDict and PackedLists instead of normal lists; this is needed in order for
                the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
                stored in the database are however always normal python primitives.
                """
                dtype = type(item)
                if dtype in (basestring, int, float, long, bool): # check the most common types first, for speed
                    return item
                elif dtype == PackedDBobject or hasattr(item, '__class__') and item.__class__.__name__ == "PackedDBobject":
                    return id2db(item)
                elif dtype == tuple:
                    return tuple([iter_id2db(val) for val in item])
                elif dtype in (dict, PackedDict):
                    return dict(zip([key for key in item.keys()],
                                                     [iter_id2db(val) for val in item.values()]))
                elif hasattr(item, '__iter__'):
                    return list(iter_id2db(val) for val in item)
                else:
                    return item

            typ, data = datatuple

            if typ == 'simple':
                # single non-db objects
                return data
            elif typ == 'dbobj':
                # a single stored dbobj
                return id2db(data)
            elif typ == 'iter':
                # all types of iterables
                return iter_id2db(data)

        if not db.dry_run:
            for attr in orm['players.PlayerAttribute'].objects.all():
                # repack attr into new format and reimport
                datatuple = loads(to_str(attr.db_value))
                python_data = from_attr(datatuple)
                new_data = to_pickle(python_data)
                attr.db_value2 = new_data # new pickleObjectField
                attr.save()

        def backwards(self, orm):
            "Write your backwards methods here."
            raise RuntimeError("This migration cannot be reversed.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0019_remove_old_attr_value_field
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'PlayerAttribute.db_value'
        db.delete_column('players_playerattribute', 'db_value')
        db.rename_column('players_playerattribute', 'db_value2', 'db_value')

    def backwards(self, orm):
        # Adding field 'PlayerAttribute.db_value'
        db.add_column('players_playerattribute', 'db_value',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)
        db.rename_column('players_playerattribute', 'db_value', 'db_value2')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0020_auto__del_playerattribute
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'PlayerAttribute'
        db.delete_table(u'players_playerattribute')

        # Adding M2M table for field db_attributes on 'PlayerDB'
        db.create_table(u'players_playerdb_db_attributes', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('playerdb', models.ForeignKey(orm[u'players.playerdb'], null=False)),
            ('attribute', models.ForeignKey(orm[u'typeclasses.attribute'], null=False))
        ))
        db.create_unique(u'players_playerdb_db_attributes', ['playerdb_id', 'attribute_id'])


    def backwards(self, orm):
        # Adding model 'PlayerAttribute'
        db.create_table(u'players_playerattribute', (
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_value2', self.gf('src.utils.picklefield.PickledObjectField')(null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('players', ['PlayerAttribute'])

        # Removing M2M table for field db_attributes on 'PlayerDB'
        db.delete_table('players_playerdb_db_attributes')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0021_add_playerdbtmp
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models, connection


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'PlayerDBtmp'
        if "auth_user" in connection.introspection.table_names():
            # auth_user exists ffrom before. Use that as a base.
            db.rename_table('auth_user', 'players_playerdbtmp')
            db.rename_table('auth_user_groups', 'players_playerdbtmp_groups')
            db.rename_table('auth_user_user_permissions', 'players_playerdbtmp_user_permissions')
            db.rename_column('players_playerdbtmp_groups', 'user_id', 'playerdbtmp_id')
            db.rename_column('players_playerdbtmp_user_permissions', 'user_id', 'playerdbtmp_id')

        else:
            # from-scratch creation; no auth_user table available. Create vanilla User table
            db.create_table(u'players_playerdbtmp', (
                (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                ('password', self.gf('django.db.models.fields.CharField')(max_length=128)),
                ('last_login', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
                ('is_superuser', self.gf('django.db.models.fields.BooleanField')(default=False)),
                ('username', self.gf('django.db.models.fields.CharField')(unique=True, max_length=30)),
                ('first_name', self.gf('django.db.models.fields.CharField')(max_length=30, blank=True)),
                ('last_name', self.gf('django.db.models.fields.CharField')(max_length=30, blank=True)),
                ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, blank=True)),
                ('is_staff', self.gf('django.db.models.fields.BooleanField')(default=False)),
                ('is_active', self.gf('django.db.models.fields.BooleanField')(default=True)),
                ('date_joined', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ))
            db.send_create_signal(u'players', ['PlayerDBtmp'])

            # Adding M2M table for field groups on 'PlayerDBtmp'
            db.create_table(u'players_playerdbtmp_groups', (
                ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
                ('playerdbtmp', models.ForeignKey(orm[u'players.playerdbtmp'], null=False)),
                ('group', models.ForeignKey(orm[u'auth.group'], null=False))
            ))
            db.create_unique(u'players_playerdbtmp_groups', ['playerdbtmp_id', 'group_id'])

            # Adding M2M table for field user_permissions on 'PlayerDBtmp'
            db.create_table(u'players_playerdbtmp_user_permissions', (
                ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
                ('playerdbtmp', models.ForeignKey(orm[u'players.playerdbtmp'], null=False)),
                ('permission', models.ForeignKey(orm[u'auth.permission'], null=False))
            ))
            db.create_unique(u'players_playerdbtmp_user_permissions', ['playerdbtmp_id', 'permission_id'])

        # add Evennia-specific columns
        db.add_column('players_playerdbtmp', 'db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True, null=True))
        db.add_column('players_playerdbtmp', 'db_typeclass_path', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))
        db.add_column('players_playerdbtmp', 'db_date_created', self.gf('django.db.models.fields.DateTimeField')(null=True, auto_now_add=True, blank=True))
        db.add_column('players_playerdbtmp', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True, null=True))
        db.add_column('players_playerdbtmp', 'db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True, null=True))
        db.add_column('players_playerdbtmp', 'db_is_connected', self.gf('django.db.models.fields.BooleanField')(default=False))
        db.add_column('players_playerdbtmp', 'db_cmdset_storage', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

    def backwards(self, orm):
        raise RuntimeError("Cannot revert migration")


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'players.playerdbtmp': {
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0022_copy_user_profile_to_tmp
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."
        if not db.dry_run:
            for profile in orm['players.PlayerDB'].objects.all():
                print "player orig:", profile.db_key, profile.db_cmdset_storage
                plyr = orm['players.PlayerDBtmp'].objects.get(id=profile.user_id)
                plyr.db_cmdset_storage = profile.db_cmdset_storage
                plyr.db_date_created = profile.db_date_created
                plyr.db_is_connected = profile.db_is_connected
                plyr.db_key = profile.db_key
                plyr.db_lock_storage = profile.db_lock_storage
                plyr.db_typeclass_path = profile.db_typeclass_path
                plyr.db_permissions = profile.db_permissions
                plyr.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration.")

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'players.playerdbtmp': {
            'Meta': {'ordering': "['-db_date_created', 'id', 'db_typeclass_path', 'db_key']", 'object_name': 'PlayerDBtmp'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0023_delete_old_profile
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        db.delete_table('players_playerdb')

    def backwards(self, orm):
        raise RuntimeError("Cannot revert this migration")

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'players.playerdbtmp': {
            'Meta': {'ordering': "['-db_date_created', 'id', 'db_typeclass_path', 'db_key']", 'object_name': 'PlayerDBtmp'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0024_rename_tmp_to_player
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        db.rename_table('players_playerdbtmp', 'players_playerdb')
        db.rename_table('players_playerdbtmp_groups', 'players_playerdb_groups')
        db.rename_column('players_playerdb_groups', 'playerdbtmp_id', 'playerdb_id')
        db.rename_table('players_playerdbtmp_user_permissions', 'players_playerdb_user_permissions')
        db.rename_column('players_playerdb_user_permissions', 'playerdbtmp_id', 'playerdb_id')

    def backwards(self, orm):
        db.rename_table('players_playerdb_groups', 'players_playerdbtmp_groups')
        db.rename_column('players_playerdbtmp_groups', 'playerdb_id', 'playerdbtmp_id')
        db.rename_table('players_playerdb_user_permissions', 'players_playerdbtmp_user_permissions')
        db.rename_column('players_playerdbtmp_user_permissions', 'playerdb_id', 'playerdbtmp_id') 

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'players.playerdbtmp': {
            'Meta': {'object_name': 'PlayerDBtmp'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0025_auto__add_db_liteattributes_db_tags
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding M2M table for field db_liteattributes on 'PlayerDB'
        m2m_table_name = db.shorten_name(u'players_playerdb_db_liteattributes')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('playerdb', models.ForeignKey(orm[u'players.playerdb'], null=False)),
            ('liteattribute', models.ForeignKey(orm[u'typeclasses.liteattribute'], null=False))
        ))
        db.create_unique(m2m_table_name, ['playerdb_id', 'liteattribute_id'])

        # Adding M2M table for field db_tags on 'PlayerDB'
        m2m_table_name = db.shorten_name(u'players_playerdb_db_tags')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('playerdb', models.ForeignKey(orm[u'players.playerdb'], null=False)),
            ('tag', models.ForeignKey(orm[u'typeclasses.tag'], null=False))
        ))
        db.create_unique(m2m_table_name, ['playerdb_id', 'tag_id'])


    def backwards(self, orm):
        # Removing M2M table for field db_liteattributes on 'PlayerDB'
        db.delete_table(db.shorten_name(u'players_playerdb_db_liteattributes'))

        # Removing M2M table for field db_tags on 'PlayerDB'
        db.delete_table(db.shorten_name(u'players_playerdb_db_tags'))


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0026_auto__del_playernick__del_unique_playernick_db_nick_db_type_db_obj
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    depends_on = (('typeclasses', '0004_copy_nicks_to_liteattrs_aliases_to_tags'),)

    def forwards(self, orm):
        # Removing unique constraint on 'PlayerNick', fields ['db_nick', 'db_type', 'db_obj']
        db.delete_unique(u'players_playernick', ['db_nick', 'db_type', 'db_obj_id'])

        # Deleting model 'PlayerNick'
        db.delete_table(u'players_playernick')


    def backwards(self, orm):
        # Adding model 'PlayerNick'
        db.create_table(u'players_playernick', (
            ('db_type', self.gf('django.db.models.fields.CharField')(default='inputline', max_length=16, null=True, blank=True)),
            ('db_nick', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'])),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_real', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'players', ['PlayerNick'])

        # Adding unique constraint on 'PlayerNick', fields ['db_nick', 'db_type', 'db_obj']
        db.create_unique(u'players_playernick', ['db_nick', 'db_type', 'db_obj_id'])


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']

########NEW FILE########
__FILENAME__ = 0027_move_permissions_to_handler
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        Tag = orm['typeclasses.Tag']
        for obj in orm.PlayerDB.objects.all():
            if obj.db_permissions:
                for perm in [perm.strip() for perm in obj.db_permissions.split(",")]:
                    tag = Tag.objects.filter(db_key=perm.lower().strip(), db_category="permissions")
                    if tag:
                        tag = tag[0]
                    else:
                        tag = Tag(db_key=perm.lower().strip(), db_category="permissions")
                        tag.save()
                    obj.db_tags.add(tag)

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0028_auto__del_field_playerdb_db_permissions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'PlayerDB.db_permissions'
        db.delete_column(u'players_playerdb', 'db_permissions')


    def backwards(self, orm):
        # Adding field 'PlayerDB.db_permissions'
        db.add_column(u'players_playerdb', 'db_permissions',
                      self.gf('django.db.models.fields.CharField')(default='', max_length=255, blank=True),
                      keep_default=False)


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
########NEW FILE########
__FILENAME__ = 0029_auto__add_field_playerdb_db_is_bot
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'PlayerDB.db_is_bot'
        db.add_column(u'players_playerdb', 'db_is_bot',
                      self.gf('django.db.models.fields.BooleanField')(default=False),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'PlayerDB.db_is_bot'
        db.delete_column(u'players_playerdb', 'db_is_bot')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_bot': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['players']
########NEW FILE########
__FILENAME__ = models
"""
Player

The player class is an extension of the default Django user class,
and is customized for the needs of Evennia.

We use the Player to store a more mud-friendly style of permission
system as well as to allow the admin more flexibility by storing
attributes on the Player.  Within the game we should normally use the
Player manager's methods to create users so that permissions are set
correctly.

To make the Player model more flexible for your own game, it can also
persistently store attributes of its own. This is ideal for extra
account info and OOC account configuration variables etc.

"""

from django.conf import settings
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.utils.encoding import smart_str

from src.players import manager
from src.scripts.models import ScriptDB
from src.typeclasses.models import (TypedObject, TagHandler, NickHandler,
                                    AliasHandler, AttributeHandler)
from src.scripts.scripthandler import ScriptHandler
from src.commands.cmdsethandler import CmdSetHandler
from src.commands import cmdhandler
from src.utils import utils, logger
from src.utils.utils import to_str, make_iter

from django.utils.translation import ugettext as _

__all__ = ("PlayerDB",)

#_ME = _("me")
#_SELF = _("self")

_SESSIONS = None
_AT_SEARCH_RESULT = utils.variable_from_module(*settings.SEARCH_AT_RESULT.rsplit('.', 1))
_MULTISESSION_MODE = settings.MULTISESSION_MODE

_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__

_TYPECLASS = None


#------------------------------------------------------------
#
# PlayerDB
#
#------------------------------------------------------------

class PlayerDB(TypedObject, AbstractUser):
    """
    This is a special model using Django's 'profile' functionality
    and extends the default Django User model. It is defined as such
    by use of the variable AUTH_PROFILE_MODULE in the settings.
    One accesses the fields/methods. We try use this model as much
    as possible rather than User, since we can customize this to
    our liking.

    The TypedObject supplies the following (inherited) properties:
      key - main name
      typeclass_path - the path to the decorating typeclass
      typeclass - auto-linked typeclass
      date_created - time stamp of object creation
      permissions - perm strings
      dbref - #id of object
      db - persistent attribute storage
      ndb - non-persistent attribute storage

    The PlayerDB adds the following properties:
      user - Connected User object. django field, needs to be save():d.
      name - alias for user.username
      sessions - sessions connected to this player
      is_superuser - bool if this player is a superuser
      is_bot - bool if this player is a bot and not a real player

    """

    #
    # PlayerDB Database model setup
    #
    # inherited fields (from TypedObject):
    # db_key, db_typeclass_path, db_date_created, db_permissions

    # store a connected flag here too, not just in sessionhandler.
    # This makes it easier to track from various out-of-process locations
    db_is_connected = models.BooleanField(default=False,
                                          verbose_name="is_connected",
                                          help_text="If player is connected to game or not")
    # database storage of persistant cmdsets.
    db_cmdset_storage = models.CharField('cmdset', max_length=255, null=True,
        help_text="optional python path to a cmdset class. If creating a Character, this will default to settings.CMDSET_CHARACTER.")
    # marks if this is a "virtual" bot player object
    db_is_bot = models.BooleanField(default=False, verbose_name="is_bot", help_text="Used to identify irc/imc2/rss bots")

    # Database manager
    objects = manager.PlayerManager()

    # caches for quick lookups
    _typeclass_paths = settings.PLAYER_TYPECLASS_PATHS
    _default_typeclass_path = settings.BASE_PLAYER_TYPECLASS or "src.players.player.Player"

    class Meta:
        app_label = 'players'
        verbose_name = 'Player'

    def __init__(self, *args, **kwargs):
        "Parent must be initiated first"
        TypedObject.__init__(self, *args, **kwargs)
        # handlers
        _SA(self, "cmdset", CmdSetHandler(self))
        _GA(self, "cmdset").update(init_mode=True)
        _SA(self, "scripts", ScriptHandler(self))
        _SA(self, "attributes", AttributeHandler(self))
        _SA(self, "nicks", NickHandler(self))
        _SA(self, "tags", TagHandler(self))
        _SA(self, "aliases", AliasHandler(self))

    # alias to the objs property
    def __characters_get(self):
        return self.objs

    def __characters_set(self, value):
        self.objs = value

    def __characters_del(self):
        raise Exception("Cannot delete name")
    characters = property(__characters_get, __characters_set, __characters_del)

    # cmdset_storage property
    # This seems very sensitive to caching, so leaving it be for now /Griatch
    #@property
    def cmdset_storage_get(self):
        """
        Getter. Allows for value = self.name. Returns a list of cmdset_storage.
        """
        storage = _GA(self, "db_cmdset_storage")
        # we need to check so storage is not None
        return [path.strip() for path in storage.split(',')] if storage else []

    #@cmdset_storage.setter
    def cmdset_storage_set(self, value):
        """
        Setter. Allows for self.name = value. Stores as a comma-separated
        string.
        """
        _SA(self, "db_cmdset_storage", ",".join(str(val).strip() for val in make_iter(value)))
        _GA(self, "save")()

    #@cmdset_storage.deleter
    def cmdset_storage_del(self):
        "Deleter. Allows for del self.name"
        _SA(self, "db_cmdset_storage", None)
        _GA(self, "save")()
    cmdset_storage = property(cmdset_storage_get, cmdset_storage_set, cmdset_storage_del)

    class Meta:
        "Define Django meta options"
        verbose_name = "Player"
        verbose_name_plural = "Players"

    #
    # PlayerDB main class properties and methods
    #

    def __str__(self):
        return smart_str("%s(player %s)" % (_GA(self, "name"), _GA(self, "dbid")))

    def __unicode__(self):
        return u"%s(player#%s)" % (_GA(self, "name"), _GA(self, "dbid"))

    #@property
    def __username_get(self):
        return _GA(self, "username")

    def __username_set(self, value):
        _SA(self, "username", value)

    def __username_del(self):
        _DA(self, "username")
    # aliases
    name = property(__username_get, __username_set, __username_del)
    key = property(__username_get, __username_set, __username_del)

    #@property
    def __uid_get(self):
        "Getter. Retrieves the user id"
        return self.id

    def __uid_set(self, value):
        raise Exception("User id cannot be set!")

    def __uid_del(self):
        raise Exception("User id cannot be deleted!")
    uid = property(__uid_get, __uid_set, __uid_del)

    #@property
    #def __is_superuser_get(self):
    #    "Superusers have all permissions."
    #    return self.db_is_superuser
    #    #is_suser = get_prop_cache(self, "_is_superuser")
    #    #if is_suser == None:
    #    #    is_suser = _GA(self, "user").is_superuser
    #    #    set_prop_cache(self, "_is_superuser", is_suser)
    #    #return is_suser
    #is_superuser = property(__is_superuser_get)

    #
    # PlayerDB class access methods
    #

    def msg(self, text=None, from_obj=None, sessid=None, **kwargs):
        """
        Evennia -> User
        This is the main route for sending data back to the user from the
        server.

        outgoing_string (string) - text data to send
        from_obj (Object/Player) - source object of message to send. Its
                 at_msg_send() hook will be called.
        sessid - the session id of the session to send to. If not given, return
                 to all sessions connected to this player. This is usually only
                 relevant when using msg() directly from a player-command (from
                 a command on a Character, the character automatically stores
                 and handles the sessid).
        kwargs (dict) - All other keywords are parsed as extra data.
        """
        if "data" in kwargs:
            # deprecation warning
            logger.log_depmsg("PlayerDB:msg() 'data'-dict keyword is deprecated. Use **kwargs instead.")
            data = kwargs.pop("data")
            if isinstance(data, dict):
                kwargs.update(data)

        text = to_str(text, force_string=True) if text else ""
        if from_obj:
            # call hook
            try:
                _GA(from_obj, "at_msg_send")(text=text, to_obj=_GA(self, "typeclass"), **kwargs)
            except Exception:
                pass
        session = _MULTISESSION_MODE == 2 and sessid and _GA(self, "get_session")(sessid) or None
        if session:
            obj = session.puppet
            if obj and not obj.at_msg_receive(text=text, **kwargs):
                # if hook returns false, cancel send
                return
            session.msg(text=text, **kwargs)
        else:
            # if no session was specified, send to them all
            for sess in _GA(self, 'get_all_sessions')():
                sess.msg(text=text, **kwargs)

    # session-related methods

    def get_session(self, sessid):
        """
        Return session with given sessid connected to this player.
        """
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS
        return _SESSIONS.session_from_player(self, sessid)

    def get_all_sessions(self):
        "Return all sessions connected to this player"
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS
        return _SESSIONS.sessions_from_player(self)
    sessions = property(get_all_sessions)  # alias shortcut

    def disconnect_session_from_player(self, sessid):
        """
        Access method for disconnecting a given session from the player
        (connection happens automatically in the sessionhandler)
        """
        # this should only be one value, loop just to make sure to
        # clean everything
        sessions = (session for session in self.get_all_sessions()
                    if session.sessid == sessid)
        for session in sessions:
            # this will also trigger unpuppeting
            session.sessionhandler.disconnect(session)

    # puppeting operations

    def puppet_object(self, sessid, obj, normal_mode=True):
        """
        Use the given session to control (puppet) the given object (usually
        a Character type). Note that we make no puppet checks here, that must
        have been done before calling this method.

        sessid - session id of session to connect
        obj - the object to connect to
        normal_mode - trigger hooks and extra checks - this is turned off when
                     the server reloads, to quickly re-connect puppets.

        returns True if successful, False otherwise
        """
        session = self.get_session(sessid)
        if not session:
            return False
        if normal_mode and session.puppet:
            # cleanly unpuppet eventual previous object puppeted by this session
            self.unpuppet_object(sessid)
        if obj.player and obj.player.is_connected and obj.player != self:
            # we don't allow to puppet an object already controlled by an active
            # player. To kick a player, call unpuppet_object on them explicitly.
            return
        # if we get to this point the character is ready to puppet or it
        # was left with a lingering player/sessid reference from an unclean
        # server kill or similar

        if normal_mode:
            _GA(obj.typeclass, "at_pre_puppet")(_GA(self, "typeclass"), sessid=sessid)
        # do the connection
        obj.sessid = sessid
        obj.player = self
        session.puid = obj.id
        session.puppet = obj
        # validate/start persistent scripts on object
        ScriptDB.objects.validate(obj=obj)
        if normal_mode:
            _GA(obj.typeclass, "at_post_puppet")()
        return True

    def unpuppet_object(self, sessid):
        """
        Disengage control over an object

        sessid - the session id to disengage

        returns True if successful
        """
        session = self.get_session(sessid)
        if not session:
            return False
        obj = hasattr(session, "puppet") and session.puppet or None
        if not obj:
            return False
        # do the disconnect
        _GA(obj.typeclass, "at_pre_unpuppet")()
        del obj.dbobj.sessid
        del obj.dbobj.player
        session.puppet = None
        session.puid = None
        _GA(obj.typeclass, "at_post_unpuppet")(_GA(self, "typeclass"), sessid=sessid)
        return True

    def unpuppet_all(self):
        """
        Disconnect all puppets. This is called by server
        before a reset/shutdown.
        """
        for session in self.get_all_sessions():
            self.unpuppet_object(session.sessid)

    def get_puppet(self, sessid, return_dbobj=False):
        """
        Get an object puppeted by this session through this player. This is
        the main method for retrieving the puppeted object from the
        player's end.

        sessid - return character connected to this sessid,
        character - return character if connected to this player, else None.

        """
        session = self.get_session(sessid)
        if not session:
            return None
        if return_dbobj:
            return session.puppet
        return session.puppet and session.puppet.typeclass or None

    def get_all_puppets(self, return_dbobj=False):
        """
        Get all currently puppeted objects as a list
        """
        puppets = [session.puppet for session in self.get_all_sessions()
                                                            if session.puppet]
        if return_dbobj:
            return puppets
        return [puppet.typeclass for puppet in puppets]

    def __get_single_puppet(self):
        """
        This is a legacy convenience link for users of
        MULTISESSION_MODE 0 or 1. It will return
        only the first puppet. For mode 2, this returns
        a list of all characters.
        """
        puppets = self.get_all_puppets()
        if _MULTISESSION_MODE in (0, 1):
            return puppets and puppets[0] or None
        return puppets
    character = property(__get_single_puppet)
    puppet = property(__get_single_puppet)

    # utility methods

    def delete(self, *args, **kwargs):
        """
        Deletes the player permanently.
        """
        for session in self.get_all_sessions():
            # unpuppeting all objects and disconnecting the user, if any
            # sessions remain (should usually be handled from the
            # deleting command)
            self.unpuppet_object(session.sessid)
            session.sessionhandler.disconnect(session, reason=_("Player being deleted."))
        self.scripts.stop()
        _GA(self, "attributes").clear()
        _GA(self, "nicks").clear()
        _GA(self, "aliases").clear()
        super(PlayerDB, self).delete(*args, **kwargs)

    def execute_cmd(self, raw_string, sessid=None):
        """
        Do something as this player. This method is never called normally,
        but only when the player object itself is supposed to execute the
        command. It takes player nicks into account, but not nicks of
        eventual puppets.

        raw_string - raw command input coming from the command line.
        """
        raw_string = utils.to_unicode(raw_string)
        raw_string = self.nicks.nickreplace(raw_string,
                          categories=("inputline", "channel"), include_player=False)
        if not sessid and _MULTISESSION_MODE in (0, 1):
            # in this case, we should either have only one sessid, or the sessid
            # should not matter (since the return goes to all of them we can
            # just use the first one as the source)
            try:
                sessid = self.get_all_sessions()[0].sessid
            except IndexError:
                # this can happen for bots
                sessid = None
        return cmdhandler.cmdhandler(self.typeclass, raw_string,
                                     callertype="player", sessid=sessid)

    def search(self, searchdata, return_puppet=False, **kwargs):
        """
        This is similar to the ObjectDB search method but will search for
        Players only. Errors will be echoed, and None returned if no Player
        is found.
        searchdata - search criterion, the Player's key or dbref to search for
        return_puppet  - will try to return the object the player controls
                           instead of the Player object itself. If no
                           puppeted object exists (since Player is OOC), None will
                           be returned.
        Extra keywords are ignored, but are allowed in call in order to make
                           API more consistent with objects.models.TypedObject.search.
        """
        #TODO deprecation
        if "return_character" in kwargs:
            logger.log_depmsg("Player.search's 'return_character' keyword is deprecated. Use the return_puppet keyword instead.")
            return_puppet = kwargs.get("return_character")

        matches = _GA(self, "__class__").objects.player_search(searchdata)
        matches = _AT_SEARCH_RESULT(_GA(self, "typeclass"), searchdata, matches, global_search=True)
        if matches and return_puppet:
            try:
                return _GA(matches, "puppet")
            except AttributeError:
                return None
        return matches


########NEW FILE########
__FILENAME__ = player
"""
Typeclass for Player objects

Note that this object is primarily intended to
store OOC information, not game info! This
object represents the actual user (not their
character) and has NO actual precence in the
game world (this is handled by the associated
character object, so you should customize that
instead for most things).

"""

import datetime
from django.conf import settings
from src.typeclasses.typeclass import TypeClass
from src.comms.models import ChannelDB
from src.utils import logger
__all__ = ("Player",)

_MULTISESSION_MODE = settings.MULTISESSION_MODE
_CMDSET_PLAYER = settings.CMDSET_PLAYER
_CONNECT_CHANNEL = None


class Player(TypeClass):
    """
    Base typeclass for all Players.
    """
    def __init__(self, dbobj):
        """
        This is the base Typeclass for all Players. Players represent
        the person playing the game and tracks account info, password
        etc. They are OOC entities without presence in-game. A Player
        can connect to a Character Object in order to "enter" the
        game.

        Player Typeclass API:

        * Available properties (only available on initiated typeclass objects)

         key (string) - name of player
         name (string)- wrapper for user.username
         aliases (list of strings) - aliases to the object. Will be saved to
                            database as AliasDB entries but returned as strings.
         dbref (int, read-only) - unique #id-number. Also "id" can be used.
         dbobj (Player, read-only) - link to database model. dbobj.typeclass
                                     points back to this class
         typeclass (Player, read-only) - this links back to this class as an
                          identified only. Use self.swap_typeclass() to switch.
         date_created (string) - time stamp of object creation
         permissions (list of strings) - list of permission strings

         user (User, read-only) - django User authorization object
         obj (Object) - game object controlled by player. 'character' can also
                        be used.
         sessions (list of Sessions) - sessions connected to this player
         is_superuser (bool, read-only) - if the connected user is a superuser

        * Handlers

         locks - lock-handler: use locks.add() to add new lock strings
         db - attribute-handler: store/retrieve database attributes on this
                                 self.db.myattr=val, val=self.db.myattr
         ndb - non-persistent attribute handler: same as db but does not
                                     create a database entry when storing data
         scripts - script-handler. Add new scripts to object with scripts.add()
         cmdset - cmdset-handler. Use cmdset.add() to add new cmdsets to object
         nicks - nick-handler. New nicks with nicks.add().

        * Helper methods

         msg(outgoing_string, from_obj=None, **kwargs)
         swap_character(new_character, delete_old_character=False)
         execute_cmd(raw_string)
         search(ostring, global_search=False, attribute_name=None,
                         use_nicks=False, location=None,
                         ignore_errors=False, player=False)
         is_typeclass(typeclass, exact=False)
         swap_typeclass(new_typeclass, clean_attributes=False, no_default=True)
         access(accessing_obj, access_type='read', default=False)
         check_permstring(permstring)

        * Hook methods

         basetype_setup()
         at_player_creation()

         - note that the following hooks are also found on Objects and are
           usually handled on the character level:

         at_init()
         at_access()
         at_cmdset_get()
         at_first_login()
         at_post_login(sessid=None)
         at_disconnect()
         at_message_receive()
         at_message_send()
         at_server_reload()
         at_server_shutdown()

         """
        super(Player, self).__init__(dbobj)

    ## methods inherited from database model

    def msg(self, text=None, from_obj=None, sessid=None, **kwargs):
        """
        Evennia -> User
        This is the main route for sending data back to the user from
        the server.

        text (string) - text data to send
        from_obj (Object/Player) - source object of message to send
        sessid - the session id of the session to send to. If not given,
          return to all sessions connected to this player. This is usually only
          relevant when using msg() directly from a player-command (from
          a command on a Character, the character automatically stores and
          handles the sessid).
        kwargs - extra data to send through protocol
                 """
        self.dbobj.msg(text=text, from_obj=from_obj, sessid=sessid, **kwargs)

    def swap_character(self, new_character, delete_old_character=False):
        """
        Swaps the character controlled by this Player, if possible.

        new_character (Object) - character/object to swap to
        delete_old_character (bool) - delete the old character when swapping

        Returns: True/False depending on if swap suceeded or not.
        """
        return self.dbobj.swap_character(new_character, delete_old_character=delete_old_character)

    def execute_cmd(self, raw_string, sessid=None):
        """
        Do something as this object. This command transparently
        lets its typeclass execute the command. This method
        is -not- called by Evennia normally, it is here to be
        called explicitly in code.

        Argument:
        raw_string (string) - raw command input
        sessid (int) - id of session executing the command. This sets the
                       sessid property on the command

        Returns Deferred - this is an asynchronous Twisted object that will
            not fire until the command has actually finished executing. To
            overload this one needs to attach callback functions to it, with
            addCallback(function). This function will be called with an
            eventual return value from the command execution.

            This return is not used at all by Evennia by default, but might
            be useful for coders intending to implement some sort of nested
            command structure.
        """
        return self.dbobj.execute_cmd(raw_string, sessid=sessid)

    def search(self, searchdata, return_puppet=False, **kwargs):
        """
        This is similar to the Object search method but will search for
        Players only. Errors will be echoed, and None returned if no Player
        is found.
        searchdata - search criterion, the Player's key or dbref to search for
        return_puppet  - will try to return the object the player controls
                           instead of the Player object itself. If no
                           puppeted object exists (since Player is OOC), None will
                           be returned.
        Extra keywords are ignored, but are allowed in call in order to make
                           API more consistent with objects.models.TypedObject.search.
        """
        # handle me, self and *me, *self
        if isinstance(searchdata, basestring):
            # handle wrapping of common terms
            if searchdata.lower() in ("me", "*me", "self", "*self",):
                return self
        return self.dbobj.search(searchdata, return_puppet=return_puppet, **kwargs)

    def is_typeclass(self, typeclass, exact=False):
        """
        Returns true if this object has this type
          OR has a typeclass which is an subclass of
          the given typeclass.

        typeclass - can be a class object or the
                python path to such an object to match against.

        exact - returns true only if the object's
               type is exactly this typeclass, ignoring
               parents.

        Returns: Boolean
        """
        return self.dbobj.is_typeclass(typeclass, exact=exact)

    def swap_typeclass(self, new_typeclass, clean_attributes=False, no_default=True):
        """
        This performs an in-situ swap of the typeclass. This means
        that in-game, this object will suddenly be something else.
        Player will not be affected. To 'move' a player to a different
        object entirely (while retaining this object's type), use
        self.player.swap_object().

        Note that this might be an error prone operation if the
        old/new typeclass was heavily customized - your code
        might expect one and not the other, so be careful to
        bug test your code if using this feature! Often its easiest
        to create a new object and just swap the player over to
        that one instead.

        Arguments:
        new_typeclass (path/classobj) - type to switch to
        clean_attributes (bool/list) - will delete all attributes
                           stored on this object (but not any
                           of the database fields such as name or
                           location). You can't get attributes back,
                           but this is often the safest bet to make
                           sure nothing in the new typeclass clashes
                           with the old one. If you supply a list,
                           only those named attributes will be cleared.
        no_default - if this is active, the swapper will not allow for
                     swapping to a default typeclass in case the given
                     one fails for some reason. Instead the old one
                     will be preserved.
        Returns:
          boolean True/False depending on if the swap worked or not.

        """
        self.dbobj.swap_typeclass(new_typeclass,
                    clean_attributes=clean_attributes, no_default=no_default)

    def access(self, accessing_obj, access_type='read', default=False, **kwargs):
        """
        Determines if another object has permission to access this object
        in whatever way.

          accessing_obj (Object)- object trying to access this one
          access_type (string) - type of access sought
          default (bool) - what to return if no lock of access_type was found
          **kwargs - passed to the at_access hook along with the result.
        """
        result = self.dbobj.access(accessing_obj, access_type=access_type, default=default)
        self.at_access(result, accessing_obj, access_type, **kwargs)
        return result

    def check_permstring(self, permstring):
        """
        This explicitly checks the given string against this object's
        'permissions' property without involving any locks.

        permstring (string) - permission string that need to match a permission
                              on the object. (example: 'Builders')
        Note that this method does -not- call the at_access hook.
        """
        return self.dbobj.check_permstring(permstring)

    ## player hooks

    def basetype_setup(self):
        """
        This sets up the basic properties for a player.
        Overload this with at_player_creation rather than
        changing this method.

        """
        # the text encoding to use.
        self.db.encoding = "utf-8"

        # A basic security setup
        lockstring = "examine:perm(Wizards);edit:perm(Wizards);delete:perm(Wizards);boot:perm(Wizards);msg:all()"
        self.locks.add(lockstring)

        # The ooc player cmdset
        self.cmdset.add_default(_CMDSET_PLAYER, permanent=True)

    def at_player_creation(self):
        """
        This is called once, the very first time
        the player is created (i.e. first time they
        register with the game). It's a good place
        to store attributes all players should have,
        like configuration values etc.
        """
        # set an (empty) attribute holding the characters this player has
        lockstring = "attrread:perm(Admins);attredit:perm(Admins);attrcreate:perm(Admins)"
        self.attributes.add("_playable_characters", [], lockstring=lockstring)

    def at_init(self):
        """
        This is always called whenever this object is initiated --
        that is, whenever it its typeclass is cached from memory. This
        happens on-demand first time the object is used or activated
        in some way after being created but also after each server
        restart or reload. In the case of player objects, this usually
        happens the moment the player logs in or reconnects after a
        reload.
        """
        pass

    # Note that the hooks below also exist in the character object's
    # typeclass. You can often ignore these and rely on the character
    # ones instead, unless you are implementing a multi-character game
    # and have some things that should be done regardless of which
    # character is currently connected to this player.

    def at_access(self, result, accessing_obj, access_type, **kwargs):
        """
        This is called with the result of an access call, along with
        any kwargs used for that call. The return of this method does
        not affect the result of the lock check. It can be used e.g. to
        customize error messages in a central location or other effects
        based on the access result.
        """
        pass

    def at_cmdset_get(self):
        """
        Called just before cmdsets on this player are requested by the
        command handler. If changes need to be done on the fly to the cmdset
        before passing them on to the cmdhandler, this is the place to do it.
        This is called also if the player currently have no cmdsets.
        """
        pass

    def at_first_login(self):
        """
        Only called once, the very first
        time the user logs in.
        """
        pass

    def at_pre_login(self):
        """
        Called every time the user logs in, just before the actual
        login-state is set.
        """
        pass

    def _send_to_connect_channel(self, message):
        "Helper method for loading the default comm channel"
        global _CONNECT_CHANNEL
        if not _CONNECT_CHANNEL:
            try:
                _CONNECT_CHANNEL = ChannelDB.objects.filter(db_key=settings.CHANNEL_CONNECTINFO[0])[0]
            except Exception:
                logger.log_trace()
        now = datetime.datetime.now()
        now = "%02i-%02i-%02i(%02i:%02i)" % (now.year, now.month,
                                             now.day, now.hour, now.minute)
        if _CONNECT_CHANNEL:
            _CONNECT_CHANNEL.tempmsg("[%s, %s]: %s" % (_CONNECT_CHANNEL.key, now, message))
        else:
            logger.log_infomsg("[%s]: %s" % (now, message))

    def at_post_login(self, sessid=None):
        """
        Called at the end of the login process, just before letting
        them loose. This is called before an eventual Character's
        at_post_login hook.
        """
        self._send_to_connect_channel("{G%s connected{n" % self.key)
        if _MULTISESSION_MODE == 0:
            # in this mode we should have only one character available. We
            # try to auto-connect to it by calling the @ic command
            # (this relies on player.db._last_puppet being set)
            self.execute_cmd("@ic", sessid=sessid)
        elif _MULTISESSION_MODE == 1:
            # in this mode the first session to connect acts like mode 0,
            # the following sessions "share" the same view and should
            # not perform any actions
            if not self.get_all_puppets():
                self.execute_cmd("@ic", sessid=sessid)
        elif _MULTISESSION_MODE == 2:
            # In this mode we by default end up at a character selection
            # screen. We execute look on the player.
            self.execute_cmd("look", sessid=sessid)

    def at_disconnect(self, reason=None):
        """
        Called just before user is disconnected.
        """
        reason = reason and "(%s)" % reason or ""
        self._send_to_connect_channel("{R%s disconnected %s{n" % (self.key, reason))

    def at_message_receive(self, message, from_obj=None):
        """
        Called when any text is emitted to this
        object. If it returns False, no text
        will be sent automatically.
        """
        return True

    def at_message_send(self, message, to_object):
        """
        Called whenever this object tries to send text
        to another object. Only called if the object supplied
        itself as a sender in the msg() call.
        """
        pass

    def at_server_reload(self):
        """
        This hook is called whenever the server is shutting down for
        restart/reboot. If you want to, for example, save non-persistent
        properties across a restart, this is the place to do it.
        """
        pass

    def at_server_shutdown(self):
        """
        This hook is called whenever the server is shutting down fully
        (i.e. not for a restart).
        """
        pass

########NEW FILE########
__FILENAME__ = admin
#
# This sets up how models are displayed
# in the web admin interface.
#

from src.typeclasses.models import Attribute
from src.scripts.models import ScriptDB
from django.contrib import admin


class AttributeInline(admin.TabularInline):
    model = Attribute
    fields = ('db_key', 'db_value')
    max_num = 1


class ScriptDBAdmin(admin.ModelAdmin):

    list_display = ('id', 'db_key', 'db_typeclass_path',
                    'db_obj', 'db_interval', 'db_repeats', 'db_persistent')
    list_display_links = ('id', 'db_key')
    ordering = ['db_obj', 'db_typeclass_path']
    search_fields = ['^db_key', 'db_typeclass_path']
    save_as = True
    save_on_top = True
    list_select_related = True
    raw_id_fields = ('db_obj',)

    fieldsets = (
        (None, {
                'fields': (('db_key', 'db_typeclass_path'), 'db_interval',
                            'db_repeats', 'db_start_delay', 'db_persistent',
                            'db_obj')}),
        )
    #inlines = [AttributeInline]


admin.site.register(ScriptDB, ScriptDBAdmin)

########NEW FILE########
__FILENAME__ = manager
"""
The custom manager for Scripts.
"""

from django.db.models import Q
from src.typeclasses.managers import TypedObjectManager
from src.typeclasses.managers import returns_typeclass_list
from src.utils.utils import make_iter
__all__ = ("ScriptManager",)
_GA = object.__getattribute__

VALIDATE_ITERATION = 0


class ScriptManager(TypedObjectManager):
    """
    This Scriptmanager implements methods for searching
    and manipulating Scripts directly from the database.

    Evennia-specific search methods (will return Typeclasses or
    lists of Typeclasses, whereas Django-general methods will return
    Querysets or database objects).

    dbref (converter)
    get_id  (or dbref_search)
    get_dbref_range
    object_totals
    typeclass_search
    get_all_scripts_on_obj
    get_all_scripts
    delete_script
    remove_non_persistent
    validate
    script_search (equivalent to ev.search_script)
    copy_script

    """
    @returns_typeclass_list
    def get_all_scripts_on_obj(self, obj, key=None):
        """
        Returns as result all the Scripts related to a particular object.
        key can be given as a dbref or name string. If given, only scripts
        matching the key on the object will be returned.
        """
        if not obj:
            return []
        obj = obj.dbobj
        player = _GA(_GA(obj, "__class__"), "__name__") == "PlayerDB"
        if key:
            dbref = self.dbref(key)
            if dbref or dbref == 0:
                if player:
                    return self.filter(db_player=obj, id=dbref)
                else:
                    return self.filter(db_obj=obj, id=dbref)
            elif player:
                return self.filter(db_player=obj, db_key=key)
            else:
                return self.filter(db_obj=obj, db_key=key)
        elif player:
            return self.filter(db_player=obj)
        else:
            return self.filter(db_obj=obj)

    @returns_typeclass_list
    def get_all_scripts(self, key=None):
        """
        Return all scripts, alternative only
        scripts with a certain key/dbref
        """
        if key:
            script = []
            dbref = self.dbref(key)
            if dbref or dbref == 0:
                script = self.dbref_search(dbref)
            if not script:
                script = self.filter(db_key=key)
            return script
        return self.all()

    def delete_script(self, dbref):
        """
        This stops and deletes a specific script directly
        from the script database. This might be
        needed for global scripts not tied to
        a specific game object.
        """
        scripts = self.get_id(dbref)
        for script in make_iter(scripts):
            script.stop()

    def remove_non_persistent(self, obj=None):
        """
        This cleans up the script database of all non-persistent
        scripts, or only those on obj. It is called every time the server
        restarts.
        """
        if obj:
            to_stop = self.filter(db_obj=obj, db_persistent=False, db_is_active=True)
            to_delete = self.filter(db_obj=obj, db_persistent=False, db_is_active=False)
        else:
            to_stop = self.filter(db_persistent=False, db_is_active=True)
            to_delete = self.filter(db_persistent=False, db_is_active=False)
        nr_deleted = to_stop.count() + to_delete.count()
        for script in to_stop:
            script.stop()
        for script in to_delete:
            script.delete()
        return nr_deleted

    def validate(self, scripts=None, obj=None, key=None, dbref=None,
                 init_mode=False):
        """
        This will step through the script database and make sure
        all objects run scripts that are still valid in the context
        they are in. This is called by the game engine at regular
        intervals but can also be initiated by player scripts.
        If key and/or obj is given, only update the related
        script/object.

        Only one of the arguments are supposed to be supplied
        at a time, since they are exclusive to each other.

        scripts = a list of scripts objects obtained somewhere.
        obj = validate only scripts defined on a special object.
        key = validate only scripts with a particular key
        dbref = validate only the single script with this particular id.

        init_mode - This is used during server upstart and can have
             three values:
                False (no init mode). Called during run.
                "reset" - server reboot. Kill non-persistent scripts
                "reload" - server reload. Keep non-persistent scripts.

        This method also makes sure start any scripts it validates,
        this should be harmless, since already-active scripts
        have the property 'is_running' set and will be skipped.
        """

        # we store a variable that tracks if we are calling a
        # validation from within another validation (avoids
        # loops).

        global VALIDATE_ITERATION
        if VALIDATE_ITERATION > 0:
            # we are in a nested validation. Exit.
            VALIDATE_ITERATION -= 1
            return None, None
        VALIDATE_ITERATION += 1

        # not in a validation - loop. Validate as normal.

        nr_started = 0
        nr_stopped = 0

        if init_mode:
            if init_mode == 'reset':
                # special mode when server starts or object logs in.
                # This deletes all non-persistent scripts from database
                nr_stopped += self.remove_non_persistent(obj=obj)
            # turn off the activity flag for all remaining scripts
            scripts = self.get_all_scripts()
            for script in scripts:
                script.dbobj.is_active = False

        elif not scripts:
            # normal operation
            if dbref and self.dbref(dbref, reqhash=False):
                scripts = self.get_id(dbref)
            elif obj:
                #print "calling get_all_scripts_on_obj", obj, key, VALIDATE_ITERATION
                scripts = self.get_all_scripts_on_obj(obj, key=key)
            else:
                scripts = self.get_all_scripts(key=key) #self.model.get_all_cached_instances()

        if not scripts:
            # no scripts available to validate
            VALIDATE_ITERATION -= 1
            return None, None

        #print "scripts to validate: [%s]" % (", ".join(script.key for script in scripts))
        for script in scripts:
            #print "validating %s (%i) (init_mode=%s)" % (script.key, id(script.dbobj), init_mode)
            if script.is_valid():
                nr_started += script.start(force_restart=init_mode)
                #print "back from start. nr_started=", nr_started
            else:
                script.stop()
                nr_stopped += 1
        VALIDATE_ITERATION -= 1
        return nr_started, nr_stopped

    @returns_typeclass_list
    def script_search(self, ostring, obj=None, only_timed=False):
        """
        Search for a particular script.

        ostring - search criterion - a script ID or key
        obj - limit search to scripts defined on this object
        only_timed - limit search only to scripts that run
                     on a timer.
        """

        ostring = ostring.strip()

        dbref = self.dbref(ostring)
        if dbref or dbref == 0:
            # this is a dbref, try to find the script directly
            dbref_match = self.dbref_search(dbref)
            if dbref_match and not ((obj and obj != dbref_match.obj)
                                     or (only_timed and dbref_match.interval)):
                return [dbref_match]

        # not a dbref; normal search
        obj_restriction = obj and Q(db_obj=obj.dbobj) or Q()
        timed_restriction = only_timed and Q(interval__gt=0) or Q()
        scripts = self.filter(timed_restriction & obj_restriction & Q(db_key__iexact=ostring))
        return scripts

    def copy_script(self, original_script, new_key=None, new_obj=None, new_locks=None):
        """
        Make an identical copy of the original_script
        """
        typeclass = original_script.typeclass_path
        new_key = new_key if new_key is not None else original_script.key
        new_obj = new_obj if new_obj is not None else original_script.obj
        new_locks = new_locks if new_locks is not None else original_script.db_lock_storage

        from src.utils import create
        new_script = create.create_script(typeclass, key=new_key, obj=new_obj,
                                          locks=new_locks, autostart=True)
        return new_script

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):
    
    depends_on = (
        ('objects', '0001_initial'),)

    def forwards(self, orm):
        
        # Adding model 'ScriptAttribute'
        db.create_table('scripts_scriptattribute', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_value', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('db_mode', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['scripts.ScriptDB'])),
        ))
        db.send_create_signal('scripts', ['ScriptAttribute'])

        # Adding model 'ScriptDB'
        db.create_table('scripts_scriptdb', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_typeclass_path', self.gf('django.db.models.fields.CharField')(max_length=255, null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_permissions', self.gf('django.db.models.fields.CharField')(max_length=512, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_desc', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['objects.ObjectDB'], null=True, blank=True)),
            ('db_interval', self.gf('django.db.models.fields.IntegerField')(default=-1)),
            ('db_start_delay', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('db_repeats', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('db_persistent', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('db_is_active', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('scripts', ['ScriptDB'])


    def backwards(self, orm):
        
        # Deleting model 'ScriptAttribute'
        db.delete_table('scripts_scriptattribute')

        # Deleting model 'ScriptDB'
        db.delete_table('scripts_scriptdb')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_mode': ('django.db.models.fields.CharField', [], {'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_scriptattribute_db_mode
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

from src.utils.dbserialize import to_pickle
try:
    import cPickle as pickle
except ImportError:
    import pickle
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__


# overloading pickle to have it find the PackedDBobj in this module
import pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

renametable = {
        'src.typeclasses.models': 'src.objects.migrations.0019_convert_attrdata',
        'PackedDBobject': 'PackedDBobject',
}

def mapname(name):
    if name in renametable:
        return renametable[name]
    return name

def mapped_load_global(self):
    module = mapname(self.readline()[:-1])
    name = mapname(self.readline()[:-1])
    klass = self.find_class(module, name)
    self.append(klass)

def loads(str):
    file = StringIO(str)
    unpickler = pickle.Unpickler(file)
    unpickler.dispatch[pickle.GLOBAL] = mapped_load_global
    return unpickler.load()



class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)
try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Deleting field 'ScriptAttribute.db_mode'

        if not db.dry_run:
            for attr in orm["scripts.ScriptAttribute"].objects.all():
                # resave attributes
                db_mode = attr.db_mode
                if db_mode and db_mode != 'pickle':
                    # an object. We need to resave this.
                    if db_mode == 'object':
                        val = PackedDBobject(attr.db_value, "objectdb")
                    elif db_mode == 'player':
                        val = PackedDBobject(attr.db_value, "playerdb")
                    elif db_mode == 'script':
                        val = PackedDBobject(attr.db_value, "scriptdb")
                    elif db_mode == 'help':
                        val = PackedDBobject(attr.db_value, "helpentry")
                    else:
                        val = PackedDBobject(attr.db_value, db_mode) # channel, msg
                    attr.value = val

        db.delete_column('scripts_scriptattribute', 'db_mode')


    def backwards(self, orm):

        # Adding field 'ScriptAttribute.db_mode'
        db.add_column('scripts_scriptattribute', 'db_mode', self.gf('django.db.models.fields.CharField')(max_length=20, null=True, blank=True), keep_default=False)


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0003_auto__chg_field_scriptdb_db_lock_storage__chg_field_scriptdb_db_permis
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'ScriptDB.db_lock_storage'
        db.alter_column('scripts_scriptdb', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'ScriptDB.db_permissions'
        db.alter_column('scripts_scriptdb', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=255))

        # Changing field 'ScriptAttribute.db_lock_storage'
        db.alter_column('scripts_scriptattribute', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))


    def backwards(self, orm):
        
        # Changing field 'ScriptDB.db_lock_storage'
        db.alter_column('scripts_scriptdb', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

        # Changing field 'ScriptDB.db_permissions'
        db.alter_column('scripts_scriptdb', 'db_permissions', self.gf('django.db.models.fields.CharField')(max_length=512))

        # Changing field 'ScriptAttribute.db_lock_storage'
        db.alter_column('scripts_scriptattribute', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0004_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'ScriptDB', fields ['db_key']
        db.create_index('scripts_scriptdb', ['db_key'])

        # Adding index on 'ScriptAttribute', fields ['db_key']
        db.create_index('scripts_scriptattribute', ['db_key'])


    def backwards(self, orm):
        
        # Removing index on 'ScriptAttribute', fields ['db_key']
        db.delete_index('scripts_scriptattribute', ['db_key'])

        # Removing index on 'ScriptDB', fields ['db_key']
        db.delete_index('scripts_scriptdb', ['db_key'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0005_converting_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    import cPickle as pickle
except ImportError:
    import pickle
from src.utils.utils import to_str, to_unicode
#from src.typeclasses.models import PackedDBobject,PackedDict,PackedList

from django.contrib.contenttypes.models import ContentType
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()

def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

def from_attr(attr, datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.dbref_search(data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject:
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return PackedDict(attr, dict(zip([key for key in item.keys()],
                                             [iter_id2db(val) for val in item.values()])))
        elif hasattr(item, '__iter__'):
            return PackedList(attr, list(iter_id2db(val) for val in item))
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for attr in orm.ScriptAttribute.objects.all():
            try:
                # repack attr into new format, and reimport
                val = pickle.loads(to_str(attr.db_value))
                if hasattr(val, '__iter__'):
                    val = ("iter", val)
                elif type(val) == PackedDBobject:
                    val = ("dbobj", val)
                else:
                    val = ("simple", val)
                attr.db_value = to_unicode(pickle.dumps(to_str(to_attr(from_attr(attr, val)))))
                attr.save()
            except TypeError, RuntimeError:
                pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0006_converting_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    import cPickle as pickle
except ImportError:
    import pickle
from src.utils.utils import to_str, to_unicode
#from src.typeclasses.models import PackedDBobject

from django.contrib.contenttypes.models import ContentType
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__

class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)


class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

        """
        self.db_obj = db_obj
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.db_obj.value = self
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.db_obj.value = self
    def pop(self, *args, **kwargs):
        "Custom pop"
        super(PackedDict, self).pop(*args, **kwargs)
        self.db_obj.value = self
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        super(PackedDict, self).popitem(*args, **kwargs)
        self.db_obj.value = self
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.db_obj.value = self

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing list.
         db_obj - the Attribute object storing this dict.
        """
        self.db_obj = db_obj
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.db_obj.value = self
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.db_obj.value = self
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.db_obj.value = self
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.db_obj.value = self
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.db_obj.value = self
    def pop(self, *args, **kwargs):
        "Custom pop"
        super(PackedList, self).pop(*args, **kwargs)
        self.db_obj.value = self
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.db_obj.value = self
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.db_obj.value = self


def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)

def from_attr(attr, datatuple):
    """
    Retrieve data from a previously stored attribute. This
    is always a dict with keys type and data.

    datatuple comes from the database storage and has
    the following format:
       (simple|dbobj|iter, <data>)
    where
        simple - a single non-db object, like a string. is returned as-is.
        dbobj - a single dbobj-id. This id is retrieved back from the database.
        iter - an iterable. This is traversed iteratively, converting all found
               dbobj-ids back to objects. Also, all lists and dictionaries are
               returned as their PackedList/PackedDict counterparts in order to
               allow in-place assignment such as obj.db.mylist[3] = val. Mylist
               is then a PackedList that saves the data on the fly.
    """
    # nested functions
    def id2db(data):
        """
        Convert db-stored dbref back to object
        """
        mclass = CTYPEGET(model=data.db_model).model_class()
        try:
            return mclass.objects.dbref_search(data.id)

        except AttributeError:
            try:
                return mclass.objects.get(id=data.id)
            except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                return None

    def iter_id2db(item):
        """
        Recursively looping through stored iterables, replacing ids with actual objects.
        We return PackedDict and PackedLists instead of normal lists; this is needed in order for
        the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
        stored in the database are however always normal python primitives.
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif dtype == PackedDBobject:
            return id2db(item)
        elif dtype == tuple:
            return tuple([iter_id2db(val) for val in item])
        elif dtype in (dict, PackedDict):
            return attr, dict(zip([key for key in item.keys()],
                                             [iter_id2db(val) for val in item.values()]))
        elif hasattr(item, '__iter__'):
            return list(iter_id2db(val) for val in item)
        else:
            return item

    typ, data = datatuple

    if typ == 'simple':
        # single non-db objects
        return data
    elif typ == 'dbobj':
        # a single stored dbobj
        return id2db(data)
    elif typ == 'iter':
        # all types of iterables
        return iter_id2db(data)

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for attr in orm.ScriptAttribute.objects.all():
            try:
                # repack attr into new format, and reimport
                val = pickle.loads(to_str(attr.db_value))
                attr.db_value = to_unicode(pickle.dumps(to_str(to_attr(from_attr(attr, val)))))
                attr.save()
            except TypeError, RuntimeError:
                pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0007_typeclass_to_new_api_default
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."

    def forwards(self, orm):
        "Write your forwards methods here."
        try:
            for obj in orm.ScriptDB.objects.all():
                if obj.db_typeclass_path == "game.gamesrc.scripts.basescript.Script":
                    obj.db_typeclass_path = "src.scripts.scripts.Script"
                    obj.save()

        except utils.DatabaseError:
            "We are starting from scratch. Ignore."
            pass

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError
    
    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0008_auto__chg_field_scriptdb_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ScriptDB.db_lock_storage'
        db.alter_column('scripts_scriptdb', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'ScriptDB.db_lock_storage'
        db.alter_column('scripts_scriptdb', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
########NEW FILE########
__FILENAME__ = 0009_auto__chg_field_scriptattribute_db_lock_storage
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ScriptAttribute.db_lock_storage'
        db.alter_column('scripts_scriptattribute', 'db_lock_storage', self.gf('django.db.models.fields.TextField')())

    def backwards(self, orm):

        # Changing field 'ScriptAttribute.db_lock_storage'
        db.alter_column('scripts_scriptattribute', 'db_lock_storage', self.gf('django.db.models.fields.CharField')(max_length=512))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
########NEW FILE########
__FILENAME__ = 0010_add_picklefield
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'ScriptAttribute.db_value2'
        db.add_column('scripts_scriptattribute', 'db_value2',
                      self.gf('src.utils.picklefield.PickledObjectField')(null=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'ScriptAttribute.db_value2'
        db.delete_column('scripts_scriptattribute', 'db_value2')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
########NEW FILE########
__FILENAME__ = 0011_convert_attrdata
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

from django.contrib.contenttypes.models import ContentType

from src.utils.utils import to_str
from src.utils.dbserialize import to_pickle
try:
    import cPickle as pickle
except ImportError:
    import pickle
CTYPEGET = ContentType.objects.get
GA = object.__getattribute__
SA = object.__setattr__
DA = object.__delattr__


# overloading pickle to have it find the PackedDBobj in this module
import pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

renametable = {
        'src.typeclasses.models': 'src.scripts.migrations.0011_convert_attrdata',
        'PackedDBobject': 'PackedDBobject',
}

def mapname(name):
    if name in renametable:
        return renametable[name]
    return name

def mapped_load_global(self):
    module = mapname(self.readline()[:-1])
    name = mapname(self.readline()[:-1])
    klass = self.find_class(module, name)
    self.append(klass)

def loads(str):
    file = StringIO(str)
    unpickler = pickle.Unpickler(file)
    unpickler.dispatch[pickle.GLOBAL] = mapped_load_global
    return unpickler.load()



class PackedDBobject(object):
    """
    Attribute helper class.
    A container for storing and easily identifying database objects in
    the database (which doesn't suppport storing db_objects directly).
    """
    def __init__(self, ID, db_model, db_key):
        self.id = ID
        self.db_model = db_model
        self.key = db_key
    def __str__(self):
        return "%s(#%s)" % (self.key, self.id)
    def __unicode__(self):
        return u"%s(#%s)" % (self.key, self.id)

class PackedDict(dict):
    """
    Attribute helper class.
    A variant of dict that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        Sets up the packing dict. The db_store variable
        is set by Attribute.validate_data() when returned in
        order to allow custom updates to the dict.

         db_obj - the Attribute object storing this dict.

         The 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. Once initialization
         is over, the Attribute from_attr() method will assign
         the parent (or None, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedDict, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join("%s:%s" % (key, str(val)) for key, val in self.items())
    def save(self):
        "Relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "assign item to this dict"
        super(PackedDict, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[key]"
        super(PackedDict, self).__delitem__(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Custom clear"
        super(PackedDict, self).clear(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedDict, self).pop(*args, **kwargs)
        self.save()
        return ret
    def popitem(self, *args, **kwargs):
        "Custom popitem"
        ret = super(PackedDict, self).popitem(*args, **kwargs)
        self.save()
        return ret
    def setdefault(self, *args, **kwargs):
        "Custom setdefault"
        super(PackedDict, self).setdefault(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Custom update"
        super(PackedDict, self).update(*args, **kwargs)
        self.save()

class PackedList(list):
    """
    Attribute helper class.
    A variant of list that stores itself to the database when
    updating one of its keys. This is called and handled by
    Attribute.validate_data().
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing list.
         db_obj - the attribute object storing this list.

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedList, self).__init__(*args, **kwargs)
    def __str__(self):
        return "[%s]" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def __setitem__(self, *args, **kwargs):
        "Custom setitem that stores changed list to database."
        super(PackedList, self).__setitem__(*args, **kwargs)
        self.save()
    def __delitem__(self, *args, **kwargs):
        "delete with del self[index]"
        super(PackedList, self).__delitem__(*args, **kwargs)
        self.save()
    def append(self, *args, **kwargs):
        "Custom append"
        super(PackedList, self).append(*args, **kwargs)
        self.save()
    def extend(self, *args, **kwargs):
        "Custom extend"
        super(PackedList, self).extend(*args, **kwargs)
        self.save()
    def insert(self, *args, **kwargs):
        "Custom insert"
        super(PackedList, self).insert(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Custom remove"
        super(PackedList, self).remove(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Custom pop"
        ret = super(PackedList, self).pop(*args, **kwargs)
        self.save()
        return ret
    def reverse(self, *args, **kwargs):
        "Custom reverse"
        super(PackedList, self).reverse(*args, **kwargs)
        self.save()
    def sort(self, *args, **kwargs):
        "Custom sort"
        super(PackedList, self).sort(*args, **kwargs)
        self.save()

class PackedSet(set):
    """
    A variant of Set that stores new updates to the databse.
    """
    def __init__(self, db_obj, *args, **kwargs):
        """
        sets up the packing set.
         db_obj - the attribute object storing this set

         the 'parent' property is set to 'init' at creation,
         this stops the system from saving itself over and over
         when first assigning the dict. once initialization
         is over, the attribute from_attr() method will assign
         the parent (or none, if at the root)

        """
        self.db_obj = db_obj
        self.parent = 'init'
        super(PackedSet, self).__init__(*args, **kwargs)
    def __str__(self):
        return "{%s}" % ", ".join(str(val) for val in self)
    def save(self):
        "relay save operation upwards in tree until we hit the root."
        if self.parent == 'init':
            pass
        elif self.parent:
            self.parent.save()
        else:
            self.db_obj.value = self
    def add(self, *args, **kwargs):
        "Add an element to the set"
        super(PackedSet, self).add(*args, **kwargs)
        self.save()
    def clear(self, *args, **kwargs):
        "Remove all elements from this set"
        super(PackedSet, self).clear(*args, **kwargs)
        self.save()
    def difference_update(self, *args, **kwargs):
        "Remove all elements of another set from this set."
        super(PackedSet, self).difference_update(*args, **kwargs)
        self.save()
    def discard(self, *args, **kwargs):
        "Remove an element from a set if it is a member.\nIf not a member, do nothing."
        super(PackedSet, self).discard(*args, **kwargs)
        self.save()
    def intersection_update(self, *args, **kwargs):
        "Update a set with the intersection of itself and another."
        super(PackedSet, self).intersection_update(*args, **kwargs)
        self.save()
    def pop(self, *args, **kwargs):
        "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
        super(PackedSet, self).pop(*args, **kwargs)
        self.save()
    def remove(self, *args, **kwargs):
        "Remove an element from a set; it must be a member.\nIf the element is not a member, raise a KeyError."
        super(PackedSet, self).remove(*args, **kwargs)
        self.save()
    def symmetric_difference_update(self, *args, **kwargs):
        "Update a set with the symmetric difference of itself and another."
        super(PackedSet, self).symmetric_difference_update(*args, **kwargs)
        self.save()
    def update(self, *args, **kwargs):
        "Update a set with the union of itself and others."
        super(PackedSet, self).update(*args, **kwargs)
        self.save()

def to_attr(data):
    """
    Convert data to proper attr data format before saving

    We have to make sure to not store database objects raw, since
    this will crash the system. Instead we must store their IDs
    and make sure to convert back when the attribute is read back
    later.

    Due to this it's criticial that we check all iterables
    recursively, converting all found database objects to a form
    the database can handle. We handle lists, tuples and dicts
    (and any nested combination of them) this way, all other
    iterables are stored and returned as lists.

    data storage format:
       (simple|dbobj|iter, <data>)
    where
       simple - a single non-db object, like a string or number
       dbobj - a single dbobj
       iter - any iterable object - will be looped over recursively
              to convert dbobj->id.

    """

    def iter_db2id(item):
        """
        recursively looping through stored iterables, replacing objects with ids.
        (Python only builds nested functions once, so there is no overhead for nesting)
        """
        dtype = type(item)
        if dtype in (basestring, int, float): # check the most common types first, for speed
            return item
        elif hasattr(item, "id") and hasattr(item, "db_model_name") and hasattr(item, "db_key"):
            db_model_name = item.db_model_name
            if db_model_name == "typeclass":
                db_model_name = GA(item.dbobj, "db_model_name")
            return PackedDBobject(item.id, db_model_name, item.db_key)
        elif dtype == tuple:
            return tuple(iter_db2id(val) for val in item)
        elif dtype in (dict, PackedDict):
            return dict((key, iter_db2id(val)) for key, val in item.items())
        elif hasattr(item, '__iter__'):
            return list(iter_db2id(val) for val in item)
        else:
            return item

    dtype = type(data)

    if dtype in (basestring, int, float):
        return ("simple",data)
    elif hasattr(data, "id") and hasattr(data, "db_model_name") and hasattr(data, 'db_key'):
        # all django models (objectdb,scriptdb,playerdb,channel,msg,typeclass)
        # have the protected property db_model_name hardcoded on themselves for speed.
        db_model_name = data.db_model_name
        if db_model_name == "typeclass":
            # typeclass cannot help us, we want the actual child object model name
            db_model_name = GA(data.dbobj, "db_model_name")
        return ("dbobj", PackedDBobject(data.id, db_model_name, data.db_key))
    elif hasattr(data, "__iter__"):
        return ("iter", iter_db2id(data))
    else:
        return ("simple", data)


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):

    depends_on = (
                 ("objects", "0018_add_picklefield"),
                    )

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        # modified for migration - converts to plain python properties
        def from_attr(datatuple):
            """
            Retrieve data from a previously stored attribute. This
            is always a dict with keys type and data.

            datatuple comes from the database storage and has
            the following format:
               (simple|dbobj|iter, <data>)
            where
                simple - a single non-db object, like a string. is returned as-is.
                dbobj - a single dbobj-id. This id is retrieved back from the database.
                iter - an iterable. This is traversed iteratively, converting all found
                       dbobj-ids back to objects. Also, all lists and dictionaries are
                       returned as their PackedList/PackedDict counterparts in order to
                       allow in-place assignment such as obj.db.mylist[3] = val. Mylist
                       is then a PackedList that saves the data on the fly.
            """
            # nested functions
            def id2db(data):
                """
                Convert db-stored dbref back to object
                """
                mclass = CTYPEGET(model=data.db_model).model_class()
                try:
                    return mclass.objects.get(id=data.id)

                except AttributeError:
                    try:
                        return mclass.objects.get(id=data.id)
                    except mclass.DoesNotExist: # could happen if object was deleted in the interim.
                        return None

            def iter_id2db(item):
                """
                Recursively looping through stored iterables, replacing ids with actual objects.
                We return PackedDict and PackedLists instead of normal lists; this is needed in order for
                the user to do dynamic saving of nested in-place, such as obj.db.attrlist[2]=3. What is
                stored in the database are however always normal python primitives.
                """
                dtype = type(item)
                if dtype in (basestring, int, float, long, bool): # check the most common types first, for speed
                    return item
                elif dtype == PackedDBobject or hasattr(item, '__class__') and item.__class__.__name__ == "PackedDBobject":
                    return id2db(item)
                elif dtype == tuple:
                    return tuple([iter_id2db(val) for val in item])
                elif dtype in (dict, PackedDict):
                    return dict(zip([key for key in item.keys()],
                                                     [iter_id2db(val) for val in item.values()]))
                elif hasattr(item, '__iter__'):
                    return list(iter_id2db(val) for val in item)
                else:
                    return item

            typ, data = datatuple

            if typ == 'simple':
                # single non-db objects
                return data
            elif typ == 'dbobj':
                # a single stored dbobj
                return id2db(data)
            elif typ == 'iter':
                # all types of iterables
                return iter_id2db(data)

        if not db.dry_run:
            for attr in orm['scripts.ScriptAttribute'].objects.all():
                # repack attr into new format and reimport
                datatuple = loads(to_str(attr.db_value))
                python_data = from_attr(datatuple)
                new_data = to_pickle(python_data)
                attr.db_value2 = new_data # new pickleObjectField
                attr.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("This migration cannot be reversed.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0012_remove_old_attr_value_field
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'ScriptAttribute.db_value'
        db.delete_column('scripts_scriptattribute', 'db_value')
        db.rename_column('scripts_scriptattribute', 'db_value2', 'db_value')

    def backwards(self, orm):
        # Adding field 'ScriptAttribute.db_value'
        db.add_column('scripts_scriptattribute', 'db_value',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)
        db.rename_column('scripts_scriptattribute', 'db_value', 'db_value2')

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['scripts.ScriptDB']"}),
            'db_value2': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0013_auto__del_scriptattribute
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting model 'ScriptAttribute'
        db.delete_table(u'scripts_scriptattribute')

        # Adding M2M table for field db_attributes on 'ScriptDB'
        db.create_table(u'scripts_scriptdb_db_attributes', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('scriptdb', models.ForeignKey(orm[u'scripts.scriptdb'], null=False)),
            ('attribute', models.ForeignKey(orm[u'typeclasses.attribute'], null=False))
        ))
        db.create_unique(u'scripts_scriptdb_db_attributes', ['scriptdb_id', 'attribute_id'])


    def backwards(self, orm):
        # Adding model 'ScriptAttribute'
        db.create_table(u'scripts_scriptattribute', (
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_value2', self.gf('src.utils.picklefield.PickledObjectField')(null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_obj', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['scripts.ScriptDB'])),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('scripts', ['ScriptAttribute'])

        # Removing M2M table for field db_attributes on 'ScriptDB'
        db.delete_table('scripts_scriptdb_db_attributes')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
########NEW FILE########
__FILENAME__ = 0014_create_db_liteattributes_db_tags
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding M2M table for field db_liteattributes on 'ScriptDB'
        m2m_table_name = db.shorten_name(u'scripts_scriptdb_db_liteattributes')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('scriptdb', models.ForeignKey(orm[u'scripts.scriptdb'], null=False)),
            ('liteattribute', models.ForeignKey(orm[u'typeclasses.liteattribute'], null=False))
        ))
        db.create_unique(m2m_table_name, ['scriptdb_id', 'liteattribute_id'])

        # Adding M2M table for field db_tags on 'ScriptDB'
        m2m_table_name = db.shorten_name(u'scripts_scriptdb_db_tags')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('scriptdb', models.ForeignKey(orm[u'scripts.scriptdb'], null=False)),
            ('tag', models.ForeignKey(orm[u'typeclasses.tag'], null=False))
        ))
        db.create_unique(m2m_table_name, ['scriptdb_id', 'tag_id'])


    def backwards(self, orm):
        # Removing M2M table for field db_liteattributes on 'ScriptDB'
        db.delete_table(db.shorten_name(u'scripts_scriptdb_db_liteattributes'))

        # Removing M2M table for field db_tags on 'ScriptDB'
        db.delete_table(db.shorten_name(u'scripts_scriptdb_db_tags'))


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']

########NEW FILE########
__FILENAME__ = 0015_move_permissions_to_handler
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        Tag = orm['typeclasses.Tag']
        for obj in orm.ScriptDB.objects.all():
            if obj.db_permissions:
                for perm in [perm.strip() for perm in obj.db_permissions.split(",")]:
                    tag = Tag.objects.filter(db_key=perm.lower().strip(), db_category="permissions")
                    if tag:
                        tag = tag[0]
                    else:
                        tag = Tag(db_key=perm.lower().strip(), db_category="permissions")
                        tag.save()
                    obj.db_tags.add(tag)

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0016_auto__del_field_scriptdb_db_permissions
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'ScriptDB.db_permissions'
        db.delete_column(u'scripts_scriptdb', 'db_permissions')


    def backwards(self, orm):
        # Adding field 'ScriptDB.db_permissions'
        db.add_column(u'scripts_scriptdb', 'db_permissions',
                      self.gf('django.db.models.fields.CharField')(default='', max_length=255, blank=True),
                      keep_default=False)


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
########NEW FILE########
__FILENAME__ = 0017_auto__add_field_scriptdb_db_player
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'ScriptDB.db_player'
        db.add_column(u'scripts_scriptdb', 'db_player',
                      self.gf('django.db.models.fields.related.ForeignKey')(to=orm['players.PlayerDB'], null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'ScriptDB.db_player'
        db.delete_column(u'scripts_scriptdb', 'db_player_id')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_bot': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['scripts']
########NEW FILE########
__FILENAME__ = models
"""
Scripts are entities that perform some sort of action, either only
once or repeatedly. They can be directly linked to a particular
Evennia Object or be stand-alonw (in the latter case it is considered
a 'global' script). Scripts can indicate both actions related to the
game world as well as pure behind-the-scenes events and
effects. Everything that has a time component in the game (i.e. is not
hard-coded at startup or directly created/controlled by players) is
handled by Scripts.

Scripts have to check for themselves that they should be applied at a
particular moment of time; this is handled by the is_valid() hook.
Scripts can also implement at_start and at_end hooks for preparing and
cleaning whatever effect they have had on the game object.

Common examples of uses of Scripts:
- load the default cmdset to the player object's cmdhandler
  when logging in.
- switch to a different state, such as entering a text editor,
  start combat or enter a dark room.
- Weather patterns in-game
- merge a new cmdset with the default one for changing which
  commands are available at a particular time
- give the player/object a time-limited bonus/effect

"""
from django.conf import settings
from django.db import models
from django.core.exceptions import ObjectDoesNotExist
from src.typeclasses.models import TypedObject, TagHandler, AttributeHandler
from src.scripts.manager import ScriptManager
from src.utils.utils import dbref, to_str

__all__ = ("ScriptDB",)
_GA = object.__getattribute__
_SA = object.__setattr__


#------------------------------------------------------------
#
# ScriptDB
#
#------------------------------------------------------------

class ScriptDB(TypedObject):
    """
    The Script database representation.

    The TypedObject supplies the following (inherited) properties:
      key - main name
      name - alias for key
      typeclass_path - the path to the decorating typeclass
      typeclass - auto-linked typeclass
      date_created - time stamp of object creation
      permissions - perm strings
      dbref - #id of object
      db - persistent attribute storage
      ndb - non-persistent attribute storage

    The ScriptDB adds the following properties:
      desc - optional description of script
      obj - the object the script is linked to, if any
      player - the player the script is linked to (exclusive with obj)
      interval - how often script should run
      start_delay - if the script should start repeating right away
      repeats - how many times the script should repeat
      persistent - if script should survive a server reboot
      is_active - bool if script is currently running

    """


    #
    # ScriptDB Database Model setup
    #
    # These databse fields are all set using their corresponding properties,
    # named same as the field, but withtou the db_* prefix.

    # inherited fields (from TypedObject):
    # db_key, db_typeclass_path, db_date_created, db_permissions

    # optional description.
    db_desc = models.CharField('desc', max_length=255, blank=True)
    # A reference to the database object affected by this Script, if any.
    db_obj = models.ForeignKey("objects.ObjectDB", null=True, blank=True, verbose_name='scripted object',
                               help_text='the object to store this script on, if not a global script.')
    db_player = models.ForeignKey("players.PlayerDB", null=True, blank=True, verbose_name="scripted player",
                               help_text='the player to store this script on (should not be set if obj is set)')
    # how often to run Script (secs). -1 means there is no timer
    db_interval = models.IntegerField('interval', default=-1, help_text='how often to repeat script, in seconds. -1 means off.')
    # start script right away or wait interval seconds first
    db_start_delay = models.BooleanField('start delay', default=False, help_text='pause interval seconds before starting.')
    # how many times this script is to be repeated, if interval!=0.
    db_repeats = models.IntegerField('number of repeats', default=0, help_text='0 means off.')
    # defines if this script should survive a reboot or not
    db_persistent = models.BooleanField('survive server reboot', default=False)
    # defines if this script has already been started in this session
    db_is_active = models.BooleanField('script active', default=False)

    # Database manager
    objects = ScriptManager()

    # caches for quick lookups
    _typeclass_paths = settings.SCRIPT_TYPECLASS_PATHS
    _default_typeclass_path = settings.BASE_SCRIPT_TYPECLASS or "src.scripts.scripts.DoNothing"

    class Meta:
        "Define Django meta options"
        verbose_name = "Script"

    def __init__(self, *args, **kwargs):
        super(ScriptDB, self).__init__(*args, **kwargs)
        _SA(self, "attributes", AttributeHandler(self))
        _SA(self, "tags", TagHandler(self))
        #_SA(self, "aliases", AliasHandler(self))


    #
    #
    # ScriptDB class properties
    #
    #

    # obj property
    def __get_obj(self):
        """
        property wrapper that homogenizes access to either
        the db_player or db_obj field, using the same obj
        property name
        """
        obj = _GA(self, "db_player")
        if not obj:
            obj = _GA(self, "db_obj")
        if obj:
            return obj.typeclass

    def __set_obj(self, value):
        """
        Set player or obj to their right database field. If
        a dbref is given, assume ObjectDB.
        """
        try:
            value = _GA(value, "dbobj")
        except AttributeError:
            pass
        if isinstance(value, (basestring, int)):
            from src.objects.models import ObjectDB
            value = to_str(value, force_string=True)
            if (value.isdigit() or value.startswith("#")):
                dbid = dbref(value, reqhash=False)
                if dbid:
                    try:
                        value = ObjectDB.objects.get(id=dbid)
                    except ObjectDoesNotExist:
                        # maybe it is just a name that happens to look like a dbid
                        pass
        if value.__class__.__name__ == "PlayerDB":
            fname = "db_player"
            _SA(self, fname, value)
        else:
            fname = "db_obj"
            _SA(self, fname, value)
        # saving the field
        _GA(self, "save")(update_fields=[fname])
    obj = property(__get_obj, __set_obj)
    object = property(__get_obj, __set_obj)


    def at_typeclass_error(self):
        """
        If this is called, it means the typeclass has a critical
        error and cannot even be loaded. We don't allow a script
        to be created under those circumstances. Already created,
        permanent scripts are set to already be active so they
        won't get activated now (next reboot the bug might be fixed)
        """
        # By setting is_active=True, we trick the script not to run "again".
        self.is_active = True
        return super(ScriptDB, self).at_typeclass_error()

    delete_iter = 0
    def delete(self):
        "Delete script"
        if self.delete_iter > 0:
            return
        self.delete_iter += 1
        _GA(self, "attributes").clear()
        super(ScriptDB, self).delete()

########NEW FILE########
__FILENAME__ = scripthandler
"""
The script handler makes sure to check through all stored scripts
to make sure they are still relevant.
An scripthandler is automatically added to all game objects. You
access it through the property 'scripts' on the game object.
"""

from src.scripts.models import ScriptDB
from src.utils import create
from src.utils import logger

from django.utils.translation import ugettext as _

class ScriptHandler(object):
    """
    Implements the handler.  This sits on each game object.
    """
    def __init__(self, obj):
        """
        Set up internal state.
        obj - a reference to the object this handler is attached to.

        We retrieve all scripts attached to this object and check
        if they are all peristent. If they are not, they are just
        cruft left over from a server shutdown.
        """
        self.obj = obj

    def __str__(self):
        "List the scripts tied to this object"
        scripts = ScriptDB.objects.get_all_scripts_on_obj(self.obj)
        string = ""
        for script in scripts:
            interval = "inf"
            next_repeat = "inf"
            repeats = "inf"
            if script.interval > 0:
                interval = script.interval
                if script.repeats:
                    repeats = script.repeats
                try:
                    next_repeat = script.time_until_next_repeat()
                except:
                    next_repeat = "?"
            string += _("\n '%(key)s' (%(next_repeat)s/%(interval)s, %(repeats)s repeats): %(desc)s") % \
              {"key": script.key, "next_repeat": next_repeat,
               "interval": interval, "repeats": repeats, "desc": script.desc}
        return string.strip()

    def add(self, scriptclass, key=None, autostart=True):
        """
        Add an script to this object.

        scriptclass - either a class object
             inheriting from Script, an instantiated script object
             or a python path to such a class object.
        key - optional identifier for the script (often set in script
              definition)
        autostart - start the script upon adding it
        """
        if self.obj.dbobj.__class__.__name__ == "PlayerDB":
            # we add to a Player, not an Object
            script = create.create_script(scriptclass, key=key, player=self.obj,
                                          autostart=autostart)
        else:
            # the normal - adding to an Object
            script = create.create_script(scriptclass, key=key, obj=self.obj,
                                      autostart=autostart)
        if not script:
            logger.log_errmsg("Script %s could not be created and/or started." % scriptclass)
            return False
        return True

    def start(self, scriptid):
        """
        Find an already added script and force-start it
        """
        scripts = ScriptDB.objects.get_all_scripts_on_obj(self.obj, key=scriptid)
        num = 0
        for script in scripts:
            num += script.start()
        return num

    def delete(self, scriptid=None):
        """
        Forcibly delete a script from this object.

        scriptid can be a script key or the path to a script (in the
                 latter case all scripts with this path will be deleted!)
                 If no scriptid is set, delete all scripts on the object.

        """
        delscripts = ScriptDB.objects.get_all_scripts_on_obj(self.obj, key=scriptid)
        if not delscripts:
            delscripts = [script for script in ScriptDB.objects.get_all_scripts_on_obj(self.obj) if script.path == scriptid]
        num = 0
        for script in delscripts:
            num += script.stop()
        return num

    def stop(self, scriptid=None):
        """
        Alias for delete. scriptid can be a script key or a script path string.
        """
        return self.delete(scriptid)

    def all(self, scriptid=None):
        """
        Get all scripts stored in the handler, alternatively all matching a key.
        """
        return ScriptDB.objects.get_all_scripts_on_obj(self.obj, key=scriptid)

    def validate(self, init_mode=False):
        """
        Runs a validation on this object's scripts only.
        This should be called regularly to crank the wheels.
        """
        ScriptDB.objects.validate(obj=self.obj, init_mode=init_mode)


########NEW FILE########
__FILENAME__ = scripts
"""
This module contains the base Script class that all
scripts are inheriting from.

It also defines a few common scripts.
"""

from twisted.internet.defer import Deferred, maybeDeferred
from twisted.internet.task import LoopingCall
from django.conf import settings
from django.utils.translation import ugettext as _
from src.typeclasses.typeclass import TypeClass
from src.scripts.models import ScriptDB
from src.comms import channelhandler
from src.utils import logger

__all__ = ["Script", "DoNothing", "CheckSessions",
           "ValidateScripts", "ValidateChannelHandler"]

_GA = object.__getattribute__
_SESSIONS = None
# attr-cache size in MB
_ATTRIBUTE_CACHE_MAXSIZE = settings.ATTRIBUTE_CACHE_MAXSIZE

class ExtendedLoopingCall(LoopingCall):
    """
    LoopingCall that can start at a delay different
    than self.interval.
    """
    start_delay = None
    callcount = 0

    def start(self, interval, now=True, start_delay=None, count_start=0):
        """
        Start running function every interval seconds.

        This overloads the LoopingCall default by offering
        the start_delay keyword and ability to repeat.

        start_delay: The number of seconds before starting.
                     If None, wait interval seconds. Only
                     valid is now is False.
        repeat_start: the task will track how many times it has run.
                      this will change where it starts counting from.
                      Note that as opposed to Twisted's inbuild
                      counter, this will count also if force_repeat()
                      was called (so it will not just count the number
                      of interval seconds since start).
        """
        assert not self.running, ("Tried to start an already running "
                                  "ExtendedLoopingCall.")
        if interval < 0:
            raise ValueError, "interval must be >= 0"

        self.running = True
        d = self.deferred = Deferred()
        self.starttime = self.clock.seconds()
        self._expectNextCallAt = self.starttime
        self.interval = interval
        self._runAtStart = now
        self.callcount = max(0, count_start)

        if now:
            self()
        else:
            if start_delay is not None and start_delay >= 0:
                # we set start_delay after the _reshedule call to make
                # next_call_time() find it until next reshedule.
                self.interval = start_delay
                self._reschedule()
                self.interval = interval
                self.start_delay = start_delay
            else:
                self._reschedule()
        return d

    def __call__(self):
        "tick one step"
        self.callcount += 1
        super(ExtendedLoopingCall, self).__call__()

    def _reschedule(self):
        """
        Handle call rescheduling including
        nulling start_delay and stopping if
        number of repeats is reached.
        """
        self.start_delay = None
        super(ExtendedLoopingCall, self)._reschedule()

    def force_repeat(self):
        "Force-fire the callback"
        assert self.running, ("Tried to fire an ExtendedLoopingCall "
                              "that was not running.")
        if self.call is not None:
            self.call.cancel()
            self._expectNextCallAt = self.clock.seconds()
            self()

    def next_call_time(self):
        """
        Return the time in seconds until the next call. This takes
        start_delay into account.
        """
        if self.running:
            currentTime = self.clock.seconds()
            return self._expectNextCallAt - currentTime
        return None

#
# Base script, inherit from Script below instead.
#
class ScriptBase(TypeClass):
    """
    Base class for scripts. Don't inherit from this, inherit
    from the class 'Script'  instead.
    """
    # private methods

    def __eq__(self, other):
        """
        This has to be located at this level, having it in the
        parent doesn't work.
        """
        try:
            return other.dbid == self.dbid
        except Exception:
            return False

    def _start_task(self):
        "start task runner"

        self.ndb._task = ExtendedLoopingCall(self._step_task)

        if self.db._paused_time:
            # the script was paused; restarting
            callcount = self.db._paused_callcount or 0
            self.ndb._task.start(self.dbobj.db_interval,
                                 now=False,
                                 start_delay=self.db._paused_time,
                                 count_start=callcount)
            del self.db._paused_time
            del self.db._paused_repeats
        else:
            # starting script anew
            self.ndb._task.start(self.dbobj.db_interval,
                                 now=not self.dbobj.db_start_delay)

    def _stop_task(self):
        "stop task runner"
        task = self.ndb._task
        if task and task.running:
            task.stop()

    def _step_errback(self, e):
        "callback for runner errors"
        cname = self.__class__.__name__
        estring = _("Script %(key)s(#%(dbid)i) of type '%(cname)s': at_repeat() error '%(err)s'.") % \
                          {"key": self.key, "dbid": self.dbid, "cname": cname,
                           "err": e.getErrorMessage()}
        try:
            self.dbobj.db_obj.msg(estring)
        except Exception:
            pass
        logger.log_errmsg(estring)

    def _step_callback(self):
        "step task runner. No try..except needed due to defer wrap."

        if not self.is_valid():
            self.stop()
            return

        # call hook
        self.at_repeat()

        # check repeats
        callcount = self.ndb._task.callcount
        maxcount = self.dbobj.db_repeats
        if maxcount > 0 and maxcount <= callcount:
            #print "stopping script!"
            self.stop()

    def _step_task(self):
        "Step task. This groups error handling."
        try:
            return maybeDeferred(self._step_callback).addErrback(self._step_errback)
        except Exception:
            logger.log_trace()

    # Public methods

    def time_until_next_repeat(self):
        """
        Returns the time in seconds until the script will be
        run again. If this is not a stepping script, returns None.
        This is not used in any way by the script's stepping
        system; it's only here for the user to be able to
        check in on their scripts and when they will next be run.
        """
        task = self.ndb._task
        if task:
            try:
                return int(round(task.next_call_time()))
            except TypeError:
                pass
        return None

    def remaining_repeats(self):
        "Get the number of returning repeats. Returns None if unlimited repeats."
        task = self.ndb._task
        if task:
            return max(0, self.dbobj.db_repeats - task.callcount)

    def start(self, force_restart=False):
        """
        Called every time the script is started (for
        persistent scripts, this is usually once every server start)

        force_restart - if True, will always restart the script, regardless
                        of if it has started before.

        returns 0 or 1 to indicated the script has been started or not.
                Used in counting.
        """

        #print "Script %s (%s) start (active:%s, force:%s) ..." % (self.key, id(self.dbobj),
        #                                                         self.is_active, force_restart)

        if self.dbobj.is_active and not force_restart:
            # script already runs and should not be restarted.
            return 0

        obj = self.obj
        if obj:
            # check so the scripted object is valid and initalized
            try:
                _GA(obj.dbobj, 'cmdset')
            except AttributeError:
                # this means the object is not initialized.
                logger.log_trace()
                self.dbobj.is_active = False
                return 0

        # try to restart a paused script
        if self.unpause():
            return 1

        # start the script from scratch
        self.dbobj.is_active = True
        try:
            self.at_start()
        except Exception:
            logger.log_trace()

        if self.dbobj.db_interval > 0:
            self._start_task()
        return 1

    def stop(self, kill=False):
        """
        Called to stop the script from running.
        This also deletes the script.

        kill - don't call finishing hooks.
        """
        #print "stopping script %s" % self.key
        #import pdb
        #pdb.set_trace()
        if not kill:
            try:
                self.at_stop()
            except Exception:
                logger.log_trace()
        self._stop_task()
        try:
            self.dbobj.delete()
        except AssertionError:
            logger.log_trace()
            return 0
        return 1

    def pause(self):
        """
        This stops a running script and stores its active state.
        It WILL NOT call that at_stop() hook.
        """
        if not self.db._paused_time:
            # only allow pause if not already paused
            task = self.ndb._task
            if task:
                self.db._paused_time = task.next_call_time()
                self.db._paused_callcount = task.callcount
                self._stop_task()
            self.dbobj.is_active = False

    def unpause(self):
        """
        Restart a paused script. This WILL call the at_start() hook.
        """
        if self.db._paused_time:
            # only unpause if previously paused
            self.dbobj.is_active = True

            try:
                self.at_start()
            except Exception:
                logger.log_trace()

            self._start_task()
            return True

    def force_repeat(self):
        """
        Fire a premature triggering of the script callback. This
        will reset the timer and count down repeats as if the script
        had fired normally.
        """
        task = self.ndb._task
        if task:
            task.force_repeat()

    # hooks
    def at_script_creation(self):
        "placeholder"
        pass

    def is_valid(self):
        "placeholder"
        pass

    def at_start(self):
        "placeholder."
        pass

    def at_stop(self):
        "placeholder"
        pass

    def at_repeat(self):
        "placeholder"
        pass

    def at_init(self):
        "called when typeclass re-caches. Usually not used for scripts."
        pass


#
# Base Script - inherit from this
#

class Script(ScriptBase):
    """
    This is the class you should inherit from, it implements
    the hooks called by the script machinery.
    """

    def __init__(self, dbobj):
        """
        This is the base TypeClass for all Scripts. Scripts describe events,
        timers and states in game, they can have a time component or describe
        a state that changes under certain conditions.

        Script API:

        * Available properties (only available on initiated Typeclass objects)

         key (string) - name of object
         name (string)- same as key
         aliases (list of strings) - aliases to the object. Will be saved to
         database as AliasDB entries but returned as strings.
         dbref (int, read-only) - unique #id-number. Also "id" can be used.
         dbobj (Object, read-only) - link to database model. dbobj.typeclass
               points back to this class
         typeclass (Object, read-only) - this links back to this class as an
                 identified only. Use self.swap_typeclass() to switch.
         date_created (string) - time stamp of object creation
         permissions (list of strings) - list of permission strings

         desc (string)      - optional description of script, shown in listings
         obj (Object)       - optional object that this script is connected to
                              and acts on (set automatically
                              by obj.scripts.add())
         interval (int)     - how often script should run, in seconds.
                              <=0 turns off ticker
         start_delay (bool) - if the script should start repeating right
                              away or wait self.interval seconds
         repeats (int)      - how many times the script should repeat before
                              stopping. <=0 means infinite repeats
         persistent (bool)  - if script should survive a server shutdown or not
         is_active (bool)   - if script is currently running

        * Handlers

         locks - lock-handler: use locks.add() to add new lock strings
         db - attribute-handler: store/retrieve database attributes on this
              self.db.myattr=val, val=self.db.myattr
         ndb - non-persistent attribute handler: same as db but does not
               create a database entry when storing data

        * Helper methods

         start() - start script (this usually happens automatically at creation
                   and obj.script.add() etc)
         stop()  - stop script, and delete it
         pause() - put the script on hold, until unpause() is called. If script
                   is persistent, the pause state will survive a shutdown.
         unpause() - restart a previously paused script. The script will
                     continue as if it was never paused.
         force_repeat() - force-step the script, regardless of how much remains
                    until next step. This counts like a normal firing in all ways.
         time_until_next_repeat() - if a timed script (interval>0), returns
                    time until next tick
         remaining_repeats() - number of repeats remaining, if limited

        * Hook methods

         at_script_creation() - called only once, when an object of this
                                class is first created.
         is_valid() - is called to check if the script is valid to be running
                      at the current time. If is_valid() returns False, the
                      running script is stopped and removed from the game. You
                      can use this to check state changes (i.e. an script
                      tracking some combat stats at regular intervals is only
                      valid to run while there is actual combat going on).
          at_start() - Called every time the script is started, which for
                      persistent scripts is at least once every server start.
                      Note that this is unaffected by self.delay_start, which
                      only delays the first call to at_repeat(). It will also
                      be called after a pause, to allow for setting up the script.
          at_repeat() - Called every self.interval seconds. It will be called
                      immediately upon launch unless self.delay_start is True,
                      which will delay the first call of this method by
                      self.interval seconds. If self.interval<=0, this method
                      will never be called.
          at_stop() - Called as the script object is stopped and is about to
                      be removed from the game, e.g. because is_valid()
                      returned False or self.stop() was called manually.
          at_server_reload() - Called when server reloads. Can be used to save
                      temporary variables you want should survive a reload.
          at_server_shutdown() - called at a full server shutdown.


          """
        super(Script, self).__init__(dbobj)

    def at_script_creation(self):
        """
        Only called once, by the create function.
        """
        self.key = "<unnamed>"
        self.desc = ""
        self.interval = 0  # infinite
        self.start_delay = False
        self.repeats = 0  # infinite
        self.persistent = False

    def is_valid(self):
        """
        Is called to check if the script is valid to run at this time.
        Should return a boolean. The method is assumed to collect all needed
        information from its related self.obj.
        """
        return True

    def at_start(self):
        """
        Called whenever the script is started, which for persistent
        scripts is at least once every server start. It will also be called
        when starting again after a pause (such as after a server reload)
        """
        pass

    def at_repeat(self):
        """
        Called repeatedly if this Script is set to repeat
        regularly.
        """
        pass

    def at_stop(self):
        """
        Called whenever when it's time for this script to stop
        (either because is_valid returned False or it runs out of iterations)
        """
        pass

    def at_server_reload(self):
        """
        This hook is called whenever the server is shutting down for
        restart/reboot. If you want to, for example, save non-persistent
        properties across a restart, this is the place to do it.
        """
        pass

    def at_server_shutdown(self):
        """
        This hook is called whenever the server is shutting down fully
        (i.e. not for a restart).
        """
        pass


# Some useful default Script types used by Evennia.

class DoNothing(Script):
    "An script that does nothing. Used as default fallback."
    def at_script_creation(self):
        "Setup the script"
        self.key = "sys_do_nothing"
        self.desc = _("This is an empty placeholder script.")


class Store(Script):
    "Simple storage script"
    def at_script_creation(self):
        "Setup the script"
        self.key = "sys_storage"
        self.desc = _("This is a generic storage container.")


class CheckSessions(Script):
    "Check sessions regularly."
    def at_script_creation(self):
        "Setup the script"
        self.key = "sys_session_check"
        self.desc = _("Checks sessions so they are live.")
        self.interval = 60  # repeat every 60 seconds
        self.persistent = True

    def at_repeat(self):
        "called every 60 seconds"
        global _SESSIONS
        if not _SESSIONS:
            from src.server.sessionhandler import SESSIONS as _SESSIONS
        #print "session check!"
        #print "ValidateSessions run"
        _SESSIONS.validate_sessions()


class ValidateScripts(Script):
    "Check script validation regularly"
    def at_script_creation(self):
        "Setup the script"
        self.key = "sys_scripts_validate"
        self.desc = _("Validates all scripts regularly.")
        self.interval = 3600  # validate every hour.
        self.persistent = True

    def at_repeat(self):
        "called every hour"
        #print "ValidateScripts run."
        ScriptDB.objects.validate()


class ValidateChannelHandler(Script):
    "Update the channelhandler to make sure it's in sync."
    def at_script_creation(self):
        "Setup the script"
        self.key = "sys_channels_validate"
        self.desc = _("Updates the channel handler")
        self.interval = 3700  # validate a little later than ValidateScripts
        self.persistent = True

    def at_repeat(self):
        "called every hour+"
        #print "ValidateChannelHandler run."
        channelhandler.CHANNELHANDLER.update()


########NEW FILE########
__FILENAME__ = tickerhandler
"""
TickerHandler

This implements an efficient Ticker which uses a subscription
model to 'tick' subscribed objects at regular intervals.

The ticker mechanism is used by importing and accessing
the instantiated TICKER_HANDLER instance in this module. This
instance is run by the server; it will save its status across
server reloads and be started automaticall on boot.

Example:

    from src.scripts.tickerhandler import TICKER_HANDLER

    # tick myobj every 15 seconds
    TICKER_HANDLER.add(myobj, 15)

The handler will by default try to call a hook "at_tick()"
on the subscribing object. The hook's name can be changed
if the "hook_key" keyword is given to the add() method (only
one such alternate name per interval though). The
handler will transparently set up and add new timers behind
the scenes to tick at given intervals, using a TickerPool.

To remove:

    TICKER_HANDLER.remove(myobj, 15)

The interval must be given since a single object can be subcribed
to many different tickers at the same time.


The TickerHandler's functionality can be overloaded by modifying the
Ticker class and then changing TickerPool and TickerHandler to use the
custom classes

class MyTicker(Ticker):
    # [doing custom stuff]

class MyTickerPool(TickerPool):
    ticker_class = MyTicker
class MyTickerHandler(TickerHandler):
    ticker_pool_class = MyTickerPool

If one wants to duplicate TICKER_HANDLER's auto-saving feature in
a  custom handler one can make a custom AT_STARTSTOP_MODULE entry to
call the handler's save() and restore() methods when the server reboots.

"""
from twisted.internet.defer import inlineCallbacks
from src.scripts.scripts import ExtendedLoopingCall
from src.server.models import ServerConfig
from src.utils.logger import log_trace
from src.utils.dbserialize import dbserialize, dbunserialize, pack_dbobj, unpack_dbobj

_GA = object.__getattribute__
_SA = object.__setattr__


class Ticker(object):
    """
    Represents a repeatedly running task that calls
    hooks repeatedly. Overload _callback to change the
    way it operates.
    """

    @inlineCallbacks
    def _callback(self):
        """
        This will be called repeatedly every self.interval seconds.
        self.subscriptions contain tuples of (obj, args, kwargs) for
        each subscribing object.

        If overloading, this callback is expected to handle all
        subscriptions when it is triggered. It should not return
        anything and should not traceback on poorly designed hooks.
        The callback should ideally work under @inlineCallbacks so it can yield
        appropriately.
        """
        for key, (obj, args, kwargs) in self.subscriptions.items():
            hook_key = yield kwargs.get("hook_key", "at_tick")
            try:
                yield _GA(obj, hook_key)(*args, **kwargs)
            except Exception:
                log_trace()

    def __init__(self, interval):
        """
        Set up the ticker
        """
        self.interval = interval
        self.subscriptions = {}
        # set up a twisted asynchronous repeat call
        self.task = ExtendedLoopingCall(self._callback)

    def validate(self, start_delay=None):
        """
        Start/stop the task depending on how many
        subscribers we have using it.
        """
        subs = self.subscriptions
        if None in subs.values():
            # clean out objects that may have been deleted
            subs = dict((store_key, obj) for store_key, obj in subs if obj)
            self.subscriptions = subs
        if self.task.running:
            if not subs:
                self.task.stop()
        elif subs:
            print "starting with start_delay=", start_delay
            self.task.start(self.interval, now=False, start_delay=start_delay)

    def add(self, store_key, obj, *args, **kwargs):
        """
        Sign up a subscriber to this ticker. If kwargs contains
        a keyword _start_delay, this will be used to delay the start
        of the trigger instead of interval.
        """
        start_delay = kwargs.pop("_start_delay", None)
        self.subscriptions[store_key] = (obj, args, kwargs)
        self.validate(start_delay=start_delay)

    def remove(self, store_key):
        """
        Unsubscribe object from this ticker
        """
        self.subscriptions.pop(store_key, False)
        self.validate()

    def stop(self):
        """
        Kill the Task, regardless of subscriptions
        """
        self.subscriptions = {}
        self.validate()


class TickerPool(object):
    """
    This maintains a pool of Twisted LoopingCall tasks
    for calling subscribed objects at given times.
    """
    ticker_class = Ticker

    def __init__(self):
        "Initialize the pool"
        self.tickers = {}

    def add(self, store_key, obj, interval, *args, **kwargs):
        """
        Add new ticker subscriber
        """
        if interval not in self.tickers:
            self.tickers[interval] = self.ticker_class(interval)
        self.tickers[interval].add(store_key, obj, *args, **kwargs)

    def remove(self, store_key, interval):
        """
        Remove subscription from pool
        """
        if interval in self.tickers:
            self.tickers[interval].remove(store_key)

    def stop(self, interval=None):
        """
        Stop all scripts in pool. This is done at server reload since
        restoring the pool will automatically re-populate the pool.
        If interval is given, only stop tickers with that interval.
        """
        if interval and interval in self.tickers:
            self.tickers[interval].stop()
        else:
            for ticker in self.tickers.values():
                ticker.stop()

class TickerHandler(object):
    """
    The Tickerhandler maintains a pool of tasks for subscribing
    objects to various tick rates.  The pool maintains creation
    instructions and and re-applies them at a server restart.
    """
    ticker_pool_class = TickerPool

    def __init__(self, save_name="ticker_storage"):
        """
        Initialize handler
        """
        self.ticker_storage = {}
        self.save_name = save_name
        self.ticker_pool = self.ticker_pool_class()

    def _store_key(self, obj, interval):
        """
        Tries to create a store_key for the object.
        Returns a tuple (isdb, store_key) where isdb
        is a boolean True if obj was a database object,
        False otherwise.
        """
        try:
            obj = obj.typeclass
        except AttributeError:
            pass
        dbobj = None
        try:
            dbobj = obj.dbobj
        except AttributeError:
            pass
        isdb = True
        if dbobj:
            # create a store_key using the database representation
            objkey = pack_dbobj(dbobj)
        else:
            # non-db object, look for a property "key" on it, otherwise
            # use its memory location.
            try:
                objkey = _GA(obj, "key")
            except AttributeError:
                objkey = id(obj)
            isdb = False
        # return sidb and store_key
        return isdb, (objkey, interval)

    def save(self):
        """
        Save ticker_storage as a serialized string into a temporary
        ServerConf field. Whereas saving is done on the fly, if called by
        server when it shuts down, the current timer of each ticker will be
        saved so it can start over from that point.
        """
        if self.ticker_storage:
            start_delays = dict((interval, ticker.task.next_call_time())
                                 for interval, ticker in self.ticker_pool.tickers.items())
            # update the timers for the tickers
            for (obj, interval), (args, kwargs) in self.ticker_storage.items():
                kwargs["_start_delay"] = start_delays.get(interval, None)

            ServerConfig.objects.conf(key=self.save_name,
                                    value=dbserialize(self.ticker_storage))
        else:
            ServerConfig.objects.conf(key=self.save_name, delete=True)

    def restore(self):
        """
        Restore ticker_storage from database and re-initialize the handler from storage. This is triggered by the server at restart.
        """
        # load stored command instructions and use them to re-initialize handler
        ticker_storage = ServerConfig.objects.conf(key=self.save_name)
        if ticker_storage:
            self.ticker_storage = dbunserialize(ticker_storage)
            #print "restore:", self.ticker_storage
            for (obj, interval), (args, kwargs) in self.ticker_storage.items():
                obj = unpack_dbobj(obj)
                _, store_key = self._store_key(obj, interval)
                self.ticker_pool.add(store_key, obj, interval, *args, **kwargs)

    def add(self, obj, interval, *args, **kwargs):
        """
        Add object to tickerhandler. The object must have an at_tick
        method. This will be called every interval seconds until the
        object is unsubscribed from the ticker.
        """
        isdb, store_key = self._store_key(obj, interval)
        if isdb:
            self.ticker_storage[store_key] = (args, kwargs)
            self.save()
        self.ticker_pool.add(store_key, obj, interval, *args, **kwargs)

    def remove(self, obj, interval):
        """
        Remove object from ticker with given interval.
        """
        isdb, store_key = self._store_key(obj, interval)
        if isdb:
            self.ticker_storage.pop(store_key, None)
            self.save()
        self.ticker_pool.remove(store_key, interval)

    def clear(self, interval=None):
        """
        Stop/remove all tickers from handler, or the ones
        with a given interval. This is the only supported
        way to kill tickers for non-db objects. If interval
        is given, only stop tickers with this interval.
        """
        self.ticker_pool.stop(interval)
        if interval:
            self.ticker_storage = dict((store_key, store_key) for store_key in self.ticker_storage if store_key[1] != interval)
        else:
            self.ticker_storage = {}
        self.save()

    def all(self, interval=None):
        """
        Get the subsciptions for a given interval. If interval
        is not given, return a dictionary with lists for every
        interval in the tickerhandler.
        """
        if interval is None:
            # return dict of all, ordered by interval
            return dict((interval, ticker.subscriptions.values())
                         for interval, ticker in self.ticker_pool.tickers.items())
        else:
            # get individual interval
            ticker = self.ticker_pool.tickers.get(interval, None)
            if ticker:
                return ticker.subscriptions.values()

# main tickerhandler
TICKER_HANDLER = TickerHandler()

########NEW FILE########
__FILENAME__ = admin
#
# This sets up how models are displayed
# in the web admin interface.
#

from django.contrib import admin
from src.server.models import ServerConfig


class ServerConfigAdmin(admin.ModelAdmin):
    "Custom admin for server configs"
    list_display = ('db_key', 'db_value')
    list_display_links = ('db_key',)
    ordering = ['db_key', 'db_value']
    search_fields = ['db_key']
    save_as = True
    save_on_top = True
    list_select_related = True
admin.site.register(ServerConfig, ServerConfigAdmin)

########NEW FILE########
__FILENAME__ = amp
"""
Contains the protocols, commands, and client factory needed for the Server
and Portal to communicate with each other, letting Portal work as a proxy.
Both sides use this same protocol.

The separation works like this:

Portal - (AMP client) handles protocols. It contains a list of connected
         sessions in a dictionary for identifying the respective player
         connected. If it looses the AMP connection it will automatically
         try to reconnect.

Server - (AMP server) Handles all mud operations. The server holds its own list
         of sessions tied to player objects. This is synced against the portal
         at startup and when a session connects/disconnects

"""

# imports needed on both server and portal side
import os
from collections import defaultdict
try:
    import cPickle as pickle
except ImportError:
    import pickle
from twisted.protocols import amp
from twisted.internet import protocol
from twisted.internet.defer import Deferred
from src.utils.utils import to_str, variable_from_module

# communication bits

PCONN = chr(1)        # portal session connect
PDISCONN = chr(2)     # portal session disconnect
PSYNC = chr(3)        # portal session sync
SLOGIN = chr(4)       # server session login
SDISCONN = chr(5)     # server session disconnect
SDISCONNALL = chr(6)  # server session disconnect all
SSHUTD = chr(7)       # server shutdown
SSYNC = chr(8)        # server session sync
SCONN = chr(9)        # server creating new connectiong (for irc/imc2 bots etc)

MAXLEN = 65535  # max allowed data length in AMP protocol
_MSGBUFFER = defaultdict(list)

def get_restart_mode(restart_file):
    """
    Parse the server/portal restart status
    """
    if os.path.exists(restart_file):
        flag = open(restart_file, 'r').read()
        return flag == "True"
    return False


class AmpServerFactory(protocol.ServerFactory):
    """
    This factory creates the Server as a new AMPProtocol instance for accepting
    connections from the Portal.
    """
    def __init__(self, server):
        """
        server: The Evennia server service instance
        protocol: The protocol the factory creates instances of.
        """
        self.server = server
        self.protocol = AMPProtocol

    def buildProtocol(self, addr):
        """
        Start a new connection, and store it on the service object
        """
        #print "Evennia Server connected to Portal at %s." % addr
        self.server.amp_protocol = AMPProtocol()
        self.server.amp_protocol.factory = self
        return self.server.amp_protocol


class AmpClientFactory(protocol.ReconnectingClientFactory):
    """
    This factory creates an instance of the Portal, an AMPProtocol
    instances to use to connect
    """
    # Initial reconnect delay in seconds.
    initialDelay = 1
    factor = 1.5
    maxDelay = 1

    def __init__(self, portal):
        self.portal = portal
        self.protocol = AMPProtocol

    def startedConnecting(self, connector):
        """
        Called when starting to try to connect to the MUD server.
        """
        pass
        #print 'AMP started to connect:', connector

    def buildProtocol(self, addr):
        """
        Creates an AMPProtocol instance when connecting to the server.
        """
        #print "Portal connected to Evennia server at %s." % addr
        self.resetDelay()
        self.portal.amp_protocol = AMPProtocol()
        self.portal.amp_protocol.factory = self
        return self.portal.amp_protocol

    def clientConnectionLost(self, connector, reason):
        """
        Called when the AMP connection to the MUD server is lost.
        """
        if hasattr(self, "server_restart_mode"):
            self.maxDelay = 1
        else:
            # Don't translate this; avoid loading django on portal side.
            self.maxDelay = 10
            self.portal.sessions.announce_all(" ... Portal lost connection to Server.")
        protocol.ReconnectingClientFactory.clientConnectionLost(self, connector, reason)

    def clientConnectionFailed(self, connector, reason):
        """
        Called when an AMP connection attempt to the MUD server fails.
        """
        if hasattr(self, "server_restart_mode"):
            self.maxDelay = 1
        else:
            self.maxDelay = 10
        self.portal.sessions.announce_all(" ...")
        protocol.ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)


# AMP Communication Command types

class MsgPortal2Server(amp.Command):
    """
    Message portal -> server
    """
    key = "MsgPortal2Server"
    arguments = [('sessid', amp.Integer()),
                 ('ipart', amp.Integer()),
                 ('nparts', amp.Integer()),
                 ('msg', amp.String()),
                 ('data', amp.String())]
    errors = [(Exception, 'EXCEPTION')]
    response = []


class MsgServer2Portal(amp.Command):
    """
    Message server -> portal
    """
    key = "MsgServer2Portal"
    arguments = [('sessid', amp.Integer()),
                 ('ipart', amp.Integer()),
                 ('nparts', amp.Integer()),
                 ('msg', amp.String()),
                 ('data', amp.String())]
    errors = [(Exception, 'EXCEPTION')]
    response = []


class ServerAdmin(amp.Command):
    """
    Portal -> Server

    Sent when the portal needs to perform admin
     operations on the server, such as when a new
     session connects or resyncs
    """
    key = "ServerAdmin"
    arguments = [('sessid', amp.Integer()),
                 ('ipart', amp.Integer()),
                 ('nparts', amp.Integer()),
                 ('operation', amp.String()),
                 ('data', amp.String())]
    errors = [(Exception, 'EXCEPTION')]
    response = []


class PortalAdmin(amp.Command):
    """
    Server -> Portal

    Sent when the server needs to perform admin
     operations on the portal.
    """
    key = "PortalAdmin"
    arguments = [('sessid', amp.Integer()),
                 ('ipart', amp.Integer()),
                 ('nparts', amp.Integer()),
                 ('operation', amp.String()),
                 ('data', amp.String())]
    errors = [(Exception, 'EXCEPTION')]
    response = []


class FunctionCall(amp.Command):
    """
    Bidirectional

    Sent when either process needs to call an
    arbitrary function in the other.
    """
    key = "FunctionCall"
    arguments = [('module', amp.String()),
                 ('function', amp.String()),
                 ('args', amp.String()),
                 ('kwargs', amp.String())]
    errors = [(Exception, 'EXCEPTION')]
    response = [('result', amp.String())]


# Helper functions

dumps = lambda data: to_str(pickle.dumps(data, pickle.HIGHEST_PROTOCOL))
loads = lambda data: pickle.loads(to_str(data))

# multipart message store



#------------------------------------------------------------
# Core AMP protocol for communication Server <-> Portal
#------------------------------------------------------------

class AMPProtocol(amp.AMP):
    """
    This is the protocol that the MUD server and the proxy server
    communicate to each other with. AMP is a bi-directional protocol, so
    both the proxy and the MUD use the same commands and protocol.

    AMP specifies responder methods here and connect them to amp.Command
    subclasses that specify the datatypes of the input/output of these methods.
    """

    # helper methods

    def connectionMade(self):
        """
        This is called when a connection is established
        between server and portal. AMP calls it on both sides,
        so we need to make sure to only trigger resync from the
        portal side.
        """
        if hasattr(self.factory, "portal"):
            # only the portal has the 'portal' property, so we know we are
            # on the portal side and can initialize the connection.
            sessdata = self.factory.portal.sessions.get_all_sync_data()
            self.call_remote_ServerAdmin(0,
                                         PSYNC,
                                         data=sessdata)
            self.factory.portal.sessions.at_server_connection()
            if hasattr(self.factory, "server_restart_mode"):
                del self.factory.server_restart_mode

    # Error handling

    def errback(self, e, info):
        "error handler, to avoid dropping connections on server tracebacks."
        f = e.trap(Exception)
        print "AMP Error for %(info)s: %(e)s" % {'info': info,
                                                 'e': e.getErrorMessage()}

    def safe_send(self, command, sessid, **kwargs):
        """
        This helper method splits the sending of a message into
        multiple parts with a maxlength of MAXLEN. This is to avoid
        repetition in two sending commands. when calling this the
        maximum length has already been exceeded.  The max-length will
        be checked for all kwargs and these will be used as argument
        to the command. The command type must have keywords ipart and
        nparts to track the parts and put them back together on the
        other side.

        Returns a deferred or a list of such
        """
        to_send = [(key, [string[i:i+MAXLEN] for i in range(0, len(string), MAXLEN)])
                          for key, string in kwargs.items()]
        nparts_max = max(len(part[1]) for part in to_send)
        if nparts_max == 1:
            # first try to send directly
            return self.callRemote(command,
                                   sessid=sessid,
                                   ipart=0,
                                   nparts=1,
                                   **kwargs).addErrback(self.errback, command.key)
        else:
            # one or more parts were too long for MAXLEN.
            #print "TooLong triggered!"
            deferreds = []
            for ipart in range(nparts_max):
                part_kwargs = {}
                for key, str_part in to_send:
                    try:
                        part_kwargs[key] = str_part[ipart]
                    except IndexError:
                        # means this kwarg needed fewer splits
                        part_kwargs[key] = ""
                # send this part
                #print "amp safe sending:", ipart, nparts_max, str_part
                deferreds.append(self.callRemote(
                                 command,
                                 sessid=sessid,
                                 ipart=ipart,
                                 nparts=nparts_max,
                                 **part_kwargs).addErrback(self.errback, command.key))
            return deferreds

    def safe_recv(self, command, sessid, ipart, nparts, **kwargs):
        """
        Safely decode potentially split data coming over the wire. No
        decoding or parsing is done here, only merging of data split
        with safe_send().
        If the data stream is not yet complete, this method will return
        None, otherwise it will return a dictionary of the (possibly
        merged) properties.
        """
        global _MSGBUFFER
        if nparts == 1:
            # the most common case
            return kwargs
        else:
            # part of a multi-part send
            hashid = "%s_%s" % (command.key, sessid)
            #print "amp safe receive:", ipart, nparts-1, kwargs
            if ipart < nparts-1:
                # not yet complete
                _MSGBUFFER[hashid].append(kwargs)
                return
            else:
                # all parts in place, put them back together
                buf = _MSGBUFFER.pop(hashid) + [kwargs]
                recv_kwargs = dict((key, "".join(kw[key] for kw in buf)) for key in kwargs)
                return recv_kwargs

    # Message definition + helper methods to call/create each message type

    # Portal -> Server Msg

    def amp_msg_portal2server(self, sessid, ipart, nparts, msg, data):
        """
        Relays message to server. This method is executed on the Server.

        Since AMP has a limit of 65355 bytes per message, it's possible the
        data comes in multiple chunks; if so (nparts>1) we buffer the data
        and wait for the remaining parts to arrive before continuing.
        """
        #print "msg portal -> server (server side):", sessid, msg, data
        ret = self.safe_recv(MsgPortal2Server, sessid, ipart, nparts,
                                                        text=msg, data=data)
        if ret is not None:
            self.factory.server.sessions.data_in(sessid,
                                                 text=ret["text"],
                                                 **loads(ret["data"]))
        return {}
    MsgPortal2Server.responder(amp_msg_portal2server)

    def call_remote_MsgPortal2Server(self, sessid, msg, data=""):
        """
        Access method called by the Portal and executed on the Portal.
        """
        #print "msg portal->server (portal side):", sessid, msg, data
        return self.safe_send(MsgPortal2Server, sessid,
                              msg=to_str(msg) if msg is not None else "",
                              data=dumps(data))

    # Server -> Portal message

    def amp_msg_server2portal(self, sessid, ipart, nparts, msg, data):
        """
        Relays message to Portal. This method is executed on the Portal.
        """
        #print "msg server->portal (portal side):", sessid, msg
        ret = self.safe_recv(MsgServer2Portal, sessid,
                             ipart, nparts, text=msg, data=data)
        if ret is not None:
            self.factory.portal.sessions.data_out(sessid,
                                                  text=ret["text"],
                                                  **loads(ret["data"]))
        return {}
    MsgServer2Portal.responder(amp_msg_server2portal)

    def call_remote_MsgServer2Portal(self, sessid, msg, data=""):
        """
        Access method called by the Server and executed on the Server.
        """
        #print "msg server->portal (server side):", sessid, msg, data
        return self.safe_send(MsgServer2Portal, sessid,
                              msg=to_str(msg) if msg is not None else "",
                              data=dumps(data))

    # Server administration from the Portal side
    def amp_server_admin(self, sessid, ipart, nparts, operation, data):
        """
        This allows the portal to perform admin
        operations on the server.  This is executed on the Server.

        """
        ret = self.safe_recv(ServerAdmin, sessid, ipart, nparts,
                             operation=operation, data=data)

        if ret is not None:
            data = loads(ret["data"])
            operation = ret["operation"]
            server_sessionhandler = self.factory.server.sessions

            #print "serveradmin (server side):", sessid, ord(operation), data

            if operation == PCONN:  # portal_session_connect
                # create a new session and sync it
                server_sessionhandler.portal_connect(data)

            elif operation == PDISCONN:  # portal_session_disconnect
                # session closed from portal side
                self.factory.server.sessions.portal_disconnect(sessid)

            elif operation == PSYNC:  # portal_session_sync
                # force a resync of sessions when portal reconnects to
                # server (e.g. after a server reboot) the data kwarg
                # contains a dict {sessid: {arg1:val1,...}}
                # representing the attributes to sync for each
                # session.
                server_sessionhandler.portal_session_sync(data)
            else:
                raise Exception("operation %(op)s not recognized." % {'op': operation})
        return {}
    ServerAdmin.responder(amp_server_admin)

    def call_remote_ServerAdmin(self, sessid, operation="", data=""):
        """
        Access method called by the Portal and Executed on the Portal.
        """
        #print "serveradmin (portal side):", sessid, ord(operation), data
        data = dumps(data)
        return self.safe_send(ServerAdmin, sessid, operation=operation, data=data)

    # Portal administraton from the Server side

    def amp_portal_admin(self, sessid, ipart, nparts, operation, data):
        """
        This allows the server to perform admin
        operations on the portal. This is executed on the Portal.
        """
        #print "portaladmin (portal side):", sessid, ord(operation), data
        ret = self.safe_recv(PortalAdmin, sessid, ipart, nparts,
                             operation=operation, data=data)
        if ret is not None:
            data = loads(data)
            portal_sessionhandler = self.factory.portal.sessions

            if operation == SLOGIN:  # server_session_login
                # a session has authenticated; sync it.
                portal_sessionhandler.server_logged_in(sessid, data)

            elif operation == SDISCONN:  # server_session_disconnect
                # the server is ordering to disconnect the session
                portal_sessionhandler.server_disconnect(sessid, reason=data)

            elif operation == SDISCONNALL:  # server_session_disconnect_all
                # server orders all sessions to disconnect
                portal_sessionhandler.server_disconnect_all(reason=data)

            elif operation == SSHUTD:  # server_shutdown
                # the server orders the portal to shut down
                self.factory.portal.shutdown(restart=False)

            elif operation == SSYNC:  # server_session_sync
                # server wants to save session data to the portal,
                # maybe because it's about to shut down.
                portal_sessionhandler.server_session_sync(data)
                # set a flag in case we are about to shut down soon
                self.factory.server_restart_mode = True

            elif operation == SCONN: # server_force_connection (for irc/imc2 etc)
                portal_sessionhandler.server_connect(**data)

            else:
                raise Exception("operation %(op)s not recognized." % {'op': operation})
        return {}
    PortalAdmin.responder(amp_portal_admin)

    def call_remote_PortalAdmin(self, sessid, operation="", data=""):
        """
        Access method called by the server side.
        """
        self.safe_send(PortalAdmin, sessid, operation=operation, data=dumps(data))

    # Extra functions

    def amp_function_call(self, module, function, args, **kwargs):
        """
        This allows Portal- and Server-process to call an arbitrary function
        in the other process. It is intended for use by plugin modules.
        """
        args = loads(args)
        kwargs = loads(kwargs)

        # call the function (don't catch tracebacks here)
        result = variable_from_module(module, function)(*args, **kwargs)

        if isinstance(result, Deferred):
            # if result is a deferred, attach handler to properly
            # wrap the return value
            result.addCallback(lambda r: {"result": dumps(r)})
            return result
        else:
            return {'result': dumps(result)}
    FunctionCall.responder(amp_function_call)

    def call_remote_FunctionCall(self, modulepath, functionname, *args, **kwargs):
        """
        Access method called by either process. This will call an arbitrary
        function on the other process (On Portal if calling from Server and
        vice versa).

        Inputs:
            modulepath (str) - python path to module holding function to call
            functionname (str) - name of function in given module
            *args, **kwargs will be used as arguments/keyword args for the
                            remote function call
        Returns:
            A deferred that fires with the return value of the remote
            function call
        """
        return self.callRemote(FunctionCall,
                               module=modulepath,
                               function=functionname,
                               args=dumps(args),
                               kwargs=dumps(kwargs)).addCallback(lambda r: loads(r["result"])).addErrback(self.errback, "FunctionCall")

########NEW FILE########
__FILENAME__ = caches
"""
Central caching module.

"""

from sys import getsizeof
import os
import threading
from collections import defaultdict

from src.server.models import ServerConfig
from src.utils.utils import uses_database, to_str, get_evennia_pids

_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__

_IS_SUBPROCESS = os.getpid() in get_evennia_pids()
_IS_MAIN_THREAD = threading.currentThread().getName() == "MainThread"

#
# Set up the cache stores
#

_ATTR_CACHE = {}
_PROP_CACHE = defaultdict(dict)

#------------------------------------------------------------
# Cache key hash generation
#------------------------------------------------------------

if uses_database("mysql") and ServerConfig.objects.get_mysql_db_version() < '5.6.4':
    # mysql <5.6.4 don't support millisecond precision
    _DATESTRING = "%Y:%m:%d-%H:%M:%S:000000"
else:
    _DATESTRING = "%Y:%m:%d-%H:%M:%S:%f"


def hashid(obj, suffix=""):
    """
    Returns a per-class unique hash that combines the object's
    class name with its idnum and creation time. This makes this id unique also
    between different typeclassed entities such as scripts and
    objects (which may still have the same id).
    """
    if not obj:
        return obj
    try:
        hid = _GA(obj, "_hashid")
    except AttributeError:
        try:
            date, idnum = _GA(obj, "db_date_created").strftime(_DATESTRING), _GA(obj, "id")
        except AttributeError:
            try:
                # maybe a typeclass, try to go to dbobj
                obj = _GA(obj, "dbobj")
                date, idnum = _GA(obj, "db_date_created").strftime(_DATESTRING), _GA(obj, "id")
            except AttributeError:
                # this happens if hashing something like ndb. We have to
                # rely on memory adressing in this case.
                date, idnum = "InMemory", id(obj)
        if not idnum or not date:
            # this will happen if setting properties on an object which
            # is not yet saved
            return None
        # we have to remove the class-name's space, for eventual use
        # of memcached
        hid = "%s-%s-#%s" % (_GA(obj, "__class__"), date, idnum)
        hid = hid.replace(" ", "")
        # we cache the object part of the hashid to avoid too many
        # object lookups
        _SA(obj, "_hashid", hid)
    # build the complete hashid
    hid = "%s%s" % (hid, suffix)
    return to_str(hid)


#------------------------------------------------------------
# Cache callback handlers
#------------------------------------------------------------

# callback to field pre_save signal (connected in src.server.server)
def field_pre_save(sender, instance=None, update_fields=None, raw=False, **kwargs):
    """
    Called at the beginning of the field save operation. The save method
    must be called with the update_fields keyword in order to be most efficient.
    This method should NOT save; rather it is the save() that triggers this
    function. Its main purpose is to allow to plug-in a save handler and oob
    handlers.
    """
    if raw:
        return
    if update_fields:
        # this is a list of strings at this point. We want field objects
        update_fields = (_GA(_GA(instance, "_meta"), "get_field_by_name")(field)[0] for field in update_fields)
    else:
        # meta.fields are already field objects; get them all
        update_fields = _GA(_GA(instance, "_meta"), "fields")
    for field in update_fields:
        fieldname = field.name
        handlername = "_at_%s_presave" % fieldname
        handler = _GA(instance, handlername) if handlername in _GA(sender, '__dict__') else None
        if callable(handler):
            handler()


def field_post_save(sender, instance=None, update_fields=None, raw=False, **kwargs):
    """
    Called at the beginning of the field save operation. The save method
    must be called with the update_fields keyword in order to be most efficient.
    This method should NOT save; rather it is the save() that triggers this
    function. Its main purpose is to allow to plug-in a save handler and oob
    handlers.
    """
    if raw:
        return
    if update_fields:
        # this is a list of strings at this point. We want field objects
        update_fields = (_GA(_GA(instance, "_meta"), "get_field_by_name")(field)[0] for field in update_fields)
    else:
        # meta.fields are already field objects; get them all
        update_fields = _GA(_GA(instance, "_meta"), "fields")
    for field in update_fields:
        fieldname = field.name
        handlername = "_at_%s_postsave" % fieldname
        handler = _GA(instance, handlername) if handlername in _GA(sender, '__dict__') else None
        if callable(handler):
            handler()
        trackerhandler = _GA(instance, "_trackerhandler") if "_trackerhandler" in _GA(instance, '__dict__') else None
        if trackerhandler:
            trackerhandler.update(fieldname, _GA(instance, fieldname))

#------------------------------------------------------------
# Attribute lookup cache
#------------------------------------------------------------

def get_attr_cache(obj):
    "Retrieve lookup cache"
    hid = hashid(obj)
    return _ATTR_CACHE.get(hid, None)


def set_attr_cache(obj, store):
    "Set lookup cache"
    global _ATTR_CACHE
    hid = hashid(obj)
    _ATTR_CACHE[hid] = store

#------------------------------------------------------------
# Property cache - this is a generic cache for properties stored on models.
#------------------------------------------------------------

# access methods

def get_prop_cache(obj, propname):
    "retrieve data from cache"
    hid = hashid(obj, "-%s" % propname)
    return _PROP_CACHE[hid].get(propname, None) if hid else None


def set_prop_cache(obj, propname, propvalue):
    "Set property cache"
    hid = hashid(obj, "-%s" % propname)
    if hid:
        _PROP_CACHE[hid][propname] = propvalue


def del_prop_cache(obj, propname):
    "Delete element from property cache"
    hid = hashid(obj, "-%s" % propname)
    if hid:
        if propname in _PROP_CACHE[hid]:
            del _PROP_CACHE[hid][propname]


def flush_prop_cache():
    "Clear property cache"
    global _PROP_CACHE
    _PROP_CACHE = defaultdict(dict)


def get_cache_sizes():
    """
    Get cache sizes, expressed in number of objects and memory size in MB
    """
    global _ATTR_CACHE, _PROP_CACHE
    attr_n = len(_ATTR_CACHE)
    attr_mb = sum(getsizeof(obj) for obj in _ATTR_CACHE) / 1024.0
    prop_n = sum(len(dic) for dic in _PROP_CACHE.values())
    prop_mb = sum(sum([getsizeof(obj) for obj in dic.values()]) for dic in _PROP_CACHE.values()) / 1024.0
    return (attr_n, attr_mb), (prop_n, prop_mb)



########NEW FILE########
__FILENAME__ = manager
"""
Custom manager for ServerConfig objects.
"""
from django.db import models


class ServerConfigManager(models.Manager):
    """
    This ServerConfigManager implements methods for searching
    and manipulating ServerConfigs directly from the database.

    These methods will all return database objects
    (or QuerySets) directly.

    ServerConfigs are used to store certain persistent settings for the
    server at run-time.

    Evennia-specific:
    conf

    """
    def conf(self, key=None, value=None, delete=False, default=None):
        """
        Access and manipulate config values
        """
        if not key:
            return self.all()
        elif delete is True:
            for conf in self.filter(db_key=key):
                conf.delete()
        elif value is not None:
            conf = self.filter(db_key=key)
            if conf:
                conf = conf[0]
            else:
                conf = self.model(db_key=key)
            conf.value = value  # this will pickle
        else:
            conf = self.filter(db_key=key)
            if not conf:
                return default
            return conf[0].value

    def get_mysql_db_version(self):
        """
        This is a helper method for getting the version string
        of a mysql database.
        """
        from django.db import connection
        conn = connection.cursor()
        conn.execute("SELECT VERSION()")
        version = conn.fetchone()
        return version and str(version[0]) or ""

########NEW FILE########
__FILENAME__ = 0001_rename_config_table_to_server_table
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models, utils
import pickle

HAS_CONFIGVAL = True
try: from src.server.models import ConfigValue
except ImportError: HAS_CONFIGVAL = False
HAS_SERVERCONF = True
try: from src.server.models import ServerConfig
except ImportError: HAS_SERVERCONF = False

class Migration(SchemaMigration):

    no_dry_run = True
    def forwards(self, orm):
        if HAS_CONFIGVAL:# and not HAS_SERVERCONF:
            # this means we have to rename the old one
            db.rename_table("config_configvalue", "server_serverconfig")
            for conf in orm.ServerConfig.objects.all():
                conf.db_value = pickle.dumps(conf.db_value)
                conf.save()
        else:# not HAS_SERVERCONF:
            # this will happen if we start db from scratch (the config
            # app will then already be gone and no data is to be transferred)
            # So instead of renaming the old we instead have to manually create the new model.
            # Adding model 'ServerConfig'
            db.create_table('server_serverconfig', (
                    ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                    ('db_key', self.gf('django.db.models.fields.CharField')(unique=True, max_length=64)),
                    ('db_value', self.gf('django.db.models.fields.TextField')(blank=True)),
                    ))
            db.send_create_signal('server', ['ServerConfig'])

    def backwards(self, orm):
        raise RuntimeError("This migration cannot be reversed.")

    models = {
        'config.configvalue': {
            'Meta': {'object_name': 'ConfigValue'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'}),
            'db_value': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'server.serverconfig': {
            'Meta': {'object_name': 'ServerConfig'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'db_value': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['config', 'server']

########NEW FILE########
__FILENAME__ = 0002_fix_config_value
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, utils
import pickle 


class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        
        # we are fixing a situation were the serverconfig value last_initial_setup_step was left at 1 instead of -1
        # as it should (due to a bug in the setter). This causes db errors as the initial_setup thinks it needs to 
        # run again. 
        
        try:
            if orm['objects.ObjectDB'].objects.filter(id=1) and orm["objects.ObjectDB"].objects.filter(id=2):
                # only an issue the critical objects have already been created
                conf = orm.ServerConfig.objects.filter(db_key="last_initial_setup_step")
                if conf:
                    conf = conf[0]
                    if pickle.loads(str(conf.db_value)) == 1:
                        # this shouldn't be 1 if objects already exists. This is the bug. Fix the error.
                        conf.db_value = pickle.dumps(-1)
                        conf.save()
        except utils.DatabaseError:
            # this will happen if we start the db from scratch (in which case this migration fix is not needed)
            db.commit_transaction()
            db.start_transaction()
            pass


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.nick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'Nick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']"}),
            'db_value': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': "orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['objects.ObjectDB']", 'null': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']", 'unique': 'True'})
        },
        'server.serverconfig': {
            'Meta': {'object_name': 'ServerConfig'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'db_value': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects', 'server']

########NEW FILE########
__FILENAME__ = 0003_add_tmpattr
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'TmpAttribute'
        db.create_table(u'server_tmpattribute', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_value', self.gf('src.utils.picklefield.PickledObjectField')(null=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_obj_id', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('db_obj_type', self.gf('django.db.models.fields.CharField')(max_length=10, null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(editable=True, auto_now_add=False)),
        ))
        db.send_create_signal('server', ['TmpAttribute'])


    def backwards(self, orm):
        # Deleting model 'TmpAttribute'
        db.delete_table(u'server_tmpattribute')


    models = {
        u'server.serverconfig': {
            'Meta': {'object_name': 'ServerConfig'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'db_value': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'server.tmpattribute': {
            'Meta': {'object_name': 'TmpAttribute'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj_id': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_obj_type': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'db_date_created':('django.db.models.fields.DateTimeField',[],{'editable':'True', 'auto_now_add':'True'}),
        }
    }

    complete_apps = ['server']

########NEW FILE########
__FILENAME__ = 0004_store_all_attrs
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
#from src.utils.dbserialize import to_pickle, from_pickle

class Migration(DataMigration):
    "Store all attributes in a temporary table"
    depends_on = (('objects', '0020_remove_old_attr_value_field'),
                  ('players','0019_remove_old_attr_value_field'),
                  ('scripts','0012_remove_old_attr_value_field'))
    no_dry_run = True
    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        # store ObjectAttributes
        for attrobj in orm['objects.ObjAttribute'].objects.all():
            #value = from_pickle(attrobj.db_value, db_obj=attrobj)
            new_attr = orm['server.TmpAttribute'](db_key=attrobj.db_key,
                                                  db_value=attrobj.db_value,
                                                  db_lock_storage=attrobj.db_lock_storage,
                                                  db_obj_id=attrobj.db_obj.id,
                                                  db_obj_type="objectdb",
                                                  db_date_created=attrobj.db_date_created)
            new_attr.save()
            #new_attr.db_value = to_pickle(value)
            #new_attr.save()

        # store PlayerAttributes
        for attrobj in orm['players.PlayerAttribute'].objects.all():
            #value = from_pickle(attrobj.db_value, db_obj=attrobj)
            new_attr = orm['server.TmpAttribute'](db_key=attrobj.db_key,
                                                  db_value=attrobj.db_value,
                                                  db_lock_storage=attrobj.db_lock_storage,
                                                  db_obj_id=attrobj.db_obj.id,
                                                  db_obj_type="playerdb",
                                                  db_date_created=attrobj.db_date_created)
            new_attr.save()
            #new_attr.db_value = to_pickle(value)
            #new_attr.save()

        # store ScriptAttributes
        for attrobj in orm['scripts.ScriptAttribute'].objects.all():
            #value = from_pickle(attrobj.db_value, db_obj=attrobj)
            new_attr = orm['server.TmpAttribute'](db_key=attrobj.db_key,
                                                  db_value=attrobj.db_value,
                                                  db_lock_storage=attrobj.db_lock_storage,
                                                  db_obj_id=attrobj.db_obj.id,
                                                  db_obj_type="scriptdb",
                                                  db_date_created=attrobj.db_date_created)
            new_attr.save()
            #new_attr.db_value = to_pickle(value)
            #new_attr.save()

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objattribute': {
            'Meta': {'object_name': 'ObjAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerattribute': {
            'Meta': {'object_name': 'PlayerAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['auth.User']", 'unique': 'True'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'scripts.scriptattribute': {
            'Meta': {'object_name': 'ScriptAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['scripts.ScriptDB']"}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'server.serverconfig': {
            'Meta': {'object_name': 'ServerConfig'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'db_value': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'server.tmpattribute': {
            'Meta': {'object_name': 'TmpAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'editable':'True','auto_now_add': 'False', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj_id': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_obj_type': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects', 'players', 'scripts', 'server']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0005_auto__del_tmpattribute
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):
    depends_on = (('typeclasses', '0002_resave_attrs'),)

    def forwards(self, orm):
        # Deleting model 'TmpAttribute'
        db.delete_table(u'server_tmpattribute')


    def backwards(self, orm):
        # Adding model 'TmpAttribute'
        db.create_table(u'server_tmpattribute', (
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_obj_id', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('db_obj_type', self.gf('django.db.models.fields.CharField')(max_length=10, null=True)),
            ('db_value', self.gf('src.utils.picklefield.PickledObjectField')(null=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=False, editable=True, blank=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('server', ['TmpAttribute'])


    models = {
        u'server.serverconfig': {
            'Meta': {'object_name': 'ServerConfig'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'db_value': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['server']

########NEW FILE########
__FILENAME__ = models
"""

Server Configuration flags

This holds persistent server configuration flags.

Config values should usually be set through the
manager's conf() method.

"""
try:
    import cPickle as pickle
except ImportError:
    import pickle

from django.db import models
from src.utils.idmapper.models import SharedMemoryModel
from src.utils import logger, utils
from src.server.manager import ServerConfigManager


#------------------------------------------------------------
#
# ServerConfig
#
#------------------------------------------------------------

class ServerConfig(SharedMemoryModel):
    """
    On-the fly storage of global settings.

    Properties defined on ServerConfig:
      key - main identifier
      value - value stored in key. This is a pickled storage.

    """

    #
    # ServerConfig database model setup
    #
    #
    # These database fields are all set using their corresponding properties,
    # named same as the field, but withtout the db_* prefix.

    # main name of the database entry
    db_key = models.CharField(max_length=64, unique=True)
    # config value
    db_value = models.TextField(blank=True)

    objects = ServerConfigManager()

    # Wrapper properties to easily set database fields. These are
    # @property decorators that allows to access these fields using
    # normal python operations (without having to remember to save()
    # etc). So e.g. a property 'attr' has a get/set/del decorator
    # defined that allows the user to do self.attr = value,
    # value = self.attr and del self.attr respectively (where self
    # is the object in question).

    # key property (wraps db_key)
    #@property
    def __key_get(self):
        "Getter. Allows for value = self.key"
        return self.db_key

    #@key.setter
    def __key_set(self, value):
        "Setter. Allows for self.key = value"
        self.db_key = value
        self.save()

    #@key.deleter
    def __key_del(self):
        "Deleter. Allows for del self.key. Deletes entry."
        self.delete()
    key = property(__key_get, __key_set, __key_del)

    # value property (wraps db_value)
    #@property
    def __value_get(self):
        "Getter. Allows for value = self.value"
        return pickle.loads(str(self.db_value))

    #@value.setter
    def __value_set(self, value):
        "Setter. Allows for self.value = value"
        if utils.has_parent('django.db.models.base.Model', value):
            # we have to protect against storing db objects.
            logger.log_errmsg("ServerConfig cannot store db objects! (%s)" % value)
            return
        self.db_value = pickle.dumps(value)
        self.save()

    #@value.deleter
    def __value_del(self):
        "Deleter. Allows for del self.value. Deletes entry."
        self.delete()
    value = property(__value_get, __value_set, __value_del)

    class Meta:
        "Define Django meta options"
        verbose_name = "Server Config value"
        verbose_name_plural = "Server Config values"

    #
    # ServerConfig other methods
    #

    def __unicode__(self):
        return "%s : %s" % (self.key, self.value)

    def store(self, key, value):
        """
        Wrap the storage (handles pickling)
        """
        self.key = key
        self.value = value

########NEW FILE########
__FILENAME__ = oobhandler
"""
OOBHandler - Out Of Band Handler

The OOBHandler.execute_cmd is called by the sessionhandler when it detects
an OOB instruction (exactly how this looked depends on the protocol; at this
point all oob calls should look the same)

The handler pieces of functionality:

    function execution - the oob protocol can execute a function directly on
                         the server. The available functions must be defined
                         as global functions in settings.OOB_PLUGIN_MODULES.
    repeat func execution - the oob protocol can request a given function be
                            executed repeatedly at a regular interval. This
                            uses an internal script pool.
    tracking - the oob protocol can request Evennia to track changes to
               fields on objects, as well as changes in Attributes. This is
               done by dynamically adding tracker-objects on entities. The
               behaviour of those objects can be customized by adding new
               tracker classes in settings.OOB_PLUGIN_MODULES.

What goes into the OOB_PLUGIN_MODULES is a (list of) modules that contains
the working server-side code available to the OOB system: oob functions and
tracker classes.

oob functions have the following call signature:
    function(caller, session, *args, **kwargs)

oob trackers should inherit from the OOBTracker class (in this
    module) and implement a minimum of the same functionality.

If a function named "oob_error" is given, this will be called with error
messages.

"""

from inspect import isfunction
from twisted.internet.defer import inlineCallbacks
from twisted.internet.task import LoopingCall
from django.conf import settings
from src.server.models import ServerConfig
from src.server.sessionhandler import SESSIONS
#from src.scripts.scripts import Script
#from src.utils.create import create_script
from src.scripts.tickerhandler import Ticker, TickerPool, TickerHandler
from src.utils.dbserialize import dbserialize, dbunserialize, pack_dbobj, unpack_dbobj
from src.utils import logger
from src.utils.utils import all_from_module, make_iter

_SA = object.__setattr__
_GA = object.__getattribute__
_DA = object.__delattr__

# load resources from plugin module
_OOB_FUNCS = {}
for mod in make_iter(settings.OOB_PLUGIN_MODULES):
    _OOB_FUNCS.update(dict((key.lower(), func) for key, func in all_from_module(mod).items() if isfunction(func)))
# get custom error method or use the default
_OOB_ERROR = _OOB_FUNCS.get("oob_error", None)

if not _OOB_ERROR:
    # create default oob error message function
    def oob_error(oobhandler, session, errmsg, *args, **kwargs):
        session.msg(oob=("send", {"ERROR": errmsg}))
    _OOB_ERROR = oob_error

class TrackerHandler(object):
    """
    This object is dynamically assigned to objects whenever one of its fields
    are to be tracked. It holds an internal dictionary mapping to the fields
    on that object. Each field can be tracked by any number of trackers (each
    tied to a different callback).
    """
    def __init__(self, obj):
        """
        This is initiated and stored on the object as a
        property _trackerhandler.
        """
        try:
            obj = obj.dbobj
        except AttributeError:
            pass
        self.obj = obj
        self.ntrackers = 0
        # initiate store only with valid on-object fieldnames
        self.tracktargets = dict((key, {})
                for key in _GA(_GA(self.obj, "_meta"), "get_all_field_names")())

    def add(self, fieldname, tracker):
        """
        Add tracker to the handler. Raises KeyError if fieldname
        does not exist.
        """
        trackerkey = tracker.__class__.__name__
        self.tracktargets[fieldname][trackerkey] = tracker
        self.ntrackers += 1

    def remove(self, fieldname, trackerclass, *args, **kwargs):
        """
        Remove tracker from handler. Raises KeyError if tracker
        is not found.
        """
        trackerkey = trackerclass.__name__
        tracker = self.tracktargets[fieldname][trackerkey]
        try:
            tracker.at_delete(*args, **kwargs)
        except Exception:
            logger.log_trace()
        del tracker
        self.ntrackers -= 1
        if self.ntrackers <= 0:
            # if there are no more trackers, clean this handler
            del self

    def update(self, fieldname, new_value):
        """
        Called by the field when it updates to a new value
        """
        for tracker in self.tracktargets[fieldname].values():
            try:
                tracker.update(new_value)
            except Exception:
                logger.log_trace()


class TrackerBase(object):
    """
    Base class for OOB Tracker objects.
    """
    def __init__(self, *args, **kwargs):
        pass

    def update(self, *args, **kwargs):
        "Called by tracked objects"
        pass

    def at_remove(self, *args, **kwargs):
        "Called when tracker is removed"
        pass


#class _RepeaterScript(Script):
#    """
#    Repeating and subscription-enabled script for triggering OOB
#    functions. Maintained in a _RepeaterPool.
#    """
#    def at_script_creation(self):
#        "Called when script is initialized"
#        self.key = "oob_func"
#        self.desc = "OOB functionality script"
#        self.persistent = False  # oob scripts should always be non-persistent
#        self.ndb.subscriptions = {}
#
#    def at_repeat(self):
#        """
#        Calls subscriptions every self.interval seconds
#        """
#        for (func_key, sessid, interval, args, kwargs) in self.ndb.subscriptions.values():
#            session = SESSIONS.session_from_sessid(sessid)
#            OOB_HANDLER.execute_cmd(session, func_key, *args, **kwargs)
#
#    def subscribe(self, store_key, sessid, func_key, interval, *args, **kwargs):
#        """
#        Sign up a subscriber to this oobfunction. Subscriber is
#        a database object with a dbref.
#        """
#        self.ndb.subscriptions[store_key] = (func_key, sessid, interval, args, kwargs)
#
#    def unsubscribe(self, store_key):
#        """
#        Unsubscribe from oobfunction. Returns True if removal was
#        successful, False otherwise
#        """
#        self.ndb.subscriptions.pop(store_key, None)
#
#
#class _RepeaterPool(object):
#    """
#    This maintains a pool of _RepeaterScript scripts, ordered one per
#    interval. It will automatically cull itself once a given interval's
#    script has no more subscriptions.
#
#    This is used and accessed from oobhandler.repeat/unrepeat
#    """
#
#    def __init__(self):
#        self.scripts = {}
#
#    def add(self, store_key, sessid, func_key, interval, *args, **kwargs):
#        """
#        Add a new tracking
#        """
#        if interval not in self.scripts:
#            # if no existing interval exists, create new script to fill the gap
#            new_tracker = create_script(_RepeaterScript,
#                           key="oob_repeater_%is" % interval, interval=interval)
#            self.scripts[interval] = new_tracker
#        self.scripts[interval].subscribe(store_key, sessid, func_key,
#                                                      interval, *args, **kwargs)
#
#    def remove(self, store_key, interval):
#        """
#        Remove tracking
#        """
#        if interval in self.scripts:
#            self.scripts[interval].unsubscribe(store_key)
#            if len(self.scripts[interval].ndb.subscriptions) == 0:
#                # no more subscriptions for this interval. Clean out the script.
#                self.scripts[interval].stop()
#
#    def stop(self):
#        """
#        Stop all scripts in pool. This is done at server reload since
#        restoring the pool will automatically re-populate the pool.
#        """
#        for script in self.scripts.values():
#            script.stop()


class OOBTicker(Ticker):
    """
    Version of Ticker that calls OOB_FUNC rather than trying to call
    a hook method.
    """
    @inlineCallbacks
    def _callback(self, oobhandler, sessions):
        "See original for more info"
        for key, (_, args, kwargs) in self.subscriptions.items():
            session = sessions.session_from_sessid(kwargs.get("sessid"))
            try:
                oobhandler.execute_cmd(session, kwargs.get("func_key"), *args, **kwargs)
            except Exception:
                logger.log_trace()

    def __init__(self, interval):
        "Sets up the Ticker"
        self.interval = interval
        self.subscriptions = {}
        self.task = LoopingCall(self._callback, OOB_HANDLER, SESSIONS)

class OOBTickerPool(TickerPool):
    ticker_class = OOBTicker

class OOBTickerHandler(TickerHandler):
    ticker_pool_class = OOBTickerPool

# Main OOB Handler

class OOBHandler(object):
    """
    The OOBHandler maintains all dynamic on-object oob hooks. It will store the
    creation instructions and and re-apply them at a server reload (but
    not after a server shutdown)
    """
    def __init__(self):
        """
        Initialize handler
        """
        self.sessionhandler = SESSIONS
        self.oob_tracker_storage = {}
        #self.oob_repeat_storage = {}
        #self.oob_tracker_pool = _RepeaterPool()
        self.tickerhandler = OOBTickerHandler("oob_ticker_storage")

    def save(self):
        """
        Save the command_storage as a serialized string into a temporary
        ServerConf field
        """
        if self.oob_tracker_storage:
            #print "saved tracker_storage:", self.oob_tracker_storage
            ServerConfig.objects.conf(key="oob_tracker_storage",
                                    value=dbserialize(self.oob_tracker_storage))
        self.tickerhandler.save()
        #if  self.oob_repeat_storage:
        #    #print "saved repeat_storage:", self.oob_repeat_storage
        #    ServerConfig.objects.conf(key="oob_repeat_storage",
        #                             value=dbserialize(self.oob_repeat_storage))
        #self.oob_tracker_pool.stop()

    def restore(self):
        """
        Restore the command_storage from database and re-initialize the handler from storage.. This is
        only triggered after a server reload, not after a shutdown-restart
        """
        # load stored command instructions and use them to re-initialize handler
        tracker_storage = ServerConfig.objects.conf(key="oob_tracker_storage")
        if tracker_storage:
            self.oob_tracker_storage = dbunserialize(tracker_storage)
            #print "recovered from tracker_storage:", self.oob_tracker_storage
            for (obj, sessid, fieldname, trackerclass, args, kwargs) in self.oob_tracker_storage.values():
                self.track(unpack_dbobj(obj), sessid, fieldname, trackerclass, *args, **kwargs)
            # make sure to purce the storage
            ServerConfig.objects.conf(key="oob_tracker_storage", delete=True)

        self.tickerhandler.restore()

        #repeat_storage = ServerConfig.objects.conf(key="oob_repeat_storage")
        #if repeat_storage:
        #    self.oob_repeat_storage = dbunserialize(repeat_storage)
        #    #print "recovered from repeat_storage:", self.oob_repeat_storage
        #    for (obj, sessid, func_key, interval, args, kwargs) in self.oob_repeat_storage.values():
        #        self.repeat(unpack_dbobj(obj), sessid, func_key, interval, *args, **kwargs)
        #    # make sure to purge the storage
        #    ServerConfig.objects.conf(key="oob_repeat_storage", delete=True)

    def track(self, obj, sessid, fieldname, trackerclass, *args, **kwargs):
        """
        Create an OOB obj of class _oob_MAPPING[tracker_key] on obj. args,
        kwargs will be used to initialize the OOB hook  before adding
        it to obj.
        If property_key is not given, but the OOB has a class property
        property_name, this will be used as the property name when assigning
        the OOB to obj, otherwise tracker_key is used as the property name.
        """
        try:
            obj = obj.dbobj
        except AttributeError:
            pass

        if not "_trackerhandler" in _GA(obj, "__dict__"):
            # assign trackerhandler to object
            _SA(obj, "_trackerhandler", TrackerHandler(obj))
        # initialize object
        tracker = trackerclass(self, fieldname, sessid, *args, **kwargs)
        _GA(obj, "_trackerhandler").add(fieldname, tracker)
        # store calling arguments as a pickle for retrieval later
        obj_packed = pack_dbobj(obj)
        storekey = (obj_packed, sessid, fieldname)
        stored = (obj_packed, sessid, fieldname, trackerclass,  args, kwargs)
        self.oob_tracker_storage[storekey] = stored

    def untrack(self, obj, sessid, fieldname, trackerclass, *args, **kwargs):
        """
        Remove the OOB from obj. If oob implements an
        at_delete hook, this will be called with args, kwargs
        """
        try:
            obj = obj.dbobj
        except AttributeError:
            pass

        try:
            # call at_delete hook
            _GA(obj, "_trackerhandler").remove(fieldname, trackerclass, *args, **kwargs)
        except AttributeError:
            pass
        # remove the pickle from storage
        store_key = (pack_dbobj(obj), sessid, fieldname)
        self.oob_tracker_storage.pop(store_key, None)

    def get_all_tracked(self, session):
        """
        Get the names of all variables this session is tracking.
        """
        sessid = session.sessid
        return [key[2].lstrip("db_") for key in self.oob_tracker_storage.keys() if key[1] == sessid]

    def track_field(self, obj, sessid, field_name, trackerclass):
        """
        Shortcut wrapper method for specifically tracking a database field.
        Takes the tracker class as argument.
        """
        # all database field names starts with db_*
        field_name = field_name if field_name.startswith("db_") else "db_%s" % field_name
        self.track(obj, sessid, field_name, trackerclass)

    def untrack_field(self, obj, sessid, field_name):
        """
        Shortcut for untracking a database field. Uses OOBTracker by defualt
        """
        field_name = field_name if field_name.startswith("db_") else "db_%s" % field_name
        self.untrack(obj, sessid, field_name)

    def track_attribute(self, obj, sessid, attr_name, trackerclass):
        """
        Shortcut wrapper method for specifically tracking the changes of an
        Attribute on an object. Will create a tracker on the Attribute
        Object and name in a way the Attribute expects.
        """
        # get the attribute object if we can
        try:
            obj = obj.dbobj
        except AttributeError:
            pass
        attrobj = _GA(obj, "attributes").get(attr_name, return_obj=True)
        if attrobj:
            self.track(attrobj, sessid, "db_value", trackerclass, attr_name)

    def untrack_attribute(self, obj, sessid, attr_name, trackerclass):
        """
        Shortcut for deactivating tracking for a given attribute.
        """
        try:
            obj = obj.dbobj
        except AttributeError:
            pass
        attrobj = _GA(obj, "attributes").get(attr_name, return_obj=True)
        if attrobj:
            self.untrack(attrobj, sessid, attr_name, trackerclass)

    def repeat(self, obj, sessid, func_key, interval=20, *args, **kwargs):
        """
        Start a repeating action. Every interval seconds,
        the oobfunc corresponding to func_key is called with
        args and kwargs.
        """
        if not func_key in _OOB_FUNCS:
            raise KeyError("%s is not a valid OOB function name.")
        #try:
        #    obj = obj.dbobj
        #except AttributeError:
        #    pass
        self.tickerhandler.add(self, obj, interval, func_key=func_key, sessid=sessid, *args, **kwargs)
        #store_obj = pack_dbobj(obj)
        #store_key = (store_obj, sessid, func_key, interval)
        ## prepare to store
        #self.oob_repeat_storage[store_key] = (store_obj, sessid, func_key, interval, args, kwargs)
        #self.oob_tracker_pool.add(store_key, sessid, func_key, interval, *args, **kwargs)

    def unrepeat(self, obj, sessid, func_key, interval=20):
        """
        Stop a repeating action
        """
        self.tickerhandler.remove(self, obj, interval)
        #try:
        #    obj = obj.dbobj
        #except AttributeError:
        #    pass
        #store_key = (pack_dbobj(obj), sessid, func_key, interval)
        #self.oob_tracker_pool.remove(store_key, interval)
        #self.oob_repeat_storage.pop(store_key, None)

    def msg(self, sessid, funcname, *args, **kwargs):
        "Shortcut to relay oob data back to portal. Used by oob functions."
        session = self.sessionhandler.session_from_sessid(sessid)
        #print "oobhandler msg:", sessid, session, funcname, args, kwargs
        if session:
            session.msg(oob=(funcname, args, kwargs))

    # access method - called from session.msg()

    def execute_cmd(self, session, func_key, *args, **kwargs):
        """
        Retrieve oobfunc from OOB_FUNCS and execute it immediately
        using *args and **kwargs
        """
        try:
            #print "OOB execute_cmd:", session, func_key, args, kwargs, _OOB_FUNCS.keys()
            oobfunc = _OOB_FUNCS[func_key]  # raise traceback if not found
            oobfunc(self, session, *args, **kwargs)
        except KeyError,e:
            errmsg = "OOB Error: function '%s' not recognized: %s" % (func_key, e)
            if _OOB_ERROR:
                _OOB_ERROR(self, session, errmsg, *args, **kwargs)
            else:
                logger.log_trace(errmsg)
            raise KeyError(errmsg)
        except Exception, err:
            errmsg = "OOB Error: Exception in '%s'(%s, %s):\n%s" % (func_key, args, kwargs, err)
            if _OOB_ERROR:
                _OOB_ERROR(self, session, errmsg, *args, **kwargs)
            else:
                logger.log_trace(errmsg)
            raise Exception(errmsg)
# access object
OOB_HANDLER = OOBHandler()

########NEW FILE########
__FILENAME__ = oob_msdp
"""
Out-of-band default plugin commands available for OOB handler. This
follows the standards defined by the MSDP out-of-band protocol
(http://tintin.sourceforge.net/msdp/)

This module is pointed to by settings.OOB_PLUGIN_MODULES. All functions
(not classes) defined globally in this module will be made available
to the oob mechanism.

    function execution - the oob protocol can execute a function directly on
                         the server. The available functions must be defined
                         as global functions via settings.OOB_PLUGIN_MODULES.
    repeat func execution - the oob protocol can request a given function be
                            executed repeatedly at a regular interval. This
                            uses an internal script pool.
    tracking - the oob protocol can request Evennia to track changes to
               fields on objects, as well as changes in Attributes. This is
               done by dynamically adding tracker-objects on entities. The
               behaviour of those objects can be customized via
               settings.OOB_PLUGIN_MODULES.

What goes into the OOB_PLUGIN_MODULES is a list of modules with input
for the OOB system.

oob functions have the following call signature:
    function(caller, session, *args, **kwargs)

oob trackers should build upon the OOBTracker class in this module
    module and implement a minimum of the same functionality.

a global function oob_error will be used as optional error management.
"""
from django.conf import settings
from src.utils.utils import to_str
_GA = object.__getattribute__
_SA = object.__setattr__
_NA = lambda o: (None, "N/A")  # not implemented

# default properties defined by the MSDP protocol. These are
# used by the SEND oob function below. Each entry should point
# to a function that takes the relevant object as input and
# returns the data it is responsible for. Most of these
# are commented out, but kept for reference for each
# game to implement.

OOB_SENDABLE = {
   ## General
    "CHARACTER_NAME": lambda o: ("db_key", o.key),
    "SERVER_ID": lambda o: ("settings.SERVERNAME", settings.SERVERNAME),
    #"SERVER_TIME": _NA,
   ## Character
    #"AFFECTS": _NA,
    #"ALIGNMENT": _NA,
    #"EXPERIENCE": _NA,
    #"EXPERIENCE_MAX": _NA,
    #"EXPERIENCE_TNL": _NA,
    #"HEALTH": _NA,
    #"HEALTH_MAX": _NA,
    #"LEVEL": _NA,
    #"RACE": _NA,
    #"CLASS": _NA,
    #"MANA": _NA,
    #"MANA_MAX": _NA,
    #"WIMPY": _NA,
    #"PRACTICE": _NA,
    #"MONEY": _NA,
    #"MOVEMENT": _NA,
    #"MOVEMENT_MAX": _NA,
    #"HITROLL": _NA,
    #"DAMROLL": _NA,
    #"AC": _NA,
    #"STR": _NA,
    #"INT": _NA,
    #"WIS": _NA,
    #"DEX": _NA,
    #"CON": _NA,
   ## Combat
    #"OPPONENT_HEALTH": _NA,
    #"OPPONENT_HEALTH_MAX": _NA,
    #"OPPONENT_LEVEL": _NA,
    #"OPPONENT_NAME": _NA,
   ## World
    #"AREA_NAME": _NA,
    #"ROOM_EXITS": _NA,
    #"ROOM_VNUM": _NA,
    "ROOM_NAME": lambda o: ("db_location", o.db_location.key),
    #"WORLD_TIME": _NA,
   ## Configurable variables
    #"CLIENT_ID": _NA,
    #"CLIENT_VERSION": _NA,
    #"PLUGIN_ID": _NA,
    #"ANSI_COLORS": _NA,
    #"XTERM_256_COLORS": _NA,
    #"UTF_8": _NA,
    #"SOUND": _NA,
    #"MXP": _NA,
   ## GUI variables
    #"BUTTON_1": _NA,
    #"BUTTON_2": _NA,
    #"BUTTON_3": _NA,
    #"BUTTON_4": _NA,
    #"BUTTON_5": _NA,
    #"GAUGE_1": _NA,
    #"GAUGE_2": _NA,
    #"GAUGE_3": _NA,
    #"GAUGE_4": _NA,
    #"GAUGE_5": _NA
    }
# mapping for which properties may be tracked
OOB_REPORTABLE = OOB_SENDABLE


#------------------------------------------------------------
# Tracker classes
#
# Trackers are added to a given object's trackerhandler and
# reports back changes when they happen. They are managed using
# the oobhandler's track/untrack mechanism
#------------------------------------------------------------

class TrackerBase(object):
    """
    Base class for OOB Tracker objects.
    """
    def __init__(self, oobhandler, *args, **kwargs):
        self.oobhandler = oobhandler

    def update(self, *args, **kwargs):
        "Called by tracked objects"
        pass

    def at_remove(self, *args, **kwargs):
        "Called when tracker is removed"
        pass


class OOBFieldTracker(TrackerBase):
    """
    Tracker that passively sends data to a stored sessid whenever
    a named database field changes. The TrackerHandler calls this with
    the correct arguments.
    """
    def __init__(self, oobhandler, fieldname, sessid, *args, **kwargs):
        """
        name - name of entity to track, such as "db_key"
        sessid - sessid of session to report to
        """
        self.oobhandler = oobhandler
        self.fieldname = fieldname
        self.sessid = sessid

    def update(self, new_value, *args, **kwargs):
        "Called by cache when updating the tracked entitiy"
        # use oobhandler to relay data
        try:
            # we must never relay objects across the amp, only text data.
            new_value = new_value.key
        except AttributeError:
            new_value = to_str(new_value, force_string=True)
        # this is a wrapper call for sending oob data back to session
        self.oobhandler.msg(self.sessid, "report", self.fieldname,
                                                    new_value, *args, **kwargs)


class OOBAttributeTracker(TrackerBase):
    """
    Tracker that passively sends data to a stored sessid whenever
    the Attribute updates. Since the field here is always "db_key",
    we instead store the name of the attribute to return.
    """
    def __init__(self, oobhandler, fieldname, sessid, attrname, *args, **kwargs):
        """
        attrname - name of attribute to track
        sessid - sessid of session to report to
        """
        self.oobhandler = oobhandler
        self.attrname = attrname
        self.sessid = sessid

    def update(self, new_value, *args, **kwargs):
        "Called by cache when attribute's db_value field updates"
        try:
            new_value = new_value.dbobj
        except AttributeError:
            new_value = to_str(new_value, force_string=True)
        # this is a wrapper call for sending oob data back to session
        self.oobhandler.msg(self.sessid, "report", self.attrname, new_value, *args, **kwargs)


#------------------------------------------------------------
# OOB commands
# This defines which internal server commands the OOB handler
# makes available to the client. These commands are called
# automatically by the OOB mechanism by triggering the
# oobhandlers's execute_cmd method with the cmdname and
# eventual args/kwargs. All functions defined globally in this
# module will be made available to call by the oobhandler. Use
# _funcname if you want to exclude one. To allow for python-names
# like "list" here, these properties are read as being case-insensitive.
#
# All OOB commands must be on the form
#      cmdname(oobhandler, session, *args, **kwargs)
#------------------------------------------------------------

def oob_error(oobhandler, session, errmsg, *args, **kwargs):
    """
    This is a special function called by the oobhandler when an error
    occurs already at the execution stage (such as the oob function
    not being recognized or having the wrong args etc).
    """
    session.msg(oob=("send", {"ERROR": errmsg}))

def list(oobhandler, session, mode, *args, **kwargs):
    """
    List available properties. Mode is the type of information
    desired:
        "COMMANDS"               Request an array of commands supported
                                 by the server.
        "LISTS"                  Request an array of lists supported
                                 by the server.
        "CONFIGURABLE_VARIABLES" Request an array of variables the client
                                 can configure.
        "REPORTABLE_VARIABLES"   Request an array of variables the server
                                 will report.
        "REPORTED_VARIABLES"     Request an array of variables currently
                                 being reported.
        "SENDABLE_VARIABLES"     Request an array of variables the server
                                 will send.
    """
    mode = mode.upper()
    # the first return argument is treated by the msdp protocol as the
    # name of the msdp array to return
    if mode == "COMMANDS":
        session.msg(oob=("list", ("COMMANDS",
                                  "LIST",
                                  "REPORT",
                                  "UNREPORT",
                                  # "RESET",
                                  "SEND")))
    elif mode == "LISTS":
        session.msg(oob=("list", ("LISTS",
                                  "REPORTABLE_VARIABLES",
                                  "REPORTED_VARIABLES",
                                  # "CONFIGURABLE_VARIABLES",
                                  "SENDABLE_VARIABLES")))
    elif mode == "REPORTABLE_VARIABLES":
        session.msg(oob=("list", ("REPORTABLE_VARIABLES",) +
                                  tuple(key for key in OOB_REPORTABLE.keys())))
    elif mode == "REPORTED_VARIABLES":
        session.msg(oob=("list", ("REPORTED_VARIABLES",) +
                                    tuple(oobhandler.get_all_tracked(session))))
    elif mode == "SENDABLE_VARIABLES":
        session.msg(oob=("list", ("SENDABLE_VARIABLES",) +
                                  tuple(key for key in OOB_REPORTABLE.keys())))
    #elif mode == "CONFIGURABLE_VARIABLES":
    #    pass
    else:
        session.msg(oob=("list", ("unsupported mode",)))


def send(oobhandler, session, *args, **kwargs):
    """
    This function directly returns the value of the given variable to the
    session. vartype can be one of
    """
    obj = session.get_puppet_or_player()
    ret = {}
    if obj:
        for name in (a.upper() for a in args if a):
            try:
                key, value = OOB_SENDABLE.get(name, _NA)(obj)
                ret[name] = value
            except Exception, e:
                ret[name] = str(e)
    # return result
    session.msg(oob=("send", ret))


def report(oobhandler, session, *args, **kwargs):
    """
    This creates a tracker instance to track the data given in *args.
    vartype is one of "prop" (database fields) or "attr" (attributes)
    """
    obj = session.get_puppet_or_player()
    if obj:
        for name in (a.upper() for a in args if a):
            key, val = OOB_REPORTABLE.get(name, _NA)(obj)
            if key:
                if key.startswith("db_"):
                    oobhandler.track_field(obj, session.sessid,
                                           key, OOBFieldTracker)
                else:  # assume attribute
                    oobhandler.track_attribute(obj, session.sessid,
                                               key, OOBAttributeTracker)


def unreport(oobhandler, session, vartype="prop", *args, **kwargs):
    """
    This removes tracking for the given data given in *args.
    vartype is one of of "prop" or "attr".
    """
    obj = session.get_puppet_or_player()
    if obj:
        for name in (a.upper() for a in args if a):
            key, val = OOB_REPORTABLE.get(name, _NA)
            if key:
                if key.startswith("db_"):
                    oobhandler.untrack_field(obj, session.sessid, key)
                else:  # assume attribute
                    oobhandler.untrack_attribute(obj, session.sessid, key)


########NEW FILE########
__FILENAME__ = imc2
"""
IMC2 client module. Handles connecting to and communicating with an IMC2 server.
"""

from time import time
from twisted.internet import task
from twisted.application import internet
from twisted.internet import protocol
from twisted.conch import telnet

from src.server.session import Session
from src.utils import logger, utils
from src.server.portal.imc2lib import imc2_ansi
from src.server.portal.imc2lib import imc2_packets as pck

from django.utils.translation import ugettext as _


# storage containers for IMC2 muds and channels

class IMC2Mud(object):
    """
    Stores information about other games connected to our current IMC2 network.
    """
    def __init__(self, packet):
        self.name = packet.origin
        self.versionid = packet.optional_data.get('versionid', None)
        self.networkname = packet.optional_data.get('networkname', None)
        self.url = packet.optional_data.get('url', None)
        self.host = packet.optional_data.get('host', None)
        self.port = packet.optional_data.get('port', None)
        self.sha256 = packet.optional_data.get('sha256', None)
        # This is used to determine when a Mud has fallen into inactive status.
        self.last_updated = time()


class IMC2MudList(dict):
    """
    Keeps track of other MUDs connected to the IMC network.
    """
    def get_mud_list(self):
        """
        Returns a sorted list of connected Muds.
        """
        muds = self.items()
        muds.sort()
        return [value for key, value in muds]

    def update_mud_from_packet(self, packet):
        """
        This grabs relevant info from the packet and stuffs it in the
        Mud list for later retrieval.
        """
        mud = IMC2Mud(packet)
        self[mud.name] = mud

    def remove_mud_from_packet(self, packet):
        """
        Removes a mud from the Mud list when given a packet.
        """
        mud = IMC2Mud(packet)
        try:
            del self[mud.name]
        except KeyError:
            # No matching entry, no big deal.
            pass


class IMC2Channel(object):
    """
    Stores information about channels available on the network.
    """
    def __init__(self, packet):
        self.localname = packet.optional_data.get('localname', None)
        self.name = packet.optional_data.get('channel', None)
        self.level = packet.optional_data.get('level', None)
        self.owner = packet.optional_data.get('owner', None)
        self.policy = packet.optional_data.get('policy', None)
        self.last_updated = time()


class IMC2ChanList(dict):
    """
    Keeps track of Channels on the IMC network.
    """

    def get_channel_list(self):
        """
        Returns a sorted list of cached channels.
        """
        channels = self.items()
        channels.sort()
        return [value for key, value in channels]

    def update_channel_from_packet(self, packet):
        """
        This grabs relevant info from the packet and stuffs it in the
        channel list for later retrieval.
        """
        channel = IMC2Channel(packet)
        self[channel.name] = channel

    def remove_channel_from_packet(self, packet):
        """
        Removes a channel from the Channel list when given a packet.
        """
        channel = IMC2Channel(packet)
        try:
            del self[channel.name]
        except KeyError:
            # No matching entry, no big deal.
            pass


#
# IMC2 protocol
#

class IMC2Bot(telnet.StatefulTelnetProtocol, Session):
    """
    Provides the abstraction for the IMC2 protocol. Handles connection,
    authentication, and all necessary packets.
    """
    def __init__(self):
        self.is_authenticated = False
        # only support plaintext passwords
        self.auth_type = "plaintext"
        self.sequence = None
        self.imc2_mudlist = IMC2MudList()
        self.imc2_chanlist = IMC2ChanList()

    def _send_packet(self, packet):
        "Helper function to send packets across the wire"
        packet.imc2_protocol = self
        packet_str = utils.to_str(packet.assemble(self.factory.mudname,
                         self.factory.client_pwd, self.factory.server_pwd))
        self.sendLine(packet_str)

    def _isalive(self):
        "Send an isalive packet"
        self._send_packet(pck.IMC2PacketIsAlive())

    def _keepalive(self):
        "Send a keepalive packet"
        # send to channel?
        self._send_packet(pck.IMC2PacketKeepAliveRequest())

    def _channellist(self):
        "Sync the network channel list"
        checked_networks = []
        if not self.network in checked_networks:
            self._send_packet(pck.IMC2PacketIceRefresh())
            checked_networks.append(self.network)

    def _prune(self):
        "Prune active channel list"
        t0 = time()
        for name, mudinfo in self.imc2_mudlist.items():
            if t0 - mudinfo.last_updated > 3599:
                del self.imc2_mudlist[name]

    def _whois_reply(self, packet):
        "handle reply from server from an imcwhois request"
        # packet.target potentially contains the id of an character to target
        # not using that here
        response_text = imc2_ansi.parse_ansi(packet.optional_data.get('text', 'Unknown'))
        string = _('Whois reply from %(origin)s: %(msg)s') % {"origin":packet.origin, "msg":response_text}
        # somehow pass reply on to a given player, for now we just send to channel
        self.data_in(string)

    def _format_tell(self, packet):
        """
        Handle tells over IMC2 by formatting the text properly
        """
        return _("{c%(sender)s@%(origin)s{n {wpages (over IMC):{n %(msg)s") % {"sender": packet.sender,
                                                        "origin": packet.origin,
                                                        "msg": packet.optional_data.get('text', 'ERROR: No text provided.')}

    def _imc_login(self, line):
        "Connect and identify to imc network"

        if self.auth_type == "plaintext":
            # Only support Plain text passwords.
            # SERVER Sends: PW <servername> <serverpw> version=<version#> <networkname>

            logger.log_infomsg("IMC2: AUTH< %s" % line)

            line_split = line.split(' ')
            pw_present = line_split[0] == 'PW'
            autosetup_present = line_split[0] == 'autosetup'

            if "reject" in line_split:
                auth_message = _("IMC2 server rejected connection.")
                logger.log_infomsg(auth_message)
                return

            if pw_present:
                self.server_name = line_split[1]
                self.network_name = line_split[4]
            elif autosetup_present:
                logger.log_infomsg(_("IMC2: Autosetup response found."))
                self.server_name = line_split[1]
                self.network_name = line_split[3]
            self.is_authenticated = True
            self.sequence = int(time())

            # Log to stdout and notify over MUDInfo.
            logger.log_infomsg('IMC2: Authenticated to %s' % self.factory.network)

            # Ask to see what other MUDs are connected.
            self._send_packet(pck.IMC2PacketKeepAliveRequest())
            # IMC2 protocol states that KeepAliveRequests should be followed
            # up by the requester sending an IsAlive packet.
            self._send_packet(pck.IMC2PacketIsAlive())
            # Get a listing of channels.
            self._send_packet(pck.IMC2PacketIceRefresh())

    def connectionMade(self):
        """
        Triggered after connecting to the IMC2 network.
        """

        self.stopping = False
        self.factory.bot = self
        address = "%s@%s" % (self.mudname, self.network)
        self.init_session("ircbot", address, self.factory.sessionhandler)
        # link back and log in
        self.uid = int(self.factory.uid)
        self.logged_in = True
        self.factory.sessionhandler.connect(self)
        logger.log_infomsg("IMC2 bot connected to %s." % self.network)
        # Send authentication packet. The reply will be caught by lineReceived
        self._send_packet(pck.IMC2PacketAuthPlaintext())

    def lineReceived(self, line):
        """
        IMC2 -> Evennia

        Triggered when text is received from the IMC2 network. Figures out
        what to do with the packet. This deals with the following

        """
        line = line.strip()

        if not self.is_authenticated:
            # we are not authenticated yet. Deal with this.
            self._imc_login(line)
            return

        #logger.log_infomsg("IMC2: RECV> %s" % line)

        # Parse the packet and encapsulate it for easy access
        packet = pck.IMC2Packet(self.mudname, packet_str=line)

        # Figure out what kind of packet we're dealing with and hand it
        # off to the correct handler.

        if packet.packet_type == 'is-alive':
            self.imc2_mudlist.update_mud_from_packet(packet)
        elif packet.packet_type == 'keepalive-request':
            # Don't need to check the destination, we only receive these
            # packets when they are intended for us.
            self.send_packet(pck.IMC2PacketIsAlive())
        elif packet.packet_type == 'ice-msg-b':
            self.data_out(text=line, packettype="broadcast")
        elif packet.packet_type == 'whois-reply':
            # handle eventual whois reply
            self._whois_reply(packet)
        elif packet.packet_type == 'close-notify':
            self.imc2_mudlist.remove_mud_from_packet(packet)
        elif packet.packet_type == 'ice-update':
            self.imc2_chanlist.update_channel_from_packet(packet)
        elif packet.packet_type == 'ice-destroy':
            self.imc2_chanlist.remove_channel_from_packet(packet)
        elif packet.packet_type == 'tell':
            # send message to identified player
            pass

    def data_in(self, text=None, **kwargs):
        """
        Data IMC2 -> Evennia
        """
        text = "bot_data_in " + text
        self.sessionhandler.data_in(self, text=text, **kwargs)

    def data_out(self, text=None, **kwargs):
        """
        Evennia -> IMC2

        Keywords
           packet_type:
            broadcast - send to everyone on IMC channel
            tell - send a tell (see target keyword)
            whois - get whois information (see target keyword)
          sender - used by tell to identify the sender
          target - key identifier of target to tells or whois. If not
                   given "Unknown" will be used.
          destination - used by tell to specify mud destination to send to

        """

        if self.sequence:
            # This gets incremented with every command.
            self.sequence += 1

        packet_type = kwargs.get("packet_type", "imcbroadcast")

        if packet_type == "broadcast":
            # broadcast to everyone on IMC channel

            if text.startswith("bot_data_out"):
                text = text.split(" ", 1)[1]
            else:
                return

            # we remove the extra channel info since imc2 supplies this anyway
            if ":" in text:
                header, message = [part.strip() for part in text.split(":", 1)]
            # Create imc2packet and send it
            self._send_packet(pck.IMC2PacketIceMsgBroadcasted(self.servername,
                                                        self.channel,
                                                        header, text))
        elif packet_type == "tell":
            # send an IMC2 tell
            sender = kwargs.get("sender", self.mudname)
            target = kwargs.get("target", "Unknown")
            destination = kwargs.get("destination", "Unknown")
            self._send_packet(pck.IMC2PacketTell(sender, target, destination, text))

        elif packet_type == "whois":
            # send a whois request
            sender = kwargs.get("sender", self.mudname)
            target = kwargs.get("target", "Unknown")
            self._send_packet(pck.IMC2PacketWhois(sender, target))


class IMC2BotFactory(protocol.ReconnectingClientFactory):
    """
    Creates instances of the IMC2Protocol. Should really only ever
    need to create one connection. Tied in via src/server.py.
    """
    initialDelay = 1
    factor = 1.5
    maxDelay = 60

    def __init__(self, sessionhandler, uid=None, network=None, channel=None,
                 port=None, mudname=None, client_pwd=None, server_pwd=None):
        self.uid = uid
        self.network = network
        sname, host = network.split(".", 1)
        self.servername = sname.strip()
        self.channel = channel
        self.port = port
        self.mudname = mudname
        self.protocol_version = '2'
        self.client_pwd = client_pwd
        self.server_pwd = server_pwd
        self.bot = None
        self.task_isalive = None
        self.task_keepalive = None
        self.task_prune = None
        self.task_channellist = None

    def buildProtocol(self, addr):
        "Build the protocol"
        protocol = IMC2Bot()
        protocol.factory = self
        protocol.network = self.network
        protocol.servername = self.servername
        protocol.channel = self.channel
        protocol.mudname = self.mudname
        protocol.port = self.port
        return protocol

    def clientConnectionFailed(self, connector, reason):
        self.retry(connector)

    def clientConnectionLost(self, connector, reason):
        if not self.bot.stopping:
            self.retry(connector)

    def start(self):
        "Connect session to sessionhandler"
        def errback(fail):
            logger.log_errmsg(fail.value)

        if self.port:
            service = internet.TCPClient(self.network, int(self.port), self)
            self.sessionhandler.portal.services.addService(service)
        # start tasks
        self.task_isalive = task.LoopingCall(self.bot._isalive)
        self.task_keepalive = task.LoopingCall(self.bot._keepalive)
        self.task_prune = task.LoopingCall(self.bot._prune)
        self.task_channellist = task.LoopingCall(self.bot._channellist)
        self.task_isalive.start(900, now=False)
        self.task_keepalive.start(3500, now=False)
        self.task_prune.start(1800, now=False)
        self.task_channellist.start(3600 * 24, now=False)


########NEW FILE########
__FILENAME__ = imc2_ansi
"""
ANSI parser - this adds colour to text according to
special markup strings.

This is a IMC2 complacent version.
"""

import re
from src.utils import ansi


class IMCANSIParser(ansi.ANSIParser):
    """
    This parser is per the IMC2 specification.
    """
    def __init__(self):
        normal = ansi.ANSI_NORMAL
        hilite = ansi.ANSI_HILITE
        self.ansi_map = [
            (r'~Z', normal),  # Random
            (r'~x', normal + ansi.ANSI_BLACK),    # Black
            (r'~D', hilite + ansi.ANSI_BLACK),    # Dark Grey
            (r'~z', hilite + ansi.ANSI_BLACK),
            (r'~w', normal + ansi.ANSI_WHITE),    # Grey
            (r'~W', hilite + ansi.ANSI_WHITE),    # White
            (r'~g', normal + ansi.ANSI_GREEN),    # Dark Green
            (r'~G', hilite + ansi.ANSI_GREEN),    # Green
            (r'~p', normal + ansi.ANSI_MAGENTA),  # Dark magenta
            (r'~m', normal + ansi.ANSI_MAGENTA),
            (r'~M', hilite + ansi.ANSI_MAGENTA),  # Magenta
            (r'~P', hilite + ansi.ANSI_MAGENTA),
            (r'~c', normal + ansi.ANSI_CYAN),     # Cyan
            (r'~y', normal + ansi.ANSI_YELLOW),   # Dark Yellow (brown)
            (r'~Y', hilite + ansi.ANSI_YELLOW),   # Yellow
            (r'~b', normal + ansi.ANSI_BLUE),     # Dark Blue
            (r'~B', hilite + ansi.ANSI_BLUE),     # Blue
            (r'~C', hilite + ansi.ANSI_BLUE),
            (r'~r', normal + ansi.ANSI_RED),      # Dark Red
            (r'~R', hilite + ansi.ANSI_RED),      # Red

            ## Formatting
            (r'~L', hilite),                     # Bold/hilite
            (r'~!', normal),                     # reset
            (r'\\r', normal),
            (r'\\n', ansi.ANSI_RETURN),
        ]
        # prepare regex matching
        self.ansi_sub = [(re.compile(sub[0], re.DOTALL), sub[1])
                         for sub in self.ansi_map]
        # prepare matching ansi codes overall
        self.ansi_regex = re.compile("\033\[[0-9;]+m")

ANSI_PARSER = IMCANSIParser()


def parse_ansi(string, strip_ansi=False, parser=ANSI_PARSER):
    """
    Shortcut to use the IMC2 ANSI parser.
    """
    return parser.parse_ansi(string, strip_ansi=strip_ansi)

########NEW FILE########
__FILENAME__ = imc2_packets
"""
IMC2 packets. These are pretty well documented at:
http://www.mudbytes.net/index.php?a=articles&s=imc2_protocol

"""
import shlex
from django.conf import settings

class Lexxer(shlex.shlex):
    """
    A lexical parser for interpreting IMC2 packets.
    """
    def __init__(self, packet_str, posix=True):
        shlex.shlex.__init__(self, packet_str, posix=True)
        # Single-quotes are notably not present. This is important!
        self.quotes = '"'
        self.commenters = ''
        # This helps denote what constitutes a continuous token.
        self.wordchars += "~`!@#$%^&*()-_+=[{]}|\\;:',<.>/?"

class IMC2Packet(object):
    """
    Base IMC2 packet class. This is generally sub-classed, aside from using it
    to parse incoming packets from the IMC2 network server.
    """
    def __init__(self, mudname=None, packet_str=None):
        """
        Optionally, parse a packet and load it up.
        """
        # The following fields are all according to the basic packet format of:
        # <sender>@<origin> <sequence> <route> <packet-type> <target>@<destination> <data...>
        self.sender = None
        if not mudname:
            mudname = settings.SERVERNAME
        self.origin = mudname
        self.sequence = None
        self.route = mudname
        self.packet_type = None
        self.target = None
        self.destination = None
        # Optional data.
        self.optional_data = {}
        # Reference to the IMC2Protocol object doing the sending.
        self.imc2_protocol = None

        if packet_str:
            # The lexxer handles the double quotes correctly, unlike just
            # splitting. Spaces throw things off, so shlex handles it
            # gracefully, ala POSIX shell-style parsing.
            lex = Lexxer(packet_str)

            # Token counter.
            counter = 0
            for token in lex:
                if counter == 0:
                    # This is the sender@origin token.
                    sender_origin = token
                    split_sender_origin = sender_origin.split('@')
                    self.sender = split_sender_origin[0].strip()
                    self.origin = split_sender_origin[1]
                elif counter == 1:
                    # Numeric time-based sequence.
                    self.sequence = token
                elif counter == 2:
                    # Packet routing info.
                    self.route = token
                elif counter == 3:
                    # Packet type string.
                    self.packet_type = token
                elif counter == 4:
                    # Get values for the target and destination attributes.
                    target_destination = token
                    split_target_destination = target_destination.split('@')
                    self.target = split_target_destination[0]
                    try:
                        self.destination = split_target_destination[1]
                    except IndexError:
                        # There is only one element to the target@dest segment
                        # of the packet. Wipe the target and move the captured
                        # value to the destination attrib.
                        self.target = '*'
                        self.destination = split_target_destination[0]
                elif counter > 4:
                    # Populate optional data.
                    try:
                        key, value = token.split('=', 1)
                        self.optional_data[key] = value
                    except ValueError:
                        # Failed to split on equal sign, disregard.
                        pass
                # Increment and continue to the next token (if applicable)
                counter += 1

    def __str__(self):
        retval =  """
        --IMC2 package (%s)
        Sender:   %s
        Origin:   %s
        Sequence: %s
        Route:    %s
        Type:     %s
        Target:   %s
        Dest.:    %s
        Data:
         %s
       ------------------------""" % (self.packet_type, self.sender,
                                      self.origin, self.sequence,
                                      self.route, self.packet_type,
                                      self.target, self.destination,
                                      "\n         ".join(["%s: %s" % items for items in self.optional_data.items()]))
        return retval.strip()

    def _get_optional_data_string(self):
        """
        Generates the optional data string to tack on to the end of the packet.
        """
        if self.optional_data:
            data_string = ''
            for key, value in self.optional_data.items():
                # Determine the number of words in this value.
                words = len(str(value).split(' '))
                # Anything over 1 word needs double quotes.
                if words > 1:
                    value = '"%s"' % (value,)
                data_string += '%s=%s ' % (key, value)
            return data_string.strip()
        else:
            return ''

    def _get_sender_name(self):
        """
        Calculates the sender name to be sent with the packet.
        """
        if self.sender == '*':
            # Some packets have no sender.
            return '*'
        elif str(self.sender).isdigit():
            return self.sender
        elif type(self.sender) in [type(u""),type(str())]:
            #this is used by e.g. IRC where no user object is present.
            return self.sender.strip().replace(' ', '_')
        elif self.sender:
            # Player object.
            name = self.sender.get_name(fullname=False, show_dbref=False,
                                        show_flags=False,
                                        no_ansi=True)
            # IMC2 does not allow for spaces.
            return name.strip().replace(' ', '_')
        else:
            # None value. Do something or other.
            return 'Unknown'

    def assemble(self, mudname=None, client_pwd=None, server_pwd=None):
        """
        Assembles the packet and returns the ready-to-send string.
        Note that the arguments are not used, they are there for
        consistency across all packets.
        """
        self.sequence = self.imc2_protocol.sequence
        packet = "%s@%s %s %s %s %s@%s %s\n" % (
                 self._get_sender_name(),
                 self.origin,
                 self.sequence,
                 self.route,
                 self.packet_type,
                 self.target,
                 self.destination,
                 self._get_optional_data_string())
        return packet.strip()


class IMC2PacketAuthPlaintext(object):
    """
    IMC2 plain-text authentication packet. Auth packets are strangely
    formatted, so this does not sub-class IMC2Packet. The SHA and plain text
    auth packets are the two only non-conformers.

    CLIENT Sends:
    PW <mudname> <clientpw> version=<version#> autosetup <serverpw> (SHA256)

    Optional Arguments( required if using the specified authentication method:
    (SHA256)    The literal string: SHA256. This is sent to notify the server
                that the MUD is SHA256-Enabled. All future logins from this
                client will be expected in SHA256-AUTH format if the server
                supports it.
    """
    def assemble(self, mudname=None, client_pwd=None, server_pwd=None):
        """
        This is one of two strange packets, just assemble the packet manually
        and go.
        """
        return 'PW %s %s version=2 autosetup %s\n' %(mudname, client_pwd, server_pwd)


class IMC2PacketKeepAliveRequest(IMC2Packet):
    """
    Description:
    This packet is sent by a MUD to trigger is-alive packets from other MUDs.
    This packet is usually followed by the sending MUD's own is-alive packet.
    It is used in the filling of a client's MUD list, thus any MUD that doesn't
    respond with an is-alive isn't marked as online on the sending MUD's
    mudlist.

    Data:
    (none)

    Example of a received keepalive-request:
    *@YourMUD 1234567890 YourMUD!Hub1 keepalive-request *@*

    Example of a sent keepalive-request:
    *@YourMUD 1234567890 YourMUD keepalive-request *@*
    """
    def __init__(self):
        super(IMC2PacketKeepAliveRequest, self).__init__()
        self.sender = '*'
        self.packet_type = 'keepalive-request'
        self.target = '*'
        self.destination = '*'


class IMC2PacketIsAlive(IMC2Packet):
    """
    Description:
    This packet is the reply to a keepalive-request packet. It is responsible
    for filling a client's mudlist with the information about other MUDs on the
    network.

    Data:
    versionid=<string>
    Where <string> is the text version ID of the client. ("IMC2 4.5 MUD-Net")

    url=<string>
    Where <string> is the proper URL of the client. (http://www.domain.com)

    host=<string>
    Where <string> is the telnet address of the MUD. (telnet://domain.com)

    port=<int>
    Where <int> is the telnet port of the MUD.

    (These data fields are not sent by the MUD, they are added by the server.)
    networkname=<string>
    Where <string> is the network name that the MUD/server is on. ("MyNetwork")

    sha256=<int>
    This is an optional tag that denotes the SHA-256 capabilities of a
    MUD or server.

    Example of a received is-alive:
    *@SomeMUD 1234567890 SomeMUD!Hub2 is-alive *@YourMUD versionid="IMC2 4.5 MUD-Net" url="http://www.domain.com" networkname="MyNetwork" sha256=1 host=domain.com port=5500

    Example of a sent is-alive:
    *@YourMUD 1234567890 YourMUD is-alive *@* versionid="IMC2 4.5 MUD-Net" url="http://www.domain.com" host=domain.com port=5500
    """
    def __init__(self):
        super(IMC2PacketIsAlive, self).__init__()
        self.sender = '*'
        self.packet_type = 'is-alive'
        self.target = '*'
        self.destination = '*'
        self.optional_data = {'versionid': 'Evennia IMC2',
                              'url': '"http://www.evennia.com"',
                              'host': 'test.com',
                              'port': '5555'}


class IMC2PacketIceRefresh(IMC2Packet):
    """
    Description:
    This packet is sent by the MUD to request data about the channels on the
    network. Servers with channels reply with an ice-update packet for each
    channel they control. The usual target for this packet is IMC@$.

    Data:
    (none)

    Example:
    *@YourMUD 1234567890 YourMUD!Hub1 ice-refresh IMC@$
    """
    def __init__(self):
        super(IMC2PacketIceRefresh, self).__init__()
        self.sender = '*'
        self.packet_type = 'ice-refresh'
        self.target = 'IMC'
        self.destination = '$'


class IMC2PacketIceUpdate(IMC2Packet):
    """
    Description:
    A server returns this packet with the data of a channel when prompted with
    an ice-refresh request.

    Data:
    channel=<string>
    The channel's network name in the format of ServerName:ChannelName

    owner=<string>
    The Name@MUD of the channel's owner

    operators=<string>
    A space-seperated list of the Channel's operators, (format: Person@MUD)

    policy=<string>
    The policy is either "open" or "private" with no quotes.

    invited=<string>
    The space-seperated list of invited User@MUDs, only valid for a
    "private" channel.

    excluded=<string>
    The space-seperated list of banned User@MUDs, only valid for "open"
    channels.

    level=<string>      The default level of the channel: Admin, Imp, Imm,
    Mort, or None

    localname=<string>  The suggested local name of the channel.

    Examples:

    Open Policy:
    ICE@Hub1 1234567890 Hub1!Hub2 ice-update *@YourMUD channel=Hub1:ichat owner=Imm@SomeMUD operators=Other@SomeMUD policy=open excluded="Flamer@badMUD Jerk@dirtyMUD" level=Imm localname=ichat

    Private Policy:
    ICE@Hub1 1234567890 Hub1!Hub2 ice-update *@YourMUD channel=Hub1:secretchat owner=Imm@SomeMUD operators=Other@SomeMUD policy=private invited="SpecialDude@OtherMUD CoolDude@WeirdMUD" level=Mort localname=schat
    """
    pass


class IMC2PacketIceMsgRelayed(IMC2Packet):
    """
    Description:
    The -r in this ice-msg packet means it was relayed. This, along with the
    ice-msg-p packet, are used with private policy channels. The 'r' stands
    for 'relay'. All incoming channel messages are from ICE@<server>, where
    <server> is the server hosting the channel.

    Data:
    realfrom=<string>
    The User@MUD the message came from.

    channel=<string>
    The Server:Channel the message is intended to be displayed on.

    text=<string>
    The message text.

    emote=<int>
    An integer value designating emotes. 0 for no emote, 1 for an emote,
    and 2 for a social.

    Examples:
    ICE@Hub1 1234567890 Hub1!Hub2 ice-msg-r *@YourMUD realfrom=You@YourMUD channel=hub1:secret text="Aha! I got it!" emote=0

    ICE@Hub1 1234567890 Hub1!Hub2 ice-msg-r *@YourMUD realfrom=You@YourMUD channel=hub1:secret text=Ahh emote=0

    ICE@Hub1 1234567890 Hub1!Hub2 ice-msg-r *@YourMUD realfrom=You@YourMUD channel=hub1:secret text="grins evilly." emote=1

    ICE@Hub1 1234567890 Hub1!Hub2 ice-msg-r *@YourMUD realfrom=You@YourMUD channel=hub1:secret text="You@YourMUD grins evilly!" emote=2
    """
    pass


class IMC2PacketIceMsgPrivate(IMC2Packet):
    """
    Description:
    This packet is sent when a player sends a message to a private channel.
    This packet should never be seen as incoming to a client. The target of
    this packet should be IMC@<server> of the server hosting the channel.

    Data:
    channel=<string>
    The Server:Channel the message is intended to be displayed on.

    text=<string>
    The message text.

    emote=<int>
    An integer value designating emotes. 0 for no emote, 1 for an emote,
    and 2 for a social.

    echo=<int>
    Tells the server to echo the message back to the sending MUD. This is only
    seen on out-going messages.

    Examples:
    You@YourMUD 1234567890 YourMUD ice-msg-p IMC@Hub1 channel=Hub1:secret text="Ahh! I got it!" emote=0 echo=1
    You@YourMUD 1234567890 YourMUD ice-msg-p IMC@Hub1 channel=Hub1:secret text=Ahh! emote=0 echo=1
    You@YourMUD 1234567890 YourMUD ice-msg-p IMC@Hub1 channel=Hub1:secret text="grins evilly." emote=1 echo=1
    You@YourMUD 1234567890 YourMUD ice-msg-p IMC@Hub1 channel=Hub1:secret text="You@YourMUD grins evilly." emote=2 echo=1
    """
    pass


class IMC2PacketIceMsgBroadcasted(IMC2Packet):
    """
    Description:
    This is the packet used to chat on open policy channels. When sent from a
    MUD, it is broadcasted across the network. Other MUDs receive it in-tact
    as it was sent by the originating MUD. The server that hosts the channel
    sends the packet back to the originating MUD as an 'echo' by removing the
    "echo=1" and attaching the "sender=Person@MUD" data field.

    Data:
    channel=<string>
    The Server:Channel the message is intended to be displayed on.

    text=<string>
    The message text.

    emote=<int>
    An integer value designating emotes. 0 for no emote, 1 for an emote,
    and 2 for a social.

    *echo=<int>
    This stays on broadcasted messages. It tells the channel's server to
    relay an echo back.

    *sender=<string>
    The hosting server replaces "echo=1" with this when sending the echo back
    to the originating MUD.

    Examples:
    (See above for emote/social examples as they are pretty much the same)

    Return Echo Packet:
    You-YourMUD@Hub1 1234567890 Hub1 ice-msg-b *@YourMUD text=Hi! channel=Hub1:ichat sender=You@YourMUD emote=0

    Broadcasted Packet:
    You@YourMUD 1234567890 YourMUD!Hub1 ice-msg-b *@* channel=Hub1:ichat text=Hi! emote=0 echo=1
    """
    def __init__(self, server, channel, pobject, message):
        """
        Args:
          server: (String) Server name the channel resides on (obs - this is
                           e.g. Server01, not the full network name!)
          channel: (String) Name of the IMC2 channel.
          pobject: (Object) Object sending the message.
          message: (String) Message to send.
        """
        super(IMC2PacketIceMsgBroadcasted, self).__init__()
        self.sender = pobject
        self.packet_type = 'ice-msg-b'
        self.target = '*'
        self.destination = '*'
        self.optional_data = {'channel': '%s:%s' % (server, channel),
                              'text': message,
                              'emote': 0,
                              'echo': 1}


class IMC2PacketUserCache(IMC2Packet):
    """
    Description:
    Sent by a MUD with a new IMC2-able player or when a player's gender changes,
    this packet contains only the gender for data. The packet's origination
    should be the Player@MUD.

    Data:
    gender=<int>  0 is male, 1 is female, 2 is anything else such as neuter.
    Will be referred to as "it".

    Example:
    Dude@someMUD 1234567890 SomeMUD!Hub2!Hub1 user-cache *@* gender=0
    """
    pass


class IMC2PacketUserCacheRequest(IMC2Packet):
    """
    Description:
    The MUD sends this packet out when making a request for the user-cache
    information of the user included in the data part of the packet.

    Data:
    user=<string>  The Person@MUD whose data the MUD is seeking.

    Example:
    *@YourMUD 1234567890 YourMUD user-cache-request *@SomeMUD user=Dude@SomeMUD
    """
    pass


class IMC2PacketUserCacheReply(IMC2Packet):
    """
    Description:
    A reply to the user-cache-request packet. It contains the user and gender
    for the user.

    Data:
    user=<string>
    The Person@MUD whose data the MUD requested.

    gender=<int>
    The gender of the Person@MUD in the 'user' field.

    Example:
    *@someMUD 1234567890 SomeMUD!Hub2!Hub1 user-cache-reply *@YourMUD user=Dude@SomeMUD gender=0
    """
    pass


class IMC2PacketTell(IMC2Packet):
    """
    Description:
    This packet is used to communicate private messages between users on MUDs
    across the network.

    Data:
    text=<string>  Message text
    isreply=<int>  Two settings: 1 denotes a reply, 2 denotes a tell social.

    Example:

    Originating:
    You@YourMUD 1234567890 YourMUD tell Dude@SomeMUD text="Having fun?"

    Reply from Dude:
    Dude@SomeMUD 1234567890 SomeMUD!Hub1 tell You@YourMUD text="Yeah, this is cool!" isreply=1
    """
    def __init__(self, pobject, target, destination, message):
        super(IMC2PacketTell, self).__init__()
        self.sender = pobject
        self.packet_type = "tell"
        self.target = target
        self.destination = destination
        self.optional_data = {"text": message,
                              "isreply":None}

    def assemble(self, mudname=None, client_pwd=None, server_pwd=None):
        self.sequence = self.imc2_protocol.sequence
        #self.route = "%s!%s" % (self.origin, self.imc2_protocol.factory.servername.capitalize())
        return '''"%s@%s %s %s tell %s@%s text="%s"''' % (self.sender, self.origin, self.sequence,
                                                          self.route, self.target, self.destination,
                                                          self.optional_data.get("text","NO TEXT GIVEN"))


class IMC2PacketEmote(IMC2Packet):
    """
    Description:
    This packet seems to be sent by servers when notifying the network of a new
    channel or the destruction of a channel.

    Data:
    channel=<int>
    Unsure of what this means. The channel seen in both creation and
    destruction packets is 15.

    level=<int>
    I am assuming this is the permission level of the sender. In both
    creation and destruction messages, this is -1.

    text=<string>
    This is the message to be sent to the users.

    Examples:
    ICE@Hub1 1234567890 Hub1 emote *@* channel=15 level=-1 text="the
                    channel called hub1:test has been destroyed by You@YourMUD."
    """
    pass


class IMC2PacketRemoteAdmin(IMC2Packet):
    """
    Description:
    This packet is used in remote server administration. Please note that
    SHA-256 Support is *required* for a client to use this feature. The command
    can vary, in fact this very packet is highly dependant on the server it's
    being directed to. In most cases, sending the 'list' command will have a
    remote-admin enabled server send you the list of commands it will accept.

    Data:
    command=<string>
    The command being sent to the server for processing.

    data=<string>
    Data associated with the command. This is not always required.

    hash=<string>
    The SHA-256 hash that is verified by the server. This hash is generated in
    the same manner as an authentication packet.

    Example:
    You@YourMUD 1234567890 YourMUD remote-admin IMC@Hub1 command=list hash=<hash goes here>
    """
    pass


class IMC2PacketIceCmd(IMC2Packet):
    """
    Description:
    Used for remote channel administration. In most cases, one must be listed
    as a channel creator on the target server in order to do much with this
    packet. Other cases include channel operators.

    Data:
    channel=<string>
    The target server:channel for the command.

    command=<string>
    The command to be processed.

    data=<string>
    Data associated with the command. This is not always required.

    Example:
    You@YourMUD 1234567890 YourMUD ice-cmd IMC@hub1 channel=hub1:ichat command=list
    """
    pass


class IMC2PacketDestroy(IMC2Packet):
    """
    Description:
    Sent by a server to indicate the destruction of a channel it hosted.
    The mud should remove this channel from its local configuration.

    Data:
    channel=<string>  The server:channel being destroyed.
    """
    pass


class IMC2PacketWho(IMC2Packet):
    """
    Description:
    A seemingly mutli-purpose information-requesting packet. The istats
    packet currently only works on servers, or at least that's the case on
    MUD-Net servers. The 'finger' type takes a player name in addition to the
    type name.

    Example: "finger Dude". The 'who' and 'info' types take no argument.
    The MUD is responsible for building the reply text sent in the who-reply
    packet.

    Data:
    type=<string>  Types: who, info, "finger <name>", istats (server only)

    Example:
    Dude@SomeMUD 1234567890 SomeMUD!Hub1 who *@YourMUD type=who
    """
    pass


class IMC2PacketWhoReply(IMC2Packet):
    """
    Description:
    The multi-purpose reply to the multi-purpose information-requesting 'who'
    packet. The MUD is responsible for building the return data, including the
    format of it. The mud can use the permission level sent in the original who
    packet to filter the output. The example below is the MUD-Net format.

    Data:
    text=<string>  The formatted reply to a 'who' packet.

    Additional Notes:
    The example below is for the who list packet. The same construction would
    go into formatting the other types of who packets.

    Example:
    *@YourMUD 1234567890 YourMUD who-reply Dude@SomeMUD text="\n\r~R-=< ~WPlayers on YourMUD ~R>=-\n\r            ~Y-=< ~Wtelnet://yourmud.domain.com:1234 ~Y>=-\n\r\n\r~B--------------------------------=< ~WPlayers ~B>=---------------------------------\n\r\n\r      ~BPlayer        ~z<--->~G Mortal the Toy\n\r\n\r~R-------------------------------=< ~WImmortals ~R>=--------------------------------\n\r\n\r      ~YStaff        ~z<--->~G You the Immortal\n\r\n\r~Y<~W2 Players~Y> ~Y<~WHomepage: http://www.yourmud.com~Y> <~W  2 Max Since Reboot~Y>\n\r~Y<~W3 logins since last reboot on Tue Feb 24, 2004 6:55:59 PM EST~Y>"
    """
    pass


class IMC2PacketWhois(IMC2Packet):
    """
    Description:
    Sends a request to the network for the location of the specified player.

    Data:
    level=<int>  The permission level of the person making the request.

    Example:
    You@YourMUD 1234567890 YourMUD whois dude@* level=5
    """
    def __init__(self, pobject_id, whois_target):
        super(IMC2PacketWhois, self).__init__()
        # Use the dbref, it's easier to trace back for the whois-reply.
        self.sender = pobject_id
        self.packet_type = 'whois'
        self.target = whois_target
        self.destination = '*'
        self.optional_data = {'level': '5'}


class IMC2PacketWhoisReply(IMC2Packet):
    """
    Description:
    The reply to a whois packet. The MUD is responsible for building and formatting
    the text sent back to the requesting player, and can use the permission level
    sent in the original whois packet to filter or block the response.

    Data:
    text=<string>  The whois text.

    Example:
    *@SomeMUD 1234567890 SomeMUD!Hub1 whois-reply You@YourMUD text="~RIMC Locate: ~YDude@SomeMUD: ~cOnline.\n\r"
    """
    pass


class IMC2PacketBeep(IMC2Packet):
    """
    Description:
    Sends out a beep packet to the Player@MUD. The client receiving this should
    then send a bell-character to the target player to 'beep' them.

    Example:
    You@YourMUD 1234567890 YourMUD beep dude@somemud
    """
    pass


class IMC2PacketIceChanWho(IMC2Packet):
    """
    Description:
    Sends a request to the specified MUD or * to list all the users listening
    to the specified channel.

    Data:
    level=<int>
    Sender's permission level.

    channel=<string>
    The server:chan name of the channel.

    lname=<string>
    The localname of the channel.

    Example:
    You@YourMUD 1234567890 YourMUD ice-chan-who somemud level=5 channel=Hub1:ichat lname=ichat
    """
    pass


class IMC2PacketIceChanWhoReply(IMC2Packet):
    """
    Description:
    This is the reply packet for an ice-chan-who. The MUD is responsible for
    creating and formatting the list sent back in the 'list' field. The
    permission level sent in the original ice-chan-who packet can be used to
    filter or block the response.

    Data:
    channel=<string>
    The server:chan of the requested channel.

    list=<string>
    The formatted list of local listeners for that MUD.

    Example:
    *@SomeMUD 1234567890 SomeMUD!Hub1 ice-chan-whoreply You@YourMUD channel=Hub1:ichat list="The following people are listening to ichat on SomeMUD:\n\r\n\rDude\n\r"
    """
    pass


class IMC2PacketLaston(IMC2Packet):
    """
    Description:
    This packet queries the server the mud is connected to to find out when a
    specified user was last seen by the network on a public channel.

    Data:
    username=<string>  The user, user@mud, or "all" being queried. Responses
    to this packet will be sent by the server in the form of a series of tells.

    Example: User@MUD 1234567890 MUD imc-laston SERVER username=somenamehere
    """
    pass


class IMC2PacketCloseNotify(IMC2Packet):
    """
    Description:
    This packet alerts the network when a server or MUD has disconnected. The
    server hosting the server or MUD is responsible for sending this packet
    out across the network. Clients need only process the packet to remove the
    disconnected MUD from their MUD list (or mark it as Disconnected).

    Data:
    host=<string>
    The MUD or server that has disconnected from the network.

    Example:
    *@Hub2 1234567890 Hub2!Hub1 close-notify *@* host=DisconnMUD
    """
    pass

if __name__ == "__main__":
    packstr = "Kayle@MW 1234567 MW!Server02!Server01 ice-msg-b *@* channel=Server01:ichat text=\"*they're going woot\" emote=0 echo=1"
    packstr = "*@Lythelian 1234567 Lythelian!Server01 is-alive *@* versionid=\"Tim's LPC IMC2 client 30-Jan-05 / Dead Souls integrated\" networkname=Mudbytes url=http://dead-souls.net host=70.32.76.142 port=6666 sha256=0"
    print IMC2Packet(packstr)


########NEW FILE########
__FILENAME__ = irc
"""
This connects to an IRC network/channel and launches an 'bot' onto it.
The bot then pipes what is being said between the IRC channel and one or
more Evennia channels.
"""

from twisted.application import internet
from twisted.words.protocols import irc
from twisted.internet import protocol
from src.server.session import Session
from src.utils import logger


# IRC bot

class IRCBot(irc.IRCClient, Session):
    """
    An IRC bot that tracks actitivity in a channel as well
    as sends text to it when prompted
    """
    lineRate = 1

    # assigned by factory at creation

    nickname = None
    logger = None
    factory = None
    channel = None

    def signedOn(self):
        """
        This is called when we successfully connect to
        the network. We make sure to now register with
        the game as a full session.
        """
        self.join(self.channel)
        self.stopping = False
        self.factory.bot = self
        address = "%s@%s" % (self.channel, self.network)
        self.init_session("ircbot", address, self.factory.sessionhandler)
        # we link back to our bot and log in
        self.uid = int(self.factory.uid)
        self.logged_in = True
        self.factory.sessionhandler.connect(self)
        logger.log_infomsg("IRC bot '%s' connected to %s at %s:%s." % (self.nickname, self.channel,
                                                                              self.network, self.port))

    def disconnect(self, reason=None):
        """
        Called by sessionhandler to disconnect this protocol
        """
        print "irc disconnect called!"
        self.sessionhandler.disconnect(self)
        self.stopping = True
        self.transport.loseConnection()

    def privmsg(self, user, channel, msg):
        "A message was sent to channel"
        if not msg.startswith('***'):
            user = user.split('!', 1)[0]
            self.data_in("bot_data_in %s@%s: %s" % (user, channel, msg))

    def action(self, user, channel, msg):
        "An action was done in channel"
        if not msg.startswith('**'):
            user = user.split('!', 1)[0]
            self.data_in("bot_data_in %s@%s %s" % (user, channel, msg))

    def data_in(self, text=None, **kwargs):
        "Data IRC -> Server"
        self.sessionhandler.data_in(self, text=text, **kwargs)

    def data_out(self, text=None, **kwargs):
        "Data from server-> IRC"
        if text.startswith("bot_data_out"):
            text = text.split(" ", 1)[1]
            self.say(self.channel, text)


class IRCBotFactory(protocol.ReconnectingClientFactory):
    """
    Creates instances of AnnounceBot, connecting with
    a staggered increase in delay
    """
    # scaling reconnect time
    initialDelay = 1
    factor = 1.5
    maxDelay = 60

    def __init__(self, sessionhandler, uid=None, botname=None, channel=None, network=None, port=None):
        "Storing some important protocol properties"
        self.sessionhandler = sessionhandler
        self.uid = uid
        self.nickname = str(botname)
        self.channel = str(channel)
        self.network = str(network)
        self.port = port
        self.bot = None

    def buildProtocol(self, addr):
        "Build the protocol and assign it some properties"
        protocol = IRCBot()
        protocol.factory = self
        protocol.nickname = self.nickname
        protocol.channel = self.channel
        protocol.network = self.network
        protocol.port = self.port
        return protocol

    def startedConnecting(self, connector):
        "Tracks reconnections for debugging"
        logger.log_infomsg("(re)connecting to %s" % self.channel)

    def clientConnectionFailed(self, connector, reason):
        self.retry(connector)

    def clientConnectionLost(self, connector, reason):
        if not self.bot.stopping:
            self.retry(connector)

    def start(self):
        "Connect session to sessionhandler"
        if self.port:
            service = internet.TCPClient(self.network, int(self.port), self)
            self.sessionhandler.portal.services.addService(service)

########NEW FILE########
__FILENAME__ = mccp
"""

MCCP - Mud Client Compression Protocol

This implements the MCCP v2 telnet protocol as per
http://tintin.sourceforge.net/mccp/. MCCP allows for the server to
compress data when sending to supporting clients, reducing bandwidth
by 70-90%.. The compression is done using Python's builtin zlib
library. If the client doesn't support MCCP, server sends uncompressed
as normal.  Note: On modern hardware you are not likely to notice the
effect of MCCP unless you have extremely heavy traffic or sits on a
terribly slow connection.

This protocol is implemented by the telnet protocol importing
mccp_compress and calling it from its write methods.
"""
import zlib

# negotiations for v1 and v2 of the protocol
MCCP = chr(86)
FLUSH = zlib.Z_SYNC_FLUSH


def mccp_compress(protocol, data):
    "Handles zlib compression, if applicable"
    if hasattr(protocol, 'zlib'):
        return protocol.zlib.compress(data) + protocol.zlib.flush(FLUSH)
    return data


class Mccp(object):
    """
    Implements the MCCP protocol. Add this to a
    variable on the telnet protocol to set it up.
    """

    def __init__(self, protocol):
        """
        initialize MCCP by storing protocol on
        ourselves and calling the client to see if
        it supports MCCP. Sets callbacks to
        start zlib compression in that case.
        """

        self.protocol = protocol
        self.protocol.protocol_flags['MCCP'] = False
        # ask if client will mccp, connect callbacks to handle answer
        self.protocol.will(MCCP).addCallbacks(self.do_mccp, self.no_mccp)

    def no_mccp(self, option):
        """
        Called if client doesn't support mccp or chooses to turn it off
        """
        if hasattr(self.protocol, 'zlib'):
            del self.protocol.zlib
        self.protocol.protocol_flags['MCCP'] = False

    def do_mccp(self, option):
        """
        The client supports MCCP. Set things up by
        creating a zlib compression stream.
        """
        self.protocol.protocol_flags['MCCP'] = True
        self.protocol.requestNegotiation(MCCP, '')
        self.protocol.zlib = zlib.compressobj(9)

########NEW FILE########
__FILENAME__ = msdp
"""

MSDP (Mud Server Data Protocol)

This implements the MSDP protocol as per
http://tintin.sourceforge.net/msdp/.  MSDP manages out-of-band
communication between the client and server, for updating health bars
etc.

"""
import re
from src.utils.utils import to_str

# MSDP-relevant telnet cmd/opt-codes
MSDP = chr(69)
MSDP_VAR = chr(1)
MSDP_VAL = chr(2)
MSDP_TABLE_OPEN = chr(3)
MSDP_TABLE_CLOSE = chr(4)
MSDP_ARRAY_OPEN = chr(5)
MSDP_ARRAY_CLOSE = chr(6)

IAC = chr(255)
SB = chr(250)
SE = chr(240)

force_str = lambda inp: to_str(inp, force_string=True)

# pre-compiled regexes
# returns 2-tuple
regex_array = re.compile(r"%s(.*?)%s%s(.*?)%s" % (MSDP_VAR, MSDP_VAL,
                                                  MSDP_ARRAY_OPEN,
                                                  MSDP_ARRAY_CLOSE))
# returns 2-tuple (may be nested)
regex_table = re.compile(r"%s(.*?)%s%s(.*?)%s" % (MSDP_VAR, MSDP_VAL,
                                                  MSDP_TABLE_OPEN,
                                                  MSDP_TABLE_CLOSE))
regex_var = re.compile(MSDP_VAR)
regex_val = re.compile(MSDP_VAL)


# Msdp object handler

class Msdp(object):
    """
    Implements the MSDP protocol.
    """

    def __init__(self, protocol):
        """
        Initiates by storing the protocol
        on itself and trying to determine
        if the client supports MSDP.
        """
        self.protocol = protocol
        self.protocol.protocol_flags['MSDP'] = False
        self.protocol.negotiationMap[MSDP] = self.msdp_to_evennia
        self.protocol.will(MSDP).addCallbacks(self.do_msdp, self.no_msdp)
        self.msdp_reported = {}

    def no_msdp(self, option):
        "No msdp supported or wanted"
        pass

    def do_msdp(self, option):
        """
        Called when client confirms that it can do MSDP.
        """
        self.protocol.protocol_flags['MSDP'] = True

    def evennia_to_msdp(self, cmdname, *args, **kwargs):
        """
        handle return data from cmdname by converting it to
        a proper msdp structure. data can either be a single value (will be
        converted to a string), a list (will be converted to an MSDP_ARRAY),
        or a dictionary (will be converted to MSDP_TABLE).

        OBS - there is no actual use of arrays and tables in the MSDP
        specification or default commands -- are returns are implemented
        as simple lists or named lists (our name for them here, these
        un-bounded structures are not named in the specification). So for
        now, this routine will not explicitly create arrays nor tables,
        although there are helper methods ready should it be needed in
        the future.
        """

        def make_table(name, **kwargs):
            "build a table that may be nested with other tables or arrays."
            string = MSDP_VAR + force_str(name) + MSDP_VAL + MSDP_TABLE_OPEN
            for key, val in kwargs.items():
                if isinstance(val, dict):
                    string += make_table(string, key, **val)
                elif hasattr(val, '__iter__'):
                    string += make_array(string, key, *val)
                else:
                    string += MSDP_VAR + force_str(key) + MSDP_VAL + force_str(val)
            string += MSDP_TABLE_CLOSE
            return string

        def make_array(name, *args):
            "build a array. Arrays may not nest tables by definition."
            string = MSDP_VAR + force_str(name) + MSDP_ARRAY_OPEN
            string += MSDP_VAL.join(force_str(arg) for arg in args)
            string += MSDP_ARRAY_CLOSE
            return string

        def make_list(name, *args):
            "build a simple list - an array without start/end markers"
            string = MSDP_VAR + force_str(name)
            string += MSDP_VAL.join(force_str(arg) for arg in args)
            return string

        def make_named_list(name, **kwargs):
            "build a named list - a table without start/end markers"
            string = MSDP_VAR + force_str(name)
            for key, val in kwargs.items():
                string += MSDP_VAR + force_str(key) + MSDP_VAL + force_str(val)
            return string

        # Default MSDP commands

        print "MSDP outgoing:", cmdname, args, kwargs

        cupper = cmdname.upper()
        if cupper == "LIST":
            if args:
                args = list(args)
                mode = args.pop(0).upper()
            self.data_out(make_array(mode, *args))
        elif cupper == "REPORT":
            self.data_out(make_list("REPORT", *args))
        elif cupper == "UNREPORT":
            self.data_out(make_list("UNREPORT", *args))
        elif cupper == "RESET":
            self.data_out(make_list("RESET", *args))
        elif cupper == "SEND":
            self.data_out(make_named_list("SEND", **kwargs))
        else:
            # return list or named lists.
            msdp_string = ""
            if args:
                msdp_string += make_list(cupper, *args)
            if kwargs:
                msdp_string += make_named_list(cupper, **kwargs)
            self.data_out(msdp_string)

    def msdp_to_evennia(self, data):
        """
        Handle a client's requested negotiation, converting
        it into a function mapping - either one of the MSDP
        default functions (LIST, SEND etc) or a custom one
        in OOB_FUNCS dictionary. command names are case-insensitive.

        varname, var  --> mapped to function varname(var)
        arrayname, array --> mapped to function arrayname(*array)
        tablename, table --> mapped to function tablename(**table)

        Note: Combinations of args/kwargs to one function is not supported
        in this implementation (it complicates the code for limited
        gain - arrayname(*array) is usually as complex as anyone should
        ever need to go anyway (I hope!).

        """
        tables = {}
        arrays = {}
        variables = {}

        if hasattr(data, "__iter__"):
            data = "".join(data)

        #logger.log_infomsg("MSDP SUBNEGOTIATION: %s" % data)

        for key, table in regex_table.findall(data):
            tables[key] = {}
            for varval in regex_var.split(table):
                parts = regex_val.split(varval)
                tables[key].expand({parts[0]: tuple(parts[1:]) if len(parts) > 1 else ("",)})
        for key, array in regex_array.findall(data):
            arrays[key] = []
            for val in regex_val.split(array):
                arrays[key].append(val)
            arrays[key] = tuple(arrays[key])
        for varval in regex_var.split(regex_array.sub("", regex_table.sub("", data))):
            # get remaining varvals after cleaning away tables/arrays
            parts = regex_val.split(varval)
            variables[parts[0].upper()] = tuple(parts[1:]) if len(parts) > 1 else ("", )

        #print "MSDP: table, array, variables:", tables, arrays, variables

        # all variables sent through msdp to Evennia are considered commands
        # with arguments. There are three forms of commands possible
        # through msdp:
        #
        # VARNAME VAR -> varname(var)
        # ARRAYNAME VAR VAL VAR VAL VAR VAL ENDARRAY -> arrayname(val,val,val)
        # TABLENAME TABLE VARNAME VAL VARNAME VAL ENDTABLE ->
        #                                    tablename(varname=val, varname=val)
        #

        # default MSDP functions
        if "LIST" in variables:
            self.data_in("list", *variables.pop("LIST"))
        if "REPORT" in variables:
            self.data_in("report", *variables.pop("REPORT"))
        if "REPORT" in arrays:
            self.data_in("report", *(arrays.pop("REPORT")))
        if "UNREPORT" in variables:
            self.data_in("unreport", *(arrays.pop("UNREPORT")))
        if "RESET" in variables:
            self.data_in("reset", *variables.pop("RESET"))
        if "RESET" in arrays:
            self.data_in("reset", *(arrays.pop("RESET")))
        if "SEND" in variables:
            self.data_in("send", *variables.pop("SEND"))
        if "SEND" in arrays:
            self.data_in("send", *(arrays.pop("SEND")))

        # if there are anything left consider it a call to a custom function

        for varname, var in variables.items():
            # a simple function + argument
            self.data_in(varname, (var,))
        for arrayname, array in arrays.items():
            # we assume the array are multiple arguments to the function
            self.data_in(arrayname, *array)
        for tablename, table in tables.items():
            # we assume tables are keyword arguments to the function
            self.data_in(tablename, **table)

    def data_out(self, msdp_string):
        """
        Return a msdp-valid subnegotiation across the protocol.
        """
        #print "msdp data_out (without IAC SE):", msdp_string
        self.protocol ._write(IAC + SB + MSDP + force_str(msdp_string) + IAC + SE)

    def data_in(self, funcname, *args, **kwargs):
        """
        Send oob data to Evennia
        """
        #print "msdp data_in:", funcname, args, kwargs
        self.protocol.data_in(text=None, oob=(funcname, args, kwargs))

########NEW FILE########
__FILENAME__ = mssp
"""

MSSP - Mud Server Status Protocol

This implements the MSSP telnet protocol as per
http://tintin.sourceforge.net/mssp/.  MSSP allows web portals and
listings to have their crawlers find the mud and automatically
extract relevant information about it, such as genre, how many
active players and so on.


"""
from django.conf import settings
from src.utils import utils

MSSP = chr(70)
MSSP_VAR = chr(1)
MSSP_VAL = chr(2)


# try to get the customized mssp info, if it exists.
MSSPTable_CUSTOM = utils.variable_from_module(settings.MSSP_META_MODULE, "MSSPTable", default={})

class Mssp(object):
    """
    Implements the MSSP protocol. Add this to a
    variable on the telnet protocol to set it up.
    """
    def __init__(self, protocol):
        """
        initialize MSSP by storing protocol on ourselves
        and calling the client to see if it supports
        MSSP.
        """
        self.protocol = protocol
        self.protocol.will(MSSP).addCallbacks(self.do_mssp, self.no_mssp)

    def get_player_count(self):
        "Get number of logged-in players"
        return str(self.protocol.sessionhandler.count_loggedin())

    def get_uptime(self):
        "Get how long the portal has been online (reloads are not counted)"
        return str(self.protocol.sessionhandler.uptime)

    def no_mssp(self, option):
        """
        This is the normal operation.
        """
        pass

    def do_mssp(self, option):
        """
        Negotiate all the information.
        """

        self.mssp_table =  {

        # Required fields

        "NAME":               "Evennia",
        "PLAYERS":            self.get_player_count,
        "UPTIME" :            self.get_uptime,

        # Generic

        "CRAWL DELAY":        "-1",

        "HOSTNAME":           "",       # current or new hostname
        "PORT":               ["4000"], # most important port should be last in list
        "CODEBASE":           "Evennia",
        "CONTACT":            "",       # email for contacting the mud
        "CREATED":            "",       # year MUD was created
        "ICON":               "",       # url to icon 32x32 or larger; <32kb.
        "IP":                 "",       # current or new IP address
        "LANGUAGE":           "",       # name of language used, e.g. English
        "LOCATION":           "",       # full English name of server country
        "MINIMUM AGE":        "0",      # set to 0 if not applicable
        "WEBSITE":            "www.evennia.com",

        # Categorisation

        "FAMILY":             "Custom", # evennia goes under 'Custom'
        "GENRE":              "None",   # Adult, Fantasy, Historical, Horror, Modern, None, or Science Fiction
        "GAMEPLAY":           "None",   # Adventure, Educational, Hack and Slash, None,
                                        # Player versus Player, Player versus Environment,
                                        # Roleplaying, Simulation, Social or Strategy
        "STATUS":             "Open Beta",  # Alpha, Closed Beta, Open Beta, Live
        "GAMESYSTEM":         "Custom", # D&D, d20 System, World of Darkness, etc. Use Custom if homebrew
        "INTERMUD":           "IMC2",   # evennia supports IMC2.
        "SUBGENRE":           "None",   # LASG, Medieval Fantasy, World War II, Frankenstein,
                                        # Cyberpunk, Dragonlance, etc. Or None if not available.

        # World

        "AREAS":              "0",
        "HELPFILES":          "0",
        "MOBILES":            "0",
        "OBJECTS":            "0",
        "ROOMS":              "0",      # use 0 if room-less
        "CLASSES":            "0",      # use 0 if class-less
        "LEVELS":             "0",      # use 0 if level-less
        "RACES":              "0",      # use 0 if race-less
        "SKILLS":             "0",      # use 0 if skill-less

        # Protocols set to 1 or 0)

        "ANSI":               "1",
        "GMCP":               "0",
        "MCCP":               "0",
        "MCP":                "0",
        "MSDP":               "0",
        "MSP":                "0",
        "MXP":                "0",
        "PUEBLO":             "0",
        "UTF-8":              "1",
        "VT100":              "0",
        "XTERM 256 COLORS":   "0",

        # Commercial set to 1 or 0)

        "PAY TO PLAY":        "0",
        "PAY FOR PERKS":      "0",

        # Hiring  set to 1 or 0)

        "HIRING BUILDERS":    "0",
        "HIRING CODERS":      "0",

        # Extended variables

        # World

        "DBSIZE":             "0",
        "EXITS":              "0",
        "EXTRA DESCRIPTIONS": "0",
        "MUDPROGS":           "0",
        "MUDTRIGS":           "0",
        "RESETS":             "0",

        # Game (set to 1, 0 or one of the given alternatives)

        "ADULT MATERIAL":     "0",
        "MULTICLASSING":      "0",
        "NEWBIE FRIENDLY":    "0",
        "PLAYER CITIES":      "0",
        "PLAYER CLANS":       "0",
        "PLAYER CRAFTING":    "0",
        "PLAYER GUILDS":      "0",
        "EQUIPMENT SYSTEM":   "None",  # "None", "Level", "Skill", "Both"
        "MULTIPLAYING":       "None",  # "None", "Restricted", "Full"
        "PLAYERKILLING":      "None",  # "None", "Restricted", "Full"
        "QUEST SYSTEM":       "None",  # "None", "Immortal Run", "Automated", "Integrated"
        "ROLEPLAYING":        "None",  # "None", "Accepted", "Encouraged", "Enforced"
        "TRAINING SYSTEM":    "None",  # "None", "Level", "Skill", "Both"
        "WORLD ORIGINALITY":  "None",  # "All Stock", "Mostly Stock", "Mostly Original", "All Original"

        # Protocols (only change if you added/removed something manually)

        "ATCP":               "0",
        "MSDP":               "0",
        "MCCP":               "1",
        "SSL":                "1",
        "UTF-8":              "1",
        "ZMP":                "0",
        "XTERM 256 COLORS":   "0"}

        # update the static table with the custom one
        if MSSPTable_CUSTOM:
            self.mssp_table.update(MSSPTable_CUSTOM)

        varlist = ''
        for variable, value in self.mssp_table.items():
            if callable(value):
                value = value()
            if utils.is_iter(value):
                for partval in value:
                    varlist += MSSP_VAR + str(variable) + MSSP_VAL + str(partval)
            else:
                varlist += MSSP_VAR + str(variable) + MSSP_VAL + str(value)

        # send to crawler by subnegotiation
        self.protocol.requestNegotiation(MSSP, varlist)

########NEW FILE########
__FILENAME__ = portal
"""
This module implements the main Evennia server process, the core of
the game engine.

This module should be started with the 'twistd' executable since it
sets up all the networking features.  (this is done automatically
by game/evennia.py).

"""

import sys
import os
if os.name == 'nt':
    # For Windows batchfile we need an extra path insertion here.
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(
                os.path.dirname(os.path.abspath(__file__))))))
from src.server.webserver import EvenniaReverseProxyResource
from twisted.application import internet, service
from twisted.internet import protocol, reactor
from twisted.web import server
from django.conf import settings
from src.utils.utils import get_evennia_version, mod_import, make_iter
from src.server.portal.portalsessionhandler import PORTAL_SESSIONS

PORTAL_SERVICES_PLUGIN_MODULES = [mod_import(module) for module in make_iter(settings.PORTAL_SERVICES_PLUGIN_MODULES)]

if os.name == 'nt':
    # For Windows we need to handle pid files manually.
    PORTAL_PIDFILE = os.path.join(settings.GAME_DIR, 'portal.pid')

#------------------------------------------------------------
# Evennia Portal settings
#------------------------------------------------------------

VERSION = get_evennia_version()

SERVERNAME = settings.SERVERNAME

PORTAL_RESTART = os.path.join(settings.GAME_DIR, 'portal.restart')

TELNET_PORTS = settings.TELNET_PORTS
SSL_PORTS = settings.SSL_PORTS
SSH_PORTS = settings.SSH_PORTS
WEBSERVER_PORTS = settings.WEBSERVER_PORTS
WEBSOCKET_PORTS = settings.WEBSOCKET_PORTS

TELNET_INTERFACES = settings.TELNET_INTERFACES
SSL_INTERFACES = settings.SSL_INTERFACES
SSH_INTERFACES = settings.SSH_INTERFACES
WEBSERVER_INTERFACES = settings.WEBSERVER_INTERFACES
WEBSOCKET_INTERFACES = settings.WEBSOCKET_INTERFACES

TELNET_ENABLED = settings.TELNET_ENABLED and TELNET_PORTS and TELNET_INTERFACES
SSL_ENABLED = settings.SSL_ENABLED and SSL_PORTS and SSL_INTERFACES
SSH_ENABLED = settings.SSH_ENABLED and SSH_PORTS and SSH_INTERFACES
WEBSERVER_ENABLED = settings.WEBSERVER_ENABLED and WEBSERVER_PORTS and WEBSERVER_INTERFACES
WEBCLIENT_ENABLED = settings.WEBCLIENT_ENABLED
WEBSOCKET_ENABLED = settings.WEBSOCKET_ENABLED and WEBSOCKET_PORTS and WEBSOCKET_INTERFACES

AMP_HOST = settings.AMP_HOST
AMP_PORT = settings.AMP_PORT
AMP_INTERFACE = settings.AMP_INTERFACE
AMP_ENABLED = AMP_HOST and AMP_PORT and AMP_INTERFACE


#------------------------------------------------------------
# Portal Service object
#------------------------------------------------------------
class Portal(object):

    """
    The main Portal server handler. This object sets up the database and
    tracks and interlinks all the twisted network services that make up
    Portal.
    """

    def __init__(self, application):
        """
        Setup the server.

        application - an instantiated Twisted application

        """
        sys.path.append('.')

        # create a store of services
        self.services = service.IServiceCollection(application)
        self.amp_protocol = None  # set by amp factory
        self.sessions = PORTAL_SESSIONS
        self.sessions.portal = self

        # set a callback if the server is killed abruptly,
        # by Ctrl-C, reboot etc.
        reactor.addSystemEventTrigger('before', 'shutdown', self.shutdown, _reactor_stopping=True)

        self.game_running = False

    def set_restart_mode(self, mode=None):
        """
        This manages the flag file that tells the runner if the server should
        be restarted or is shutting down. Valid modes are True/False and None.
        If mode is None, no change will be done to the flag file.
        """
        if mode is None:
            return
        f = open(PORTAL_RESTART, 'w')
        print "writing mode=%(mode)s to %(portal_restart)s" % {'mode': mode, 'portal_restart': PORTAL_RESTART}
        f.write(str(mode))
        f.close()

    def shutdown(self, restart=None, _reactor_stopping=False):
        """
        Shuts down the server from inside it.

        restart - True/False sets the flags so the server will be
                  restarted or not. If None, the current flag setting
                  (set at initialization or previous runs) is used.
        _reactor_stopping - this is set if server is already in the process of
                  shutting down; in this case we don't need to stop it again.

        Note that restarting (regardless of the setting) will not work
        if the Portal is currently running in daemon mode. In that
        case it always needs to be restarted manually.
        """
        if _reactor_stopping and hasattr(self, "shutdown_complete"):
            # we get here due to us calling reactor.stop below. No need
            # to do the shutdown procedure again.
            return
        self.set_restart_mode(restart)
        if os.name == 'nt' and os.path.exists(PORTAL_PIDFILE):
            # for Windows we need to remove pid files manually
            os.remove(PORTAL_PIDFILE)
        if not _reactor_stopping:
            # shutting down the reactor will trigger another signal. We set
            # a flag to avoid loops.
            self.shutdown_complete = True
            reactor.callLater(0, reactor.stop)

#------------------------------------------------------------
#
# Start the Portal proxy server and add all active services
#
#------------------------------------------------------------

# twistd requires us to define the variable 'application' so it knows
# what to execute from.
application = service.Application('Portal')

# The main Portal server program. This sets up the database
# and is where we store all the other services.
PORTAL = Portal(application)

print '-' * 50
print ' %(servername)s Portal (%(version)s) started.' % {'servername': SERVERNAME, 'version': VERSION}

if AMP_ENABLED:

    # The AMP protocol handles the communication between
    # the portal and the mud server. Only reason to ever deactivate
    # it would be during testing and debugging.

    from src.server import amp

    print '  amp (to Server): %s' % AMP_PORT

    factory = amp.AmpClientFactory(PORTAL)
    amp_client = internet.TCPClient(AMP_HOST, AMP_PORT, factory)
    amp_client.setName('evennia_amp')
    PORTAL.services.addService(amp_client)


# We group all the various services under the same twisted app.
# These will gradually be started as they are initialized below.

if TELNET_ENABLED:

    # Start telnet game connections

    from src.server.portal import telnet

    for interface in TELNET_INTERFACES:
        ifacestr = ""
        if interface not in ('0.0.0.0', '::') or len(TELNET_INTERFACES) > 1:
            ifacestr = "-%s" % interface
        for port in TELNET_PORTS:
            pstring = "%s:%s" % (ifacestr, port)
            factory = protocol.ServerFactory()
            factory.protocol = telnet.TelnetProtocol
            factory.sessionhandler = PORTAL_SESSIONS
            telnet_service = internet.TCPServer(port, factory, interface=interface)
            telnet_service.setName('EvenniaTelnet%s' % pstring)
            PORTAL.services.addService(telnet_service)

            print '  telnet%s: %s' % (ifacestr, port)


if SSL_ENABLED:

    # Start SSL game connection (requires PyOpenSSL).

    from src.server.portal import ssl

    for interface in SSL_INTERFACES:
        ifacestr = ""
        if interface not in ('0.0.0.0', '::') or len(SSL_INTERFACES) > 1:
            ifacestr = "-%s" % interface
        for port in SSL_PORTS:
            pstring = "%s:%s" % (ifacestr, port)
            factory = protocol.ServerFactory()
            factory.sessionhandler = PORTAL_SESSIONS
            factory.protocol = ssl.SSLProtocol
            ssl_service = internet.SSLServer(port,
                                             factory,
                                             ssl.getSSLContext(),
                                             interface=interface)
            ssl_service.setName('EvenniaSSL%s' % pstring)
            PORTAL.services.addService(ssl_service)

            print "  ssl%s: %s" % (ifacestr, port)


if SSH_ENABLED:

    # Start SSH game connections. Will create a keypair in
    # evennia/game if necessary.

    from src.server.portal import ssh

    for interface in SSH_INTERFACES:
        ifacestr = ""
        if interface not in ('0.0.0.0', '::') or len(SSH_INTERFACES) > 1:
            ifacestr = "-%s" % interface
        for port in SSH_PORTS:
            pstring = "%s:%s" % (ifacestr, port)
            factory = ssh.makeFactory({'protocolFactory': ssh.SshProtocol,
                                       'protocolArgs': (),
                                       'sessions': PORTAL_SESSIONS})
            ssh_service = internet.TCPServer(port, factory, interface=interface)
            ssh_service.setName('EvenniaSSH%s' % pstring)
            PORTAL.services.addService(ssh_service)

            print "  ssl%s: %s" % (ifacestr, port)


if WEBSERVER_ENABLED:

    # Start a reverse proxy to relay data to the Server-side webserver

    for interface in WEBSERVER_INTERFACES:
        ifacestr = ""
        if interface not in ('0.0.0.0', '::') or len(WEBSERVER_INTERFACES) > 1:
            ifacestr = "-%s" % interface
        for proxyport, serverport in WEBSERVER_PORTS:
            pstring = "%s:%s<->%s" % (ifacestr, proxyport, serverport)
            web_root = EvenniaReverseProxyResource('127.0.0.1', serverport, '')
            webclientstr = ""
            if WEBCLIENT_ENABLED:
                # create ajax client processes at /webclientdata
                from src.server.portal.webclient import WebClient
                webclient = WebClient()
                webclient.sessionhandler = PORTAL_SESSIONS
                web_root.putChild("webclientdata", webclient)
                webclientstr = "/client"

            web_root = server.Site(web_root, logPath=settings.HTTP_LOG_FILE)
            proxy_service = internet.TCPServer(proxyport,
                                               web_root,
                                               interface=interface)
            proxy_service.setName('EvenniaWebProxy%s' % pstring)
            PORTAL.services.addService(proxy_service)
            print "  webproxy%s%s:%s (<-> %s)" % (webclientstr, ifacestr, proxyport, serverport)


if WEBSOCKET_ENABLED:
    # websocket support is experimental!

    # start websocket ports for real-time web communication

    from src.server.portal import websocket
    from src.utils.txws import WebSocketFactory

    for interface in WEBSOCKET_INTERFACES:
        ifacestr = ""
        if interface not in ('0.0.0.0', '::') or len(WEBSOCKET_INTERFACES) > 1:
            ifacestr = "-%s" % interface
        for port in WEBSOCKET_PORTS:
            pstring = "%s:%s" % (ifacestr, port)
            factory = protocol.ServerFactory()
            factory.protocol = websocket.WebSocketProtocol
            factory.sessionhandler = PORTAL_SESSIONS
            websocket_service = internet.TCPServer(port, WebSocketFactory(factory), interface=interface)
            websocket_service.setName('EvenniaWebSocket%s' % pstring)
            PORTAL.services.addService(websocket_service)

            print '  websocket%s: %s' % (ifacestr, port)

for plugin_module in PORTAL_SERVICES_PLUGIN_MODULES:
    # external plugin services to start
    plugin_module.start_plugin_services(PORTAL)

print '-' * 50  # end of terminal output

if os.name == 'nt':
    # Windows only: Set PID file manually
    f = open(os.path.join(settings.GAME_DIR, 'portal.pid'), 'w')
    f.write(str(os.getpid()))
    f.close()

########NEW FILE########
__FILENAME__ = portalsessionhandler
"""
Sessionhandler for portal sessions
"""
import time
from src.server.sessionhandler import SessionHandler, PCONN, PDISCONN

_MOD_IMPORT = None

#------------------------------------------------------------
# Portal-SessionHandler class
#------------------------------------------------------------
class PortalSessionHandler(SessionHandler):
    """
    This object holds the sessions connected to the portal at any time.
    It is synced with the server's equivalent SessionHandler over the AMP
    connection.

    Sessions register with the handler using the connect() method. This
    will assign a new unique sessionid to the session and send that sessid
    to the server using the AMP connection.

    """

    def __init__(self):
        """
        Init the handler
        """
        self.portal = None
        self.sessions = {}
        self.latest_sessid = 0
        self.uptime = time.time()
        self.connection_time = 0

    def at_server_connection(self):
        """
        Called when the Portal establishes connection with the
        Server. At this point, the AMP connection is already
        established.
        """
        self.connection_time = time.time()

    def connect(self, session):
        """
        Called by protocol at first connect. This adds a not-yet
        authenticated session using an ever-increasing counter for sessid.
        """
        self.latest_sessid += 1
        sessid = self.latest_sessid
        session.sessid = sessid
        sessdata = session.get_sync_data()
        self.sessions[sessid] = session
        # sync with server-side
        if self.portal.amp_protocol:  # this is a timing issue
            self.portal.amp_protocol.call_remote_ServerAdmin(sessid,
                                                         operation=PCONN,
                                                         data=sessdata)

    def disconnect(self, session):
        """
        Called from portal side when the connection is closed
        from the portal side.
        """
        sessid = session.sessid
        if sessid in self.sessions:
            del self.sessions[sessid]
        del session
        # tell server to also delete this session
        self.portal.amp_protocol.call_remote_ServerAdmin(sessid,
                                                         operation=PDISCONN)


    def server_connect(self, protocol_path="", config=dict()):
        """
        Called by server to force the initialization of a new
        protocol instance. Server wants this instance to get
        a unique sessid and to be connected back as normal. This
        is used to initiate irc/imc2/rss etc connections.

        protocol_path - full python path to the class factory
                    for the protocol used, eg
                    'src.server.portal.irc.IRCClientFactory'
        config - dictionary of configuration options, fed as **kwarg
                 to protocol class' __init__ method.

        The called protocol class must have a method start()
        that calls the portalsession.connect() as a normal protocol.
        """
        global _MOD_IMPORT
        if not _MOD_IMPORT:
            from src.utils.utils import variable_from_module as _MOD_IMPORT
        path, clsname = protocol_path.rsplit(".", 1)
        cls = _MOD_IMPORT(path, clsname)
        if not cls:
            raise RuntimeError("ServerConnect: protocol factory '%s' not found." % protocol_path)
        protocol = cls(self, **config)
        protocol.start()

    def server_disconnect(self, sessid, reason=""):
        """
        Called by server to force a disconnect by sessid
        """
        session = self.sessions.get(sessid, None)
        if session:
            session.disconnect(reason)
            if sessid in self.sessions:
                # in case sess.disconnect doesn't delete it
                del self.sessions[sessid]
            del session

    def server_disconnect_all(self, reason=""):
        """
        Called by server when forcing a clean disconnect for everyone.
        """
        for session in self.sessions.values():
            session.disconnect(reason)
            del session
        self.sessions = {}

    def server_logged_in(self, sessid, data):
        """
        The server tells us that the session has been
        authenticated. Updated it.
        """
        sess = self.get_session(sessid)
        sess.load_sync_data(data)

    def server_session_sync(self, serversessions):
        """
        Server wants to save data to the portal, maybe because it's about
        to shut down. We don't overwrite any sessions here, just update
        them in-place and remove any that are out of sync (which should
        normally not be the case)

        serversessions - dictionary {sessid:{property:value},...} describing
                         the properties to sync on all sessions
        """
        to_save = [sessid for sessid in serversessions if sessid in self.sessions]
        to_delete = [sessid for sessid in self.sessions if sessid not in to_save]
        # save protocols
        for sessid in to_save:
            self.sessions[sessid].load_sync_data(serversessions[sessid])
        # disconnect out-of-sync missing protocols
        for sessid in to_delete:
            self.server_disconnect(sessid)

    def count_loggedin(self, include_unloggedin=False):
        """
        Count loggedin connections, alternatively count all connections.
        """
        return len(self.get_sessions(include_unloggedin=include_unloggedin))

    def session_from_suid(self, suid):
        """
        Given a session id, retrieve the session (this is primarily
        intended to be called by web clients)
        """
        return [sess for sess in self.get_sessions(include_unloggedin=True)
                if hasattr(sess, 'suid') and sess.suid == suid]

    def data_in(self, session, text="", **kwargs):
        """
        Called by portal sessions for relaying data coming
        in from the protocol to the server. data is
        serialized before passed on.
        """
        self.portal.amp_protocol.call_remote_MsgPortal2Server(session.sessid,
                                                              msg=text,
                                                              data=kwargs)

    def announce_all(self, message):
        """
        Send message to all connection sessions
        """
        for session in self.sessions.values():
            session.data_out(message)

    def data_out(self, sessid, text=None, **kwargs):
        """
        Called by server for having the portal relay messages and data
        to the correct session protocol.
        """
        session = self.sessions.get(sessid, None)
        if session:
            session.data_out(text=text, **kwargs)

PORTAL_SESSIONS = PortalSessionHandler()

########NEW FILE########
__FILENAME__ = rss
"""
RSS parser for Evennia

This connects an RSS feed to an in-game Evennia channel, sending messages
to the channel whenever the feed updates.

"""

from twisted.internet import task, threads
from django.conf import settings
from src.server.session import Session
from src.utils import logger

RSS_ENABLED = settings.RSS_ENABLED
#RETAG = re.compile(r'<[^>]*?>')

if RSS_ENABLED:
    try:
        import feedparser
    except ImportError:
        raise ImportError("RSS requires python-feedparser to be installed. Install or set RSS_ENABLED=False.")

class RSSReader(Session):
    """
    A simple RSS reader using universal feedparser
    """
    def __init__(self, factory, url, rate):
        self.url = url
        self.rate = rate
        self.factory = factory
        self.old_entries = {}

    def get_new(self):
        """Returns list of new items."""
        feed = feedparser.parse(self.url)
        new_entries = []
        for entry in feed['entries']:
            idval = entry['id'] + entry.get("updated", "")
            if idval not in self.old_entries:
                self.old_entries[idval] = entry
                new_entries.append(entry)
        return new_entries

    def disconnect(self, reason=None):
        "Disconnect from feed"
        if self.factory.task and self.factory.task.running:
            self.factory.task.stop()
        self.sessionhandler.disconnect(self)

    def _callback(self, new_entries, init):
        "Called when RSS returns (threaded)"
        if not init:
            # for initialization we just ignore old entries
            for entry in reversed(new_entries):
                self.data_in("bot_data_in " + entry)

    def data_in(self, text=None, **kwargs):
        "Data RSS -> Server"
        self.sessionhandler.data_in(self, text=text, **kwargs)

    def _errback(self, fail):
        "Report error"
        logger.log_errmsg("RSS feed error: %s" % fail.value)

    def update(self, init=False):
        "Request feed"
        return threads.deferToThread(self.get_new).addCallback(self._callback, init).addErrback(self._errback)

class RSSBotFactory(object):
    """
    Initializes new bots
    """

    def __init__(self, sessionhandler, uid=None, url=None, rate=None):
        "Initialize"
        self.sessionhandler = sessionhandler
        self.url = url
        self.rate = rate
        self.uid = uid
        self.bot = RSSReader(self, url, rate)
        self.task = None

    def start(self):
        """
        Called by portalsessionhandler
        """
        def errback(fail):
            logger.log_errmsg(fail.value)

        # set up session and connect it to sessionhandler
        self.bot.init_session("rssbot", self.url, self.sessionhandler)
        self.bot.uid = self.uid
        self.bot.logged_in = True
        self.sessionhandler.connect(self.bot)

        # start repeater task
        self.bot.update(init=True)
        self.task = task.LoopingCall(self.bot.update)
        if self.rate:
            self.task.start(self.rate, now=False).addErrback(errback)

########NEW FILE########
__FILENAME__ = ssh
"""
This module implements the ssh (Secure SHell) protocol for encrypted
connections.

This depends on a generic session module that implements
the actual login procedure of the game, tracks
sessions etc.

Using standard ssh client,

"""
import os

from twisted.cred.checkers import credentials
from twisted.cred.portal import Portal
from twisted.conch.ssh.keys import Key
from twisted.conch.interfaces import IConchUser
from twisted.conch.ssh.userauth import SSHUserAuthServer
from twisted.conch.ssh import common
from twisted.conch.insults import insults
from twisted.conch.manhole_ssh import TerminalRealm, _Glue, ConchFactory
from twisted.conch.manhole import Manhole, recvline
from twisted.internet import defer
from twisted.conch import interfaces as iconch
from twisted.python import components
from django.conf import settings
from src.server import session
from src.players.models import PlayerDB
from src.utils import ansi, utils

ENCODINGS = settings.ENCODINGS

CTRL_C = '\x03'
CTRL_D = '\x04'
CTRL_BACKSLASH = '\x1c'
CTRL_L = '\x0c'


class SshProtocol(Manhole, session.Session):
    """
    Each player connecting over ssh gets this protocol assigned to
    them.  All communication between game and player goes through
    here.
    """
    def __init__(self, starttuple):
        """
        For setting up the player.  If player is not None then we'll
        login automatically.
        """
        self.authenticated_player = starttuple[0]
        # obs must not be called self.factory, that gets overwritten!
        self.cfactory = starttuple[1]

    def terminalSize(self, width, height):
        """
        Initialize the terminal and connect to the new session.
        """
        # Clear the previous input line, redraw it at the new
        # cursor position
        self.terminal.eraseDisplay()
        self.terminal.cursorHome()
        self.width = width
        self.height = height

        # initialize the session
        client_address = self.getClientAddress()
        self.init_session("ssh", client_address, self.cfactory.sessionhandler)

        # since we might have authenticated already, we might set this here.
        if self.authenticated_player:
            self.logged_in = True
            self.uid = self.authenticated_player.user.id
        self.sessionhandler.connect(self)

    def connectionMade(self):
        """
        This is called when the connection is first
        established.
        """
        recvline.HistoricRecvLine.connectionMade(self)
        self.keyHandlers[CTRL_C] = self.handle_INT
        self.keyHandlers[CTRL_D] = self.handle_EOF
        self.keyHandlers[CTRL_L] = self.handle_FF
        self.keyHandlers[CTRL_BACKSLASH] = self.handle_QUIT

        # initalize

    def handle_INT(self):
        """
        Handle ^C as an interrupt keystroke by resetting the current input
        variables to their initial state.
        """
        self.lineBuffer = []
        self.lineBufferIndex = 0

        self.terminal.nextLine()
        self.terminal.write("KeyboardInterrupt")
        self.terminal.nextLine()

    def handle_EOF(self):
        """
        Handles EOF generally used to exit.
        """
        if self.lineBuffer:
            self.terminal.write('\a')
        else:
            self.handle_QUIT()

    def handle_FF(self):
        """
        Handle a 'form feed' byte - generally used to request a screen
        refresh/redraw.
        """
        self.terminal.eraseDisplay()
        self.terminal.cursorHome()

    def handle_QUIT(self):
        """
        Quit, end, and lose the connection.
        """
        self.terminal.loseConnection()

    def connectionLost(self, reason=None):
        """
        This is executed when the connection is lost for
        whatever reason. It can also be called directly,
        from the disconnect method.

        """
        insults.TerminalProtocol.connectionLost(self, reason)
        self.sessionhandler.disconnect(self)
        self.terminal.loseConnection()

    def getClientAddress(self):
        """
        Returns the client's address and port in a tuple. For example
        ('127.0.0.1', 41917)
        """
        return self.terminal.transport.getPeer()

    def lineReceived(self, string):
        """
        Communication Player -> Evennia. Any line return indicates a
        command for the purpose of the MUD.  So we take the user input
        and pass it on to the game engine.
        """
        self.sessionhandler.data_in(self, string)

    def lineSend(self, string):
        """
        Communication Evennia -> Player
        Any string sent should already have been
        properly formatted and processed
        before reaching this point.

        """
        for line in string.split('\n'):
            #this is the telnet-specific method for sending
            self.terminal.write(line)
            self.terminal.nextLine()

    # session-general method hooks

    def disconnect(self, reason="Connection closed. Goodbye for now."):
        """
        Disconnect from server
        """
        if reason:
            self.data_out(reason)
        self.connectionLost(reason)

    def data_out(self, text=None, **kwargs):
        """
        Data Evennia -> Player access hook. 'data' argument is a dict
        parsed for string settings.

        ssh flags:
            raw=True - leave all ansi markup and tokens unparsed
            nomarkup=True - remove all ansi markup

        """
        try:
            text = utils.to_str(text if text else "", encoding=self.encoding)
        except Exception, e:
            self.lineSend(str(e))
            return
        raw = kwargs.get("raw", False)
        nomarkup = kwargs.get("nomarkup", False)
        if raw:
            self.lineSend(text)
        else:
            self.lineSend(ansi.parse_ansi(text.strip("{r") + "{r", strip_ansi=nomarkup))


class ExtraInfoAuthServer(SSHUserAuthServer):
    def auth_password(self, packet):
        """
        Password authentication.

        Used mostly for setting up the transport so we can query
        username and password later.
        """
        password = common.getNS(packet[1:])[0]
        c = credentials.UsernamePassword(self.user, password)
        c.transport = self.transport
        return self.portal.login(c, None, IConchUser).addErrback(
                                                        self._ebPassword)


class PlayerDBPasswordChecker(object):
    """
    Checks the django db for the correct credentials for
    username/password otherwise it returns the player or None which is
    useful for the Realm.
    """
    credentialInterfaces = (credentials.IUsernamePassword,)

    def __init__(self, factory):
        self.factory = factory
        super(PlayerDBPasswordChecker, self).__init__()

    def requestAvatarId(self, c):
        "Generic credentials"
        up = credentials.IUsernamePassword(c, None)
        username = up.username
        password = up.password
        player = PlayerDB.objects.get_player_from_name(username)
        res = (None, self.factory)
        if player and player.user.check_password(password):
            res = (player, self.factory)
        return defer.succeed(res)


class PassAvatarIdTerminalRealm(TerminalRealm):
    """
    Returns an avatar that passes the avatarId through to the
    protocol.  This is probably not the best way to do it.
    """

    def _getAvatar(self, avatarId):
        comp = components.Componentized()
        user = self.userFactory(comp, avatarId)
        sess = self.sessionFactory(comp)

        sess.transportFactory = self.transportFactory
        sess.chainedProtocolFactory = lambda: self.chainedProtocolFactory(avatarId)

        comp.setComponent(iconch.IConchUser, user)
        comp.setComponent(iconch.ISession, sess)

        return user


class TerminalSessionTransport_getPeer:
    """
    Taken from twisted's TerminalSessionTransport which doesn't
    provide getPeer to the transport.  This one does.
    """
    def __init__(self, proto, chainedProtocol, avatar, width, height):
        self.proto = proto
        self.avatar = avatar
        self.chainedProtocol = chainedProtocol

        session = self.proto.session

        self.proto.makeConnection(
            _Glue(write=self.chainedProtocol.dataReceived,
                  loseConnection=lambda: avatar.conn.sendClose(session),
                  name="SSH Proto Transport"))

        def loseConnection():
            self.proto.loseConnection()

        def getPeer():
            session.conn.transport.transport.getPeer()

        self.chainedProtocol.makeConnection(
            _Glue(getPeer=getPeer, write=self.proto.write,
                  loseConnection=loseConnection,
                  name="Chained Proto Transport"))

        self.chainedProtocol.terminalProtocol.terminalSize(width, height)


def getKeyPair(pubkeyfile, privkeyfile):
    """
    This function looks for RSA keypair files in the current directory. If they
    do not exist, the keypair is created.
    """

    if not (os.path.exists(pubkeyfile) and os.path.exists(privkeyfile)):
        # No keypair exists. Generate a new RSA keypair
        print "  Generating SSH RSA keypair ...",
        from Crypto.PublicKey import RSA

        KEY_LENGTH = 1024
        rsaKey = Key(RSA.generate(KEY_LENGTH))
        publicKeyString = rsaKey.public().toString(type="OPENSSH")
        privateKeyString = rsaKey.toString(type="OPENSSH")

        # save keys for the future.
        file(pubkeyfile, 'w+b').write(publicKeyString)
        file(privkeyfile, 'w+b').write(privateKeyString)
        print " done."
    else:
        publicKeyString = file(pubkeyfile).read()
        privateKeyString = file(privkeyfile).read()

    return Key.fromString(publicKeyString), Key.fromString(privateKeyString)


def makeFactory(configdict):
    """
    Creates the ssh server factory.
    """

    pubkeyfile = "ssh-public.key"
    privkeyfile = "ssh-private.key"

    def chainProtocolFactory(username=None):
        return insults.ServerProtocol(
            configdict['protocolFactory'],
            *configdict.get('protocolConfigdict', (username,)),
            **configdict.get('protocolKwArgs', {}))

    rlm = PassAvatarIdTerminalRealm()
    rlm.transportFactory = TerminalSessionTransport_getPeer
    rlm.chainedProtocolFactory = chainProtocolFactory
    factory = ConchFactory(Portal(rlm))
    factory.sessionhandler = configdict['sessions']

    try:
        # create/get RSA keypair
        publicKey, privateKey = getKeyPair(pubkeyfile, privkeyfile)
        factory.publicKeys = {'ssh-rsa': publicKey}
        factory.privateKeys = {'ssh-rsa': privateKey}
    except Exception, e:
        print " getKeyPair error: %(e)s\n WARNING: Evennia could not auto-generate SSH keypair. Using conch default keys instead." % {'e': e}
        print " If this error persists, create game/%(pub)s and game/%(priv)s yourself using third-party tools." % {'pub': pubkeyfile, 'priv': privkeyfile}

    factory.services = factory.services.copy()
    factory.services['ssh-userauth'] = ExtraInfoAuthServer

    factory.portal.registerChecker(PlayerDBPasswordChecker(factory))

    return factory
########NEW FILE########
__FILENAME__ = ssl
"""
This is a simple context factory for auto-creating
SSL keys and certificates.
"""

import os
import sys
from twisted.internet import ssl as twisted_ssl
try:
    import OpenSSL
except ImportError:
    print "  SSL_ENABLED requires PyOpenSSL."
    sys.exit(5)

from src.server.portal.telnet import TelnetProtocol


class SSLProtocol(TelnetProtocol):
    """
    Communication is the same as telnet, except data transfer
    is done with encryption.
    """
    pass


def verify_SSL_key_and_cert(keyfile, certfile):
    """
    This function looks for RSA key and certificate in the current
    directory. If files ssl.key and ssl.cert does not exist, they
    are created.
    """

    if not (os.path.exists(keyfile) and os.path.exists(certfile)):
        # key/cert does not exist. Create.
        import subprocess
        from Crypto.PublicKey import RSA
        from twisted.conch.ssh.keys import Key

        print "  Creating SSL key and certificate ... ",

        try:
            # create the RSA key and store it.
            KEY_LENGTH = 1024
            rsaKey = Key(RSA.generate(KEY_LENGTH))
            keyString = rsaKey.toString(type="OPENSSH")
            file(keyfile, 'w+b').write(keyString)
        except Exception, e:
            print "rsaKey error: %(e)s\n WARNING: Evennia could not auto-generate SSL private key." % {'e': e}
            print "If this error persists, create game/%(keyfile)s yourself using third-party tools." % {'keyfile': keyfile}
            sys.exit(5)

        # try to create the certificate
        CERT_EXPIRE = 365 * 20  # twenty years validity
        # default:
        #openssl req -new -x509 -key ssl.key -out ssl.cert -days 7300
        exestring = "openssl req -new -x509 -key %s -out %s -days %s" % (keyfile, certfile, CERT_EXPIRE)
        #print "exestring:", exestring
        try:
            #, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            subprocess.call(exestring)
        except OSError, e:
            string = "\n".join([
                 "  %s\n" % e,
                 "  Evennia's SSL context factory could not automatically",
                 "  create an SSL certificate game/%(cert)s." % {'cert': certfile},
                 "  A private key 'ssl.key' was already created. Please",
                 "  create %(cert)s manually using the commands valid" % {'cert': certfile},
                 "  for your operating system.",
                 "  Example (linux, using the openssl program): ",
                 "    %s" % exestring])
            print string
            sys.exit(5)
        print "done."


def getSSLContext():
    """
    Returns an SSL context (key and certificate). This function
    verifies that key/cert exists before obtaining the context, and if
    not, creates them.
    """
    keyfile, certfile = "ssl.key", "ssl.cert"
    verify_SSL_key_and_cert(keyfile, certfile)
    return twisted_ssl.DefaultOpenSSLContextFactory(keyfile, certfile)

########NEW FILE########
__FILENAME__ = telnet
"""
This module implements the telnet protocol.

This depends on a generic session module that implements
the actual login procedure of the game, tracks
sessions etc.

"""

import re
from twisted.conch.telnet import Telnet, StatefulTelnetProtocol, IAC, LINEMODE
from src.server.session import Session
from src.server.portal import ttype, mssp, msdp
from src.server.portal.mccp import Mccp, mccp_compress, MCCP
from src.utils import utils, ansi, logger

_RE_N = re.compile(r"\{n$")


class TelnetProtocol(Telnet, StatefulTelnetProtocol, Session):
    """
    Each player connecting over telnet (ie using most traditional mud
    clients) gets a telnet protocol instance assigned to them.  All
    communication between game and player goes through here.
    """
    def connectionMade(self):
        """
        This is called when the connection is first
        established.
        """
        # initialize the session
        self.iaw_mode = False
        client_address = self.transport.client
        self.init_session("telnet", client_address, self.factory.sessionhandler)
        # negotiate mccp (data compression)
        self.mccp = Mccp(self)
        # negotiate ttype (client info)
        self.ttype = ttype.Ttype(self)
        # negotiate mssp (crawler communication)
        self.mssp = mssp.Mssp(self)
        # msdp
        self.msdp = msdp.Msdp(self)
        # add this new connection to sessionhandler so
        # the Server becomes aware of it.

        # This is a fix to make sure the connection does not
        # continue until the handshakes are done. This is a
        # dumb delay of 1 second. This solution is not ideal (and
        # potentially buggy for slow connections?) but
        # adding a callback chain to all protocols (and notably
        # to their handshakes, which in some cases are multi-part)
        # is not trivial. Without it, the protocol will default
        # to their defaults since sessionhandler.connect will sync
        # before the handshakes have had time to finish. Keeping this patch
        # until coming up with a more elegant solution /Griatch
        from src.utils.utils import delay
        delay(1, callback=self.sessionhandler.connect, retval=self)
        #self.sessionhandler.connect(self)

    def enableRemote(self, option):
        """
        This sets up the remote-activated options we allow for this protocol.
        """
        return (option == LINEMODE or
                option == ttype.TTYPE or
                option == MCCP or
                option == mssp.MSSP)

    def enableLocal(self, option):
        """
        Call to allow the activation of options for this protocol
        """
        return option == MCCP

    def disableLocal(self, option):
        """
        Disable a given option
        """
        if option == MCCP:
            self.mccp.no_mccp(option)
            return True
        else:
            return super(TelnetProtocol, self).disableLocal(option)

    def connectionLost(self, reason):
        """
        this is executed when the connection is lost for
        whatever reason. it can also be called directly, from
        the disconnect method
        """
        self.sessionhandler.disconnect(self)
        self.transport.loseConnection()

    def dataReceived(self, data):
        """
        This method will split the incoming data depending on if it
        starts with IAC (a telnet command) or not. All other data will
        be handled in line mode. Some clients also sends an erroneous
        line break after IAC, which we must watch out for.

        OOB protocols (MSDP etc) already intercept subnegotiations
        on their own, never entering this method. They will relay
        their parsed data directly to self.data_in.

        """

        if data and data[0] == IAC or self.iaw_mode:
            try:
                #print "IAC mode"
                super(TelnetProtocol, self).dataReceived(data)
                if len(data) == 1:
                    self.iaw_mode = True
                else:
                    self.iaw_mode = False
                return
            except Exception, err1:
                conv = ""
                try:
                    for b in data:
                        conv += " " + repr(ord(b))
                except Exception, err2:
                    conv = str(err2) + ":", str(data)
                out = "Telnet Error (%s): %s (%s)" % (err1, data, conv)
                logger.log_trace(out)
                return
        # if we get to this point the command must end with a linebreak.
        # We make sure to add it, to fix some clients messing this up.
        data = data.rstrip("\r\n") + "\n"
        #print "line data in:", repr(data)
        StatefulTelnetProtocol.dataReceived(self, data)

    def _write(self, data):
        "hook overloading the one used in plain telnet"
        # print "_write (%s): %s" % (self.state,  " ".join(str(ord(c)) for c in data))
        data = data.replace('\n', '\r\n').replace('\r\r\n', '\r\n')
        #data = data.replace('\n', '\r\n')
        super(TelnetProtocol, self)._write(mccp_compress(self, data))

    def sendLine(self, line):
        "hook overloading the one used by linereceiver"
        #print "sendLine (%s):\n%s" % (self.state, line)
        #escape IAC in line mode, and correctly add \r\n
        line += self.delimiter
        line = line.replace(IAC, IAC + IAC).replace('\n', '\r\n')
        return self.transport.write(mccp_compress(self, line))

    def lineReceived(self, string):
        """
        Telnet method called when data is coming in over the telnet
        connection. We pass it on to the game engine directly.
        """
        self.data_in(text=string)

    # Session hooks

    def disconnect(self, reason=None):
        """
        generic hook for the engine to call in order to
        disconnect this protocol.
        """
        if reason:
            self.data_out(reason)
        self.connectionLost(reason)

    def data_in(self, text=None, **kwargs):
        """
        Data Telnet -> Server
        """
        self.sessionhandler.data_in(self, text=text, **kwargs)

    def data_out(self, text=None, **kwargs):
        """
        Data Evennia -> Player.
        generic hook method for engine to call in order to send data
        through the telnet connection.

        valid telnet kwargs:
            oob=<string> - supply an Out-of-Band instruction.
            xterm256=True/False - enforce xterm256 setting. If not
                                  given, ttype result is used. If
                                  client does not suport xterm256, the
                                  ansi fallback will be used
            ansi=True/False - enforce ansi setting. If not given,
                              ttype result is used.
            nomarkup=True - strip all ansi markup (this is the same as
                            xterm256=False, ansi=False)
            raw=True - pass string through without any ansi
                       processing (i.e. include Evennia ansi markers but do
                       not convert them into ansi tokens)

        The telnet ttype negotiation flags, if any, are used if no kwargs
        are given.
        """
        try:
            text = utils.to_str(text if text else "", encoding=self.encoding)
        except Exception, e:
            self.sendLine(str(e))
            return
        if "oob" in kwargs:
            oobstruct = self.sessionhandler.oobstruct_parser(kwargs.pop("oob"))
            if "MSDP" in self.protocol_flags:
                for cmdname, args, kwargs in oobstruct:
                    #print "cmdname, args, kwargs:", cmdname, args, kwargs
                    msdp_string = self.msdp.evennia_to_msdp(cmdname, *args, **kwargs)
                    #print "msdp_string:", msdp_string
                    self.msdp.data_out(msdp_string)

        # parse **kwargs, falling back to ttype if nothing is given explicitly
        ttype = self.protocol_flags.get('TTYPE', {})
        xterm256 = kwargs.get("xterm256", ttype and ttype.get('256 COLORS', False))
        useansi = kwargs.get("ansi", ttype and ttype.get('ANSI', False))
        raw = kwargs.get("raw", False)
        nomarkup = kwargs.get("nomarkup", not (xterm256 or useansi) or not ttype.get("init_done"))

        #print "telnet kwargs=%s, message=%s" % (kwargs, text)
        #print "xterm256=%s, useansi=%s, raw=%s, nomarkup=%s, init_done=%s" % (xterm256, useansi, raw, nomarkup, ttype.get("init_done"))
        if raw:
            # no processing whatsoever
            self.sendLine(text)
        else:
            # we need to make sure to kill the color at the end in order
            # to match the webclient output.
            # print "telnet data out:", self.protocol_flags, id(self.protocol_flags), id(self)
            self.sendLine(ansi.parse_ansi(_RE_N.sub("", text) + "{n", strip_ansi=nomarkup, xterm256=xterm256))

########NEW FILE########
__FILENAME__ = ttype
"""
TTYPE (MTTS) - Mud Terminal Type Standard

This module implements the TTYPE telnet protocol as per
http://tintin.sourceforge.net/mtts/. It allows the server to ask the
client about its capabilities. If the client also supports TTYPE, it
will return with information such as its name, if it supports colour
etc. If the client does not support TTYPE, this will be ignored.

All data will be stored on the protocol's protocol_flags dictionary,
under the 'TTYPE' key.
"""

# telnet option codes
TTYPE = chr(24)
IS = chr(0)
SEND = chr(1)

# terminal capabilities and their codes
MTTS = [(128, 'PROXY'),
        (64, 'SCREEN READER'),
        (32, 'OSC COLOR PALETTE'),
        (16, 'MOUSE TRACKING'),
        (8, '256 COLORS'),
        (4, 'UTF-8'),
        (2, 'VT100'),
        (1, 'ANSI')]

class Ttype(object):
    """
    Handles ttype negotiations. Called and initiated by the
    telnet protocol.
    """
    def __init__(self, protocol):
        """
        initialize ttype by storing protocol on ourselves and calling
        the client to see if it supporst ttype.

        the ttype_step indicates how far in the data retrieval we've
        gotten.
        """
        self.ttype_step = 0
        self.protocol = protocol
        self.protocol.protocol_flags['TTYPE'] = {"init_done": False}
        # is it a safe bet to assume ANSI is always supported?
        self.protocol.protocol_flags['TTYPE']['ANSI'] = True
        # setup protocol to handle ttype initialization and negotiation
        self.protocol.negotiationMap[TTYPE] = self.will_ttype
        # ask if client will ttype, connect callback if it does.
        self.protocol.do(TTYPE).addCallbacks(self.will_ttype, self.wont_ttype)

    def wont_ttype(self, option):
        """
        Callback if ttype is not supported by client.
        """
        self.protocol.protocol_flags['TTYPE']["init_done"] = True

    def will_ttype(self, option):
        """
        Handles negotiation of the ttype protocol once the
        client has confirmed that it will respond with the ttype
        protocol.

        The negotiation proceeds in several steps, each returning a
        certain piece of information about the client. All data is
        stored on protocol.protocol_flags under the TTYPE key.
        """

        options = self.protocol.protocol_flags.get('TTYPE')

        if options and options.get('init_done') or self.ttype_step > 3:
            return

        try:
            option = "".join(option).lstrip(IS)
        except TypeError:
            pass

        #print "incoming TTYPE option:", option

        if self.ttype_step == 0:
            # just start the request chain
            self.protocol.requestNegotiation(TTYPE, SEND)

        elif self.ttype_step == 1:
            # this is supposed to be the name of the client/terminal.
            # For clients not supporting the extended TTYPE
            # definition, subsequent calls will just repeat-return this.
            clientname = option.upper()
            # use name to identify support for xterm256. Many of these
            # only support after a certain version, but all support
            # it since at least 4 years. We assume recent client here for now.
            xterm256 = False
            if clientname.startswith("MUDLET"):
                # supports xterm256 stably since 1.1 (2010?)
                xterm256 = clientname.split("MUDLET",1)[1].strip() >= "1.1"
            else:
                xterm256 = (clientname.startswith("XTERM") or
                            clientname.endswith("-256COLOR") or
                            clientname in ("ATLANTIS",      # > 0.9.9.0 (aug 2009)
                                           "CMUD",          # > 3.04 (mar 2009)
                                           "KILDCLIENT",    # > 2.2.0 (sep 2005)
                                           "MUDLET",        # > beta 15 (sep 2009)
                                           "MUSHCLIENT",    # > 4.02 (apr 2007)
                                           "PUTTY"))        # > 0.58 (apr 2005)

            # all clients supporting TTYPE at all seem to support ANSI
            self.protocol.protocol_flags['TTYPE']['ANSI'] = True
            self.protocol.protocol_flags['TTYPE']['256 COLORS'] = xterm256
            self.protocol.protocol_flags['TTYPE']['CLIENTNAME'] = clientname
            self.protocol.requestNegotiation(TTYPE, SEND)

        elif self.ttype_step == 2:
            # this is a term capabilities flag
            term = option
            # identify xterm256 based on flag
            xterm256 = (term.endswith("-256color")         # Apple Terminal, old Tintin
                        or term.endswith("xterm") and      # old Tintin, Putty
                        not term.endswith("-color"))
            if xterm256:
                self.protocol.protocol_flags['TTYPE']['ANSI'] = True
                self.protocol.protocol_flags['TTYPE']['256 COLORS'] = xterm256
            self.protocol.protocol_flags['TTYPE']['TERM'] = term
            # request next information
            self.protocol.requestNegotiation(TTYPE, SEND)

        elif self.ttype_step == 3:
            # the MTTS bitstring identifying term capabilities
            if option.startswith("MTTS"):
                option = option.split(" ")[1]
                if option.isdigit():
                    # a number - determine the actual capabilities
                    option = int(option)
                    support = dict((capability, True) for bitval, capability in MTTS if option & bitval > 0)
                    self.protocol.protocol_flags['TTYPE'].update(support)
                else:
                    # some clients send erroneous MTTS as a string. Add directly.
                    self.protocol.protocol_flags['TTYPE'][option.upper()] = True

            self.protocol.protocol_flags['TTYPE']['init_done'] = True
            #print "TTYPE final:", self.protocol.protocol_flags['TTYPE']
        self.ttype_step += 1

########NEW FILE########
__FILENAME__ = webclient
"""
Web client server resource.

The Evennia web client consists of two components running
on twisted and django. They are both a part of the Evennia
website url tree (so the testing website might be located
on http://localhost:8000/, whereas the webclient can be
found on http://localhost:8000/webclient.)

/webclient - this url is handled through django's template
             system and serves the html page for the client
             itself along with its javascript chat program.
/webclientdata - this url is called by the ajax chat using
                 POST requests (long-polling when necessary)
                 The WebClient resource in this module will
                 handle these requests and act as a gateway
                 to sessions connected over the webclient.
"""
import time
import json
from hashlib import md5

from twisted.web import server, resource

from django.utils.functional import Promise
from django.utils.encoding import force_unicode
from django.conf import settings
from src.utils import utils, logger
from src.utils.text2html import parse_html
from src.server import session

SERVERNAME = settings.SERVERNAME
ENCODINGS = settings.ENCODINGS


# defining a simple json encoder for returning
# django data to the client. Might need to
# extend this if one wants to send more
# complex database objects too.

class LazyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, Promise):
            return force_unicode(obj)
        return super(LazyEncoder, self).default(obj)


def jsonify(obj):
    return utils.to_str(json.dumps(obj, ensure_ascii=False, cls=LazyEncoder))


#
# WebClient resource - this is called by the ajax client
# using POST requests to /webclientdata.
#

class WebClient(resource.Resource):
    """
    An ajax/comet long-polling transport
    """
    isLeaf = True
    allowedMethods = ('POST',)

    def __init__(self):
        self.requests = {}
        self.databuffer = {}

    #def getChild(self, path, request):
    #    """
    #    This is the place to put dynamic content.
    #    """
    #    return self

    def _responseFailed(self, failure, suid, request):
        "callback if a request is lost/timed out"
        try:
            del self.requests[suid]
        except KeyError:
            pass

    def lineSend(self, suid, string, data=None):
        """
        This adds the data to the buffer and/or sends it to
        the client as soon as possible.
        """
        request = self.requests.get(suid)
        if request:
            # we have a request waiting. Return immediately.
            request.write(jsonify({'msg': string, 'data': data}))
            request.finish()
            del self.requests[suid]
        else:
            # no waiting request. Store data in buffer
            dataentries = self.databuffer.get(suid, [])
            dataentries.append(jsonify({'msg': string, 'data': data}))
            self.databuffer[suid] = dataentries

    def client_disconnect(self, suid):
        """
        Disconnect session with given suid.
        """
        if suid in self.requests:
            self.requests[suid].finish()
            del self.requests[suid]
        if suid in self.databuffer:
            del self.databuffer[suid]

    def mode_init(self, request):
        """
        This is called by render_POST when the client
        requests an init mode operation (at startup)
        """
        #csess = request.getSession() # obs, this is a cookie, not
                                      # an evennia session!
        #csees.expireCallbacks.append(lambda : )
        suid = request.args.get('suid', ['0'])[0]

        remote_addr = request.getClientIP()
        host_string = "%s (%s:%s)" % (SERVERNAME, request.getRequestHostname(), request.getHost().port)
        if suid == '0':
            # creating a unique id hash string
            suid = md5(str(time.time())).hexdigest()
            self.databuffer[suid] = []

            sess = WebClientSession()
            sess.client = self
            sess.init_session("webclient", remote_addr, self.sessionhandler)
            sess.suid = suid
            sess.sessionhandler.connect(sess)
        return jsonify({'msg': host_string, 'suid': suid})

    def mode_input(self, request):
        """
        This is called by render_POST when the client
        is sending data to the server.
        """
        suid = request.args.get('suid', ['0'])[0]
        if suid == '0':
            return ''
        sess = self.sessionhandler.session_from_suid(suid)
        if sess:
            sess = sess[0]
            text = request.args.get('msg', [''])[0]
            data = request.args.get('data', [None])[0]
            sess.sessionhandler.data_in(sess, text, data=data)
        return ''

    def mode_receive(self, request):
        """
        This is called by render_POST when the client is telling us
        that it is ready to receive data as soon as it is
        available. This is the basis of a long-polling (comet)
        mechanism: the server will wait to reply until data is
        available.
        """
        suid = request.args.get('suid', ['0'])[0]
        if suid == '0':
            return ''

        dataentries = self.databuffer.get(suid, [])
        if dataentries:
            return dataentries.pop(0)
        request.notifyFinish().addErrback(self._responseFailed, suid, request)
        if suid in self.requests:
            self.requests[suid].finish()  # Clear any stale request.
        self.requests[suid] = request
        return server.NOT_DONE_YET

    def mode_close(self, request):
        """
        This is called by render_POST when the client is signalling
        that it is about to be closed.
        """
        suid = request.args.get('suid', ['0'])[0]
        if suid == '0':
            self.client_disconnect(suid)
        else:
            try:
                sess = self.sessionhandler.session_from_suid(suid)[0]
                sess.sessionhandler.disconnect(sess)
            except IndexError:
                self.client_disconnect(suid)
                pass
        return ''

    def render_POST(self, request):
        """
        This function is what Twisted calls with POST requests coming
        in from the ajax client. The requests should be tagged with
        different modes depending on what needs to be done, such as
        initializing or sending/receving data through the request. It
        uses a long-polling mechanism to avoid sending data unless
        there is actual data available.
        """
        dmode = request.args.get('mode', [None])[0]
        if dmode == 'init':
            # startup. Setup the server.
            return self.mode_init(request)
        elif dmode == 'input':
            # input from the client to the server
            return self.mode_input(request)
        elif dmode == 'receive':
            # the client is waiting to receive data.
            return self.mode_receive(request)
        elif dmode == 'close':
            # the client is closing
            return self.mode_close(request)
        else:
            # this should not happen if client sends valid data.
            return ''


#
# A session type handling communication over the
# web client interface.
#

class WebClientSession(session.Session):
    """
    This represents a session running in a webclient.
    """

    def disconnect(self, reason=None):
        """
        Disconnect from server
        """
        if reason:
            self.client.lineSend(self.suid, reason)
        self.client.client_disconnect(self.suid)

    def data_out(self, text=None, **kwargs):
        """
        Data Evennia -> Player access hook.

        webclient flags checked are
        raw=True - no parsing at all (leave ansi-to-html markers unparsed)
        nomarkup=True - clean out all ansi/html markers and tokens

        """
        # string handling is similar to telnet
        try:
            text = utils.to_str(text if text else "", encoding=self.encoding)
            raw = kwargs.get("raw", False)
            nomarkup = kwargs.get("nomarkup", False)
            if raw:
                self.client.lineSend(self.suid, text)
            else:
                self.client.lineSend(self.suid,
                                     parse_html(text, strip_ansi=nomarkup))
            return
        except Exception:
            logger.log_trace()

########NEW FILE########
__FILENAME__ = websocket
"""
Websockets Protocol

This implements WebSockets (http://en.wikipedia.org/wiki/WebSocket)
by use of the txws implementation (https://github.com/MostAwesomeDude/txWS).

Thanks to Ricard Pillosu whose Evennia plugin inspired this module.

Communication over the websocket interface is done with normal text
communication. A special case is OOB-style communication; to do this
the client must send data on the following form:

    OOB{oobfunc:[[args], {kwargs}], ...}

where the tuple/list is sent json-encoded. The initial OOB-prefix
is used to identify this type of communication, all other data
is considered plain text (command input).

Example of call from javascript client:

    websocket = new WeSocket("ws://localhost:8021")
    var msg1 = "WebSocket Test"
    websocket.send(msg1)
    var msg2 = JSON.stringify({"testfunc":[[1,2,3], {"kwarg":"val"}]})
    websocket.send("OOB" + msg2)
    websocket.close()

"""
import json
from twisted.internet.protocol import Protocol
from src.server.session import Session
from src.utils.logger import log_trace
from src.utils.utils import to_str
from src.utils.text2html import parse_html

class WebSocketProtocol(Protocol, Session):
    """
    This is called when the connection is first established
    """
    def connectionMade(self):
        """
        This is called when the connection is first established.
        """
        client_address = self.transport.client
        self.init_session("websocket", client_address, self.factory.sessionhandler)
        self.sessionhandler.connect(self)

    def disconnect(self, reason=None):
        """
        generic hook for the engine to call in order to
        disconnect this protocol.
        """
        if reason:
            self.data_out(text=reason)
        self.connectionLost(reason)

    def connectionLost(self, reason):
        """
        this is executed when the connection is lost for
        whatever reason. it can also be called directly, from
        the disconnect method
        """
        self.sessionhandler.disconnect(self)
        self.transport.close()

    def dataReceived(self, string):
        """
        Method called when data is coming in over
        the websocket connection.

        Type of data is identified by a 3-character
        prefix.
            OOB - This is an Out-of-band instruction. If so,
                  the remaining string should be a json-packed
                  string on the form {oobfuncname: [[args], {kwargs}], ...}
            any other prefix (or lack of prefix) is considered
                  plain text data, to be treated like a game
                  input command.
        """
        if string[:3] == "OOB":
            string = string[3:]
            try:
                oobdata = json.loads(string)
                for (key, argstuple) in oobdata.items():
                    args = argstuple[0] if argstuple else []
                    kwargs = argstuple[1] if len(argstuple) > 1 else {}
                    self.data_in(oob=(key, args, kwargs))
            except Exception:
                log_trace("Websocket malformed OOB request: %s" % string)
        else:
            # plain text input
            self.data_in(text=string)

    def sendLine(self, line):
        "send data to client"
        return self.transport.write(line)

    def data_in(self, text=None, **kwargs):
        """
        Data Websocket -> Server
        """
        self.sessionhandler.data_in(self, text=text, **kwargs)

    def data_out(self, text=None, **kwargs):
        """
        Data Evennia -> Player.
        generic hook method for engine to call in order to send data
        through the websocket connection.

        valid webclient kwargs:
            oob=<string> - supply an Out-of-Band instruction.
            raw=True - no parsing at all (leave ansi-to-html markers unparsed)
            nomarkup=True - clean out all ansi/html markers and tokens
        """
        try:
            text = to_str(text if text else "", encoding=self.encoding)
        except Exception, e:
            self.sendLine(str(e))
        if "oob" in kwargs:
            oobstruct = self.sessionhandler.oobstruct_parser(kwargs.pop("oob"))
            self.sendLine("OOB" + json.dumps(oobstruct))
        raw = kwargs.get("raw", False)
        nomarkup = kwargs.get("nomarkup", False)
        if raw:
            self.sendLine(text)
        else:
            self.sendLine(parse_html(text, strip_ansi=nomarkup))


########NEW FILE########
__FILENAME__ = server
"""
This module implements the main Evennia server process, the core of
the game engine.

This module should be started with the 'twistd' executable since it
sets up all the networking features.  (this is done automatically
by game/evennia.py).

"""
import time
import sys
import os
if os.name == 'nt':
    # For Windows batchfile we need an extra path insertion here.
    sys.path.insert(0, os.path.dirname(os.path.dirname(
                os.path.dirname(os.path.abspath(__file__)))))
from twisted.web import server, static
from twisted.application import internet, service
from twisted.internet import reactor, defer
import django
from django.db import connection
from django.conf import settings

from src.players.models import PlayerDB
from src.scripts.models import ScriptDB
from src.server.models import ServerConfig
from src.server import initial_setup

from src.utils.utils import get_evennia_version, mod_import, make_iter
from src.comms import channelhandler
from src.server.sessionhandler import SESSIONS

# setting up server-side field cache

from django.db.models.signals import post_save
from src.server.caches import field_pre_save
#pre_save.connect(field_pre_save, dispatch_uid="fieldcache")
post_save.connect(field_pre_save, dispatch_uid="fieldcache")

#from src.server.caches import post_attr_update
#from django.db.models.signals import m2m_changed

# connect to attribute cache signal
#m2m_changed.connect(post_attr_update, sender=TypedObject.db_attributes.through)

_SA = object.__setattr__

if os.name == 'nt':
    # For Windows we need to handle pid files manually.
    SERVER_PIDFILE = os.path.join(settings.GAME_DIR, 'server.pid')

# a file with a flag telling the server to restart after shutdown or not.
SERVER_RESTART = os.path.join(settings.GAME_DIR, 'server.restart')

# module containing hook methods called during start_stop
SERVER_STARTSTOP_MODULE = mod_import(settings.AT_SERVER_STARTSTOP_MODULE)

# module containing plugin services
SERVER_SERVICES_PLUGIN_MODULES = [mod_import(module) for module in make_iter(settings.SERVER_SERVICES_PLUGIN_MODULES)]

#------------------------------------------------------------
# Evennia Server settings
#------------------------------------------------------------

SERVERNAME = settings.SERVERNAME
VERSION = get_evennia_version()

AMP_ENABLED = True
AMP_HOST = settings.AMP_HOST
AMP_PORT = settings.AMP_PORT
AMP_INTERFACE = settings.AMP_INTERFACE

WEBSERVER_PORTS = settings.WEBSERVER_PORTS
WEBSERVER_INTERFACES = settings.WEBSERVER_INTERFACES

# server-channel mappings
WEBSERVER_ENABLED = settings.WEBSERVER_ENABLED and WEBSERVER_PORTS and WEBSERVER_INTERFACES
IMC2_ENABLED = settings.IMC2_ENABLED
IRC_ENABLED = settings.IRC_ENABLED
RSS_ENABLED = settings.RSS_ENABLED
WEBCLIENT_ENABLED = settings.WEBCLIENT_ENABLED


#------------------------------------------------------------
# Evennia Main Server object
#------------------------------------------------------------
class Evennia(object):

    """
    The main Evennia server handler. This object sets up the database and
    tracks and interlinks all the twisted network services that make up
    evennia.
    """

    def __init__(self, application):
        """
        Setup the server.

        application - an instantiated Twisted application

        """
        sys.path.append('.')

        # create a store of services
        self.services = service.IServiceCollection(application)
        self.amp_protocol = None  # set by amp factory
        self.sessions = SESSIONS
        self.sessions.server = self

        # Database-specific startup optimizations.
        self.sqlite3_prep()

        # Run the initial setup if needed
        self.run_initial_setup()

        self.start_time = time.time()

        # initialize channelhandler
        channelhandler.CHANNELHANDLER.update()

        # set a callback if the server is killed abruptly,
        # by Ctrl-C, reboot etc.
        reactor.addSystemEventTrigger('before', 'shutdown',
                                          self.shutdown, _reactor_stopping=True)

        self.game_running = True

        self.run_init_hooks()

    # Server startup methods

    def sqlite3_prep(self):
        """
        Optimize some SQLite stuff at startup since we
        can't save it to the database.
        """
        if ((".".join(str(i) for i in django.VERSION) < "1.2" and settings.DATABASE_ENGINE == "sqlite3")
            or (hasattr(settings, 'DATABASES')
                and settings.DATABASES.get("default", {}).get('ENGINE', None)
                == 'django.db.backends.sqlite3')):
            cursor = connection.cursor()
            cursor.execute("PRAGMA cache_size=10000")
            cursor.execute("PRAGMA synchronous=OFF")
            cursor.execute("PRAGMA count_changes=OFF")
            cursor.execute("PRAGMA temp_store=2")

    def update_defaults(self):
        """
        We make sure to store the most important object defaults here, so
        we can catch if they change and update them on-objects automatically.
        This allows for changing default cmdset locations and default
        typeclasses in the settings file and have them auto-update all
        already existing objects.
        """
        # setting names
        settings_names = ("CMDSET_CHARACTER", "CMDSET_PLAYER",
                          "BASE_PLAYER_TYPECLASS", "BASE_OBJECT_TYPECLASS",
                          "BASE_CHARACTER_TYPECLASS", "BASE_ROOM_TYPECLASS",
                          "BASE_EXIT_TYPECLASS", "BASE_SCRIPT_TYPECLASS",
                          "BASE_CHANNEL_TYPECLASS")
        # get previous and current settings so they can be compared
        settings_compare = zip([ServerConfig.objects.conf(name) for name in settings_names],
                               [settings.__getattr__(name) for name in settings_names])
        mismatches = [i for i, tup in enumerate(settings_compare) if tup[0] and tup[1] and tup[0] != tup[1]]
        if len(mismatches):  # can't use any() since mismatches may be [0] which reads as False for any()
            # we have a changed default. Import relevant objects and
            # run the update
            from src.objects.models import ObjectDB
            from src.comms.models import ChannelDB
            #from src.players.models import PlayerDB
            for i, prev, curr in ((i, tup[0], tup[1]) for i, tup in enumerate(settings_compare) if i in mismatches):
                # update the database
                print " %s:\n '%s' changed to '%s'. Updating unchanged entries in database ..." % (settings_names[i], prev, curr)
                if i == 0:
                    [obj.__setattr__("cmdset_storage", curr) for obj in ObjectDB.objects.filter(db_cmdset_storage__exact=prev)]
                if i == 1:
                    [ply.__setattr__("cmdset_storage", curr) for ply in PlayerDB.objects.filter(db_cmdset_storage__exact=prev)]
                if i == 2:
                    [ply.__setattr__("typeclass_path", curr) for ply in PlayerDB.objects.filter(db_typeclass_path__exact=prev)]
                if i in (3, 4, 5, 6):
                    [obj.__setattr__("typeclass_path", curr) for obj in ObjectDB.objects.filter(db_typeclass_path__exact=prev)]
                if i == 7:
                    [scr.__setattr__("typeclass_path", curr) for scr in ScriptDB.objects.filter(db_typeclass_path__exact=prev)]
                if i == 8:
                    [scr.__setattr__("typeclass_path", curr) for scr in ChannelDB.objects.filter(db_typeclass_path__exact=prev)]
                # store the new default and clean caches
                ServerConfig.objects.conf(settings_names[i], curr)
                ObjectDB.flush_instance_cache()
                PlayerDB.flush_instance_cache()
                ScriptDB.flush_instance_cache()
                ChannelDB.flush_instance_cache()
        # if this is the first start we might not have a "previous"
        # setup saved. Store it now.
        [ServerConfig.objects.conf(settings_names[i], tup[1])
                        for i, tup in enumerate(settings_compare) if not tup[0]]

    def run_initial_setup(self):
        """
        This attempts to run the initial_setup script of the server.
        It returns if this is not the first time the server starts.
        Once finished the last_initial_setup_step is set to -1.
        """
        last_initial_setup_step = ServerConfig.objects.conf('last_initial_setup_step')
        if not last_initial_setup_step:
            # None is only returned if the config does not exist,
            # i.e. this is an empty DB that needs populating.
            print ' Server started for the first time. Setting defaults.'
            initial_setup.handle_setup(0)
            print '-' * 50
        elif int(last_initial_setup_step) >= 0:
            # a positive value means the setup crashed on one of its
            # modules and setup will resume from this step, retrying
            # the last failed module. When all are finished, the step
            # is set to -1 to show it does not need to be run again.
            print ' Resuming initial setup from step %(last)s.' % \
                {'last': last_initial_setup_step}
            initial_setup.handle_setup(int(last_initial_setup_step))
            print '-' * 50

    def run_init_hooks(self):
        """
        Called every server start
        """
        from src.objects.models import ObjectDB
        #from src.players.models import PlayerDB

        #update eventual changed defaults
        self.update_defaults()

        #print "run_init_hooks:", ObjectDB.get_all_cached_instances()
        [(o.typeclass, o.at_init()) for o in ObjectDB.get_all_cached_instances()]
        [(p.typeclass, p.at_init()) for p in PlayerDB.get_all_cached_instances()]

        with open(SERVER_RESTART, 'r') as f:
            mode = f.read()
        if mode in ('True', 'reload'):
            from src.server.oobhandler import OOB_HANDLER
            OOB_HANDLER.restore()

        from src.scripts.tickerhandler import TICKER_HANDLER
        TICKER_HANDLER.restore()

        if SERVER_STARTSTOP_MODULE:
            # call correct server hook based on start file value
            if mode in ('True', 'reload'):
                # True was the old reload flag, kept for compatibilty
                SERVER_STARTSTOP_MODULE.at_server_reload_start()
            elif mode in ('reset', 'shutdown'):
                SERVER_STARTSTOP_MODULE.at_server_cold_start()
                # clear eventual lingering session storages
                ObjectDB.objects.clear_all_sessids()
            # always call this regardless of start type
            SERVER_STARTSTOP_MODULE.at_server_start()

    def set_restart_mode(self, mode=None):
        """
        This manages the flag file that tells the runner if the server is
        reloading, resetting or shutting down. Valid modes are
          'reload', 'reset', 'shutdown' and None.
        If mode is None, no change will be done to the flag file.

        Either way, the active restart setting (Restart=True/False) is
        returned so the server knows which more it's in.
        """
        if mode is None:
            with open(SERVER_RESTART, 'r') as f:
                # mode is either shutdown, reset or reload
                mode = f.read()
        else:
            with open(SERVER_RESTART, 'w') as f:
                f.write(str(mode))
        return mode

    @defer.inlineCallbacks
    def shutdown(self, mode=None, _reactor_stopping=False):
        """
        Shuts down the server from inside it.

        mode - sets the server restart mode.
               'reload' - server restarts, no "persistent" scripts
                          are stopped, at_reload hooks called.
               'reset' - server restarts, non-persistent scripts stopped,
                         at_shutdown hooks called.
               'shutdown' - like reset, but server will not auto-restart.
               None - keep currently set flag from flag file.
        _reactor_stopping - this is set if server is stopped by a kill
                            command OR this method was already called
                             once - in both cases the reactor is
                             dead/stopping already.
        """
        if _reactor_stopping and hasattr(self, "shutdown_complete"):
            # this means we have already passed through this method
            # once; we don't need to run the shutdown procedure again.
            defer.returnValue(None)

        mode = self.set_restart_mode(mode)
        # call shutdown hooks on all cached objects

        from src.objects.models import ObjectDB
        #from src.players.models import PlayerDB
        from src.server.models import ServerConfig

        if mode == 'reload':
            # call restart hooks
            yield [(o.typeclass, o.at_server_reload())
                                   for o in ObjectDB.get_all_cached_instances()]
            yield [(p.typeclass, p.at_server_reload())
                                   for p in PlayerDB.get_all_cached_instances()]
            yield [(s.typeclass, s.pause(), s.at_server_reload())
                                   for s in ScriptDB.get_all_cached_instances()]
            yield self.sessions.all_sessions_portal_sync()
            ServerConfig.objects.conf("server_restart_mode", "reload")

            from src.server.oobhandler import OOB_HANDLER
            OOB_HANDLER.save()
            from src.scripts.tickerhandler import TICKER_HANDLER
            TICKER_HANDLER.save()

            if SERVER_STARTSTOP_MODULE:
                SERVER_STARTSTOP_MODULE.at_server_reload_stop()

        else:
            if mode == 'reset':
                # don't unset the is_connected flag on reset, otherwise
                # same as shutdown
                yield [(o.typeclass, o.at_server_shutdown())
                                   for o in ObjectDB.get_all_cached_instances()]
                yield [(p.typeclass, p.at_server_shutdown())
                                       for p in PlayerDB.get_all_cached_instances()]
            else:  # shutdown
                yield [_SA(p, "is_connected", False)
                                   for p in PlayerDB.get_all_cached_instances()]
                yield [(o.typeclass, o.at_server_shutdown())
                                   for o in ObjectDB.get_all_cached_instances()]
                yield [(p.typeclass, p.unpuppet_all(), p.at_server_shutdown())
                                       for p in PlayerDB.get_all_cached_instances()]
            yield [(s.typeclass, s.at_server_shutdown())
                                   for s in ScriptDB.get_all_cached_instances()]
            yield ObjectDB.objects.clear_all_sessids()
            ServerConfig.objects.conf("server_restart_mode", "reset")

            if SERVER_STARTSTOP_MODULE:
                SERVER_STARTSTOP_MODULE.at_server_cold_stop()

        # stopping time
        from src.utils import gametime
        gametime.save()

        if SERVER_STARTSTOP_MODULE:
            SERVER_STARTSTOP_MODULE.at_server_stop()
        # if _reactor_stopping is true, reactor does not need to
        # be stopped again.
        if os.name == 'nt' and os.path.exists(SERVER_PIDFILE):
            # for Windows we need to remove pid files manually
            os.remove(SERVER_PIDFILE)
        if not _reactor_stopping:
            # this will also send a reactor.stop signal, so we set a
            # flag to avoid loops.
            self.shutdown_complete = True
            reactor.callLater(0, reactor.stop)

#------------------------------------------------------------
#
# Start the Evennia game server and add all active services
#
#------------------------------------------------------------

# Tell the system the server is starting up; some things are not available yet
ServerConfig.objects.conf("server_starting_mode", True)

# twistd requires us to define the variable 'application' so it knows
# what to execute from.
application = service.Application('Evennia')

# The main evennia server program. This sets up the database
# and is where we store all the other services.
EVENNIA = Evennia(application)

print '-' * 50
print ' %(servername)s Server (%(version)s) started.' % {'servername': SERVERNAME, 'version': VERSION}

if not settings.GAME_CACHE_TYPE:
    print "  caching disabled"

if AMP_ENABLED:

    # The AMP protocol handles the communication between
    # the portal and the mud server. Only reason to ever deactivate
    # it would be during testing and debugging.

    ifacestr = ""
    if AMP_INTERFACE != '127.0.0.1':
        ifacestr = "-%s" % AMP_INTERFACE
    print '  amp (to Portal)%s: %s' % (ifacestr, AMP_PORT)

    from src.server import amp

    factory = amp.AmpServerFactory(EVENNIA)
    amp_service = internet.TCPServer(AMP_PORT, factory, interface=AMP_INTERFACE)
    amp_service.setName("EvenniaPortal")
    EVENNIA.services.addService(amp_service)

if WEBSERVER_ENABLED:

    # Start a django-compatible webserver.

    from twisted.python import threadpool
    from src.server.webserver import DjangoWebRoot, WSGIWebServer

    # start a thread pool and define the root url (/) as a wsgi resource
    # recognized by Django
    threads = threadpool.ThreadPool(minthreads=max(1, settings.WEBSERVER_THREADPOOL_LIMITS[0]),
                                    maxthreads=max(1, settings.WEBSERVER_THREADPOOL_LIMITS[1]))
    web_root = DjangoWebRoot(threads)
    # point our media resources to url /media
    web_root.putChild("media", static.File(settings.MEDIA_ROOT))
    web_site = server.Site(web_root, logPath=settings.HTTP_LOG_FILE)

    for proxyport, serverport in WEBSERVER_PORTS:
        # create the webserver (we only need the port for this)
        webserver = WSGIWebServer(threads, serverport, web_site, interface='127.0.0.1')
        webserver.setName('EvenniaWebServer%s' % serverport)
        EVENNIA.services.addService(webserver)

        print "  webserver: %s" % serverport

ENABLED = []
if IRC_ENABLED:
    # IRC channel connections
    ENABLED.append('irc')

if IMC2_ENABLED:
    # IMC2 channel connections
    ENABLED.append('imc2')

if RSS_ENABLED:
    # RSS feed channel connections
    ENABLED.append('rss')

if ENABLED:
    print "  " + ", ".join(ENABLED) + " enabled."

for plugin_module in SERVER_SERVICES_PLUGIN_MODULES:
    # external plugin protocols
    plugin_module.start_plugin_services(EVENNIA)

print '-' * 50  # end of terminal output

# clear server startup mode
ServerConfig.objects.conf("server_starting_mode", delete=True)

if os.name == 'nt':
    # Windows only: Set PID file manually
    f = open(os.path.join(settings.GAME_DIR, 'server.pid'), 'w')
    f.write(str(os.getpid()))
    f.close()

########NEW FILE########
__FILENAME__ = serversession
"""
This defines a the Server's generic session object. This object represents
a connection to the outside world but don't know any details about how the
connection actually happens (so it's the same for telnet, web, ssh etc).

It is stored on the Server side (as opposed to protocol-specific sessions which
are stored on the Portal side)
"""

import time
from datetime import datetime
from django.conf import settings
#from src.scripts.models import ScriptDB
from src.comms.models import ChannelDB
from src.utils import logger, utils
from src.utils.utils import make_iter, to_unicode
from src.commands import cmdhandler, cmdsethandler
from src.server.session import Session

IDLE_COMMAND = settings.IDLE_COMMAND
_GA = object.__getattribute__
_ObjectDB = None
_OOB_HANDLER = None

# load optional out-of-band function module (this acts as a verification)
OOB_PLUGIN_MODULES = [utils.mod_import(mod)
                      for mod in make_iter(settings.OOB_PLUGIN_MODULES) if mod]

# i18n
from django.utils.translation import ugettext as _


#------------------------------------------------------------
# Server Session
#------------------------------------------------------------

class ServerSession(Session):
    """
    This class represents a player's session and is a template for
    individual protocols to communicate with Evennia.

    Each player gets a session assigned to them whenever they connect
    to the game server. All communication between game and player goes
    through their session.

    """
    def __init__(self):
        "Initiate to avoid AttributeErrors down the line"
        self.puppet = None
        self.player = None
        self.cmdset_storage_string = ""
        self.cmdset = cmdsethandler.CmdSetHandler(self)

    def __cmdset_storage_get(self):
        return [path.strip() for path in self.cmdset_storage_string.split(',')]

    def __cmdset_storage_set(self, value):
        self.cmdset_storage_string = ",".join(str(val).strip() for val in make_iter(value))
    cmdset_storage = property(__cmdset_storage_get, __cmdset_storage_set)

    def at_sync(self):
        """
        This is called whenever a session has been resynced with the portal.
        At this point all relevant attributes have already been set and
        self.player been assigned (if applicable).

        Since this is often called after a server restart we need to set up
        the session as it was.
        """
        global _ObjectDB
        if not _ObjectDB:
            from src.objects.models import ObjectDB as _ObjectDB

        if not self.logged_in:
            # assign the unloggedin-command set.
            self.cmdset_storage = settings.CMDSET_UNLOGGEDIN

        self.cmdset.update(init_mode=True)

        if self.puid:
            # reconnect puppet (puid is only set if we are coming
            # back from a server reload)
            obj = _ObjectDB.objects.get(id=self.puid)
            self.player.puppet_object(self.sessid, obj, normal_mode=False)

    def at_login(self, player):
        """
        Hook called by sessionhandler when the session becomes authenticated.

        player - the player associated with the session
        """
        self.player = player
        self.uid = self.player.id
        self.uname = self.player.username
        self.logged_in = True
        self.conn_time = time.time()
        self.puid = None
        self.puppet = None
        self.cmdset_storage = settings.CMDSET_SESSION

        # Update account's last login time.
        self.player.last_login = datetime.now()
        self.player.save()

        # add the session-level cmdset
        self.cmdset = cmdsethandler.CmdSetHandler(self)
        self.cmdset.update(init_mode=True)

    def at_disconnect(self):
        """
        Hook called by sessionhandler when disconnecting this session.
        """
        if self.logged_in:
            sessid = self.sessid
            player = self.player
            _GA(player.dbobj, "unpuppet_object")(sessid)
            uaccount = player.dbobj
            uaccount.last_login = datetime.now()
            uaccount.save()
            # calling player hook
            _GA(player.typeclass, "at_disconnect")()
            self.logged_in = False
            if not self.sessionhandler.sessions_from_player(player):
                # no more sessions connected to this player
                player.is_connected = False

    def get_player(self):
        """
        Get the player associated with this session
        """
        return self.logged_in and self.player

    def get_puppet(self):
        """
        Returns the in-game character associated with this session.
        This returns the typeclass of the object.
        """
        return self.logged_in and self.puppet
    get_character = get_puppet

    def get_puppet_or_player(self):
        """
        Returns session if not logged in; puppet if one exists,
        otherwise return the player.
        """
        if self.logged_in:
            return self.puppet if self.puppet else self.player
        return None

    def log(self, message, channel=True):
        """
        Emits session info to the appropriate outputs and info channels.
        """
        if channel:
            try:
                cchan = settings.CHANNEL_CONNECTINFO
                cchan = ChannelDB.objects.get_channel(cchan[0])
                cchan.msg("[%s]: %s" % (cchan.key, message))
            except Exception:
                pass
        logger.log_infomsg(message)

    def update_session_counters(self, idle=False):
        """
        Hit this when the user enters a command in order to update idle timers
        and command counters.
        """
        # Store the timestamp of the user's last command.
        self.cmd_last = time.time()
        if not idle:
            # Increment the user's command counter.
            self.cmd_total += 1
            # Player-visible idle time, not used in idle timeout calcs.
            self.cmd_last_visible = time.time()

    def data_in(self, text=None, **kwargs):
        """
        Send User->Evennia. This will in effect
        execute a command string on the server.

        Especially handled keywords:

        oob - this should hold a dictionary of oob command calls from
              the oob-supporting protocol.
        """
        if text:
            # this is treated as a command input
            text = to_unicode(text)
            # handle the 'idle' command
            if text.strip() == IDLE_COMMAND:
                self.update_session_counters(idle=True)
                return
            if self.player:
                # nick replacement
                puppet = self.player.get_puppet(self.sessid)
                if puppet:
                    text = puppet.nicks.nickreplace(text,
                                  categories=("inputline", "channel"), include_player=True)
                else:
                    text = self.player.nicks.nickreplace(text,
                                categories=("inputline", "channels"), include_player=False)
            cmdhandler.cmdhandler(self, text, callertype="session", sessid=self.sessid)
            self.update_session_counters()
        if "oob" in kwargs:
            # handle oob instructions
            global _OOB_HANDLER
            if not _OOB_HANDLER:
                from src.server.oobhandler import OOB_HANDLER as _OOB_HANDLER
            oobstruct = self.sessionhandler.oobstruct_parser(kwargs.pop("oob", None))
            for (funcname, args, kwargs) in oobstruct:
                if funcname:
                    _OOB_HANDLER.execute_cmd(self, funcname, *args, **kwargs)

    execute_cmd = data_in  # alias

    def data_out(self, text=None, **kwargs):
        """
        Send Evennia -> User
        """
        self.sessionhandler.data_out(self, text=text, **kwargs)

    def __eq__(self, other):
        return self.address == other.address

    def __str__(self):
        """
        String representation of the user session class. We use
        this a lot in the server logs.
        """
        symbol = ""
        if self.logged_in and hasattr(self, "player") and self.player:
            symbol = "(#%s)" % self.player.id
        try:
            if hasattr(self.address, '__iter__'):
                address = ":".join([str(part) for part in self.address])
            else:
                address = self.address
        except Exception:
            address = self.address
        return "%s%s@%s" % (self.uname, symbol, address)

    def __unicode__(self):
        """
        Unicode representation
        """
        return u"%s" % str(self)

    # easy-access functions

    #def login(self, player):
    #    "alias for at_login"
    #    self.session_login(player)
    #def disconnect(self):
    #    "alias for session_disconnect"
    #    self.session_disconnect()
    def msg(self, text='', **kwargs):
        "alias for at_data_out"
        self.data_out(text=text, **kwargs)

    # Dummy API hooks for use during non-loggedin operation

    def at_cmdset_get(self):
        "dummy hook all objects with cmdsets need to have"
        pass

    # Mock db/ndb properties for allowing easy storage on the session
    # (note that no databse is involved at all here. session.db.attr =
    # value just saves a normal property in memory, just like ndb).

    #@property
    def ndb_get(self):
        """
        A non-persistent store (ndb: NonDataBase). Everything stored
        to this is guaranteed to be cleared when a server is shutdown.
        Syntax is same as for the _get_db_holder() method and
        property, e.g. obj.ndb.attr = value etc.
        """
        try:
            return self._ndb_holder
        except AttributeError:
            class NdbHolder(object):
                "Holder for storing non-persistent attributes."
                def all(self):
                    return [val for val in self.__dict__.keys()
                            if not val.startswith['_']]

                def __getattribute__(self, key):
                    # return None if no matching attribute was found.
                    try:
                        return object.__getattribute__(self, key)
                    except AttributeError:
                        return None
            self._ndb_holder = NdbHolder()
            return self._ndb_holder

    #@ndb.setter
    def ndb_set(self, value):
        "Stop accidentally replacing the db object"
        string = "Cannot assign directly to ndb object! "
        string = "Use ndb.attr=value instead."
        raise Exception(string)

    #@ndb.deleter
    def ndb_del(self):
        "Stop accidental deletion."
        raise Exception("Cannot delete the ndb object!")
    ndb = property(ndb_get, ndb_set, ndb_del)
    db = property(ndb_get, ndb_set, ndb_del)

    # Mock access method for the session (there is no lock info
    # at this stage, so we just present a uniform API)
    def access(self, *args, **kwargs):
        "Dummy method."
        return True

########NEW FILE########
__FILENAME__ = session
"""
This defines a generic session class. All connection instances (both
on Portal and Server side) should inherit from this class.

"""

import time


#------------------------------------------------------------
# Server Session
#------------------------------------------------------------

class Session(object):
    """
    This class represents a player's session and is a template for
    both portal- and server-side sessions.

    Each connection will see two session instances created:

     1) A Portal session. This is customized for the respective connection
        protocols that Evennia supports, like Telnet, SSH etc. The Portal
        session must call init_session() as part of its initialization. The
        respective hook methods should be connected to the methods unique
        for the respective protocol so that there is a unified interface
        to Evennia.
     2) A Server session. This is the same for all connected players,
        regardless of how they connect.

    The Portal and Server have their own respective sessionhandlers. These
    are synced whenever new connections happen or the Server restarts etc,
    which means much of the same information must be stored in both places
    e.g. the portal can re-sync with the server when the server reboots.

    """

    # names of attributes that should be affected by syncing.
    _attrs_to_sync = ('protocol_key', 'address', 'suid', 'sessid', 'uid',
                      'uname', 'logged_in', 'puid', 'encoding',
                      'conn_time', 'cmd_last', 'cmd_last_visible', 'cmd_total',
                      'protocol_flags', 'server_data', "cmdset_storage_string")

    def init_session(self, protocol_key, address, sessionhandler):
        """
        Initialize the Session. This should be called by the protocol when
        a new session is established.
        protocol_key - telnet, ssh, ssl or web
        address - client address
        sessionhandler - reference to the sessionhandler instance
        """
        # This is currently 'telnet', 'ssh', 'ssl' or 'web'
        self.protocol_key = protocol_key
        # Protocol address tied to this session
        self.address = address

        # suid is used by some protocols, it's a hex key.
        self.suid = None

        # unique id for this session
        self.sessid = 0  # no sessid yet
        # database id for the user connected to this session
        self.uid = None
        # user name, for easier tracking of sessions
        self.uname = None
        # if user has authenticated already or not
        self.logged_in = False

        # database id of puppeted object (if any)
        self.puid = None

        # session time statistics
        self.conn_time = time.time()
        self.cmd_last_visible = self.conn_time
        self.cmd_last = self.conn_time
        self.cmd_total = 0
        self.encoding = "utf-8"

        self.protocol_flags = {}
        self.server_data = {}

        # a back-reference to the relevant sessionhandler this
        # session is stored in.
        self.sessionhandler = sessionhandler

    def get_sync_data(self):
        """
        Return all data relevant to sync the session
        """
        return dict((key, value) for key, value in self.__dict__.items()
                                                  if key in self._attrs_to_sync)

    def load_sync_data(self, sessdata):
        """
        Takes a session dictionary, as created by get_sync_data,
        and loads it into the correct properties of the session.
        """
        for propname, value in sessdata.items():
            self.__dict__[propname] = value

    def at_sync(self):
        """
        Called after a session has been fully synced (including
        secondary operations such as setting self.player based
        on uid etc).
        """
        pass

    # access hooks

    def disconnect(self, reason=None):
        """
        generic hook called from the outside to disconnect this session
        should be connected to the protocols actual disconnect mechanism.
        """
        pass

    def data_out(self, text=None, **kwargs):
        """
        generic hook for sending data out through the protocol. Server
        protocols can use this right away. Portal sessions
        should overload this to format/handle the outgoing data as needed.
        """
        pass

    def data_in(self, text=None, **kwargs):
        """
        hook for protocols to send incoming data to the engine.
        """
        pass

########NEW FILE########
__FILENAME__ = sessionhandler
"""
This module defines handlers for storing sessions when handles
sessions of users connecting to the server.

There are two similar but separate stores of sessions:
  ServerSessionHandler - this stores generic game sessions
         for the game. These sessions has no knowledge about
         how they are connected to the world.
  PortalSessionHandler - this stores sessions created by
         twisted protocols. These are dumb connectors that
         handle network communication but holds no game info.

"""

import time
from django.conf import settings
from src.commands.cmdhandler import CMD_LOGINSTART
from src.utils.utils import variable_from_module
try:
    import cPickle as pickle
except ImportError:
    import pickle

# delayed imports
_PlayerDB = None
_ServerSession = None
_ServerConfig = None
_ScriptDB = None


# AMP signals
PCONN = chr(1)        # portal session connect
PDISCONN = chr(2)     # portal session disconnect
PSYNC = chr(3)        # portal session sync
SLOGIN = chr(4)       # server session login
SDISCONN = chr(5)     # server session disconnect
SDISCONNALL = chr(6)  # server session disconnect all
SSHUTD = chr(7)       # server shutdown
SSYNC = chr(8)        # server session sync
SCONN = chr(9)        # server portal connection (for bots)

# i18n
from django.utils.translation import ugettext as _

SERVERNAME = settings.SERVERNAME
MULTISESSION_MODE = settings.MULTISESSION_MODE
IDLE_TIMEOUT = settings.IDLE_TIMEOUT


def delayed_import():
    "Helper method for delayed import of all needed entities"
    global _ServerSession, _PlayerDB, _ServerConfig, _ScriptDB
    if not _ServerSession:
        # we allow optional arbitrary serversession class for overloading
        modulename, classname = settings.SERVER_SESSION_CLASS.rsplit(".", 1)
        _ServerSession = variable_from_module(modulename, classname)
    if not _PlayerDB:
        from src.players.models import PlayerDB as _PlayerDB
    if not _ServerConfig:
        from src.server.models import ServerConfig as _ServerConfig
    if not _ScriptDB:
        from src.scripts.models import ScriptDB as _ScriptDB
    # including once to avoid warnings in Python syntax checkers
    _ServerSession, _PlayerDB, _ServerConfig, _ScriptDB


#-----------------------------------------------------------
# SessionHandler base class
#------------------------------------------------------------

class SessionHandler(object):
    """
    This handler holds a stack of sessions.
    """
    def __init__(self):
        """
        Init the handler.
        """
        self.sessions = {}

    def get_sessions(self, include_unloggedin=False):
        """
        Returns the connected session objects.
        """
        if include_unloggedin:
            return self.sessions.values()
        else:
            return [session for session in self.sessions.values() if session.logged_in]

    def get_session(self, sessid):
        """
        Get session by sessid
        """
        return self.sessions.get(sessid, None)

    def get_all_sync_data(self):
        """
        Create a dictionary of sessdata dicts representing all
        sessions in store.
        """
        return dict((sessid, sess.get_sync_data()) for sessid, sess in self.sessions.items())

    def oobstruct_parser(self, oobstruct):
        """
         Helper method for each session to use to parse oob structures
         (The 'oob' kwarg of the msg() method)
         allowed oob structures are
                 cmdname
                ((cmdname,), (cmdname,))
                (cmdname,(arg, ))
                (cmdname,(arg1,arg2))
                (cmdname,{key:val,key2:val2})
                (cmdname, (args,), {kwargs})
                ((cmdname, (arg1,arg2)), cmdname, (cmdname, (arg1,)))
        outputs an ordered structure on the form
                ((cmdname, (args,), {kwargs}), ...), where the two last
                                              parts of each tuple may be empty
        """
        def _parse(oobstruct):
            slen = len(oobstruct)
            if not oobstruct:
                return tuple(None, (), {})
            elif not hasattr(oobstruct, "__iter__"):
                # a singular command name, without arguments or kwargs
                return (oobstruct.lower(), (), {})
            # regardless of number of args/kwargs, the first element must be
            # the function name. We will not catch this error if not, but
            # allow it to propagate.
            if slen == 1:
                return (oobstruct[0].lower(), (), {})
            elif slen == 2:
                if isinstance(oobstruct[1], dict):
                    # cmdname, {kwargs}
                    return (oobstruct[0].lower(), (), dict(oobstruct[1]))
                elif isinstance(oobstruct[1], (tuple, list)):
                    # cmdname, (args,)
                    return (oobstruct[0].lower(), tuple(oobstruct[1]), {})
            else:
                # cmdname, (args,), {kwargs}
                return (oobstruct[0].lower(), tuple(oobstruct[1]), dict(oobstruct[2]))

        if hasattr(oobstruct, "__iter__"):
            # differentiate between (cmdname, cmdname),
            # (cmdname, args, kwargs) and ((cmdname,args,kwargs),
            # (cmdname,args,kwargs), ...)

            if oobstruct and isinstance(oobstruct[0], basestring):
                return (tuple(_parse(oobstruct)),)
            else:
                out = []
                for oobpart in oobstruct:
                    out.append(_parse(oobpart))
                return (tuple(out),)
        return (_parse(oobstruct),)


#------------------------------------------------------------
# Server-SessionHandler class
#------------------------------------------------------------

class ServerSessionHandler(SessionHandler):
    """
    This object holds the stack of sessions active in the game at
    any time.

    A session register with the handler in two steps, first by
    registering itself with the connect() method. This indicates an
    non-authenticated session. Whenever the session is authenticated
    the session together with the related player is sent to the login()
    method.

    """

    # AMP communication methods

    def __init__(self):
        """
        Init the handler.
        """
        self.sessions = {}
        self.server = None
        self.server_data = {"servername": SERVERNAME}

    def portal_connect(self, portalsession):
        """
        Called by Portal when a new session has connected.
        Creates a new, unlogged-in game session.

        portalsession is a dictionary of all property:value keys
                      defining the session and which is marked to
                      be synced.
        """
        delayed_import()
        global _ServerSession, _PlayerDB, _ScriptDB

        sess = _ServerSession()
        sess.sessionhandler = self
        sess.load_sync_data(portalsession)
        if sess.logged_in and sess.uid:
            # this can happen in the case of auto-authenticating
            # protocols like SSH
            sess.player = _PlayerDB.objects.get_player_from_uid(sess.uid)
        sess.at_sync()
        # validate all scripts
        _ScriptDB.objects.validate()
        self.sessions[sess.sessid] = sess
        sess.data_in(CMD_LOGINSTART)

    def portal_disconnect(self, sessid):
        """
        Called by Portal when portal reports a closing of a session
        from the portal side.
        """
        session = self.sessions.get(sessid, None)
        if not session:
            return
        player = session.player
        if player:
            nsess = len(self.sessions_from_player(player))
            remaintext = nsess and "%i session%s remaining" % (nsess, nsess > 1 and "s" or "") or "no more sessions"
            session.log(_('Connection dropped: %s %s (%s)' % (session.player, session.address, remaintext)))
        session.at_disconnect()
        session.disconnect()
        del self.sessions[session.sessid]

    def portal_session_sync(self, portalsessions):
        """
        Syncing all session ids of the portal with the ones of the
        server. This is instantiated by the portal when reconnecting.

        portalsessions is a dictionary {sessid: {property:value},...} defining
                      each session and the properties in it which should
                      be synced.
        """
        delayed_import()
        global _ServerSession, _PlayerDB, _ServerConfig, _ScriptDB

        for sess in self.sessions.values():
            # we delete the old session to make sure to catch eventual
            # lingering references.
            del sess

        for sessid, sessdict in portalsessions.items():
            sess = _ServerSession()
            sess.sessionhandler = self
            sess.load_sync_data(sessdict)
            if sess.uid:
                sess.player = _PlayerDB.objects.get_player_from_uid(sess.uid)
            self.sessions[sessid] = sess
            sess.at_sync()

        # after sync is complete we force-validate all scripts
        # (this also starts them)
        init_mode = _ServerConfig.objects.conf("server_restart_mode", default=None)
        _ScriptDB.objects.validate(init_mode=init_mode)
        _ServerConfig.objects.conf("server_restart_mode", delete=True)
        # announce the reconnection
        self.announce_all(_(" ... Server restarted."))

    # server-side access methods

    def start_bot_session(self, protocol_path, configdict):
        """
        This method allows the server-side to force the Portal to create
        a new bot session using the protocol specified by protocol_path,
        which should be the full python path to the class, including the
        class name, like "src.server.portal.irc.IRCClient".
        The new session will use the supplied player-bot uid to
        initiate an already logged-in connection. The Portal will
        treat this as a normal connection and henceforth so will the
        Server.
        """
        data = {"protocol_path":protocol_path,
                "config":configdict}
        self.server.amp_protocol.call_remote_PortalAdmin(0,
                                                         operation=SCONN,
                                                         data=data)

    def portal_shutdown(self):
        """
        Called by server when shutting down the portal.
        """
        self.server.amp_protocol.call_remote_PortalAdmin(0,
                                                         operation=SSHUTD,
                                                         data="")

    def login(self, session, player, testmode=False):
        """
        Log in the previously unloggedin session and the player we by
        now should know is connected to it. After this point we
        assume the session to be logged in one way or another.

        testmode - this is used by unittesting for faking login without
        any AMP being actually active
        """

        # we have to check this first before uid has been assigned
        # this session.

        if not self.sessions_from_player(player):
            player.is_connected = True

        # sets up and assigns all properties on the session
        session.at_login(player)

        # player init
        player.at_init()

        # Check if this is the first time the *player* logs in
        if player.db.FIRST_LOGIN:
            player.at_first_login()
            del player.db.FIRST_LOGIN

        player.at_pre_login()

        if MULTISESSION_MODE == 0:
            # disconnect all previous sessions.
            self.disconnect_duplicate_sessions(session)

        nsess = len(self.sessions_from_player(player))
        totalstring = "%i session%s total" % (nsess, nsess > 1 and "s" or "")
        session.log(_('Logged in: %s %s (%s)' % (player, session.address, totalstring)))

        session.logged_in = True
        # sync the portal to the session
        sessdata = session.get_sync_data()
        if not testmode:
            self.server.amp_protocol.call_remote_PortalAdmin(session.sessid,
                                                         operation=SLOGIN,
                                                         data=sessdata)
        player.at_post_login(sessid=session.sessid)

    def disconnect(self, session, reason=""):
        """
        Called from server side to remove session and inform portal
        of this fact.
        """
        session = self.sessions.get(session.sessid)
        if not session:
            return

        if hasattr(session, "player") and session.player:
            # only log accounts logging off
            nsess = len(self.sessions_from_player(session.player)) - 1
            remaintext = nsess and "%i session%s remaining" % (nsess, nsess > 1 and "s" or "") or "no more sessions"
            session.log(_('Logged out: %s %s (%s)' % (session.player, session.address, remaintext)))

        session.at_disconnect()
        sessid = session.sessid
        del self.sessions[sessid]
        # inform portal that session should be closed.
        self.server.amp_protocol.call_remote_PortalAdmin(sessid,
                                                         operation=SDISCONN,
                                                         data=reason)

    def all_sessions_portal_sync(self):
        """
        This is called by the server when it reboots. It syncs all session data
        to the portal. Returns a deferred!
        """
        sessdata = self.get_all_sync_data()
        return self.server.amp_protocol.call_remote_PortalAdmin(0,
                                                         operation=SSYNC,
                                                         data=sessdata)

    def disconnect_all_sessions(self, reason=_("You have been disconnected.")):
        """
        Cleanly disconnect all of the connected sessions.
        """

        for session in self.sessions:
            del session
        # tell portal to disconnect all sessions
        self.server.amp_protocol.call_remote_PortalAdmin(0,
                                                         operation=SDISCONNALL,
                                                         data=reason)

    def disconnect_duplicate_sessions(self, curr_session,
                      reason=_("Logged in from elsewhere. Disconnecting.")):
        """
        Disconnects any existing sessions with the same user.
        """
        uid = curr_session.uid
        doublet_sessions = [sess for sess in self.sessions.values()
                            if sess.logged_in
                            and sess.uid == uid
                            and sess != curr_session]
        for session in doublet_sessions:
            self.disconnect(session, reason)

    def validate_sessions(self):
        """
        Check all currently connected sessions (logged in and not)
        and see if any are dead.
        """
        tcurr = time.time()
        reason = _("Idle timeout exceeded, disconnecting.")
        for session in (session for session in self.sessions.values()
                        if session.logged_in and IDLE_TIMEOUT > 0
                        and (tcurr - session.cmd_last) > IDLE_TIMEOUT):
            self.disconnect(session, reason=reason)

    def player_count(self):
        """
        Get the number of connected players (not sessions since a
        player may have more than one session depending on settings).
        Only logged-in players are counted here.
        """
        return len(set(session.uid for session in self.sessions.values() if session.logged_in))

    def session_from_sessid(self, sessid):
        """
        Return session based on sessid, or None if not found
        """
        return self.sessions.get(sessid)

    def session_from_player(self, player, sessid):
        """
        Given a player and a session id, return the actual session object
        """
        session = self.sessions.get(sessid)
        return session and session.logged_in and player.uid == session.uid and session or None

    def sessions_from_player(self, player):
        """
        Given a player, return all matching sessions.
        """
        uid = player.uid
        return [session for session in self.sessions.values() if session.logged_in and session.uid == uid]

    def sessions_from_character(self, character):
        """
        Given a game character, return any matching sessions.
        """
        sessid = character.sessid
        if sessid:
            return self.sessions.get(sessid)
        return None

    def announce_all(self, message):
        """
        Send message to all connected sessions
        """
        for sess in self.sessions.values():
            self.data_out(sess, message)

    def data_out(self, session, text="", **kwargs):
        """
        Sending data Server -> Portal
        """
        self.server.amp_protocol.call_remote_MsgServer2Portal(sessid=session.sessid,
                                                              msg=text,
                                                              data=kwargs)

    def data_in(self, sessid, text="", **kwargs):
        """
        Data Portal -> Server
        """
        session = self.sessions.get(sessid, None)
        if session:
            session.data_in(text=text, **kwargs)

SESSIONS = ServerSessionHandler()

########NEW FILE########
__FILENAME__ = tests
# -*- coding: utf-8 -*-

"""
Unit testing of the 'objects' Evennia component.

Runs as part of the Evennia's test suite with 'manage.py test"

Please add new tests to this module as needed.

Guidelines:
 A 'test case' is testing a specific component and is defined as a class
 inheriting from unittest.TestCase. The test case class can have a method
 setUp() that creates and sets up the testing environment.
 All methods inside the test case class whose names start with 'test' are
 used as test methods by the runner. Inside the test methods, special member
 methods assert*() are used to test the behaviour.
"""

import sys
import glob

try:
    from django.utils.unittest import TestCase
except ImportError:
    from django.test import TestCase
try:
    from django.utils import unittest
except ImportError:
    import unittest

from django.conf import settings
from django.test.simple import DjangoTestSuiteRunner
from src.utils.utils import mod_import


class EvenniaTestSuiteRunner(DjangoTestSuiteRunner):
    """
    This test runner only runs tests on the apps specified in src/ and game/ to
     avoid running the large number of tests defined by Django
    """
    def build_suite(self, test_labels, extra_tests=None, **kwargs):
        """
        Build a test suite for Evennia. test_labels is a list of apps to test.
        If not given, a subset of settings.INSTALLED_APPS will be used.
        """
        if not test_labels:
            test_labels = [applabel.rsplit('.', 1)[1] for applabel in settings.INSTALLED_APPS
                           if (applabel.startswith('src.') or applabel.startswith('game.'))]
        return super(EvenniaTestSuiteRunner, self).build_suite(test_labels, extra_tests=extra_tests, **kwargs)


def suite():
    """
    This function is called automatically by the django test runner.
    This also collates tests from packages that are not formally django applications.
    """
    from src.locks import tests as locktests
    from src.utils import tests as utiltests
    from src.commands.default import tests as commandtests

    tsuite = unittest.TestSuite()
    tsuite.addTest(unittest.defaultTestLoader.loadTestsFromModule(sys.modules[__name__]))

    # test modules from non-django apps
    tsuite.addTest(unittest.defaultTestLoader.loadTestsFromModule(commandtests))
    tsuite.addTest(unittest.defaultTestLoader.loadTestsFromModule(locktests))
    tsuite.addTest(unittest.defaultTestLoader.loadTestsFromModule(utiltests))

    for path in glob.glob("../src/tests/test_*.py"):
        testmod = mod_import(path)
        tsuite.addTest(unittest.defaultTestLoader.loadTestsFromModule(testmod))

    #from src.tests import test_commands_cmdhandler
    #tsuite.addTest(unittest.defaultTestLoader.loadTestsFromModule(test_commands_cmdhandler))

    return tsuite

########NEW FILE########
__FILENAME__ = webserver
"""
This implements resources for twisted webservers using the wsgi
interface of django. This alleviates the need of running e.g. an
apache server to serve Evennia's web presence (although you could do
that too if desired).

The actual servers are started inside server.py as part of the Evennia
application.

(Lots of thanks to http://githup.com/clemensha/twisted-wsgi-django for
a great example/aid on how to do this.)

"""
import urlparse
from urllib import quote as urlquote
from twisted.web import resource, http
from twisted.internet import reactor
from twisted.application import internet
from twisted.web.proxy import ReverseProxyResource
from twisted.web.server import NOT_DONE_YET

from twisted.web.wsgi import WSGIResource
from django.core.handlers.wsgi import WSGIHandler

from settings import UPSTREAM_IPS


#
# X-Forwarded-For Handler
#

class HTTPChannelWithXForwardedFor(http.HTTPChannel):
    def allHeadersReceived(self):
        """
        Check to see if this is a reverse proxied connection.
        """
        CLIENT = 0
        http.HTTPChannel.allHeadersReceived(self)
        req = self.requests[-1]
        client_ip, port = self.transport.client
        proxy_chain = req.getHeader('X-FORWARDED-FOR')
        if proxy_chain and client_ip in UPSTREAM_IPS:
            forwarded = proxy_chain.split(', ', 1)[CLIENT]
            self.transport.client = (forwarded, port)


# Monkey-patch Twisted to handle X-Forwarded-For.

http.HTTPFactory.protocol = HTTPChannelWithXForwardedFor


class EvenniaReverseProxyResource(ReverseProxyResource):
    def getChild(self, path, request):
        """
        Create and return a proxy resource with the same proxy configuration
        as this one, except that its path also contains the segment given by
        C{path} at the end.
        """
        return EvenniaReverseProxyResource(
            self.host, self.port, self.path + '/' + urlquote(path, safe=""),
            self.reactor)

    def render(self, request):
        """
        Render a request by forwarding it to the proxied server.
        """
        # RFC 2616 tells us that we can omit the port if it's the default port,
        # but we have to provide it otherwise
        request.content.seek(0, 0)
        qs = urlparse.urlparse(request.uri)[4]
        if qs:
            rest = self.path + '?' + qs
        else:
            rest = self.path
        clientFactory = self.proxyClientFactoryClass(
            request.method, rest, request.clientproto,
            request.getAllHeaders(), request.content.read(), request)
        self.reactor.connectTCP(self.host, self.port, clientFactory)
        return NOT_DONE_YET


#
# Website server resource
#

class DjangoWebRoot(resource.Resource):
    """
    This creates a web root (/) that Django
    understands by tweaking the way the
    child instancee are recognized.
    """
    def __init__(self, pool):
        """
        Setup the django+twisted resource
        """
        resource.Resource.__init__(self)
        self.wsgi_resource = WSGIResource(reactor, pool, WSGIHandler())

    def getChild(self, path, request):
        """
        To make things work we nudge the
        url tree to make this the root.
        """
        path0 = request.prepath.pop(0)
        request.postpath.insert(0, path0)
        return self.wsgi_resource


#
# Threaded Webserver
#

class WSGIWebServer(internet.TCPServer):
    """
    This is a WSGI webserver. It makes sure to start
    the threadpool after the service itself started,
    so as to register correctly with the twisted daemon.

    call with WSGIWebServer(threadpool, port, wsgi_resource)
    """
    def __init__(self, pool, *args, **kwargs):
        "This just stores the threadpool"
        self.pool = pool
        internet.TCPServer.__init__(self, *args, **kwargs)

    def startService(self):
        "Start the pool after the service"
        internet.TCPServer.startService(self)
        self.pool.start()

    def stopService(self):
        "Safely stop the pool after service stop."
        internet.TCPServer.stopService(self)
        self.pool.stop()

########NEW FILE########
__FILENAME__ = settings_default
"""
Master configuration file for Evennia.

NOTE: NO MODIFICATIONS SHOULD BE MADE TO THIS FILE!

All settings changes should be done by copy-pasting the variable and
its value to game/settings.py. An empty game/settings.py can be
auto-generated by running game/manage.py without any arguments.

Hint: Don't copy&paste over more from this file than you actually want
to change.  Anything you don't copy&paste will thus retain its default
value - which may change as Evennia is developed. This way you can
always be sure of what you have changed and what is default behaviour.
"""

import os

######################################################################
# Evennia base server config
######################################################################

# This is the name of your game. Make it catchy!
SERVERNAME = "Evennia"
# Activate telnet service
TELNET_ENABLED = True
# A list of ports the Evennia telnet server listens on Can be one or many.
TELNET_PORTS = [4000]
# Interface addresses to listen to. If 0.0.0.0, listen to all. Use :: for IPv6.
TELNET_INTERFACES = ['0.0.0.0']
# OOB (out-of-band) telnet communication allows Evennia to communicate
# special commands and data with enabled Telnet clients. This is used
# to create custom client interfaces over a telnet connection. To make
# full use of OOB, you need to prepare functions to handle the data
# server-side (see OOB_FUNC_MODULE). TELNET_ENABLED is required for this
# to work.
TELNET_OOB_ENABLED = False
# Start the evennia django+twisted webserver so you can
# browse the evennia website and the admin interface
# (Obs - further web configuration can be found below
# in the section  'Config for Django web features')
WEBSERVER_ENABLED = True
# This is a security setting protecting against host poisoning
# attacks.  It defaults to allowing all. In production, make
# sure to change this to your actual host addresses/IPs.
ALLOWED_HOSTS = ["*"]
# The webserver sits behind a Portal proxy. This is a list
# of tuples (proxyport,serverport) used. The proxyports are what
# the Portal proxy presents to the world. The serverports are
# the internal ports the proxy uses to forward data to the Server-side
# webserver (these should not be publicly open)
WEBSERVER_PORTS = [(8000, 5001)]
# Interface addresses to listen to. If 0.0.0.0, listen to all. Use :: for IPv6.
WEBSERVER_INTERFACES = ['0.0.0.0']
# IP addresses that may talk to the server in a reverse proxy configuration,
# like NginX.
UPSTREAM_IPS = ['127.0.0.1']
# The webserver uses threadpool for handling requests. This will scale
# with server load. Set the minimum and maximum number of threads it
# may use as (min, max) (must be > 0)
WEBSERVER_THREADPOOL_LIMITS = (1, 20)
# Start the evennia ajax client on /webclient
# (the webserver must also be running)
WEBCLIENT_ENABLED = True
# Activate SSH protocol (SecureShell)
SSH_ENABLED = False
# Ports to use for SSH
SSH_PORTS = [8022]
# Interface addresses to listen to. If 0.0.0.0, listen to all. Use :: for IPv6.
SSH_INTERFACES = ['0.0.0.0']
# Activate SSL protocol (SecureSocketLibrary)
SSL_ENABLED = False
# Ports to use for SSL
SSL_PORTS = [4001]
# Interface addresses to listen to. If 0.0.0.0, listen to all. Use :: for IPv6.
SSL_INTERFACES = ['0.0.0.0']
# Activate Websocket support
WEBSOCKET_ENABLED = False
# Ports to use for Websockets
WEBSOCKET_PORTS = [8021]
# Interface addresses to listen to. If 0.0.0.0, listen to all. Use :: for IPv6.
WEBSOCKET_INTERFACES = ['0.0.0.0']
# The path that contains this settings.py file (no trailing slash).
BASE_PATH = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
# Path to the src directory containing the bulk of the codebase's code.
SRC_DIR = os.path.join(BASE_PATH, 'src')
# Path to the game directory (containing the database file if using sqlite).
GAME_DIR = os.path.join(BASE_PATH, 'game')
# Place to put log files
LOG_DIR = os.path.join(GAME_DIR, 'logs')
SERVER_LOG_FILE = os.path.join(LOG_DIR, 'server.log')
PORTAL_LOG_FILE = os.path.join(LOG_DIR, 'portal.log')
HTTP_LOG_FILE = os.path.join(LOG_DIR, 'http_requests.log')
# Rotate log files when server and/or portal stops. This will keep log
# file sizes down. Turn off to get ever growing log files and never
# loose log info.
CYCLE_LOGFILES = True
# Local time zone for this installation. All choices can be found here:
# http://www.postgresql.org/docs/8.0/interactive/datetime-keywords.html#DATETIME-TIMEZONE-SET-TABLE
TIME_ZONE = 'UTC'
# Authentication backends. This is the code used to authenticate a user.
AUTHENTICATION_BACKENDS = ('src.web.backends.CaseInsensitiveModelBackend',)
# Language code for this installation. All choices can be found here:
# http://www.w3.org/TR/REC-html40/struct/dirlang.html#langcodes
LANGUAGE_CODE = 'en-us'
# How long time (in seconds) a user may idle before being logged
# out. This can be set as big as desired. A user may avoid being
# thrown off by sending the empty system command 'idle' to the server
# at regular intervals. Set <=0 to deactivate idle timout completely.
IDLE_TIMEOUT = 3600
# The idle command can be sent to keep your session active without actually
# having to spam normal commands regularly. It gives no feedback, only updates
# the idle timer.
IDLE_COMMAND = "idle"
# The set of encodings tried. A Player object may set an attribute "encoding" on
# itself to match the client used. If not set, or wrong encoding is
# given, this list is tried, in order, aborting on the first match.
# Add sets for languages/regions your players are likely to use.
# (see http://en.wikipedia.org/wiki/Character_encoding)
ENCODINGS = ["utf-8", "latin-1", "ISO-8859-1"]
# The game server opens an AMP port so that the portal can
# communicate with it. This is an internal functionality of Evennia, usually
# operating between two processes on the same machine. You usually don't need to
# change this unless you cannot use the default AMP port/host for
# whatever reason.
AMP_HOST = 'localhost'
AMP_PORT = 5000
AMP_INTERFACE = '127.0.0.1'
# Caching speeds up all forms of database access, often considerably. There
# are (currently) only two settings, "local" or None, the latter of which turns
# off all caching completely. Local caching stores data in the process. It's
# very fast but will go out of sync if more than one process writes to the
# database (such as when using procpool or an extensice web precense).
GAME_CACHE_TYPE = "local"
# Attributes on objects are cached aggressively for speed. If the number of
# objects is large (and their attributes are often accessed) this can use up
# a lot of memory. So every now and then Evennia checks the size of this
# cache and resets it if it's too big. This variable sets the maximum
# size (in MB).
ATTRIBUTE_CACHE_MAXSIZE = 100

######################################################################
# Evennia Database config
######################################################################

# Database config syntax for Django 1.2+.
# ENGINE - path to the the database backend. Possible choices are:
#            'django.db.backends.sqlite3', (default)
#            'django.db.backends.mysql',
#            'django.db.backends.'postgresql_psycopg2' (see Issue 241),
#            'django.db.backends.oracle' (untested).
# NAME - database name, or path to the db file for sqlite3
# USER - db admin (unused in sqlite3)
# PASSWORD - db admin password (unused in sqlite3)
# HOST - empty string is localhost (unused in sqlite3)
# PORT - empty string defaults to localhost (unused in sqlite3)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(GAME_DIR, 'evennia.db3'),
        'USER': '',
        'PASSWORD': '',
        'HOST': '',
        'PORT': ''
        }}

######################################################################
# Evennia pluggable modules
######################################################################
# Plugin modules extend Evennia in various ways. In the cases with no
# existing default, there are examples of many of these modules
# in game/gamesrc/conf/examples.

# The command parser module to use. See the default module for which
# functions it must implement
COMMAND_PARSER = "src.commands.cmdparser.cmdparser"
# The handler that outputs errors when searching
# objects using object.search().
SEARCH_AT_RESULT = "src.commands.cmdparser.at_search_result"
# The parser used in order to separate multiple
# object matches (so you can separate between same-named
# objects without using dbrefs).
SEARCH_AT_MULTIMATCH_INPUT = "src.commands.cmdparser.at_multimatch_input"
# The module holding text strings for the connection screen.
# This module should contain one or more variables
# with strings defining the look of the screen.
CONNECTION_SCREEN_MODULE = "src.commands.connection_screen"
# An optional module that, if existing, must hold a function
# named at_initial_setup(). This hook method can be used to customize
# the server's initial setup sequence (the very first startup of the system).
# The check will fail quietly if module doesn't exist or fails to load.
AT_INITIAL_SETUP_HOOK_MODULE = ""
# Module containing your custom at_server_start(), at_server_reload() and
# at_server_stop() methods. These methods will be called every time
# the server starts, reloads and resets/stops respectively.
AT_SERVER_STARTSTOP_MODULE = ""
# List of one or more module paths to modules containing a function start_
# plugin_services(application). This module will be called with the main
# Evennia Server application when the Server is initiated.
# It will be called last in the startup sequence.
SERVER_SERVICES_PLUGIN_MODULES = []
# List of one or more module paths to modules containing a function
# start_plugin_services(application). This module will be called with the
# main Evennia Portal application when the Portal is initiated.
# It will be called last in the startup sequence.
PORTAL_SERVICES_PLUGIN_MODULES = []
# Module holding MSSP meta data. This is used by MUD-crawlers to determine
# what type of game you are running, how many players you have etc.
MSSP_META_MODULE = ""
# Tuple of modules implementing lock functions. All callable functions
# inside these modules will be available as lock functions.
LOCK_FUNC_MODULES = ("src.locks.lockfuncs",)
# Module holding OOB (Out of Band) hook objects. This allows for customization
# and expansion of which hooks OOB protocols are allowed to call on the server
# protocols for attaching tracker hooks for when various object field change
OOB_PLUGIN_MODULES = ["src.server.oob_msdp"]

######################################################################
# Default command sets
######################################################################
# Note that with the exception of the unloggedin set (which is not
# stored anywhere in the databse), changing these paths will only affect
# NEW created characters/objects, not those already in play. So if you plan to
# change this, it's recommended you do it before having created a lot of objects
# (or simply reset the database after the change for simplicity). Remember
# that you should never edit things in src/. Instead copy out the examples
# in game/gamesrc/commands/examples up one level and re-point these settings
# to point to these copies instead - these you can then change as you please
# (or copy/paste from the default modules in src/ if you prefer).

# Command set used on session before player has logged in
CMDSET_UNLOGGEDIN = "src.commands.default.cmdset_unloggedin.UnloggedinCmdSet"
# Command set used on the logged-in session
CMDSET_SESSION = "src.commands.default.cmdset_session.SessionCmdSet"
# Default set for logged in player with characters (fallback)
CMDSET_CHARACTER = "src.commands.default.cmdset_character.CharacterCmdSet"
# Command set for players without a character (ooc)
CMDSET_PLAYER = "src.commands.default.cmdset_player.PlayerCmdSet"

######################################################################
# Typeclasses and other paths
######################################################################

# Server-side session class used.
SERVER_SESSION_CLASS = "src.server.serversession.ServerSession"

# Base paths for typeclassed object classes. These paths must be
# defined relative evennia's root directory. They will be searched in
# order to find relative typeclass paths.
OBJECT_TYPECLASS_PATHS = ["game.gamesrc.objects",
                          "game.gamesrc.objects.examples",
                          "contrib"]
SCRIPT_TYPECLASS_PATHS = ["game.gamesrc.scripts",
                          "game.gamesrc.scripts.examples",
                          "contrib"]
PLAYER_TYPECLASS_PATHS = ["game.gamesrc.objects", "contrib"]
CHANNEL_TYPECLASS_PATHS = ["game.gamesrc.conf", "contrib"]

# Typeclass for player objects (linked to a character) (fallback)
BASE_PLAYER_TYPECLASS = "src.players.player.Player"
# Typeclass and base for all objects (fallback)
BASE_OBJECT_TYPECLASS = "src.objects.objects.Object"
# Typeclass for character objects linked to a player (fallback)
BASE_CHARACTER_TYPECLASS = "src.objects.objects.Character"
# Typeclass for rooms (fallback)
BASE_ROOM_TYPECLASS = "src.objects.objects.Room"
# Typeclass for Exit objects (fallback).
BASE_EXIT_TYPECLASS = "src.objects.objects.Exit"
# Typeclass for Channel (fallback).
BASE_CHANNEL_TYPECLASS = "src.comms.comms.Channel"
# Typeclass for Scripts (fallback). You usually don't need to change this
# but create custom variations of scripts on a per-case basis instead.
BASE_SCRIPT_TYPECLASS = "src.scripts.scripts.DoNothing"
# The default home location used for all objects. This is used as a
# fallback if an object's normal home location is deleted. Default
# is Limbo (#2).
DEFAULT_HOME = "#2"
# The start position for new characters. Default is Limbo (#2).
#  MULTISESSION_MODE = 0, 1 - used by default unloggedin create command
#  MULTISESSION_MODE = 2 - used by default character_create command
START_LOCATION = "#2"
# Lookups of Attributes, Tags, Nicks, Aliases can be aggressively
# cached to avoid repeated database hits. This often gives noticeable
# performance gains since they are called so often. Drawback is that
# if you are accessing the database from multiple processes (such as
# from a website -not- running Evennia's own webserver) data may go
# out of sync between the processes. Keep on unless you face such
# issues.
TYPECLASS_AGGRESSIVE_CACHE = True

######################################################################
# Batch processors
######################################################################

# Python path to a directory to be searched for batch scripts
# for the batch processors (.ev and/or .py files).
BASE_BATCHPROCESS_PATHS = ['game.gamesrc.world', 'contrib']

######################################################################
# Game Time setup
######################################################################

# You don't actually have to use this, but it affects the routines in
# src.utils.gametime.py and allows for a convenient measure to
# determine the current in-game time. You can of course interpret
# "week", "month" etc as your own in-game time units as desired.

#The time factor dictates if the game world runs faster (timefactor>1)
# or slower (timefactor<1) than the real world.
TIME_FACTOR = 2.0
# These measures might or might not make sense to your game world.
TIME_SEC_PER_MIN = 60
TIME_MIN_PER_HOUR = 60
TIME_HOUR_PER_DAY = 24
TIME_DAY_PER_WEEK = 7
TIME_WEEK_PER_MONTH = 4
TIME_MONTH_PER_YEAR = 12

######################################################################
# Default Player setup and access
######################################################################

# Different Multisession modes allow a player (=account) to connect to the
# game simultaneously with multiple clients (=sessions). In modes 0,1 there is
# only one character created to the same name as the account at first login.
# In modes 1,2 no default character will be created and the MAX_NR_CHARACTERS
# value (below) defines how many characters are allowed.
#  0 - single session, one player, one character, when a new session is
#      connected, the old one is disconnected
#  1 - multiple sessions, one player, one character, each session getting
#      the same data
#  2 - multiple sessions, one player, many characters, each session getting
#      data from different characters
MULTISESSION_MODE = 0
# The maximum number of characters allowed for MULTISESSION_MODE 2. This is
# checked
# by the default ooc char-creation command. Forced to 1 for
# MULTISESSION_MODE 0 and 1.
MAX_NR_CHARACTERS = 1
# The access hiearchy, in climbing order. A higher permission in the
# hierarchy includes access of all levels below it. Used by the perm()/pperm()
# lock functions.
PERMISSION_HIERARCHY = ("Players",
                        "PlayerHelpers",
                        "Builders",
                        "Wizards",
                        "Immortals")
# The default permission given to all new players
PERMISSION_PLAYER_DEFAULT = "Players"

######################################################################
# In-game Channels created from server start
######################################################################

# Each default channel is defined by a tuple containing
# (name, aliases, description, locks)
# where aliases may be a tuple too, and locks is
# a valid lockstring definition.
# Default user channel for communication
CHANNEL_PUBLIC = ("Public", ('ooc',), 'Public discussion',
                  "control:perm(Wizards);listen:all();send:all()")
# General info about the server
CHANNEL_MUDINFO = ("MUDinfo", '', 'Informative messages',
                 "control:perm(Immortals);listen:perm(Immortals);send:false()")
# Channel showing when new people connecting
CHANNEL_CONNECTINFO = ("MUDconnections", '', 'Connection log',
                    "control:perm(Immortals);listen:perm(Wizards);send:false()")

######################################################################
# External Channel connections
######################################################################

# Note: You do *not* have to make your MUD open to
# the public to use the external connections, they
# operate as long as you have an internet connection,
# just like stand-alone chat clients. IRC and IMC2
# requires that you have twisted.words installed.

# Evennia can connect to external IRC channels and
# echo what is said on the channel to IRC and vice
# versa. Obs - make sure the IRC network allows bots.
# When enabled, command @irc2chan will be available in-game
IRC_ENABLED = False
# RSS allows to connect RSS feeds (from forum updates, blogs etc) to
# an in-game channel. The channel will be updated when the rss feed
# updates. Use @rss2chan in game to connect if this setting is
# active. OBS: RSS support requires the python-feedparser package to
# be installed (through package manager or from the website
# http://code.google.com/p/feedparser/)
RSS_ENABLED=False
RSS_UPDATE_INTERVAL = 60*10 # 10 minutes

# IMC (Inter-MUD communication) allows to connect an Evennia channel
# to an IMC2 server. This lets them talk to people on other MUDs also
# using IMC.  Evennia's IMC2 client was developed against MudByte's
# network. You must register your MUD on the network before you can
# use it, go to http://www.mudbytes.net/imc2-intermud-join-network.
# Choose 'Other unsupported IMC2 version' from the choices and and
# enter your information there. You should enter the same 'short mud
# name' as your SERVERNAME above, then choose imc network server as
# well as client/server passwords same as below. When enabled, the
# command @imc2chan becomes available in-game and allows you to
# connect Evennia channels to IMC channels on the network. The Evennia
# discussion channel 'ievennia' is on server01.mudbytes.net:5000.

# NOTE - IMC2 is currently NOT FUNCTIONAL due to lack of testing means.
IMC2_ENABLED = False
IMC2_NETWORK = "server01.mudbytes.net"
IMC2_PORT = 5000 # this is the imc2 port, not on localhost
IMC2_CLIENT_PWD = ""
IMC2_SERVER_PWD = ""


######################################################################
# Django web features
######################################################################

# While DEBUG is False, show a regular server error page on the web
# stuff, email the traceback to the people in the ADMINS tuple
# below. If True, show a detailed traceback for the web
# browser to display. Note however that this will leak memory when
# active, so make sure to turn it off for a production server!
DEBUG = False
# While true, show "pretty" error messages for template syntax errors.
TEMPLATE_DEBUG = DEBUG
# Emails are sent to these people if the above DEBUG value is False. If you'd
# rather nobody recieve emails, leave this commented out or empty.
ADMINS = () #'Your Name', 'your_email@domain.com'),)
# These guys get broken link notifications when SEND_BROKEN_LINK_EMAILS is True.
MANAGERS = ADMINS
# Absolute path to the directory that holds media (no trailing slash).
# Example: "/home/media/media.lawrence.com"
MEDIA_ROOT = os.path.join(SRC_DIR, 'web', 'media')
# Absolute path to the directory that holds (usually links to) the
# django admin media files. If the target directory does not exist, it
# is created and linked by Evennia upon first start. Otherwise link it
# manually to django/contrib/admin/media.
ADMIN_MEDIA_ROOT = os.path.join(MEDIA_ROOT, 'admin')
# It's safe to dis-regard this, as it's a Django feature we only half use as a
# dependency, not actually what it's primarily meant for.
SITE_ID = 1
# The age for sessions.
# Default: 1209600 (2 weeks, in seconds)
SESSION_COOKIE_AGE = 1209600
# Session cookie domain
# Default: None
SESSION_COOKIE_DOMAIN = None
# The name of the cookie to use for sessions.
# Default: 'sessionid'
SESSION_COOKIE_NAME = 'sessionid'
# Should the session expire when the browser closes?
# Default: False
SESSION_EXPIRE_AT_BROWSER_CLOSE = False
# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = False
# Where to find locales (no need to change this, most likely)
LOCALE_PATHS = ["../locale/"]
# This should be turned off unless you want to do tests with Django's
# development webserver (normally Evennia runs its own server)
SERVE_MEDIA = False
# The master urlconf file that contains all of the sub-branches to the
# applications.
ROOT_URLCONF = 'src.web.urls'
# Where users are redirected after logging in via contrib.auth.login.
LOGIN_REDIRECT_URL = '/'
# Where to redirect users when using the @login_required decorator.
LOGIN_URL = '/accounts/login'
# Where to redirect users who wish to logout.
LOGOUT_URL = '/accounts/login'
# URL that handles the media served from MEDIA_ROOT.
# Example: "http://media.lawrence.com"
MEDIA_URL = '/media/'
# URL prefix for admin media -- CSS, JavaScript and images. Make sure
# to use a trailing slash. Django1.4+ will look for admin files under
# STATIC_URL/admin.
STATIC_URL = '/media/'
# The name of the currently selected web template. This corresponds to the
# directory names shown in the webtemplates directory.
ACTIVE_TEMPLATE = 'prosimii'
# We setup the location of the website template as well as the admin site.
TEMPLATE_DIRS = (
    os.path.join(SRC_DIR, "web", "templates", ACTIVE_TEMPLATE),
    os.path.join(SRC_DIR, "web", "templates"),)
# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',)
# MiddleWare are semi-transparent extensions to Django's functionality.
# see http://www.djangoproject.com/documentation/middleware/ for a more detailed
# explanation.
MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',  # 1.4?
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.middleware.doc.XViewMiddleware',
    'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware',)
# Context processors define context variables, generally for the template
# system to use.
TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.i18n',
    'django.core.context_processors.request',
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.media',
    'django.core.context_processors.debug',
    'src.web.utils.general_context.general_context',)

######################################################################
# Evennia components
######################################################################

# Global and Evennia-specific apps. This ties everything together so we can
# refer to app models and perform DB syncs.
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.sites',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.admin',
    'django.contrib.admindocs',
    'django.contrib.flatpages',
    'src.server',
    'src.typeclasses',
    'src.players',
    'src.objects',
    'src.comms',
    'src.help',
    'src.scripts',
    'src.web.news',
    'src.web.website',)
# The user profile extends the User object with more functionality;
# This should usually not be changed.
AUTH_USER_MODEL = "players.PlayerDB"
#AUTH_PROFILE_MODULE = "players.PlayerDB"
# Use a custom test runner that just tests Evennia-specific apps.
TEST_RUNNER = 'src.server.tests.EvenniaTestSuiteRunner'

######################################################################
# Django extensions
######################################################################

# Django extesions are useful third-party tools that are not
# always included in the default django distro.
try:
    import django_extensions
    INSTALLED_APPS = INSTALLED_APPS + ('django_extensions',)
except ImportError:
    pass
# South handles automatic database scheme migrations when evennia
# updates
try:
    import south
    INSTALLED_APPS = INSTALLED_APPS + ('south',)
except ImportError:
    pass

#######################################################################
# SECRET_KEY
#######################################################################
# This is the salt for cryptographic hashing used by Django.
# It is a fallback for the SECRET_KEY setting in settings.py, which
# is randomly seeded when settings.py is first created. If copying
# from here, make sure to change it!
SECRET_KEY = 'changeme!(*#&*($&*(#*(&SDFKJJKLS*(@#KJAS'

########NEW FILE########
__FILENAME__ = test_commands_cmdhandler
import unittest

class TestGetAndMergeCmdsets(unittest.TestCase):
    def test_get_and_merge_cmdsets(self):
        # self.assertEqual(expected, get_and_merge_cmdsets(caller, session, player, obj, callertype, sessid))
        assert True # TODO: implement your test here

class TestCmdhandler(unittest.TestCase):
    def test_cmdhandler(self):
        # self.assertEqual(expected, cmdhandler(called_by, raw_string, testing, callertype, sessid))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_commands_cmdparser
import unittest

class TestCmdparser(unittest.TestCase):
    def test_cmdparser(self):
        # self.assertEqual(expected, cmdparser(raw_string, cmdset, caller, match_index))
        assert True # TODO: implement your test here

class TestAtSearchResult(unittest.TestCase):
    def test_at_search_result(self):
        # self.assertEqual(expected, at_search_result(msg_obj, ostring, results, global_search, nofound_string, multimatch_string))
        assert True # TODO: implement your test here

class TestAtMultimatchInput(unittest.TestCase):
    def test_at_multimatch_input(self):
        # self.assertEqual(expected, at_multimatch_input(ostring))
        assert True # TODO: implement your test here

class TestAtMultimatchCmd(unittest.TestCase):
    def test_at_multimatch_cmd(self):
        # self.assertEqual(expected, at_multimatch_cmd(caller, matches))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_commands_cmdset
import unittest

class test__CmdSetMeta(unittest.TestCase):
    def test___init__(self):
        # __cmd_set_meta = _CmdSetMeta(*args, **kwargs)
        assert True # TODO: implement your test here

class TestCmdSet(unittest.TestCase):
    def test___add__(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.__add__(cmdset_b))
        assert True # TODO: implement your test here

    def test___contains__(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.__contains__(othercmd))
        assert True # TODO: implement your test here

    def test___init__(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        assert True # TODO: implement your test here

    def test___iter__(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.__iter__())
        assert True # TODO: implement your test here

    def test___str__(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.__str__())
        assert True # TODO: implement your test here

    def test_add(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.add(cmd))
        assert True # TODO: implement your test here

    def test_at_cmdset_creation(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.at_cmdset_creation())
        assert True # TODO: implement your test here

    def test_count(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.count())
        assert True # TODO: implement your test here

    def test_get(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.get(cmd))
        assert True # TODO: implement your test here

    def test_get_all_cmd_keys_and_aliases(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.get_all_cmd_keys_and_aliases(caller))
        assert True # TODO: implement your test here

    def test_get_system_cmds(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.get_system_cmds())
        assert True # TODO: implement your test here

    def test_make_unique(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.make_unique(caller))
        assert True # TODO: implement your test here

    def test_remove(self):
        # cmd_set = CmdSet(cmdsetobj, key)
        # self.assertEqual(expected, cmd_set.remove(cmd))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_commands_cmdsethandler
import unittest

class TestImportCmdset(unittest.TestCase):
    def test_import_cmdset(self):
        # self.assertEqual(expected, import_cmdset(python_path, cmdsetobj, emit_to_obj, no_logging))
        assert True # TODO: implement your test here

class TestCmdSetHandler(unittest.TestCase):
    def test___init__(self):
        # cmd_set_handler = CmdSetHandler(obj)
        assert True # TODO: implement your test here

    def test___str__(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.__str__())
        assert True # TODO: implement your test here

    def test_add(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.add(cmdset, emit_to_obj, permanent))
        assert True # TODO: implement your test here

    def test_add_default(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.add_default(cmdset, emit_to_obj, permanent))
        assert True # TODO: implement your test here

    def test_all(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.all())
        assert True # TODO: implement your test here

    def test_clear(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.clear())
        assert True # TODO: implement your test here

    def test_delete(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.delete(cmdset))
        assert True # TODO: implement your test here

    def test_delete_default(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.delete_default())
        assert True # TODO: implement your test here

    def test_has_cmdset(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.has_cmdset(cmdset_key, must_be_default))
        assert True # TODO: implement your test here

    def test_reset(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.reset())
        assert True # TODO: implement your test here

    def test_update(self):
        # cmd_set_handler = CmdSetHandler(obj)
        # self.assertEqual(expected, cmd_set_handler.update(init_mode))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_commands_command
import unittest

class TestCommandMeta(unittest.TestCase):
    def test___init__(self):
        # command_meta = CommandMeta(*args, **kwargs)
        assert True # TODO: implement your test here

class TestCommand(unittest.TestCase):
    def test___contains__(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.__contains__(query))
        assert True # TODO: implement your test here

    def test___eq__(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.__eq__(cmd))
        assert True # TODO: implement your test here

    def test___init__(self):
        # command = Command(**kwargs)
        assert True # TODO: implement your test here

    def test___ne__(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.__ne__(cmd))
        assert True # TODO: implement your test here

    def test___str__(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.__str__())
        assert True # TODO: implement your test here

    def test_access(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.access(srcobj, access_type, default))
        assert True # TODO: implement your test here

    def test_at_post_cmd(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.at_post_cmd())
        assert True # TODO: implement your test here

    def test_at_pre_cmd(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.at_pre_cmd())
        assert True # TODO: implement your test here

    def test_func(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.func())
        assert True # TODO: implement your test here

    def test_match(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.match(cmdname))
        assert True # TODO: implement your test here

    def test_msg(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.msg(msg, to_obj, from_obj, sessid, all_sessions, **kwargs))
        assert True # TODO: implement your test here

    def test_parse(self):
        # command = Command(**kwargs)
        # self.assertEqual(expected, command.parse())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_comms_channelhandler
import unittest

class TestChannelCommand(unittest.TestCase):
    def test_func(self):
        # channel_command = ChannelCommand()
        # self.assertEqual(expected, channel_command.func())
        assert True # TODO: implement your test here

    def test_parse(self):
        # channel_command = ChannelCommand()
        # self.assertEqual(expected, channel_command.parse())
        assert True # TODO: implement your test here

class TestChannelHandler(unittest.TestCase):
    def test___init__(self):
        # channel_handler = ChannelHandler()
        assert True # TODO: implement your test here

    def test___str__(self):
        # channel_handler = ChannelHandler()
        # self.assertEqual(expected, channel_handler.__str__())
        assert True # TODO: implement your test here

    def test_add_channel(self):
        # channel_handler = ChannelHandler()
        # self.assertEqual(expected, channel_handler.add_channel(channel))
        assert True # TODO: implement your test here

    def test_clear(self):
        # channel_handler = ChannelHandler()
        # self.assertEqual(expected, channel_handler.clear())
        assert True # TODO: implement your test here

    def test_get_cmdset(self):
        # channel_handler = ChannelHandler()
        # self.assertEqual(expected, channel_handler.get_cmdset(source_object))
        assert True # TODO: implement your test here

    def test_update(self):
        # channel_handler = ChannelHandler()
        # self.assertEqual(expected, channel_handler.update())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_comms_comms
import unittest

class TestChannel(unittest.TestCase):
    def test_at_channel_create(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.at_channel_create())
        assert True # TODO: implement your test here

    def test_at_init(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.at_init())
        assert True # TODO: implement your test here

    def test_channel_prefix(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.channel_prefix(msg, emit))
        assert True # TODO: implement your test here

    def test_distribute_message(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.distribute_message(msg, online))
        assert True # TODO: implement your test here

    def test_format_external(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.format_external(msg, senders, emit))
        assert True # TODO: implement your test here

    def test_format_message(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.format_message(msg, emit))
        assert True # TODO: implement your test here

    def test_format_senders(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.format_senders(senders))
        assert True # TODO: implement your test here

    def test_message_transform(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.message_transform(msg, emit, prefix, sender_strings, external))
        assert True # TODO: implement your test here

    def test_msg(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.msg(msgobj, header, senders, sender_strings, persistent, online, emit, external))
        assert True # TODO: implement your test here

    def test_pose_transform(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.pose_transform(msg, sender_string))
        assert True # TODO: implement your test here

    def test_post_join_channel(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.post_join_channel(joiner))
        assert True # TODO: implement your test here

    def test_post_leave_channel(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.post_leave_channel(leaver))
        assert True # TODO: implement your test here

    def test_post_send_message(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.post_send_message(msg))
        assert True # TODO: implement your test here

    def test_pre_join_channel(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.pre_join_channel(joiner))
        assert True # TODO: implement your test here

    def test_pre_leave_channel(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.pre_leave_channel(leaver))
        assert True # TODO: implement your test here

    def test_pre_send_message(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.pre_send_message(msg))
        assert True # TODO: implement your test here

    def test_tempmsg(self):
        # channel = Channel()
        # self.assertEqual(expected, channel.tempmsg(message, header, senders))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_comms_models
import unittest

class TestMsg(unittest.TestCase):
    def test___init__(self):
        # msg = Msg(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # msg = Msg(*args, **kwargs)
        # self.assertEqual(expected, msg.__str__())
        assert True # TODO: implement your test here

    def test_remove_receiver(self):
        # msg = Msg(*args, **kwargs)
        # self.assertEqual(expected, msg.remove_receiver(obj))
        assert True # TODO: implement your test here

    def test_remove_sender(self):
        # msg = Msg(*args, **kwargs)
        # self.assertEqual(expected, msg.remove_sender(value))
        assert True # TODO: implement your test here

class TestTempMsg(unittest.TestCase):
    def test___init__(self):
        # temp_msg = TempMsg(senders, receivers, channels, message, header, type, lockstring, hide_from)
        assert True # TODO: implement your test here

    def test___str__(self):
        # temp_msg = TempMsg(senders, receivers, channels, message, header, type, lockstring, hide_from)
        # self.assertEqual(expected, temp_msg.__str__())
        assert True # TODO: implement your test here

    def test_access(self):
        # temp_msg = TempMsg(senders, receivers, channels, message, header, type, lockstring, hide_from)
        # self.assertEqual(expected, temp_msg.access(accessing_obj, access_type, default))
        assert True # TODO: implement your test here

    def test_remove_receiver(self):
        # temp_msg = TempMsg(senders, receivers, channels, message, header, type, lockstring, hide_from)
        # self.assertEqual(expected, temp_msg.remove_receiver(obj))
        assert True # TODO: implement your test here

    def test_remove_sender(self):
        # temp_msg = TempMsg(senders, receivers, channels, message, header, type, lockstring, hide_from)
        # self.assertEqual(expected, temp_msg.remove_sender(obj))
        assert True # TODO: implement your test here

class TestChannelDB(unittest.TestCase):
    def test___init__(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        # self.assertEqual(expected, channel_d_b.__str__())
        assert True # TODO: implement your test here

    def test_access(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        # self.assertEqual(expected, channel_d_b.access(accessing_obj, access_type, default))
        assert True # TODO: implement your test here

    def test_connect(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        # self.assertEqual(expected, channel_d_b.connect(player))
        assert True # TODO: implement your test here

    def test_delete(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        # self.assertEqual(expected, channel_d_b.delete())
        assert True # TODO: implement your test here

    def test_disconnect(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        # self.assertEqual(expected, channel_d_b.disconnect(player))
        assert True # TODO: implement your test here

    def test_has_connection(self):
        # channel_d_b = ChannelDB(*args, **kwargs)
        # self.assertEqual(expected, channel_d_b.has_connection(player))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_locks_lockfuncs
import unittest

class TestTrue(unittest.TestCase):
    def test_true(self):
        # self.assertEqual(expected, true(*args, **kwargs))
        assert True # TODO: implement your test here

class TestAll(unittest.TestCase):
    def test_all(self):
        # self.assertEqual(expected, all(*args, **kwargs))
        assert True # TODO: implement your test here

class TestTrue(unittest.TestCase):
    def test_false(self):
        # self.assertEqual(expected, false(*args, **kwargs))
        assert True # TODO: implement your test here

class TestNone(unittest.TestCase):
    def test_none(self):
        # self.assertEqual(expected, none(*args, **kwargs))
        assert True # TODO: implement your test here

class TestSelf(unittest.TestCase):
    def test_self(self):
        # self.assertEqual(expected, self(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestPerm(unittest.TestCase):
    def test_perm(self):
        # self.assertEqual(expected, perm(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestPermAbove(unittest.TestCase):
    def test_perm_above(self):
        # self.assertEqual(expected, perm_above(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestPperm(unittest.TestCase):
    def test_pperm(self):
        # self.assertEqual(expected, pperm(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestPpermAbove(unittest.TestCase):
    def test_pperm_above(self):
        # self.assertEqual(expected, pperm_above(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestDbref(unittest.TestCase):
    def test_dbref(self):
        # self.assertEqual(expected, dbref(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestPdbref(unittest.TestCase):
    def test_pdbref(self):
        # self.assertEqual(expected, pdbref(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestId(unittest.TestCase):
    def test_id(self):
        # self.assertEqual(expected, id(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestPid(unittest.TestCase):
    def test_pid(self):
        # self.assertEqual(expected, pid(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttr(unittest.TestCase):
    def test_attr(self):
        # self.assertEqual(expected, attr(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestObjattr(unittest.TestCase):
    def test_objattr(self):
        # self.assertEqual(expected, objattr(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestLocattr(unittest.TestCase):
    def test_locattr(self):
        # self.assertEqual(expected, locattr(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttrEq(unittest.TestCase):
    def test_attr_eq(self):
        # self.assertEqual(expected, attr_eq(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttrGt(unittest.TestCase):
    def test_attr_gt(self):
        # self.assertEqual(expected, attr_gt(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttrGe(unittest.TestCase):
    def test_attr_ge(self):
        # self.assertEqual(expected, attr_ge(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttrLt(unittest.TestCase):
    def test_attr_lt(self):
        # self.assertEqual(expected, attr_lt(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttrLe(unittest.TestCase):
    def test_attr_le(self):
        # self.assertEqual(expected, attr_le(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestAttrNe(unittest.TestCase):
    def test_attr_ne(self):
        # self.assertEqual(expected, attr_ne(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestHolds(unittest.TestCase):
    def test_holds(self):
        # self.assertEqual(expected, holds(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

class TestSuperuser(unittest.TestCase):
    def test_superuser(self):
        # self.assertEqual(expected, superuser(*args, **kwargs))
        assert True # TODO: implement your test here

class TestServersetting(unittest.TestCase):
    def test_serversetting(self):
        # self.assertEqual(expected, serversetting(accessing_obj, accessed_obj, *args, **kwargs))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_locks_lockhandler
import unittest

class TestLockHandler(unittest.TestCase):
    def test___init__(self):
        # lock_handler = LockHandler(obj)
        assert True # TODO: implement your test here

    def test___str__(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.__str__())
        assert True # TODO: implement your test here

    def test_add(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.add(lockstring))
        assert True # TODO: implement your test here

    def test_cache_lock_bypass(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.cache_lock_bypass(obj))
        assert True # TODO: implement your test here

    def test_check(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.check(accessing_obj, access_type, default, no_superuser_bypass))
        assert True # TODO: implement your test here

    def test_check_lockstring(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.check_lockstring(accessing_obj, lockstring, no_superuser_bypass))
        assert True # TODO: implement your test here

    def test_clear(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.clear())
        assert True # TODO: implement your test here

    def test_delete(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.delete(access_type))
        assert True # TODO: implement your test here

    def test_get(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.get(access_type))
        assert True # TODO: implement your test here

    def test_replace(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.replace(lockstring))
        assert True # TODO: implement your test here

    def test_reset(self):
        # lock_handler = LockHandler(obj)
        # self.assertEqual(expected, lock_handler.reset())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_objects_models
import unittest

class TestObjectDB(unittest.TestCase):
    def test___init__(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        assert True # TODO: implement your test here

    def test_clear_contents(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.clear_contents())
        assert True # TODO: implement your test here

    def test_clear_exits(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.clear_exits())
        assert True # TODO: implement your test here

    def test_contents_get(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.contents_get(exclude))
        assert True # TODO: implement your test here

    def test_copy(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.copy(new_key))
        assert True # TODO: implement your test here

    def test_delete(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.delete())
        assert True # TODO: implement your test here

    def test_execute_cmd(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.execute_cmd(raw_string, sessid))
        assert True # TODO: implement your test here

    def test_move_to(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.move_to(destination, quiet, emit_to_obj, use_destination, to_none))
        assert True # TODO: implement your test here

    def test_msg(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.msg(text, from_obj, sessid, **kwargs))
        assert True # TODO: implement your test here

    def test_msg_contents(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.msg_contents(message, exclude, from_obj, **kwargs))
        assert True # TODO: implement your test here

    def test_search(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.search(searchdata, global_search, use_nicks, typeclass, location, attribute_name, quiet, exact))
        assert True # TODO: implement your test here

    def test_search_player(self):
        # object_d_b = ObjectDB(*args, **kwargs)
        # self.assertEqual(expected, object_d_b.search_player(searchdata, quiet))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_objects_objects
import unittest

class TestObject(unittest.TestCase):
    def test___eq__(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.__eq__(other))
        assert True # TODO: implement your test here

    def test___init__(self):
        # object = Object(dbobj)
        assert True # TODO: implement your test here

    def test_access(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.access(accessing_obj, access_type, default, **kwargs))
        assert True # TODO: implement your test here

    def test_announce_move_from(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.announce_move_from(destination))
        assert True # TODO: implement your test here

    def test_announce_move_to(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.announce_move_to(source_location))
        assert True # TODO: implement your test here

    def test_at_access(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_access(result, accessing_obj, access_type, **kwargs))
        assert True # TODO: implement your test here

    def test_at_access_failure(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_access_failure(accessing_obj, access_type))
        assert True # TODO: implement your test here

    def test_at_access_success(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_access_success(accessing_obj, access_type))
        assert True # TODO: implement your test here

    def test_at_after_move(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_after_move(source_location))
        assert True # TODO: implement your test here

    def test_at_after_traverse(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_after_traverse(traversing_object, source_location))
        assert True # TODO: implement your test here

    def test_at_before_move(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_before_move(destination))
        assert True # TODO: implement your test here

    def test_at_before_traverse(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_before_traverse(traversing_object))
        assert True # TODO: implement your test here

    def test_at_cmdset_get(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_cmdset_get())
        assert True # TODO: implement your test here

    def test_at_desc(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_desc(looker))
        assert True # TODO: implement your test here

    def test_at_drop(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_drop(dropper))
        assert True # TODO: implement your test here

    def test_at_failed_traverse(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_failed_traverse(traversing_object))
        assert True # TODO: implement your test here

    def test_at_get(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_get(getter))
        assert True # TODO: implement your test here

    def test_at_init(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_init())
        assert True # TODO: implement your test here

    def test_at_msg_receive(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_msg_receive(text, **kwargs))
        assert True # TODO: implement your test here

    def test_at_msg_send(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_msg_send(text, to_obj, **kwargs))
        assert True # TODO: implement your test here

    def test_at_object_creation(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_object_creation())
        assert True # TODO: implement your test here

    def test_at_object_delete(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_object_delete())
        assert True # TODO: implement your test here

    def test_at_object_leave(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_object_leave(moved_obj, target_location))
        assert True # TODO: implement your test here

    def test_at_object_receive(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_object_receive(moved_obj, source_location))
        assert True # TODO: implement your test here

    def test_at_post_puppet(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_post_puppet())
        assert True # TODO: implement your test here

    def test_at_post_unpuppet(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_post_unpuppet(player, sessid))
        assert True # TODO: implement your test here

    def test_at_pre_puppet(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_pre_puppet(player, sessid))
        assert True # TODO: implement your test here

    def test_at_pre_unpuppet(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_pre_unpuppet())
        assert True # TODO: implement your test here

    def test_at_say(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_say(speaker, message))
        assert True # TODO: implement your test here

    def test_at_server_reload(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_server_reload())
        assert True # TODO: implement your test here

    def test_at_server_shutdown(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_server_shutdown())
        assert True # TODO: implement your test here

    def test_at_traverse(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.at_traverse(traversing_object, target_location))
        assert True # TODO: implement your test here

    def test_basetype_posthook_setup(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.basetype_posthook_setup())
        assert True # TODO: implement your test here

    def test_basetype_setup(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.basetype_setup())
        assert True # TODO: implement your test here

    def test_check_permstring(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.check_permstring(permstring))
        assert True # TODO: implement your test here

    def test_copy(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.copy(new_key))
        assert True # TODO: implement your test here

    def test_delete(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.delete())
        assert True # TODO: implement your test here

    def test_execute_cmd(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.execute_cmd(raw_string, sessid))
        assert True # TODO: implement your test here

    def test_is_typeclass(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.is_typeclass(typeclass, exact))
        assert True # TODO: implement your test here

    def test_move_to(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.move_to(destination, quiet, emit_to_obj, use_destination, to_none))
        assert True # TODO: implement your test here

    def test_msg(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.msg(text, from_obj, sessid, **kwargs))
        assert True # TODO: implement your test here

    def test_msg_contents(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.msg_contents(text, exclude, from_obj, **kwargs))
        assert True # TODO: implement your test here

    def test_return_appearance(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.return_appearance(pobject))
        assert True # TODO: implement your test here

    def test_search(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.search(ostring, global_search, use_nicks, typeclass, location, attribute_name, quiet, exact))
        assert True # TODO: implement your test here

    def test_swap_typeclass(self):
        # object = Object(dbobj)
        # self.assertEqual(expected, object.swap_typeclass(new_typeclass, clean_attributes, no_default))
        assert True # TODO: implement your test here

class TestCharacter(unittest.TestCase):
    def test_at_after_move(self):
        # character = Character()
        # self.assertEqual(expected, character.at_after_move(source_location))
        assert True # TODO: implement your test here

    def test_at_object_creation(self):
        # character = Character()
        # self.assertEqual(expected, character.at_object_creation())
        assert True # TODO: implement your test here

    def test_at_post_puppet(self):
        # character = Character()
        # self.assertEqual(expected, character.at_post_puppet())
        assert True # TODO: implement your test here

    def test_at_post_unpuppet(self):
        # character = Character()
        # self.assertEqual(expected, character.at_post_unpuppet(player, sessid))
        assert True # TODO: implement your test here

    def test_at_pre_puppet(self):
        # character = Character()
        # self.assertEqual(expected, character.at_pre_puppet(player, sessid))
        assert True # TODO: implement your test here

    def test_basetype_setup(self):
        # character = Character()
        # self.assertEqual(expected, character.basetype_setup())
        assert True # TODO: implement your test here

class TestRoom(unittest.TestCase):
    def test_basetype_setup(self):
        # room = Room()
        # self.assertEqual(expected, room.basetype_setup())
        assert True # TODO: implement your test here

class TestExit(unittest.TestCase):
    def test_at_after_traverse(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.at_after_traverse(traversing_object, source_location))
        assert True # TODO: implement your test here

    def test_at_cmdset_get(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.at_cmdset_get())
        assert True # TODO: implement your test here

    def test_at_failed_traverse(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.at_failed_traverse(traversing_object))
        assert True # TODO: implement your test here

    def test_at_object_creation(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.at_object_creation())
        assert True # TODO: implement your test here

    def test_at_traverse(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.at_traverse(traversing_object, target_location))
        assert True # TODO: implement your test here

    def test_basetype_setup(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.basetype_setup())
        assert True # TODO: implement your test here

    def test_create_exit_cmdset(self):
        # exit = Exit()
        # self.assertEqual(expected, exit.create_exit_cmdset(exidbobj))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_players_bots
import unittest

class TestBotStarter(unittest.TestCase):
    def test_at_repeat(self):
        # bot_starter = BotStarter()
        # self.assertEqual(expected, bot_starter.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # bot_starter = BotStarter()
        # self.assertEqual(expected, bot_starter.at_script_creation())
        assert True # TODO: implement your test here

    def test_at_server_reload(self):
        # bot_starter = BotStarter()
        # self.assertEqual(expected, bot_starter.at_server_reload())
        assert True # TODO: implement your test here

    def test_at_server_shutdown(self):
        # bot_starter = BotStarter()
        # self.assertEqual(expected, bot_starter.at_server_shutdown())
        assert True # TODO: implement your test here

    def test_at_start(self):
        # bot_starter = BotStarter()
        # self.assertEqual(expected, bot_starter.at_start())
        assert True # TODO: implement your test here

class TestCmdBotListen(unittest.TestCase):
    def test_func(self):
        # cmd_bot_listen = CmdBotListen()
        # self.assertEqual(expected, cmd_bot_listen.func())
        assert True # TODO: implement your test here

class TestBotCmdSet(unittest.TestCase):
    def test_at_cmdset_creation(self):
        # bot_cmd_set = BotCmdSet()
        # self.assertEqual(expected, bot_cmd_set.at_cmdset_creation())
        assert True # TODO: implement your test here

class TestBot(unittest.TestCase):
    def test_basetype_setup(self):
        # bot = Bot()
        # self.assertEqual(expected, bot.basetype_setup())
        assert True # TODO: implement your test here

    def test_execute_cmd(self):
        # bot = Bot()
        # self.assertEqual(expected, bot.execute_cmd(raw_string, sessid))
        assert True # TODO: implement your test here

    def test_msg(self):
        # bot = Bot()
        # self.assertEqual(expected, bot.msg(text, from_obj, sessid, **kwargs))
        assert True # TODO: implement your test here

    def test_start(self):
        # bot = Bot()
        # self.assertEqual(expected, bot.start(**kwargs))
        assert True # TODO: implement your test here

class TestIRCBot(unittest.TestCase):
    def test_execute_cmd(self):
        # i_rc_bot = IRCBot()
        # self.assertEqual(expected, i_rc_bot.execute_cmd(text, sessid))
        assert True # TODO: implement your test here

    def test_msg(self):
        # i_rc_bot = IRCBot()
        # self.assertEqual(expected, i_rc_bot.msg(text, **kwargs))
        assert True # TODO: implement your test here

    def test_start(self):
        # i_rc_bot = IRCBot()
        # self.assertEqual(expected, i_rc_bot.start(ev_channel, irc_botname, irc_channel, irc_network, irc_port))
        assert True # TODO: implement your test here

class TestRSSBot(unittest.TestCase):
    def test_execute_cmd(self):
        # r_ss_bot = RSSBot()
        # self.assertEqual(expected, r_ss_bot.execute_cmd(text, sessid))
        assert True # TODO: implement your test here

    def test_start(self):
        # r_ss_bot = RSSBot()
        # self.assertEqual(expected, r_ss_bot.start(ev_channel, rss_url, rss_rate))
        assert True # TODO: implement your test here

class TestIMC2Bot(unittest.TestCase):
    def test_execute_cmd(self):
        # i_m_c2_bot = IMC2Bot()
        # self.assertEqual(expected, i_m_c2_bot.execute_cmd(text, sessid))
        assert True # TODO: implement your test here

    def test_msg(self):
        # i_m_c2_bot = IMC2Bot()
        # self.assertEqual(expected, i_m_c2_bot.msg(text, **kwargs))
        assert True # TODO: implement your test here

    def test_start(self):
        # i_m_c2_bot = IMC2Bot()
        # self.assertEqual(expected, i_m_c2_bot.start(ev_channel, imc2_network, imc2_mudname, imc2_port, imc2_client_pwd, imc2_server_pwd))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_players_models
import unittest

class TestPlayerDB(unittest.TestCase):
    def test___init__(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.__unicode__())
        assert True # TODO: implement your test here

    def test_cmdset_storage_del(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.cmdset_storage_del())
        assert True # TODO: implement your test here

    def test_cmdset_storage_get(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.cmdset_storage_get())
        assert True # TODO: implement your test here

    def test_cmdset_storage_set(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.cmdset_storage_set(value))
        assert True # TODO: implement your test here

    def test_delete(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.delete(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_disconnect_session_from_player(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.disconnect_session_from_player(sessid))
        assert True # TODO: implement your test here

    def test_execute_cmd(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.execute_cmd(raw_string, sessid))
        assert True # TODO: implement your test here

    def test_get_all_puppets(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.get_all_puppets(return_dbobj))
        assert True # TODO: implement your test here

    def test_get_all_sessions(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.get_all_sessions())
        assert True # TODO: implement your test here

    def test_get_puppet(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.get_puppet(sessid, return_dbobj))
        assert True # TODO: implement your test here

    def test_get_session(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.get_session(sessid))
        assert True # TODO: implement your test here

    def test_msg(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.msg(text, from_obj, sessid, **kwargs))
        assert True # TODO: implement your test here

    def test_puppet_object(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.puppet_object(sessid, obj, normal_mode))
        assert True # TODO: implement your test here

    def test_search(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.search(ostring, return_puppet, return_character, **kwargs))
        assert True # TODO: implement your test here

    def test_unpuppet_all(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.unpuppet_all())
        assert True # TODO: implement your test here

    def test_unpuppet_object(self):
        # player_d_b = PlayerDB(*args, **kwargs)
        # self.assertEqual(expected, player_d_b.unpuppet_object(sessid))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_scripts_models
try:
    # this is an optimized version only available in later Django versions
    from django.utils.unittest import TestCase
except ImportError:
    # if the first fails, we use the old version
    from django.test import TestCase

from src.scripts.models import ScriptDB, ObjectDoesNotExist
from src.utils.create import create_script
from src.scripts import DoNothing
import unittest
from django.conf import settings


class TestScriptDB(TestCase):
    "Check the singleton/static ScriptDB object works correctly"
    def setUp(self):
        self.scr = create_script(DoNothing)

    def tearDown(self):
        self.scr.delete()
        del self.scr

    def test_delete(self):
        "Check the script is removed from the database"
        self.scr.delete()
        self.assertFalse(self.scr in ScriptDB.objects.get_all_scripts())

    def test_double_delete(self):
        "What should happen? Isn't it already deleted?"
        self.scr.delete()
        self.scr.delete()

    @unittest.skip("not implemented")
    def test___init__fails(self):  # Users should be told not to do this
        with self.assertRaises(Exception):
            ScriptDB()

    @unittest.skip("not implemented")
    def test_deleted_script_fails_start(self):
        "Would it ever be necessary to start a deleted script?"
        self.scr.delete()
        with self.assertRaises(ObjectDoesNotExist):  # See issue #509
            self.scr.start()
        # Check the script is not recreated as a side-effect
        self.assertFalse(self.scr in ScriptDB.objects.get_all_scripts())
        self.scr = create_script(DoNothing)  # for tearDown()

    @unittest.skip("not implemented")
    def test_deleted_script_is_invalid(self):
        "Can deleted scripts be said to be valid?"
        self.scr.delete()
        self.assertFalse(self.scr.is_valid())  # assertRaises? See issue #509
        self.scr = create_script(DoNothing)  # for tearDown()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_scripts_scripthandler
import unittest

class TestScriptHandler(unittest.TestCase):
    def test___init__(self):
        # script_handler = ScriptHandler(obj)
        assert True # TODO: implement your test here

    def test___str__(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.__str__())
        assert True # TODO: implement your test here

    def test_add(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.add(scriptclass, key, autostart))
        assert True # TODO: implement your test here

    def test_all(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.all(scriptid))
        assert True # TODO: implement your test here

    def test_delete(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.delete(scriptid))
        assert True # TODO: implement your test here

    def test_start(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.start(scriptid))
        assert True # TODO: implement your test here

    def test_stop(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.stop(scriptid))
        assert True # TODO: implement your test here

    def test_validate(self):
        # script_handler = ScriptHandler(obj)
        # self.assertEqual(expected, script_handler.validate(init_mode))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_scripts_scripts
import unittest

class TestExtendedLoopingCall(unittest.TestCase):
    def test___call__(self):
        # extended_looping_call = ExtendedLoopingCall()
        # self.assertEqual(expected, extended_looping_call.__call__())
        assert True # TODO: implement your test here

    def test_force_repeat(self):
        # extended_looping_call = ExtendedLoopingCall()
        # self.assertEqual(expected, extended_looping_call.force_repeat())
        assert True # TODO: implement your test here

    def test_next_call_time(self):
        # extended_looping_call = ExtendedLoopingCall()
        # self.assertEqual(expected, extended_looping_call.next_call_time())
        assert True # TODO: implement your test here

    def test_start(self):
        # extended_looping_call = ExtendedLoopingCall()
        # self.assertEqual(expected, extended_looping_call.start(interval, now, start_delay, count_start))
        assert True # TODO: implement your test here

class TestScriptBase(unittest.TestCase):
    def test___eq__(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.__eq__(other))
        assert True # TODO: implement your test here

    def test_at_init(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.at_init())
        assert True # TODO: implement your test here

    def test_at_repeat(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.at_script_creation())
        assert True # TODO: implement your test here

    def test_at_start(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.at_start())
        assert True # TODO: implement your test here

    def test_at_stop(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.at_stop())
        assert True # TODO: implement your test here

    def test_force_repeat(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.force_repeat())
        assert True # TODO: implement your test here

    def test_is_valid(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.is_valid())
        assert True # TODO: implement your test here

    def test_pause(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.pause())
        assert True # TODO: implement your test here

    def test_remaining_repeats(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.remaining_repeats())
        assert True # TODO: implement your test here

    def test_start(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.start(force_restart))
        assert True # TODO: implement your test here

    def test_stop(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.stop(kill))
        assert True # TODO: implement your test here

    def test_time_until_next_repeat(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.time_until_next_repeat())
        assert True # TODO: implement your test here

    def test_unpause(self):
        # script_base = ScriptBase()
        # self.assertEqual(expected, script_base.unpause())
        assert True # TODO: implement your test here

class TestScript(unittest.TestCase):
    def test___init__(self):
        # script = Script(dbobj)
        assert True # TODO: implement your test here

    def test_at_repeat(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.at_script_creation())
        assert True # TODO: implement your test here

    def test_at_server_reload(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.at_server_reload())
        assert True # TODO: implement your test here

    def test_at_server_shutdown(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.at_server_shutdown())
        assert True # TODO: implement your test here

    def test_at_start(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.at_start())
        assert True # TODO: implement your test here

    def test_at_stop(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.at_stop())
        assert True # TODO: implement your test here

    def test_is_valid(self):
        # script = Script(dbobj)
        # self.assertEqual(expected, script.is_valid())
        assert True # TODO: implement your test here

class TestDoNothing(unittest.TestCase):
    def test_at_script_creation(self):
        # do_nothing = DoNothing()
        # self.assertEqual(expected, do_nothing.at_script_creation())
        assert True # TODO: implement your test here

class TestStore(unittest.TestCase):
    def test_at_script_creation(self):
        # store = Store()
        # self.assertEqual(expected, store.at_script_creation())
        assert True # TODO: implement your test here

class TestCheckSessions(unittest.TestCase):
    def test_at_repeat(self):
        # check_sessions = CheckSessions()
        # self.assertEqual(expected, check_sessions.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # check_sessions = CheckSessions()
        # self.assertEqual(expected, check_sessions.at_script_creation())
        assert True # TODO: implement your test here

class TestValidateScripts(unittest.TestCase):
    def test_at_repeat(self):
        # validate_scripts = ValidateScripts()
        # self.assertEqual(expected, validate_scripts.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # validate_scripts = ValidateScripts()
        # self.assertEqual(expected, validate_scripts.at_script_creation())
        assert True # TODO: implement your test here

class TestValidateChannelHandler(unittest.TestCase):
    def test_at_repeat(self):
        # validate_channel_handler = ValidateChannelHandler()
        # self.assertEqual(expected, validate_channel_handler.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # validate_channel_handler = ValidateChannelHandler()
        # self.assertEqual(expected, validate_channel_handler.at_script_creation())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_scripts_tickerhandler
import unittest

class TestTicker(unittest.TestCase):
    def test___init__(self):
        # ticker = Ticker(interval)
        assert True # TODO: implement your test here

    def test_add(self):
        # ticker = Ticker(interval)
        # self.assertEqual(expected, ticker.add(store_key, obj, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_remove(self):
        # ticker = Ticker(interval)
        # self.assertEqual(expected, ticker.remove(store_key))
        assert True # TODO: implement your test here

    def test_stop(self):
        # ticker = Ticker(interval)
        # self.assertEqual(expected, ticker.stop())
        assert True # TODO: implement your test here

    def test_validate(self):
        # ticker = Ticker(interval)
        # self.assertEqual(expected, ticker.validate(start_delay))
        assert True # TODO: implement your test here

class TestTickerPool(unittest.TestCase):
    def test___init__(self):
        # ticker_pool = TickerPool()
        assert True # TODO: implement your test here

    def test_add(self):
        # ticker_pool = TickerPool()
        # self.assertEqual(expected, ticker_pool.add(store_key, obj, interval, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_remove(self):
        # ticker_pool = TickerPool()
        # self.assertEqual(expected, ticker_pool.remove(store_key, interval))
        assert True # TODO: implement your test here

    def test_stop(self):
        # ticker_pool = TickerPool()
        # self.assertEqual(expected, ticker_pool.stop(interval))
        assert True # TODO: implement your test here

class TestTickerHandler(unittest.TestCase):
    def test___init__(self):
        # ticker_handler = TickerHandler(save_name)
        assert True # TODO: implement your test here

    def test_add(self):
        # ticker_handler = TickerHandler(save_name)
        # self.assertEqual(expected, ticker_handler.add(obj, interval, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_all(self):
        # ticker_handler = TickerHandler(save_name)
        # self.assertEqual(expected, ticker_handler.all(interval))
        assert True # TODO: implement your test here

    def test_clear(self):
        # ticker_handler = TickerHandler(save_name)
        # self.assertEqual(expected, ticker_handler.clear(interval))
        assert True # TODO: implement your test here

    def test_remove(self):
        # ticker_handler = TickerHandler(save_name)
        # self.assertEqual(expected, ticker_handler.remove(obj, interval))
        assert True # TODO: implement your test here

    def test_restore(self):
        # ticker_handler = TickerHandler(save_name)
        # self.assertEqual(expected, ticker_handler.restore())
        assert True # TODO: implement your test here

    def test_save(self):
        # ticker_handler = TickerHandler(save_name)
        # self.assertEqual(expected, ticker_handler.save())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_amp
import unittest

class TestGetRestartMode(unittest.TestCase):
    def test_get_restart_mode(self):
        # self.assertEqual(expected, get_restart_mode(restart_file))
        assert True # TODO: implement your test here

class TestAmpServerFactory(unittest.TestCase):
    def test___init__(self):
        # amp_server_factory = AmpServerFactory(server)
        assert True # TODO: implement your test here

    def test_buildProtocol(self):
        # amp_server_factory = AmpServerFactory(server)
        # self.assertEqual(expected, amp_server_factory.buildProtocol(addr))
        assert True # TODO: implement your test here

class TestAmpClientFactory(unittest.TestCase):
    def test___init__(self):
        # amp_client_factory = AmpClientFactory(portal)
        assert True # TODO: implement your test here

    def test_buildProtocol(self):
        # amp_client_factory = AmpClientFactory(portal)
        # self.assertEqual(expected, amp_client_factory.buildProtocol(addr))
        assert True # TODO: implement your test here

    def test_clientConnectionFailed(self):
        # amp_client_factory = AmpClientFactory(portal)
        # self.assertEqual(expected, amp_client_factory.clientConnectionFailed(connector, reason))
        assert True # TODO: implement your test here

    def test_clientConnectionLost(self):
        # amp_client_factory = AmpClientFactory(portal)
        # self.assertEqual(expected, amp_client_factory.clientConnectionLost(connector, reason))
        assert True # TODO: implement your test here

    def test_startedConnecting(self):
        # amp_client_factory = AmpClientFactory(portal)
        # self.assertEqual(expected, amp_client_factory.startedConnecting(connector))
        assert True # TODO: implement your test here

class TestDumps(unittest.TestCase):
    def test_dumps(self):
        # self.assertEqual(expected, dumps(data))
        assert True # TODO: implement your test here

class TestLoads(unittest.TestCase):
    def test_loads(self):
        # self.assertEqual(expected, loads(data))
        assert True # TODO: implement your test here

class TestAMPProtocol(unittest.TestCase):
    def test_amp_function_call(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.amp_function_call(module, function, args, **kwargs))
        assert True # TODO: implement your test here

    def test_amp_msg_portal2server(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.amp_msg_portal2server(sessid, ipart, nparts, msg, data))
        assert True # TODO: implement your test here

    def test_amp_msg_server2portal(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.amp_msg_server2portal(sessid, ipart, nparts, msg, data))
        assert True # TODO: implement your test here

    def test_amp_portal_admin(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.amp_portal_admin(sessid, ipart, nparts, operation, data))
        assert True # TODO: implement your test here

    def test_amp_server_admin(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.amp_server_admin(sessid, ipart, nparts, operation, data))
        assert True # TODO: implement your test here

    def test_call_remote_FunctionCall(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.call_remote_FunctionCall(modulepath, functionname, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_call_remote_MsgPortal2Server(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.call_remote_MsgPortal2Server(sessid, msg, data))
        assert True # TODO: implement your test here

    def test_call_remote_MsgServer2Portal(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.call_remote_MsgServer2Portal(sessid, msg, data))
        assert True # TODO: implement your test here

    def test_call_remote_PortalAdmin(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.call_remote_PortalAdmin(sessid, operation, data))
        assert True # TODO: implement your test here

    def test_call_remote_ServerAdmin(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.call_remote_ServerAdmin(sessid, operation, data))
        assert True # TODO: implement your test here

    def test_connectionMade(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.connectionMade())
        assert True # TODO: implement your test here

    def test_errback(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.errback(e, info))
        assert True # TODO: implement your test here

    def test_safe_recv(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.safe_recv(command, sessid, ipart, nparts, **kwargs))
        assert True # TODO: implement your test here

    def test_safe_send(self):
        # a_mp_protocol = AMPProtocol()
        # self.assertEqual(expected, a_mp_protocol.safe_send(command, sessid, **kwargs))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_caches
import unittest

class TestHashid(unittest.TestCase):
    def test_hashid(self):
        # self.assertEqual(expected, hashid(obj, suffix))
        assert True # TODO: implement your test here

class TestFieldPreSave(unittest.TestCase):
    def test_field_pre_save(self):
        # self.assertEqual(expected, field_pre_save(sender, instance, update_fields, raw, **kwargs))
        assert True # TODO: implement your test here

class TestFieldPostSave(unittest.TestCase):
    def test_field_post_save(self):
        # self.assertEqual(expected, field_post_save(sender, instance, update_fields, raw, **kwargs))
        assert True # TODO: implement your test here

class TestGetAttrCache(unittest.TestCase):
    def test_get_attr_cache(self):
        # self.assertEqual(expected, get_attr_cache(obj))
        assert True # TODO: implement your test here

class TestSetAttrCache(unittest.TestCase):
    def test_set_attr_cache(self):
        # self.assertEqual(expected, set_attr_cache(obj, store))
        assert True # TODO: implement your test here

class TestGetPropCache(unittest.TestCase):
    def test_get_prop_cache(self):
        # self.assertEqual(expected, get_prop_cache(obj, propname))
        assert True # TODO: implement your test here

class TestSetPropCache(unittest.TestCase):
    def test_set_prop_cache(self):
        # self.assertEqual(expected, set_prop_cache(obj, propname, propvalue))
        assert True # TODO: implement your test here

class TestDelPropCache(unittest.TestCase):
    def test_del_prop_cache(self):
        # self.assertEqual(expected, del_prop_cache(obj, propname))
        assert True # TODO: implement your test here

class TestFlushPropCache(unittest.TestCase):
    def test_flush_prop_cache(self):
        # self.assertEqual(expected, flush_prop_cache())
        assert True # TODO: implement your test here

class TestGetCacheSizes(unittest.TestCase):
    def test_get_cache_sizes(self):
        # self.assertEqual(expected, get_cache_sizes())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_manager
import unittest

class TestServerConfigManager(unittest.TestCase):
    def test_conf(self):
        # server_config_manager = ServerConfigManager()
        # self.assertEqual(expected, server_config_manager.conf(key, value, delete, default))
        assert True # TODO: implement your test here

    def test_get_mysql_db_version(self):
        # server_config_manager = ServerConfigManager()
        # self.assertEqual(expected, server_config_manager.get_mysql_db_version())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_models
import unittest

class TestServerConfig(unittest.TestCase):
    def test___unicode__(self):
        # server_config = ServerConfig()
        # self.assertEqual(expected, server_config.__unicode__())
        assert True # TODO: implement your test here

    def test_store(self):
        # server_config = ServerConfig()
        # self.assertEqual(expected, server_config.store(key, value))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_oobhandler
import unittest

class TestTrackerHandler(unittest.TestCase):
    def test___init__(self):
        # tracker_handler = TrackerHandler(obj)
        assert True # TODO: implement your test here

    def test_add(self):
        # tracker_handler = TrackerHandler(obj)
        # self.assertEqual(expected, tracker_handler.add(fieldname, tracker))
        assert True # TODO: implement your test here

    def test_remove(self):
        # tracker_handler = TrackerHandler(obj)
        # self.assertEqual(expected, tracker_handler.remove(fieldname, trackerclass, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_update(self):
        # tracker_handler = TrackerHandler(obj)
        # self.assertEqual(expected, tracker_handler.update(fieldname, new_value))
        assert True # TODO: implement your test here

class TestTrackerBase(unittest.TestCase):
    def test___init__(self):
        # tracker_base = TrackerBase(*args, **kwargs)
        assert True # TODO: implement your test here

    def test_at_remove(self):
        # tracker_base = TrackerBase(*args, **kwargs)
        # self.assertEqual(expected, tracker_base.at_remove(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_update(self):
        # tracker_base = TrackerBase(*args, **kwargs)
        # self.assertEqual(expected, tracker_base.update(*args, **kwargs))
        assert True # TODO: implement your test here

class TestOOBTicker(unittest.TestCase):
    def test___init__(self):
        # o_ob_ticker = OOBTicker(interval)
        assert True # TODO: implement your test here

class TestOOBHandler(unittest.TestCase):
    def test___init__(self):
        # o_ob_handler = OOBHandler()
        assert True # TODO: implement your test here

    def test_execute_cmd(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.execute_cmd(session, func_key, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_get_all_tracked(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.get_all_tracked(session))
        assert True # TODO: implement your test here

    def test_msg(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.msg(sessid, funcname, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_repeat(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.repeat(obj, sessid, func_key, interval, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_restore(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.restore())
        assert True # TODO: implement your test here

    def test_save(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.save())
        assert True # TODO: implement your test here

    def test_track(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.track(obj, sessid, fieldname, trackerclass, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_track_attribute(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.track_attribute(obj, sessid, attr_name, trackerclass))
        assert True # TODO: implement your test here

    def test_track_field(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.track_field(obj, sessid, field_name, trackerclass))
        assert True # TODO: implement your test here

    def test_unrepeat(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.unrepeat(obj, sessid, func_key, interval))
        assert True # TODO: implement your test here

    def test_untrack(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.untrack(obj, sessid, fieldname, trackerclass, *args, **kwargs))
        assert True # TODO: implement your test here

    def test_untrack_attribute(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.untrack_attribute(obj, sessid, attr_name, trackerclass))
        assert True # TODO: implement your test here

    def test_untrack_field(self):
        # o_ob_handler = OOBHandler()
        # self.assertEqual(expected, o_ob_handler.untrack_field(obj, sessid, field_name))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_oob_msdp
import unittest

class TestOOBFieldTracker(unittest.TestCase):
    def test___init__(self):
        # o_ob_field_tracker = OOBFieldTracker(oobhandler, fieldname, sessid, *args, **kwargs)
        assert True # TODO: implement your test here

    def test_update(self):
        # o_ob_field_tracker = OOBFieldTracker(oobhandler, fieldname, sessid, *args, **kwargs)
        # self.assertEqual(expected, o_ob_field_tracker.update(new_value, *args, **kwargs))
        assert True # TODO: implement your test here

class TestOOBAttributeTracker(unittest.TestCase):
    def test___init__(self):
        # o_ob_attribute_tracker = OOBAttributeTracker(oobhandler, fieldname, sessid, attrname, *args, **kwargs)
        assert True # TODO: implement your test here

    def test_update(self):
        # o_ob_attribute_tracker = OOBAttributeTracker(oobhandler, fieldname, sessid, attrname, *args, **kwargs)
        # self.assertEqual(expected, o_ob_attribute_tracker.update(new_value, *args, **kwargs))
        assert True # TODO: implement your test here

class TestOobError(unittest.TestCase):
    def test_oob_error(self):
        # self.assertEqual(expected, oob_error(oobhandler, session, errmsg, *args, **kwargs))
        assert True # TODO: implement your test here

class TestList(unittest.TestCase):
    def test_list(self):
        # self.assertEqual(expected, list(oobhandler, session, mode, *args, **kwargs))
        assert True # TODO: implement your test here

class TestSend(unittest.TestCase):
    def test_send(self):
        # self.assertEqual(expected, send(oobhandler, session, *args, **kwargs))
        assert True # TODO: implement your test here

class TestReport(unittest.TestCase):
    def test_report(self):
        # self.assertEqual(expected, report(oobhandler, session, *args, **kwargs))
        assert True # TODO: implement your test here

class TestUnreport(unittest.TestCase):
    def test_unreport(self):
        # self.assertEqual(expected, unreport(oobhandler, session, vartype, *args, **kwargs))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_server
import unittest

class TestEvennia(unittest.TestCase):
    def test___init__(self):
        # evennia = Evennia(application)
        assert True # TODO: implement your test here

    def test_run_init_hooks(self):
        # evennia = Evennia(application)
        # self.assertEqual(expected, evennia.run_init_hooks())
        assert True # TODO: implement your test here

    def test_run_initial_setup(self):
        # evennia = Evennia(application)
        # self.assertEqual(expected, evennia.run_initial_setup())
        assert True # TODO: implement your test here

    def test_set_restart_mode(self):
        # evennia = Evennia(application)
        # self.assertEqual(expected, evennia.set_restart_mode(mode))
        assert True # TODO: implement your test here

    def test_shutdown(self):
        # evennia = Evennia(application)
        # self.assertEqual(expected, evennia.shutdown(mode, _reactor_stopping))
        assert True # TODO: implement your test here

    def test_sqlite3_prep(self):
        # evennia = Evennia(application)
        # self.assertEqual(expected, evennia.sqlite3_prep())
        assert True # TODO: implement your test here

    def test_update_defaults(self):
        # evennia = Evennia(application)
        # self.assertEqual(expected, evennia.update_defaults())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_serversession
import unittest

class TestServerSession(unittest.TestCase):
    def test___eq__(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.__eq__(other))
        assert True # TODO: implement your test here

    def test___init__(self):
        # server_session = ServerSession()
        assert True # TODO: implement your test here

    def test___str__(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.__unicode__())
        assert True # TODO: implement your test here

    def test_access(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.access(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_at_cmdset_get(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.at_cmdset_get())
        assert True # TODO: implement your test here

    def test_at_disconnect(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.at_disconnect())
        assert True # TODO: implement your test here

    def test_at_login(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.at_login(player))
        assert True # TODO: implement your test here

    def test_at_sync(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.at_sync())
        assert True # TODO: implement your test here

    def test_data_in(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.data_in(text, **kwargs))
        assert True # TODO: implement your test here

    def test_data_out(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.data_out(text, **kwargs))
        assert True # TODO: implement your test here

    def test_get_player(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.get_player())
        assert True # TODO: implement your test here

    def test_get_puppet(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.get_puppet())
        assert True # TODO: implement your test here

    def test_get_puppet_or_player(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.get_puppet_or_player())
        assert True # TODO: implement your test here

    def test_log(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.log(message, channel))
        assert True # TODO: implement your test here

    def test_msg(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.msg(text, **kwargs))
        assert True # TODO: implement your test here

    def test_ndb_del(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.ndb_del())
        assert True # TODO: implement your test here

    def test_ndb_get(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.ndb_get())
        assert True # TODO: implement your test here

    def test_ndb_set(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.ndb_set(value))
        assert True # TODO: implement your test here

    def test_update_session_counters(self):
        # server_session = ServerSession()
        # self.assertEqual(expected, server_session.update_session_counters(idle))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_session
import unittest

class TestSession(unittest.TestCase):
    def test_at_sync(self):
        # session = Session()
        # self.assertEqual(expected, session.at_sync())
        assert True # TODO: implement your test here

    def test_data_in(self):
        # session = Session()
        # self.assertEqual(expected, session.data_in(text, **kwargs))
        assert True # TODO: implement your test here

    def test_data_out(self):
        # session = Session()
        # self.assertEqual(expected, session.data_out(text, **kwargs))
        assert True # TODO: implement your test here

    def test_disconnect(self):
        # session = Session()
        # self.assertEqual(expected, session.disconnect(reason))
        assert True # TODO: implement your test here

    def test_get_sync_data(self):
        # session = Session()
        # self.assertEqual(expected, session.get_sync_data())
        assert True # TODO: implement your test here

    def test_init_session(self):
        # session = Session()
        # self.assertEqual(expected, session.init_session(protocol_key, address, sessionhandler))
        assert True # TODO: implement your test here

    def test_load_sync_data(self):
        # session = Session()
        # self.assertEqual(expected, session.load_sync_data(sessdata))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_webserver
import unittest

class TestHTTPChannelWithXForwardedFor(unittest.TestCase):
    def test_allHeadersReceived(self):
        # h_ttp_channel_with_x_forwarded_for = HTTPChannelWithXForwardedFor()
        # self.assertEqual(expected, h_ttp_channel_with_x_forwarded_for.allHeadersReceived())
        assert True # TODO: implement your test here

class TestEvenniaReverseProxyResource(unittest.TestCase):
    def test_getChild(self):
        # evennia_reverse_proxy_resource = EvenniaReverseProxyResource()
        # self.assertEqual(expected, evennia_reverse_proxy_resource.getChild(path, request))
        assert True # TODO: implement your test here

    def test_render(self):
        # evennia_reverse_proxy_resource = EvenniaReverseProxyResource()
        # self.assertEqual(expected, evennia_reverse_proxy_resource.render(request))
        assert True # TODO: implement your test here

class TestDjangoWebRoot(unittest.TestCase):
    def test___init__(self):
        # django_web_root = DjangoWebRoot(pool)
        assert True # TODO: implement your test here

    def test_getChild(self):
        # django_web_root = DjangoWebRoot(pool)
        # self.assertEqual(expected, django_web_root.getChild(path, request))
        assert True # TODO: implement your test here

class TestWSGIWebServer(unittest.TestCase):
    def test___init__(self):
        # w_sgi_web_server = WSGIWebServer(pool, *args, **kwargs)
        assert True # TODO: implement your test here

    def test_startService(self):
        # w_sgi_web_server = WSGIWebServer(pool, *args, **kwargs)
        # self.assertEqual(expected, w_sgi_web_server.startService())
        assert True # TODO: implement your test here

    def test_stopService(self):
        # w_sgi_web_server = WSGIWebServer(pool, *args, **kwargs)
        # self.assertEqual(expected, w_sgi_web_server.stopService())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_typeclasses_models
import unittest

class TestAttribute(unittest.TestCase):
    def test___init__(self):
        # attribute = Attribute(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # attribute = Attribute(*args, **kwargs)
        # self.assertEqual(expected, attribute.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # attribute = Attribute(*args, **kwargs)
        # self.assertEqual(expected, attribute.__unicode__())
        assert True # TODO: implement your test here

    def test_access(self):
        # attribute = Attribute(*args, **kwargs)
        # self.assertEqual(expected, attribute.access(accessing_obj, access_type, default, **kwargs))
        assert True # TODO: implement your test here

    def test_at_set(self):
        # attribute = Attribute(*args, **kwargs)
        # self.assertEqual(expected, attribute.at_set(new_value))
        assert True # TODO: implement your test here

class TestAttributeHandler(unittest.TestCase):
    def test___init__(self):
        # attribute_handler = AttributeHandler(obj)
        assert True # TODO: implement your test here

    def test_add(self):
        # attribute_handler = AttributeHandler(obj)
        # self.assertEqual(expected, attribute_handler.add(key, value, category, lockstring, strattr, accessing_obj, default_access))
        assert True # TODO: implement your test here

    def test_all(self):
        # attribute_handler = AttributeHandler(obj)
        # self.assertEqual(expected, attribute_handler.all(accessing_obj, default_access))
        assert True # TODO: implement your test here

    def test_clear(self):
        # attribute_handler = AttributeHandler(obj)
        # self.assertEqual(expected, attribute_handler.clear(category, accessing_obj, default_access))
        assert True # TODO: implement your test here

    def test_get(self):
        # attribute_handler = AttributeHandler(obj)
        # self.assertEqual(expected, attribute_handler.get(key, category, default, return_obj, strattr, raise_exception, accessing_obj, default_access, not_found_none))
        assert True # TODO: implement your test here

    def test_has(self):
        # attribute_handler = AttributeHandler(obj)
        # self.assertEqual(expected, attribute_handler.has(key, category))
        assert True # TODO: implement your test here

    def test_remove(self):
        # attribute_handler = AttributeHandler(obj)
        # self.assertEqual(expected, attribute_handler.remove(key, raise_exception, category, accessing_obj, default_access))
        assert True # TODO: implement your test here

class TestNickHandler(unittest.TestCase):
    def test_add(self):
        # nick_handler = NickHandler()
        # self.assertEqual(expected, nick_handler.add(key, replacement, category, **kwargs))
        assert True # TODO: implement your test here

    def test_get(self):
        # nick_handler = NickHandler()
        # self.assertEqual(expected, nick_handler.get(key, category, **kwargs))
        assert True # TODO: implement your test here

    def test_has(self):
        # nick_handler = NickHandler()
        # self.assertEqual(expected, nick_handler.has(key, category))
        assert True # TODO: implement your test here

    def test_nickreplace(self):
        # nick_handler = NickHandler()
        # self.assertEqual(expected, nick_handler.nickreplace(raw_string, categories, include_player))
        assert True # TODO: implement your test here

    def test_remove(self):
        # nick_handler = NickHandler()
        # self.assertEqual(expected, nick_handler.remove(key, category, **kwargs))
        assert True # TODO: implement your test here

class TestNAttributeHandler(unittest.TestCase):
    def test___init__(self):
        # n_attribute_handler = NAttributeHandler(obj)
        assert True # TODO: implement your test here

    def test_add(self):
        # n_attribute_handler = NAttributeHandler(obj)
        # self.assertEqual(expected, n_attribute_handler.add(key, value))
        assert True # TODO: implement your test here

    def test_all(self):
        # n_attribute_handler = NAttributeHandler(obj)
        # self.assertEqual(expected, n_attribute_handler.all())
        assert True # TODO: implement your test here

    def test_get(self):
        # n_attribute_handler = NAttributeHandler(obj)
        # self.assertEqual(expected, n_attribute_handler.get(key))
        assert True # TODO: implement your test here

    def test_has(self):
        # n_attribute_handler = NAttributeHandler(obj)
        # self.assertEqual(expected, n_attribute_handler.has(key))
        assert True # TODO: implement your test here

    def test_remove(self):
        # n_attribute_handler = NAttributeHandler(obj)
        # self.assertEqual(expected, n_attribute_handler.remove(key))
        assert True # TODO: implement your test here

class TestTag(unittest.TestCase):
    def test___str__(self):
        # tag = Tag()
        # self.assertEqual(expected, tag.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # tag = Tag()
        # self.assertEqual(expected, tag.__unicode__())
        assert True # TODO: implement your test here

class TestTagHandler(unittest.TestCase):
    def test___init__(self):
        # tag_handler = TagHandler(obj)
        assert True # TODO: implement your test here

    def test___str__(self):
        # tag_handler = TagHandler(obj)
        # self.assertEqual(expected, tag_handler.__str__())
        assert True # TODO: implement your test here

    def test_add(self):
        # tag_handler = TagHandler(obj)
        # self.assertEqual(expected, tag_handler.add(tag, category, data))
        assert True # TODO: implement your test here

    def test_all(self):
        # tag_handler = TagHandler(obj)
        # self.assertEqual(expected, tag_handler.all(category, return_key_and_category))
        assert True # TODO: implement your test here

    def test_clear(self):
        # tag_handler = TagHandler(obj)
        # self.assertEqual(expected, tag_handler.clear())
        assert True # TODO: implement your test here

    def test_get(self):
        # tag_handler = TagHandler(obj)
        # self.assertEqual(expected, tag_handler.get(key, category, return_tagobj))
        assert True # TODO: implement your test here

    def test_remove(self):
        # tag_handler = TagHandler(obj)
        # self.assertEqual(expected, tag_handler.remove(key, category))
        assert True # TODO: implement your test here

class TestTypedObject(unittest.TestCase):
    def test___eq__(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.__eq__(other))
        assert True # TODO: implement your test here

    def test___getattribute__(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.__getattribute__(propname))
        assert True # TODO: implement your test here

    def test___init__(self):
        # typed_object = TypedObject(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.__unicode__())
        assert True # TODO: implement your test here

    def test_access(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.access(accessing_obj, access_type, default, **kwargs))
        assert True # TODO: implement your test here

    def test_attr(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.attr(attribute_name, value, delete))
        assert True # TODO: implement your test here

    def test_check_permstring(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.check_permstring(permstring))
        assert True # TODO: implement your test here

    def test_del_attribute(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.del_attribute(attribute_name, raise_exception))
        assert True # TODO: implement your test here

    def test_delete(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.delete(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_flush_from_cache(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.flush_from_cache())
        assert True # TODO: implement your test here

    def test_get_all_attributes(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.get_all_attributes())
        assert True # TODO: implement your test here

    def test_get_attribute(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.get_attribute(attribute_name, default, raise_exception))
        assert True # TODO: implement your test here

    def test_get_attribute_obj(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.get_attribute_obj(attribute_name, default))
        assert True # TODO: implement your test here

    def test_has_attribute(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.has_attribute(attribute_name))
        assert True # TODO: implement your test here

    def test_is_typeclass(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.is_typeclass(typeclass, exact))
        assert True # TODO: implement your test here

    def test_nattr(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.nattr(attribute_name, value, delete))
        assert True # TODO: implement your test here

    def test_secure_attr(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.secure_attr(accessing_object, attribute_name, value, delete, default_access_read, default_access_edit, default_access_create))
        assert True # TODO: implement your test here

    def test_set_attribute(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.set_attribute(attribute_name, new_value, lockstring))
        assert True # TODO: implement your test here

    def test_swap_typeclass(self):
        # typed_object = TypedObject(*args, **kwargs)
        # self.assertEqual(expected, typed_object.swap_typeclass(new_typeclass, clean_attributes, no_default))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_typeclasses_typeclass
import unittest

class TestMetaTypeClass(unittest.TestCase):
    def test___init__(self):
        # meta_type_class = MetaTypeClass(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # meta_type_class = MetaTypeClass(*args, **kwargs)
        # self.assertEqual(expected, meta_type_class.__str__())
        assert True # TODO: implement your test here

class TestTypeClass(unittest.TestCase):
    def test___delattr__(self):
        # type_class = TypeClass(dbobj)
        # self.assertEqual(expected, type_class.__delattr__(propname))
        assert True # TODO: implement your test here

    def test___eq__(self):
        # type_class = TypeClass(dbobj)
        # self.assertEqual(expected, type_class.__eq__(other))
        assert True # TODO: implement your test here

    def test___getattribute__(self):
        # type_class = TypeClass(dbobj)
        # self.assertEqual(expected, type_class.__getattribute__(propname))
        assert True # TODO: implement your test here

    def test___init__(self):
        # type_class = TypeClass(dbobj)
        assert True # TODO: implement your test here

    def test___setattr__(self):
        # type_class = TypeClass(dbobj)
        # self.assertEqual(expected, type_class.__setattr__(propname, value))
        assert True # TODO: implement your test here

    def test___str__(self):
        # type_class = TypeClass(dbobj)
        # self.assertEqual(expected, type_class.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # type_class = TypeClass(dbobj)
        # self.assertEqual(expected, type_class.__unicode__())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_ansi
import unittest

class TestANSIParser(unittest.TestCase):
    def test_parse_ansi(self):
        # a_nsi_parser = ANSIParser()
        # self.assertEqual(expected, a_nsi_parser.parse_ansi(string, strip_ansi, xterm256))
        assert True # TODO: implement your test here

    def test_strip_raw_codes(self):
        # a_nsi_parser = ANSIParser()
        # self.assertEqual(expected, a_nsi_parser.strip_raw_codes(string))
        assert True # TODO: implement your test here

    def test_sub_ansi(self):
        # a_nsi_parser = ANSIParser()
        # self.assertEqual(expected, a_nsi_parser.sub_ansi(ansimatch))
        assert True # TODO: implement your test here

    def test_sub_xterm256(self):
        # a_nsi_parser = ANSIParser()
        # self.assertEqual(expected, a_nsi_parser.sub_xterm256(rgbmatch))
        assert True # TODO: implement your test here

    def test_parse_rgb(self):
        # a_nsi_parser = ANSIParser()
        # self.assertEqual(expected, a_nsi_parser.parse_rgb(rgbmatch))
        assert True # TODO: implement your test here

class TestParseAnsi(unittest.TestCase):
    def test_parse_ansi(self):
        # self.assertEqual(expected, parse_ansi(string, strip_ansi, parser, xterm256))
        assert True # TODO: implement your test here

class TestRaw(unittest.TestCase):
    def test_raw(self):
        # self.assertEqual(expected, raw(string))
        assert True # TODO: implement your test here

class TestGroup(unittest.TestCase):
    def test_group(self):
        # self.assertEqual(expected, group(lst, n))
        assert True # TODO: implement your test here

class TestANSIMeta(unittest.TestCase):
    def test___init__(self):
        # a_nsi_meta = ANSIMeta(*args, **kwargs)
        assert True # TODO: implement your test here

class TestANSIString(unittest.TestCase):
    def test___add__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__add__(other))
        assert True # TODO: implement your test here

    def test___getitem__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__getitem__(item))
        assert True # TODO: implement your test here

    def test___getslice__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__getslice__(i, j))
        assert True # TODO: implement your test here

    def test___init__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___new__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___radd__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__radd__(other))
        assert True # TODO: implement your test here

    def test___repr__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__repr__())
        assert True # TODO: implement your test here

    def test___str__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.__unicode__())
        assert True # TODO: implement your test here

    def test_center(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.center(width, fillchar, difference))
        assert True # TODO: implement your test here

    def test_clean(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.clean())
        assert True # TODO: implement your test here

    def test_join(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.join(iterable))
        assert True # TODO: implement your test here

    def test_ljust(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.ljust(width, fillchar, difference))
        assert True # TODO: implement your test here

    def test_partition(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.partition(sep, reverse))
        assert True # TODO: implement your test here

    def test_raw(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.raw())
        assert True # TODO: implement your test here

    def test_rjust(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.rjust(width, fillchar, difference))
        assert True # TODO: implement your test here

    def test_rsplit(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.rsplit(by, maxsplit))
        assert True # TODO: implement your test here

    def test_split(self):
        # a_nsi_string = ANSIString(*args, **kwargs)
        # self.assertEqual(expected, a_nsi_string.split(by, maxsplit))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_ansi_new
import unittest

class TestSubMeth(unittest.TestCase):
    def test_sub_meth(self):
        # self.assertEqual(expected, sub_meth(obj, function))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_batchprocessors
import unittest

class TestReadBatchfile(unittest.TestCase):
    def test_read_batchfile(self):
        # self.assertEqual(expected, read_batchfile(pythonpath, file_ending))
        assert True # TODO: implement your test here

class TestBatchCommandProcessor(unittest.TestCase):
    def test_parse_file(self):
        # batch_command_processor = BatchCommandProcessor()
        # self.assertEqual(expected, batch_command_processor.parse_file(pythonpath))
        assert True # TODO: implement your test here

class TestTbFilename(unittest.TestCase):
    def test_tb_filename(self):
        # self.assertEqual(expected, tb_filename(tb))
        assert True # TODO: implement your test here

class TestTbIter(unittest.TestCase):
    def test_tb_iter(self):
        # self.assertEqual(expected, tb_iter(tb))
        assert True # TODO: implement your test here

class TestBatchCodeProcessor(unittest.TestCase):
    def test_code_exec(self):
        # batch_code_processor = BatchCodeProcessor()
        # self.assertEqual(expected, batch_code_processor.code_exec(codedict, extra_environ, debug))
        assert True # TODO: implement your test here

    def test_parse_file(self):
        # batch_code_processor = BatchCodeProcessor()
        # self.assertEqual(expected, batch_code_processor.parse_file(pythonpath))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_create
import unittest

class TestHandleDbref(unittest.TestCase):
    def test_handle_dbref(self):
        # self.assertEqual(expected, handle_dbref(inp, objclass, raise_errors))
        assert True # TODO: implement your test here

class TestCreateObject(unittest.TestCase):
    def test_create_object(self):
        # self.assertEqual(expected, create_object(typeclass, key, location, home, permissions, locks, aliases, destination, report_to, nohome))
        assert True # TODO: implement your test here

class TestCreateScript(unittest.TestCase):
    def test_create_script(self):
        # self.assertEqual(expected, create_script(typeclass, key, obj, player, locks, interval, start_delay, repeats, persistent, autostart, report_to))
        assert True # TODO: implement your test here

class TestCreateHelpEntry(unittest.TestCase):
    def test_create_help_entry(self):
        # self.assertEqual(expected, create_help_entry(key, entrytext, category, locks))
        assert True # TODO: implement your test here

class TestCreateMessage(unittest.TestCase):
    def test_create_message(self):
        # self.assertEqual(expected, create_message(senderobj, message, channels, receivers, locks, header))
        assert True # TODO: implement your test here

class TestCreateChannel(unittest.TestCase):
    def test_create_channel(self):
        # self.assertEqual(expected, create_channel(key, aliases, desc, locks, keep_log, typeclass))
        assert True # TODO: implement your test here

class TestCreateTag(unittest.TestCase):
    def test_create_tag(self):
        # self.assertEqual(expected, create_tag(self, key, category, data))
        assert True # TODO: implement your test here

class TestCreatePlayer(unittest.TestCase):
    def test_create_player(self):
        # self.assertEqual(expected, create_player(key, email, password, typeclass, is_superuser, locks, permissions, report_to))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_dbserialize
import unittest

class test__SaverMutable(unittest.TestCase):
    def test___delitem__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        # self.assertEqual(expected, __saver_mutable.__delitem__(key))
        assert True # TODO: implement your test here

    def test___getitem__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        # self.assertEqual(expected, __saver_mutable.__getitem__(key))
        assert True # TODO: implement your test here

    def test___init__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___iter__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        # self.assertEqual(expected, __saver_mutable.__iter__())
        assert True # TODO: implement your test here

    def test___len__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        # self.assertEqual(expected, __saver_mutable.__len__())
        assert True # TODO: implement your test here

    def test___repr__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        # self.assertEqual(expected, __saver_mutable.__repr__())
        assert True # TODO: implement your test here

    def test___setitem__(self):
        # __saver_mutable = _SaverMutable(*args, **kwargs)
        # self.assertEqual(expected, __saver_mutable.__setitem__(key, value))
        assert True # TODO: implement your test here

class test__SaverList(unittest.TestCase):
    def test___add__(self):
        # __saver_list = _SaverList(*args, **kwargs)
        # self.assertEqual(expected, __saver_list.__add__(otherlist))
        assert True # TODO: implement your test here

    def test___init__(self):
        # __saver_list = _SaverList(*args, **kwargs)
        assert True # TODO: implement your test here

    def test_insert(self):
        # __saver_list = _SaverList(*args, **kwargs)
        # self.assertEqual(expected, __saver_list.insert(index, value))
        assert True # TODO: implement your test here

class test__SaverDict(unittest.TestCase):
    def test___init__(self):
        # __saver_dict = _SaverDict(*args, **kwargs)
        assert True # TODO: implement your test here

    def test_has_key(self):
        # __saver_dict = _SaverDict(*args, **kwargs)
        # self.assertEqual(expected, __saver_dict.has_key(key))
        assert True # TODO: implement your test here

class test__SaverSet(unittest.TestCase):
    def test___contains__(self):
        # __saver_set = _SaverSet(*args, **kwargs)
        # self.assertEqual(expected, __saver_set.__contains__(value))
        assert True # TODO: implement your test here

    def test___init__(self):
        # __saver_set = _SaverSet(*args, **kwargs)
        assert True # TODO: implement your test here

    def test_add(self):
        # __saver_set = _SaverSet(*args, **kwargs)
        # self.assertEqual(expected, __saver_set.add(value))
        assert True # TODO: implement your test here

    def test_discard(self):
        # __saver_set = _SaverSet(*args, **kwargs)
        # self.assertEqual(expected, __saver_set.discard(value))
        assert True # TODO: implement your test here

class TestPackDbobj(unittest.TestCase):
    def test_pack_dbobj(self):
        # self.assertEqual(expected, pack_dbobj(item))
        assert True # TODO: implement your test here

class TestUnpackDbobj(unittest.TestCase):
    def test_unpack_dbobj(self):
        # self.assertEqual(expected, unpack_dbobj(item))
        assert True # TODO: implement your test here

class TestToPickle(unittest.TestCase):
    def test_to_pickle(self):
        # self.assertEqual(expected, to_pickle(data))
        assert True # TODO: implement your test here

class TestFromPickle(unittest.TestCase):
    def test_from_pickle(self):
        # self.assertEqual(expected, from_pickle(data, db_obj))
        assert True # TODO: implement your test here

class TestDoPickle(unittest.TestCase):
    def test_do_pickle(self):
        # self.assertEqual(expected, do_pickle(data))
        assert True # TODO: implement your test here

class TestDoUnpickle(unittest.TestCase):
    def test_do_unpickle(self):
        # self.assertEqual(expected, do_unpickle(data))
        assert True # TODO: implement your test here

class TestDbserialize(unittest.TestCase):
    def test_dbserialize(self):
        # self.assertEqual(expected, dbserialize(data))
        assert True # TODO: implement your test here

class TestDbunserialize(unittest.TestCase):
    def test_dbunserialize(self):
        # self.assertEqual(expected, dbunserialize(data, db_obj))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_evform
import unittest

class TestEvForm(unittest.TestCase):
    def test___init__(self):
        # ev_form = EvForm(filename, cells, tables, form, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # ev_form = EvForm(filename, cells, tables, form, **kwargs)
        # self.assertEqual(expected, ev_form.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # ev_form = EvForm(filename, cells, tables, form, **kwargs)
        # self.assertEqual(expected, ev_form.__unicode__())
        assert True # TODO: implement your test here

    def test_map(self):
        # ev_form = EvForm(filename, cells, tables, form, **kwargs)
        # self.assertEqual(expected, ev_form.map(cells, tables, **kwargs))
        assert True # TODO: implement your test here

    def test_reload(self):
        # ev_form = EvForm(filename, cells, tables, form, **kwargs)
        # self.assertEqual(expected, ev_form.reload(filename, form, **kwargs))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_evtable
import unittest

class TestMakeIter(unittest.TestCase):
    def test_make_iter(self):
        # self.assertEqual(expected, make_iter(obj))
        assert True # TODO: implement your test here

class TestWrap(unittest.TestCase):
    def test_wrap(self):
        # self.assertEqual(expected, wrap(text, width, **kwargs))
        assert True # TODO: implement your test here

class TestFill(unittest.TestCase):
    def test_fill(self):
        # self.assertEqual(expected, fill(text, width, **kwargs))
        assert True # TODO: implement your test here

class TestCell(unittest.TestCase):
    def test___init__(self):
        # cell = Cell(data, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.__unicode__())
        assert True # TODO: implement your test here

    def test_get(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.get())
        assert True # TODO: implement your test here

    def test_get_height(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.get_height())
        assert True # TODO: implement your test here

    def test_get_min_height(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.get_min_height())
        assert True # TODO: implement your test here

    def test_get_min_width(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.get_min_width())
        assert True # TODO: implement your test here

    def test_get_width(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.get_width())
        assert True # TODO: implement your test here

    def test_reformat(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.reformat(**kwargs))
        assert True # TODO: implement your test here

    def test_replace_data(self):
        # cell = Cell(data, **kwargs)
        # self.assertEqual(expected, cell.replace_data(data, **kwargs))
        assert True # TODO: implement your test here

class TestEvTable(unittest.TestCase):
    def test___init__(self):
        # ev_table = EvTable(*args, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.__unicode__())
        assert True # TODO: implement your test here

    def test_add_column(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.add_column(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_add_header(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.add_header(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_add_row(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.add_row(*args, **kwargs))
        assert True # TODO: implement your test here

    def test_get(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.get())
        assert True # TODO: implement your test here

    def test_reformat(self):
        # ev_table = EvTable(*args, **kwargs)
        # self.assertEqual(expected, ev_table.reformat(**kwargs))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_gametime
import unittest

class TestGameTime(unittest.TestCase):
    def test_at_repeat(self):
        # game_time = GameTime()
        # self.assertEqual(expected, game_time.at_repeat())
        assert True # TODO: implement your test here

    def test_at_script_creation(self):
        # game_time = GameTime()
        # self.assertEqual(expected, game_time.at_script_creation())
        assert True # TODO: implement your test here

    def test_at_start(self):
        # game_time = GameTime()
        # self.assertEqual(expected, game_time.at_start())
        assert True # TODO: implement your test here

class TestSave(unittest.TestCase):
    def test_save(self):
        # self.assertEqual(expected, save())
        assert True # TODO: implement your test here

class TestRuntime(unittest.TestCase):
    def test_runtime(self):
        # self.assertEqual(expected, runtime(format))
        assert True # TODO: implement your test here

class TestUptime(unittest.TestCase):
    def test_uptime(self):
        # self.assertEqual(expected, uptime(format))
        assert True # TODO: implement your test here

class TestGametime(unittest.TestCase):
    def test_gametime(self):
        # self.assertEqual(expected, gametime(format))
        assert True # TODO: implement your test here

class TestGametimeToRealtime(unittest.TestCase):
    def test_gametime_to_realtime(self):
        # self.assertEqual(expected, gametime_to_realtime(secs, mins, hrs, days, weeks, months, yrs, format))
        assert True # TODO: implement your test here

class TestRealtimeToGametime(unittest.TestCase):
    def test_realtime_to_gametime(self):
        # self.assertEqual(expected, realtime_to_gametime(secs, mins, hrs, days, weeks, months, yrs, format))
        assert True # TODO: implement your test here

class TestInitGametime(unittest.TestCase):
    def test_init_gametime(self):
        # self.assertEqual(expected, init_gametime())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_logger
import unittest

class TestLogTrace(unittest.TestCase):
    def test_log_trace(self):
        # self.assertEqual(expected, log_trace(errmsg))
        assert True # TODO: implement your test here

class TestLogErrmsg(unittest.TestCase):
    def test_log_errmsg(self):
        # self.assertEqual(expected, log_errmsg(errmsg))
        assert True # TODO: implement your test here

class TestLogWarnmsg(unittest.TestCase):
    def test_log_warnmsg(self):
        # self.assertEqual(expected, log_warnmsg(warnmsg))
        assert True # TODO: implement your test here

class TestLogInfomsg(unittest.TestCase):
    def test_log_infomsg(self):
        # self.assertEqual(expected, log_infomsg(infomsg))
        assert True # TODO: implement your test here

class TestLogDepmsg(unittest.TestCase):
    def test_log_depmsg(self):
        # self.assertEqual(expected, log_depmsg(depmsg))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_picklefield
import unittest

class test__ObjectWrapper(unittest.TestCase):
    def test___init__(self):
        # __object_wrapper = _ObjectWrapper(obj)
        assert True # TODO: implement your test here

class TestWrapConflictualObject(unittest.TestCase):
    def test_wrap_conflictual_object(self):
        # self.assertEqual(expected, wrap_conflictual_object(obj))
        assert True # TODO: implement your test here

class TestDbsafeEncode(unittest.TestCase):
    def test_dbsafe_encode(self):
        # self.assertEqual(expected, dbsafe_encode(value, compress_object, pickle_protocol))
        assert True # TODO: implement your test here

class TestDbsafeDecode(unittest.TestCase):
    def test_dbsafe_decode(self):
        # self.assertEqual(expected, dbsafe_decode(value, compress_object))
        assert True # TODO: implement your test here

class TestPickledObjectField(unittest.TestCase):
    def test___init__(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        assert True # TODO: implement your test here

    def test_get_db_prep_lookup(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.get_db_prep_lookup(lookup_type, value, connection, prepared))
        assert True # TODO: implement your test here

    def test_get_db_prep_value(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.get_db_prep_value(value, connection, prepared))
        assert True # TODO: implement your test here

    def test_get_default(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.get_default())
        assert True # TODO: implement your test here

    def test_get_internal_type(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.get_internal_type())
        assert True # TODO: implement your test here

    def test_pre_save(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.pre_save(model_instance, add))
        assert True # TODO: implement your test here

    def test_to_python(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.to_python(value))
        assert True # TODO: implement your test here

    def test_value_to_string(self):
        # pickled_object_field = PickledObjectField(*args, **kwargs)
        # self.assertEqual(expected, pickled_object_field.value_to_string(obj))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_prettytable
import unittest

class TestPrettyTable(unittest.TestCase):
    def test___getattr__(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.__getattr__(name))
        assert True # TODO: implement your test here

    def test___getitem__(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.__getitem__(index))
        assert True # TODO: implement your test here

    def test___init__(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        assert True # TODO: implement your test here

    def test___str__(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.__str__())
        assert True # TODO: implement your test here

    def test___str___case_2(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.__str__())
        assert True # TODO: implement your test here

    def test___unicode__(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.__unicode__())
        assert True # TODO: implement your test here

    def test_add_column(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.add_column(fieldname, column, align, valign))
        assert True # TODO: implement your test here

    def test_add_row(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.add_row(row))
        assert True # TODO: implement your test here

    def test_clear(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.clear())
        assert True # TODO: implement your test here

    def test_clear_rows(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.clear_rows())
        assert True # TODO: implement your test here

    def test_copy(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.copy())
        assert True # TODO: implement your test here

    def test_del_row(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.del_row(row_index))
        assert True # TODO: implement your test here

    def test_get_html_string(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.get_html_string(**kwargs))
        assert True # TODO: implement your test here

    def test_get_string(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.get_string(**kwargs))
        assert True # TODO: implement your test here

    def test_set_style(self):
        # pretty_table = PrettyTable(field_names, **kwargs)
        # self.assertEqual(expected, pretty_table.set_style(style))
        assert True # TODO: implement your test here

class TestFromCsv(unittest.TestCase):
    def test_from_csv(self):
        # self.assertEqual(expected, from_csv(fp, field_names, **kwargs))
        assert True # TODO: implement your test here

class TestFromDbCursor(unittest.TestCase):
    def test_from_db_cursor(self):
        # self.assertEqual(expected, from_db_cursor(cursor, **kwargs))
        assert True # TODO: implement your test here

class TestTableHandler(unittest.TestCase):
    def test___init__(self):
        # table_handler = TableHandler(**kwargs)
        assert True # TODO: implement your test here

    def test_generate_table(self):
        # table_handler = TableHandler(**kwargs)
        # self.assertEqual(expected, table_handler.generate_table(rows))
        assert True # TODO: implement your test here

    def test_handle_data(self):
        # table_handler = TableHandler(**kwargs)
        # self.assertEqual(expected, table_handler.handle_data(data))
        assert True # TODO: implement your test here

    def test_handle_endtag(self):
        # table_handler = TableHandler(**kwargs)
        # self.assertEqual(expected, table_handler.handle_endtag(tag))
        assert True # TODO: implement your test here

    def test_handle_starttag(self):
        # table_handler = TableHandler(**kwargs)
        # self.assertEqual(expected, table_handler.handle_starttag(tag, attrs))
        assert True # TODO: implement your test here

    def test_make_fields_unique(self):
        # table_handler = TableHandler(**kwargs)
        # self.assertEqual(expected, table_handler.make_fields_unique(fields))
        assert True # TODO: implement your test here

class TestFromHtml(unittest.TestCase):
    def test_from_html(self):
        # self.assertEqual(expected, from_html(html_code, **kwargs))
        assert True # TODO: implement your test here

class TestFromHtmlOne(unittest.TestCase):
    def test_from_html_one(self):
        # self.assertEqual(expected, from_html_one(html_code, **kwargs))
        assert True # TODO: implement your test here

class TestMain(unittest.TestCase):
    def test_main(self):
        # self.assertEqual(expected, main())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_search
import unittest

class TestSearchObjectTag(unittest.TestCase):
    def test_search_object_tag(self):
        # self.assertEqual(expected, search_object_tag(key, category))
        assert True # TODO: implement your test here

class TestSearchPlayerTag(unittest.TestCase):
    def test_search_player_tag(self):
        # self.assertEqual(expected, search_player_tag(key, category))
        assert True # TODO: implement your test here

class TestSearchScriptTag(unittest.TestCase):
    def test_search_script_tag(self):
        # self.assertEqual(expected, search_script_tag(key, category))
        assert True # TODO: implement your test here

class TestSearchChannelTag(unittest.TestCase):
    def test_search_channel_tag(self):
        # self.assertEqual(expected, search_channel_tag(key, category))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_tests
import unittest

class TestANSIStringTestCase(unittest.TestCase):
    def test_checker(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.checker(ansi, raw, clean))
        assert True # TODO: implement your test here

    def test_table_check(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.table_check(ansi, char, code))
        assert True # TODO: implement your test here

    def test_test_instance(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.test_instance())
        assert True # TODO: implement your test here

    def test_test_join(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.test_join())
        assert True # TODO: implement your test here

    def test_test_len(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.test_len())
        assert True # TODO: implement your test here

    def test_test_slice(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.test_slice())
        assert True # TODO: implement your test here

    def test_test_split(self):
        # a_nsi_string_test_case = ANSIStringTestCase()
        # self.assertEqual(expected, a_nsi_string_test_case.test_split())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_text2html
import unittest

class TestTextToHTMLparser(unittest.TestCase):
    def test_convert_linebreaks(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.convert_linebreaks(text))
        assert True # TODO: implement your test here

    def test_convert_urls(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.convert_urls(text))
        assert True # TODO: implement your test here

    def test_do_sub(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.do_sub(m))
        assert True # TODO: implement your test here

    def test_parse(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.parse(text, strip_ansi))
        assert True # TODO: implement your test here

    def test_re_bold(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.re_bold(text))
        assert True # TODO: implement your test here

    def test_re_color(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.re_color(text))
        assert True # TODO: implement your test here

    def test_re_underline(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.re_underline(text))
        assert True # TODO: implement your test here

    def test_remove_backspaces(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.remove_backspaces(text))
        assert True # TODO: implement your test here

    def test_remove_bells(self):
        # text_to_htm_lparser = TextToHTMLparser()
        # self.assertEqual(expected, text_to_htm_lparser.remove_bells(text))
        assert True # TODO: implement your test here

class TestParseHtml(unittest.TestCase):
    def test_parse_html(self):
        # self.assertEqual(expected, parse_html(string, strip_ansi, parser))
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils_utils
# test with game/manage.py test
import unittest

from src.utils import utils

class TestIsIter(unittest.TestCase):
    def test_is_iter(self):
        self.assertEqual(True, utils.is_iter([1,2,3,4]))
        self.assertEqual(False, utils.is_iter("This is not an iterable"))

class TestCrop(unittest.TestCase):
    def test_crop(self):
        # No text, return no text
        self.assertEqual("", utils.crop("", width=10, suffix="[...]"))
        # Input length equal to max width, no crop
        self.assertEqual("0123456789", utils.crop("0123456789", width=10, suffix="[...]"))
        # Input length greater than max width, crop (suffix included in width)
        self.assertEqual("0123[...]", utils.crop("0123456789", width=9, suffix="[...]"))
        # Input length less than desired width, no crop
        self.assertEqual("0123", utils.crop("0123", width=9, suffix="[...]"))
        # Width too small or equal to width of suffix
        self.assertEqual("012", utils.crop("0123", width=3, suffix="[...]"))
        self.assertEqual("01234", utils.crop("0123456", width=5, suffix="[...]"))

class TestDedent(unittest.TestCase):
    def test_dedent(self):
        #print "Did TestDedent run?"
        # Empty string, return empty string
        self.assertEqual("", utils.dedent(""))
        # No leading whitespace
        self.assertEqual("TestDedent", utils.dedent("TestDedent"))
        # Leading whitespace, single line
        self.assertEqual("TestDedent", utils.dedent("   TestDedent"))
        # Leading whitespace, multi line
        input_string = "  hello\n  world"
    	expected_string = "hello\nworld"
    	self.assertEqual(expected_string, utils.dedent(input_string))        

class TestListToString(unittest.TestCase):
    """
    Default function header from utils.py: 
    	list_to_string(inlist, endsep="and", addquote=False)

    Examples:
     no endsep:
        [1,2,3] -> '1, 2, 3'
     with endsep=='and':
        [1,2,3] -> '1, 2 and 3'
     with addquote and endsep
        [1,2,3] -> '"1", "2" and "3"'
    """
    #print "Did TestListToString run?"
    def test_list_to_string(self):
        self.assertEqual('1, 2, 3', utils.list_to_string([1,2,3], endsep=""))
        self.assertEqual('"1", "2", "3"', utils.list_to_string([1,2,3], endsep="", addquote=True))
        self.assertEqual('1, 2 and 3', utils.list_to_string([1,2,3]))
        self.assertEqual('"1", "2" and "3"', utils.list_to_string([1,2,3], endsep="and", addquote=True))
        

class TestWildcardToRegexp(unittest.TestCase):
    def test_wildcard_to_regexp(self):
        # self.assertEqual(expected, wildcard_to_regexp(instring))
        assert True # TODO: implement your test here

class TestTimeFormat(unittest.TestCase):
    def test_time_format(self):
        # self.assertEqual(expected, time_format(seconds, style))
        assert True # TODO: implement your test here

class TestDatetimeFormat(unittest.TestCase):
    def test_datetime_format(self):
        # self.assertEqual(expected, datetime_format(dtobj))
        assert True # TODO: implement your test here

class TestHostOsIs(unittest.TestCase):
    def test_host_os_is(self):
        # self.assertEqual(expected, host_os_is(osname))
        assert True # TODO: implement your test here

class TestGetEvenniaVersion(unittest.TestCase):
    def test_get_evennia_version(self):
        # self.assertEqual(expected, get_evennia_version())
        assert True # TODO: implement your test here

class TestPypathToRealpath(unittest.TestCase):
    def test_pypath_to_realpath(self):
        # self.assertEqual(expected, pypath_to_realpath(python_path, file_ending))
        assert True # TODO: implement your test here

class TestToUnicode(unittest.TestCase):
    def test_to_unicode(self):
        # self.assertEqual(expected, to_unicode(obj, encoding, force_string))
        assert True # TODO: implement your test here

class TestToStr(unittest.TestCase):
    def test_to_str(self):
        # self.assertEqual(expected, to_str(obj, encoding, force_string))
        assert True # TODO: implement your test here

class TestValidateEmailAddress(unittest.TestCase):
    def test_validate_email_address(self):
        # self.assertEqual(expected, validate_email_address(emailaddress))
        assert True # TODO: implement your test here

class TestInheritsFrom(unittest.TestCase):
    def test_inherits_from(self):
        # self.assertEqual(expected, inherits_from(obj, parent))
        assert True # TODO: implement your test here

class TestServerServices(unittest.TestCase):
    def test_server_services(self):
        # self.assertEqual(expected, server_services())
        assert True # TODO: implement your test here

class TestUsesDatabase(unittest.TestCase):
    def test_uses_database(self):
        # self.assertEqual(expected, uses_database(name))
        assert True # TODO: implement your test here

class TestDelay(unittest.TestCase):
    def test_delay(self):
        # self.assertEqual(expected, delay(delay, callback, retval))
        assert True # TODO: implement your test here

class TestCleanObjectCaches(unittest.TestCase):
    def test_clean_object_caches(self):
        # self.assertEqual(expected, clean_object_caches(obj))
        assert True # TODO: implement your test here

class TestRunAsync(unittest.TestCase):
    def test_run_async(self):
        # self.assertEqual(expected, run_async(to_execute, *args, **kwargs))
        assert True # TODO: implement your test here

class TestCheckEvenniaDependencies(unittest.TestCase):
    def test_check_evennia_dependencies(self):
        # self.assertEqual(expected, check_evennia_dependencies())
        assert True # TODO: implement your test here

class TestHasParent(unittest.TestCase):
    def test_has_parent(self):
        # self.assertEqual(expected, has_parent(basepath, obj))
        assert True # TODO: implement your test here

class TestModImport(unittest.TestCase):
    def test_mod_import(self):
        # self.assertEqual(expected, mod_import(module))
        assert True # TODO: implement your test here

class TestAllFromModule(unittest.TestCase):
    def test_all_from_module(self):
        # self.assertEqual(expected, all_from_module(module))
        assert True # TODO: implement your test here

class TestVariableFromModule(unittest.TestCase):
    def test_variable_from_module(self):
        # self.assertEqual(expected, variable_from_module(module, variable, default))
        assert True # TODO: implement your test here

class TestStringFromModule(unittest.TestCase):
    def test_string_from_module(self):
        # self.assertEqual(expected, string_from_module(module, variable, default))
        assert True # TODO: implement your test here

class TestInitNewPlayer(unittest.TestCase):
    def test_init_new_player(self):
        # self.assertEqual(expected, init_new_player(player))
        assert True # TODO: implement your test here

class TestStringSimilarity(unittest.TestCase):
    def test_string_similarity(self):
        # self.assertEqual(expected, string_similarity(string1, string2))
        assert True # TODO: implement your test here

class TestStringSuggestions(unittest.TestCase):
    def test_string_suggestions(self):
        # self.assertEqual(expected, string_suggestions(string, vocabulary, cutoff, maxnum))
        assert True # TODO: implement your test here

class TestStringPartialMatching(unittest.TestCase):
    def test_string_partial_matching(self):
        # self.assertEqual(expected, string_partial_matching(alternatives, inp, ret_index))
        assert True # TODO: implement your test here

class TestFormatTable(unittest.TestCase):
    def test_format_table(self):
        # self.assertEqual(expected, format_table(table, extra_space))
        assert True # TODO: implement your test here

class TestGetEvenniaPids(unittest.TestCase):
    def test_get_evennia_pids(self):
        # self.assertEqual(expected, get_evennia_pids())
        assert True # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = managers
"""
This implements the common managers that are used by the
abstract models in dbobjects.py (and which are thus shared by
all Attributes and TypedObjects).
"""
from functools import update_wrapper
from django.db import models
from django.db.models import Q
from django.contrib.contenttypes.models import ContentType
from src.utils import idmapper
from src.utils.utils import make_iter, variable_from_module
from src.utils.dbserialize import to_pickle

__all__ = ("AttributeManager", "TypedObjectManager")
_GA = object.__getattribute__
_ObjectDB = None

#
# helper functions for the TypedObjectManager.
#

def returns_typeclass_list(method):
    """
    Decorator: Changes return of the decorated method (which are
    TypeClassed objects) into object_classes(s) instead.  Will always
    return a list (may be empty).
    """
    def func(self, *args, **kwargs):
        "decorator. Returns a list."
        self.__doc__ = method.__doc__
        matches = make_iter(method(self, *args, **kwargs))
        return [(hasattr(dbobj, "typeclass") and dbobj.typeclass) or dbobj
                                               for dbobj in make_iter(matches)]
    return update_wrapper(func, method)


def returns_typeclass(method):
    """
    Decorator: Will always return a single typeclassed result or None.
    """
    def func(self, *args, **kwargs):
        "decorator. Returns result or None."
        self.__doc__ = method.__doc__
        matches = method(self, *args, **kwargs)
        dbobj = matches and make_iter(matches)[0] or None
        if dbobj:
            return (hasattr(dbobj, "typeclass") and dbobj.typeclass) or dbobj
        return None
    return update_wrapper(func, method)

# Managers

def _attr_pickled(method):
    """
    decorator for safely handling attribute searches
    - db_value is a pickled field and this is required
    in order to be able for pickled django objects directly.
    """
    def wrapper(self, *args, **kwargs):
        "wrap all queries searching the db_value field in some way"
        self.__doc__ = method.__doc__
        for key in (key for key in kwargs if key.startswith('db_value')):
            kwargs[key] = to_pickle(kwargs[key])
        return method(self, *args, **kwargs)
    return update_wrapper(wrapper, method)


class AttributeManager(models.Manager):
    "Manager for handling Attributes."
    @_attr_pickled
    def get(self, *args, **kwargs):
        return super(AttributeManager, self).get(*args, **kwargs)
    @_attr_pickled

    def filter(self,*args, **kwargs):
        return super(AttributeManager, self).filter(*args, **kwargs)
    @_attr_pickled

    def exclude(self,*args, **kwargs):
        return super(AttributeManager, self).exclude(*args, **kwargs)
    @_attr_pickled

    def values(self,*args, **kwargs):
        return super(AttributeManager, self).values(*args, **kwargs)
    @_attr_pickled

    def values_list(self,*args, **kwargs):
        return super(AttributeManager, self).values_list(*args, **kwargs)
    @_attr_pickled

    def exists(self,*args, **kwargs):
        return super(AttributeManager, self).exists(*args, **kwargs)

    def get_attrs_on_obj(self, searchstr, obj, category=None, exact_match=True):
        """
        Searches the object's attributes for attribute key matches.

        searchstr: (str) A string to search for.
        """
        # Retrieve the list of attributes for this object.

        category_cond = Q(db_category__iexact=category) if category else Q()
        if exact_match:
            return _GA("obj", "db_attributes").filter(db_key__iexact=searchstr & category_cond)
        else:
            return _GA("obj", "db_attributes").filter(db_key__icontains=searchstr & category_cond)

    def attr_namesearch(self, *args, **kwargs):
        "alias wrapper for backwards compatability"
        return self.get_attrs_on_obj(*args, **kwargs)

    def get_attr_by_value(self, searchstr, obj=None):
        """
        Searches obj for Attributes with a given value.
        searchstr - value to search for. This may be any suitable object.
        obj - limit to a given object instance

        If no restraint is given, all Attributes on all types of objects
                will be searched. It's highly recommended to at least
                supply the objclass argument (DBObject, DBScript or DBPlayer)
                to restrict this lookup.
        """
        if obj:
            return _GA(obj, "db_attributes").filter(db_value=searchstr)
        return self.filter(db_value=searchstr)

    def attr_valuesearch(self, *args, **kwargs):
        "alias wrapper for backwards compatability"
        return self.get_attr_by_value(self, *args, **kwargs)

#
# TagManager
#

class TagManager(models.Manager):
    """
    Extra manager methods for Tags
    """
    def get_tags_on_obj(self, obj, key=None, category=None):
        """
        Get all tags on obj, optionally limited by key and/or category
        """
        tags = _GA(obj, "db_tags").all()
        if key:
            tags = tags.filter(db_key__iexact=key.lower().strip())
        if category:
            tags = tags.filter(db_category__iexact=category.lower().strip())
        return list(tags)

    def get_tag(self, key=None, category=None, model="objects.objectdb", tagtype=None):
        """
        Search and return all tags matching any combination of
        the search criteria.
         search_key (string) - the tag identifier
         category (string) - the tag category
         model - the type of object tagged, on naturalkey form, like "objects.objectdb"
         tagtype - None, alias or permission

        Returns a single Tag (or None) if both key and category is given,
        otherwise it will return a list.
        """
        key_cands = Q(db_key__iexact=key.lower().strip()) if key is not None else Q()
        cat_cands = Q(db_category__iexact=category.lower().strip()) if category is not None else Q()
        tags = self.filter(db_model=model, db_tagtype=tagtype).filter(key_cands & cat_cands)
        if key and category:
            return tags[0] if tags else None
        else:
            return list(tags)

    @returns_typeclass_list
    def get_objs_with_tag(self, key=None, category=None, model="objects.objectdb", tagtype=None):
        """
        Search and return all objects of objclass that has tags matching
        the given search criteria.
         key (string) - the tag identifier
         category (string) - the tag category
         model (string) - tag model name. Defaults to "ObjectDB"
         tagtype (string) - None, alias or permission
         objclass (dbmodel) - the object class to search. If not given, use ObjectDB.
        """
        objclass = ContentType.objects.get_by_natural_key(*model.split(".", 1)).model_class()
        key_cands = Q(db_tags__db_key__iexact=key.lower().strip()) if key is not None else Q()
        cat_cands = Q(db_tags__db_category__iexact=category.lower().strip()) if category is not None else Q()
        tag_crit = Q(db_tags__db_model=model, db_tags__db_tagtype=tagtype)
        return objclass.objects.filter(tag_crit & key_cands & cat_cands)

    def create_tag(self, key=None, category=None, data=None, model="objects.objectdb", tagtype=None):
        """
        Create a tag. This makes sure the create case-insensitive tags.
        Note that if the exact same tag configuration (key+category+model+tagtype)
        exists, it will be re-used. A data keyword will overwrite existing
        data on a tag (it is not part of what makes the tag unique).

        """
        data = str(data) if data is not None else None

        tag = self.get_tag(key=key, category=category, model=model, tagtype=tagtype)
        if tag and data is not None:
            tag.db_data = data
            tag.save()
        elif not tag:
            tag = self.create(db_key=key.lower().strip() if key is not None else None,
                              db_category=category.lower().strip() if category and key is not None else None,
                              db_data=str(data) if data is not None else None,
                              db_model=model,
                              db_tagtype=tagtype)
            tag.save()
        return make_iter(tag)[0]




#class TypedObjectManager(idmap.CachingManager):
#class TypedObjectManager(models.Manager):
class TypedObjectManager(idmapper.manager.SharedMemoryManager):
    """
    Common ObjectManager for all dbobjects.
    """

    def dbref(self, dbref, reqhash=True):
        """
        Valid forms of dbref (database reference number)
        are either a string '#N' or an integer N.
        Output is the integer part.
        reqhash - require input to be on form "#N" to be
        identified as a dbref
        """
        if reqhash and not (isinstance(dbref, basestring) and dbref.startswith("#")):
            return None
        if isinstance(dbref, basestring):
            dbref = dbref.lstrip('#')
        try:
            if int(dbref) < 0:
                return None
        except Exception:
            return None
        return dbref

    @returns_typeclass
    def get_id(self, dbref):
        """
        Find object with given dbref
        """
        dbref = self.dbref(dbref, reqhash=False)
        try:
            return self.get(id=dbref)
        except self.model.DoesNotExist:
            pass
        return None

    def dbref_search(self, dbref):
        """
        Alias to get_id
        """
        return self.get_id(dbref)

    @returns_typeclass_list
    def get_dbref_range(self, min_dbref=None, max_dbref=None):
        """
        Return all objects inside and including the
        given boundaries.
        """
        retval = super(TypedObjectManager, self).all()
        if min_dbref is not None:
            retval = retval.filter(id__gte=self.dbref(min_dbref, reqhash=False))
        if max_dbref is not None:
            retval = retval.filter(id__lte=self.dbref(max_dbref, reqhash=False))
        return retval

    def object_totals(self):
        """
        Returns a dictionary with all the typeclasses active in-game
        as well as the number of such objects defined (i.e. the number
        of database object having that typeclass set on themselves).
        """
        dbtotals = {}
        typeclass_paths = set(self.values_list('db_typeclass_path', flat=True))
        for typeclass_path in typeclass_paths:
            dbtotals[typeclass_path] = \
               self.filter(db_typeclass_path=typeclass_path).count()
        return dbtotals

    @returns_typeclass_list
    def typeclass_search(self, typeclass, include_children=False, include_parents=False):
        """
        Searches through all objects returning those which has a
        certain typeclass. If location is set, limit search to objects
        in that location.

        typeclass - a typeclass class or a python path to a typeclass
        include_children - return objects with given typeclass and all
                       children inheriting from this typeclass.
        include_parents - return objects with given typeclass and all
                       parents to this typeclass
        The include_children/parents keywords are mutually exclusive.
        """

        if callable(typeclass):
            cls = typeclass.__class__
            typeclass = "%s.%s" % (cls.__module__, cls.__name__)
        elif not isinstance(typeclass, basestring) and hasattr(typeclass, "path"):
            typeclass = typeclass.path

        # query objects of exact typeclass
        query = Q(db_typeclass_path__exact=typeclass)

        if include_children:
            # build requests for child typeclass objects
            clsmodule, clsname = typeclass.rsplit(".", 1)
            cls = variable_from_module(clsmodule, clsname)
            subclasses = cls.__subclasses__()
            if subclasses:
                for child in (child for child in subclasses if hasattr(child, "path")):
                    query = query | Q(db_typeclass_path__exact=child.path)
        elif include_parents:
            # build requests for parent typeclass objects
            clsmodule, clsname = typeclass.rsplit(".", 1)
            cls = variable_from_module(clsmodule, clsname)
            parents = cls.__mro__
            if parents:
                for parent in (parent for parent in parents if hasattr(parent, "path")):
                    query = query | Q(db_typeclass_path__exact=parent.path)
        # actually query the database
        return self.filter(query)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Attribute'
        db.create_table(u'typeclasses_attribute', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('db_value', self.gf('src.utils.picklefield.PickledObjectField')(null=True)),
            ('db_lock_storage', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('db_date_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal(u'typeclasses', ['Attribute'])


    def backwards(self, orm):
        # Deleting model 'Attribute'
        db.delete_table(u'typeclasses_attribute')


    models = {
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['typeclasses']
########NEW FILE########
__FILENAME__ = 0002_resave_attrs
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

try:
    from django.contrib.auth import get_user_model
except ImportError: # django < 1.5
    from django.contrib.auth.models import User
else:
    User = get_user_model()

user_orm_label = '%s.%s' % (User._meta.app_label, User._meta.object_name)
user_model_label = '%s.%s' % (User._meta.app_label, User._meta.module_name)
user_ptr_name = '%s_ptr' % User._meta.object_name.lower()

class Migration(DataMigration):
    depends_on = (('server', '0004_store_all_attrs'),
                  ('objects', '0021_auto__del_objattribute'),
                  ('players', '0020_auto__del_playerattribute'),
                  ('scripts', '0013_auto__del_scriptattribute'))
    no_dry_run=True
    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Remember to use orm['appname.ModelName'] rather than "from appname.models..."

        for tmpattr in orm['server.TmpAttribute'].objects.all():
            typ = tmpattr.db_obj_type
            dbid = tmpattr.db_obj_id
            if typ == 'objectdb':
                try:
                    dbobj = orm['objects.ObjectDB'].objects.get(id=dbid)
                except:
                    print "could not find objid %i" % dbid
                    continue
            elif typ == 'playerdb':
                try:
                    dbobj = orm['players.PlayerDB'].objects.get(id=dbid)
                except:
                    print "could not find objid %i" % dbid
                    continue
            elif typ == 'scriptdb':
                try:
                    dbobj = orm['scripts.ScriptDB'].objects.get(id=dbid)
                except:
                    print "could not find objid %i" % dbid
                    continue
            else:
                print "Wrong object type to store on: %s" % typ
                continue
            dbattr = orm['typeclasses.Attribute'](db_key=tmpattr.db_key,
                                                  db_value=tmpattr.db_value,
                                                  db_lock_storage=tmpattr.db_lock_storage,
                                                  db_date_created=tmpattr.db_date_created)

            dbattr.save()
            dbobj.db_attributes.add(dbattr)


    def backwards(self, orm):
        "Write your backwards methods here."
        raise RuntimeError("Cannot revert this migration.")

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        user_model_label: {
            'Meta': {'object_name': User.__name__, 'db_table': "'%s'" % User._meta.db_table},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'server.serverconfig': {
            'Meta': {'object_name': 'ServerConfig'},
            'db_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'db_value': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'server.tmpattribute': {
            'Meta': {'object_name': 'TmpAttribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj_id': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_obj_type': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['%s']" % user_orm_label, 'unique': 'True'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['server', 'typeclasses', 'objects', 'scripts', 'players']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0003_auto__add_liteattribute__add_index_liteattribute_db_key_db_category__a
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'LiteAttribute'
        db.create_table(u'typeclasses_liteattribute', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_category', self.gf('django.db.models.fields.CharField')(max_length=64, null=True, blank=True)),
            ('db_data', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'typeclasses', ['LiteAttribute'])

        # Adding index on 'LiteAttribute', fields ['db_key', 'db_category']
        db.create_index(u'typeclasses_liteattribute', ['db_key', 'db_category'])

        # Adding model 'Tag'
        db.create_table(u'typeclasses_tag', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255, null=True)),
            ('db_category', self.gf('django.db.models.fields.CharField')(max_length=64, null=True)),
            ('db_data', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal(u'typeclasses', ['Tag'])

        # Adding unique constraint on 'Tag', fields ['db_key', 'db_category']
        db.create_unique(u'typeclasses_tag', ['db_key', 'db_category'])

        # Adding index on 'Tag', fields ['db_key', 'db_category']
        db.create_index(u'typeclasses_tag', ['db_key', 'db_category'])


    def backwards(self, orm):
        # Removing index on 'Tag', fields ['db_key', 'db_category']
        db.delete_index(u'typeclasses_tag', ['db_key', 'db_category'])

        # Removing unique constraint on 'Tag', fields ['db_key', 'db_category']
        db.delete_unique(u'typeclasses_tag', ['db_key', 'db_category'])

        # Removing index on 'LiteAttribute', fields ['db_key', 'db_category']
        db.delete_index(u'typeclasses_liteattribute', ['db_key', 'db_category'])

        # Deleting model 'LiteAttribute'
        db.delete_table(u'typeclasses_liteattribute')

        # Deleting model 'Tag'
        db.delete_table(u'typeclasses_tag')


    models = {
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['typeclasses']

########NEW FILE########
__FILENAME__ = 0004_copy_nicks_to_liteattrs_aliases_to_tags
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models, IntegrityError


class Migration(DataMigration):

    depends_on = (("objects", "0022_add_db_liteattributes_db_tags"),
                  ("players", "0025_auto__add_db_liteattributes_db_tags"))

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.

        # Each alias and nick is its own case. By default, this function starts
        # in a transaction, so we'll close that and make our own transactions.

        for alias in orm['objects.Alias'].objects.all():
            # convert all Aliases to tags
            try:
                tag = orm.Tag.objects.get(db_key=alias.db_key, db_category="object_alias")
            except orm.Tag.DoesNotExist:
                tag = orm.Tag(db_key=alias.db_key, db_category="object_alias", db_data=None)
                tag.save()
            obj = alias.db_obj
            obj.db_tags.add(tag)
        # convert all nicks to LiteAttrs
        for nick in orm['objects.ObjectNick'].objects.all():
            lattr = orm.LiteAttribute(db_key=nick.db_nick, db_category="object_nick_%s" % nick.db_type, db_data=nick.db_real)
            lattr.save()
            obj = nick.db_obj
            obj.db_liteattributes.add(lattr)
        for nick in orm['players.PlayerNick'].objects.all():
            lattr = orm.LiteAttribute(db_key=nick.db_nick, db_category="player_nick_%s" % nick.db_type, db_data=nick.db_real)
            lattr.save()
            obj = nick.db_obj
            obj.db_liteattributes.add(lattr)

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.alias': {
            'Meta': {'object_name': 'Alias'},
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'objects.objectnick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'ObjectNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'players.playernick': {
            'Meta': {'unique_together': "(('db_nick', 'db_type', 'db_obj'),)", 'object_name': 'PlayerNick'},
            'db_nick': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            'db_real': ('django.db.models.fields.TextField', [], {}),
            'db_type': ('django.db.models.fields.CharField', [], {'default': "'inputline'", 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_liteattributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.LiteAttribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_permissions': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects', 'scripts', 'players', 'typeclasses']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0005_auto__add_field_attribute_db_strvalue__add_field_attribute_db_category
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Attribute.db_strvalue'
        db.add_column(u'typeclasses_attribute', 'db_strvalue',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'Attribute.db_category'
        db.add_column(u'typeclasses_attribute', 'db_category',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=128, null=True, blank=True),
                      keep_default=False)

        # Adding index on 'Tag', fields ['db_category']
        db.create_index(u'typeclasses_tag', ['db_category'])

        # Adding index on 'Tag', fields ['db_key']
        db.create_index(u'typeclasses_tag', ['db_key'])


    def backwards(self, orm):
        # Removing index on 'Tag', fields ['db_key']
        db.delete_index(u'typeclasses_tag', ['db_key'])

        # Removing index on 'Tag', fields ['db_category']
        db.delete_index(u'typeclasses_tag', ['db_category'])

        # Deleting field 'Attribute.db_strvalue'
        db.delete_column(u'typeclasses_attribute', 'db_strvalue')

        # Deleting field 'Attribute.db_category'
        db.delete_column(u'typeclasses_attribute', 'db_category')


    models = {
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.liteattribute': {
            'Meta': {'object_name': 'LiteAttribute', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'blank': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['typeclasses']
########NEW FILE########
__FILENAME__ = 0006_auto__del_liteattribute__del_index_liteattribute_db_key_db_category
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    depends_on = (("scripts", "0014_create_db_liteattributes_db_tags"),
                  ("objects", "0022_add_db_liteattributes_db_tags"),
                  ("players", "0025_auto__add_db_liteattributes_db_tags"))

    def forwards(self, orm):
        # Deleting model 'LiteAttribute'
        db.delete_table(u'typeclasses_liteattribute')

    def backwards(self, orm):
        # Adding index on 'LiteAttribute', fields ['db_key', 'db_category']
        db.create_index(u'typeclasses_liteattribute', ['db_key', 'db_category'])

        # Adding model 'LiteAttribute'
        db.create_table(u'typeclasses_liteattribute', (
            ('db_category', self.gf('django.db.models.fields.CharField')(max_length=64, null=True, blank=True)),
            ('db_key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('db_data', self.gf('django.db.models.fields.TextField')()),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal(u'typeclasses', ['LiteAttribute'])


    models = {
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['typeclasses']

########NEW FILE########
__FILENAME__ = 0007_auto__add_field_attribute_db_model__add_field_attribute_db_attrype__ad
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Attribute.db_model'
        db.add_column(u'typeclasses_attribute', 'db_model',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=32, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Attribute.db_attrtype'
        db.add_column(u'typeclasses_attribute', 'db_attrtype',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=16, null=True, blank=True),
                      keep_default=False)

        # Adding field 'Tag.db_model'
        db.add_column(u'typeclasses_tag', 'db_model',
                      self.gf('django.db.models.fields.CharField')(max_length=32, null=True, db_index=True),
                      keep_default=False)

        # Adding field 'Tag.db_tagtype'
        db.add_column(u'typeclasses_tag', 'db_tagtype',
                      self.gf('django.db.models.fields.CharField')(max_length=16, null=True, db_index=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Attribute.db_model'
        db.delete_column(u'typeclasses_attribute', 'db_model')

        # Deleting field 'Attribute.db_attrtype'
        db.delete_column(u'typeclasses_attribute', 'db_attrtype')

        # Deleting field 'Tag.db_model'
        db.delete_column(u'typeclasses_tag', 'db_model')

        # Deleting field 'Tag.db_tagtype'
        db.delete_column(u'typeclasses_tag', 'db_tagtype')


    models = {
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['typeclasses']

########NEW FILE########
__FILENAME__ = 0008_converting_tags_attribute_categories
# -*- coding: utf-8 -*-
from south.utils import datetime_utils as datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (("comms", "0017_renaming_typeclass_from_comm_to_channel"), )

    def forwards(self, orm):
        "Write your forwards methods here."
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.

        for obj in orm['objects.ObjectDB'].objects.all():
            # object-attributes
            for attr in obj.db_attributes.all():
                cat = attr.db_category or ""
                if cat.startswith("nick_"):
                    attr.db_category = cat.split("nick_", 1)[1]
                    attr.db_attrtype = "nick"
                attr.db_model = "objects.objectdb"
                attr.save()
            # object-tags
            for tag in obj.db_tags.all():
                # split info stored in category into separate fields
                tag.db_model = "objects.objectdb"
                cat = tag.db_category or ""
                if cat.startswith("object"):
                    cat = cat.split("object", 1)[1]
                if cat.startswith("alias"):
                    tag.db_tagtype = "alias"
                    cat = cat.split("alias", 1)[1]
                if cat.startswith("permission"):
                    tag.db_tagtype = "permission"
                    cat = cat.split("permission", 1)[1]
                tag.db_category = cat
                tag.save()

        for player in orm['players.PlayerDB'].objects.all():
            # player-attributes
            for attr in player.db_attributes.all():
                cat = attr.db_category or ""
                if cat.startswith("nick_"):
                    attr.db_category = cat.split("nick_", 1)[1]
                    attr.db_attrtype = "nick"
                attr.db_model = "players.playerdb"
                attr.save()
            # player-tags
            for tag in player.db_tags.all():
                # split info stored in category into separate fields
                tag.db_model = "players.playerdb"
                cat = tag.db_category or ""
                if cat.startswith("player"):
                    cat = cat.split("player", 1)[1]
                if cat.startswith("alias"):
                    tag.db_tagtype = "alias"
                    cat = cat.split("alias", 1)[1]
                if cat.startswith("permission"):
                    tag.db_tagtype = "permission"
                    cat = cat.split("permission", 1)[1]
                tag.db_category = cat
                tag.save()

        for script in orm['scripts.ScriptDB'].objects.all():
            # script-attributes
            for attr in script.db_attributes.all():
                cat = attr.db_category or ""
                if cat.startswith("nick_"):
                    attr.db_category = cat.split("nick_", 1)[1]
                    attr.db_attrtype = "nick"
                attr.db_model = "scripts.scriptdb"
                attr.save()
            # script-tags
            for tag in script.db_tags.all():
                # split info stored in category into separate fields
                tag.db_model = "scripts.scriptdb"
                cat = tag.db_category or ""
                if cat.startswith("script"):
                    cat = cat.split("script", 1)[1]
                if cat.startswith("alias"):
                    tag.db_tagtype = "alias"
                    cat = cat.split("alias", 1)[1]
                if cat.startswith("permission"):
                    tag.db_tagtype = "permission"
                    cat = cat.split("permission", 1)[1]
                tag.db_category = cat
                tag.save()

        for channel in orm['comms.ChannelDB'].objects.all():
            # comm-attributes
            for attr in channel.db_attributes.all():
                cat = attr.db_category or ""
                if cat.startswith("nick_"):
                    attr.db_category = cat.split("nick_", 1)[1]
                    attr.db_attrtype = "nick"
                attr.db_model = "comms.channeldb"
                attr.save()
            # comm-tags
            for tag in channel.db_tags.all():
                # split info stored in category into separate fields
                tag.db_model = "comms.channeldb"
                cat = tag.db_category or ""
                if cat.startswith("comms"):
                    cat = cat.split("comms", 1)[1]
                if cat.startswith("alias"):
                    tag.db_tagtype = "alias"
                    cat = cat.split("alias", 1)[1]
                if cat.startswith("permission"):
                    tag.db_tagtype = "permission"
                    cat = cat.split("permission", 1)[1]
                tag.db_category = cat
                tag.save()

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'comms.channeldb': {
            'Meta': {'object_name': 'ChannelDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.externalchannelconnection': {
            'Meta': {'object_name': 'ExternalChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_external_config': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_external_key': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'db_external_send_code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_is_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.msg': {
            'Meta': {'object_name': 'Msg'},
            'db_date_sent': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'db_index': 'True', 'blank': 'True'}),
            'db_header': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_hide_from_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_channels_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_hide_from_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_objects_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_hide_from_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'hide_from_players_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_message': ('django.db.models.fields.TextField', [], {}),
            'db_receivers_channels': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'channel_set'", 'null': 'True', 'to': u"orm['comms.ChannelDB']"}),
            'db_receivers_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_object_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_receivers_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'receiver_player_set'", 'null': 'True', 'to': u"orm['players.PlayerDB']"}),
            'db_sender_external': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_sender_objects': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_object_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_sender_players': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'sender_player_set'", 'null': 'True', 'db_index': 'True', 'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'comms.playerchannelconnection': {
            'Meta': {'object_name': 'PlayerChannelConnection'},
            'db_channel': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['comms.ChannelDB']"}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'objects.objectdb': {
            'Meta': {'object_name': 'ObjectDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_destination': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'destinations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_home': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'homes_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_location': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations_set'", 'null': 'True', 'to': u"orm['objects.ObjectDB']"}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_player': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['players.PlayerDB']", 'null': 'True', 'blank': 'True'}),
            'db_sessid': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'players.playerdb': {
            'Meta': {'object_name': 'PlayerDB'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_cmdset_storage': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_is_connected': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Group']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "u'user_set'", 'blank': 'True', 'to': u"orm['auth.Permission']"}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        u'scripts.scriptdb': {
            'Meta': {'object_name': 'ScriptDB'},
            'db_attributes': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Attribute']", 'null': 'True', 'symmetrical': 'False'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_desc': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'db_interval': ('django.db.models.fields.IntegerField', [], {'default': '-1'}),
            'db_is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_obj': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['objects.ObjectDB']", 'null': 'True', 'blank': 'True'}),
            'db_persistent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_repeats': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'db_start_delay': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'db_tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['typeclasses.Tag']", 'null': 'True', 'symmetrical': 'False'}),
            'db_typeclass_path': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'db_attrtype': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '16', 'null': 'True', 'blank': 'True'}),
            'db_category': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'db_date_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'db_lock_storage': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'null': 'True', 'blank': 'True'}),
            'db_strvalue': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_value': ('src.utils.picklefield.PickledObjectField', [], {'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        u'typeclasses.tag': {
            'Meta': {'unique_together': "(('db_key', 'db_category'),)", 'object_name': 'Tag', 'index_together': "(('db_key', 'db_category'),)"},
            'db_category': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True', 'db_index': 'True'}),
            'db_data': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'db_key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'db_model': ('django.db.models.fields.CharField', [], {'max_length': '32', 'null': 'True', 'db_index': 'True'}),
            'db_tagtype': ('django.db.models.fields.CharField', [], {'max_length': '16', 'null': 'True', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        }
    }

    complete_apps = ['objects', 'scripts', 'comms', 'players', 'typeclasses']
    symmetrical = True

########NEW FILE########
__FILENAME__ = models
"""
This is the *abstract* django models for many of the database objects
in Evennia. A django abstract (obs, not the same as a Python metaclass!) is
a model which is not actually created in the database, but which only exists
for other models to inherit from, to avoid code duplication. Any model can
import and inherit from these classes.

Attributes are database objects stored on other objects. The implementing
class needs to supply a ForeignKey field attr_object pointing to the kind
of object being mapped. Attributes storing iterables actually store special
types of iterables named PackedList/PackedDict respectively. These make
sure to save changes to them to database - this is criticial in order to
allow for obj.db.mylist[2] = data. Also, all dbobjects are saved as
dbrefs but are also aggressively cached.

TypedObjects are objects 'decorated' with a typeclass - that is, the typeclass
(which is a normal Python class implementing some special tricks with its
get/set attribute methods, allows for the creation of all sorts of different
objects all with the same database object underneath. Usually attributes are
used to permanently store things not hard-coded as field on the database object.
The admin should usually not have to deal directly  with the database object
layer.

This module also contains the Managers for the respective models; inherit from
these to create custom managers.

"""

import sys
import re
import traceback

from django.db import models
from django.conf import settings
from django.utils.encoding import smart_str
from django.contrib.contenttypes.models import ContentType

from src.utils.idmapper.models import SharedMemoryModel
from src.server.caches import get_prop_cache, set_prop_cache
#from src.server.caches import set_attr_cache

#from src.server.caches import call_ndb_hooks
from src.server.models import ServerConfig
from src.typeclasses import managers
from src.locks.lockhandler import LockHandler
from src.utils import logger
from src.utils.utils import make_iter, is_iter, to_str, inherits_from
from src.utils.dbserialize import to_pickle, from_pickle
from src.utils.picklefield import PickledObjectField

__all__ = ("Attribute", "TypeNick", "TypedObject")

_PERMISSION_HIERARCHY = [p.lower() for p in settings.PERMISSION_HIERARCHY]
_TYPECLASS_AGGRESSIVE_CACHE = settings.TYPECLASS_AGGRESSIVE_CACHE

_CTYPEGET = ContentType.objects.get
_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__


#------------------------------------------------------------
#
#   Attributes
#
#------------------------------------------------------------

class Attribute(SharedMemoryModel):
    """
    Abstract django model.

    Attributes are things that are specific to different types of objects. For
    example, a drink container needs to store its fill level, whereas an exit
    needs to store its open/closed/locked/unlocked state. These are done via
    attributes, rather than making different classes for each object type and
    storing them directly. The added benefit is that we can add/remove
    attributes on the fly as we like.
    The Attribute class defines the following properties:
      key - primary identifier
      lock_storage - perm strings
      obj - which object the attribute is defined on
      date_created - when the attribute was created.
      value - the data stored in the attribute, in pickled form
              using wrappers to be able to store/retrieve models.
      strvalue - string-only data. This data is not pickled and is
                 thus faster to search for in the database.
      category - optional character string for grouping the Attribute

    """

    #
    # Attribute Database Model setup
    #
    # These database fields are all set using their corresponding properties,
    # named same as the field, but withtout the db_* prefix.
    db_key = models.CharField('key', max_length=255, db_index=True)
    # access through the value property
    db_value = PickledObjectField('value', null=True)
    # string-specific storage for quick look-up
    db_strvalue = models.TextField('strvalue', null=True, blank=True)
    # optional categorization of attribute
    db_category = models.CharField('category', max_length=128, db_index=True, blank=True, null=True)
    # Lock storage
    db_lock_storage = models.TextField('locks', blank=True)
    # Which model of object this Attribute is attached to (A natural key like objects.dbobject)
    db_model = models.CharField('model', max_length=32, db_index=True, blank=True, null=True)
    # subclass of Attribute (None or nick)
    db_attrtype = models.CharField('attrtype', max_length=16, db_index=True, blank=True, null=True)
    # time stamp
    db_date_created = models.DateTimeField('date_created', editable=False, auto_now_add=True)

    # Database manager
    objects = managers.AttributeManager()

    # Lock handler self.locks
    def __init__(self, *args, **kwargs):
        "Initializes the parent first -important!"
        SharedMemoryModel.__init__(self, *args, **kwargs)
        self.locks = LockHandler(self)

    class Meta:
        "Define Django meta options"
        verbose_name = "Evennia Attribute"

    # Wrapper properties to easily set database fields. These are
    # @property decorators that allows to access these fields using
    # normal python operations (without having to remember to save()
    # etc). So e.g. a property 'attr' has a get/set/del decorator
    # defined that allows the user to do self.attr = value,
    # value = self.attr and del self.attr respectively (where self
    # is the object in question).

    # value property (wraps db_value)
    #@property
    def __value_get(self):
        """
        Getter. Allows for value = self.value.
        We cannot cache here since it makes certain cases (such
        as storing a dbobj which is then deleted elsewhere) out-of-sync.
        The overhead of unpickling seems hard to avoid.
        """
        return from_pickle(self.db_value, db_obj=self)

    #@value.setter
    def __value_set(self, new_value):
        """
        Setter. Allows for self.value = value. We cannot cache here,
        see self.__value_get.
        """
        self.db_value = to_pickle(new_value)
        self.save()
        try:
            self._track_db_value_change.update(self.cached_value)
        except AttributeError:
            pass
        return

    #@value.deleter
    def __value_del(self):
        "Deleter. Allows for del attr.value. This removes the entire attribute."
        self.delete()
    value = property(__value_get, __value_set, __value_del)

    #
    #
    # Attribute methods
    #
    #

    def __str__(self):
        return smart_str("%s(%s)" % (_GA(self, "db_key"), _GA(self, "id")))

    def __unicode__(self):
        return u"%s(%s)" % (_GA(self, "db_key"), _GA(self, "id"))

    def access(self, accessing_obj, access_type='read', default=False, **kwargs):
        """
        Determines if another object has permission to access.
        accessing_obj - object trying to access this one
        access_type - type of access sought
        default - what to return if no lock of access_type was found
        **kwargs - passed to at_access hook along with result.
        """
        result = self.locks.check(accessing_obj, access_type=access_type, default=default)
        self.at_access(result, **kwargs)
        return result

    def at_set(self, new_value):
        """
        Hook method called when the attribute changes value.
        """
        pass


#
# Handlers making use of the Attribute model
#

class AttributeHandler(object):
    """
    Handler for adding Attributes to the object.
    """
    _m2m_fieldname = "db_attributes"
    _attrcreate = "attrcreate"
    _attredit = "attredit"
    _attrread = "attrread"
    _attrtype = None

    def __init__(self, obj):
        "Initialize handler"
        self.obj = obj
        self._model = "%s.%s" % ContentType.objects.get_for_model(obj).natural_key()
        self._cache = None

    def _recache(self):
        self._cache = dict(("%s-%s" % (to_str(attr.db_key).lower(),
                                       attr.db_category.lower() if attr.db_category else None), attr)
                        for attr in _GA(self.obj, self._m2m_fieldname).filter(
                            db_model=self._model, db_attrtype=self._attrtype))
        #set_attr_cache(self.obj, self._cache) # currently only for testing

    def has(self, key, category=None):
        """
        Checks if the given Attribute (or list of Attributes) exists on
        the object.

        If an iterable is given, returns list of booleans.
        """
        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        key = [k.strip().lower() for k in make_iter(key) if k]
        category = category.strip().lower() if category is not None else None
        searchkeys = ["%s-%s" % (k, category) for k in make_iter(key)]
        ret = [self._cache.get(skey) for skey in searchkeys if skey in self._cache]
        return ret[0] if len(ret) == 1 else ret

    def get(self, key=None, category=None, default=None, return_obj=False,
            strattr=False, raise_exception=False, accessing_obj=None,
            default_access=True, not_found_none=False):
        """
        Returns the value of the given Attribute or list of Attributes.
        strattr will cause the string-only value field instead of the normal
        pickled field data. Use to get back values from Attributes added with
        the strattr keyword.
        If return_obj=True, return the matching Attribute object
        instead. Returns default if no matches (or [ ] if key was a list
        with no matches). If raise_exception=True, failure to find a
        match will raise AttributeError instead.

        If accessing_obj is given, its "attrread" permission lock will be
        checked before displaying each looked-after Attribute. If no
        accessing_obj is given, no check will be done.
        """

        class RetDefault(object):
            "Holds default values"
            def __init__(self):
                self.value = default
                self.strvalue = str(default) if default is not None else None

        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        ret = []
        key = [k.strip().lower() for k in make_iter(key) if k]
        category = category.strip().lower() if category is not None else None
        #print "cache:", self._cache.keys(), key
        if not key:
            # return all with matching category (or no category)
            catkey = "-%s" % category if category is not None else None
            ret = [attr for key, attr in self._cache.items() if key and key.endswith(catkey)]
        else:
            for searchkey in ("%s-%s" % (k, category) for k in key):
                attr_obj = self._cache.get(searchkey)
                if attr_obj:
                    ret.append(attr_obj)
                else:
                    if raise_exception:
                        raise AttributeError
                    else:
                        ret.append(RetDefault())
        if accessing_obj:
            # check 'attrread' locks
            ret = [attr for attr in ret if attr.access(accessing_obj, self._attrread, default=default_access)]
        if strattr:
            ret = ret if return_obj else [attr.strvalue for attr in ret if attr]
        else:
            ret = ret if return_obj else [attr.value for attr in ret if attr]
        if not ret:
            return ret if len(key) > 1 else default
        return ret[0] if len(ret)==1 else ret

    def add(self, key, value, category=None, lockstring="",
            strattr=False, accessing_obj=None, default_access=True):
        """
        Add attribute to object, with optional lockstring.

        If strattr is set, the db_strvalue field will be used (no pickling).
        Use the get() method with the strattr keyword to get it back.

        If accessing_obj is given, self.obj's  'attrcreate' lock access
        will be checked against it. If no accessing_obj is given, no check
        will be done.
        """
        if accessing_obj and not self.obj.access(accessing_obj,
                                      self._attrcreate, default=default_access):
            # check create access
            return
        if self._cache is None:
            self._recache()
        if not key:
            return
        key = key.strip().lower()
        category = category.strip().lower() if category is not None else None
        cachekey = "%s-%s" % (key, category)
        attr_obj = self._cache.get(cachekey)
        if not attr_obj:
            # no old attr available; create new.
            attr_obj = Attribute(db_key=key, db_category=category,
                                 db_model=self._model, db_attrtype=self._attrtype)
            attr_obj.save()  # important
            _GA(self.obj, self._m2m_fieldname).add(attr_obj)
            self._cache[cachekey] = attr_obj
        if lockstring:
            attr_obj.locks.add(lockstring)
        # we shouldn't need to fear stale objects, the field signalling
        # should catch all cases
        if strattr:
            # store as a simple string
            attr_obj.strvalue = value
            attr_obj.value = None
        else:
            # pickle arbitrary data
            attr_obj.value = value
            attr_obj.strvalue = None

    def remove(self, key, raise_exception=False, category=None,
               accessing_obj=None, default_access=True):
        """Remove attribute or a list of attributes from object.

        If accessing_obj is given, will check against the 'attredit' lock.
        If not given, this check is skipped.
        """
        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        key = [k.strip().lower() for k in make_iter(key) if k]
        category = category.strip().lower() if category is not None else None
        for searchstr in ("%s-%s" % (k, category) for k in key):
            attr_obj = self._cache.get(searchstr)
            if attr_obj:
                if not (accessing_obj and not attr_obj.access(accessing_obj,
                        self._attredit, default=default_access)):
                    attr_obj.delete()
            elif not attr_obj and raise_exception:
                raise AttributeError
        self._recache()

    def clear(self, category=None, accessing_obj=None, default_access=True):
        """
        Remove all Attributes on this object. If accessing_obj is
        given, check the 'attredit' lock on each Attribute before
        continuing. If not given, skip check.
        """
        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        if accessing_obj:
            [attr.delete() for attr in self._cache.values()
             if attr.access(accessing_obj, self._attredit, default=default_access)]
        else:
            [attr.delete() for attr in self._cache.values()]
        self._recache()

    def all(self, accessing_obj=None, default_access=True):
        """
        Return all Attribute objects on this object.

        If accessing_obj is given, check the "attrread" lock on
        each attribute before returning them. If not given, this
        check is skipped.
        """
        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        if accessing_obj:
            return [attr for attr in self._cache.values()
                    if attr.access(accessing_obj, self._attredit, default=default_access)]
        else:
            return self._cache.values()

class NickHandler(AttributeHandler):
    """
    Handles the addition and removal of Nicks
    (uses Attributes' strvalue and category fields)

    Nicks are stored as Attributes
    with categories nick_<nicktype>
    """
    _attrtype = "nick"

    def has(self, key, category="inputline"):
        return super(NickHandler, self).has(key, category=category)

    def get(self, key=None, category="inputline", **kwargs):
        "Get the replacement value matching the given key and category"
        return super(NickHandler, self).get(key=key, category=category, strattr=True, **kwargs)

    def add(self, key, replacement, category="inputline", **kwargs):
        "Add a new nick"
        super(NickHandler, self).add(key, replacement, category=category, strattr=True, **kwargs)

    def remove(self, key, category="inputline", **kwargs):
        "Remove Nick with matching category"
        super(NickHandler, self).remove(key, category=category, **kwargs)

    def nickreplace(self, raw_string, categories=("inputline", "channel"), include_player=True):
        "Replace entries in raw_string with nick replacement"
        raw_string
        obj_nicks, player_nicks = [], []
        for category in make_iter(categories):
            obj_nicks.extend([n for n in make_iter(self.get(category=category, return_obj=True)) if n])
        if include_player and self.obj.has_player:
            for category in make_iter(categories):
                player_nicks.extend([n for n in make_iter(self.obj.player.nicks.get(category=category, return_obj=True)) if n])
        for nick in obj_nicks + player_nicks:
            # make a case-insensitive match here
            match = re.match(re.escape(nick.db_key), raw_string, re.IGNORECASE)
            if match:
                raw_string = raw_string.replace(match.group(), nick.db_strvalue, 1)
                break
        return raw_string


class NAttributeHandler(object):
    """
    This stand-alone handler manages non-database saved properties by storing
    them as properties on obj.ndb. It has the same methods as AttributeHandler,
    but they are much simplified.
    """
    def __init__(self, obj):
        "initialized on the object"
        self.ndb = _GA(obj, "ndb")

    def has(self, key):
        "Check if object has this attribute or not"
        return _GA(self.ndb, key)  # ndb returns None if not found

    def get(self, key):
        "Returns named key value"
        return _GA(self.ndb, key)

    def add(self, key, value):
        "Add new key and value"
        _SA(self.ndb, key, value)

    def remove(self, key):
        "Remove key from storage"
        _DA(self.ndb, key)

    def all(self):
        "List all keys stored"
        if callable(self.ndb.all):
            return self.ndb.all()
        else:
            return [val for val in self.ndb.__dict__.keys() if not val.startswith('_')]


#------------------------------------------------------------
#
# Tags
#
#------------------------------------------------------------

class Tag(models.Model):
    """
    Tags are quick markers for objects in-game. An typeobject
    can have any number of tags, stored via its db_tags property.
    Tagging similar objects will make it easier to quickly locate the
    group later (such as when implementing zones). The main advantage
    of tagging as opposed to using Attributes is speed; a tag is very
    limited in what data it can hold, and the tag key+category is
    indexed for efficient lookup in the database. Tags are shared between
    objects - a new tag is only created if the key+category combination
    did not previously exist, making them unsuitable for storing
    object-related data (for this a full Attribute
    should be used).
    The 'db_data' field is intended as a documentation
    field for the tag itself, such as to document what this tag+category
    stands for and display that in a web interface or similar.

    The main default use for Tags is to implement Aliases for objects.
    this uses the 'aliases' tag category, which is also checked by the
    default search functions of Evennia to allow quick searches by alias.
    """
    db_key = models.CharField('key', max_length=255, null=True,
                              help_text="tag identifier", db_index=True)
    db_category = models.CharField('category', max_length=64, null=True,
                                   help_text="tag category", db_index=True)
    db_data = models.TextField('data', null=True, blank=True,
                               help_text="optional data field with extra information. This is not searched for.")
    # this is "objects.objectdb" etc
    db_model = models.CharField('model', max_length=32, null=True, help_text="database model to Tag", db_index=True)
    # this is None, alias or permission
    db_tagtype = models.CharField('tagtype', max_length=16, null=True, help_text="overall type of Tag", db_index=True)
    objects = managers.TagManager()

    class Meta:
        "Define Django meta options"
        verbose_name = "Tag"
        unique_together = (('db_key', 'db_category'),)
        index_together = (('db_key', 'db_category'),)

    def __unicode__(self):
        return u"%s" % self.db_key

    def __str__(self):
        return str(self.db_key)


#
# Handlers making use of the Tags model
#

class TagHandler(object):
    """
    Generic tag-handler. Accessed via TypedObject.tags.
    """
    _m2m_fieldname = "db_tags"
    _tagtype = None

    def __init__(self, obj):
        """
        Tags are stored internally in the TypedObject.db_tags m2m field
        with an tag.db_model based on the obj the taghandler is stored on
        and with a tagtype given by self.handlertype
        """
        self.obj = obj
        self._model = "%s.%s" % ContentType.objects.get_for_model(obj).natural_key()
        self._cache = None


    def _recache(self):
        "Update cache from database field"
        self._cache = dict(("%s-%s" % (tag.db_key, tag.db_category), tag)
                            for tag in _GA(self.obj, self._m2m_fieldname).filter(
                                         db_model=self._model, db_tagtype=self._tagtype))

    def add(self, tag, category=None, data=None):
        "Add a new tag to the handler. Tag is a string or a list of strings."
        for tagstr in make_iter(tag):
            if not tagstr:
                continue
            tagstr = tagstr.strip().lower()
            category = category.strip().lower() if category is not None else None
            data = str(data) if data is not None else None
            # this will only create tag if no matches existed beforehand (it
            # will overload data on an existing tag since that is not
            # considered part of making the tag unique)
            tagobj = Tag.objects.create_tag(key=tagstr, category=category, data=data,
                                            model=self._model, tagtype=self._tagtype)
            _GA(self.obj, self._m2m_fieldname).add(tagobj)
            if self._cache is None:
                self._recache()
            cachestring = "%s-%s" % (tagstr, category)
            self._cache[cachestring] = tagobj

    def get(self, key, category="", return_tagobj=False):
        """
        Get the tag for the given key or list of tags. If
        return_data=True, return the matching Tag objects instead.
        Returns a single tag if a unique match, otherwise a list
        """
        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        ret = []
        category = category.strip().lower() if category is not None else None
        searchkey = ["%s-%s" % (key.strip().lower(), category) if key is not None else None for key in make_iter(key)]
        ret = [val for val in (self._cache.get(keystr) for keystr in searchkey) if val]
        ret = [to_str(tag.db_data) for tag in ret] if return_tagobj else ret
        return ret[0] if len(ret) == 1 else ret

    def remove(self, key, category=None):
        "Remove a tag from the handler based ond key and category."
        for key in make_iter(key):
            if not (key or key.strip()):  # we don't allow empty tags
                continue
            tagstr = key.strip().lower()
            category = category.strip().lower() if category is not None else None

            # This does not delete the tag object itself. Maybe it should do
            # that when no objects reference the tag anymore (how to check)?
            tagobj = self.obj.db_tags.filter(db_key=tagstr, db_category=category)
            if tagobj:
                _GA(self.obj, self._m2m_fieldname).remove(tagobj[0])
        self._recache()

    def clear(self):
        "Remove all tags from the handler"
        for tag in _GA(self.obj, self._m2m_fieldname).filter(db_model=self._model, db_tagtype=self._tagtype):
            _GA(self.obj, self._m2m_fieldname).remove(tag)
        self._recache()

    def all(self, category=None, return_key_and_category=False):
        """
        Get all tags in this handler.
        If category is given, return only Tags with this category.  If
        return_keys_and_categories is set, return a list of tuples [(key, category), ...]
        """
        if self._cache is None or not _TYPECLASS_AGGRESSIVE_CACHE:
            self._recache()
        if category:
            category = category.strip().lower() if category is not None else None
            matches = _GA(self.obj, self._m2m_fieldname).filter(db_category=category,
                                                                db_tagtype=self._tagtype,
                                                                db_model=self._model).values_list("db_key")
        else:
            matches = self._cache.values()
        if matches:
            if return_key_and_category:
                # return tuple (key, category)
                return [(to_str(p.db_key), to_str(p.db_category)) for p in matches]
            else:
                return [to_str(p.db_key) for p in matches]
        return []

        #return [to_str(p[0]) for p in _GA(self.obj, self._m2m_fieldname).filter(db_category__startswith=self.prefix).values_list("db_key") if p[0]]

    def __str__(self):
        return ",".join(self.all())

    def __unicode(self):
        return u",".join(self.all())


class AliasHandler(TagHandler):
    _tagtype = "alias"


class PermissionHandler(TagHandler):
    _tagtype = "permission"


#------------------------------------------------------------
#
# Typed Objects
#
#------------------------------------------------------------


class TypedObject(SharedMemoryModel):
    """
    Abstract Django model.

    This is the basis for a typed object. It also contains all the
    mechanics for managing connected attributes.

    The TypedObject has the following properties:
      key - main name
      name - alias for key
      typeclass_path - the path to the decorating typeclass
      typeclass - auto-linked typeclass
      date_created - time stamp of object creation
      permissions - perm strings
      dbref - #id of object
      db - persistent attribute storage
      ndb - non-persistent attribute storage

    """

    #
    # TypedObject Database Model setup
    #
    #
    # These databse fields are all accessed and set using their corresponding
    # properties, named same as the field, but without the db_* prefix
    # (no separate save() call is needed)

    # Main identifier of the object, for searching. Is accessed with self.key
    # or self.name
    db_key = models.CharField('key', max_length=255, db_index=True)
    # This is the python path to the type class this object is tied to the
    # typeclass is what defines what kind of Object this is)
    db_typeclass_path = models.CharField('typeclass', max_length=255, null=True,
            help_text="this defines what 'type' of entity this is. This variable holds a Python path to a module with a valid Evennia Typeclass.")
    # Creation date. This is not changed once the object is created.
    db_date_created = models.DateTimeField('creation date', editable=False, auto_now_add=True)
    # Permissions (access these through the 'permissions' property)
    #db_permissions = models.CharField('permissions', max_length=255, blank=True,
    #     help_text="a comma-separated list of text strings checked by
    # in-game locks. They are often used for hierarchies, such as letting a Player have permission 'Wizards', 'Builders' etc. Character objects use 'Players' by default. Most other objects don't have any permissions.")
    # Lock storage
    db_lock_storage = models.TextField('locks', blank=True,
            help_text="locks limit access to an entity. A lock is defined as a 'lock string' on the form 'type:lockfunctions', defining what functionality is locked and how to determine access. Not defining a lock means no access is granted.")
    # many2many relationships
    db_attributes = models.ManyToManyField(Attribute, null=True,
            help_text='attributes on this object. An attribute can hold any pickle-able python object (see docs for special cases).')
    db_tags = models.ManyToManyField(Tag, null=True,
            help_text='tags on this object. Tags are simple string markers to identify, group and alias objects.')

    # Database manager
    objects = managers.TypedObjectManager()

    # quick on-object typeclass cache for speed
    _cached_typeclass = None

    # lock handler self.locks
    def __init__(self, *args, **kwargs):
        "We must initialize the parent first - important!"
        super(SharedMemoryModel, self).__init__(*args, **kwargs)
        #SharedMemoryModel.__init__(self, *args, **kwargs)
        _SA(self, "dbobj", self)   # this allows for self-reference
        _SA(self, "locks", LockHandler(self))
        _SA(self, "permissions", PermissionHandler(self))
        _SA(self, "nattributes", NAttributeHandler(self))

    class Meta:
        """
        Django setup info.
        """
        abstract = True
        verbose_name = "Evennia Database Object"
        ordering = ['-db_date_created', 'id', 'db_typeclass_path', 'db_key']

    # wrapper
    # Wrapper properties to easily set database fields. These are
    # @property decorators that allows to access these fields using
    # normal python operations (without having to remember to save()
    # etc). So e.g. a property 'attr' has a get/set/del decorator
    # defined that allows the user to do self.attr = value,
    # value = self.attr and del self.attr respectively (where self
    # is the object in question).

    # name property (alias to self.key)
    def __name_get(self):
        return self.key

    def __name_set(self, value):
        self.key = value

    def __name_del(self):
        raise Exception("Cannot delete name")
    name = property(__name_get, __name_set, __name_del)

    #
    #
    # TypedObject main class methods and properties
    #
    #

    _typeclass_paths = settings.OBJECT_TYPECLASS_PATHS

    def __eq__(self, other):
        return other and hasattr(other, 'dbid') and self.dbid == other.dbid

    def __str__(self):
        return smart_str("%s" % _GA(self, "db_key"))

    def __unicode__(self):
        return u"%s" % _GA(self, "db_key")

    def __getattribute__(self, propname):
        """
        Will predominantly look for an attribute
        on this object, but if not found we will
        check if it might exist on the typeclass instead. Since
        the typeclass refers back to the databaseobject as well, we
        have to be very careful to avoid loops.
        """
        try:
            return _GA(self, propname)
        except AttributeError:
            if propname.startswith('_'):
                # don't relay private/special varname lookups to the typeclass
                raise AttributeError("private property %s not found on db model (typeclass not searched)." % propname)
            # check if the attribute exists on the typeclass instead
            # (we make sure to not incur a loop by not triggering the
            # typeclass' __getattribute__, since that one would
            # try to look back to this very database object.)
            return _GA(_GA(self, 'typeclass'), propname)

    def _hasattr(self, obj, attrname):
        """
        Loop-safe version of hasattr, to avoid running a lookup that
        will be rerouted up the typeclass. Returns True/False.
        """
        try:
            _GA(obj, attrname)
            return True
        except AttributeError:
            return False

    #@property
    def __dbid_get(self):
        """
        Caches and returns the unique id of the object.
        Use this instead of self.id, which is not cached.
        """
        dbid = get_prop_cache(self, "_dbid")
        if not dbid:
            dbid = _GA(self, "id")
            set_prop_cache(self, "_dbid", dbid)
        return dbid

    def __dbid_set(self, value):
        raise Exception("dbid cannot be set!")

    def __dbid_del(self):
        raise Exception("dbid cannot be deleted!")
    dbid = property(__dbid_get, __dbid_set, __dbid_del)

    #@property
    def __dbref_get(self):
        """
        Returns the object's dbref on the form #NN.
        """
        return "#%s" % _GA(self, "_TypedObject__dbid_get")()

    def __dbref_set(self):
        raise Exception("dbref cannot be set!")

    def __dbref_del(self):
        raise Exception("dbref cannot be deleted!")
    dbref = property(__dbref_get, __dbref_set, __dbref_del)

    # typeclass property
    #@property
    def __typeclass_get(self):
        """
        Getter. Allows for value = self.typeclass.
        The typeclass is a class object found at self.typeclass_path;
        it allows for extending the Typed object for all different
        types of objects that the game needs. This property
        handles loading and initialization of the typeclass on the fly.

        Note: The liberal use of _GA and __setattr__ (instead
              of normal dot notation) is due to optimization: it avoids calling
              the custom self.__getattribute__ more than necessary.
        """

        path = _GA(self, "typeclass_path")
        typeclass = _GA(self, "_cached_typeclass")
        try:
            if typeclass and _GA(typeclass, "path") == path:
                # don't call at_init() when returning from cache
                return typeclass
        except AttributeError:
            pass
        errstring = ""
        if not path:
            # this means we should get the default obj without giving errors.
            return _GA(self, "_get_default_typeclass")(cache=True, silent=True, save=True)
        else:
            # handle loading/importing of typeclasses, searching all paths.
            # (self._typeclass_paths is a shortcut to settings.TYPECLASS_*_PATHS
            # where '*' is either OBJECT, SCRIPT or PLAYER depending on the
            # typed entities).
            typeclass_paths = [path] + ["%s.%s" % (prefix, path)
                                    for prefix in _GA(self, '_typeclass_paths')]

            for tpath in typeclass_paths:

                # try to import and analyze the result
                typeclass = _GA(self, "_path_import")(tpath)
                if callable(typeclass):
                    # we succeeded to import. Cache and return.
                    _SA(self, "typeclass_path", tpath)
                    typeclass = typeclass(self)
                    _SA(self, "_cached_typeclass", typeclass)
                    try:
                        typeclass.at_init()
                    except AttributeError:
                        logger.log_trace("\n%s: Error initializing typeclass %s. Using default." % (self, tpath))
                        break
                    except Exception:
                        logger.log_trace()
                    return typeclass
                elif hasattr(typeclass, '__file__'):
                    errstring += "\n%s seems to be just the path to a module. You need" % tpath
                    errstring +=  " to specify the actual typeclass name inside the module too."
                elif typeclass:
                    errstring += "\n%s" % typeclass.strip()    # this will hold a growing error message.
            errstring += "\nTypeclass failed to load. Falling back to default."
        # If we reach this point we couldn't import any typeclasses. Return
        # default. It's up to the calling method to use e.g. self.is_typeclass()
        # to detect that the result is not the one asked for.
        _GA(self, "_display_errmsg")(errstring.strip())
        return _GA(self, "_get_default_typeclass")(cache=False, silent=False, save=False)

    #@typeclass.deleter
    def __typeclass_del(self):
        "Deleter. Disallow 'del self.typeclass'"
        raise Exception("The typeclass property should never be deleted, only changed in-place!")

    # typeclass property
    typeclass = property(__typeclass_get, fdel=__typeclass_del)

    # the last error string will be stored here for accessing methods to access.
    # It is set by _display_errmsg, which will print to log if error happens
    # during server startup.
    typeclass_last_errmsg = ""

    def _path_import(self, path):
        """
        Import a class from a python path of the
        form src.objects.object.Object
        """
        errstring = ""
        if not path:
            # this needs not be bad, it just means
            # we should use defaults.
            return None
        try:
            modpath, class_name = path.rsplit('.', 1)
            module = __import__(modpath, fromlist=["none"])
            return module.__dict__[class_name]
        except ImportError:
            trc = sys.exc_traceback
            if not trc.tb_next:
                # we separate between not finding the module, and finding
                # a buggy one.
                pass
                #errstring = ""#Typeclass not found trying path '%s'." % path
            else:
                # a bug in the module is reported normally.
                trc = traceback.format_exc().strip()
                errstring = "\n%sError importing '%s'." % (trc, path)
        except (ValueError, TypeError):
            errstring = "Malformed typeclass path '%s'." % path
        except KeyError:
            errstring = "No class '%s' was found in module '%s'."
            errstring = errstring % (class_name, modpath)
        except Exception:
            trc = traceback.format_exc().strip()
            errstring = "\n%sException importing '%s'." % (trc, path)
        # return the error.
        return errstring

    def _display_errmsg(self, message):
        """
        Helper function to display error.
        """
        _SA(self, "typeclass_lasterrmsg", message)
        if ServerConfig.objects.conf("server_starting_mode"):
            print message
        else:
            logger.log_errmsg(message)
        return

    def _get_default_typeclass(self, cache=False, silent=False, save=False):
        """
        This is called when a typeclass fails to
        load for whatever reason.
        Overload this in different entities.

        Default operation is to load a default typeclass.
        """
        defpath = _GA(self, "_default_typeclass_path")
        typeclass = _GA(self, "_path_import")(defpath)
        # if not silent:
        #     #errstring = "\n\nUsing Default class '%s'." % defpath
        #     _GA(self, "_display_errmsg")(errstring)

        if not callable(typeclass):
            # if typeclass still doesn't exist at this point, we're in trouble.
            # fall back to hardcoded core class which is wrong for e.g.
            # scripts/players etc.
            failpath = defpath
            defpath = "src.objects.objects.Object"
            typeclass = _GA(self, "_path_import")(defpath)
            if not silent:
                #errstring = "  %s\n%s" % (typeclass, errstring)
                errstring = "  Default class '%s' failed to load." % failpath
                errstring += "\n  Using Evennia's default root '%s'." % defpath
                _GA(self, "_display_errmsg")(errstring.strip())
        if not callable(typeclass):
            # if this is still giving an error, Evennia is wrongly
            # configured or buggy
            raise Exception("CRITICAL ERROR: The final fallback typeclass %s cannot load!!" % defpath)
        typeclass = typeclass(self)
        if save:
            _SA(self, 'db_typeclass_path', defpath)
            _GA(self, 'save')()
        if cache:
            _SA(self, "_cached_db_typeclass_path", defpath)

            _SA(self, "_cached_typeclass", typeclass)
        try:
            typeclass.at_init()
        except Exception:
            logger.log_trace()
        return typeclass

    def is_typeclass(self, typeclass, exact=True):
        """
        Returns true if this object has this type
          OR has a typeclass which is an subclass of
          the given typeclass. This operates on the actually
          loaded typeclass (this is important since a failing
          typeclass may instead have its default currently loaded)

        typeclass - can be a class object or the
                python path to such an object to match against.

        exact - returns true only if the object's
               type is exactly this typeclass, ignoring
               parents.
        """
        try:
            typeclass = _GA(typeclass, "path")
        except AttributeError:
            pass
        typeclasses = [typeclass] + ["%s.%s" % (path, typeclass)
                                     for path in _GA(self, "_typeclass_paths")]
        if exact:
            current_path = _GA(self.typeclass, "path") #"_GA(self, "_cached_db_typeclass_path")
            return typeclass and any((current_path == typec for typec in typeclasses))
        else:
            # check parent chain
            return any((cls for cls in self.typeclass.__class__.mro()
                        if any(("%s.%s" % (_GA(cls, "__module__"),
                                _GA(cls, "__name__")) == typec
                                    for typec in typeclasses))))

    #
    # Object manipulation methods
    #

    def swap_typeclass(self, new_typeclass, clean_attributes=False,
                       run_start_hooks=True, no_default=True):
        """
        This performs an in-situ swap of the typeclass. This means
        that in-game, this object will suddenly be something else.
        Player will not be affected. To 'move' a player to a different
        object entirely (while retaining this object's type), use
        self.player.swap_object().

        Note that this might be an error prone operation if the
        old/new typeclass was heavily customized - your code
        might expect one and not the other, so be careful to
        bug test your code if using this feature! Often its easiest
        to create a new object and just swap the player over to
        that one instead.

        Arguments:
        new_typeclass (path/classobj) - type to switch to
        clean_attributes (bool/list) - will delete all attributes
                           stored on this object (but not any
                           of the database fields such as name or
                           location). You can't get attributes back,
                           but this is often the safest bet to make
                           sure nothing in the new typeclass clashes
                           with the old one. If you supply a list,
                           only those named attributes will be cleared.
        no_default - if this is active, the swapper will not allow for
                     swapping to a default typeclass in case the given
                     one fails for some reason. Instead the old one
                     will be preserved.
        Returns:
          boolean True/False depending on if the swap worked or not.

        """
        if callable(new_typeclass):
            # this is an actual class object - build the path
            cls = new_typeclass
            new_typeclass = "%s.%s" % (cls.__module__, cls.__name__)
        else:
            new_typeclass = "%s" % to_str(new_typeclass)

        # Try to set the new path
        # this will automatically save to database
        old_typeclass_path = self.typeclass_path

        if inherits_from(self, "src.scripts.models.ScriptDB"):
            if self.interval > 0:
                raise RuntimeError("Cannot use swap_typeclass on time-dependent " \
                                   "Script '%s'.\nStop and start a new Script of the " \
                                   "right type instead." % self.key)

        _SA(self, "typeclass_path", new_typeclass.strip())
        # this will automatically use a default class if
        # there is an error with the given typeclass.
        new_typeclass = self.typeclass
        if self.typeclass_path != new_typeclass.path and no_default:
            # something went wrong; the default was loaded instead,
            # and we don't allow that; instead we return to previous.
            _SA(self, "typeclass_path", old_typeclass_path)
            return False

        if clean_attributes:
            # Clean out old attributes
            if is_iter(clean_attributes):
                for attr in clean_attributes:
                    self.attr(attr, delete=True)
                for nattr in clean_attributes:
                    if hasattr(self.ndb, nattr):
                        self.nattr(nattr, delete=True)
            else:
                #print "deleting attrs ..."
                for attr in self.get_all_attributes():
                    attr.delete()
                for nattr in self.ndb.all:
                    del nattr

        if run_start_hooks:
            # run hooks for this new typeclass
            if inherits_from(self, "src.objects.models.ObjectDB"):
                new_typeclass.basetype_setup()
                new_typeclass.at_object_creation()
            elif inherits_from(self, "src.players.models.PlayerDB"):
                new_typeclass.basetype_setup()
                new_typeclass.at_player_creation()
            elif inherits_from(self, "src.scripts.models.ScriptDB"):
                new_typeclass.at_script_creation()
                new_typeclass.start()
            elif inherits_from(self, "src.channels.models.Channel"):
                # channels do no initial setup
                pass

        return True

    #
    # Lock / permission methods
    #

    def access(self, accessing_obj, access_type='read', default=False, **kwargs):
        """
        Determines if another object has permission to access.
        accessing_obj - object trying to access this one
        access_type - type of access sought
        default - what to return if no lock of access_type was found
        **kwargs - this is ignored, but is there to make the api consistent with the
                   object-typeclass method access, which use it to feed to its hook methods.
        """
        return self.locks.check(accessing_obj, access_type=access_type, default=default)

    def check_permstring(self, permstring):
        """
        This explicitly checks if we hold particular permission without
        involving any locks. It does -not- trigger the at_access hook.
        """
        if hasattr(self, "player"):
            if self.player and self.player.is_superuser:
                return True
        else:
            if self.is_superuser:
                return True

        if not permstring:
            return False
        perm = permstring.lower()
        perms = [p.lower() for p in self.permissions.all()]
        if perm in perms:
            # simplest case - we have a direct match
            return True
        if perm in _PERMISSION_HIERARCHY:
            # check if we have a higher hierarchy position
            ppos = _PERMISSION_HIERARCHY.index(perm)
            return any(True for hpos, hperm in enumerate(_PERMISSION_HIERARCHY)
                       if hperm in perms and hpos > ppos)
        return False

    def delete(self):
        "Cleaning up handlers on the typeclass level"
        _GA(self, "permissions").clear()
        _SA(self, "_cached_typeclass", None)
        _GA(self, "flush_from_cache")()
        super(TypedObject, self).delete()

    #
    # Memory management
    #

    def flush_from_cache(self):
        """
        Flush this object instance from cache, forcing an object reload.
        Note that this will kill all temporary attributes on this object
         since it will be recreated as a new Typeclass instance.
        """
        self.__class__.flush_cached_instance(self)

    #
    # Attribute storage
    #

    #@property db
    def __db_get(self):
        """
        Attribute handler wrapper. Allows for the syntax
           obj.db.attrname = value
             and
           value = obj.db.attrname
             and
           del obj.db.attrname
             and
           all_attr = obj.db.all() (unless there is an attribute
                      named 'all', in which case that will be returned instead).
        """
        try:
            return self._db_holder
        except AttributeError:
            class DbHolder(object):
                "Holder for allowing property access of attributes"
                def __init__(self, obj):
                    _SA(self, 'obj', obj)
                    _SA(self, "attrhandler", _GA(_GA(self, "obj"), "attributes"))

                def __getattribute__(self, attrname):
                    if attrname == 'all':
                        # we allow to overload our default .all
                        attr = _GA(self, "attrhandler").get("all")
                        if attr:
                            return attr
                        return _GA(self, 'all')
                    return _GA(self, "attrhandler").get(attrname)

                def __setattr__(self, attrname, value):
                    _GA(self, "attrhandler").add(attrname, value)

                def __delattr__(self, attrname):
                    _GA(self, "attrhandler").remove(attrname)

                def get_all(self):
                    return _GA(self, "attrhandler").all()
                all = property(get_all)
            self._db_holder = DbHolder(self)
            return self._db_holder

    #@db.setter
    def __db_set(self, value):
        "Stop accidentally replacing the db object"
        string = "Cannot assign directly to db object! "
        string += "Use db.attr=value instead."
        raise Exception(string)

    #@db.deleter
    def __db_del(self):
        "Stop accidental deletion."
        raise Exception("Cannot delete the db object!")
    db = property(__db_get, __db_set, __db_del)

    #
    # Non-persistent (ndb) storage
    #

    #@property ndb
    def __ndb_get(self):
        """
        A non-attr_obj store (ndb: NonDataBase). Everything stored
        to this is guaranteed to be cleared when a server is shutdown.
        Syntax is same as for the _get_db_holder() method and
        property, e.g. obj.ndb.attr = value etc.
        """
        try:
            return self._ndb_holder
        except AttributeError:
            class NdbHolder(object):
                "Holder for storing non-attr_obj attributes."
                def get_all(self):
                    return [val for val in self.__dict__.keys()
                            if not val.startswith('_')]
                all = property(get_all)

                def __getattribute__(self, key):
                    # return None if no matching attribute was found.
                    try:
                        return _GA(self, key)
                    except AttributeError:
                        return None

                def __setattr__(self, key, value):
                    # hook the oob handler here
                    #call_ndb_hooks(self, key, value)
                    _SA(self, key, value)
            self._ndb_holder = NdbHolder()
            return self._ndb_holder

    #@ndb.setter
    def __ndb_set(self, value):
        "Stop accidentally replacing the db object"
        string = "Cannot assign directly to ndb object! "
        string = "Use ndb.attr=value instead."
        raise Exception(string)

    #@ndb.deleter
    def __ndb_del(self):
        "Stop accidental deletion."
        raise Exception("Cannot delete the ndb object!")
    ndb = property(__ndb_get, __ndb_set, __ndb_del)

    #
    # ***** DEPRECATED METHODS BELOW   *******
    #

    #
    # Full attr_obj attributes. You usually access these
    # through the obj.db.attrname method.

    # Helper methods for attr_obj attributes

    def has_attribute(self, attribute_name):
        """
        See if we have an attribute set on the object.

        attribute_name: (str) The attribute's name.
        """
        logger.log_depmsg("obj.has_attribute() is deprecated. Use obj.attributes.has().")
        return _GA(self, "attributes").has(attribute_name)

    def set_attribute(self, attribute_name, new_value=None, lockstring=""):
        """
        Sets an attribute on an object. Creates the attribute if need
        be.

        attribute_name: (str) The attribute's name.
        new_value: (python obj) The value to set the attribute to. If this is not
                                a str, the object will be stored as a pickle.
        lockstring - this sets an access restriction on the attribute object. Note that
                     this is normally NOT checked - use the secureattr() access method
                     below to perform access-checked modification of attributes. Lock
                     types checked by secureattr are 'attrread','attredit','attrcreate'.
        """
        logger.log_depmsg("obj.set_attribute() is deprecated. Use obj.db.attr=value or obj.attributes.add().")
        _GA(self, "attributes").add(attribute_name, new_value, lockstring=lockstring)

    def get_attribute_obj(self, attribute_name, default=None):
        """
        Get the actual attribute object named attribute_name
        """
        logger.log_depmsg("obj.get_attribute_obj() is deprecated. Use obj.attributes.get(..., return_obj=True)")
        return _GA(self, "attributes").get(attribute_name, default=default, return_obj=True)

    def get_attribute(self, attribute_name, default=None, raise_exception=False):
        """
        Returns the value of an attribute on an object. You may need to
        type cast the returned value from this function since the attribute
        can be of any type. Returns default if no match is found.

        attribute_name: (str) The attribute's name.
        default: What to return if no attribute is found
        raise_exception (bool) - raise an exception if no object exists instead of returning default.
        """
        logger.log_depmsg("obj.get_attribute() is deprecated. Use obj.db.attr or obj.attributes.get().")
        return _GA(self, "attributes").get(attribute_name, default=default, raise_exception=raise_exception)

    def del_attribute(self, attribute_name, raise_exception=False):
        """
        Removes an attribute entirely.

        attribute_name: (str) The attribute's name.
        raise_exception (bool) - raise exception if attribute to delete
                                 could not be found
        """
        logger.log_depmsg("obj.del_attribute() is deprecated. Use del obj.db.attr or obj.attributes.remove().")
        _GA(self, "attributes").remove(attribute_name, raise_exception=raise_exception)

    def get_all_attributes(self):
        """
        Returns all attributes defined on the object.
        """
        logger.log_depmsg("obj.get_all_attributes() is deprecated. Use obj.db.all() or obj.attributes.all().")
        return _GA(self, "attributes").all()

    def attr(self, attribute_name=None, value=None, delete=False):
        """
        This is a convenient wrapper for
        get_attribute, set_attribute, del_attribute
        and get_all_attributes.
        If value is None, attr will act like
        a getter, otherwise as a setter.
        set delete=True to delete the named attribute.

        Note that you cannot set the attribute
        value to None using this method. Use set_attribute.
        """
        logger.log_depmsg("obj.attr() is deprecated. Use handlers obj.db or obj.attributes.")
        if attribute_name is None:
            # act as a list method
            return _GA(self, "attributes").all()
        elif delete is True:
            _GA(self, "attributes").remove(attribute_name)
        elif value is None:
            # act as a getter.
            return _GA(self, "attributes").get(attribute_name)
        else:
            # act as a setter
            self._GA(self, "attributes").add(attribute_name, value)

    def secure_attr(self, accessing_object, attribute_name=None, value=None, delete=False,
                    default_access_read=True, default_access_edit=True, default_access_create=True):
        """
        This is a version of attr that requires the accessing object
        as input and will use that to check eventual access locks on
        the Attribute before allowing any changes or reads.

        In the cases when this method wouldn't return, it will return
        True for a successful operation, None otherwise.

        locktypes checked on the Attribute itself:
            attrread - control access to reading the attribute value
            attredit - control edit/delete access
        locktype checked on the object on which the Attribute is/will be stored:
            attrcreate - control attribute create access (this is checked *on the object*  not on the Attribute!)

        default_access_* defines which access is assumed if no
        suitable lock is defined on the Atttribute.

        """
        logger.log_depmsg("obj.secure_attr() is deprecated. Use obj.attributes methods, giving accessing_obj keyword.")
        if attribute_name is None:
            return _GA(self, "attributes").all(accessing_obj=accessing_object, default_access=default_access_read)
        elif delete is True:
            # act as deleter
            _GA(self, "attributes").remove(attribute_name, accessing_obj=accessing_object, default_access=default_access_edit)
        elif value is None:
            # act as getter
            return _GA(self, "attributes").get(attribute_name, accessing_obj=accessing_object, default_access=default_access_read)
        else:
            # act as setter
            attr = _GA(self, "attributes").get(attribute_name, return_obj=True)
            if attr:
               # attribute already exists
                _GA(self, "attributes").add(attribute_name, value, accessing_obj=accessing_object, default_access=default_access_edit)
            else:
                # creating a new attribute - check access on storing object!
                _GA(self, "attributes").add(attribute_name, value, accessing_obj=accessing_object, default_access=default_access_create)

    def nattr(self, attribute_name=None, value=None, delete=False):
        """
        This allows for assigning non-persistent data on the object using
        a method call. Will return None if trying to access a non-existing property.
        """
        logger.log_depmsg("obj.nattr() is deprecated. Use obj.nattributes instead.")
        if attribute_name is None:
            # act as a list method
            if callable(self.ndb.all):
                return self.ndb.all()
            else:
                return [val for val in self.ndb.__dict__.keys()
                        if not val.startswith['_']]
        elif delete is True:
            if hasattr(self.ndb, attribute_name):
                _DA(_GA(self, "ndb"), attribute_name)
        elif value is None:
            # act as a getter.
            if hasattr(self.ndb, attribute_name):
                _GA(_GA(self, "ndb"), attribute_name)
            else:
                return None
        else:
            # act as a setter
            _SA(self.ndb, attribute_name, value)




########NEW FILE########
__FILENAME__ = typeclass
"""
A typeclass is the companion of a TypedObject django model.
It 'decorates' the model without actually having to add new
fields to the model - transparently storing data onto its
associated model without the admin/user just having to deal
with a 'normal' Python class. The only restrictions is that
the typeclass must inherit from TypeClass and not reimplement
the get/setters defined below. There are also a few properties
that are protected, so as to not overwrite property names
used by the typesystem or django itself.
"""

from src.utils.logger import log_trace, log_errmsg

__all__ = ("TypeClass",)

# these are called so many times it's worth to avoid lookup calls
_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__

# To ensure the sanity of the model, there are a
# few property names we won't allow the admin to
# set on the typeclass just like that. Note that these are *not* related
# to *in-game* safety (if you can edit typeclasses you have
# full access anyway), so no protection against changing
# e.g. 'locks' or 'permissions' should go here.
PROTECTED = ('id', 'dbobj', 'db', 'ndb', 'objects', 'typeclass', 'db_player',
             'attr', 'save', 'delete', 'db_model_name','attribute_class',
             'typeclass_paths')


# If this is true, all non-protected property assignments
# are directly stored to a database attribute

class MetaTypeClass(type):
    """
    This metaclass just makes sure the class object gets
    printed in a nicer way (it might end up having no name at all
    otherwise due to the magics being done with get/setattribute).
    """
    def __init__(mcs, *args, **kwargs):
        """
        Adds some features to typeclassed objects
        """
        super(MetaTypeClass, mcs).__init__(*args, **kwargs)
        mcs.typename = mcs.__name__
        mcs.path = "%s.%s" % (mcs.__module__, mcs.__name__)

    def __str__(cls):
        return "%s" % cls.__name__


class TypeClass(object):
    """
    This class implements a 'typeclass' object. This is connected
    to a database object inheriting from TypedObject.
    the TypeClass allows for all customization.
    Most of the time this means that the admin never has to
    worry about database access but only deal with extending
    TypeClasses to create diverse objects in the game.

    The ObjectType class has all functionality for wrapping a
    database object transparently.

    It's up to its child classes to implement eventual custom hooks
    and other functions called by the engine.

    """
    __metaclass__ = MetaTypeClass

    def __init__(self, dbobj):
        """
        Initialize the object class. There are two ways to call this class.
        o = object_class(dbobj) : this is used to initialize dbobj with the
                                  class name
        o = dbobj.object_class(dbobj) : this is used when dbobj.object_class
                                        is already set.

        """
        # typecheck of dbobj - we can't allow it to be added here
        # unless it's really a TypedObject.
        dbobj_cls = _GA(dbobj, '__class__')
        dbobj_mro = _GA(dbobj_cls, '__mro__')
        if not any('src.typeclasses.models.TypedObject' in str(mro) for mro in dbobj_mro):
            raise Exception("dbobj is not a TypedObject: %s: %s" % (dbobj_cls, dbobj_mro))

        # we should always be able to use dbobj/typeclass to get back an object of the desired type
        _SA(self, 'dbobj', dbobj)
        _SA(self, 'typeclass', self)

    def __getattribute__(self, propname):
        """
        Change the normal property access to
        transparently include the properties on
        self.dbobj. Note that dbobj properties have
        priority, so if you define a same-named
        property on the class, it will NOT be
        accessible through getattr.
        """
        if propname.startswith('__') and propname.endswith('__'):
            # python specials are parsed as-is (otherwise things like
            # isinstance() fail to identify the typeclass)
            return _GA(self, propname)
        #print "get %s (dbobj:%s)" % (propname, type(dbobj))
        try:
            return _GA(self, propname)
        except AttributeError:
            try:
                dbobj = _GA(self, 'dbobj')
            except AttributeError:
                log_trace("Typeclass CRITICAL ERROR! dbobj not found for Typeclass %s!" % self)
                raise
            try:
                return _GA(dbobj, propname)
            except AttributeError:
                string = "Object: '%s' not found on %s(#%s), nor on its typeclass %s."
                raise AttributeError(string % (propname, dbobj, _GA(dbobj, "dbid"), _GA(dbobj, "typeclass_path")))

    def __setattr__(self, propname, value):
        """
        Transparently save data to the dbobj object in
        all situations. Note that this does not
        necessarily mean storing it to the database.
        """
        #print "set %s -> %s" % (propname, value)
        if propname in PROTECTED:
            string = "%s: '%s' is a protected attribute name."
            string += " (protected: [%s])" % (", ".join(PROTECTED))
            log_errmsg(string % (self.name, propname))
            return
        try:
            dbobj = _GA(self, 'dbobj')
        except AttributeError:
            dbobj = None
            log_trace("This is probably due to an unsafe reload.")
        if dbobj:
            _SA(dbobj, propname, value)
        else:
            # only as a last resort do we save on the typeclass object
            _SA(self, propname, value)

    def __eq__(self, other):
        """
        dbobj-recognized comparison
        """
        try:
            return _GA(_GA(self, "dbobj"), "dbid") == _GA(_GA(other, "dbobj"), "dbid")
        except AttributeError:
            return id(self) == id(other)

    def __delattr__(self, propname):
        """
        Transparently deletes data from the typeclass or dbobj by first
        searching on the typeclass, secondly on the dbobj.db.
        Will not allow deletion of properties stored directly on dbobj.
        """
        if propname in PROTECTED:
            string = "%s: '%s' is a protected attribute name."
            string += " (protected: [%s])" % (", ".join(PROTECTED))
            log_errmsg(string % (self.name, propname))
            return

        try:
            _DA(self, propname)
        except AttributeError:
            # not on typeclass, try to delete on db/ndb
            try:
                dbobj = _GA(self, 'dbobj')
            except AttributeError:
                log_trace("This is probably due to an unsafe reload.")
                return  # ignore delete
            try:
                dbobj.del_attribute(propname, raise_exception=True)
            except AttributeError:
                string = "Object: '%s' not found on %s(#%s), nor on its typeclass %s."
                raise AttributeError(string % (propname, dbobj,
                                               dbobj.dbid,
                                               dbobj.typeclass_path,))

    def __str__(self):
        "represent the object"
        return self.key

    def __unicode__(self):
        return u"%s" % self.key

########NEW FILE########
__FILENAME__ = ansi
"""
ANSI - Gives colour to text.

Use the codes defined in ANSIPARSER in your text
to apply colour to text according to the ANSI standard.

Examples:
 This is %crRed text%cn and this is normal again.
 This is {rRed text{n and this is normal again.

Mostly you should not need to call parse_ansi() explicitly;
it is run by Evennia just before returning data to/from the
user.

"""
import re
from src.utils import utils
from src.utils.utils import to_str, to_unicode

# ANSI definitions

ANSI_BEEP = "\07"
ANSI_ESCAPE = "\033"
ANSI_NORMAL = "\033[0m"

ANSI_UNDERLINE = "\033[4m"
ANSI_HILITE = "\033[1m"
ANSI_BLINK = "\033[5m"
ANSI_INVERSE = "\033[7m"
ANSI_INV_HILITE = "\033[1;7m"
ANSI_INV_BLINK = "\033[7;5m"
ANSI_BLINK_HILITE = "\033[1;5m"
ANSI_INV_BLINK_HILITE = "\033[1;5;7m"

# Foreground colors
ANSI_BLACK = "\033[30m"
ANSI_RED = "\033[31m"
ANSI_GREEN = "\033[32m"
ANSI_YELLOW = "\033[33m"
ANSI_BLUE = "\033[34m"
ANSI_MAGENTA = "\033[35m"
ANSI_CYAN = "\033[36m"
ANSI_WHITE = "\033[37m"

# Background colors
ANSI_BACK_BLACK = "\033[40m"
ANSI_BACK_RED = "\033[41m"
ANSI_BACK_GREEN = "\033[42m"
ANSI_BACK_YELLOW = "\033[43m"
ANSI_BACK_BLUE = "\033[44m"
ANSI_BACK_MAGENTA = "\033[45m"
ANSI_BACK_CYAN = "\033[46m"
ANSI_BACK_WHITE = "\033[47m"

# Formatting Characters
ANSI_RETURN = "\r\n"
ANSI_TAB = "\t"
ANSI_SPACE = " "

# Escapes
ANSI_ESCAPES = ("{{", "%%", "\\\\")

from collections import OrderedDict
_PARSE_CACHE = OrderedDict()
_PARSE_CACHE_SIZE = 10000


class ANSIParser(object):
    """
    A class that parses ansi markup
    to ANSI command sequences

    We also allow to escape colour codes
    by prepending with a \ for mux-style and xterm256,
    an extra { for Merc-style codes
    """

    def sub_ansi(self, ansimatch):
        """
        Replacer used by re.sub to replace ansi
        markers with correct ansi sequences
        """
        return self.ansi_map.get(ansimatch.group(), "")

    def sub_xterm256(self, rgbmatch):
        """
        This is a replacer method called by re.sub with the matched
        tag. It must return the correct ansi sequence.

        It checks self.do_xterm256 to determine if conversion
        to standard ansi should be done or not.
        """
        if not rgbmatch:
            return ""

        # get tag, stripping the initial marker
        rgbtag = rgbmatch.group()[1:]

        background = rgbtag[0] == '['
        if background:
            red, green, blue = int(rgbtag[1]), int(rgbtag[2]), int(rgbtag[3])
        else:
            red, green, blue = int(rgbtag[0]), int(rgbtag[1]), int(rgbtag[2])

        if self.do_xterm256:
            colval = 16 + (red * 36) + (green * 6) + blue
            #print "RGB colours:", red, green, blue
            return "\033[%s8;5;%s%s%sm" % (3 + int(background), colval/100, (colval % 100)/10, colval%10)
        else:
            #print "ANSI convert:", red, green, blue
            # xterm256 not supported, convert the rgb value to ansi instead
            if red == green and red == blue and red < 2:
                if background:
                    return ANSI_BACK_BLACK
                elif red >= 1:
                    return ANSI_HILITE + ANSI_BLACK
                else:
                    return ANSI_NORMAL + ANSI_BLACK
            elif red == green and red == blue:
                if background:
                    return ANSI_BACK_WHITE
                elif red >= 4:
                    return ANSI_HILITE + ANSI_WHITE
                else:
                    return ANSI_NORMAL + ANSI_WHITE
            elif red > green and red > blue:
                if background:
                    return ANSI_BACK_RED
                elif red >= 3:
                    return ANSI_HILITE + ANSI_RED
                else:
                    return ANSI_NORMAL + ANSI_RED
            elif red == green and red > blue:
                if background:
                    return ANSI_BACK_YELLOW
                elif red >= 3:
                    return ANSI_HILITE + ANSI_YELLOW
                else:
                    return ANSI_NORMAL + ANSI_YELLOW
            elif red == blue and red > green:
                if background:
                    return ANSI_BACK_MAGENTA
                elif red >= 3:
                    return ANSI_HILITE + ANSI_MAGENTA
                else:
                    return ANSI_NORMAL + ANSI_MAGENTA
            elif green > blue:
                if background:
                    return ANSI_BACK_GREEN
                elif green >= 3:
                    return ANSI_HILITE + ANSI_GREEN
                else:
                    return ANSI_NORMAL + ANSI_GREEN
            elif green == blue:
                if background:
                    return ANSI_BACK_CYAN
                elif green >= 3:
                    return ANSI_HILITE + ANSI_CYAN
                else:
                    return ANSI_NORMAL + ANSI_CYAN
            else:    # mostly blue
                if background:
                    return ANSI_BACK_BLUE
                elif blue >= 3:
                    return ANSI_HILITE + ANSI_BLUE
                else:
                    return ANSI_NORMAL + ANSI_BLUE

    def strip_raw_codes(self, string):
        """
        Strips raw ANSI codes from a string.
        """
        return self.ansi_regex.sub("", string)

    def parse_ansi(self, string, strip_ansi=False, xterm256=False):
        """
        Parses a string, subbing color codes according to
        the stored mapping.

        strip_ansi flag instead removes all ansi markup.

        """
        if hasattr(string, '_raw_string'):
            if strip_ansi:
                return string.clean()
            else:
                return string.raw()

        if not string:
            return ''

        # check cached parsings
        global _PARSE_CACHE
        cachekey = "%s-%s-%s" % (string, strip_ansi, xterm256)
        if cachekey in _PARSE_CACHE:
            return _PARSE_CACHE[cachekey]

        self.do_xterm256 = xterm256
        in_string = utils.to_str(string)

        # do string replacement
        parsed_string =  ""
        parts = self.ansi_escapes.split(in_string) + [" "]
        for part, sep in zip(parts[::2], parts[1::2]):
            pstring = self.xterm256_sub.sub(self.sub_xterm256, part)
            pstring = self.ansi_sub.sub(self.sub_ansi, pstring)
            parsed_string += "%s%s" % (pstring, sep[0].strip())

        if strip_ansi:
            # remove all ansi codes (including those manually
            # inserted in string)
            return self.strip_raw_codes(parsed_string)

         # cache and crop old cache
        _PARSE_CACHE[cachekey] = parsed_string
        if len(_PARSE_CACHE) > _PARSE_CACHE_SIZE:
           _PARSE_CACHE.popitem(last=False)

        return parsed_string
    # MUX-style mappings %cr %cn etc

    mux_ansi_map = [
        (r'%cn', ANSI_NORMAL),
        (r'%ch', ANSI_HILITE),
        (r'%r', ANSI_RETURN),
        (r'%t', ANSI_TAB),
        (r'%b', ANSI_SPACE),
        (r'%cf', ANSI_BLINK), # annoying and not supported by all clients
        (r'%ci', ANSI_INVERSE),

        (r'%cr', ANSI_RED),
        (r'%cg', ANSI_GREEN),
        (r'%cy', ANSI_YELLOW),
        (r'%cb', ANSI_BLUE),
        (r'%cm', ANSI_MAGENTA),
        (r'%cc', ANSI_CYAN),
        (r'%cw', ANSI_WHITE),
        (r'%cx', ANSI_BLACK),

        (r'%cR', ANSI_BACK_RED),
        (r'%cG', ANSI_BACK_GREEN),
        (r'%cY', ANSI_BACK_YELLOW),
        (r'%cB', ANSI_BACK_BLUE),
        (r'%cM', ANSI_BACK_MAGENTA),
        (r'%cC', ANSI_BACK_CYAN),
        (r'%cW', ANSI_BACK_WHITE),
        (r'%cX', ANSI_BACK_BLACK)
        ]

    # Expanded mapping {r {n etc

    hilite = ANSI_HILITE
    normal = ANSI_NORMAL

    ext_ansi_map = [
        (r'{n', normal),                # reset
        (r'{/', ANSI_RETURN),          # line break
        (r'{-', ANSI_TAB),             # tab
        (r'{_', ANSI_SPACE),           # space
        (r'{*', ANSI_INVERSE),        # invert
        (r'{^', ANSI_BLINK),          # blinking text (very annoying and not supported by all clients)

        (r'{r', hilite + ANSI_RED),
        (r'{g', hilite + ANSI_GREEN),
        (r'{y', hilite + ANSI_YELLOW),
        (r'{b', hilite + ANSI_BLUE),
        (r'{m', hilite + ANSI_MAGENTA),
        (r'{c', hilite + ANSI_CYAN),
        (r'{w', hilite + ANSI_WHITE),  # pure white
        (r'{x', hilite + ANSI_BLACK),  # dark grey

        (r'{R', normal + ANSI_RED),
        (r'{G', normal + ANSI_GREEN),
        (r'{Y', normal + ANSI_YELLOW),
        (r'{B', normal + ANSI_BLUE),
        (r'{M', normal + ANSI_MAGENTA),
        (r'{C', normal + ANSI_CYAN),
        (r'{W', normal + ANSI_WHITE),  # light grey
        (r'{X', normal + ANSI_BLACK),  # pure black

        (r'{[r', ANSI_BACK_RED),
        (r'{[g', ANSI_BACK_GREEN),
        (r'{[y', ANSI_BACK_YELLOW),
        (r'{[b', ANSI_BACK_BLUE),
        (r'{[m', ANSI_BACK_MAGENTA),
        (r'{[c', ANSI_BACK_CYAN),
        (r'{[w', ANSI_BACK_WHITE),    # light grey background
        (r'{[x', ANSI_BACK_BLACK)     # pure black background
        ]

    #ansi_map = mux_ansi_map + ext_ansi_map

    # xterm256 {123, %c134. These are replaced directly by
    # the sub_xterm256 method

    xterm256_map = [
        (r'%[0-5]{3}', ""),  # %123 - foreground colour
        (r'%\[[0-5]{3}', ""),  # %[123 - background colour
        (r'\{[0-5]{3}', ""),   # {123 - foreground colour
        (r'\{\[[0-5]{3}', "")   # {[123 - background colour
        ]

    # prepare regex matching
    #ansi_sub = [(re.compile(sub[0], re.DOTALL), sub[1])
    #                 for sub in ansi_map]
    xterm256_sub = re.compile(r"|".join([tup[0] for tup in xterm256_map]), re.DOTALL)
    ansi_sub = re.compile(r"|".join([re.escape(tup[0]) for tup in mux_ansi_map + ext_ansi_map]), re.DOTALL)

    # used by regex replacer to correctly map ansi sequences
    ansi_map = dict(mux_ansi_map + ext_ansi_map)

    # prepare matching ansi codes overall
    ansi_regex = re.compile("\033\[[0-9;]+m")

    # escapes - these double-chars will be replaced with a single
    # instance of each
    ansi_escapes = re.compile(r"(%s)" % "|".join(ANSI_ESCAPES), re.DOTALL)

ANSI_PARSER = ANSIParser()


#
# Access function
#

def parse_ansi(string, strip_ansi=False, parser=ANSI_PARSER, xterm256=False):
    """
    Parses a string, subbing color codes as needed.

    """
    return parser.parse_ansi(string, strip_ansi=strip_ansi, xterm256=xterm256)


def raw(string):
    """
    Escapes a string into a form which won't be colorized by the ansi parser.
    """
    return string.replace('{', '{{').replace('%', '%%')


def group(lst, n):
    for i in range(0, len(lst), n):
        val = lst[i:i+n]
        if len(val) == n:
            yield tuple(val)


def _spacing_preflight(func):
    """
    This wrapper function is used to do some preflight checks on functions used
    for padding ANSIStrings.
    """
    def wrapped(self, width, fillchar=None):
        if fillchar is None:
            fillchar = " "
        if (len(fillchar) != 1) or (not isinstance(fillchar, str)):
            raise TypeError("must be char, not %s" % type(fillchar))
        if not isinstance(width, int):
            raise TypeError("integer argument expected, got %s" % type(width))
        difference = width - len(self)
        if difference <= 0:
            return self
        return func(self, width, fillchar, difference)
    return wrapped


def _query_super(func_name):
    """
    Have the string class handle this with the cleaned string instead of
    ANSIString.
    """
    def wrapped(self, *args, **kwargs):
        return getattr(self.clean(), func_name)(*args, **kwargs)
    return wrapped


def _on_raw(func_name):
    """
    Like query_super, but makes the operation run on the raw string.
    """
    def wrapped(self, *args, **kwargs):
        args = list(args)
        try:
            string = args.pop(0)
            if hasattr(string, '_raw_string'):
                args.insert(0, string.raw())
            else:
                args.insert(0, string)
        except IndexError:
            pass
        result = getattr(self._raw_string, func_name)(*args, **kwargs)
        if isinstance(result, basestring):
            return ANSIString(result, decoded=True)
        return result
    return wrapped


def _transform(func_name):
    """
    Some string functions, like those manipulating capital letters,
    return a string the same length as the original. This function
    allows us to do the same, replacing all the non-coded characters
    with the resulting string.
    """
    def wrapped(self, *args, **kwargs):
        replacement_string = _query_super(func_name)(self, *args, **kwargs)
        to_string = []
        char_counter = 0
        for index in range(0, len(self._raw_string)):
            if index in self._code_indexes:
                to_string.append(self._raw_string[index])
            elif index in self._char_indexes:
                to_string.append(replacement_string[char_counter])
                char_counter += 1
        return ANSIString(''.join(to_string), decoded=True)
    return wrapped


class ANSIMeta(type):
    """
    Many functions on ANSIString are just light wrappers around the unicode
    base class. We apply them here, as part of the classes construction.
    """
    def __init__(cls, *args, **kwargs):
        for func_name in [
                'count', 'startswith', 'endswith', 'find', 'index', 'isalnum',
                'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper',
                'rfind', 'rindex', '__len__']:
            setattr(cls, func_name, _query_super(func_name))
        for func_name in [
                '__mul__', '__mod__', 'expandtabs', '__rmul__',
                'decode', 'replace', 'format', 'encode']:
            setattr(cls, func_name, _on_raw(func_name))
        for func_name in [
                'capitalize', 'translate', 'lower', 'upper', 'swapcase']:
            setattr(cls, func_name, _transform(func_name))
        super(ANSIMeta, cls).__init__(*args, **kwargs)


class ANSIString(unicode):
    """
    String-like object that is aware of ANSI codes.

    This isn't especially efficient, as it doesn't really have an
    understanding of what the codes mean in order to eliminate
    redundant characters. This could be made as an enhancement to ANSI_PARSER.

    If one is going to use ANSIString, one should generally avoid converting
    away from it until one is about to send information on the wire. This is
    because escape sequences in the string may otherwise already be decoded,
    and taken literally the second time around.

    Please refer to the Metaclass, ANSIMeta, which is used to apply wrappers
    for several of the methods that need not be defined directly here.
    """
    __metaclass__ = ANSIMeta

    def __new__(cls, *args, **kwargs):
        """
        When creating a new ANSIString, you may use a custom parser that has
        the same attributes as the standard one, and you may declare the
        string to be handled as already decoded. It is important not to double
        decode strings, as escapes can only be respected once.
        """
        string = args[0]
        if not isinstance(string, basestring):
            string = to_str(string, force_string=True)
        parser = kwargs.get('parser', ANSI_PARSER)
        decoded = kwargs.get('decoded', False) or hasattr(string, '_raw_string')
        if not decoded:
            # Completely new ANSI String
            clean_string = to_unicode(parser.parse_ansi(string, strip_ansi=True))
            string = parser.parse_ansi(string)
        elif hasattr(string, '_clean_string'):
            # It's already an ANSIString
            clean_string = string._clean_string
            string = string._raw_string
        else:
            # It's a string that has been pre-ansi decoded.
            clean_string = parser.strip_raw_codes(string)

        if not isinstance(string, unicode):
            string = string.decode('utf-8')
        else:
            # Do this to prevent recursive ANSIStrings.
            string = unicode(string)
        ansi_string = super(ANSIString, cls).__new__(ANSIString, to_str(clean_string), "utf-8")
        ansi_string._raw_string = string
        ansi_string._clean_string = clean_string
        return ansi_string

    def __str__(self):
        return self._raw_string.encode('utf-8')

    def __unicode__(self):
        """
        Unfortunately, this is not called during print() statements due to a
        bug in the Python interpreter. You can always do unicode() or str()
        around the resulting ANSIString and print that.
        """
        return self._raw_string

    def __repr__(self):
        """
        Let's make the repr the command that would actually be used to
        construct this object, for convenience and reference.
        """
        return "ANSIString(%s, decoded=True)" % repr(self._raw_string)

    def __init__(self, *_, **kwargs):
        """
        When the ANSIString is first initialized, a few internal variables
        have to be set.

        The first is the parser. It is possible to replace Evennia's standard
        ANSI parser with one of your own syntax if you wish, so long as it
        implements the same interface.

        The second is the _raw_string. It should be noted that the ANSIStrings
        are unicode based. This seemed more reasonable than basing it off of
        the string class, because if someone were to use a unicode character,
        the benefits of knowing the indexes of the ANSI characters would be
        negated by the fact that a character within the string might require
        more than one byte to be represented. The raw string is, then, a
        unicode object rather than a true encoded string. If you need the
        encoded string for sending over the wire, try using the .encode()
        method.

        The third thing to set is the _clean_string. This is a unicode object
        that is devoid of all ANSI Escapes.

        Finally, _code_indexes and _char_indexes are defined. These are lookup
        tables for which characters in the raw string are related to ANSI
        escapes, and which are for the readable text.
        """
        self.parser = kwargs.pop('parser', ANSI_PARSER)
        super(ANSIString, self).__init__()
        self._code_indexes, self._char_indexes = self._get_indexes()

    def __add__(self, other):
        """
        We have to be careful when adding two strings not to reprocess things
        that don't need to be reprocessed, lest we end up with escapes being
        interpreted literally.
        """
        if not isinstance(other, basestring):
            return NotImplemented
        return ANSIString(self._raw_string + getattr(
            other, '_raw_string', other), decoded=True)

    def __radd__(self, other):
        """
        Likewise, if we're on the other end.
        """
        if not isinstance(other, basestring):
            return NotImplemented
        return ANSIString(getattr(
            other, '_raw_string', other) + self._raw_string, decoded=True)

    def __getslice__(self, i, j):
        """
        This function is deprecated, so we just make it call the proper
        function.
        """
        return self.__getitem__(slice(i, j))

    def _slice(self, slc):
        """
        This function takes a slice() object.

        Slices have to be handled specially. Not only are they able to specify
        a start and end with [x:y], but many forget that they can also specify
        an interval with [x:y:z]. As a result, not only do we have to track
        the ANSI Escapes that have played before the start of the slice, we
        must also replay any in these intervals, should the exist.

        Thankfully, slicing the _char_indexes table gives us the actual
        indexes that need slicing in the raw string. We can check between
        those indexes to figure out what escape characters need to be
        replayed.
        """
        slice_indexes = self._char_indexes[slc]
        # If it's the end of the string, we need to append final color codes.
        if not slice_indexes:
            return ANSIString('')
        try:
            string = self[slc.start]._raw_string
        except IndexError:
            return ANSIString('')
        last_mark = slice_indexes[0]
        # Check between the slice intervals for escape sequences.
        i = None
        for i in slice_indexes[1:]:
            for index in range(last_mark, i):
                if index in self._code_indexes:
                    string += self._raw_string[index]
            last_mark = i
            try:
                string += self._raw_string[i]
            except IndexError:
                pass
        if i is not None:
            append_tail = self._get_interleving(self._char_indexes.index(i) + 1)
        else:
            append_tail = ''
        return ANSIString(string + append_tail, decoded=True)

    def __getitem__(self, item):
        """
        Gateway for slices and getting specific indexes in the ANSIString. If
        this is a regexable ANSIString, it will get the data from the raw
        string instead, bypassing ANSIString's intelligent escape skipping,
        for reasons explained in the __new__ method's docstring.
        """
        if isinstance(item, slice):
            # Slices must be handled specially.
            return self._slice(item)
        try:
            self._char_indexes[item]
        except IndexError:
            raise IndexError("ANSIString Index out of range")
        # Get character codes after the index as well.
        if self._char_indexes[-1] == self._char_indexes[item]:
            append_tail = self._get_interleving(item + 1)
        else:
            append_tail = ''
        item = self._char_indexes[item]

        clean = self._raw_string[item]
        result = ''
        # Get the character they're after, and replay all escape sequences
        # previous to it.
        for index in range(0, item + 1):
            if index in self._code_indexes:
                result += self._raw_string[index]
        return ANSIString(result + clean + append_tail, decoded=True)

    def clean(self):
        """
        Return a unicode object without the ANSI escapes.
        """
        return self._clean_string

    def raw(self):
        """
        Return a unicode object with the ANSI escapes.
        """
        return self._raw_string

    def partition(self, sep, reverse=False):
        """
        Similar to split, but always creates a tuple with three items:
        1. The part before the separator
        2. The separator itself.
        3. The part after.

        We use the same techniques we used in split() to make sure each are
        colored.
        """
        if hasattr(sep, '_clean_string'):
            sep = sep.clean()
        if reverse:
            parent_result = self._clean_string.rpartition(sep)
        else:
            parent_result = self._clean_string.partition(sep)
        current_index = 0
        result = tuple()
        for section in parent_result:
            result += (self[current_index:current_index + len(section)],)
            current_index += len(section)
        return result

    def _get_indexes(self):
        """
        Two tables need to be made, one which contains the indexes of all
        readable characters, and one which contains the indexes of all ANSI
        escapes. It's important to remember that ANSI escapes require more
        that one character at a time, though no readable character needs more
        than one character, since the unicode base class abstracts that away
        from us. However, several readable characters can be placed in a row.

        We must use regexes here to figure out where all the escape sequences
        are hiding in the string. Then we use the ranges of their starts and
        ends to create a final, comprehensive list of all indexes which are
        dedicated to code, and all dedicated to text.

        It's possible that only one of these tables is actually needed, the
        other assumed to be what isn't in the first.
        """
        # These are all the indexes which hold code characters.
        #matches = [(match.start(), match.end())
        #            for match in self.parser.ansi_regex.finditer(self._raw_string)]
        #code_indexes = []
        #         # These are all the indexes which hold code characters.
        #for start, end in matches:
        #    code_indexes.extend(range(start, end))

        code_indexes = []
        for match in self.parser.ansi_regex.finditer(self._raw_string):
            code_indexes.extend(range(match.start(), match.end()))
        if not code_indexes:
            # Plain string, no ANSI codes.
            return code_indexes, range(0, len(self._raw_string))
        # all indexes not occupied by ansi codes are normal characters
        char_indexes = [i for i in range(len(self._raw_string)) if i not in code_indexes]
        return code_indexes, char_indexes

    def _get_interleving(self, index):
        """
        Get the code characters from the given slice end to the next
        character.
        """
        try:
            index = self._char_indexes[index - 1]
        except IndexError:
            return ''
        s = ''
        while True:
            index += 1
            if index in self._char_indexes:
                break
            elif index in self._code_indexes:
                s += self._raw_string[index]
            else:
                break
        return s

    def split(self, by, maxsplit=-1):
        """
        Stolen from PyPy's pure Python string implementation, tweaked for
        ANSIString.

        PyPy is distributed under the MIT licence.
        http://opensource.org/licenses/MIT
        """
        bylen = len(by)
        if bylen == 0:
            raise ValueError("empty separator")

        res = []
        start = 0
        while maxsplit != 0:
            next = self._clean_string.find(by, start)
            if next < 0:
                break
            # Get character codes after the index as well.
            res.append(self[start:next])
            start = next + bylen
            maxsplit -= 1   # NB. if it's already < 0, it stays < 0

        res.append(self[start:len(self)])
        return res

    def rsplit(self, by, maxsplit=-1):
        """
        Stolen from PyPy's pure Python string implementation, tweaked for
        ANSIString.

        PyPy is distributed under the MIT licence.
        http://opensource.org/licenses/MIT
        """
        res = []
        end = len(self)
        bylen = len(by)
        if bylen == 0:
            raise ValueError("empty separator")

        while maxsplit != 0:
            next = self._clean_string.rfind(by, 0, end)
            if next < 0:
                break
            # Get character codes after the index as well.
            res.append(self[next+bylen:end])
            end = next
            maxsplit -= 1   # NB. if it's already < 0, it stays < 0

        res.append(self[:end])
        res.reverse()
        return res

    def join(self, iterable):
        """
        Joins together strings in an iterable.
        """
        result = ANSIString('')
        last_item = None
        for item in iterable:
            if last_item is not None:
                result += self
            result += item
            last_item = item
        return result


    @_spacing_preflight
    def center(self, width, fillchar, difference):
        """
        Center some text with some spaces padding both sides.
        """
        remainder = difference % 2
        difference /= 2
        spacing = difference * fillchar
        result = spacing + self + spacing + (remainder * fillchar)
        return result

    @_spacing_preflight
    def ljust(self, width, fillchar, difference):
        """
        Left justify some text.
        """
        return self + (difference * fillchar)

    @_spacing_preflight
    def rjust(self, width, fillchar, difference):
        """
        Right justify some text.
        """
        return (difference * fillchar) + self

########NEW FILE########
__FILENAME__ = batchprocessors
"""
This file contains the core methods for the Batch-command- and
Batch-code-processors respectively. In short, these are two different
ways to build a game world using a normal text-editor without having
to do so 'on the fly' in-game. They also serve as an automatic backup
so you can quickly recreate a world also after a server reset. The
functions in this module is meant to form the backbone of a system
called and accessed through game commands.

The Batch-command processor is the simplest. It simply runs a list of
in-game commands in sequence by reading them from a text file. The
advantage of this is that the builder only need to remember the normal
in-game commands. They are also executing with full permission checks
etc, making it relatively safe for builders to use. The drawback is
that in-game there is really a builder-character walking around
building things, and it can be important to create rooms and objects
in the right order, so the character can move between them. Also
objects that affects players (such as mobs, dark rooms etc) will
affect the building character too, requiring extra care to turn
off/on.

The Batch-code processor is a more advanced system that accepts full
Python code, executing in chunks. The advantage of this is much more
power; practically anything imaginable can be coded and handled using
the batch-code processor. There is no in-game character that moves and
that can be affected by what is being built - the database is
populated on the fly. The drawback is safety and entry threshold - the
code is executed as would any server code, without mud-specific
permission checks and you have full access to modifying objects
etc. You also need to know Python and Evennia's API. Hence it's
recommended that the batch-code processor is limited only to
superusers or highly trusted staff.


=======================================================================

Batch-command processor file syntax

The batch-command processor accepts 'batchcommand files' e.g
'batch.ev', containing a sequence of valid evennia commands in a
simple format. The engine runs each command in sequence, as if they
had been run at the game prompt.

Each evennia command must be delimited by a line comment to mark its
end.

#INSERT path.batchcmdfile - this as the first entry on a line will
      import and run a batch.ev file in this position, as if it was
      written in this file.

This way entire game worlds can be created and planned offline; it is
especially useful in order to create long room descriptions where a
real offline text editor is often much better than any online text
editor or prompt.

Example of batch.ev file:
----------------------------

# batch file
# all lines starting with # are comments; they also indicate
# that a command definition is over.

@create box

# this comment ends the @create command.

@set box/desc = A large box.

Inside are some scattered piles of clothing.


It seems the bottom of the box is a bit loose.

# Again, this comment indicates the @set command is over. Note how
# the description could be freely added. Excess whitespace on a line
# is ignored.  An empty line in the command definition is parsed as a \n
# (so two empty lines becomes a new paragraph).

@teleport #221

# (Assuming #221 is a warehouse or something.)
# (remember, this comment ends the @teleport command! Don'f forget it)

# Example of importing another file at this point.
#IMPORT examples.batch

@drop box

# Done, the box is in the warehouse! (this last comment is not necessary to
# close the @drop command since it's the end of the file)
-------------------------

An example batch file is game/gamesrc/commands/examples/batch_example.ev.


==========================================================================


Batch-code processor file syntax

The Batch-code processor accepts full python modules (e.g. "batch.py")
that looks identical to normal Python files with a few exceptions that
allows them to the executed in blocks. This way of working assures a
sequential execution of the file and allows for features like stepping
from block to block (without executing those coming before), as well
as automatic deletion of created objects etc. You can however also run
a batch-code python file directly using Python (and can also be de).

Code blocks are separated by python comments starting with special
code words.

#HEADER - this denotes commands global to the entire file, such as
          import statements and global variables. They will
          automatically be pasted at the top of all code
          blocks. Observe that changes to these variables made in one
          block is not preserved between blocks!
#CODE
#CODE (info)
#CODE (info) objname1, objname1, ... -
           This designates a code block that will be executed like a
           stand-alone piece of code together with any #HEADER
           defined. (info) text is used by the interactive mode to
           display info about the node to run.  <objname>s mark the
           (variable-)names of objects created in the code, and which
           may be auto-deleted by the processor if desired (such as
           when debugging the script). E.g., if the code contains the
           command myobj = create.create_object(...), you could put
           'myobj' in the #CODE header regardless of what the created
           object is actually called in-game.
#INSERT path.filename - This imports another batch_code.py file and
          runs it in the given position.  paths are given as python
          path. The inserted file will retain its own HEADERs which
          will not be mixed with the HEADERs of the file importing
          this file.

The following variables are automatically made available for the script:

caller - the object executing the script

Example batch.py file
-----------------------------------

#HEADER

import traceback
from django.config import settings
from src.utils import create
from game.gamesrc.typeclasses import basetypes

GOLD = 10

#CODE obj, obj2

obj = create.create_object(basetypes.Object)
obj2 = create.create_object(basetypes.Object)
obj.location = caller.location
obj.db.gold = GOLD
caller.msg("The object was created!")

#INSERT another_batch_file

#CODE

script = create.create_script()

"""

import re
import codecs
import traceback
import sys
#from traceback import format_exc
from django.conf import settings
from src.utils import logger
from src.utils import utils
#from game import settings as settings_module

ENCODINGS = settings.ENCODINGS
CODE_INFO_HEADER = re.compile(r"\(.*?\)")


#------------------------------------------------------------
# Helper function
#------------------------------------------------------------

def read_batchfile(pythonpath, file_ending='.py'):
    """
    This reads the contents of a batch-file.
    Filename is considered to be a python path to a batch file
    relative the directory specified in settings.py.

    file_ending specify which batchfile ending should be
    assumed (.ev or .py). The ending should not be included
    in the python path.
    """

    # open the file
    if pythonpath and not (pythonpath.startswith('src.') or pythonpath.startswith('game.')
                           or pythonpath.startswith('contrib.')):
        abspaths = []
        for basepath in settings.BASE_BATCHPROCESS_PATHS:
            abspaths.append(utils.pypath_to_realpath("%s.%s" % (basepath, pythonpath), file_ending))
    else:
        abspaths = [utils.pypath_to_realpath(pythonpath, file_ending)]
    text, fobj  = None, None
    fileerr, decoderr = [], []
    for abspath in abspaths:
        # try different paths, until we get a match
        # we read the file directly into unicode.
        for file_encoding in ENCODINGS:
            # try different encodings, in order
            try:
                fobj = codecs.open(abspath, 'r', encoding=file_encoding)
                text = fobj.read()
            except IOError, e:
                # could not find the file
                fileerr.append(str(e))
                break
            except (ValueError, UnicodeDecodeError), e:
                # this means an encoding error; try another encoding
                decoderr.append(str(e))
                continue
            break
    if not fobj:
        raise IOError("\n".join(fileerr))
    if not text:
        raise UnicodeDecodeError("\n".join(decoderr))

    return text


#------------------------------------------------------------
#
# Batch-command processor
#
#------------------------------------------------------------

class BatchCommandProcessor(object):
    """
    This class implements a batch-command processor.

    """
    def parse_file(self, pythonpath):
        """
        This parses the lines of a batchfile according to the following
        rules:
          1) # at the beginning of a line marks the end of the command before
               it. It is also a comment and any number of # can exist on
               subsequent lines (but not inside comments).
          2) #INSERT at the beginning of a line imports another
             batch-cmd file file and pastes it into the batch file as if
             it was written there.
          3) Commands are placed alone at the beginning of a line and their
             arguments are considered to be everything following (on any
             number of lines) until the next comment line beginning with #.
          4) Newlines are ignored in command definitions
          5) A completely empty line in a command line definition is condered
             a newline (so two empty lines is a paragraph).
          6) Excess spaces and indents inside arguments are stripped.

        """

        text = "".join(read_batchfile(pythonpath, file_ending='.ev'))

        def replace_insert(match):
            "Map replace entries"
            return "\#\n".join(self.parse_file(match.group()))

        # insert commands from inserted files
        text = re.sub(r"^\#INSERT (.*?)", replace_insert, text, flags=re.MULTILINE)
        # get all commands
        commands = re.split(r"^\#.*?$", text, flags=re.MULTILINE)
        #remove eventual newline at the end of commands
        commands = [c.strip('\r\n') for c in commands]
        commands = [c for c in commands if c]

        return commands


#------------------------------------------------------------
#
# Batch-code processor
#
#------------------------------------------------------------

def tb_filename(tb):
    "Helper to get filename from traceback"
    return tb.tb_frame.f_code.co_filename


def tb_iter(tb):
    while tb is not None:
        yield tb
        tb = tb.tb_next


class BatchCodeProcessor(object):
    """
    This implements a batch-code processor

    """

    def parse_file(self, pythonpath, debug=False):
        """
        This parses the lines of a batchfile according to the following
        rules:

        1) Lines starting with #HEADER starts a header block (ends other blocks)
        2) Lines starting with #CODE begins a code block (ends other blocks)
        3) #CODE headers may be of the following form:
                              #CODE (info) objname, objname2, ...
        4) Lines starting with #INSERT are on form #INSERT filename.
        3) All lines outside blocks are stripped.
        4) All excess whitespace beginning/ending a block is stripped.

        """

        text = "".join(read_batchfile(pythonpath, file_ending='.py'))

        def clean_block(text):
            text = re.sub(r"^\#.*?$|^\s*$", "", text, flags=re.MULTILINE)
            return "\n".join([line for line in text.split("\n") if line])

        def replace_insert(match):
            "Map replace entries"
            return "\#\n".join(self.parse_file(match.group()))

        text = re.sub(r"^\#INSERT (.*?)", replace_insert, text, flags=re.MULTILINE)
        blocks = re.split(r"(^\#CODE.*?$|^\#HEADER)$", text, flags=re.MULTILINE)
        headers = []
        codes = [] # list of tuples (code, info, objtuple)
        if blocks:
            if blocks[0]:
                # the first block is either empty or an unmarked code block
                code = clean_block(blocks.pop(0))
                if code:
                    codes.append((code, ""))
            iblock = 0
            for block in blocks[::2]:
                # loop over every second component; these are the #CODE/#HEADERs
                if block.startswith("#HEADER"):
                    headers.append(clean_block(blocks[iblock + 1]))
                elif block.startswith("#CODE"):
                    match = re.search(r"\(.*?\)", block)
                    info = match.group() if match else ""
                    objs = []
                    if debug:
                        # insert auto-delete lines into code
                        objs = block[match.end():].split(",")
                        objs = ["# added by Evennia's debug mode\n%s.delete()" % obj.strip() for obj in objs if obj]
                    # build the code block
                    code = "\n".join([clean_block(blocks[iblock + 1])] + objs)
                    if code:
                        codes.append((code, info))
                iblock += 2

        # join the headers together to one header
        headers = "\n".join(headers)
        if codes:
            # add the headers at the top of each non-empty block
            codes = ["%s\n%s\n%s" % ("#CODE %s: " % tup[1], headers, tup[0]) for tup in codes if tup[0]]
        else:
            codes = ["#CODE: \n" + headers]
        return codes


    def code_exec(self, code, extra_environ=None, debug=False):
        """
        Execute a single code block, including imports and appending global vars

        extra_environ - dict with environment variables
        """
        # define the execution environment
        environdict = {"settings_module": settings}
        environ = "settings_module.configure()"
        if extra_environ:
            for key, value in extra_environ.items():
                environdict[key] = value

        # initializing the django settings at the top of code
        code = "# auto-added by Evennia\n" \
               "try: %s\n" \
               "except RuntimeError: pass\n" \
               "finally: del settings_module\n%s" % (environ, code)

        # execute the block
        try:
            exec(code, environdict)
        except Exception:
            etype, value, tb = sys.exc_info()

            fname = tb_filename(tb)
            for tb in tb_iter(tb):
                if fname != tb_filename(tb):
                    break
            lineno = tb.tb_lineno - 1
            err = ""
            for iline, line in enumerate(code.split("\n")):
                if iline == lineno:
                    err += "\n{w%02i{n: %s" % (iline + 1, line)
                elif lineno - 5 < iline < lineno + 5:
                    err += "\n%02i: %s" % (iline + 1, line)

            err += "\n".join(traceback.format_exception(etype, value, tb))
            return err
        return None

BATCHCMD = BatchCommandProcessor()
BATCHCODE = BatchCodeProcessor()

########NEW FILE########
__FILENAME__ = create
"""
This module gathers all the essential database-creation
functions for the game engine's various object types.

Only objects created 'stand-alone' are in here, e.g. object Attributes
are always created directly through their respective objects.

Each creation_* function also has an alias named for the entity being
created, such as create_object() and object().  This is for
consistency with the utils.search module and allows you to do the
shorter "create.object()".

The respective object managers hold more methods for manipulating and
searching objects already existing in the database.

Models covered:
 Objects
 Scripts
 Help
 Message
 Channel
 Players
"""
from django.conf import settings
from django.db import IntegrityError
from src.utils.idmapper.models import SharedMemoryModel
from src.utils import utils, logger
from src.utils.utils import make_iter

# delayed imports
_User = None
_Object = None
_ObjectDB = None
_Script = None
_ScriptDB = None
_HelpEntry = None
_Msg = None
_Player = None
_PlayerDB = None
_to_object = None
_ChannelDB = None
_channelhandler = None
_Tag = None


# limit symbol import from API
__all__ = ("create_object", "create_script", "create_help_entry",
           "create_message", "create_channel", "create_player")

_GA = object.__getattribute__

# Helper function

def handle_dbref(inp, objclass, raise_errors=True):
    """
    Convert a #dbid to a valid object of objclass. objclass
    should be a valid object class to filter against (objclass.filter ...)
    If not raise_errors is set, this will swallow errors of non-existing
    objects.
    """
    if not (isinstance(inp, basestring) and inp.startswith("#")):
        return inp
    inp = inp.lstrip('#')
    try:
        if int(inp) < 0:
            return None
    except ValueError:
        return None

    # if we get to this point, inp is an integer dbref
    try:
        return objclass.objects.get(id=inp)
    except Exception:
        if raise_errors:
            raise
        return inp

#
# Game Object creation
#

def create_object(typeclass=None, key=None, location=None,
                  home=None, permissions=None, locks=None,
                  aliases=None, destination=None, report_to=None, nohome=False):
    """
    Create a new in-game object. Any game object is a combination
    of a database object that stores data persistently to
    the database, and a typeclass, which on-the-fly 'decorates'
    the database object into whataver different type of object
    it is supposed to be in the game.

    See src.objects.managers for methods to manipulate existing objects
    in the database. src.objects.objects holds the base typeclasses
    and src.objects.models hold the database model.

    report_to is an optional object for reporting errors to in string form.
              If report_to is not set, errors will be raised as en Exception
              containing the error message. If set, this method will return
              None upon errors.
    nohome - this allows the creation of objects without a default home location;
             this only used when creating default location itself or during unittests
    """
    global _Object, _ObjectDB
    if not _Object:
        from src.objects.objects import Object as _Object
    if not _ObjectDB:
        from src.objects.models import ObjectDB as _ObjectDB

    # input validation

    if not typeclass:
        typeclass = settings.BASE_OBJECT_TYPECLASS
    elif isinstance(typeclass, _ObjectDB):
        # this is already an objectdb instance, extract its typeclass
        typeclass = typeclass.typeclass.path
    elif isinstance(typeclass, _Object) or utils.inherits_from(typeclass, _Object):
        # this is already an object typeclass, extract its path
        typeclass = typeclass.path

    # handle eventual #dbref input
    location = handle_dbref(location, _ObjectDB)
    home = handle_dbref(home, _ObjectDB)
    destination = handle_dbref(destination, _ObjectDB)
    report_to = handle_dbref(report_to, _ObjectDB)

    # create new database object
    new_db_object = _ObjectDB()

    # assign the typeclass
    typeclass = utils.to_unicode(typeclass)
    new_db_object.typeclass_path = typeclass

    # the name/key is often set later in the typeclass. This
    # is set here as a failsafe.
    if key:
        new_db_object.key = key
    else:
        new_db_object.key = "#%i" % new_db_object.dbid

    # this will either load the typeclass or the default one
    new_object = new_db_object.typeclass

    if not _GA(new_object, "is_typeclass")(typeclass, exact=True):
        # this will fail if we gave a typeclass as input and it still
        # gave us a default
        SharedMemoryModel.delete(new_db_object)
        if report_to:
            _GA(report_to, "msg")("Error creating %s (%s):\n%s" % (new_db_object.key, typeclass,
                                                                 _GA(new_db_object, "typeclass_last_errmsg")))
            return None
        else:
            raise Exception(_GA(new_db_object, "typeclass_last_errmsg"))

    # from now on we can use the typeclass object
    # as if it was the database object.

    new_object.destination = destination

    # call the hook method. This is where all at_creation
    # customization happens as the typeclass stores custom
    # things on its database object.
    new_object.basetype_setup()  # setup the basics of Exits, Characters etc.
    new_object.at_object_creation()

    # custom-given perms/locks overwrite hooks
    if permissions:
        new_object.permissions.add(permissions)
    if locks:
        new_object.locks.add(locks)
    if aliases:
        new_object.aliases.add(aliases)

    if home:
        new_object.home = home
    else:
        # we shouldn't need to handle dbref here (home handler should fix it), but some have
        # reported issues here (issue 446).
        try:
            new_object.home = handle_dbref(settings.DEFAULT_HOME, _ObjectDB) if not nohome else None
        except _ObjectDB.DoesNotExist:
            raise _ObjectDB.DoesNotExist("settings.DEFAULT_HOME (= '%s') does not exist, or the setting is malformed." %
                                         settings.DEFAULT_HOME)

    # perform a move_to in order to display eventual messages.
    if location:
        new_object.move_to(location, quiet=True)
    else:
        # rooms would have location=None.
        new_object.location = None

    # post-hook setup (mainly used by Exits)
    new_object.basetype_posthook_setup()

    new_object.save()
    return new_object

#alias for create_object
object = create_object


#
# Script creation
#

def create_script(typeclass, key=None, obj=None, player=None, locks=None,
                  interval=None, start_delay=None, repeats=None,
                  persistent=None, autostart=True, report_to=None):
    """
    Create a new script. All scripts are a combination
    of a database object that communicates with the
    database, and an typeclass that 'decorates' the
    database object into being different types of scripts.
    It's behaviour is similar to the game objects except
    scripts has a time component and are more limited in
    scope.

    Argument 'typeclass' can be either an actual
    typeclass object or a python path to such an object.
    Only set key here if you want a unique name for this
    particular script (set it in config to give
    same key to all scripts of the same type). Set obj
    to tie this script to a particular object.

    See src.scripts.manager for methods to manipulate existing
    scripts in the database.

    report_to is an obtional object to receive error messages.
              If report_to is not set, an Exception with the
              error will be raised. If set, this method will
              return None upon errors.
    """
    global _Script, _ScriptDB
    if not _Script:
        from src.scripts.scripts import Script as _Script
    if not _ScriptDB:
        from src.scripts.models import ScriptDB as _ScriptDB

    if not typeclass:
        typeclass = settings.BASE_SCRIPT_TYPECLASS
    elif isinstance(typeclass, _ScriptDB):
        # this is already an scriptdb instance, extract its typeclass
        typeclass = typeclass.typeclass.path
    elif isinstance(typeclass, _Script) or utils.inherits_from(typeclass, _Script):
        # this is already an object typeclass, extract its path
        typeclass = typeclass.path

    # create new database script
    new_db_script = _ScriptDB()

    # assign the typeclass
    typeclass = utils.to_unicode(typeclass)
    new_db_script.typeclass_path = typeclass

    # the name/key is often set later in the typeclass. This
    # is set here as a failsafe.
    if key:
        new_db_script.key = key
    else:
        new_db_script.key = "#%i" % new_db_script.id

    # this will either load the typeclass or the default one
    new_script = new_db_script.typeclass

    if not _GA(new_db_script, "is_typeclass")(typeclass, exact=True):
        # this will fail if we gave a typeclass as input and it still
        # gave us a default
        SharedMemoryModel.delete(new_db_script)
        if report_to:
            _GA(report_to, "msg")("Error creating %s (%s): %s" % (new_db_script.key, typeclass,
                                                                 _GA(new_db_script, "typeclass_last_errmsg")))
            return None
        else:
            raise Exception(_GA(new_db_script, "typeclass_last_errmsg"))

    if obj:
        new_script.obj = obj
    if player:
        new_script.player = player

    # call the hook method. This is where all at_creation
    # customization happens as the typeclass stores custom
    # things on its database object.
    new_script.at_script_creation()

    # custom-given variables override the hook
    if key:
        new_script.key = key
    if locks:
        new_script.locks.add(locks)
    if interval is not None:
        new_script.interval = interval
    if start_delay is not None:
        new_script.start_delay = start_delay
    if repeats is not None:
        new_script.repeats = repeats
    if persistent is not None:
        new_script.persistent = persistent

    # a new created script should usually be started.
    if autostart:
        new_script.start()

    new_db_script.save()
    return new_script
#alias
script = create_script


#
# Help entry creation
#

def create_help_entry(key, entrytext, category="General", locks=None):
    """
    Create a static help entry in the help database. Note that Command
    help entries are dynamic and directly taken from the __doc__ entries
    of the command. The database-stored help entries are intended for more
    general help on the game, more extensive info, in-game setting information
    and so on.
    """
    global _HelpEntry
    if not _HelpEntry:
        from src.help.models import HelpEntry as _HelpEntry

    try:
        new_help = _HelpEntry()
        new_help.key = key
        new_help.entrytext = entrytext
        new_help.help_category = category
        if locks:
            new_help.locks.add(locks)
        new_help.save()
        return new_help
    except IntegrityError:
        string = "Could not add help entry: key '%s' already exists." % key
        logger.log_errmsg(string)
        return None
    except Exception:
        logger.log_trace()
        return None
# alias
help_entry = create_help_entry


#
# Comm system methods
#

def create_message(senderobj, message, channels=None,
                   receivers=None, locks=None, header=None):
    """
    Create a new communication message. Msgs are used for all
    player-to-player communication, both between individual players
    and over channels.
    senderobj - the player sending the message. This must be the actual object.
    message - text with the message. Eventual headers, titles etc
              should all be included in this text string. Formatting
              will be retained.
    channels - a channel or a list of channels to send to. The channels
             may be actual channel objects or their unique key strings.
    receivers - a player to send to, or a list of them. May be Player objects
               or playernames.
    locks - lock definition string
    header - mime-type or other optional information for the message

    The Comm system is created very open-ended, so it's fully possible
    to let a message both go to several channels and to several receivers
    at the same time, it's up to the command definitions to limit this as
    desired.
    """
    global _Msg
    if not _Msg:
        from src.comms.models import Msg as _Msg
    if not message:
        # we don't allow empty messages.
        return
    new_message = _Msg(db_message=message)
    new_message.save()
    for sender in make_iter(senderobj):
        new_message.senders = sender
    new_message.header = header
    for channel in make_iter(channels):
        new_message.channels = channel
    for receiver in make_iter(receivers):
        new_message.receivers = receiver
    if locks:
        new_message.locks.add(locks)
    new_message.save()
    return new_message
message = create_message


def create_channel(key, aliases=None, desc=None,
                   locks=None, keep_log=True,
                   typeclass=None):
    """
    Create A communication Channel. A Channel serves as a central
    hub for distributing Msgs to groups of people without
    specifying the receivers explicitly. Instead players may
    'connect' to the channel and follow the flow of messages. By
    default the channel allows access to all old messages, but
    this can be turned off with the keep_log switch.

    key - this must be unique.
    aliases - list of alternative (likely shorter) keynames.
    locks - lock string definitions
    """
    global _ChannelDB, _channelhandler
    if not _ChannelDB:
        from src.comms.models import ChannelDB as _ChannelDB
    if not _channelhandler:
        from src.comms import channelhandler as _channelhandler
    if not typeclass:
        typeclass = settings.BASE_CHANNEL_TYPECLASS
    try:
        new_channel = _ChannelDB(typeclass=typeclass, db_key=key)
        new_channel.save()
        new_channel = new_channel.typeclass
        if aliases:
            if not utils.is_iter(aliases):
                aliases = [aliases]
            new_channel.aliases.add(aliases)
        new_channel.save()
        new_channel.db.desc = desc
        new_channel.db.keep_log = keep_log
    except IntegrityError:
        string = "Could not add channel: key '%s' already exists." % key
        logger.log_errmsg(string)
        return None
    if locks:
        new_channel.locks.add(locks)
    new_channel.save()
    _channelhandler.CHANNELHANDLER.add_channel(new_channel)
    new_channel.at_channel_create()
    return new_channel

channel = create_channel


def create_tag(self, key=None, category=None, data=None):
    """
    Create a tag. This makes sure to create case-insensitive tags.
    Note that if the exact same tag configuration (key+category)
    exists, it will be re-used. A data keyword will overwrite existing
    data on a tag (it is not part of what makes the tag unique).
    """
    global _Tag
    if not _Tag:
        from src.typeclasses.models import Tag as _Tag
    return _Tag.objects.create_tag(key=key, category=category, data=data)


#
# Player creation methods
#

def create_player(key, email, password,
                  typeclass=None,
                  is_superuser=False,
                  locks=None, permissions=None,
                  report_to=None):

    """
    This creates a new player.

    key - the player's name. This should be unique.
    email - email on valid addr@addr.domain form.
    password - password in cleartext
    is_superuser - wether or not this player is to be a superuser
    locks - lockstring
    permission - list of permissions
    report_to - an object with a msg() method to report errors to. If
                not given, errors will be logged.

    Will return the Player-typeclass or None/raise Exception if the
    Typeclass given failed to load.

    Concerning is_superuser:
     Usually only the server admin should need to be superuser, all
     other access levels can be handled with more fine-grained
     permissions or groups. A superuser bypasses all lock checking
     operations and is thus not suitable for play-testing the game.

    """
    global _PlayerDB, _Player
    if not _PlayerDB:
        from src.players.models import PlayerDB as _PlayerDB
    if not _Player:
        from src.players.player import Player as _Player

    if not email:
        email = "dummy@dummy.com"
    if _PlayerDB.objects.filter(username__iexact=key):
        raise ValueError("A Player with the name '%s' already exists." % key)

    # this handles a given dbref-relocate to a player.
    report_to = handle_dbref(report_to, _PlayerDB)

    try:

        # create the correct Player object
        if is_superuser:
            new_db_player = _PlayerDB.objects.create_superuser(key, email, password)
        else:
            new_db_player = _PlayerDB.objects.create_user(key, email, password)

        if not typeclass:
            typeclass = settings.BASE_PLAYER_TYPECLASS
        elif isinstance(typeclass, _PlayerDB):
            # this is an PlayerDB instance, extract its typeclass path
            typeclass = typeclass.typeclass.path
        elif isinstance(typeclass, _Player) or utils.inherits_from(typeclass, _Player):
            # this is Player object typeclass, extract its path
            typeclass = typeclass.path

        # assign the typeclass
        typeclass = utils.to_unicode(typeclass)
        new_db_player.typeclass_path = typeclass

        # this will either load the typeclass or the default one
        new_player = new_db_player.typeclass

        if not _GA(new_db_player, "is_typeclass")(typeclass, exact=True):
            # this will fail if we gave a typeclass as input
            # and it still gave us a default
            SharedMemoryModel.delete(new_db_player)
            if report_to:
                _GA(report_to, "msg")("Error creating %s (%s):\n%s" % (new_db_player.key, typeclass,
                                                                  _GA(new_db_player, "typeclass_last_errmsg")))
                return None
            else:
                raise Exception(_GA(new_db_player, "typeclass_last_errmsg"))

        new_player.basetype_setup()  # setup the basic locks and cmdset
        # call hook method (may override default permissions)
        new_player.at_player_creation()

        # custom given arguments potentially overrides the hook
        if permissions:
            new_player.permissions.add(permissions)
        elif not new_player.permissions:
            new_player.permissions.add(settings.PERMISSION_PLAYER_DEFAULT)
        if locks:
            new_player.locks.add(locks)
        return new_player

    except Exception:
        # a failure in creating the player; we try to clean
        # up as much as we can
        logger.log_trace()
        try:
            new_player.delete()
        except Exception:
            pass
        try:
            del new_player
        except Exception:
            pass
        raise

# alias
player = create_player

########NEW FILE########
__FILENAME__ = dbserialize
"""
This module handles serialization of arbitrary python structural data,
intended primarily to be stored in the database. It also supports
storing Django model instances (which plain pickle cannot do).

This serialization is used internally by the server, notably for
storing data in Attributes and for piping data to process pools.

The purpose of dbserialize is to handle all forms of data. For
well-structured non-arbitrary exchange, such as communicating with a
rich web client, a simpler JSON serialization makes more sense.

This module also implements the SaverList, SaverDict and SaverSet
classes. These are iterables that track their position in a nested
structure and makes sure to send updates up to their root. This is
used by Attributes - without it, one would not be able to update mutables
in-situ, e.g obj.db.mynestedlist[3][5] = 3 would never be saved and
be out of sync with the database.

"""

from functools import update_wrapper
from collections import defaultdict, MutableSequence, MutableSet, MutableMapping
try:
    from cPickle import dumps, loads
except ImportError:
    from pickle import dumps, loads
from django.db import transaction
from django.core.exceptions import ObjectDoesNotExist
from django.contrib.contenttypes.models import ContentType
from src.server.models import ServerConfig
from src.utils.utils import to_str, uses_database
from src.utils import logger

__all__ = ("to_pickle", "from_pickle", "do_pickle", "do_unpickle")

PICKLE_PROTOCOL = 2

# initialization and helpers

_GA = object.__getattribute__
_SA = object.__setattr__
_FROM_MODEL_MAP = None
_TO_MODEL_MAP = None
_TO_TYPECLASS = lambda o: hasattr(o, 'typeclass') and o.typeclass or o
_IS_PACKED_DBOBJ = lambda o: type(o) == tuple and len(o) == 4 and o[0] == '__packed_dbobj__'
if uses_database("mysql") and ServerConfig.objects.get_mysql_db_version() < '5.6.4':
    # mysql <5.6.4 don't support millisecond precision
    _DATESTRING = "%Y:%m:%d-%H:%M:%S:000000"
else:
    _DATESTRING = "%Y:%m:%d-%H:%M:%S:%f"


def _TO_DATESTRING(obj):
    """
    this will only be called with valid database objects. Returns datestring
    on correct form.
    """
    try:
        return _GA(obj, "db_date_created").strftime(_DATESTRING)
    except AttributeError:
        # this can happen if object is not yet saved - no datestring is then set
        obj.save()
        return _GA(obj, "db_date_created").strftime(_DATESTRING)


def _init_globals():
    "Lazy importing to avoid circular import issues"
    global _FROM_MODEL_MAP, _TO_MODEL_MAP
    if not _FROM_MODEL_MAP:
        _FROM_MODEL_MAP = defaultdict(str)
        _FROM_MODEL_MAP.update(dict((c.model, c.natural_key()) for c in ContentType.objects.all()))
    if not _TO_MODEL_MAP:
        _TO_MODEL_MAP = defaultdict(str)
        _TO_MODEL_MAP.update(dict((c.natural_key(), c.model_class()) for c in ContentType.objects.all()))

#
# SaverList, SaverDict, SaverSet - Attribute-specific helper classes and functions
#


def _save(method):
    "method decorator that saves data to Attribute"
    def save_wrapper(self, *args, **kwargs):
        self.__doc__ = method.__doc__
        ret = method(self, *args, **kwargs)
        self._save_tree()
        return ret
    return update_wrapper(save_wrapper, method)


class _SaverMutable(object):
    """
    Parent class for properly handling  of nested mutables in
    an Attribute. If not used something like
     obj.db.mylist[1][2] = "test" (allocation to a nested list)
    will not save the updated value to the database.
    """
    def __init__(self, *args, **kwargs):
        "store all properties for tracking the tree"
        self._parent = kwargs.pop("parent", None)
        self._db_obj = kwargs.pop("db_obj", None)
        self._data = None

    def _save_tree(self):
        "recursively traverse back up the tree, save when we reach the root"
        if self._parent:
            self._parent._save_tree()
        elif self._db_obj:
            self._db_obj.value = self
        else:
            logger.log_errmsg("_SaverMutable %s has no root Attribute to save to." % self)

    def _convert_mutables(self, data):
        "converts mutables to Saver* variants and assigns .parent property"
        def process_tree(item, parent):
            "recursively populate the tree, storing parents"
            dtype = type(item)
            if dtype in (basestring, int, long, float, bool, tuple):
                return item
            elif dtype == list:
                dat = _SaverList(parent=parent)
                dat._data.extend(process_tree(val, dat) for val in item)
                return dat
            elif dtype == dict:
                dat = _SaverDict(parent=parent)
                dat._data.update((key, process_tree(val, dat)) for key, val in item.items())
                return dat
            elif dtype == set:
                dat = _SaverSet(parent=parent)
                dat._data.update(process_tree(val, dat) for val in item)
                return dat
            return item
        return process_tree(data, self)

    def __repr__(self):
        return self._data.__repr__()

    def __len__(self):
        return self._data.__len__()

    def __iter__(self):
        return self._data.__iter__()

    def __getitem__(self, key):
        return self._data.__getitem__(key)

    @_save
    def __setitem__(self, key, value):
        self._data.__setitem__(key, self._convert_mutables(value))

    @_save
    def __delitem__(self, key):
        self._data.__delitem__(key)


class _SaverList(_SaverMutable, MutableSequence):
    """
    A list that saves itself to an Attribute when updated.
    """
    def __init__(self, *args, **kwargs):
        super(_SaverList, self).__init__(*args, **kwargs)
        self._data = list(*args)

    @_save
    def __add__(self, otherlist):
        self._data = self._data.__add__(otherlist)
        return self._data

    @_save
    def insert(self, index, value):
        self._data.insert(index, self._convert_mutables(value))


class _SaverDict(_SaverMutable, MutableMapping):
    """
    A dict that stores changes to an Attribute when updated
    """
    def __init__(self, *args, **kwargs):
        super(_SaverDict, self).__init__(*args, **kwargs)
        self._data = dict(*args)

    def has_key(self, key):
        return key in self._data


class _SaverSet(_SaverMutable, MutableSet):
    """
    A set that saves to an Attribute when updated
    """
    def __init__(self, *args, **kwargs):
        super(_SaverSet, self).__init__(*args, **kwargs)
        self._data = set(*args)

    def __contains__(self, value):
        return self._data.__contains__(value)

    @_save
    def add(self, value):
        self._data.add(self._convert_mutables(value))

    @_save
    def discard(self, value):
        self._data.discard(value)

#
# serialization helpers
#

def pack_dbobj(item):
    """
    Check and convert django database objects to an internal representation.
    This either returns the original input item or a tuple
      ("__packed_dbobj__", key, creation_time, id)
    """
    _init_globals()
    obj = hasattr(item, 'dbobj') and item.dbobj or item
    natural_key = _FROM_MODEL_MAP[hasattr(obj, "id") and hasattr(obj, "db_date_created") and
                                  hasattr(obj, '__class__') and obj.__class__.__name__.lower()]
    # build the internal representation as a tuple
    #  ("__packed_dbobj__", key, creation_time, id)
    return natural_key and ('__packed_dbobj__', natural_key,
                             _TO_DATESTRING(obj), _GA(obj, "id")) or item


def unpack_dbobj(item):
    """
    Check and convert internal representations back to Django database models.
    The fact that item is a packed dbobj should be checked before this call.
    This either returns the original input or converts the internal store back
    to a database representation (its typeclass is returned if applicable).
    """
    _init_globals()
    try:
        obj = item[3] and _TO_TYPECLASS(_TO_MODEL_MAP[item[1]].objects.get(id=item[3]))
    except ObjectDoesNotExist:
        return None
    # even if we got back a match, check the sanity of the date (some
    # databases may 're-use' the id)
    try:
        dbobj = obj.dbobj
    except AttributeError:
        dbobj = obj
    return _TO_DATESTRING(dbobj) == item[2] and obj or None

#
# Access methods
#

def to_pickle(data):
    """
    This prepares data on arbitrary form to be pickled. It handles any nested
    structure and returns data on a form that is safe to pickle (including
    having converted any database models to their internal representation).
    We also convert any Saver*-type objects back to their normal
    representations, they are not pickle-safe.
    """
    def process_item(item):
        "Recursive processor and identification of data"
        dtype = type(item)
        if dtype in (basestring, int, long, float, bool):
            return item
        elif dtype == tuple:
            return tuple(process_item(val) for val in item)
        elif dtype in (list, _SaverList):
            return [process_item(val) for val in item]
        elif dtype in (dict, _SaverDict):
            return dict((process_item(key), process_item(val)) for key, val in item.items())
        elif dtype in (set, _SaverSet):
            return set(process_item(val) for val in item)
        elif hasattr(item, '__item__'):
            # we try to conserve the iterable class, if not convert to list
            try:
                return item.__class__([process_item(val) for val in item])
            except (AttributeError, TypeError):
                return [process_item(val) for val in item]
        return pack_dbobj(item)
    return process_item(data)


@transaction.autocommit
def from_pickle(data, db_obj=None):
    """
    This should be fed a just de-pickled data object. It will be converted back
    to a form that may contain database objects again. Note that if a database
    object was removed (or changed in-place) in the database, None will be
    returned.

    db_obj - this is the model instance (normally an Attribute) that
             _Saver*-type iterables (_SaverList etc) will save to when they
             update. It must have a 'value' property that saves assigned data
             to the database. Skip if not serializing onto a given object.

    If db_obj is given, this function will convert lists, dicts and sets
    to their _SaverList, _SaverDict and _SaverSet counterparts.

    """
    def process_item(item):
        "Recursive processor and identification of data"
        dtype = type(item)
        if dtype in (basestring, int, long, float, bool):
            return item
        elif _IS_PACKED_DBOBJ(item):
            # this must be checked before tuple
            return unpack_dbobj(item)
        elif dtype == tuple:
            return tuple(process_item(val) for val in item)
        elif dtype == dict:
            return dict((process_item(key), process_item(val)) for key, val in item.items())
        elif dtype == set:
            return set(process_item(val) for val in item)
        elif hasattr(item, '__iter__'):
            try:
                # we try to conserve the iterable class if
                # it accepts an iterator
                return item.__class__(process_item(val) for val in item)
            except (AttributeError, TypeError):
                return [process_item(val) for val in item]
        return item

    def process_tree(item, parent):
        "Recursive processor, building a parent-tree from iterable data"
        dtype = type(item)
        if dtype in (basestring, int, long, float, bool):
            return item
        elif _IS_PACKED_DBOBJ(item):
            # this must be checked before tuple
            return unpack_dbobj(item)
        elif dtype == tuple:
            return tuple(process_tree(val, item) for val in item)
        elif dtype == list:
            dat = _SaverList(parent=parent)
            dat._data.extend(process_tree(val, dat) for val in item)
            return dat
        elif dtype == dict:
            dat = _SaverDict(parent=parent)
            dat._data.update(dict((process_item(key), process_tree(val, dat))
                                   for key, val in item.items()))
            return dat
        elif dtype == set:
            dat = _SaverSet(parent=parent)
            dat._data.update(set(process_tree(val, dat) for val in item))
            return dat
        elif hasattr(item, '__iter__'):
            try:
                # we try to conserve the iterable class if it
                # accepts an iterator
                return item.__class__(process_tree(val, parent) for val in item)
            except (AttributeError, TypeError):
                dat = _SaverList(parent=parent)
                dat._data.extend(process_tree(val, dat) for val in item)
                return dat
        return item

    if db_obj:
        # convert lists, dicts and sets to their Saved* counterparts. It
        # is only relevant if the "root" is an iterable of the right type.
        dtype = type(data)
        if dtype == list:
            dat = _SaverList(db_obj=db_obj)
            dat._data.extend(process_tree(val, parent=dat) for val in data)
            return dat
        elif dtype == dict:
            dat = _SaverDict(db_obj=db_obj)
            dat._data.update((process_item(key), process_tree(val, parent=dat))
                              for key, val in data.items())
            return dat
        elif dtype == set:
            dat = _SaverSet(db_obj=db_obj)
            dat._data.update(process_tree(val, parent=dat) for val in data)
            return dat
    return process_item(data)


def do_pickle(data):
    "Perform pickle to string"
    return to_str(dumps(data, protocol=PICKLE_PROTOCOL))


def do_unpickle(data):
    "Retrieve pickle from pickled string"
    return loads(to_str(data))


def dbserialize(data):
    "Serialize to pickled form in one step"
    return do_pickle(to_pickle(data))


def dbunserialize(data, db_obj=None):
    "Un-serialize in one step. See from_pickle for help db_obj."
    return do_unpickle(from_pickle(data, db_obj=db_obj))

########NEW FILE########
__FILENAME__ = dummyrunner
"""
Dummy client runner

This module implements a stand-alone launcher for stress-testing
an Evennia game. It will launch any number of fake clients. These
clients will log into the server and start doing random operations.
Customizing and weighing these operations differently depends on
which type of game is tested. The module contains a testing module
for plain Evennia.

Please note that you shouldn't run this on a production server!
Launch the program without any arguments or options to see a
full step-by-step setup help.

Basically (for testing default Evennia):

 - Use an empty/testing database.
 - set PERMISSION_PLAYER_DEFAULT = "Builders"
 - start server, eventually with profiling active
 - launch this client runner

If you want to customize the runner's client actions
(because you changed the cmdset or needs to better
match your use cases or add more actions), you can
change which actions by adding a path to

   DUMMYRUNNER_ACTIONS_MODULE = <path.to.your.module>

in your settings. See utils.dummyrunner_actions.py
for instructions on how to define this module.

"""

import os, sys, time, random
from optparse import OptionParser
from twisted.conch import telnet
from twisted.internet import reactor, protocol
# from twisted.application import internet, service
# from twisted.web import client
from twisted.internet.task import LoopingCall

# Tack on the root evennia directory to the python path and initialize django settings
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))
os.environ["DJANGO_SETTINGS_MODULE"] = "game.settings"
#from game import settings
#try:
#    from django.conf import settings as settings2
#    settings2.configure()
#except RuntimeError:
#    pass
#finally:
#    del settings2

from django.conf import settings
from src.utils import utils

HELPTEXT = """

Usage: dummyrunner.py [-h][-v][-V] [nclients]

DO NOT RUN THIS ON A PRODUCTION SERVER! USE A CLEAN/TESTING DATABASE!

This stand-alone program launches dummy telnet clients against a
running Evennia server. The idea is to mimic real players logging in
and repeatedly doing resource-heavy commands so as to stress test the
game. It uses the default command set to log in and issue commands, so
if that was customized, some of the functionality will not be tested
(it will not fail, the commands will just not be recognized).  The
running clients will create new objects and rooms all over the place
as part of their running, so using a clean/testing database is
strongly recommended.

Setup:
  1) setup a fresh/clean database (if using sqlite, just safe-copy
     away your real evennia.db3 file and create a new one with
     manage.py)
  2) in game/settings.py, add

        PERMISSION_PLAYER_DEFAULT="Builders"

  3a) Start Evennia like normal.
  3b) If you want profiling, start Evennia like this instead:

        python runner.py -S start

     this will start Evennia under cProfiler with output server.prof.
  4) run this dummy runner:

        python dummyclients.py <nr_of_clients> [timestep] [port]

     Default is to connect one client to port 4000, using a 5 second
     timestep.  Increase the number of clients and shorten the
     timestep (minimum is 1s) to further stress the game.

     You can stop the dummy runner with Ctrl-C.

  5) Log on and determine if game remains responsive despite the
     heavier load. Note that if you do profiling, there is an
     additional overhead from the profiler too!
  6) If you use profiling, let the game run long enough to gather
     data, then stop the server. You can inspect the server.prof file
     from a python prompt (see Python's manual on cProfiler).

"""
# number of clients to launch if no input is given on command line
DEFAULT_NCLIENTS = 1
# time between each 'tick', in seconds, if not set on command
# line. All launched clients will be called upon to possibly do an
# action with this frequency.
DEFAULT_TIMESTEP = 2
# chance of a client performing an action, per timestep. This helps to
# spread out usage randomly, like it would be in reality.
CHANCE_OF_ACTION = 0.05
# Port to use, if not specified on command line
DEFAULT_PORT = settings.TELNET_PORTS[0]


#------------------------------------------------------------
# Helper functions
#------------------------------------------------------------

def idcounter():
    "generates subsequent id numbers"
    idcount = 0
    while True:
        idcount += 1
        yield idcount
OID = idcounter()
CID = idcounter()

def makeiter(obj):
    "makes everything iterable"
    if not hasattr(obj, '__iter__'):
        return [obj]
    return obj

#------------------------------------------------------------
# Client classes
#------------------------------------------------------------

class DummyClient(telnet.StatefulTelnetProtocol):
    """
    Handles connection to a running Evennia server,
    mimicking a real player by sending commands on
    a timer.
    """

    def connectionMade(self):

        # public properties
        self.cid = CID.next()
        self.istep = 0
        self.exits = [] # exit names created
        self.objs = [] # obj names created

        self._report = ""
        self._cmdlist = [] # already stepping in a cmd definition
        self._ncmds = 0
        self._actions = self.factory.actions
        self._echo_brief = self.factory.verbose == 1
        self._echo_all = self.factory.verbose == 2
        #print " ** client %i connected." % self.cid

        reactor.addSystemEventTrigger('before', 'shutdown', self.logout)

        # start client tick
        d = LoopingCall(self.step)
        d.start(self.factory.timestep, now=True).addErrback(self.error)

    def dataReceived(self, data):
        "Echo incoming data to stdout"
        if self._echo_all:
            print data

    def connectionLost(self, reason):
        "loosing the connection"
        #print " ** client %i lost connection." % self.cid

    def error(self, err):
        "error callback"
        print err

    def counter(self):
        "produces a unique id, also between clients"
        return OID.next()

    def logout(self):
        "Causes the client to log out of the server. Triggered by ctrl-c signal."
        cmd, report = self._actions[1](self)
        print "client %i %s (%s actions)" % (self.cid, report, self.istep)
        self.sendLine(cmd)

    def step(self):
        """
        Perform a step. This is called repeatedly by the runner
        and causes the client to issue commands to the server.
        This holds all "intelligence" of the dummy client.
        """
        if random.random() > CHANCE_OF_ACTION:
            return
        if not self._cmdlist:
            # no cmdlist in store, get a new one
            if self.istep == 0:
                cfunc = self._actions[0]
            else: # random selection using cumulative probabilities
                rand = random.random()
                cfunc = [func for cprob, func in self._actions[2] if cprob >= rand][0]
            # assign to internal cmdlist
            cmd, self._report = cfunc(self)
            self._cmdlist = list(makeiter(cmd))
            self._ncmds = len(self._cmdlist)
        # output
        if self.istep == 0 and not (self._echo_brief or self._echo_all):
            print "client %i %s" % (self.cid, self._report)
        elif self.istep == 0 or self._echo_brief or self._echo_all:
            print "client %i %s (%i/%i)" % (self.cid, self._report, self._ncmds-(len(self._cmdlist)-1), self._ncmds)
        # launch the action by popping the first element from cmdlist (don't hide tracebacks)
        self.sendLine(str(self._cmdlist.pop(0)))
        self.istep += 1 # only steps up if an action is taken

class DummyFactory(protocol.ClientFactory):
    protocol = DummyClient
    def __init__(self, actions, timestep, verbose):
        "Setup the factory base (shared by all clients)"
        self.actions = actions
        self.timestep = timestep
        self.verbose = verbose

#------------------------------------------------------------
# Access method:
# Starts clients and connects them to a running server.
#------------------------------------------------------------

def start_all_dummy_clients(actions, nclients=1, timestep=5, telnet_port=4000, verbose=0):

    # validating and preparing the action tuple

    # make sure the probabilities add up to 1
    pratio = 1.0 / sum(tup[0] for tup in actions[2:])
    flogin, flogout, probs, cfuncs = actions[0], actions[1], [tup[0] * pratio for tup in actions[2:]], [tup[1] for tup in actions[2:]]
    # create cumulative probabilies for the random actions
    cprobs = [sum(v for i,v in enumerate(probs) if i<=k) for k in range(len(probs))]
    # rebuild a new, optimized action structure
    actions = (flogin, flogout, zip(cprobs, cfuncs))

    # setting up all clients (they are automatically started)
    factory = DummyFactory(actions, timestep, verbose)
    for i in range(nclients):
        reactor.connectTCP("localhost", telnet_port, factory)
    # start reactor
    reactor.run()

#------------------------------------------------------------
# Command line interface
#------------------------------------------------------------

if __name__ == '__main__':

    # parsing command line with default vals
    parser = OptionParser(usage="%prog [options] <nclients> [timestep, [port]]",
                          description="This program requires some preparations to run properly. Start it without any arguments or options for full help.")
    parser.add_option('-v', '--verbose', action='store_const', const=1, dest='verbose',
                      default=0,help="echo brief description of what clients do every timestep.")
    parser.add_option('-V', '--very-verbose', action='store_const',const=2, dest='verbose',
                      default=0,help="echo all client returns to stdout (hint: use only with nclients=1!)")

    options, args = parser.parse_args()

    nargs = len(args)
    nclients = DEFAULT_NCLIENTS
    timestep = DEFAULT_TIMESTEP
    port = DEFAULT_PORT
    try:
        if not args : raise Exception
        if nargs > 0: nclients = max(1, int(args[0]))
        if nargs > 1: timestep = max(1, int(args[1]))
        if nargs > 2: port = int(args[2])
    except Exception:
        print HELPTEXT
        sys.exit()

    # import the ACTION tuple from a given module
    try:
        action_modpath = settings.DUMMYRUNNER_ACTIONS_MODULE
    except AttributeError:
        # use default
        action_modpath = "src.utils.dummyrunner.dummyrunner_actions"
    actions = utils.variable_from_module(action_modpath, "ACTIONS")

    print "Connecting %i dummy client(s) to port %i using a %i second timestep ... " % (nclients, port, timestep)
    t0 = time.time()
    start_all_dummy_clients(actions, nclients, timestep, port,
                       verbose=options.verbose)
    ttot = time.time() - t0
    print "... dummy client runner finished after %i seconds." % ttot

########NEW FILE########
__FILENAME__ = dummyrunner_actions
"""
These are actions for the dummy client runner, using
the default command set and intended for unmodified Evennia.

Each client action is defined as a function. The clients
will perform these actions randomly (except the login action).

Each action-definition function should take one argument- "client",
which is a reference to the client currently performing the action
Use the client object for saving data between actions.

The client object has the following relevant properties and methods:
  cid - unique client id
  istep - the current step
  exits - an empty list. Can be used to store exit names
  objs - an empty list. Can be used to store object names
  counter() - get an integer value. This counts up for every call and
              is always unique between clients.

The action-definition function should return the command that the
client should send to the server (as if it was input in a mud client).
It should also return a string detailing the action taken. This string is
used by the "brief verbose" mode of the runner and is prepended by
"Client N " to produce output like "Client 3 is creating objects ..."

This module *must* also define a variable named ACTIONS. This is a tuple
where the first element is the function object for the action function
to call when the client logs onto the server.  The following elements
are 2-tuples (probability, action_func), where probability defines how
common it is for that particular action to happen. The runner will
randomly pick between those functions based on the probability.

ACTIONS = (login_func, (0.3, func1), (0.1, func2) ... )

To change the runner to use your custom ACTION and/or action
definitions, edit settings.py and add

 DUMMYRUNNER_ACTIONS_MODULE = "path.to.your.module"

"""

# it's very useful to have a unique id for this run to avoid any risk
# of clashes

import time
RUNID = time.time()

# some convenient templates

START_ROOM = "testing_room_start-%s-%s" % (RUNID, "%i")
ROOM_TEMPLATE = "testing_room_%s-%s" % (RUNID, "%i")
EXIT_TEMPLATE = "exit_%s-%s" % (RUNID, "%i")
OBJ_TEMPLATE = "testing_obj_%s-%s" % (RUNID, "%i")
TOBJ_TEMPLATE = "testing_button_%s-%s" % (RUNID, "%i")
TOBJ_TYPECLASS = "examples.red_button.RedButton"

# action function definitions

def c_login(client):
    "logins to the game"
    cname = "Dummy-%s-%i" % (RUNID, client.cid)
    #cemail = "%s@dummy.com" % (cname.lower())
    cpwd = "%s-%s" % (RUNID, client.cid)
    # set up for digging a first room (to move to)
    roomname = ROOM_TEMPLATE % client.counter()
    exitname1 = EXIT_TEMPLATE % client.counter()
    exitname2 = EXIT_TEMPLATE % client.counter()
    client.exits.extend([exitname1, exitname2])
    #cmd = '@dig %s = %s, %s' % (roomname, exitname1, exitname2)
    cmd = ('create %s %s' % (cname, cpwd),
           'connect %s %s' % (cname, cpwd),
           '@dig %s' % START_ROOM % client.cid,
           '@teleport %s' % START_ROOM % client.cid,
           '@dig %s = %s, %s' % (roomname, exitname1, exitname2)
           )

    return cmd, "logs in as %s ..." % cname

def c_logout(client):
    "logouts of the game"
    return "@quit", "logs out"

def c_looks(client):
    "looks at various objects"
    cmd = ["look %s" % obj for obj in client.objs]
    if not cmd:
        cmd = ["look %s" % exi for exi in client.exits]
        if not cmd:
            cmd = "look"
    return cmd, "looks ..."

def c_examines(client):
    "examines various objects"
    cmd = ["examine %s" % obj for obj in client.objs]
    if not cmd:
        cmd = ["examine %s" % exi for exi in client.exits]
    if not cmd:
        cmd = "examine me"
    return cmd, "examines objs ..."

def c_help(client):
    "reads help files"
    cmd = ('help',
           'help @teleport',
           'help look',
           'help @tunnel',
           'help @dig')
    return cmd, "reads help ..."

def c_digs(client):
    "digs a new room, storing exit names on client"
    roomname = ROOM_TEMPLATE % client.counter()
    exitname1 = EXIT_TEMPLATE % client.counter()
    exitname2 = EXIT_TEMPLATE % client.counter()
    client.exits.extend([exitname1, exitname2])
    cmd = '@dig %s = %s, %s' % (roomname, exitname1, exitname2)
    return cmd, "digs ..."

def c_creates_obj(client):
    "creates normal objects, storing their name on client"
    objname = OBJ_TEMPLATE % client.counter()
    client.objs.append(objname)
    cmd = ('@create %s' % objname,
           '@desc %s = "this is a test object' % objname,
           '@set %s/testattr = this is a test attribute value.' % objname,
           '@set %s/testattr2 = this is a second test attribute.' % objname)
    return cmd, "creates obj ..."

def c_creates_button(client):
    "creates example button, storing name on client"
    objname = TOBJ_TEMPLATE % client.counter()
    client.objs.append(objname)
    cmd = ('@create %s:%s' % (objname, TOBJ_TYPECLASS),
           '@desc %s = test red button!' % objname)
    return cmd, "creates button ..."

def c_socialize(client):
    "socializechats on channel"
    cmd = ('ooc Hello!',
          'ooc Testing ...',
          'ooc Testing ... times 2',
          'say Yo!',
          'emote stands looking around.')
    return cmd, "socializes ..."

def c_moves(client):
    "moves to a previously created room, using the stored exits"
    cmd = client.exits # try all exits - finally one will work
    if not cmd: cmd = "look"
    return cmd, "moves ..."


# Action tuple (required)
#
# This is a tuple of client action functions. The first element is the
# function the client should use to log into the game and move to
# STARTROOM . The second element is the logout command, for cleanly
# exiting the mud. The following elements are 2-tuples of (probability,
# action_function). The probablities should normally sum up to 1,
# otherwise the system will normalize them.
#

## "normal builder" definition
#ACTIONS = ( c_login,
#            c_logout,
#            (0.5, c_looks),
#            (0.08, c_examines),
#            (0.1, c_help),
#            (0.01, c_digs),
#            (0.01, c_creates_obj),
#            #(0.1, c_creates_button),
#            (0.3, c_moves))
## "heavy" builder definition
#ACTIONS = ( c_login,
#            c_logout,
#            (0.2, c_looks),
#            (0.1, c_examines),
#            (0.2, c_help),
#            (0.1, c_digs),
#            (0.1, c_creates_obj),
#            #(0.01, c_creates_button),
#            (0.2, c_moves))
## "passive player" definition
#ACTIONS = ( c_login,
#            c_logout,
#            (0.7, c_looks),
#            #(0.1, c_examines),
#            (0.3, c_help))
#            #(0.1, c_digs),
#            #(0.1, c_creates_obj),
#            #(0.1, c_creates_button),
#            #(0.4, c_moves))
## "normal player" definition
#ACTIONS = ( c_login,
#            c_logout,
#            (0.01, c_digs),
#            (0.1, c_socialize),
#            (0.39, c_looks),
#            (0.1, c_help),
#            (0.4, c_moves))
## "socializing heavy builder" definition
ACTIONS = (c_login,
           c_logout,
           (0.1, c_socialize),
           (0.1, c_looks),
           (0.1, c_help),
           (0.2, c_creates_obj),
           (0.2, c_digs),
           (0.3, c_moves))

########NEW FILE########
__FILENAME__ = test_queries
"""
This is a little routine for viewing the sql queries that are executed by a given
query as well as count them for optimization testing.

"""
import sys, os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))
os.environ["DJANGO_SETTINGS_MODULE"] = "game.settings"
from django.db import connection


def count_queries(exec_string, setup_string):
    """
    Display queries done by exec_string. Use setup_string
    to setup the environment to test.
    """

    exec setup_string

    num_queries_old = len(connection.queries)
    exec exec_string
    nqueries = len(connection.queries) - num_queries_old

    for query in connection.queries[-nqueries if nqueries else 1:]:
        print query["time"], query["sql"]
    print "Number of queries: %s" % nqueries

if __name__ == "__main__":

    # setup tests here

    setup_string = \
"""
from src.objects.models import ObjectDB
g = ObjectDB.objects.get(db_key="Griatch")
"""
    exec_string = \
"""
g.tags.all()
"""
    count_queries(exec_string, setup_string)

########NEW FILE########
__FILENAME__ = evform
# coding=utf-8
"""
Mudform - a way to create advanced ascii forms

WARNING: UNDER DEVELOPMENT. Evform does currently NOT support
colour ANSI markers in the table. Non-colour forms should
work fully (so make issues if they don't).


This is intended for creating advanced ascii game forms, such as a
large pretty character sheet or info document.

The system works on the basis of a readin template that is given in a
separate python file imported into the handler. This file contains
some optional settings and a string mapping out the form. The template
has markers in it to denounce fields to fill. The markers map the
absolute size of the field and will be filled with an evtable.Cell
object when displaying the form.

Note, when printing examples with ANSI color, you need to wrap
the output in unicode(), such as print unicode(form). This is
due to a bug in the Python parser and the print statement.


Example of input file testform.py:

FORMCHAR = "x"
TABLECHAR = "c"

FORM = '''
.------------------------------------------------.
|                                                |
|  Name: xxxxx1xxxxx    Player: xxxxxxx2xxxxxxx  |
|        xxxxxxxxxxx                             |
|                                                |
 >----------------------------------------------<
|                                                |
| Desc:  xxxxxxxxxxx    STR: x4x    DEX: x5x     |
|        xxxxx3xxxxx    INT: x6x    STA: x7x     |
|        xxxxxxxxxxx    LUC: x8x    MAG: x9x     |
|                                                |
 >----------------------------------------------<
|          |                                     |
| cccccccc | ccccccccccccccccccccccccccccccccccc |
| cccccccc | ccccccccccccccccccccccccccccccccccc |
| cccAcccc | ccccccccccccccccccccccccccccccccccc |
| cccccccc | ccccccccccccccccccccccccccccccccccc |
| cccccccc | cccccccccccccccccBccccccccccccccccc |
|          |                                     |
-------------------------------------------------
'''

The first line of the FORM string is ignored. The forms and table
markers must mark out complete, unbroken rectangles, each containing
one embedded single-character identifier (so the smallest element
possible is a 3-character wide form). The identifier can be any
character except for the FORM_CHAR and TABLE_CHAR and some of the
common ascii-art elements, like space, _ | * etc (see
INVALID_FORMCHARS in this module). Form Rectangles can have any size,
but must be separated from each other by at least one other
character's width.


Use as follows:

    import evform

    # create a new form from the template
    form = evform.EvForm("path/to/testform.py")

    (MudForm can also take a dictionary holding
     the required keys FORMCHAR, TABLECHAR and FORM)

    # add data to each tagged form cell
    form.map(cells={1: "Tom the Bouncer",
                    2: "Griatch",
                    3: "A sturdy fellow",
                    4: 12,
                    5: 10,
                    6:  5,
                    7: 18,
                    8: 10,
                    9:  3})
    # create the EvTables
    tableA = evform.EvTable("HP","MV","MP",
                               table=[["**"], ["*****"], ["***"]],
                               border="incols")
    tableB = evform.EvTable("Skill", "Value", "Exp",
                               table=[["Shooting", "Herbalism", "Smithing"],
                                      [12,14,9],["550/1200", "990/1400", "205/900"]],
                               border="incols")
    # add the tables to the proper ids in the form
    form.map(tables={"A": tableA,
                     "B": tableB}

    # unicode is required since the example contains non-ascii characters
    print unicode(form)

This produces the following result:

.------------------------------------------------.
|                                                |
|  Name: Tom the        Player: Griatch          |
|        Bouncer                                 |
|                                                |
 >----------------------------------------------<
|                                                |
| Desc:  A sturdy       STR: 12     DEX: 10      |
|        fellow         INT: 5      STA: 18      |
|                       LUC: 10     MAG: 3       |
|                                                |
 >----------------------------------------------<
|          |                                     |
| HP|MV|MP | Skill      |Value      |Exp         |
| ~~+~~+~~ | ~~~~~~~~~~~+~~~~~~~~~~~+~~~~~~~~~~~ |
| **|**|** | Shooting   |12         |550/1200    |
|   |**|*  | Herbalism  |14         |990/1400    |
|   |* |   | Smithing   |9          |205/900     |
|          |                                     |
 ------------------------------------------------

The marked forms have been replaced with Cells of text and with
EvTables. The form can be updated by simply re-applying form.map()
with the updated data.

When working with the template ascii file, you can use form.reload()
to re-read the template and re-apply all existing mappings.

Each component is restrained to the width and height specified by the
template, so it will resize to fit (or crop text if the area is too
small for it. If you try to fit a table into an area it cannot fit
into (when including its borders and at least one line of text), the
form will raise an error.

"""

import re
import copy
from src.utils.evtable import Cell, EvTable
from src.utils.utils import all_from_module, to_str, to_unicode
from src.utils.ansi import ANSIString

# non-valid form-identifying characters (which can thus be
# used as separators between forms without being detected
# as an identifier). These should be listed in regex form.

INVALID_FORMCHARS = r"\s\/\|\\\*\_\-\#\<\>\~\^\:\;\.\,"

def _to_ansi(obj, regexable=False):
    "convert to ANSIString"
    if isinstance(obj, dict):
        return dict((key, _to_ansi(value, regexable=regexable)) for key, value in obj.items())
    elif hasattr(obj, "__iter__"):
        return [_to_ansi(o) for o in obj]
    else:
        return ANSIString(to_unicode(obj), regexable=regexable)

class EvForm(object):
    """
    This object is instantiated with a text file and parses
    it for rectangular form fields. It can then be fed a
    mapping so as to populate the fields with fixed-width
    Cell or Tablets.

    """
    def __init__(self, filename=None, cells=None, tables=None, form=None, **kwargs):
        """
        Initiate the form

        keywords:
            filename - path to template file
            form - dictionary of {"CELLCHAR":char,
                                  "TABLECHAR":char,
                                  "FORM":templatestring}
                    if this is given, filename is not read.
            cells - a dictionary mapping of {id:text}
            tables -  dictionary mapping of {id:EvTable}

        other kwargs are fed as options to the Cells and EvTables
        (see evtablet.Cell and evtable.EvTable for more info).

        """
        self.filename = filename
        self.input_form_dict = form

        self.cells_mapping =  dict((to_str(key, force_string=True), value) for key, value in cells.items()) if cells  else {}
        self.tables_mapping = dict((to_str(key, force_string=True), value) for key, value in tables.items()) if tables else {}

        self.cellchar = "x"
        self.tablechar = "c"

        self.raw_form = []
        self.form = []

        # clean kwargs (these cannot be overridden)
        kwargs.pop("enforce_size", None)
        kwargs.pop("width", None)
        kwargs.pop("height", None)
        # table/cell options
        self.options = kwargs

        self.reload()

    def _parse_rectangles(self, cellchar, tablechar, form, **kwargs):
        """
        Parse a form for rectangular formfields identified by
        formchar enclosing an identifier.
        """

        # update options given at creation with new input - this
        # allows e.g. self.map() to add custom settings for individual
        # cells/tables
        custom_options = copy.copy(self.options)
        custom_options.update(kwargs)

        nform = len(form)

        mapping = {}
        cell_coords = {}
        table_coords = {}

        # Locate the identifier tags and the horizontal end coords for all forms
        re_cellchar =  re.compile(r"%s+([^%s%s])%s+" % (cellchar, INVALID_FORMCHARS, cellchar, cellchar))
        re_tablechar = re.compile(r"%s+([^%s%s|])%s+" % (tablechar, INVALID_FORMCHARS, tablechar, tablechar))
        for iy, line in enumerate(_to_ansi(form, regexable=True)):
            # find cells
            ix0 = 0
            while True:
                match = re_cellchar.search(line, ix0)
                if match:
                    # get the width of the rectangle directly from the match
                    cell_coords[match.group(1)] = [iy, match.start(), match.end()]
                    ix0 = match.end()
                else:
                    break
            # find tables
            ix0 = 0
            while True:
                match = re_tablechar.search(line, ix0)
                if match:
                    # get the width of the rectangle directly from the match
                    table_coords[match.group(1)] = [iy, match.start(), match.end()]
                    ix0 = match.end()
                else:
                    break
        #print "cell_coords:", cell_coords
        #print "table_coords:", table_coords

        # get rectangles and assign Cells
        for key, (iy, leftix, rightix) in cell_coords.items():

            # scan up to find top of rectangle
            dy_up = 0
            if iy > 0:
                for i in range(1,iy):
                    #print "dy_up:", [form[iy-i][ix] for ix in range(leftix, rightix)]
                    if all(form[iy-i][ix] == cellchar for ix in range(leftix, rightix)):
                        dy_up += 1
                    else:
                        break
            # find bottom edge of rectangle
            dy_down = 0
            if iy < nform-1:
                for i in range(1,nform-iy-1):
                    #print "dy_down:", [form[iy+i][ix]for ix in range(leftix, rightix)]
                    if all(form[iy+i][ix] == cellchar for ix in range(leftix, rightix)):
                        dy_down += 1
                    else:
                        break

            #  we have our rectangle. Calculate size of Cell.
            iyup = iy - dy_up
            iydown = iy + dy_down
            width = rightix - leftix
            height = abs(iyup - iydown) + 1

            # we have all the coordinates we need. Create Cell.
            data = self.cells_mapping.get(key, "")
            #if key == "1":
            #    print "creating cell '%s' (%s):" % (key, data)
            #    print "iy=%s, iyup=%s, iydown=%s, leftix=%s, rightix=%s, width=%s, height=%s" % (iy, iyup, iydown, leftix, rightix, width, height)

            options = { "pad_left":0, "pad_right":0, "pad_top":0, "pad_bottom":0, "align":"l", "valign":"t", "enforce_size":True}
            options.update(custom_options)
            #if key=="4":
            #print "options:", options

            mapping[key] = (iyup, leftix, width, height, Cell(data, width=width, height=height,**options))

        # get rectangles and assign Tables
        for key, (iy, leftix, rightix) in table_coords.items():

            # scan up to find top of rectangle
            dy_up = 0
            if iy > 0:
                for i in range(1,iy):
                    #print "dy_up:", [form[iy-i][ix] for ix in range(leftix, rightix)]
                    if all(form[iy-i][ix] == tablechar for ix in range(leftix, rightix)):
                        dy_up += 1
                    else:
                        break
            # find bottom edge of rectangle
            dy_down = 0
            if iy < nform-1:
                for i in range(1,nform-iy-1):
                    #print "dy_down:", [form[iy+i][ix]for ix in range(leftix, rightix)]
                    if all(form[iy+i][ix] == tablechar for ix in range(leftix, rightix)):
                        dy_down += 1
                    else:
                        break

            #  we have our rectangle. Calculate size of Table.
            iyup = iy - dy_up
            iydown = iy + dy_down
            width = rightix - leftix
            height = abs(iyup - iydown) + 1

            # we have all the coordinates we need. Create Table.
            table = self.tables_mapping.get(key, None)
            #print "creating table '%s' (%s):" % (key, data)
            #print "iy=%s, iyup=%s, iydown=%s, leftix=%s, rightix=%s, width=%s, height=%s" % (iy, iyup, iydown, leftix, rightix, width, height)

            options = { "pad_left":0, "pad_right":0, "pad_top":0, "pad_bottom":0,
                        "align":"l", "valign":"t", "enforce_size":True}
            options.update(custom_options)
            #print "options:", options

            if table:
                table.reformat(width=width, height=height, **options)
            else:
                table = EvTable(width=width, height=height, **options)
            mapping[key] = (iyup, leftix, width, height, table)

        return mapping

    def _populate_form(self, raw_form, mapping):
        """
        Insert cell contents into form at given locations
        """
        form = copy.copy(raw_form)
        for key, (iy0, ix0, width, height, cell_or_table) in mapping.items():
            # rect is a list of <height> lines, each <width> wide
            rect = cell_or_table.get()
            for il, rectline in enumerate(rect):
                formline = form[iy0+il]
                # insert new content, replacing old
                form[iy0+il] = formline = formline[:ix0] + rectline + formline[ix0+width:]
        return form

    def map(self, cells=None, tables=None, **kwargs):
        """
        Add mapping for form.

        cells - a dictionary of {identifier:celltext}
        tables - a dictionary of {identifier:table}

        kwargs will be forwarded to tables/cells. See
        evtable.Cell and evtable.EvTable for info.

        """
        # clean kwargs (these cannot be overridden)
        kwargs.pop("enforce_size", None)
        kwargs.pop("width", None)
        kwargs.pop("height", None)

        new_cells =  dict((to_str(key, force_string=True), value) for key, value in cells.items()) if cells  else {}
        new_tables = dict((to_str(key, force_string=True), value) for key, value in tables.items()) if tables else {}

        self.cells_mapping.update(new_cells)
        self.tables_mapping.update(new_tables)
        self.reload()

    def reload(self, filename=None, form=None, **kwargs):
        """
        Creates the form from a stored file name
        """
        # clean kwargs (these cannot be overridden)
        kwargs.pop("enforce_size", None)
        kwargs.pop("width", None)
        kwargs.pop("height", None)

        if form or self.input_form_dict:
            datadict = form if form else self.input_form_dict
            self.input_form_dict = datadict
        elif filename or self.filename:
            filename = filename if filename else self.filename
            datadict = all_from_module(filename)
            self.filename = filename
        else:
            datadict = {}

        cellchar = to_str(datadict.get("FORMCHAR", "x"))
        self.cellchar = to_str(cellchar[0] if len(cellchar) > 1 else cellchar)
        tablechar = datadict.get("TABLECHAR", "c")
        self.tablechar = tablechar[0] if len(tablechar) > 1 else tablechar

        # split into a list of list of lines. Form can be indexed with form[iy][ix]
        self.raw_form = _to_ansi(to_unicode(datadict.get("FORM", "")).split("\n"))
        # strip first line
        self.raw_form = self.raw_form[1:] if self.raw_form else self.raw_form

        self.options.update(kwargs)

        # parse and replace
        self.mapping = self._parse_rectangles(self.cellchar, self.tablechar, self.raw_form, **kwargs)
        self.form = self._populate_form(self.raw_form, self.mapping)

    def __str__(self):
        "Prints the form"
        return ANSIString("\n").join([line for line in self.form])

    def __unicode__(self):
        "prints the form"
        return unicode(ANSIString("\n").join([line for line in self.form]))

def _test():
    "test evform"
    form = EvForm("src.utils.evform_test")

    # add data to each tagged form cell
    form.map(cells={1: "{gTom the Bouncer{n",
                    2: "{yGriatch{n",
                    3: "A sturdy fellow",
                    4: 12,
                    5: 10,
                    6:  5,
                    7: 18,
                    8: 10,
                    9:  3})
    # create the EvTables
    tableA = EvTable("HP","MV","MP",
                               table=[["**"], ["*****"], ["***"]],
                               border="incols")
    tableB = EvTable("Skill", "Value", "Exp",
                               table=[["Shooting", "Herbalism", "Smithing"],
                                      [12,14,9],["550/1200", "990/1400", "205/900"]],
                               border="incols")
    # add the tables to the proper ids in the form
    form.map(tables={"A": tableA,
                     "B": tableB})

    # unicode is required since the example contains non-ascii characters
    print unicode(form)

########NEW FILE########
__FILENAME__ = evform_test
# encoding=utf-8
"""
Test form
"""

FORMCHAR = "x"
TABLECHAR = "c"

FORM = """
.------------------------------------------------.
|                                                |
|  Name: xxxxx1xxxxx    Player: xxxxxxx2xxxxxxx  |
|        xxxxxxxxxxx                             |
|                                                |
 >----------------------------------------------<
|                                                |
| Desc:  xxxxxxxxxxx    STR: x4x    DEX: x5x     |
|        xxxxx3xxxxx    INT: x6x    STA: x7x     |
|        xxxxxxxxxxx    LUC: x8x    MAG: x9x     |
|                                                |
 >----------------------------------------------<
|          |                                     |
| cccccccc | ccccccccccccccccccccccccccccccccccc |
| cccccccc | ccccccccccccccccccccccccccccccccccc |
| cccAcccc | ccccccccccccccccccccccccccccccccccc |
| cccccccc | ccccccccccccccccccccccccccccccccccc |
| cccccccc | cccccccccccccccccBccccccccccccccccc |
|          |                                     |
 ------------------------------------------------
"""



########NEW FILE########
__FILENAME__ = evtable
"""

EvTable

This is an advanced ASCII table creator. It was inspired
by prettytable but shares no code.

Note: to test ANSI colors on the command line you need to
call the printed table in a unicode() call, like print unicode(table).
This is due to a bug in the python interpreter and print.

Example usage:

    table = EvTable("Heading1", "Heading2", table=[[1,2,3],[4,5,6],[7,8,9]], border="cells")
    table.add_column("This is long data", "This is even longer data")
    table.add_row("This is a single row")
    print table

Result:

+----------------------+----------+---+--------------------------+
|       Heading1       | Heading2 |   |                          |
+~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~+~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~+
|           1          |     4    | 7 |     This is long data    |
+----------------------+----------+---+--------------------------+
|           2          |     5    | 8 | This is even longer data |
+----------------------+----------+---+--------------------------+
|           3          |     6    | 9 |                          |
+----------------------+----------+---+--------------------------+
| This is a single row |          |   |                          |
+----------------------+----------+---+--------------------------+

As seen, the table will automatically expand with empty cells to
make the table symmetric.

Tables can be restricted to a given width.

table.reformat(width=50, align="l")

(We could just have added these keywords to the table
creation call) yields the following result:
+-----------+------------+-----------+-----------+
| Heading1  | Heading2   |           |           |
+~~~~~~~~~~~+~~~~~~~~~~~~+~~~~~~~~~~~+~~~~~~~~~~~+
| 1         | 4          | 7         | This is   |
|           |            |           | long data |
+-----------+------------+-----------+-----------+
|           |            |           | This is   |
| 2         | 5          | 8         | even      |
|           |            |           | longer    |
|           |            |           | data      |
+-----------+------------+-----------+-----------+
| 3         | 6          | 9         |           |
+-----------+------------+-----------+-----------+
| This is a |            |           |           |
|  single   |            |           |           |
| row       |            |           |           |
+-----------+------------+-----------+-----------+

When adding new rows/columns their data can have its
own alignments (left/center/right, top/center/bottom).

If the height is restricted, cells will be restricted
from expanding vertically. This will lead to text
contents being cropped. Each cell can only shrink
to a minimum width and height of 1.


It is intended to be used with ANSIString for supporting
ANSI-coloured string types.

When a cell is auto-wrapped across multiple lines,
ANSI-reset sequences will be put at the end of each
wrapped line. This means that the colour of a wrapped
cell will not "bleed", but it also means that eventual
colour outside

"""
#from textwrap import wrap
from textwrap import TextWrapper
from copy import deepcopy, copy
from src.utils.utils import to_unicode
from src.utils.ansi import ANSIString

def make_iter(obj):
    "Makes sure that the object is always iterable."
    return not hasattr(obj, '__iter__') and [obj] or obj

def _to_ansi(obj):
    "convert to ANSIString"
    if hasattr(obj, "__iter__"):
        return [_to_ansi(o) for o in obj]
    else:
        return ANSIString(to_unicode(obj))


_unicode = unicode
_whitespace = '\t\n\x0b\x0c\r '
class ANSITextWrapper(TextWrapper):

    def _munge_whitespace(self, text):
        """_munge_whitespace(text : string) -> string

        Munge whitespace in text: expand tabs and convert all other
        whitespace characters to spaces.  Eg. " foo\tbar\n\nbaz"
        becomes " foo    bar  baz".
        """
        # ignore expand_tabs/replace_whitespace until ANSISTring handles them
        return text
        if self.expand_tabs:
            text = text.expandtabs()
        if self.replace_whitespace:
            if isinstance(text, str):
                text = text.translate(self.whitespace_trans)
            elif isinstance(text, _unicode):
                text = text.translate(self.unicode_whitespace_trans)
        return text


    def _split(self, text):
        """_split(text : string) -> [string]

        Split the text to wrap into indivisible chunks.  Chunks are
        not quite the same as words; see _wrap_chunks() for full
        details.  As an example, the text
          Look, goof-ball -- use the -b option!
        breaks into the following chunks:
          'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',
          'use', ' ', 'the', ' ', '-b', ' ', 'option!'
        if break_on_hyphens is True, or in:
          'Look,', ' ', 'goof-ball', ' ', '--', ' ',
          'use', ' ', 'the', ' ', '-b', ' ', option!'
        otherwise.
        """
        # only use unicode wrapper
        if self.break_on_hyphens:
            pat = self.wordsep_re_uni
        else:
            pat = self.wordsep_simple_re_uni
        chunks = pat.split(_to_ansi(text))
        chunks = filter(None, chunks)  # remove empty chunks
        return chunks

    def _wrap_chunks(self, chunks):
        """_wrap_chunks(chunks : [string]) -> [string]

        Wrap a sequence of text chunks and return a list of lines of
        length 'self.width' or less.  (If 'break_long_words' is false,
        some lines may be longer than this.)  Chunks correspond roughly
        to words and the whitespace between them: each chunk is
        indivisible (modulo 'break_long_words'), but a line break can
        come between any two chunks.  Chunks should not have internal
        whitespace; ie. a chunk is either all whitespace or a "word".
        Whitespace chunks will be removed from the beginning and end of
        lines, but apart from that whitespace is preserved.
        """
        lines = []
        if self.width <= 0:
            raise ValueError("invalid width %r (must be > 0)" % self.width)

        # Arrange in reverse order so items can be efficiently popped
        # from a stack of chucks.
        chunks.reverse()

        while chunks:

            # Start the list of chunks that will make up the current line.
            # cur_len is just the length of all the chunks in cur_line.
            cur_line = []
            cur_len = 0

            # Figure out which static string will prefix this line.
            if lines:
                indent = self.subsequent_indent
            else:
                indent = self.initial_indent

            # Maximum width for this line.
            width = self.width - len(indent)

            # First chunk on line is whitespace -- drop it, unless this
            # is the very beginning of the text (ie. no lines started yet).
            if self.drop_whitespace and chunks[-1].strip() == '' and lines:
                del chunks[-1]

            while chunks:
                l = len(chunks[-1])

                # Can at least squeeze this chunk onto the current line.
                if cur_len + l <= width:
                    cur_line.append(chunks.pop())
                    cur_len += l

                # Nope, this line is full.
                else:
                    break

            # The current line is full, and the next chunk is too big to
            # fit on *any* line (not just this one).
            if chunks and len(chunks[-1]) > width:
                self._handle_long_word(chunks, cur_line, cur_len, width)

            # If the last chunk on this line is all whitespace, drop it.
            if self.drop_whitespace and cur_line and cur_line[-1].strip() == '':
                del cur_line[-1]

            # Convert current line back to a string and store it in list
            # of all lines (return value).
            if cur_line:
                l = ""
                for w in cur_line:   # ANSI fix
                    l += w           #
                lines.append(indent + l)
        return lines


# -- Convenience interface ---------------------------------------------

def wrap(text, width=70, **kwargs):
    """Wrap a single paragraph of text, returning a list of wrapped lines.

    Reformat the single paragraph in 'text' so it fits in lines of no
    more than 'width' columns, and return a list of wrapped lines.  By
    default, tabs in 'text' are expanded with string.expandtabs(), and
    all other whitespace characters (including newline) are converted to
    space.  See TextWrapper class for available keyword args to customize
    wrapping behaviour.
    """
    w = ANSITextWrapper(width=width, **kwargs)
    return w.wrap(text)

def fill(text, width=70, **kwargs):
    """Fill a single paragraph of text, returning a new string.

    Reformat the single paragraph in 'text' to fit in lines of no more
    than 'width' columns, and return a new string containing the entire
    wrapped paragraph.  As with wrap(), tabs are expanded and other
    whitespace characters converted to space.  See TextWrapper class for
    available keyword args to customize wrapping behaviour.
    """
    w = ANSITextWrapper(width=width, **kwargs)
    return w.fill(text)

# Cell class (see further down for the EvTable itself)

class Cell(object):
    """
    Holds a single data cell for the table. A cell has a certain width
    and height and contains one or more lines of data. It can shrink
    and resize as needed.
    """
    def __init__(self, data, **kwargs):
        """
        data - the un-padded data of the entry.
        kwargs:
            width - desired width of cell. It will pad
                    to this size.
            height - desired height of cell. it will pad
                    to this size
            pad_width - general padding width. This can be overruled
                       by individual settings below
            pad_left - number of extra pad characters on the left
            pad_right - extra pad characters on the right
            pad_top - extra pad lines top (will pad with vpad_char)
            pad_bottom - extra pad lines bottom (will pad with vpad_char)

            pad_char - pad character to use for padding. This is overruled
                       by individual settings below (default " ")
            hpad_char - pad character to use both for extra horizontal
                      padding (default " ")
            vpad_char - pad character to use for extra vertical padding
                       and for vertical fill (default " ")

            fill_char - character used to filling (expanding cells to
                        desired size). This can be overruled by individual
                        settings below.
            hfill_char - character used for horizontal fill (default " ")
            vfill_char - character used for vertical fill (default " ")

            align - "l", "r" or  "c", default is left-aligned
            valign - "t", "b" or "c", default is centered

            border_width -general border width. This is overruled
                        - by individual settings below.
            border_left - left border width
            border_right - right border width
            border_top - top border width
            border_bottom - bottom border width

            crop_string - string to use when cropping sideways,
                          default is '[...]'
            crop - crop content of cell rather than expand vertically,
                   default=False

            border_char - this will use a single border char for all borders.
                          overruled by individual settings below
            border_left_char - char used for left border
            border_right_char - char used for right border
            border_top_char   - char used for top border
            border_bottom_char - char user for bottom border

            corner_char - character used when two borders cross.
                          (default is ""). This is overruled by
                          individual settings below.
            corner_top_left
            corner_top_right
            corner_bottom_left
            corner_bottom_right

            enforce_size - if true, the width/height of the
                           cell is strictly enforced and
                           extra text will be cropped rather
                           than the cell growing vertically.
        """

        padwidth = kwargs.get("pad_width", None)
        padwidth = int(padwidth) if padwidth is not None else None
        self.pad_left = int(kwargs.get("pad_left", padwidth if padwidth is not None else 1))
        self.pad_right = int(kwargs.get("pad_right", padwidth if padwidth is not None else 1))
        self.pad_top = int( kwargs.get("pad_top", padwidth if padwidth is not None else 0))
        self.pad_bottom = int(kwargs.get("pad_bottom", padwidth if padwidth is not None else 0))

        self.enforce_size = kwargs.get("enforce_size", False)

        # avoid multi-char pad_chars messing up counting
        pad_char = kwargs.get("pad_char", " ")
        pad_char = pad_char[0] if pad_char else " "
        hpad_char = kwargs.get("hpad_char", pad_char)
        self.hpad_char = hpad_char[0] if hpad_char else pad_char
        vpad_char = kwargs.get("vpad_char", pad_char)
        self.vpad_char = vpad_char[0] if vpad_char else pad_char

        fill_char = kwargs.get("fill_char", " ")
        fill_char = fill_char[0] if fill_char else " "
        hfill_char = kwargs.get("hfill_char", fill_char)
        self.hfill_char = hfill_char[0] if hfill_char else " "
        vfill_char = kwargs.get("vfill_char", fill_char)
        self.vfill_char = vfill_char[0] if vfill_char else " "

        self.crop_string = kwargs.get("crop_string", "[...]")

        # borders and corners
        borderwidth = kwargs.get("border_width", 0)
        self.border_left = kwargs.get("border_left", borderwidth)
        self.border_right = kwargs.get("border_right", borderwidth)
        self.border_top = kwargs.get("border_top", borderwidth)
        self.border_bottom = kwargs.get("border_bottom", borderwidth)

        borderchar = kwargs.get("border_char", None)
        self.border_left_char = kwargs.get("border_left_char", borderchar if borderchar else "|")
        self.border_right_char = kwargs.get("border_right_char", borderchar if borderchar else "|")
        self.border_top_char = kwargs.get("border_topchar", borderchar if borderchar else "-")
        self.border_bottom_char = kwargs.get("border_bottom_char", borderchar if borderchar else "-")

        corner = kwargs.get("corner_char", "+")
        self.corner_top_left = kwargs.get("corner_top_left", corner)
        self.corner_top_right = kwargs.get("corner_top_right", corner)
        self.corner_bottom_left = kwargs.get("corner_bottom_left", corner)
        self.corner_bottom_right = kwargs.get("corner_bottom_right", corner)

        # alignments
        self.align = kwargs.get("align", "l")
        self.valign = kwargs.get("valign", "c")

        #self.data = self._split_lines(unicode(data))
        self.data = self._split_lines(_to_ansi(data))
        self.raw_width = max(len(line) for line in self.data)
        self.raw_height = len(self.data)

        # width/height is given without left/right or top/bottom padding
        if "width" in kwargs:
            width = kwargs.pop("width")
            self.width = width - self.pad_left - self.pad_right - self.border_left - self.border_right
            if self.width <= 0:
                raise Exception("Cell width too small - no space for data.")
        else:
            self.width = self.raw_width
        if "height" in kwargs:
            height = kwargs.pop("height")
            self.height = height - self.pad_top - self.pad_bottom - self.border_top - self.border_bottom
            if self.height <= 0:
                raise Exception("Cell height too small - no space for data.")
        else:
            self.height = self.raw_height

        # prepare data
        self.formatted = self._reformat()

    def _crop(self, text, width):
        "Apply cropping of text"
        if len(text) > width:
            crop_string = self.crop_string
            return text[:width-len(crop_string)] + crop_string
        return text

    def _reformat(self):
        "Apply formatting"
        return self._border(self._pad(self._valign(self._align(self._fit_width(self.data)))))

    def _split_lines(self, text):
        "Simply split by linebreak"
        return text.split("\n")

    def _fit_width(self, data):
        """
        Split too-long lines to fit the desired width of the Cell.
        Note that this also updates raw_width
        """
        width = self.width
        adjusted_data = []
        for line in data:
            if 0 < width < len(line):
                # replace_whitespace=False, expand_tabs=False is a
                # fix for ANSIString not supporting expand_tabs/translate
                adjusted_data.extend([ANSIString(part + ANSIString("{n"))
                    for part in wrap(line, width=width, drop_whitespace=False)])
            else:
                adjusted_data.append(line)
        if self.enforce_size:
            # don't allow too high cells
            excess = len(adjusted_data) - self.height
            if excess > 0:
                # too many lines. Crop and mark last line with ...
                adjusted_data = adjusted_data[:-excess]
                if len(adjusted_data[-1]) > 3:
                    adjusted_data[-1] = adjusted_data[-1][:-2] + ".."
            elif excess < 0:
                # too few lines. Fill to height.
                adjusted_data.extend(["" for i in range(excess)])

        return adjusted_data

    def _center(self, text, width, pad_char):
        "Horizontally center text on line of certain width, using padding"
        excess = width - len(text)
        if excess <= 0:
            return text
        if excess % 2:
            # uneven padding
            narrowside = (excess // 2) * pad_char
            widerside = narrowside + pad_char
            if width % 2:
                return narrowside + text + widerside
            else:
                return widerside + text + narrowside
        else:
            # even padding - same on both sides
            side = (excess // 2) * pad_char
            return side + text + side

    def _align(self, data):
        "Align list of rows of cell"
        align = self.align
        if align == "l":
            return [line.ljust(self.width, self.hfill_char) for line in data]
        elif align == "r":
            return [line.rjust(self.width, self.hfill_char) for line in data]
        else:
            return [self._center(line, self.width, self.hfill_char) for line in data]

    def _valign(self, data):
        "align cell vertically"
        valign = self.valign
        height = self.height
        cheight = len(data)
        excess = height - cheight
        padline = self.vfill_char * self.width

        if excess <= 0:
            return data
        # only care if we need to add new lines
        if valign == 't':
            return data + [padline for i in range(excess)]
        elif valign == 'b':
            return [padline for i in range(excess)] + data
        else: # center
            narrowside = [padline  for i in range(excess // 2)]
            widerside = narrowside + [padline]
            if excess % 2:
                # uneven padding
                if height % 2:
                    return widerside + data + narrowside
                else:
                    return narrowside + data + widerside
            else:
                # even padding, same on both sides
                return narrowside + data + narrowside

    def _pad(self, data):
        "Pad data with extra characters on all sides"
        left = self.hpad_char * self.pad_left
        right = self.hpad_char * self.pad_right
        vfill = (self.width + self.pad_left + self.pad_right) * self.vpad_char
        top = [vfill for i in range(self.pad_top)]
        bottom = [vfill for i in range(self.pad_bottom)]
        return top + [left + line + right for line in data] + bottom

    def _border(self, data):
        "Add borders to the cell"

        left = self.border_left_char * self.border_left
        right = self.border_right_char * self.border_right

        cwidth = self.width + self.pad_left + self.pad_right + \
                 max(0,self.border_left-1) + max(0, self.border_right-1)

        vfill = self.corner_top_left if left else ""
        vfill += cwidth * self.border_top_char
        vfill += self.corner_top_right if right else ""
        top = [vfill for i in range(self.border_top)]

        vfill = self.corner_bottom_left if left else ""
        vfill += cwidth * self.border_bottom_char
        vfill += self.corner_bottom_right if right else ""
        bottom = [vfill for i in range(self.border_bottom)]

        return top + [left + line + right for line in data] + bottom

    def get_min_height(self):
        """
        Get the minimum possible height of cell, including at least
        one line for data.
        """
        return self.pad_top + self.pad_bottom + self.border_bottom + self.border_top + 1

    def get_min_width(self):
        """
        Get the minimum possible width of cell, including at least one
        character-width for data.
        """
        return self.pad_left + self.pad_right + self.border_left + self.border_right + 1

    def get_height(self):
        "Get natural height of cell, including padding"
        return len(self.formatted)

    def get_width(self):
        "Get natural width of cell, including padding"
        return len(self.formatted[0]) if self.formatted else 0

    def replace_data(self, data, **kwargs):
        """
        Replace cell data. This causes a full reformat of the cell.

        kwargs - like when creating the cell anew.
        """
        #self.data = self._split_lines(unicode(data))
        self.data = self._split_lines(_to_ansi(data))
        self.raw_width = max(len(line) for line in self.data)
        self.raw_height = len(self.data)
        self.reformat(**kwargs)

    def reformat(self, **kwargs):
        """
        Reformat the Cell with new options
        kwargs:
            as the class __init__
        """

        # keywords that require manipulation

        padwidth = kwargs.get("pad_width", None)
        padwidth = int(padwidth) if padwidth is not None else None
        self.pad_left = int(kwargs.get("pad_left", padwidth if padwidth is not None else self.pad_left))
        self.pad_right = int(kwargs.get("pad_right", padwidth if padwidth is not None else self.pad_right))
        self.pad_top = int( kwargs.get("pad_top", padwidth if padwidth is not None else self.pad_top))
        self.pad_bottom = int(kwargs.get("pad_bottom", padwidth if padwidth is not None else self.pad_bottom))

        padchar = kwargs.pop("pad_char", None)
        hpad_char = kwargs.pop("hpad_char", padchar)
        self.hpad_char = hpad_char[0] if hpad_char else self.hpad_char
        vpad_char = kwargs.pop("vpad_char", padchar)
        self.vpad_char = vpad_char[0] if vpad_char else self.vpad_char

        fillchar = kwargs.pop("fill_char", None)
        hfill_char = kwargs.pop("hfill_char", fillchar)
        self.hfill_char = hfill_char[0] if hfill_char else self.hfill_char
        vfill_char = kwargs.pop("vfill_char", fillchar)
        self.vfill_char = vfill_char[0] if vfill_char else self.vfill_char

        borderwidth = kwargs.get("border_width", None)
        self.border_left = kwargs.pop("border_left", borderwidth if borderwidth is not None else self.border_left)
        self.border_right = kwargs.get("border_right", borderwidth if borderwidth is not None else self.border_right)
        self.border_top = kwargs.get("border_top", borderwidth if borderwidth is not None else self.border_top)
        self.border_bottom = kwargs.get("border_bottom", borderwidth if borderwidth is not None else self.border_bottom)

        borderchar = kwargs.get("border_char", None)
        self.border_left_char = kwargs.get("border_left_char", borderchar if borderchar else self.border_left_char)
        self.border_right_char = kwargs.get("border_right_char", borderchar if borderchar else self.border_right_char)
        self.border_top_char = kwargs.get("border_topchar", borderchar if borderchar else self.border_top_char)
        self.border_bottom_char = kwargs.get("border_bottom_char", borderchar if borderchar else self.border_bottom_char)

        corner = kwargs.get("corner_char", None)
        self.corner_top_left = kwargs.get("corner_top_left", corner if corner is not None else self.corner_top_left)
        self.corner_top_right = kwargs.get("corner_top_right", corner if corner is not None else self.corner_top_right)
        self.corner_bottom_left = kwargs.get("corner_bottom_left", corner if corner is not None else self.corner_bottom_left)
        self.corner_bottom_right = kwargs.get("corner_bottom_right", corner if corner is not None else self.corner_bottom_right)

        # fill all other properties
        for key, value in kwargs.items():
            setattr(self, key, value)

        # Handle sizes
        if "width" in kwargs:
            width = kwargs.pop("width")
            self.width = width - self.pad_left - self.pad_right - self.border_left - self.border_right
            if self.width <= 0:
                raise Exception("Cell width too small, no room for data.")
        if "height" in kwargs:
            height = kwargs.pop("height")
            self.height = height - self.pad_top - self.pad_bottom - self.border_top - self.border_bottom
            if self.height <= 0:
                raise Exception("Cell height too small, no room for data.")

        # reformat (to new sizes, padding, header and borders)
        self.formatted = self._reformat()

    def get(self):
        """
        Get data, padded and aligned in the form of a list of lines.
        """
        return self.formatted

    def __str__(self):
        "returns cell contents on string form"
        return ANSIString("\n").join(self.formatted)

    def __unicode__(self):
        "returns cell contents"
        return unicode(ANSIString("\n").join(self.formatted))


## Main Evtable class

class EvTable(object):
    """
    Table class.

    This table implements an ordered grid of Cells, with
    all cell boundaries lining up.
    """

    def __init__(self, *args, **kwargs):
        """
         Args:
            headers for the table

         Keywords:
            table - list of columns (list of lists) for seeding
                    the table. If not given, the table will start
                    out empty
            header - True/False - turn off header being treated
                    as a header (like extra underlining)

            pad_width - how much empty space to pad your cells with
                        (default is 1)
            border - None, or one of
                    "table" - only a border around the whole table
                    "tablecols" - table and column borders
                    "header" - only border under header
                    "cols" - only vertical borders
                    "incols" - vertical borders, no outer edges
                    "rows" - only borders between rows
                    "cells" - border around all cells
            border_width - width of table borders, if border is active.
                          Note that widths wider than 1 may give artifacts in the
                          corners. Default is 1.
            corner_char - character to use in corners when border is
                          active.
            corner_top_left - character to use in upper left corner of table
                                (defaults to corner_char)
            corner_top_right
            corner_bottom_left
            corner_bottom_right
            pretty_corners - (default True): use custom characters to make
                             the table corners look "rounded". Uses UTF-8
                             characters.

            header_line_char - characters to use for underlining
                                    the header row (default is '~')
                                    Requires border to be active.

            width - fixed width of table. If not set, width is
                    set by the total width of each column.
                    This will resize individual columns in
                    the vertical direction to fit.
            height - fixed height of table. Defaults to unset.
                     Width is still given precedence. If
                     height is given, table cells will crop
                     text rather than expand vertically.
            evenwidth - (default False). Used with the width keyword.
                     Adjusts collumns to have as even width as
                     possible. This often looks best also for
                     mixed-length tables.
            maxwidth - This will set a maximum width of the table
                    while allowing it to be smaller. Only if it
                    grows wider than this size will it be resized.
                    This has no meaning if width is set.

            See Cell class for further kwargs. These will be passed
            to each cell in the table.

        """
        # table itself is a 2D grid - a list of columns
        # x is the column position, y the row
        self.table = kwargs.pop("table", [])

        # header is a list of texts. We merge it to the table's top
        header = list(args)
        self.header = header != []
        if self.header:
            if self.table:
                excess = len(header) - len(self.table)
                if excess > 0:
                    # header bigger than table
                    self.table.extend([] for i in range(excess))
                elif excess < 0:
                    # too short header
                    header.extend(_to_ansi(["" for i in range(abs(excess))]))
                for ix, heading in enumerate(header):
                    self.table[ix].insert(0, heading)
            else:
                self.table = [[heading] for heading in header]
        # even though we inserted the header, we can still turn off
        # header border underling etc. We only allow this if a header
        # was actually set
        self.header = kwargs.pop("header", self.header) if self.header else False
        hchar = kwargs.pop("header_line_char", "~")
        self.header_line_char = hchar[0] if hchar else "~"

        border = kwargs.pop("border", "tablecols")
        if border is None:
            border = "none"
        if not border in ("none", "table", "tablecols",
                          "header", "incols", "cols", "rows", "cells"):
            raise Exception("Unsupported border type: '%s'" % border)
        self.border = border

        # border settings are passed into Cell as well (so kwargs.get and not pop)
        self.border_width = kwargs.get("border_width", 1)
        self.corner_char = kwargs.get("corner_char", "+")
        pcorners = kwargs.pop("pretty_corners", False)
        self.corner_top_left = _to_ansi(kwargs.pop("corner_top_left", '.' if pcorners else  self.corner_char))
        self.corner_top_right = _to_ansi(kwargs.pop("corner_top_right", '.' if pcorners else self.corner_char))
        self.corner_bottom_left = _to_ansi(kwargs.pop("corner_bottom_left", ' ' if pcorners else self.corner_char))
        self.corner_bottom_right = _to_ansi(kwargs.pop("corner_bottom_right", ' ' if pcorners else self.corner_char))

        self.width = kwargs.pop("width", None)
        self.height = kwargs.pop("height", None)
        self.evenwidth = kwargs.pop("evenwidth", False)
        self.maxwidth = kwargs.pop("maxwidth", None)
        if self.maxwidth and self.width and self.maxwidth < self.width:
            raise Exception("table maxwidth < table width!")
        # size in cell cols/rows
        self.ncols = 0
        self.nrows = 0
        # size in characters
        self.nwidth = 0
        self.nheight = 0
        # save options
        self.options = kwargs

        if self.table:
            # generate the table on the fly
            self.table = [[Cell(data, **kwargs) for data in col] for col in self.table]

        # this is the actual working table
        self.worktable = None

        # balance the table
        self._balance()

    def _cellborders(self, ix, iy, nx, ny, kwargs):
        """
        Adds borders to the table by adjusting the input
        kwarg to instruct cells to build a border in
        the right positions. Returns a copy of the
        kwarg to return to the cell. This is called
        by self._borders.
        """

        ret = kwargs.copy()

        def corners(ret):
            "Handle corners of table"
            if ix == 0 and iy == 0:
                ret["corner_top_left"] = self.corner_top_left
            if ix == nx and iy == 0:
                ret["corner_top_right"] = self.corner_top_right
            if ix == 0 and iy == ny:
                ret["corner_bottom_left"] = self.corner_bottom_left
            if ix == nx and iy == ny:
                ret["corner_bottom_right"] = self.corner_bottom_right
            return ret

        def left_edge(ret):
            "add vertical border along left table edge"
            if ix == 0:
                ret["border_left"] = bwidth
            return ret

        def top_edge(ret):
            "add border along top table edge"
            if iy == 0:
                ret["border_top"] = bwidth
            return ret

        def right_edge(ret):
            "add vertical border along right table edge"
            if ix == nx:# and 0 < iy < ny:
                ret["border_right"] = bwidth
            return ret

        def bottom_edge(ret):
            "add border along bottom table edge"
            if iy == ny:
                ret["border_bottom"] = bwidth
            return ret

        def cols(ret):
            "Adding vertical borders inside the table"
            if 0 <= ix < nx:
                ret["border_right"] = bwidth
            return ret

        def rows(ret):
            "Adding horizontal borders inside the table"
            if 0 <= iy < ny:
                ret["border_bottom"] = bwidth
            return ret

        def head(ret):
            "Add header underline"
            if iy == 0:
                # put different bottom line for header
                ret["border_bottom"] = bwidth
                ret["border_bottom_char"] = headchar
            return ret


        # handle the various border modes
        border = self.border
        header = self.header

        bwidth = self.border_width
        headchar = self.header_line_char

        # use the helper functions to define various
        # table "styles"

        if border in ("table", "tablecols","cells"):
            ret = bottom_edge(right_edge(top_edge(left_edge(corners(ret)))))
        if border in ("cols", "tablecols", "cells"):
            ret = cols(right_edge(left_edge(ret)))
        if border in ("incols"):
            ret = cols(ret)
        if border in ("rows", "cells"):
            ret = rows(bottom_edge(top_edge(ret)))
        if header and not border in ("none", None):
            ret = head(ret)

        return ret

    def _borders(self):
        """
        Add borders to table. This is called from self._balance
        """
        nx, ny = self.ncols-1, self.nrows-1
        options = self.options
        for ix, col in enumerate(self.worktable):
            for iy, cell in enumerate(col):
                cell.reformat(**self._cellborders(ix,iy,nx,ny,options))

    def _balance(self):
        """
        Balance the table. This means to make sure
        all cells on the same row have the same height,
        that all columns have the same number of rows
        and that the table fits within the given width.
        """

        # we make all modifications on a working copy of the
        # actual table. This allows us to add columns/rows
        # and re-balance over and over without issue.
        self.worktable = deepcopy(self.table)
        options = copy(self.options)

        # balance number of rows
        ncols = len(self.worktable)
        nrows = [len(col) for col in self.worktable]
        nrowmax = max(nrows) if nrows else 0
        for icol, nrow in enumerate(nrows):
            if nrow < nrowmax:
                # add more rows
                self.worktable[icol].extend([Cell("", **self.options) for i in range(nrowmax-nrow)])

        self.ncols = ncols
        self.nrows = nrowmax

        # add borders - these add to the width/height, so we must do this before calculating width/height
        self._borders()

        # equalize widths within each column
        cwidths = [max(cell.get_width() for cell in col) for col in self.worktable]

        if self.width or self.maxwidth and self.maxwidth < sum(cwidths):
            # we set a table width. Horizontal cells will be evenly distributed and
            # expand vertically as needed (unless self.height is set, see below)

            # use fixed width, or set to maxwidth
            width = self.width if self.width else self.maxwidth

            if ncols:
                # get minimum possible cell widths for each row
                cwidths_min = [max(cell.get_min_width() for cell in col) for col in self.worktable]
                cwmin = sum(cwidths_min)

                if cwmin > width:
                    # we cannot shrink any more
                    raise Exception("Cannot shrink table width to %s. Minimum size is %s." % (self.width, cwmin))

                excess = width - cwmin
                if self.evenwidth:
                    # make each collumn of equal width
                    for i in range(excess):
                        # flood-fill the minimum table starting with the smallest collumns
                        ci = cwidths_min.index(min(cwidths_min))
                        cwidths_min[ci] += 1
                    cwidths = cwidths_min
                else:
                    # make each collumn expand more proportional to their data size
                    for i in range(excess):
                        # fill wider collumns first
                        ci = cwidths.index(max(cwidths))
                        cwidths_min[ci] += 1
                        cwidths[ci] -= 3
                    cwidths = cwidths_min

        # reformat worktable (for width align)
        for ix, col in enumerate(self.worktable):
            for iy, cell in enumerate(col):
                try:
                    cell.reformat(width=cwidths[ix], **options)
                except Exception, e:
                    msg = "ix=%s, iy=%s, width=%s: %s" % (ix, iy, cwidths[ix], e.message)
                    raise Exception ("Error in horizontal allign:\n %s" % msg)

        # equalize heights for each row (we must do this here, since it may have changed to fit new widths)
        cheights = [max(cell.get_height() for cell in (col[iy] for col in self.worktable)) for iy in range(nrowmax)]

        if self.height:
            # if we are fixing the table height, it means cells must crop text instead of resizing.
            if nrowmax:

                # get minimum possible cell heights for each collumn
                cheights_min = [max(cell.get_min_height() for cell in (col[iy] for col in self.worktable)) for iy in range(nrowmax)]
                chmin = sum(cheights_min)
                #print "cheights_min:", cheights_min

                if chmin > self.height:
                    # we cannot shrink any more
                    raise Exception("Cannot shrink table height to %s. Minimum size is %s." % (self.height, chmin))

                # now we add all the extra height up to the desired table-height.
                # We do this so that the tallest cells gets expanded first (and
                # thus avoid getting cropped)

                excess = self.height - chmin
                even = self.height % 2 == 0
                for i in range(excess):
                    # expand the cells with the most rows first
                    if 0 <= i < nrowmax and nrowmax > 1:
                        # avoid adding to header first round (looks bad on very small tables)
                        ci = cheights[1:].index(max(cheights[1:])) + 1
                    else:
                        ci = cheights.index(max(cheights))
                    cheights_min[ci] += 1
                    if ci == 0 and self.header:
                        # it doesn't look very good if header expands too fast
                        cheights[ci] -= 2 if even else 3
                    cheights[ci] -= 2 if even else 1
                cheights = cheights_min

                # we must tell cells to crop instead of expanding
            options["enforce_size"] = True
        #print "cheights2:", cheights

        # reformat table (for vertical align)
        for ix, col in enumerate(self.worktable):
            for iy, cell in enumerate(col):
                try:
                    cell.reformat(height=cheights[iy], **options)
                except Exception, e:
                    msg = "ix=%s, iy=%s, height=%s: %s" % (ix, iy, cheights[iy], e.message)
                    raise Exception ("Error in vertical allign:\n %s" % msg)

        # calculate actual table width/height in characters
        self.cwidth = sum(cwidths)
        self.cheight = sum(cheights)
        #print "actual table width, height:", self.cwidth, self.cheight, self.width, self.height

    def _generate_lines(self):
        """
        Generates lines across all columns
        (each cell may contain multiple lines)
        Before calling, the table must be
        balanced.
        """
        for iy in range(self.nrows):
            cell_row = [col[iy] for col in self.worktable]
            # this produces a list of lists, each of equal length
            cell_data = [cell.get() for cell in cell_row]
            cell_height = min(len(lines) for lines in cell_data)
            for iline in range(cell_height):
                yield ANSIString("").join(_to_ansi(celldata[iline] for celldata in cell_data))

    def add_header(self, *args, **kwargs):
        """
        Add header to table. This is a number of texts to
        be put at the top of the table. They will replace
        an existing header.
        """
        self.header = True
        self.add_row(ypos=0, *args, **kwargs)

    def add_column(self, *args, **kwargs):
        """
        Add a column to table. If there are more
        rows in new column than there are rows in the
        current table, the table will expand with
        empty rows in the other columns. If too few,
        the new column with get new empty rows. All
        filling rows are added to the end.
        keyword-
            header - the header text for the column
            xpos - index position in table before which
                   to input new column. If not given,
                   column will be added to the end. Uses
                   Python indexing (so first column is xpos=0)
        See Cell class for other keyword arguments
        """
        # this will replace default options with new ones without changing default
        options = dict(self.options.items() + kwargs.items())

        xpos = kwargs.get("xpos", None)
        column = [Cell(data, **options) for data in args]
        htable = self.nrows
        excess = self.ncols - htable

        if excess > 0:
            # we need to add new rows to table
            for col in self.table:
                col.extend([Cell("", **options) for i in range(excess)])
        elif excess < 0:
            # we need to add new rows to new column
            column.extend([Cell("", **options) for i in range(abs(excess))])

        header = kwargs.get("header", None)
        if header:
            column.insert(0, Cell(unicode(header), **options))
            self.header = True
        elif self.header:
            # we have a header already. Offset
            column.insert(0, Cell("", **options))
        if xpos is None or xpos > len(self.table) - 1:
            # add to the end
            self.table.append(column)
        else:
            # insert column
            xpos = min(len(self.table)-1, max(0, int(xpos)))
            self.table.insert(xpos, column)
        self._balance()

    def add_row(self, *args, **kwargs):
        """
        Add a row to table (not a header). If there are
        more cells in the given row than there are cells
        in the current table the table will be expanded
        with empty columns to match. These will be added
        to the end of the table. In the same way, adding
        a line with too few cells will lead to the last
        ones getting padded.
        keyword
          ypos - index position in table before which to
                 input new row. If not given, will be added
                 to the end. Uses Python indexing (so first row is
                 ypos=0)
        See Cell class for other keyword arguments
        """
        # this will replace default options with new ones without changing default
        options = dict(self.options.items() + kwargs.items())

        ypos = kwargs.get("ypos", None)
        row = [Cell(data, **options) for data in args]
        htable = len(self.table[0]) # assuming balanced table
        excess = len(row) - len(self.table)

        if excess > 0:
            # we need to add new empty columns to table
            self.table.extend([[Cell("", **options) for i in range(htable)] for k in range(excess)])
        elif excess < 0:
            # we need to add more cells to row
            row.extend([Cell("", **options) for i in range(abs(excess))])

        if ypos is None or ypos > htable - 1:
            # add new row to the end
            for icol, col in enumerate(self.table):
                col.append(row[icol])
        else:
            # insert row elsewhere
            ypos = min(htable-1, max(0, int(ypos)))
            for icol, col in enumerate(self.table):
                col.insert(ypos, row[icol])
        self._balance()

    def reformat(self, **kwargs):
        """
        Force a re-shape of the entire table
        """
        self.width = kwargs.pop("width", self.width)
        self.height = kwargs.pop("height", self.height)
        for key, value in kwargs.items():
            setattr(self, key, value)

        hchar = kwargs.pop("header_line_char", self.header_line_char)

        # border settings are also passed on into Cells (so kwargs.get, not kwargs.pop)
        self.header_line_char = hchar[0] if hchar else self.header_line_char
        self.border_width = kwargs.get("border_width", self.border_width)
        self.corner_char = kwargs.get("corner_char", self.corner_char)
        self.header_line_char = kwargs.get("header_line_char", self.header_line_char)

        self.corner_top_left = _to_ansi(kwargs.pop("corner_top_left", self.corner_char))
        self.corner_top_right = _to_ansi(kwargs.pop("corner_top_right", self.corner_char))
        self.corner_bottom_left = _to_ansi(kwargs.pop("corner_bottom_left", self.corner_char))
        self.corner_bottom_right = _to_ansi(kwargs.pop("corner_bottom_right", self.corner_char))

        self.options.update(kwargs)
        self._balance()

    def get(self):
        """
        Return lines of table as a list
        """
        return [line for line in self._generate_lines()]

    def __str__(self):
        "print table"
        return  ANSIString("\n").join([line for line in self._generate_lines()])

    def __unicode__(self):
        return  unicode(ANSIString("\n").join([line for line in self._generate_lines()]))

def _test():
    "Test"
    table = EvTable("{yHeading1{n", "{gHeading2{n", table=[[1,2,3],[4,5,6],[7,8,9]], border="cells")
    table.add_column("{rThis is long data{n", "{bThis is even longer data{n")
    table.add_row("This is a single row")
    print unicode(table)
    table.reformat(width=50)
    print unicode(table)




########NEW FILE########
__FILENAME__ = gametime
"""
The gametime module handles the global passage of time in the mud.

It also supplies some useful methods to convert between
in-mud time and real-world time as well allows to get the
total runtime of the server and the current uptime.
"""

from time import time
from django.conf import settings
from src.scripts.scripts import Script
from src.utils.create import create_script

GAMETIME_SCRIPT_NAME = "sys_game_time"

# Speed-up factor of the in-game time compared
# to real time.

TIMEFACTOR = settings.TIME_FACTOR

# Common real-life time measure, in seconds.
# You should not change this.

REAL_MIN = 60.0  # seconds per minute in real world

# Game-time units, in real-life seconds. These are supplied as
# a convenient measure for determining the current in-game time,
# e.g. when defining in-game events. The words month, week and year can
# be used to mean whatever units of time are used in the game.

MIN = settings.TIME_SEC_PER_MIN
HOUR = MIN * settings.TIME_MIN_PER_HOUR
DAY = HOUR * settings.TIME_HOUR_PER_DAY
WEEK = DAY * settings.TIME_DAY_PER_WEEK
MONTH = WEEK * settings.TIME_WEEK_PER_MONTH
YEAR = MONTH * settings.TIME_MONTH_PER_YEAR

# Cached time stamps
SERVER_STARTTIME = time()
SERVER_RUNTIME = 0.0


class GameTime(Script):
    """
    This script repeatedly saves server times so
    it can be retrieved after server downtime.
    """
    def at_script_creation(self):
        """
        Setup the script
        """
        self.key = GAMETIME_SCRIPT_NAME
        self.desc = "Saves uptime/runtime"
        self.interval = 60
        self.persistent = True
        self.start_delay = True
        self.attributes.add("run_time", 0.0)  # OOC time
        self.attributes.add("up_time", 0.0)  # OOC time

    def at_repeat(self):
        """
        Called every minute to update the timers.
        """
        self.attributes.add("run_time", runtime())
        self.attributes.add("up_time", uptime())

    def at_start(self):
        """
        This is called once every server restart.
        We reset the up time and load the relevant
        times.
        """
        global SERVER_RUNTIME
        SERVER_RUNTIME = self.attributes.get("run_time")

def save():
    "Force save of time. This is called by server when shutting down/reloading."
    from src.scripts.models import ScriptDB
    try:
        script = ScriptDB.objects.get(db_key=GAMETIME_SCRIPT_NAME)
        script.at_repeat()
    except Exception:
        from src.utils import logger
        logger.log_trace()

def _format(seconds, *divisors) :
    """
    Helper function. Creates a tuple of even dividends given
    a range of divisors.

    Inputs
      seconds - number of seconds to format
      *divisors - a number of integer dividends. The number of seconds will be
                  integer-divided by the first number in this sequence, the remainder
                  will be divided with the second and so on.
    Output:
        A tuple of length len(*args)+1, with the last element being the last remaining
        seconds not evenly divided by the supplied dividends.

    """
    results = []
    seconds = int(seconds)
    for divisor in divisors:
        results.append(seconds / divisor)
        seconds %= divisor
    results.append(seconds)
    return tuple(results)


# Access functions

def runtime(format=False):
    "Get the total runtime of the server since first start (minus downtimes)"
    runtime = SERVER_RUNTIME + (time() - SERVER_STARTTIME)
    if format:
        return _format(runtime, 31536000, 2628000, 604800, 86400, 3600, 60)
    return runtime

def uptime(format=False):
    "Get the current uptime of the server since last reload"
    uptime = time() - SERVER_STARTTIME
    if format:
        return _format(uptime, 31536000, 2628000, 604800, 86400, 3600, 60)
    return uptime

def gametime(format=False):
    "Get the total gametime of the server since first start (minus downtimes)"
    gametime = runtime() * TIMEFACTOR
    if format:
        return _format(gametime, YEAR, MONTH, WEEK, DAY, HOUR, MIN)
    return gametime


def gametime_to_realtime(secs=0, mins=0, hrs=0, days=0,
                         weeks=0, months=0, yrs=0, format=False):
    """
    This method helps to figure out the real-world time it will take until an
    in-game time has passed. E.g. if an event should take place a month later
    in-game, you will be able to find the number of real-world seconds this
    corresponds to (hint: Interval events deal with real life seconds).

    Example:
     gametime_to_realtime(days=2) -> number of seconds in real life from
                                now after which 2 in-game days will have passed.
    """
    realtime = (secs + mins * MIN + hrs * HOUR + days * DAY + weeks * WEEK + \
                months * MONTH + yrs * YEAR) / TIMEFACTOR
    if format:
        return _format(realtime, 31536000, 2628000, 604800, 86400, 3600, 60)
    return realtime


def realtime_to_gametime(secs=0, mins=0, hrs=0, days=0,
                         weeks=0, months=0, yrs=0, format=False):
    """
    This method calculates how much in-game time a real-world time
    interval would correspond to. This is usually a lot less interesting
    than the other way around.

     Example:
      realtime_to_gametime(days=2) -> number of game-world seconds
                                      corresponding to 2 real days.
    """
    gametime = TIMEFACTOR * (secs + mins * 60 + hrs * 3600 + days * 86400 +
                             weeks * 604800 + months * 2628000 + yrs * 31536000)
    if format:
        return _format(gametime, YEAR, MONTH, WEEK, DAY, HOUR, MIN)
    return gametime


# Time administration routines

def init_gametime():
    """
    This is called once, when the server starts for the very first time.
    """
    # create the GameTime script and start it
    game_time = create_script(GameTime)
    game_time.start()

########NEW FILE########
__FILENAME__ = base
"""
Django ID mapper

Modified for Evennia by making sure that no model references
leave caching unexpectedly (no use of WeakRefs).

Also adds cache_size() for monitoring the size of the cache.
"""

import os, threading
#from twisted.internet import reactor
#from twisted.internet.threads import blockingCallFromThread
from twisted.internet.reactor import callFromThread
from django.core.exceptions import ObjectDoesNotExist, FieldError
from django.db.models.base import Model, ModelBase
from django.db.models.signals import post_save, pre_delete, post_syncdb
from src.utils.utils import dbref, get_evennia_pids, to_str

from manager import SharedMemoryManager

_FIELD_CACHE_GET = None
_FIELD_CACHE_SET = None
_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__


# determine if our current pid is different from the server PID (i.e.
# if we are in a subprocess or not)
from src import PROC_MODIFIED_OBJS

# get info about the current process and thread
_SELF_PID = os.getpid()
_SERVER_PID, _PORTAL_PID = get_evennia_pids()
_IS_SUBPROCESS = (_SERVER_PID and _PORTAL_PID) and not _SELF_PID in (_SERVER_PID, _PORTAL_PID)
_IS_MAIN_THREAD = threading.currentThread().getName() == "MainThread"

#_SERVER_PID = None
#_PORTAL_PID = None
#        #global _SERVER_PID, _PORTAL_PID, _IS_SUBPROCESS, _SELF_PID
#        if not _SERVER_PID and not _PORTAL_PID:
#            _IS_SUBPROCESS = (_SERVER_PID and _PORTAL_PID) and not _SELF_PID in (_SERVER_PID, _PORTAL_PID)

class SharedMemoryModelBase(ModelBase):
    # CL: upstream had a __new__ method that skipped ModelBase's __new__ if
    # SharedMemoryModelBase was not in the model class's ancestors. It's not
    # clear what was the intended purpose, but skipping ModelBase.__new__
    # broke things; in particular, default manager inheritance.

    def __call__(cls, *args, **kwargs):
        """
        this method will either create an instance (by calling the default implementation)
        or try to retrieve one from the class-wide cache by infering the pk value from
        args and kwargs. If instance caching is enabled for this class, the cache is
        populated whenever possible (ie when it is possible to infer the pk value).
        """
        def new_instance():
            return super(SharedMemoryModelBase, cls).__call__(*args, **kwargs)

        instance_key = cls._get_cache_key(args, kwargs)
        # depending on the arguments, we might not be able to infer the PK, so in that case we create a new instance
        if instance_key is None:
            return new_instance()

        cached_instance = cls.get_cached_instance(instance_key)
        if cached_instance is None:
            cached_instance = new_instance()
            cls.cache_instance(cached_instance)
        return cached_instance


    def _prepare(cls):
        cls.__instance_cache__ = {}  #WeakValueDictionary()
        super(SharedMemoryModelBase, cls)._prepare()

    def __new__(cls, classname, bases, classdict, *args, **kwargs):
        """
        Field shortcut creation:
        Takes field names db_* and creates property wrappers named without the db_ prefix. So db_key -> key
        This wrapper happens on the class level, so there is no overhead when creating objects. If a class
        already has a wrapper of the given name, the automatic creation is skipped. Note: Remember to
        document this auto-wrapping in the class header, this could seem very much like magic to the user otherwise.
        """
        def create_wrapper(cls, fieldname, wrappername, editable=True, foreignkey=False):
            "Helper method to create property wrappers with unique names (must be in separate call)"
            def _get(cls, fname):
                "Wrapper for getting database field"
                #print "_get:", fieldname, wrappername,_GA(cls,fieldname)
                return _GA(cls, fieldname)
            def _get_foreign(cls, fname):
                "Wrapper for returing foreignkey fields"
                value = _GA(cls, fieldname)
                #print "_get_foreign:value:", value
                try:
                    return _GA(value, "typeclass")
                except:
                    return value
            def _set_nonedit(cls, fname, value):
                "Wrapper for blocking editing of field"
                raise FieldError("Field %s cannot be edited." % fname)
            def _set(cls, fname, value):
                "Wrapper for setting database field"
                _SA(cls, fname, value)
                # only use explicit update_fields in save if we actually have a
                # primary key assigned already (won't be set when first creating object)
                update_fields = [fname] if _GA(cls, "_get_pk_val")(_GA(cls, "_meta")) is not None else None
                _GA(cls, "save")(update_fields=update_fields)
            def _set_foreign(cls, fname, value):
                "Setter only used on foreign key relations, allows setting with #dbref"
                try:
                    value = _GA(value, "dbobj")
                except AttributeError:
                    pass
                if isinstance(value, (basestring, int)):
                    value = to_str(value, force_string=True)
                    if (value.isdigit() or value.startswith("#")):
                        # we also allow setting using dbrefs, if so we try to load the matching object.
                        # (we assume the object is of the same type as the class holding the field, if
                        # not a custom handler must be used for that field)
                        dbid = dbref(value, reqhash=False)
                        if dbid:
                            model = _GA(cls, "_meta").get_field(fname).model
                            try:
                                value = model._default_manager.get(id=dbid)
                            except ObjectDoesNotExist:
                                # maybe it is just a name that happens to look like a dbid
                                pass
                _SA(cls, fname, value)
                # only use explicit update_fields in save if we actually have a
                # primary key assigned already (won't be set when first creating object)
                update_fields = [fname] if _GA(cls, "_get_pk_val")(_GA(cls, "_meta")) is not None else None
                _GA(cls, "save")(update_fields=update_fields)
            def _del_nonedit(cls, fname):
                "wrapper for not allowing deletion"
                raise FieldError("Field %s cannot be edited." % fname)
            def _del(cls, fname):
                "Wrapper for clearing database field - sets it to None"
                _SA(cls, fname, None)
                update_fields = [fname] if _GA(cls, "_get_pk_val")(_GA(cls, "_meta")) is not None else None
                _GA(cls, "save")(update_fields=update_fields)

            # wrapper factories
            fget = lambda cls: _get(cls, fieldname)
            if not editable:
                fset = lambda cls, val: _set_nonedit(cls, fieldname, val)
            elif foreignkey:
                fget = lambda cls: _get_foreign(cls, fieldname)
                fset = lambda cls, val: _set_foreign(cls, fieldname, val)
            else:
                fset = lambda cls, val: _set(cls, fieldname, val)
            fdel = lambda cls: _del(cls, fieldname) if editable else _del_nonedit(cls,fieldname)
            # assigning
            classdict[wrappername] = property(fget, fset, fdel)
            #type(cls).__setattr__(cls, wrappername, property(fget, fset, fdel))#, doc))

        # exclude some models that should not auto-create wrapper fields
        if cls.__name__ in ("ServerConfig", "TypeNick"):
            return
        # dynamically create the wrapper properties for all fields not already handled (manytomanyfields are always handlers)
        for fieldname, field in ((fname, field) for fname, field in classdict.items()
                                  if fname.startswith("db_") and type(field).__name__ != "ManyToManyField"):
            foreignkey = type(field).__name__ == "ForeignKey"
            #print fieldname, type(field).__name__, field
            wrappername = "dbid" if fieldname == "id" else fieldname.replace("db_", "", 1)
            if wrappername not in classdict:
                # makes sure not to overload manually created wrappers on the model
                #print "wrapping %s -> %s" % (fieldname, wrappername)
                create_wrapper(cls, fieldname, wrappername, editable=field.editable, foreignkey=foreignkey)
        return super(SharedMemoryModelBase, cls).__new__(cls, classname, bases, classdict, *args, **kwargs)

    #def __init__(cls, *args, **kwargs):
    #    """
    #    Field shortcut creation:
    #    Takes field names db_* and creates property wrappers named without the db_ prefix. So db_key -> key
    #    This wrapper happens on the class level, so there is no overhead when creating objects. If a class
    #    already has a wrapper of the given name, the automatic creation is skipped. Note: Remember to
    #    document this auto-wrapping in the class header, this could seem very much like magic to the user otherwise.
    #    """
    #    super(SharedMemoryModelBase, cls).__init__(*args, **kwargs)
    #    def create_wrapper(cls, fieldname, wrappername, editable=True):
    #        "Helper method to create property wrappers with unique names (must be in separate call)"
    #        def _get(cls, fname):
    #            "Wrapper for getting database field"
    #            value = _GA(cls, fieldname)
    #            if type(value) in (basestring, int, float, bool):
    #                return value
    #            elif hasattr(value, "typeclass"):
    #                return _GA(value, "typeclass")
    #            return value
    #        def _set_nonedit(cls, fname, value):
    #            "Wrapper for blocking editing of field"
    #            raise FieldError("Field %s cannot be edited." % fname)
    #        def _set(cls, fname, value):
    #            "Wrapper for setting database field"
    #            #print "_set:", fname
    #            if hasattr(value, "dbobj"):
    #                value = _GA(value, "dbobj")
    #            elif isinstance(value, basestring) and (value.isdigit() or value.startswith("#")):
    #                # we also allow setting using dbrefs, if so we try to load the matching object.
    #                # (we assume the object is of the same type as the class holding the field, if
    #                # not a custom handler must be used for that field)
    #                dbid = dbref(value, reqhash=False)
    #                if dbid:
    #                    try:
    #                        value = cls._default_manager.get(id=dbid)
    #                    except ObjectDoesNotExist:
    #                        # maybe it is just a name that happens to look like a dbid
    #                        from src.utils.logger import log_trace
    #                        log_trace()
    #            #print "_set wrapper:", fname, value, type(value), cls._get_pk_val(cls._meta)
    #            _SA(cls, fname, value)
    #            # only use explicit update_fields in save if we actually have a
    #            # primary key assigned already (won't be set when first creating object)
    #            update_fields = [fname] if _GA(cls, "_get_pk_val")(_GA(cls, "_meta")) is not None else None
    #            _GA(cls, "save")(update_fields=update_fields)
    #        def _del_nonedit(cls, fname):
    #            "wrapper for not allowing deletion"
    #            raise FieldError("Field %s cannot be edited." % fname)
    #        def _del(cls, fname):
    #            "Wrapper for clearing database field - sets it to None"
    #            _SA(cls, fname, None)
    #            update_fields = [fname] if _GA(cls, "_get_pk_val")(_GA(cls, "_meta")) is not None else None
    #            _GA(cls, "save")(update_fields=update_fields)

    #        # create class field wrappers
    #        fget = lambda cls: _get(cls, fieldname)
    #        fset = lambda cls, val: _set(cls, fieldname, val) if editable else _set_nonedit(cls, fieldname, val)
    #        fdel = lambda cls: _del(cls, fieldname) if editable else _del_nonedit(cls,fieldname)
    #        type(cls).__setattr__(cls, wrappername, property(fget, fset, fdel))#, doc))

    #    # exclude some models that should not auto-create wrapper fields
    #    if cls.__name__ in ("ServerConfig", "TypeNick"):
    #        return
    #    # dynamically create the wrapper properties for all fields not already handled
    #    for field in cls._meta.fields:
    #        fieldname = field.name
    #        if fieldname.startswith("db_"):
    #            wrappername = "dbid" if fieldname == "id" else fieldname.replace("db_", "")
    #            if not hasattr(cls, wrappername):
    #                # makes sure not to overload manually created wrappers on the model
    #                #print "wrapping %s -> %s" % (fieldname, wrappername)
    #                create_wrapper(cls, fieldname, wrappername, editable=field.editable)

class SharedMemoryModel(Model):
    # CL: setting abstract correctly to allow subclasses to inherit the default
    # manager.
    __metaclass__ = SharedMemoryModelBase

    objects = SharedMemoryManager()

    class Meta:
        abstract = True

    def _get_cache_key(cls, args, kwargs):
        """
        This method is used by the caching subsystem to infer the PK value from the constructor arguments.
        It is used to decide if an instance has to be built or is already in the cache.
        """
        result = None
        # Quick hack for my composites work for now.
        if hasattr(cls._meta, 'pks'):
            pk = cls._meta.pks[0]
        else:
            pk = cls._meta.pk
        # get the index of the pk in the class fields. this should be calculated *once*, but isn't atm
        pk_position = cls._meta.fields.index(pk)
        if len(args) > pk_position:
            # if it's in the args, we can get it easily by index
            result = args[pk_position]
        elif pk.attname in kwargs:
            # retrieve the pk value. Note that we use attname instead of name, to handle the case where the pk is a
            # a ForeignKey.
            result = kwargs[pk.attname]
        elif pk.name != pk.attname and pk.name in kwargs:
            # ok we couldn't find the value, but maybe it's a FK and we can find the corresponding object instead
            result = kwargs[pk.name]

        if result is not None and isinstance(result, Model):
            # if the pk value happens to be a model instance (which can happen wich a FK), we'd rather use its own pk as the key
            result = result._get_pk_val()
        return result
    _get_cache_key = classmethod(_get_cache_key)

    def _flush_cached_by_key(cls, key):
        try:
            del cls.__instance_cache__[key]
        except KeyError:
            pass
    _flush_cached_by_key = classmethod(_flush_cached_by_key)

    def get_cached_instance(cls, id):
        """
        Method to retrieve a cached instance by pk value. Returns None when not found
        (which will always be the case when caching is disabled for this class). Please
        note that the lookup will be done even when instance caching is disabled.
        """
        return cls.__instance_cache__.get(id)
    get_cached_instance = classmethod(get_cached_instance)

    def cache_instance(cls, instance):
        """
        Method to store an instance in the cache.
        """
        if instance._get_pk_val() is not None:
            cls.__instance_cache__[instance._get_pk_val()] = instance
    cache_instance = classmethod(cache_instance)

    def get_all_cached_instances(cls):
        "return the objects so far cached by idmapper for this class."
        return cls.__instance_cache__.values()
    get_all_cached_instances = classmethod(get_all_cached_instances)

    def flush_cached_instance(cls, instance):
        """
        Method to flush an instance from the cache. The instance will always be flushed from the cache,
        since this is most likely called from delete(), and we want to make sure we don't cache dead objects.
        """
        cls._flush_cached_by_key(instance._get_pk_val())
    flush_cached_instance = classmethod(flush_cached_instance)

    def flush_instance_cache(cls):
        cls.__instance_cache__ = {} #WeakValueDictionary()
    flush_instance_cache = classmethod(flush_instance_cache)

    def save(cls, *args, **kwargs):
        "save method tracking process/thread issues"

        if _IS_SUBPROCESS:
            # we keep a store of objects modified in subprocesses so
            # we know to update their caches in the central process
            PROC_MODIFIED_OBJS.append(cls)

        if _IS_MAIN_THREAD:
            # in main thread - normal operation
            super(SharedMemoryModel, cls).save(*args, **kwargs)
        else:
            # in another thread; make sure to save in reactor thread
            def _save_callback(cls, *args, **kwargs):
                super(SharedMemoryModel, cls).save(*args, **kwargs)
            #blockingCallFromThread(reactor, _save_callback, cls, *args, **kwargs)
            callFromThread(_save_callback, cls, *args, **kwargs)

# Use a signal so we make sure to catch cascades.
def flush_cache(**kwargs):
    def class_hierarchy(root):
        """Recursively yield a class hierarchy."""
        yield root
        for subcls in root.__subclasses__():
            for cls in class_hierarchy(subcls):
                yield cls
    for model in class_hierarchy(SharedMemoryModel):
        model.flush_instance_cache()
#request_finished.connect(flush_cache)
post_syncdb.connect(flush_cache)


def flush_cached_instance(sender, instance, **kwargs):
    # XXX: Is this the best way to make sure we can flush?
    if not hasattr(instance, 'flush_cached_instance'):
        return
    sender.flush_cached_instance(instance)
pre_delete.connect(flush_cached_instance)

def update_cached_instance(sender, instance, **kwargs):
    if not hasattr(instance, 'cache_instance'):
        return
    sender.cache_instance(instance)
post_save.connect(update_cached_instance)

def cache_size(mb=True):
    """
    Returns a dictionary with estimates of the
    cache size of each subclass.

    mb - return the result in MB.
    """
    import sys
    sizedict = {"_total": [0, 0]}
    def getsize(model):
        instances = model.get_all_cached_instances()
        linst = len(instances)
        size = sum([sys.getsizeof(o) for o in instances])
        size = (mb and size/1024.0) or size
        return (linst, size)
    def get_recurse(submodels):
        for submodel in submodels:
            subclasses = submodel.__subclasses__()
            if not subclasses:
                tup = getsize(submodel)
                sizedict["_total"][0] += tup[0]
                sizedict["_total"][1] += tup[1]
                sizedict[submodel.__name__] = tup
            else:
                get_recurse(subclasses)
    get_recurse(SharedMemoryModel.__subclasses__())
    sizedict["_total"] = tuple(sizedict["_total"])
    return sizedict


########NEW FILE########
__FILENAME__ = manager
from django.db.models.manager import Manager
try:
    from django.db import router
except:
    pass


class SharedMemoryManager(Manager):
    # CL: this ensures our manager is used when accessing instances via
    # ForeignKey etc. (see docs)
    use_for_related_fields = True

    # CL: in the dev version of django, ReverseSingleRelatedObjectDescriptor
    # will call us as:
    #     rel_obj = rel_mgr.using(db).get(**params)
    # We need to handle using, or the get method will be called on a vanilla
    # queryset, and we won't get a change to use the cache.
    def using(self, alias):
        if alias == router.db_for_read(self.model):
            return self
        else:
            return super(SharedMemoryManager, self).using(alias)

    # TODO: improve on this implementation
    # We need a way to handle reverse lookups so that this model can
    # still use the singleton cache, but the active model isn't required
    # to be a SharedMemoryModel.
    def get(self, **kwargs):
        items = kwargs.keys()
        inst = None
        if len(items) == 1:
            # CL: support __exact
            key = items[0]
            if key.endswith('__exact'):
                key = key[:-len('__exact')]
            if key in ('pk', self.model._meta.pk.attname):
                inst = self.model.get_cached_instance(kwargs[items[0]])
        if inst is None:
            inst = super(SharedMemoryManager, self).get(**kwargs)
        return inst

########NEW FILE########
__FILENAME__ = models
from django.db.models import *
from base import SharedMemoryModel
########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase

from base import SharedMemoryModel
from django.db import models

class Category(SharedMemoryModel):
    name = models.CharField(max_length=32)

class RegularCategory(models.Model):
    name = models.CharField(max_length=32)

class Article(SharedMemoryModel):
    name = models.CharField(max_length=32)
    category = models.ForeignKey(Category)
    category2 = models.ForeignKey(RegularCategory)

class RegularArticle(models.Model):
    name = models.CharField(max_length=32)
    category = models.ForeignKey(Category)
    category2 = models.ForeignKey(RegularCategory)

class SharedMemorysTest(TestCase):
    # TODO: test for cross model relation (singleton to regular)
    
    def setUp(self):
        n = 0
        category = Category.objects.create(name="Category %d" % (n,))
        regcategory = RegularCategory.objects.create(name="Category %d" % (n,))
        
        for n in xrange(0, 10):
            Article.objects.create(name="Article %d" % (n,), category=category, category2=regcategory)
            RegularArticle.objects.create(name="Article %d" % (n,), category=category, category2=regcategory)
    
    def testSharedMemoryReferences(self):
        article_list = Article.objects.all().select_related('category')
        last_article = article_list[0]
        for article in article_list[1:]:
            self.assertEquals(article.category is last_article.category, True)
            last_article = article

    def testRegularReferences(self):
        article_list = RegularArticle.objects.all().select_related('category')
        last_article = article_list[0]
        for article in article_list[1:]:
            self.assertEquals(article.category2 is last_article.category2, False)
            last_article = article

    def testMixedReferences(self):
        article_list = RegularArticle.objects.all().select_related('category')
        last_article = article_list[0]
        for article in article_list[1:]:
            self.assertEquals(article.category is last_article.category, True)
            last_article = article

        article_list = Article.objects.all().select_related('category')
        last_article = article_list[0]
        for article in article_list[1:]:
            self.assertEquals(article.category2 is last_article.category2, False)
            last_article = article
        
    def testObjectDeletion(self):
        # This must execute first so its guaranteed to be in memory.
        article_list = list(Article.objects.all().select_related('category'))
        
        article = Article.objects.all()[0:1].get()
        pk = article.pk
        article.delete()
        self.assertEquals(pk not in Article.__instance_cache__, True)
        
        
########NEW FILE########
__FILENAME__ = logger
"""
Logging facilities

These are thin wrappers on top of Twisted's
logging facilities; logs are all directed
either to stdout (if Evennia is running in
interactive mode) or to game/logs.

The log_file() function uses its own threading
system to log to arbitrary files in game/logs.

Note:
All logging functions have two aliases,
log_type() and log_typemsg(). This is for
historical, back-compatible reasons.

"""

from datetime import datetime
from traceback import format_exc
from twisted.python import log
from twisted.internet.threads import deferToThread


def log_trace(errmsg=None):
    """
    Log a traceback to the log. This should be called
    from within an exception. errmsg is optional and
    adds an extra line with added info.
    """
    tracestring = format_exc()
    try:
        if tracestring:
            for line in tracestring.splitlines():
                log.msg('[::] %s' % line)
        if errmsg:
            try:
                errmsg = str(errmsg)
            except Exception, e:
                errmsg = str(e)
            for line in errmsg.splitlines():
                log.msg('[EE] %s' % line)
    except Exception:
        log.msg('[EE] %s' % errmsg)
log_tracemsg = log_trace


def log_err(errmsg):
    """
    Prints/logs an error message to the server log.

    errormsg: (string) The message to be logged.
    """
    try:
        errmsg = str(errmsg)
    except Exception, e:
        errmsg = str(e)
    for line in errmsg.splitlines():
        log.msg('[EE] %s' % line)
    #log.err('ERROR: %s' % (errormsg,))
log_errmsg = log_err


def log_warn(warnmsg):
    """
    Prints/logs any warnings that aren't critical but should be noted.

    warnmsg: (string) The message to be logged.
    """
    try:
        warnmsg = str(warnmsg)
    except Exception, e:
        warnmsg = str(e)
    for line in warnmsg.splitlines():
        log.msg('[WW] %s' % line)
    #log.msg('WARNING: %s' % (warnmsg,))
log_warnmsg = log_warn


def log_info(infomsg):
    """
    Prints any generic debugging/informative info that should appear in the log.

    infomsg: (string) The message to be logged.
    """
    try:
        infomsg = str(infomsg)
    except Exception, e:
        infomsg = str(e)
    for line in infomsg.splitlines():
        log.msg('[..] %s' % line)
log_infomsg = log_info


def log_dep(depmsg):
    """
    Prints a deprecation message
    """
    try:
        depmsg = str(depmsg)
    except Exception, e:
        depmsg = str(e)
    for line in depmsg.splitlines():
        log.msg('[DP] %s' % line)
log_depmsg = log_dep


# Arbitrary file logger

LOG_FILE_HANDLES = {} # holds open log handles

def log_file(msg, filename="game.log"):
    """
    Arbitrary file logger using threads.  Filename defaults to
    'game.log'. All logs will appear in game/logs directory and log
    entries will start on new lines following datetime info.
    """
    global LOG_FILE_HANDLES

    def callback(filehandle, msg):
        "Writing to file and flushing result"
        msg = "\n%s [-] %s" % (datetime.now(), msg.strip())
        filehandle.write(msg)
        # since we don't close the handle, we need to flush
        # manually or log file won't be written to until the
        # write buffer is full.
        filehandle.flush()
    def errback(failure):
        "Catching errors to normal log"
        log_trace()

    # save to game/logs/ directory
    filename = "logs/" + filename

    if filename in LOG_FILE_HANDLES:
        filehandle = LOG_FILE_HANDLES[filename]
    else:
        try:
            filehandle = open(filename, "a")
            LOG_FILE_HANDLES[filename] = filehandle
        except IOError:
            log_trace()
            return
    deferToThread(callback, filehandle, msg).addErrback(errback)

########NEW FILE########
__FILENAME__ = picklefield
#
#  Copyright (c) 2009-2010 Gintautas Miliauskas
#
#   Permission is hereby granted, free of charge, to any person
#   obtaining a copy of this software and associated documentation
#   files (the "Software"), to deal in the Software without
#   restriction, including without limitation the rights to use,
#   copy, modify, merge, publish, distribute, sublicense, and/or sell
#   copies of the Software, and to permit persons to whom the
#   Software is furnished to do so, subject to the following
#   conditions:
#
#   The above copyright notice and this permission notice shall be
#   included in all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#   OTHER DEALINGS IN THE SOFTWARE.

"""
Pickle field implementation for Django.

Modified for Evennia by Griatch.

"""

from copy import deepcopy
from base64 import b64encode, b64decode
from zlib import compress, decompress
#import six # this is actually a pypy component, not in default syslib
import django
from django.db import models

# django 1.5 introduces force_text instead of force_unicode
try:
    from django.utils.encoding import force_text
except ImportError:
    from django.utils.encoding import force_unicode as force_text

# python 3.x does not have cPickle module
try:
    from cPickle import loads, dumps # cpython 2.x
except ImportError:
    from pickle import loads, dumps # cpython 3.x, other interpreters

DEFAULT_PROTOCOL = 2

class PickledObject(str):
    """
    A subclass of string so it can be told whether a string is a pickled
    object or not (if the object is an instance of this class then it must
    [well, should] be a pickled one).

    Only really useful for passing pre-encoded values to ``default``
    with ``dbsafe_encode``, not that doing so is necessary. If you
    remove PickledObject and its references, you won't be able to pass
    in pre-encoded values anymore, but you can always just pass in the
    python objects themselves.
    """


class _ObjectWrapper(object):
    """
    A class used to wrap object that have properties that may clash with the
    ORM internals.

    For example, objects with the `prepare_database_save` property such as
    `django.db.Model` subclasses won't work under certain conditions and the
    same apply for trying to retrieve any `callable` object.
    """
    __slots__ = ('_obj',)

    def __init__(self, obj):
        self._obj = obj


def wrap_conflictual_object(obj):
    if hasattr(obj, 'prepare_database_save') or callable(obj):
        obj = _ObjectWrapper(obj)
    return obj


def dbsafe_encode(value, compress_object=False, pickle_protocol=DEFAULT_PROTOCOL):
    # We use deepcopy() here to avoid a problem with cPickle, where dumps
    # can generate different character streams for same lookup value if
    # they are referenced differently.
    # The reason this is important is because we do all of our lookups as
    # simple string matches, thus the character streams must be the same
    # for the lookups to work properly. See tests.py for more information.
    value = dumps(deepcopy(value), protocol=pickle_protocol)
    if compress_object:
        value = compress(value)
    value = b64encode(value).decode() # decode bytes to str
    return PickledObject(value)


def dbsafe_decode(value, compress_object=False):
    value = value.encode() # encode str to bytes
    value = b64decode(value)
    if compress_object:
        value = decompress(value)
    return loads(value)


def _get_subfield_superclass():
    # hardcore trick to support django < 1.3 - there was something wrong with
    # inheritance and SubfieldBase before django 1.3
    # see https://github.com/django/django/commit/222c73261650201f5ce99e8dd4b1ce0d30a69eb4
    if django.VERSION < (1,3):
        return models.Field
    # mimic six.with_metaclass
    meta = models.SubfieldBase
    base = models.Field
    return meta("NewBase", (base,), {})
    #return six.with_metaclass(models.SubfieldBase, models.Field)


class PickledObjectField(_get_subfield_superclass()):
    """
    A field that will accept *any* python object and store it in the
    database. PickledObjectField will optionally compress its values if
    declared with the keyword argument ``compress=True``.

    Does not actually encode and compress ``None`` objects (although you
    can still do lookups using None). This way, it is still possible to
    use the ``isnull`` lookup type correctly.
    """
    __metaclass__ = models.SubfieldBase  # for django < 1.3

    def __init__(self, *args, **kwargs):
        self.compress = kwargs.pop('compress', False)
        self.protocol = kwargs.pop('protocol', DEFAULT_PROTOCOL)
        kwargs.setdefault('editable', False)
        super(PickledObjectField, self).__init__(*args, **kwargs)

    def get_default(self):
        """
        Returns the default value for this field.

        The default implementation on models.Field calls force_unicode
        on the default, which means you can't set arbitrary Python
        objects as the default. To fix this, we just return the value
        without calling force_unicode on it. Note that if you set a
        callable as a default, the field will still call it. It will
        *not* try to pickle and encode it.

        """
        if self.has_default():
            if callable(self.default):
                return self.default()
            return self.default
        # If the field doesn't have a default, then we punt to models.Field.
        return super(PickledObjectField, self).get_default()

    def to_python(self, value):
        """
        B64decode and unpickle the object, optionally decompressing it.

        If an error is raised in de-pickling and we're sure the value is
        a definite pickle, the error is allowed to propagate. If we
        aren't sure if the value is a pickle or not, then we catch the
        error and return the original value instead.

        """
        if value is not None:
            try:
                value = dbsafe_decode(value, self.compress)
            except:
                # If the value is a definite pickle; and an error is raised in
                # de-pickling it should be allowed to propogate.
                if isinstance(value, PickledObject):
                    raise
            else:
                if isinstance(value, _ObjectWrapper):
                    return value._obj
        return value

    def pre_save(self, model_instance, add):
        value = super(PickledObjectField, self).pre_save(model_instance, add)
        return wrap_conflictual_object(value)

    def get_db_prep_value(self, value, connection=None, prepared=False):
        """
        Pickle and b64encode the object, optionally compressing it.

        The pickling protocol is specified explicitly (by default 2),
        rather than as -1 or HIGHEST_PROTOCOL, because we don't want the
        protocol to change over time. If it did, ``exact`` and ``in``
        lookups would likely fail, since pickle would now be generating
        a different string.

        """
        if value is not None and not isinstance(value, PickledObject):
            # We call force_text here explicitly, so that the encoded string
            # isn't rejected by the postgresql_psycopg2 backend. Alternatively,
            # we could have just registered PickledObject with the psycopg
            # marshaller (telling it to store it like it would a string), but
            # since both of these methods result in the same value being stored,
            # doing things this way is much easier.
            value = force_text(dbsafe_encode(value, self.compress, self.protocol))
        return value

    def value_to_string(self, obj):
        value = self._get_val_from_obj(obj)
        return self.get_db_prep_value(value)

    def get_internal_type(self):
        return 'TextField'

    def get_db_prep_lookup(self, lookup_type, value, connection=None, prepared=False):
        if lookup_type not in ['exact', 'in', 'isnull']:
            raise TypeError('Lookup type %s is not supported.' % lookup_type)
        # The Field model already calls get_db_prep_value before doing the
        # actual lookup, so all we need to do is limit the lookup types.
        return super(PickledObjectField, self).get_db_prep_lookup(
            lookup_type, value, connection=connection, prepared=prepared)


# South support; see http://south.aeracode.org/docs/tutorial/part4.html#simple-inheritance
try:
    from south.modelsinspector import add_introspection_rules
except ImportError:
    pass
else:
    add_introspection_rules([], [r"^src\.utils\.picklefield\.PickledObjectField"])

########NEW FILE########
__FILENAME__ = prettytable
#!/usr/bin/env python
#
# Copyright (c) 2009-2013, Luke Maurits <luke@maurits.id.au>
# All rights reserved.
# With contributions from:
#  * Chris Clark
#  * Klein Stephane
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * The name of the author may not be used to endorse or promote products
#   derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

__version__ = "trunk"

import copy
import csv
import random
import re
import sys
import textwrap
import itertools
import unicodedata

from src.utils.ansi import parse_ansi

py3k = sys.version_info[0] >= 3
if py3k:
    unicode = str
    basestring = str
    itermap = map
    iterzip = zip
    uni_chr = chr
    from html.parser import HTMLParser
else:
    itermap = itertools.imap
    iterzip = itertools.izip
    uni_chr = unichr
    from HTMLParser import HTMLParser

if py3k and sys.version_info[1] >= 2:
    from html import escape
else:
    from cgi import escape

# hrule styles
FRAME = 0
ALL   = 1
NONE  = 2
HEADER = 3

# Table styles
DEFAULT = 10
MSWORD_FRIENDLY = 11
PLAIN_COLUMNS = 12
RANDOM = 20

_re = re.compile("\033\[[0-9;]*m")

def _ansi(method):
    "decorator for converting ansi in input"
    def wrapper(self, *args, **kwargs):
        def convert(inp):
            if isinstance(inp, basestring):
                return parse_ansi("{n%s{n" % inp)
            elif hasattr(inp, '__iter__'):
                li = []
                for element in inp:
                    if isinstance(element, basestring):
                        li.append(convert(element))
                    elif hasattr(element, '__iter__'):
                        li.append(convert(element))
                    else:
                        li.append(element)
                return li
            return inp
        args = [convert(arg) for arg in args]
        #kwargs = dict((key, convert(val)) for key, val in kwargs.items())
        return method(self, *args, **kwargs)
    return wrapper

def _get_size(text):
    lines = text.split("\n")
    height = len(lines)
    width = max([_str_block_width(line) for line in lines])
    return (width, height)

class PrettyTable(object):


    @_ansi
    def __init__(self, field_names=None, **kwargs):

        """Return a new PrettyTable instance

        Arguments:

        encoding - Unicode encoding scheme used to decode any encoded input
        field_names - list or tuple of field names
        fields - list or tuple of field names to include in displays
        start - index of first data row to include in output
        end - index of last data row to include in output PLUS ONE (list slice style)
        header - print a header showing field names (True or False)
        header_style - stylisation to apply to field names in header ("cap", "title", "upper", "lower" or None)
        border - print a border around the table (True or False)
        hrules - controls printing of horizontal rules after rows.  Allowed values: FRAME, HEADER, ALL, NONE
        vrules - controls printing of vertical rules between columns.  Allowed values: FRAME, ALL, NONE
        int_format - controls formatting of integer data
        float_format - controls formatting of floating point data
        padding_width - number of spaces on either side of column data (only used if left and right paddings are None)
        left_padding_width - number of spaces on left hand side of column data
        right_padding_width - number of spaces on right hand side of column data
        vertical_char - single character string used to draw vertical lines
        horizontal_char - single character string used to draw horizontal lines
        junction_char - single character string used to draw line junctions
        sortby - name of field to sort rows by
        sort_key - sorting key function, applied to data points before sorting
        valign - default valign for each row (None, "t", "m" or "b")
        reversesort - True or False to sort in descending or ascending order"""

        self.encoding = kwargs.get("encoding", "UTF-8")

        # Data
        self._field_names = []
        self._align = {}
        self._valign = {}
        self._max_width = {}
        self._rows = []
        if field_names:
            self.field_names = field_names
        else:
            self._widths = []

        # Options
        self._options = "start end fields header border sortby reversesort sort_key attributes format hrules vrules".split()
        self._options.extend("int_format float_format padding_width left_padding_width right_padding_width".split())
        self._options.extend("vertical_char horizontal_char junction_char header_style valign xhtml print_empty".split())
        for option in self._options:
            if option in kwargs:
                self._validate_option(option, kwargs[option])
            else:
                kwargs[option] = None

        self._start = kwargs["start"] or 0
        self._end = kwargs["end"] or None
        self._fields = kwargs["fields"] or None

        if kwargs["header"] in (True, False):
            self._header = kwargs["header"]
        else:
            self._header = True
        self._header_style = kwargs["header_style"] or None
        if kwargs["border"] in (True, False):
            self._border = kwargs["border"]
        else:
            self._border = True
        self._hrules = kwargs["hrules"] or FRAME
        self._vrules = kwargs["vrules"] or ALL

        self._sortby = kwargs["sortby"] or None
        if kwargs["reversesort"] in (True, False):
            self._reversesort = kwargs["reversesort"]
        else:
            self._reversesort = False
        self._sort_key = kwargs["sort_key"] or (lambda x: x)

        self._int_format = kwargs["int_format"] or {}
        self._float_format = kwargs["float_format"] or {}
        self._padding_width = kwargs["padding_width"] or 1
        self._left_padding_width = kwargs["left_padding_width"] or None
        self._right_padding_width = kwargs["right_padding_width"] or None

        self._vertical_char = kwargs["vertical_char"] or self._unicode("|")
        self._horizontal_char = kwargs["horizontal_char"] or self._unicode("-")
        self._junction_char = kwargs["junction_char"] or self._unicode("+")

        if kwargs["print_empty"] in (True, False):
            self._print_empty = kwargs["print_empty"]
        else:
            self._print_empty = True
        self._format = kwargs["format"] or False
        self._xhtml = kwargs["xhtml"] or False
        self._attributes = kwargs["attributes"] or {}

    def _unicode(self, value):
        if not isinstance(value, basestring):
            value = str(value)
        if not isinstance(value, unicode):
            value = unicode(value, self.encoding, "strict")
        return value

    def _justify(self, text, width, align):
        excess = width - _str_block_width(text)
        if align == "l":
            return text + excess * " "
        elif align == "r":
            return excess * " " + text
        else:
            if excess % 2:
                # Uneven padding
                # Put more space on right if text is of odd length...
                if _str_block_width(text) % 2:
                    return (excess//2)*" " + text + (excess//2 + 1)*" "
                # and more space on left if text is of even length
                else:
                    return (excess//2 + 1)*" " + text + (excess//2)*" "
                # Why distribute extra space this way?  To match the behaviour of
                # the inbuilt str.center() method.
            else:
                # Equal padding on either side
                return (excess//2)*" " + text + (excess//2)*" "

    def __getattr__(self, name):

        if name == "rowcount":
            return len(self._rows)
        elif name == "colcount":
            if self._field_names:
                return len(self._field_names)
            elif self._rows:
                return len(self._rows[0])
            else:
                return 0
        else:
            raise AttributeError(name)

    def __getitem__(self, index):

        new = PrettyTable()
        new.field_names = self.field_names
        for attr in self._options:
            setattr(new, "_"+attr, getattr(self, "_"+attr))
        setattr(new, "_align", getattr(self, "_align"))
        if isinstance(index, slice):
            for row in self._rows[index]:
                new.add_row(row)
        elif isinstance(index, int):
            new.add_row(self._rows[index])
        else:
            raise Exception("Index %s is invalid, must be an integer or slice" % str(index))
        return new

    if py3k:
        def __str__(self):
           return self.__unicode__()
    else:
        def __str__(self):
           return self.__unicode__().encode(self.encoding)

    def __unicode__(self):
        return self.get_string()

    ##############################
    # ATTRIBUTE VALIDATORS       #
    ##############################

    # The method _validate_option is all that should be used elsewhere in the code base to validate options.
    # It will call the appropriate validation method for that option.  The individual validation methods should
    # never need to be called directly (although nothing bad will happen if they *are*).
    # Validation happens in TWO places.
    # Firstly, in the property setters defined in the ATTRIBUTE MANAGMENT section.
    # Secondly, in the _get_options method, where keyword arguments are mixed with persistent settings

    def _validate_option(self, option, val):
        if option in ("field_names"):
            self._validate_field_names(val)
        elif option in ("start", "end", "max_width", "padding_width", "left_padding_width", "right_padding_width", "format"):
            self._validate_nonnegative_int(option, val)
        elif option in ("sortby"):
            self._validate_field_name(option, val)
        elif option in ("sort_key"):
            self._validate_function(option, val)
        elif option in ("hrules"):
            self._validate_hrules(option, val)
        elif option in ("vrules"):
            self._validate_vrules(option, val)
        elif option in ("fields"):
            self._validate_all_field_names(option, val)
        elif option in ("header", "border", "reversesort", "xhtml", "print_empty"):
            self._validate_true_or_false(option, val)
        elif option in ("header_style"):
            self._validate_header_style(val)
        elif option in ("int_format"):
            self._validate_int_format(option, val)
        elif option in ("float_format"):
            self._validate_float_format(option, val)
        elif option in ("vertical_char", "horizontal_char", "junction_char"):
            self._validate_single_char(option, val)
        elif option in ("attributes"):
            self._validate_attributes(option, val)
        else:
            raise Exception("Unrecognised option: %s!" % option)

    def _validate_field_names(self, val):
        # Check for appropriate length
        if self._field_names:
            try:
               assert len(val) == len(self._field_names)
            except AssertionError:
               raise Exception("Field name list has incorrect number of values, (actual) %d!=%d (expected)" % (len(val), len(self._field_names)))
        if self._rows:
            try:
               assert len(val) == len(self._rows[0])
            except AssertionError:
               raise Exception("Field name list has incorrect number of values, (actual) %d!=%d (expected)" % (len(val), len(self._rows[0])))
        # Check for uniqueness
        try:
            assert len(val) == len(set(val))
        except AssertionError:
            raise Exception("Field names must be unique!")

    def _validate_header_style(self, val):
        try:
            assert val in ("cap", "title", "upper", "lower", None)
        except AssertionError:
            raise Exception("Invalid header style, use cap, title, upper, lower or None!")

    def _validate_align(self, val):
        try:
            assert val in ["l","c","r"]
        except AssertionError:
            raise Exception("Alignment %s is invalid, use l, c or r!" % val)

    def _validate_valign(self, val):
        try:
            assert val in ["t","m","b",None]
        except AssertionError:
            raise Exception("Alignment %s is invalid, use t, m, b or None!" % val)

    def _validate_nonnegative_int(self, name, val):
        try:
            assert int(val) >= 0
        except AssertionError:
            raise Exception("Invalid value for %s: %s!" % (name, self._unicode(val)))

    def _validate_true_or_false(self, name, val):
        try:
            assert val in (True, False)
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be True or False." % name)

    def _validate_int_format(self, name, val):
        if val == "":
            return
        try:
            assert type(val) in (str, unicode)
            assert val.isdigit()
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be an integer format string." % name)

    def _validate_float_format(self, name, val):
        if val == "":
            return
        try:
            assert type(val) in (str, unicode)
            assert "." in val
            bits = val.split(".")
            assert len(bits) <= 2
            assert bits[0] == "" or bits[0].isdigit()
            assert bits[1] == "" or bits[1].isdigit()
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be a float format string." % name)

    def _validate_function(self, name, val):
        try:
            assert hasattr(val, "__call__")
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be a function." % name)

    def _validate_hrules(self, name, val):
        try:
            assert val in (ALL, FRAME, HEADER, NONE)
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be ALL, FRAME, HEADER or NONE." % name)

    def _validate_vrules(self, name, val):
        try:
            assert val in (ALL, FRAME, NONE)
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be ALL, FRAME, or NONE." % name)

    def _validate_field_name(self, name, val):
        try:
            assert (val in self._field_names) or (val is None)
        except AssertionError:
            raise Exception("Invalid field name: %s!" % val)

    def _validate_all_field_names(self, name, val):
        try:
            for x in val:
                self._validate_field_name(name, x)
        except AssertionError:
            raise Exception("fields must be a sequence of field names!")

    def _validate_single_char(self, name, val):
        try:
            assert _str_block_width(val) == 1
        except AssertionError:
            raise Exception("Invalid value for %s!  Must be a string of length 1." % name)

    def _validate_attributes(self, name, val):
        try:
            assert isinstance(val, dict)
        except AssertionError:
            raise Exception("attributes must be a dictionary of name/value pairs!")

    ##############################
    # ATTRIBUTE MANAGEMENT       #
    ##############################

    def _get_field_names(self):
        return self._field_names
        """The names of the fields

        Arguments:

        fields - list or tuple of field names"""
    def _set_field_names(self, val):
        val = [self._unicode(x) for x in val]
        self._validate_option("field_names", val)
        if self._field_names:
            old_names = self._field_names[:]
        self._field_names = val
        if self._align and old_names:
            for old_name, new_name in zip(old_names, val):
                self._align[new_name] = self._align[old_name]
            for old_name in old_names:
                if old_name not in self._align:
                    self._align.pop(old_name)
        else:
            for field in self._field_names:
                self._align[field] = "l"
        if self._valign and old_names:
            for old_name, new_name in zip(old_names, val):
                self._valign[new_name] = self._valign[old_name]
            for old_name in old_names:
                if old_name not in self._valign:
                    self._valign.pop(old_name)
        else:
            for field in self._field_names:
                self._valign[field] = "t"
    field_names = property(_get_field_names, _set_field_names)

    def _get_align(self):
        return self._align
    def _set_align(self, val):
        self._validate_align(val)
        for field in self._field_names:
            self._align[field] = val
    align = property(_get_align, _set_align)

    def _get_valign(self):
        return self._valign
    def _set_valign(self, val):
        self._validate_valign(val)
        for field in self._field_names:
            self._valign[field] = val
    valign = property(_get_valign, _set_valign)

    def _get_max_width(self):
        return self._max_width
    def _set_max_width(self, val):
        self._validate_option("max_width", val)
        for field in self._field_names:
            self._max_width[field] = val
    max_width = property(_get_max_width, _set_max_width)

    def _get_fields(self):
        """List or tuple of field names to include in displays

        Arguments:

        fields - list or tuple of field names to include in displays"""
        return self._fields
    def _set_fields(self, val):
        self._validate_option("fields", val)
        self._fields = val
    fields = property(_get_fields, _set_fields)

    def _get_start(self):
        """Start index of the range of rows to print

        Arguments:

        start - index of first data row to include in output"""
        return self._start

    def _set_start(self, val):
        self._validate_option("start", val)
        self._start = val
    start = property(_get_start, _set_start)

    def _get_end(self):
        """End index of the range of rows to print

        Arguments:

        end - index of last data row to include in output PLUS ONE (list slice style)"""
        return self._end
    def _set_end(self, val):
        self._validate_option("end", val)
        self._end = val
    end = property(_get_end, _set_end)

    def _get_sortby(self):
        """Name of field by which to sort rows

        Arguments:

        sortby - field name to sort by"""
        return self._sortby
    def _set_sortby(self, val):
        self._validate_option("sortby", val)
        self._sortby = val
    sortby = property(_get_sortby, _set_sortby)

    def _get_reversesort(self):
        """Controls direction of sorting (ascending vs descending)

        Arguments:

        reveresort - set to True to sort by descending order, or False to sort by ascending order"""
        return self._reversesort
    def _set_reversesort(self, val):
        self._validate_option("reversesort", val)
        self._reversesort = val
    reversesort = property(_get_reversesort, _set_reversesort)

    def _get_sort_key(self):
        """Sorting key function, applied to data points before sorting

        Arguments:

        sort_key - a function which takes one argument and returns something to be sorted"""
        return self._sort_key
    def _set_sort_key(self, val):
        self._validate_option("sort_key", val)
        self._sort_key = val
    sort_key = property(_get_sort_key, _set_sort_key)

    def _get_header(self):
        """Controls printing of table header with field names

        Arguments:

        header - print a header showing field names (True or False)"""
        return self._header
    def _set_header(self, val):
        self._validate_option("header", val)
        self._header = val
    header = property(_get_header, _set_header)

    def _get_header_style(self):
        """Controls stylisation applied to field names in header

        Arguments:

        header_style - stylisation to apply to field names in header ("cap", "title", "upper", "lower" or None)"""
        return self._header_style
    def _set_header_style(self, val):
        self._validate_header_style(val)
        self._header_style = val
    header_style = property(_get_header_style, _set_header_style)

    def _get_border(self):
        """Controls printing of border around table

        Arguments:

        border - print a border around the table (True or False)"""
        return self._border
    def _set_border(self, val):
        self._validate_option("border", val)
        self._border = val
    border = property(_get_border, _set_border)

    def _get_hrules(self):
        """Controls printing of horizontal rules after rows

        Arguments:

        hrules - horizontal rules style.  Allowed values: FRAME, ALL, HEADER, NONE"""
        return self._hrules
    def _set_hrules(self, val):
        self._validate_option("hrules", val)
        self._hrules = val
    hrules = property(_get_hrules, _set_hrules)

    def _get_vrules(self):
        """Controls printing of vertical rules between columns

        Arguments:

        vrules - vertical rules style.  Allowed values: FRAME, ALL, NONE"""
        return self._vrules
    def _set_vrules(self, val):
        self._validate_option("vrules", val)
        self._vrules = val
    vrules = property(_get_vrules, _set_vrules)

    def _get_int_format(self):
        """Controls formatting of integer data
        Arguments:

        int_format - integer format string"""
        return self._int_format
    def _set_int_format(self, val):
#        self._validate_option("int_format", val)
        for field in self._field_names:
            self._int_format[field] = val
    int_format = property(_get_int_format, _set_int_format)

    def _get_float_format(self):
        """Controls formatting of floating point data
        Arguments:

        float_format - floating point format string"""
        return self._float_format
    def _set_float_format(self, val):
#        self._validate_option("float_format", val)
        for field in self._field_names:
            self._float_format[field] = val
    float_format = property(_get_float_format, _set_float_format)

    def _get_padding_width(self):
        """The number of empty spaces between a column's edge and its content

        Arguments:

        padding_width - number of spaces, must be a positive integer"""
        return self._padding_width
    def _set_padding_width(self, val):
        self._validate_option("padding_width", val)
        self._padding_width = val
    padding_width = property(_get_padding_width, _set_padding_width)

    def _get_left_padding_width(self):
        """The number of empty spaces between a column's left edge and its content

        Arguments:

        left_padding - number of spaces, must be a positive integer"""
        return self._left_padding_width
    def _set_left_padding_width(self, val):
        self._validate_option("left_padding_width", val)
        self._left_padding_width = val
    left_padding_width = property(_get_left_padding_width, _set_left_padding_width)

    def _get_right_padding_width(self):
        """The number of empty spaces between a column's right edge and its content

        Arguments:

        right_padding - number of spaces, must be a positive integer"""
        return self._right_padding_width
    def _set_right_padding_width(self, val):
        self._validate_option("right_padding_width", val)
        self._right_padding_width = val
    right_padding_width = property(_get_right_padding_width, _set_right_padding_width)

    def _get_vertical_char(self):
        """The charcter used when printing table borders to draw vertical lines

        Arguments:

        vertical_char - single character string used to draw vertical lines"""
        return self._vertical_char
    def _set_vertical_char(self, val):
        val = self._unicode(val)
        self._validate_option("vertical_char", val)
        self._vertical_char = val
    vertical_char = property(_get_vertical_char, _set_vertical_char)

    def _get_horizontal_char(self):
        """The charcter used when printing table borders to draw horizontal lines

        Arguments:

        horizontal_char - single character string used to draw horizontal lines"""
        return self._horizontal_char
    def _set_horizontal_char(self, val):
        val = self._unicode(val)
        self._validate_option("horizontal_char", val)
        self._horizontal_char = val
    horizontal_char = property(_get_horizontal_char, _set_horizontal_char)

    def _get_junction_char(self):
        """The charcter used when printing table borders to draw line junctions

        Arguments:

        junction_char - single character string used to draw line junctions"""
        return self._junction_char
    def _set_junction_char(self, val):
        val = self._unicode(val)
        self._validate_option("vertical_char", val)
        self._junction_char = val
    junction_char = property(_get_junction_char, _set_junction_char)

    def _get_format(self):
        """Controls whether or not HTML tables are formatted to match styling options

        Arguments:

        format - True or False"""
        return self._format
    def _set_format(self, val):
        self._validate_option("format", val)
        self._format = val
    format = property(_get_format, _set_format)

    def _get_print_empty(self):
        """Controls whether or not empty tables produce a header and frame or just an empty string

        Arguments:

        print_empty - True or False"""
        return self._print_empty
    def _set_print_empty(self, val):
        self._validate_option("print_empty", val)
        self._print_empty = val
    print_empty = property(_get_print_empty, _set_print_empty)

    def _get_attributes(self):
        """A dictionary of HTML attribute name/value pairs to be included in the <table> tag when printing HTML

        Arguments:

        attributes - dictionary of attributes"""
        return self._attributes
    def _set_attributes(self, val):
        self._validate_option("attributes", val)
        self._attributes = val
    attributes = property(_get_attributes, _set_attributes)

    ##############################
    # OPTION MIXER               #
    ##############################

    def _get_options(self, kwargs):

        options = {}
        for option in self._options:
            if option in kwargs:
                self._validate_option(option, kwargs[option])
                options[option] = kwargs[option]
            else:
                options[option] = getattr(self, "_"+option)
        return options

    ##############################
    # PRESET STYLE LOGIC         #
    ##############################

    def set_style(self, style):

        if style == DEFAULT:
            self._set_default_style()
        elif style == MSWORD_FRIENDLY:
            self._set_msword_style()
        elif style == PLAIN_COLUMNS:
            self._set_columns_style()
        elif style == RANDOM:
            self._set_random_style()
        else:
            raise Exception("Invalid pre-set style!")

    def _set_default_style(self):

        self.header = True
        self.border = True
        self._hrules = FRAME
        self._vrules = ALL
        self.padding_width = 1
        self.left_padding_width = 1
        self.right_padding_width = 1
        self.vertical_char = "|"
        self.horizontal_char = "-"
        self.junction_char = "+"

    def _set_msword_style(self):

        self.header = True
        self.border = True
        self._hrules = NONE
        self.padding_width = 1
        self.left_padding_width = 1
        self.right_padding_width = 1
        self.vertical_char = "|"

    def _set_columns_style(self):

        self.header = True
        self.border = False
        self.padding_width = 1
        self.left_padding_width = 0
        self.right_padding_width = 8

    def _set_random_style(self):

        # Just for fun!
        self.header = random.choice((True, False))
        self.border = random.choice((True, False))
        self._hrules = random.choice((ALL, FRAME, HEADER, NONE))
        self._vrules = random.choice((ALL, FRAME, NONE))
        self.left_padding_width = random.randint(0,5)
        self.right_padding_width = random.randint(0,5)
        self.vertical_char = random.choice("~!@#$%^&*()_+|-=\{}[];':\",./;<>?")
        self.horizontal_char = random.choice("~!@#$%^&*()_+|-=\{}[];':\",./;<>?")
        self.junction_char = random.choice("~!@#$%^&*()_+|-=\{}[];':\",./;<>?")

    ##############################
    # DATA INPUT METHODS         #
    ##############################

    @_ansi
    def add_row(self, row):

        """Add a row to the table

        Arguments:

        row - row of data, should be a list with as many elements as the table
        has fields"""

        if self._field_names and len(row) != len(self._field_names):
            raise Exception("Row has incorrect number of values, (actual) %d!=%d (expected)" %(len(row),len(self._field_names)))
        if not self._field_names:
            self.field_names = [("Field %d" % (n+1)) for n in range(0,len(row))]
        self._rows.append(list(row))

    def del_row(self, row_index):

        """Delete a row to the table

        Arguments:

        row_index - The index of the row you want to delete.  Indexing starts at 0."""

        if row_index > len(self._rows)-1:
            raise Exception("Cant delete row at index %d, table only has %d rows!" % (row_index, len(self._rows)))
        del self._rows[row_index]

    @_ansi
    def add_column(self, fieldname, column, align="l", valign="t"):

        """Add a column to the table.

        Arguments:

        fieldname - name of the field to contain the new column of data
        column - column of data, should be a list with as many elements as the
        table has rows
        align - desired alignment for this column - "l" for left, "c" for centre and "r" for right
        valign - desired vertical alignment for new columns - "t" for top, "m" for middle and "b" for bottom"""

        if len(self._rows) in (0, len(column)):
            self._validate_align(align)
            self._validate_valign(valign)
            self._field_names.append(fieldname)
            self._align[fieldname] = align
            self._valign[fieldname] = valign
            for i in range(0, len(column)):
                if len(self._rows) < i+1:
                    self._rows.append([])
                self._rows[i].append(column[i])
        else:
            raise Exception("Column length %d does not match number of rows %d!" % (len(column), len(self._rows)))

    def clear_rows(self):

        """Delete all rows from the table but keep the current field names"""

        self._rows = []

    def clear(self):

        """Delete all rows and field names from the table, maintaining nothing but styling options"""

        self._rows = []
        self._field_names = []
        self._widths = []

    ##############################
    # MISC PUBLIC METHODS        #
    ##############################

    def copy(self):
        return copy.deepcopy(self)

    ##############################
    # MISC PRIVATE METHODS       #
    ##############################

    def _format_value(self, field, value):
        if isinstance(value, int) and field in self._int_format:
            value = self._unicode(("%%%sd" % self._int_format[field]) % value)
        elif isinstance(value, float) and field in self._float_format:
            value = self._unicode(("%%%sf" % self._float_format[field]) % value)
        return self._unicode(value)

    def _compute_widths(self, rows, options):
        if options["header"]:
            widths = [_get_size(field)[0] for field in self._field_names]
        else:
            widths = len(self.field_names) * [0]
        for row in rows:
            for index, value in enumerate(row):
                fieldname = self.field_names[index]
                if fieldname in self.max_width:
                    widths[index] = max(widths[index], min(_get_size(value)[0], self.max_width[fieldname]))
                else:
                    widths[index] = max(widths[index], _get_size(value)[0])
        self._widths = widths

    def _get_padding_widths(self, options):

        if options["left_padding_width"] is not None:
            lpad = options["left_padding_width"]
        else:
            lpad = options["padding_width"]
        if options["right_padding_width"] is not None:
            rpad = options["right_padding_width"]
        else:
            rpad = options["padding_width"]
        return lpad, rpad

    def _get_rows(self, options):
        """Return only those data rows that should be printed, based on slicing and sorting.

        Arguments:

        options - dictionary of option settings."""

        # Make a copy of only those rows in the slice range
        rows = copy.deepcopy(self._rows[options["start"]:options["end"]])
        # Sort if necessary
        if options["sortby"]:
            sortindex = self._field_names.index(options["sortby"])
            # Decorate
            rows = [[row[sortindex]]+row for row in rows]
            # Sort
            rows.sort(reverse=options["reversesort"], key=options["sort_key"])
            # Undecorate
            rows = [row[1:] for row in rows]
        return rows

    def _format_row(self, row, options):
        return [self._format_value(field, value) for (field, value) in zip(self._field_names, row)]

    def _format_rows(self, rows, options):
        return [self._format_row(row, options) for row in rows]

    ##############################
    # PLAIN TEXT STRING METHODS  #
    ##############################

    def get_string(self, **kwargs):

        """Return string representation of table in current state.

        Arguments:

        start - index of first data row to include in output
        end - index of last data row to include in output PLUS ONE (list slice style)
        fields - names of fields (columns) to include
        header - print a header showing field names (True or False)
        border - print a border around the table (True or False)
        hrules - controls printing of horizontal rules after rows.  Allowed values: ALL, FRAME, HEADER, NONE
        vrules - controls printing of vertical rules between columns.  Allowed values: FRAME, ALL, NONE
        int_format - controls formatting of integer data
        float_format - controls formatting of floating point data
        padding_width - number of spaces on either side of column data (only used if left and right paddings are None)
        left_padding_width - number of spaces on left hand side of column data
        right_padding_width - number of spaces on right hand side of column data
        vertical_char - single character string used to draw vertical lines
        horizontal_char - single character string used to draw horizontal lines
        junction_char - single character string used to draw line junctions
        sortby - name of field to sort rows by
        sort_key - sorting key function, applied to data points before sorting
        reversesort - True or False to sort in descending or ascending order
        print empty - if True, stringify just the header for an empty table, if False return an empty string """

        options = self._get_options(kwargs)

        lines = []

        # Don't think too hard about an empty table
        # Is this the desired behaviour?  Maybe we should still print the header?
        if self.rowcount == 0 and (not options["print_empty"] or not options["border"]):
            return ""

        #print "prettytable:", self._rows

        # Get the rows we need to print, taking into account slicing, sorting, etc.
        rows = self._get_rows(options)

        # Turn all data in all rows into Unicode, formatted as desired
        formatted_rows = self._format_rows(rows, options)

        # Compute column widths
        self._compute_widths(formatted_rows, options)

        # Add header or top of border
        self._hrule = self._stringify_hrule(options)
        if options["header"]:
            lines.append(self._stringify_header(options))
        elif options["border"] and options["hrules"] in (ALL, FRAME):
            lines.append(self._hrule)

        # Add rows
        for row in formatted_rows:
            lines.append(self._stringify_row(row, options))

        # Add bottom of border
        if options["border"] and options["hrules"] == FRAME:
            lines.append(self._hrule)

        return self._unicode("\n").join(lines)

    def _stringify_hrule(self, options):

        if not options["border"]:
            return ""
        lpad, rpad = self._get_padding_widths(options)
        if options['vrules'] in (ALL, FRAME):
            bits = [options["junction_char"]]
        else:
            bits = [options["horizontal_char"]]
        # For tables with no data or fieldnames
        if not self._field_names:
                bits.append(options["junction_char"])
                return "".join(bits)
        for field, width in zip(self._field_names, self._widths):
            if options["fields"] and field not in options["fields"]:
                continue
            bits.append((width+lpad+rpad)*options["horizontal_char"])
            if options['vrules'] == ALL:
                bits.append(options["junction_char"])
            else:
                bits.append(options["horizontal_char"])
        if options["vrules"] == FRAME:
            bits.pop()
            bits.append(options["junction_char"])
        return "".join(bits)

    def _stringify_header(self, options):

        bits = []
        lpad, rpad = self._get_padding_widths(options)
        if options["border"]:
            if options["hrules"] in (ALL, FRAME):
                bits.append(self._hrule)
                bits.append("\n")
            if options["vrules"] in (ALL, FRAME):
                bits.append(options["vertical_char"])
            else:
                bits.append(" ")
        # For tables with no data or field names
        if not self._field_names:
            if options["vrules"] in (ALL, FRAME):
                bits.append(options["vertical_char"])
            else:
                bits.append(" ")
        for field, width, in zip(self._field_names, self._widths):
            if options["fields"] and field not in options["fields"]:
                continue
            if self._header_style == "cap":
                fieldname = field.capitalize()
            elif self._header_style == "title":
                fieldname = field.title()
            elif self._header_style == "upper":
                fieldname = field.upper()
            elif self._header_style == "lower":
                fieldname = field.lower()
            else:
                fieldname = field
            bits.append(" " * lpad + self._justify(fieldname, width, self._align[field]) + " " * rpad)
            if options["border"]:
                if options["vrules"] == ALL:
                    bits.append(options["vertical_char"])
                else:
                    bits.append(" ")
        # If vrules is FRAME, then we just appended a space at the end
        # of the last field, when we really want a vertical character
        if options["border"] and options["vrules"] == FRAME:
            bits.pop()
            bits.append(options["vertical_char"])
        if options["border"] and options["hrules"] != NONE:
            bits.append("\n")
            bits.append(self._hrule)
        return "".join(bits)

    def _stringify_row(self, row, options):

        for index, field, value, width, in zip(range(0,len(row)), self._field_names, row, self._widths):
            # Enforce max widths
            lines = value.split("\n")
            new_lines = []
            for line in lines:
                if _str_block_width(line) > width:
                    line = textwrap.fill(line, width)
                new_lines.append(line)
            lines = new_lines
            value = "\n".join(lines)
            row[index] = value

        row_height = 0
        for c in row:
            h = _get_size(c)[1]
            if h > row_height:
                row_height = h

        bits = []
        lpad, rpad = self._get_padding_widths(options)
        for y in range(0, row_height):
            bits.append([])
            if options["border"]:
                if options["vrules"] in (ALL, FRAME):
                    bits[y].append(self.vertical_char)
                else:
                    bits[y].append(" ")

        for field, value, width, in zip(self._field_names, row, self._widths):

            valign = self._valign[field]
            lines = value.split("\n")
            dHeight = row_height - len(lines)
            if dHeight:
                if valign == "m":
                  lines = [""] * int(dHeight / 2) + lines + [""] * (dHeight - int(dHeight / 2))
                elif valign == "b":
                  lines = [""] * dHeight + lines
                else:
                  lines = lines + [""] * dHeight

            y = 0
            for l in lines:
                if options["fields"] and field not in options["fields"]:
                    continue

                bits[y].append(" " * lpad + self._justify(l, width, self._align[field]) + " " * rpad)
                if options["border"]:
                    if options["vrules"] == ALL:
                        bits[y].append(self.vertical_char)
                    else:
                        bits[y].append(" ")
                y += 1

        # If vrules is FRAME, then we just appended a space at the end
        # of the last field, when we really want a vertical character
        for y in range(0, row_height):
            if options["border"] and options["vrules"] == FRAME:
                bits[y].pop()
                bits[y].append(options["vertical_char"])

        if options["border"] and options["hrules"]== ALL:
            bits[row_height-1].append("\n")
            bits[row_height-1].append(self._hrule)

        for y in range(0, row_height):
            bits[y] = "".join(bits[y])

        return "\n".join(bits)

    ##############################
    # HTML STRING METHODS        #
    ##############################

    def get_html_string(self, **kwargs):

        """Return string representation of HTML formatted version of table in current state.

        Arguments:

        start - index of first data row to include in output
        end - index of last data row to include in output PLUS ONE (list slice style)
        fields - names of fields (columns) to include
        header - print a header showing field names (True or False)
        border - print a border around the table (True or False)
        hrules - controls printing of horizontal rules after rows.  Allowed values: ALL, FRAME, HEADER, NONE
        vrules - controls printing of vertical rules between columns.  Allowed values: FRAME, ALL, NONE
        int_format - controls formatting of integer data
        float_format - controls formatting of floating point data
        padding_width - number of spaces on either side of column data (only used if left and right paddings are None)
        left_padding_width - number of spaces on left hand side of column data
        right_padding_width - number of spaces on right hand side of column data
        sortby - name of field to sort rows by
        sort_key - sorting key function, applied to data points before sorting
        attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag
        xhtml - print <br/> tags if True, <br> tags if false"""

        options = self._get_options(kwargs)

        if options["format"]:
            string = self._get_formatted_html_string(options)
        else:
            string = self._get_simple_html_string(options)

        return string

    def _get_simple_html_string(self, options):

        lines = []
        if options["xhtml"]:
            linebreak = "<br/>"
        else:
            linebreak = "<br>"

        open_tag = []
        open_tag.append("<table")
        if options["attributes"]:
            for attr_name in options["attributes"]:
                open_tag.append(" %s=\"%s\"" % (attr_name, options["attributes"][attr_name]))
        open_tag.append(">")
        lines.append("".join(open_tag))

        # Headers
        if options["header"]:
            lines.append("    <tr>")
            for field in self._field_names:
                if options["fields"] and field not in options["fields"]:
                    continue
                lines.append("        <th>%s</th>" % escape(field).replace("\n", linebreak))
            lines.append("    </tr>")

        # Data
        rows = self._get_rows(options)
        formatted_rows = self._format_rows(rows, options)
        for row in formatted_rows:
            lines.append("    <tr>")
            for field, datum in zip(self._field_names, row):
                if options["fields"] and field not in options["fields"]:
                    continue
                lines.append("        <td>%s</td>" % escape(datum).replace("\n", linebreak))
            lines.append("    </tr>")

        lines.append("</table>")

        return self._unicode("\n").join(lines)

    def _get_formatted_html_string(self, options):

        lines = []
        lpad, rpad = self._get_padding_widths(options)
        if options["xhtml"]:
            linebreak = "<br/>"
        else:
            linebreak = "<br>"

        open_tag = []
        open_tag.append("<table")
        if options["border"]:
            if options["hrules"] == ALL and options["vrules"] == ALL:
                open_tag.append(" frame=\"box\" rules=\"all\"")
            elif options["hrules"] == FRAME and options["vrules"] == FRAME:
                open_tag.append(" frame=\"box\"")
            elif options["hrules"] == FRAME and options["vrules"] == ALL:
                open_tag.append(" frame=\"box\" rules=\"cols\"")
            elif options["hrules"] == FRAME:
                open_tag.append(" frame=\"hsides\"")
            elif options["hrules"] == ALL:
                open_tag.append(" frame=\"hsides\" rules=\"rows\"")
            elif options["vrules"] == FRAME:
                open_tag.append(" frame=\"vsides\"")
            elif options["vrules"] == ALL:
                open_tag.append(" frame=\"vsides\" rules=\"cols\"")
        if options["attributes"]:
            for attr_name in options["attributes"]:
                open_tag.append(" %s=\"%s\"" % (attr_name, options["attributes"][attr_name]))
        open_tag.append(">")
        lines.append("".join(open_tag))

        # Headers
        if options["header"]:
            lines.append("    <tr>")
            for field in self._field_names:
                if options["fields"] and field not in options["fields"]:
                    continue
                lines.append("        <th style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</th>" % (lpad, rpad, escape(field).replace("\n", linebreak)))
            lines.append("    </tr>")

        # Data
        rows = self._get_rows(options)
        formatted_rows = self._format_rows(rows, options)
        aligns = []
        valigns = []
        for field in self._field_names:
            aligns.append({ "l" : "left", "r" : "right", "c" : "center" }[self._align[field]])
            valigns.append({"t" : "top", "m" : "middle", "b" : "bottom"}[self._valign[field]])
        for row in formatted_rows:
            lines.append("    <tr>")
            for field, datum, align, valign in zip(self._field_names, row, aligns, valigns):
                if options["fields"] and field not in options["fields"]:
                    continue
                lines.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: %s; vertical-align: %s\">%s</td>" % (lpad, rpad, align, valign, escape(datum).replace("\n", linebreak)))
            lines.append("    </tr>")
        lines.append("</table>")

        return self._unicode("\n").join(lines)

##############################
# UNICODE WIDTH FUNCTIONS    #
##############################

def _char_block_width(char):
    # Basic Latin, which is probably the most common case
    #if char in xrange(0x0021, 0x007e):
    #if char >= 0x0021 and char <= 0x007e:
    if 0x0021 <= char <= 0x007e:
        return 1
    # Chinese, Japanese, Korean (common)
    if 0x4e00 <= char <= 0x9fff:
        return 2
    # Hangul
    if 0xac00 <= char <= 0xd7af:
        return 2
    # Combining?
    if unicodedata.combining(uni_chr(char)):
        return 0
    # Hiragana and Katakana
    if 0x3040 <= char <= 0x309f or 0x30a0 <= char <= 0x30ff:
        return 2
    # Full-width Latin characters
    if 0xff01 <= char <= 0xff60:
        return 2
    # CJK punctuation
    if 0x3000 <= char <= 0x303e:
        return 2
    # Backspace and delete
    if char in (0x0008, 0x007f):
        return -1
    # Other control characters
    elif char in (0x0000, 0x001f):
        return 0
    # Take a guess
    return 1

def _str_block_width(val):

    return sum(itermap(_char_block_width, itermap(ord, _re.sub("", val))))

##############################
# TABLE FACTORIES            #
##############################

def from_csv(fp, field_names = None, **kwargs):

    dialect = csv.Sniffer().sniff(fp.read(1024))
    fp.seek(0)
    reader = csv.reader(fp, dialect)

    table = PrettyTable(**kwargs)
    if field_names:
        table.field_names = field_names
    else:
        if py3k:
            table.field_names = [x.strip() for x in next(reader)]
        else:
            table.field_names = [x.strip() for x in reader.next()]

    for row in reader:
        table.add_row([x.strip() for x in row])

    return table

def from_db_cursor(cursor, **kwargs):

    if cursor.description:
        table = PrettyTable(**kwargs)
        table.field_names = [col[0] for col in cursor.description]
        for row in cursor.fetchall():
            table.add_row(row)
        return table

class TableHandler(HTMLParser):

    def __init__(self, **kwargs):
        HTMLParser.__init__(self)
        self.kwargs = kwargs
        self.tables = []
        self.last_row = []
        self.rows = []
        self.max_row_width = 0
        self.active = None
        self.last_content = ""
        self.is_last_row_header = False

    def handle_starttag(self,tag, attrs):
        self.active = tag
        if tag == "th":
            self.is_last_row_header = True

    def handle_endtag(self,tag):
        if tag in ["th", "td"]:
            stripped_content = self.last_content.strip()
            self.last_row.append(stripped_content)
        if tag == "tr":
            self.rows.append(
                (self.last_row, self.is_last_row_header))
            self.max_row_width = max(self.max_row_width, len(self.last_row))
            self.last_row = []
            self.is_last_row_header = False
        if tag == "table":
            table = self.generate_table(self.rows)
            self.tables.append(table)
            self.rows = []
        self.last_content = " "
        self.active = None


    def handle_data(self, data):
        self.last_content += data

    def generate_table(self, rows):
        """
        Generates from a list of rows a PrettyTable object.
        """
        table = PrettyTable(**self.kwargs)
        for row in self.rows:
            if len(row[0]) < self.max_row_width:
                appends = self.max_row_width - len(row[0])
                for i in range(1,appends):
                    row[0].append("-")

            if row[1] == True:
                self.make_fields_unique(row[0])
                table.field_names = row[0]
            else:
                table.add_row(row[0])
        return table

    def make_fields_unique(self, fields):
        """
        iterates over the row and make each field unique
        """
        for i in range(0, len(fields)):
            for j in range(i+1, len(fields)):
                if fields[i] == fields[j]:
                    fields[j] += "'"

def from_html(html_code, **kwargs):
    """
    Generates a list of PrettyTables from a string of HTML code. Each <table> in
    the HTML becomes one PrettyTable object.
    """

    parser = TableHandler(**kwargs)
    parser.feed(html_code)
    return parser.tables

def from_html_one(html_code, **kwargs):
    """
    Generates a PrettyTables from a string of HTML code which contains only a
    single <table>
    """

    tables = from_html(html_code, **kwargs)
    try:
        assert len(tables) == 1
    except AssertionError:
        raise Exception("More than one <table> in provided HTML code!  Use from_html instead.")
    return tables[0]

##############################
# MAIN (TEST FUNCTION)       #
##############################

def main():

    x = PrettyTable(["City name", "Area", "Population", "Annual Rainfall"])
    x.sortby = "Population"
    x.reversesort = True
    x.int_format["Area"] = "04d"
    x.float_format = "6.1f"
    x.align["City name"] = "l" # Left align city names
    x.add_row(["Adelaide", 1295, 1158259, 600.5])
    x.add_row(["Brisbane", 5905, 1857594, 1146.4])
    x.add_row(["Darwin", 112, 120900, 1714.7])
    x.add_row(["Hobart", 1357, 205556, 619.5])
    x.add_row(["Sydney", 2058, 4336374, 1214.8])
    x.add_row(["Melbourne", 1566, 3806092, 646.9])
    x.add_row(["Perth", 5386, 1554769, 869.4])
    print(x)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = search

"""
This is a convenient container gathering all the main
search methods for the various database tables.

It is intended to be used e.g. as

> from src.utils import search
> match = search.objects(...)

Note that this is not intended to be a complete listing of all search
methods! You need to refer to the respective manager to get all
possible search methods. To get to the managers from your code, import
the database model and call its 'objects' property.

Also remember that all commands in this file return lists (also if
there is only one match) unless noted otherwise.

Example: To reach the search method 'get_object_with_player'
         in src/objects/managers.py:

> from src.objects.models import ObjectDB
> match = Object.objects.get_object_with_player(...)


"""

# Import the manager methods to be wrapped

from django.contrib.contenttypes.models import ContentType

# limit symbol import from API
__all__ = ("search_object", "search_player", "search_script",
           "search_message", "search_channel", "search_help_entry",
           "search_object_tag", "search_script_tag", "search_player_tag",
           "search_channel_tag")


# import objects this way to avoid circular import problems
ObjectDB = ContentType.objects.get(app_label="objects", model="objectdb").model_class()
PlayerDB = ContentType.objects.get(app_label="players", model="playerdb").model_class()
ScriptDB = ContentType.objects.get(app_label="scripts", model="scriptdb").model_class()
Msg = ContentType.objects.get(app_label="comms", model="msg").model_class()
Channel = ContentType.objects.get(app_label="comms", model="channeldb").model_class()
HelpEntry = ContentType.objects.get(app_label="help", model="helpentry").model_class()
Tag = ContentType.objects.get(app_label="typeclasses", model="tag").model_class()

#
# Search objects as a character
#
# NOTE: A more powerful wrapper of this method
#  is reachable from within each command class
#  by using self.caller.search()!
#
#    def object_search(self, ostring=None,
#                      attribute_name=None,
#                      typeclass=None,
#                      candidates=None,
#                      exact=True):
#
#        Search globally or in a list of candidates and return results.
#        The result is always a list of Objects (or the empty list)
#
#        Arguments:
#        ostring: (str) The string to compare names against. By default (if
#                  not attribute_name is set), this will search object.key
#                  and object.aliases in order. Can also be on the form #dbref,
#                  which will, if exact=True be matched against primary key.
#        attribute_name: (str): Use this named ObjectAttribute to match ostring
#                        against, instead of the defaults.
#        typeclass (str or TypeClass): restrict matches to objects having
#                  this typeclass. This will help speed up global searches.
#        candidates (list obj ObjectDBs): If supplied, search will only be
#                  performed among the candidates in this list. A common list
#                  of candidates is the contents of the current location.
#        exact (bool): Match names/aliases exactly or partially. Partial
#                  matching matches the beginning of words in the names/aliases,
#                  using a matching routine to separate multiple matches in
#                  names with multiple components (so "bi sw" will match
#                  "Big sword"). Since this is more expensive than exact
#                  matching, it is recommended to be used together with
#                  the objlist keyword to limit the number of possibilities.
#                  This keyword has no meaning if attribute_name is set.
#
#        Returns:
#        A list of matching objects (or a list with one unique match)
#    def object_search(self, ostring, caller=None,
#                      candidates=None,
#                      attribute_name=None):
#
search_object = ObjectDB.objects.object_search
search_objects = search_object
object_search = search_object
objects = search_objects

#
# Search for players
#
# def player_search(self, ostring):
#     """
#     Searches for a particular player by name or
#     database id.
#
#     ostring = a string or database id.
#     """

search_player = PlayerDB.objects.player_search
search_players = search_player
player_search = search_player
players = search_players

#
#   Searching for scripts
#
# def script_search(self, ostring, obj=None, only_timed=False):
#     """
#     Search for a particular script.
#
#     ostring - search criterion - a script ID or key
#     obj - limit search to scripts defined on this object
#     only_timed - limit search only to scripts that run
#                  on a timer.
#     """

search_script = ScriptDB.objects.script_search
search_scripts = search_script
script_search = search_script
scripts = search_scripts
#
# Searching for communication messages
#
#
# def message_search(self, sender=None, receiver=None, channel=None, freetext=None):
#     """
#     Search the message database for particular messages. At least one
#     of the arguments must be given to do a search.
#
#     sender - get messages sent by a particular player
#     receiver - get messages received by a certain player
#     channel - get messages sent to a particular channel
#     freetext - Search for a text string in a message.
#                NOTE: This can potentially be slow, so make sure to supply
#                one of the other arguments to limit the search.
#     """

search_message = Msg.objects.message_search
search_messages = search_message
message_search = search_message
messages = search_messages

#
# Search for Communication Channels
#
# def channel_search(self, ostring)
#     """
#     Search the channel database for a particular channel.
#
#     ostring - the key or database id of the channel.
#     """

search_channel = Channel.objects.channel_search
search_channels = search_channel
channel_search = search_channel
channels = search_channels

#
# Find help entry objects.
#
# def search_help(self, ostring, help_category=None):
#     """
#     Retrieve a search entry object.
#
#     ostring - the help topic to look for
#     category - limit the search to a particular help topic
#     """

search_help_entry = HelpEntry.objects.search_help
search_help_entries = search_help_entry
help_entry_search = search_help_entry
help_entries = search_help_entries


# Locate Tags

#    search_object_tag(key, category=None) (also search_tag works)
#    search_player_tag(key, category=None)
#    search_script_tag(key, category=None)
#    search_channel_tag(key, category=None)

# Note that this returns the object attached to the tag, not the tag itself
# (this is usually what you want)
search_tag = Tag.objects.get_objs_with_tag
def search_object_tag(key, category=None): return Tag.objects.get_objs_with_tag(key, category, model="objects.objectdb")
def search_player_tag(key, category=None): return Tag.objects.get_objs_with_tag(key, category, model="players.playerdb")
def search_script_tag(key, category=None): return Tag.objects.get_objs_with_tag(key, category, model="scripts.scriptdb")
def search_channel_tag(key, category=None): return Tag.objects.get_objs_with_tag(key, category, model="comms.channeldb")

#        """
#        Search and return all tags matching any combination of
#        the search criteria.
#         search_key (string) - the tag identifier
#         category (string) - the tag category
#         model - one of
#              "objects.objectdb" (default), "players.playerdb",
#              "scripts.scriptdb" or "comms.channeldb"
#
#        Returns a single Tag (or None) if both key and category is given,
#        otherwise it will return a list.
#        """
# This returns the tag object itself.
search_tag_object = Tag.objects.get_tag



########NEW FILE########
__FILENAME__ = tests
import re

try:
    from django.utils.unittest import TestCase
except ImportError:
    from django.test import TestCase

from ansi import ANSIString


class ANSIStringTestCase(TestCase):
    def checker(self, ansi, raw, clean):
        """
        Verifies the raw and clean strings of an ANSIString match expected
        output.
        """
        self.assertEqual(unicode(ansi.clean()), clean)
        self.assertEqual(unicode(ansi.raw()), raw)

    def table_check(self, ansi, char, code):
        """
        Verifies the indexes in an ANSIString match what they should.
        """
        self.assertEqual(ansi._char_indexes, char)
        self.assertEqual(ansi._code_indexes, code)

    def test_instance(self):
        """
        Make sure the ANSIString is always constructed correctly.
        """
        clean = u'This isA{r testTest'
        encoded = u'\x1b[1m\x1b[32mThis is\x1b[1m\x1b[31mA{r test\x1b[0mTest\x1b[0m'
        target = ANSIString(r'{gThis is{rA{{r test{nTest{n')
        char_table = [9, 10, 11, 12, 13, 14, 15, 25, 26, 27, 28, 29, 30, 31,
                      32, 37, 38, 39, 40]
        code_table = [0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 18, 19, 20, 21, 22,
                      23, 24, 33, 34, 35, 36, 41, 42, 43, 44]
        self.checker(target, encoded, clean)
        self.table_check(target, char_table, code_table)
        self.checker(ANSIString(target), encoded, clean)
        self.table_check(ANSIString(target), char_table, code_table)
        self.checker(ANSIString(encoded, decoded=True), encoded, clean)
        self.table_check(ANSIString(encoded, decoded=True), char_table,
                         code_table)
        self.checker(ANSIString('Test'), u'Test', u'Test')
        self.table_check(ANSIString('Test'), [0, 1, 2, 3], [])
        self.checker(ANSIString(''), u'', u'')

    def test_slice(self):
        """
        Verifies that slicing an ANSIString results in expected color code
        distribution.
        """
        target = ANSIString(r'{gTest{rTest{n')
        result = target[:3]
        self.checker(result, u'\x1b[1m\x1b[32mTes', u'Tes')
        result = target[:4]
        self.checker(result, u'\x1b[1m\x1b[32mTest\x1b[1m\x1b[31m', u'Test')
        result = target[:]
        self.checker(
            result,
            u'\x1b[1m\x1b[32mTest\x1b[1m\x1b[31mTest\x1b[0m',
            u'TestTest')
        result = target[:-1]
        self.checker(
            result,
            u'\x1b[1m\x1b[32mTest\x1b[1m\x1b[31mTes',
            u'TestTes')
        result = target[0:0]
        self.checker(
            result,
            u'',
            u'')

    def test_split(self):
        """
        Verifies that re.split and .split behave similarly and that color
        codes end up where they should.
        """
        target = ANSIString("{gThis is {nA split string{g")
        first = (u'\x1b[1m\x1b[32mThis is \x1b[0m', u'This is ')
        second = (u'\x1b[1m\x1b[32m\x1b[0m split string\x1b[1m\x1b[32m',
                  u' split string')
        re_split = re.split('A', target)
        normal_split = target.split('A')
        self.assertEqual(re_split, normal_split)
        self.assertEqual(len(normal_split), 2)
        self.checker(normal_split[0], *first)
        self.checker(normal_split[1], *second)

    def test_join(self):
        """
        Verify that joining a set of ANSIStrings works.
        """
        # This isn't the desired behavior, but the expected one. Python
        # concatinates the in-memory representation with the built-in string's
        # join.
        l = [ANSIString("{gTest{r") for s in range(0, 3)]
        # Force the generator to be evaluated.
        result = "".join(l)
        self.assertEqual(unicode(result), u'TestTestTest')
        result = ANSIString("").join(l)
        self.checker(result, u'\x1b[1m\x1b[32mTest\x1b[1m\x1b[31m\x1b[1m\x1b'
                             u'[32mTest\x1b[1m\x1b[31m\x1b[1m\x1b[32mTest'
                             u'\x1b[1m\x1b[31m', u'TestTestTest')

    def test_len(self):
        """
        Make sure that length reporting on ANSIStrings does not include
        ANSI codes.
        """
        self.assertEqual(len(ANSIString('{gTest{n')), 4)

    def test_capitalize(self):
        """
        Make sure that capitalization works. This is the simplest of the
        _transform functions.
        """
        target = ANSIString('{gtest{n')
        result = u'\x1b[1m\x1b[32mTest\x1b[0m'
        self.checker(target.capitalize(), result, u'Test')
########NEW FILE########
__FILENAME__ = text2html

"""
ANSI -> html converter

Credit for original idea and implementation
goes to Muhammad Alkarouri and his
snippet #577349 on http://code.activestate.com.

(extensively modified by Griatch 2010)
"""

import re
import cgi
from ansi import *


class TextToHTMLparser(object):
    """
    This class describes a parser for converting from ansi to html.
    """

    tabstop = 4
    # mapping html color name <-> ansi code.
    hilite = ANSI_HILITE
    normal = ANSI_NORMAL
    underline = ANSI_UNDERLINE
    colorcodes = [
            ('red', hilite + ANSI_RED),
            ('maroon', ANSI_RED),
            ('lime', hilite + ANSI_GREEN),
            ('green', ANSI_GREEN),
            ('yellow', hilite + ANSI_YELLOW),
            ('olive', ANSI_YELLOW),
            ('blue', hilite + ANSI_BLUE),
            ('navy', ANSI_BLUE),
            ('magenta', hilite + ANSI_MAGENTA),
            ('purple', ANSI_MAGENTA),
            ('cyan', hilite + ANSI_CYAN),
            ('teal', ANSI_CYAN),
            ('white', hilite + ANSI_WHITE),  # pure white
            ('gray', ANSI_WHITE),  # light grey
            ('dimgray', hilite + ANSI_BLACK),  # dark grey
            ('black', ANSI_BLACK),  # pure black
    ]
    colorback = [
            ('bgred', hilite + ANSI_BACK_RED),
            ('bgmaroon', ANSI_BACK_RED),
            ('bglime', hilite + ANSI_BACK_GREEN),
            ('bggreen', ANSI_BACK_GREEN),
            ('bgyellow', hilite + ANSI_BACK_YELLOW),
            ('bgolive', ANSI_BACK_YELLOW),
            ('bgblue', hilite + ANSI_BACK_BLUE),
            ('bgnavy', ANSI_BACK_BLUE),
            ('bgmagenta', hilite + ANSI_BACK_MAGENTA),
            ('bgpurple', ANSI_BACK_MAGENTA),
            ('bgcyan', hilite + ANSI_BACK_CYAN),
            ('bgteal', ANSI_BACK_CYAN),
            ('bgwhite', hilite + ANSI_BACK_WHITE),
            ('bggray', ANSI_BACK_WHITE),
            ('bgdimgray', hilite + ANSI_BACK_BLACK),
            ('bgblack', ANSI_BACK_BLACK),
    ]

    # make sure to escape [
    colorcodes = [(c, code.replace("[", r"\[")) for c, code in colorcodes]
    colorback = [(c, code.replace("[", r"\[")) for c, code in colorback]
    # create stop markers
    fgstop = [("", c.replace("[", r"\[")) for c in (normal, hilite, underline)]
    bgstop = [("", c.replace("[", r"\[")) for c in (normal,)]
    fgstop = "|".join(co[1] for co in colorcodes + fgstop + [("", "$")])
    bgstop = "|".join(co[1] for co in colorback + bgstop + [("", "$")])

    # pre-compile regexes
    re_fgs = [(cname, re.compile("(?:%s)(.*?)(?=%s)" % (code, fgstop))) for cname, code in colorcodes]
    re_bgs = [(cname, re.compile("(?:%s)(.*?)(?=%s)" % (code, bgstop))) for cname, code in colorback]
    re_normal = re.compile(normal.replace("[", r"\["))
    re_hilite = re.compile("(?:%s)(.*)(?=%s)" % (hilite.replace("[", r"\["), fgstop))
    re_uline = re.compile("(?:%s)(.*?)(?=%s)" % (ANSI_UNDERLINE.replace("[", r"\["), fgstop))
    re_string = re.compile(r'(?P<htmlchars>[<&>])|(?P<space> [ \t]+)|(?P<lineend>\r\n|\r|\n)', re.S|re.M|re.I)

    def re_color(self, text):
        """
        Replace ansi colors with html color class names.
        Let the client choose how it will display colors, if it wishes to.  """
        for colorname, regex in self.re_fgs:
            text = regex.sub(r'''<span class="%s">\1</span>''' % colorname, text)
        for bgname, regex in self.re_bgs:
            text = regex.sub(r'''<span class="%s">\1</span>''' % bgname, text)
        return self.re_normal.sub("", text)

    def re_bold(self, text):
        "Clean out superfluous hilights rather than set <strong>to make it match the look of telnet."
        return self.re_hilite.sub(r'<strong>\1</strong>', text)

    def re_underline(self, text):
        "Replace ansi underline with html underline class name."
        return self.re_uline.sub(r'<span class="underline">\1</span>', text)

    def remove_bells(self, text):
        "Remove ansi specials"
        return text.replace('\07', '')

    def remove_backspaces(self, text):
        "Removes special escape sequences"
        backspace_or_eol = r'(.\010)|(\033\[K)'
        n = 1
        while n > 0:
            text, n = re.subn(backspace_or_eol, '', text, 1)
        return text

    def convert_linebreaks(self, text):
        "Extra method for cleaning linebreaks"
        return text.replace(r'\n', r'<br>')

    def convert_urls(self, text):
        "Replace urls (http://...) by valid HTML"
        regexp = r"((ftp|www|http)(\W+\S+[^).,:;?\]\}(\<span\>) \r\n$\"\']+))"
        # -> added target to output prevent the web browser from attempting to
        # change pages (and losing our webclient session).
        return re.sub(regexp, r'<a href="\1" target="_blank">\1</a>', text)

    def do_sub(self, m):
        "Helper method to be passed to re.sub."
        c = m.groupdict()
        if c['htmlchars']:
            return cgi.escape(c['htmlchars'])
        if c['lineend']:
            return '<br>'
        elif c['space'] == '\t':
            return ' ' * self.tabstop
        elif c['space']:
            t = m.group().replace('\t', '&nbsp;' * self.tabstop)
            t = t.replace(' ', '&nbsp;')
            return t

    def parse(self, text, strip_ansi=False):
        """
        Main access function, converts a text containing
        ansi codes into html statements.
        """
        # parse everything to ansi first
        text = parse_ansi(text, strip_ansi=strip_ansi, xterm256=False)
        # convert all ansi to html
        result = re.sub(self.re_string, self.do_sub, text)
        result = self.re_color(result)
        result = self.re_bold(result)
        result = self.re_underline(result)
        result = self.remove_bells(result)
        result = self.convert_linebreaks(result)
        result = self.remove_backspaces(result)
        result = self.convert_urls(result)
        # clean out eventual ansi that was missed
        #result = parse_ansi(result, strip_ansi=True)

        return result

HTML_PARSER = TextToHTMLparser()


#
# Access function
#

def parse_html(string, strip_ansi=False, parser=HTML_PARSER):
    """
    Parses a string, replace ansi markup with html
    """
    return parser.parse(string, strip_ansi=strip_ansi)

########NEW FILE########
__FILENAME__ = txws
# Copyright (c) 2011 Oregon State University Open Source Lab
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#    The above copyright notice and this permission notice shall be included
#    in all copies or substantial portions of the Software.
#
#    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
#    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
#    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
#    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
#    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
#    USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
Blind reimplementation of WebSockets as a standalone wrapper for Twisted
protocols.
"""

__version__ = "0.7.1"

from base64 import b64encode, b64decode
from hashlib import md5, sha1
from string import digits
from struct import pack, unpack

from twisted.internet.interfaces import ISSLTransport
from twisted.protocols.policies import ProtocolWrapper, WrappingFactory
from twisted.python import log
from twisted.web.http import datetimeToString

class WSException(Exception):
    """
    Something stupid happened here.

    If this class escapes txWS, then something stupid happened in multiple
    places.
    """

# Flavors of WS supported here.
# HYBI00  - Hixie-76, HyBi-00. Challenge/response after headers, very minimal
#           framing. Tricky to start up, but very smooth sailing afterwards.
# HYBI07  - HyBi-07. Modern "standard" handshake. Bizarre masked frames, lots
#           of binary data packing.
# HYBI10  - HyBi-10. Just like HyBi-07. No, seriously. *Exactly* the same,
#           except for the protocol number.
# RFC6455 - RFC 6455. The official WebSocket protocol standard. The protocol
#           number is 13, but otherwise it is identical to HyBi-07.

HYBI00, HYBI07, HYBI10, RFC6455 = range(4)

# States of the state machine. Because there are no reliable byte counts for
# any of this, we don't use StatefulProtocol; instead, we use custom state
# enumerations. Yay!

REQUEST, NEGOTIATING, CHALLENGE, FRAMES = range(4)

# Control frame specifiers. Some versions of WS have control signals sent
# in-band. Adorable, right?

NORMAL, CLOSE, PING, PONG = range(4)

opcode_types = {
    0x0: NORMAL,
    0x1: NORMAL,
    0x2: NORMAL,
    0x8: CLOSE,
    0x9: PING,
    0xa: PONG,
}

encoders = {
    "base64": b64encode,
}

decoders = {
    "base64": b64decode,
}

# Fake HTTP stuff, and a couple convenience methods for examining fake HTTP
# headers.

def http_headers(s):
    """
    Create a dictionary of data from raw HTTP headers.
    """

    d = {}

    for line in s.split("\r\n"):
        try:
            key, value = [i.strip() for i in line.split(":", 1)]
            d[key] = value
        except ValueError:
            pass

    return d

def is_websocket(headers):
    """
    Determine whether a given set of headers is asking for WebSockets.
    """

    return ("upgrade" in headers.get("Connection", "").lower()
            and headers.get("Upgrade").lower() == "websocket")

def is_hybi00(headers):
    """
    Determine whether a given set of headers is HyBi-00-compliant.

    Hixie-76 and HyBi-00 use a pair of keys in the headers to handshake with
    servers.
    """

    return "Sec-WebSocket-Key1" in headers and "Sec-WebSocket-Key2" in headers

# Authentication for WS.

def complete_hybi00(headers, challenge):
    """
    Generate the response for a HyBi-00 challenge.
    """

    key1 = headers["Sec-WebSocket-Key1"]
    key2 = headers["Sec-WebSocket-Key2"]

    first = int("".join(i for i in key1 if i in digits)) / key1.count(" ")
    second = int("".join(i for i in key2 if i in digits)) / key2.count(" ")

    nonce = pack(">II8s", first, second, challenge)

    return md5(nonce).digest()

def make_accept(key):
    """
    Create an "accept" response for a given key.

    This dance is expected to somehow magically make WebSockets secure.
    """

    guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

    return sha1("%s%s" % (key, guid)).digest().encode("base64").strip()

# Frame helpers.
# Separated out to make unit testing a lot easier.
# Frames are bonghits in newer WS versions, so helpers are appreciated.

def make_hybi00_frame(buf):
    """
    Make a HyBi-00 frame from some data.

    This function does exactly zero checks to make sure that the data is safe
    and valid text without any 0xff bytes.
    """

    return "\x00%s\xff" % buf

def parse_hybi00_frames(buf):
    """
    Parse HyBi-00 frames, returning unwrapped frames and any unmatched data.

    This function does not care about garbage data on the wire between frames,
    and will actively ignore it.
    """

    start = buf.find("\x00")
    tail = 0
    frames = []

    while start != -1:
        end = buf.find("\xff", start + 1)
        if end == -1:
            # Incomplete frame, try again later.
            break
        else:
            # Found a frame, put it in the list.
            frame = buf[start + 1:end]
            frames.append((NORMAL, frame))
            tail = end + 1
        start = buf.find("\x00", end + 1)

    # Adjust the buffer and return.
    buf = buf[tail:]
    return frames, buf

def mask(buf, key):
    """
    Mask or unmask a buffer of bytes with a masking key.

    The key must be exactly four bytes long.
    """

    # This is super-secure, I promise~
    key = [ord(i) for i in key]
    buf = list(buf)
    for i, char in enumerate(buf):
        buf[i] = chr(ord(char) ^ key[i % 4])
    return "".join(buf)

def make_hybi07_frame(buf, opcode=0x1):
    """
    Make a HyBi-07 frame.

    This function always creates unmasked frames, and attempts to use the
    smallest possible lengths.
    """

    if len(buf) > 0xffff:
        length = "\x7f%s" % pack(">Q", len(buf))
    elif len(buf) > 0x7d:
        length = "\x7e%s" % pack(">H", len(buf))
    else:
        length = chr(len(buf))

    # Always make a normal packet.
    header = chr(0x80 | opcode)
    frame = "%s%s%s" % (header, length, buf)
    return frame

def make_hybi07_frame_dwim(buf):
    """
    Make a HyBi-07 frame with binary or text data according to the type of buf.
    """
    
    # TODO: eliminate magic numbers.
    if isinstance(buf, str):
        return make_hybi07_frame(buf, opcode=0x2)
    elif isinstance(buf, unicode):
        return make_hybi07_frame(buf.encode("utf-8"), opcode=0x1)
    else:
        raise TypeError("In binary support mode, frame data must be either str or unicode")

def parse_hybi07_frames(buf):
    """
    Parse HyBi-07 frames in a highly compliant manner.
    """

    start = 0
    frames = []

    while True:
        # If there's not at least two bytes in the buffer, bail.
        if len(buf) - start < 2:
            break

        # Grab the header. This single byte holds some flags nobody cares
        # about, and an opcode which nobody cares about.
        header = ord(buf[start])
        if header & 0x70:
            # At least one of the reserved flags is set. Pork chop sandwiches!
            raise WSException("Reserved flag in HyBi-07 frame (%d)" % header)
            frames.append(("", CLOSE))
            return frames, buf

        # Get the opcode, and translate it to a local enum which we actually
        # care about.
        opcode = header & 0xf
        try:
            opcode = opcode_types[opcode]
        except KeyError:
            raise WSException("Unknown opcode %d in HyBi-07 frame" % opcode)

        # Get the payload length and determine whether we need to look for an
        # extra length.
        length = ord(buf[start + 1])
        masked = length & 0x80
        length &= 0x7f

        # The offset we're gonna be using to walk through the frame. We use
        # this because the offset is variable depending on the length and
        # mask.
        offset = 2

        # Extra length fields.
        if length == 0x7e:
            if len(buf) - start < 4:
                break

            length = buf[start + 2:start + 4]
            length = unpack(">H", length)[0]
            offset += 2
        elif length == 0x7f:
            if len(buf) - start < 10:
                break

            # Protocol bug: The top bit of this long long *must* be cleared;
            # that is, it is expected to be interpreted as signed. That's
            # fucking stupid, if you don't mind me saying so, and so we're
            # interpreting it as unsigned anyway. If you wanna send exabytes
            # of data down the wire, then go ahead!
            length = buf[start + 2:start + 10]
            length = unpack(">Q", length)[0]
            offset += 8

        if masked:
            if len(buf) - (start + offset) < 4:
                break

            key = buf[start + offset:start + offset + 4]
            offset += 4

        if len(buf) - (start + offset) < length:
            break

        data = buf[start + offset:start + offset + length]

        if masked:
            data = mask(data, key)

        if opcode == CLOSE:
            if len(data) >= 2:
                # Gotta unpack the opcode and return usable data here.
                data = unpack(">H", data[:2])[0], data[2:]
            else:
                # No reason given; use generic data.
                data = 1000, "No reason given"

        frames.append((opcode, data))
        start += offset + length

    return frames, buf[start:]

class WebSocketProtocol(ProtocolWrapper):
    """
    Protocol which wraps another protocol to provide a WebSockets transport
    layer.
    """

    buf = ""
    codec = None
    location = "/"
    host = "example.com"
    origin = "http://example.com"
    state = REQUEST
    flavor = None
    do_binary_frames = False

    def __init__(self, *args, **kwargs):
        ProtocolWrapper.__init__(self, *args, **kwargs)
        self.pending_frames = []

    def setBinaryMode(self, mode):
        """
        If True, send str as binary and unicode as text.
        
        Defaults to false for backwards compatibility.
        """
        self.do_binary_frames = bool(mode)

    def isSecure(self):
        """
        Borrowed technique for determining whether this connection is over
        SSL/TLS.
        """

        return ISSLTransport(self.transport, None) is not None

    def sendCommonPreamble(self):
        """
        Send the preamble common to all WebSockets connections.

        This might go away in the future if WebSockets continue to diverge.
        """

        self.transport.writeSequence([
            "HTTP/1.1 101 FYI I am not a webserver\r\n",
            "Server: TwistedWebSocketWrapper/1.0\r\n",
            "Date: %s\r\n" % datetimeToString(),
            "Upgrade: WebSocket\r\n",
            "Connection: Upgrade\r\n",
        ])

    def sendHyBi00Preamble(self):
        """
        Send a HyBi-00 preamble.
        """

        protocol = "wss" if self.isSecure() else "ws"

        self.sendCommonPreamble()

        self.transport.writeSequence([
            "Sec-WebSocket-Origin: %s\r\n" % self.origin,
            "Sec-WebSocket-Location: %s://%s%s\r\n" % (protocol, self.host,
                                                       self.location),
            "WebSocket-Protocol: %s\r\n" % self.codec,
            "Sec-WebSocket-Protocol: %s\r\n" % self.codec,
            "\r\n",
        ])

    def sendHyBi07Preamble(self):
        """
        Send a HyBi-07 preamble.
        """

        self.sendCommonPreamble()
        challenge = self.headers["Sec-WebSocket-Key"]
        response = make_accept(challenge)

        self.transport.write("Sec-WebSocket-Accept: %s\r\n\r\n" % response)

    def parseFrames(self):
        """
        Find frames in incoming data and pass them to the underlying protocol.
        """

        if self.flavor == HYBI00:
            parser = parse_hybi00_frames
        elif self.flavor in (HYBI07, HYBI10, RFC6455):
            parser = parse_hybi07_frames
        else:
            raise WSException("Unknown flavor %r" % self.flavor)

        try:
            frames, self.buf = parser(self.buf)
        except WSException, wse:
            # Couldn't parse all the frames, something went wrong, let's bail.
            self.close(wse.args[0])
            return

        for frame in frames:
            opcode, data = frame
            if opcode == NORMAL:
                # Business as usual. Decode the frame, if we have a decoder.
                if self.codec:
                    data = decoders[self.codec](data)
                # Pass the frame to the underlying protocol.
                ProtocolWrapper.dataReceived(self, data)
            elif opcode == CLOSE:
                # The other side wants us to close. I wonder why?
                reason, text = data
                log.msg("Closing connection: %r (%d)" % (text, reason))

                # Close the connection.
                self.close()

    def sendFrames(self):
        """
        Send all pending frames.
        """

        if self.state != FRAMES:
            return

        if self.flavor == HYBI00:
            maker = make_hybi00_frame
        elif self.flavor in (HYBI07, HYBI10, RFC6455):
            if self.do_binary_frames:
                maker = make_hybi07_frame_dwim
            else:
                maker = make_hybi07_frame
        else:
            raise WSException("Unknown flavor %r" % self.flavor)

        for frame in self.pending_frames:
            # Encode the frame before sending it.
            if self.codec:
                frame = encoders[self.codec](frame)
            packet = maker(frame)
            self.transport.write(packet)
        self.pending_frames = []

    def validateHeaders(self):
        """
        Check received headers for sanity and correctness, and stash any data
        from them which will be required later.
        """

        # Obvious but necessary.
        if not is_websocket(self.headers):
            log.msg("Not handling non-WS request")
            return False

        # Stash host and origin for those browsers that care about it.
        if "Host" in self.headers:
            self.host = self.headers["Host"]
        if "Origin" in self.headers:
            self.origin = self.headers["Origin"]

        # Check whether a codec is needed. WS calls this a "protocol" for
        # reasons I cannot fathom. Newer versions of noVNC (0.4+) sets
        # multiple comma-separated codecs, handle this by chosing first one
        # we can encode/decode.
        protocols = None
        if "WebSocket-Protocol" in self.headers:
            protocols = self.headers["WebSocket-Protocol"]
        elif "Sec-WebSocket-Protocol" in self.headers:
            protocols = self.headers["Sec-WebSocket-Protocol"]

        if isinstance(protocols, basestring):
            protocols = [p.strip() for p in protocols.split(',')]

            for protocol in protocols:
                if protocol in encoders or protocol in decoders:
                    log.msg("Using WS protocol %s!" % protocol)
                    self.codec = protocol
                    break

                log.msg("Couldn't handle WS protocol %s!" % protocol)

            if not self.codec:
                return False

        # Start the next phase of the handshake for HyBi-00.
        if is_hybi00(self.headers):
            log.msg("Starting HyBi-00/Hixie-76 handshake")
            self.flavor = HYBI00
            self.state = CHALLENGE

        # Start the next phase of the handshake for HyBi-07+.
        if "Sec-WebSocket-Version" in self.headers:
            version = self.headers["Sec-WebSocket-Version"]
            if version == "7":
                log.msg("Starting HyBi-07 conversation")
                self.sendHyBi07Preamble()
                self.flavor = HYBI07
                self.state = FRAMES
            elif version == "8":
                log.msg("Starting HyBi-10 conversation")
                self.sendHyBi07Preamble()
                self.flavor = HYBI10
                self.state = FRAMES
            elif version == "13":
                log.msg("Starting RFC 6455 conversation")
                self.sendHyBi07Preamble()
                self.flavor = RFC6455
                self.state = FRAMES
            else:
                log.msg("Can't support protocol version %s!" % version)
                return False

        return True

    def dataReceived(self, data):
        self.buf += data

        oldstate = None

        while oldstate != self.state:
            oldstate = self.state

            # Handle initial requests. These look very much like HTTP
            # requests, but aren't. We need to capture the request path for
            # those browsers which want us to echo it back to them (Chrome,
            # mainly.)
            # These lines look like:
            # GET /some/path/to/a/websocket/resource HTTP/1.1
            if self.state == REQUEST:
                if "\r\n" in self.buf:
                    request, chaff, self.buf = self.buf.partition("\r\n")
                    try:
                        verb, self.location, version = request.split(" ")
                    except ValueError:
                        self.loseConnection()
                    else:
                        self.state = NEGOTIATING

            elif self.state == NEGOTIATING:
                # Check to see if we've got a complete set of headers yet.
                if "\r\n\r\n" in self.buf:
                    head, chaff, self.buf = self.buf.partition("\r\n\r\n")
                    self.headers = http_headers(head)
                    # Validate headers. This will cause a state change.
                    if not self.validateHeaders():
                        self.loseConnection()

            elif self.state == CHALLENGE:
                # Handle the challenge. This is completely exclusive to
                # HyBi-00/Hixie-76.
                if len(self.buf) >= 8:
                    challenge, self.buf = self.buf[:8], self.buf[8:]
                    response = complete_hybi00(self.headers, challenge)
                    self.sendHyBi00Preamble()
                    self.transport.write(response)
                    log.msg("Completed HyBi-00/Hixie-76 handshake")
                    # We're all finished here; start sending frames.
                    self.state = FRAMES

            elif self.state == FRAMES:
                self.parseFrames()

        # Kick any pending frames. This is needed because frames might have
        # started piling up early; we can get write()s from our protocol above
        # when they makeConnection() immediately, before our browser client
        # actually sends any data. In those cases, we need to manually kick
        # pending frames.
        if self.pending_frames:
            self.sendFrames()

    def write(self, data):
        """
        Write to the transport.

        This method will only be called by the underlying protocol.
        """

        self.pending_frames.append(data)
        self.sendFrames()

    def writeSequence(self, data):
        """
        Write a sequence of data to the transport.

        This method will only be called by the underlying protocol.
        """

        self.pending_frames.extend(data)
        self.sendFrames()

    def close(self, reason=""):
        """
        Close the connection.

        This includes telling the other side we're closing the connection.

        If the other side didn't signal that the connection is being closed,
        then we might not see their last message, but since their last message
        should, according to the spec, be a simple acknowledgement, it
        shouldn't be a problem.
        """

        # Send a closing frame. It's only polite. (And might keep the browser
        # from hanging.)
        if self.flavor in (HYBI07, HYBI10, RFC6455):
            frame = make_hybi07_frame(reason, opcode=0x8)
            self.transport.write(frame)

        self.loseConnection()

class WebSocketFactory(WrappingFactory):
    """
    Factory which wraps another factory to provide WebSockets transports for
    all of its protocols.
    """

    protocol = WebSocketProtocol

########NEW FILE########
__FILENAME__ = utils
"""
General helper functions that don't fit neatly under any given category.

They provide some useful string and conversion methods that might
be of use when designing your own game.

"""

import os
import sys
import imp
import types
import math
import re
import textwrap
import datetime
import random
import traceback
from inspect import ismodule
from collections import defaultdict
from twisted.internet import threads, defer, reactor
from django.conf import settings

try:
    import cPickle as pickle
except ImportError:
    import pickle

ENCODINGS = settings.ENCODINGS
_GA = object.__getattribute__
_SA = object.__setattr__
_DA = object.__delattr__


def is_iter(iterable):
    """
    Checks if an object behaves iterably. However,
    strings are not accepted as iterable (although
    they are actually iterable), since string iterations
    are usually not what we want to do with a string.
    """
    # use a try..except here to avoid a property
    # lookup when using this from a typeclassed entity
    try:
        _GA(iterable, '__iter__')
        return True
    except AttributeError:
        return False


def make_iter(obj):
    "Makes sure that the object is always iterable."
    return not hasattr(obj, '__iter__') and [obj] or obj


def fill(text, width=78, indent=0):
    """
    Safely wrap text to a certain number of characters.

    text: (str) The text to wrap.
    width: (int) The number of characters to wrap to.
    indent: (int) How much to indent new lines (the first line
                  will not be indented)
    """
    if not text:
        return ""
    indent = " " * indent
    return textwrap.fill(str(text), width, subsequent_indent=indent)


def crop(text, width=78, suffix="[...]"):
    """
    Crop text to a certain width, adding suffix to show the line
    continues. Cropping will be done so that the suffix will also fit
    within the given width. If width is too small to fit both crop
    and suffix, crop without the suffix.
    """
    ltext = len(to_str(text))
    if ltext <= width:
        return text
    else:
        lsuffix = len(suffix)
        return text[:width] if lsuffix >= width else "%s%s" % (text[:width - lsuffix], suffix)


def dedent(text):
    """
    Safely clean all whitespace at the left
    of a paragraph. This is useful for preserving
    triple-quoted string indentation while still
    shifting it all to be next to the left edge of
    the display.
    """
    if not text:
        return ""
    return textwrap.dedent(text)


def list_to_string(inlist, endsep="and", addquote=False):
    """
    This pretty-formats a list as string output, adding
    an optional alternative separator to the second to last entry.
    If addquote is True, the outgoing strings will be surrounded by quotes.

    Examples:
     no endsep:
        [1,2,3] -> '1, 2, 3'
     with endsep=='and':
        [1,2,3] -> '1, 2 and 3'
     with addquote and endsep
        [1,2,3] -> '"1", "2" and "3"'
    """
    if not endsep:
        endsep = ","
    else:
        endsep = " " + endsep
    if not inlist:
        return ""
    if addquote:
        if len(inlist) == 1:
            return "\"%s\"" % inlist[0]
        return ", ".join("\"%s\"" % v for v in inlist[:-1]) + "%s %s" % (endsep, "\"%s\"" % inlist[-1])
    else:
        if len(inlist) == 1:
            return str(inlist[0])
        return ", ".join(str(v) for v in inlist[:-1]) + "%s %s" % (endsep, inlist[-1])


def wildcard_to_regexp(instring):
    """
    Converts a player-supplied string that may have wildcards in it to regular
    expressions. This is useful for name matching.

    instring: (string) A string that may potentially contain wildcards (* or ?).
    """
    regexp_string = ""

    # If the string starts with an asterisk, we can't impose the beginning of
    # string (^) limiter.
    if instring[0] != "*":
        regexp_string += "^"

    # Replace any occurances of * or ? with the appropriate groups.
    regexp_string += instring.replace("*", "(.*)").replace("?", "(.{1})")

    # If there's an asterisk at the end of the string, we can't impose the
    # end of string ($) limiter.
    if instring[-1] != "*":
        regexp_string += "$"

    return regexp_string


def time_format(seconds, style=0):
    """
    Function to return a 'prettified' version of a value in seconds.

    Style 0: 1d 08:30
    Style 1: 1d
    Style 2: 1 day, 8 hours, 30 minutes, 10 seconds
    """
    if seconds < 0:
        seconds = 0
    else:
        # We'll just use integer math, no need for decimal precision.
        seconds = int(seconds)

    days = seconds / 86400
    seconds -= days * 86400
    hours = seconds / 3600
    seconds -= hours * 3600
    minutes = seconds / 60
    seconds -= minutes * 60

    if style is 0:
        """
        Standard colon-style output.
        """
        if days > 0:
            retval = '%id %02i:%02i' % (days, hours, minutes,)
        else:
            retval = '%02i:%02i' % (hours, minutes,)

        return retval
    elif style is 1:
        """
        Simple, abbreviated form that only shows the highest time amount.
        """
        if days > 0:
            return '%id' % (days,)
        elif hours > 0:
            return '%ih' % (hours,)
        elif minutes > 0:
            return '%im' % (minutes,)
        else:
            return '%is' % (seconds,)
    elif style is 2:
        """
        Full-detailed, long-winded format. We ignore seconds.
        """
        days_str = hours_str = minutes_str = seconds_str = ''
        if days > 0:
            if days == 1:
                days_str = '%i day, ' % days
            else:
                days_str = '%i days, ' % days
        if days or hours > 0:
            if hours == 1:
                hours_str = '%i hour, ' % hours
            else:
                hours_str = '%i hours, ' % hours
        if hours or minutes > 0:
            if minutes == 1:
                minutes_str = '%i minute ' % minutes
            else:
                minutes_str = '%i minutes ' % minutes
        retval = '%s%s%s' % (days_str, hours_str, minutes_str)
    elif style is 3:
        """
        Full-detailed, long-winded format. Includes seconds.
        """
        days_str = hours_str = minutes_str = seconds_str = ''
        if days > 0:
            if days == 1:
                days_str = '%i day, ' % days
            else:
                days_str = '%i days, ' % days
        if days or hours > 0:
            if hours == 1:
                hours_str = '%i hour, ' % hours
            else:
                hours_str = '%i hours, ' % hours
        if hours or minutes > 0:
            if minutes == 1:
                minutes_str = '%i minute ' % minutes
            else:
                minutes_str = '%i minutes ' % minutes
        if minutes or seconds > 0:
            if seconds == 1:
                seconds_str = '%i second ' % seconds
            else:
                seconds_str = '%i seconds ' % seconds
        retval = '%s%s%s%s' % (days_str, hours_str, minutes_str, seconds_str)

    return retval


def datetime_format(dtobj):
    """
    Takes a datetime object instance (e.g. from django's DateTimeField)
    and returns a string describing how long ago that date was.

    """

    year, month, day = dtobj.year, dtobj.month, dtobj.day
    hour, minute, second = dtobj.hour, dtobj.minute, dtobj.second
    now = datetime.datetime.now()

    if year < now.year:
        # another year
        timestring = str(dtobj.date())
    elif dtobj.date() < now.date():
        # another date, same year
        timestring = "%02i-%02i" % (day, month)
    elif hour < now.hour - 1:
        # same day, more than 1 hour ago
        timestring = "%02i:%02i" % (hour, minute)
    else:
        # same day, less than 1 hour ago
        timestring = "%02i:%02i:%02i" % (hour, minute, second)
    return timestring


def host_os_is(osname):
    """
    Check to see if the host OS matches the query.
    """
    if os.name == osname:
        return True
    return False


def get_evennia_version():
    """
    Check for the evennia version info.
    """
    try:
        f = open(settings.BASE_PATH + os.sep + "VERSION.txt", 'r')
        return "%s-%s" % (f.read().strip(), os.popen("git rev-parse --short HEAD").read().strip())
    except IOError:
        return "Unknown version"


def pypath_to_realpath(python_path, file_ending='.py'):
    """
    Converts a path on dot python form (e.g. 'src.objects.models') to
    a system path ($BASE_PATH/src/objects/models.py). Calculates all
    paths as absoulte paths starting from the evennia main directory.

    Since it seems to be a common mistake to include the file ending
    when entering filename for things like batchprocess, we handle the
    case of erroneously adding the file ending too.
    """
    pathsplit = python_path.strip().split('.')
    if python_path.endswith(file_ending):
        # this is actually a malformed path ...
        pathsplit = pathsplit[:-1]
    if not pathsplit:
        return python_path
    path = settings.BASE_PATH
    for directory in pathsplit:
        path = os.path.join(path, directory)
    if file_ending:
        return "%s%s" % (path, file_ending)
    return path


def dbref(dbref, reqhash=True):
    """
    Converts/checks if input is a valid dbref.  If reqhash is set,
    only input strings on the form '#N', where N is an integer is
    accepted. Otherwise strings '#N', 'N' and integers N are all
    accepted.
     Output is the integer part.
    """
    if reqhash:
        return (int(dbref.lstrip('#')) if (isinstance(dbref, basestring) and
                                           dbref.startswith("#") and
                                           dbref.lstrip('#').isdigit())
                                       else None)
    elif isinstance(dbref, basestring):
        dbref = dbref.lstrip('#')
        return int(dbref) if dbref.isdigit() else None
    return dbref if isinstance(dbref, int) else None


def to_unicode(obj, encoding='utf-8', force_string=False):
    """
    This decodes a suitable object to the unicode format. Note that
    one needs to encode it back to utf-8 before writing to disk or
    printing. Note that non-string objects are let through without
    conversion - this is important for e.g. Attributes. Use
    force_string to enforce conversion of objects to string. .
    """

    if force_string and not isinstance(obj, basestring):
        # some sort of other object. Try to
        # convert it to a string representation.
        if hasattr(obj, '__str__'):
            obj = obj.__str__()
        elif hasattr(obj, '__unicode__'):
            obj = obj.__unicode__()
        else:
            # last resort
            obj = str(obj)

    if isinstance(obj, basestring) and not isinstance(obj, unicode):
        try:
            obj = unicode(obj, encoding)
            return obj
        except UnicodeDecodeError:
            for alt_encoding in ENCODINGS:
                try:
                    obj = unicode(obj, alt_encoding)
                    return obj
                except UnicodeDecodeError:
                    pass
        raise Exception("Error: '%s' contains invalid character(s) not in %s." % (obj, encoding))
    return obj


def to_str(obj, encoding='utf-8', force_string=False):
    """
    This encodes a unicode string back to byte-representation,
    for printing, writing to disk etc. Note that non-string
    objects are let through without modification - this is
    required e.g. for Attributes. Use force_string to force
    conversion of objects to strings.
    """

    if force_string and not isinstance(obj, basestring):
        # some sort of other object. Try to
        # convert it to a string representation.
        try:
            obj = str(obj)
        except Exception:
            obj = unicode(obj)

    if isinstance(obj, basestring) and isinstance(obj, unicode):
        try:
            obj = obj.encode(encoding)
            return obj
        except UnicodeEncodeError:
            for alt_encoding in ENCODINGS:
                try:
                    obj = obj.encode(encoding)
                    return obj
                except UnicodeEncodeError:
                    pass
        raise Exception("Error: Unicode could not encode unicode string '%s'(%s) to a bytestring. " % (obj, encoding))
    return obj


def validate_email_address(emailaddress):
    """
    Checks if an email address is syntactically correct.

    (This snippet was adapted from
    http://commandline.org.uk/python/email-syntax-check.)
    """

    emailaddress = r"%s" % emailaddress

    domains = ("aero", "asia", "biz", "cat", "com", "coop",
               "edu", "gov", "info", "int", "jobs", "mil", "mobi", "museum",
               "name", "net", "org", "pro", "tel", "travel")

    # Email address must be more than 7 characters in total.
    if len(emailaddress) < 7:
        return False  # Address too short.

    # Split up email address into parts.
    try:
        localpart, domainname = emailaddress.rsplit('@', 1)
        host, toplevel = domainname.rsplit('.', 1)
    except ValueError:
        return False  # Address does not have enough parts.

    # Check for Country code or Generic Domain.
    if len(toplevel) != 2 and toplevel not in domains:
        return False  # Not a domain name.

    for i in '-_.%+.':
        localpart = localpart.replace(i, "")
    for i in '-_.':
        host = host.replace(i, "")

    if localpart.isalnum() and host.isalnum():
        return True  # Email address is fine.
    else:
        return False  # Email address has funny characters.


def inherits_from(obj, parent):
    """
    Takes an object and tries to determine if it inherits at any distance
    from parent. What differs this function from e.g. isinstance()
    is that obj may be both an instance and a class, and parent
    may be an instance, a class, or the python path to a class (counting
    from the evennia root directory).
    """

    if callable(obj):
        # this is a class
        obj_paths = ["%s.%s" % (mod.__module__, mod.__name__) for mod in obj.mro()]
    else:
        obj_paths = ["%s.%s" % (mod.__module__, mod.__name__) for mod in obj.__class__.mro()]

    if isinstance(parent, basestring):
        # a given string path, for direct matching
        parent_path = parent
    elif callable(parent):
        # this is a class
        parent_path = "%s.%s" % (parent.__module__, parent.__name__)
    else:
        parent_path = "%s.%s" % (parent.__class__.__module__, parent.__class__.__name__)
    return any(1 for obj_path in obj_paths if obj_path == parent_path)


def server_services():
    """
    Lists all services active on the Server. Observe that
    since services are launced in memory, this function will
    only return any results if called from inside the game.
    """
    from src.server.sessionhandler import SESSIONS
    if hasattr(SESSIONS, "server") and hasattr(SESSIONS.server, "services"):
        server = SESSIONS.server.services.namedServices
    else:
        # This function must be called from inside the evennia process.
        server = {}
    del SESSIONS
    return server


def uses_database(name="sqlite3"):
    """
    Checks if the game is currently using a given database. This is a
    shortcut to having to use the full backend name

    name - one of 'sqlite3', 'mysql', 'postgresql_psycopg2' or 'oracle'
    """
    try:
        engine = settings.DATABASES["default"]["ENGINE"]
    except KeyError:
        engine = settings.DATABASE_ENGINE
    return engine == "django.db.backends.%s" % name


def delay(delay=2, callback=None, retval=None):
    """
    Delay the return of a value.
    Inputs:
      delay (int) - the delay in seconds
      callback (func() or func(retval)) - if given, will be called without
                     arguments or with retval after delay seconds
      retval (any) - this will be returned by this function after a delay,
                     or as input to callback
    Returns:
      deferred that will fire with callback after delay seconds. Note that
      if delay() is used in the commandhandler callback chain, the callback
      chain can be defined directly in the command body and don't need to be
      specified here.
    """
    callb = callback or defer.Deferred().callback
    if retval is not None:
        return reactor.callLater(delay, callb, retval)
    else:
        return reactor.callLater(delay, callb)


_TYPECLASSMODELS = None
_OBJECTMODELS = None
def clean_object_caches(obj):
    """
    Clean all object caches on the given object
    """
    global _TYPECLASSMODELS, _OBJECTMODELS
    if not _TYPECLASSMODELS:
        from src.typeclasses import models as _TYPECLASSMODELS
    #if not _OBJECTMODELS:
    #    from src.objects import models as _OBJECTMODELS

    #print "recaching:", obj
    if not obj:
        return
    obj = hasattr(obj, "dbobj") and obj.dbobj or obj
    # contents cache
    try:
        _SA(obj, "_contents_cache", None)
    except AttributeError:
        pass

    # on-object property cache
    [_DA(obj, cname) for cname in obj.__dict__.keys()
                     if cname.startswith("_cached_db_")]
    try:
        hashid = _GA(obj, "hashid")
        _TYPECLASSMODELS._ATTRIBUTE_CACHE[hashid] = {}
    except AttributeError:
        pass


_PPOOL = None
_PCMD = None
_PROC_ERR = "A process has ended with a probable error condition: process ended by signal 9."
def run_async(to_execute, *args, **kwargs):
    """
    Runs a function or executes a code snippet asynchronously.

    Inputs:
    to_execute (callable) - if this is a callable, it will
            be executed with *args and non-reserver *kwargs as
            arguments.
            The callable will be executed using ProcPool, or in
            a thread if ProcPool is not available.

    reserved kwargs:
        'at_return' -should point to a callable with one argument.
                    It will be called with the return value from
                    to_execute.
        'at_return_kwargs' - this dictionary which be used as keyword
                             arguments to the at_return callback.
        'at_err' - this will be called with a Failure instance if
                       there is an error in to_execute.
        'at_err_kwargs' - this dictionary will be used as keyword
                          arguments to the at_err errback.

    *args   - these args will be used
              as arguments for that function. If to_execute is a string
              *args are not used.
    *kwargs - these kwargs will be used
              as keyword arguments in that function. If a string, they
              instead are used to define the executable environment
              that should be available to execute the code in to_execute.

    run_async will relay executed code to a thread or procpool.

    Use this function with restrain and only for features/commands
    that you know has no influence on the cause-and-effect order of your
    game (commands given after the async function might be executed before
    it has finished). Accessing the same property from different threads
    can lead to unpredicted behaviour if you are not careful (this is called a
    "race condition").

    Also note that some databases, notably sqlite3, don't support access from
    multiple threads simultaneously, so if you do heavy database access from
    your to_execute under sqlite3 you will probably run very slow or even get
    tracebacks.

    """

    # handle special reserved input kwargs
    callback = kwargs.pop("at_return", None)
    errback = kwargs.pop("at_err", None)
    callback_kwargs = kwargs.pop("at_return_kwargs", {})
    errback_kwargs = kwargs.pop("at_err_kwargs", {})

    if callable(to_execute):
        # no process pool available, fall back to old deferToThread mechanism.
        deferred = threads.deferToThread(to_execute, *args, **kwargs)
    else:
        # no appropriate input for this server setup
        raise RuntimeError("'%s' could not be handled by run_async" % to_execute)

    # attach callbacks
    if callback:
        deferred.addCallback(callback, **callback_kwargs)
    deferred.addErrback(errback, **errback_kwargs)


def check_evennia_dependencies():
    """
    Checks the versions of Evennia's dependencies.

    Returns False if a show-stopping version mismatch is found.
    """
    # defining the requirements
    python_min = '2.6'
    nt_python_min = '2.7'
    nt_stop_python_min = "2.6"
    twisted_min = '11.0'
    django_min = '1.5'
    django_rec = '1.6'
    south_min = '0.8.4'

    errstring = ""
    no_error = True

    # Python
    pversion = ".".join(str(num) for num in sys.version_info if type(num) == int)
    if pversion < python_min:
        errstring += "\n WARNING: Python %s used. Evennia recommends version %s or higher (but not 3.x)." % (pversion, python_min)
    if os.name == 'nt' and pversion < nt_python_min:
        errstring += "\n WARNING: Python %s used. Windows requires v%s or higher in order to" % (pversion, nt_stop_python_min)
        errstring += "\n          restart/stop the server from the command line (Under v%s you" % pversion
        errstring += "\n          may only restart/stop from inside the game.)"
    # Twisted
    try:
        import twisted
        tversion = twisted.version.short()
        if tversion < twisted_min:
            errstring += "\n WARNING: Twisted %s found. Evennia recommends v%s or higher." % (twisted.version.short(), twisted_min)
    except ImportError:
        errstring += "\n ERROR: Twisted does not seem to be installed."
        no_error = False
    # Django
    try:
        import django
        dversion = ".".join(str(num) for num in django.VERSION if type(num) == int)
        dversion_main = ".".join(dversion.split(".")[:2]) # only the main version (1.5, not 1.5.4.0)
        if dversion < django_min:
            errstring += "\n ERROR: Django %s found. Evennia requires version %s or higher." % (dversion, django_min)
            no_error = False
        elif django_min <= dversion < django_rec:
            errstring += "\n NOTE: Django %s found. This will work, but v%s is recommended for production." % (dversion, django_rec)
        elif django_rec < dversion_main:
            errstring += "\n NOTE: Django %s found. This is newer than Evennia's recommended version. It will"
            errstring += "\n       probably work, but may be new enough not to be fully tested yet. Report any issues."
    except ImportError:
        errstring += "\n ERROR: Django does not seem to be installed."
        no_error = False
    # South
    try:
        import south
        sversion = south.__version__
        if sversion < south_min:
            errstring += "\n WARNING: South %s found. Evennia recommends version %s or higher." % (sversion, south_min)
        if sversion in ("0.8.2", "0.8.3"):
            errstring += "\n ERROR: South %s found. This has known issues. Please upgrade." % sversion
            no_error = False
    except ImportError:
        errstring += "\n ERROR: South (django-south) does not seem to be installed."
        no_error = False
    # IRC support
    if settings.IRC_ENABLED:
        try:
            import twisted.words
            twisted.words  # set to avoid debug info about not-used import
        except ImportError:
            errstring += "\n ERROR: IRC is enabled, but twisted.words is not installed. Please install it."
            errstring += "\n   Linux Debian/Ubuntu users should install package 'python-twisted-words', others"
            errstring += "\n   can get it from http://twistedmatrix.com/trac/wiki/TwistedWords."
            no_error = False
    errstring = errstring.strip()
    if errstring:
        mlen = max(len(line) for line in errstring.split("\n"))
        print "%s\n%s\n%s" % ("-"*mlen, errstring, '-'*mlen)
    return no_error


def has_parent(basepath, obj):
    "Checks if basepath is somewhere in objs parent tree."
    try:
        return any(cls for cls in obj.__class__.mro()
                   if basepath == "%s.%s" % (cls.__module__, cls.__name__))
    except (TypeError, AttributeError):
        # this can occur if we tried to store a class object, not an
        # instance. Not sure if one should defend against this.
        return False


def mod_import(module):
    """
    A generic Python module loader.

    Args:
        module - this can be either a Python path (dot-notation like
                 src.objects.models), an absolute path
                 (e.g. /home/eve/evennia/src/objects.models.py)
                 or an already import module object (e.g. models)
    Returns:
        an imported module. If the input argument was already a model,
        this is returned as-is, otherwise the path is parsed and imported.
    Error:
        returns None. The error is also logged.
    """

    def log_trace(errmsg=None):
        """
        Log a traceback to the log. This should be called
        from within an exception. errmsg is optional and
        adds an extra line with added info.
        """
        from twisted.python import log
        print errmsg

        tracestring = traceback.format_exc()
        if tracestring:
            for line in tracestring.splitlines():
                log.msg('[::] %s' % line)
        if errmsg:
            try:
                errmsg = to_str(errmsg)
            except Exception, e:
                errmsg = str(e)
            for line in errmsg.splitlines():
                log.msg('[EE] %s' % line)

    if not module:
        return None

    if isinstance(module, types.ModuleType):
        # if this is already a module, we are done
        mod = module
    else:
        # first try to import as a python path
        try:
            mod = __import__(module, fromlist=["None"])
        except ImportError, ex:
            # check just where the ImportError happened (it could have been
            # an erroneous import inside the module as well). This is the
            # trivial way to do it ...
            if str(ex) != "Import by filename is not supported.":
                #log_trace("ImportError inside module '%s': '%s'" % (module, str(ex)))
                raise

            # error in this module. Try absolute path import instead

            if not os.path.isabs(module):
                module = os.path.abspath(module)
            path, filename = module.rsplit(os.path.sep, 1)
            modname = re.sub(r"\.py$", "", filename)

            try:
                result = imp.find_module(modname, [path])
            except ImportError:
                log_trace("Could not find module '%s' (%s.py) at path '%s'" % (modname, modname, path))
                return
            try:
                mod = imp.load_module(modname, *result)
            except ImportError:
                log_trace("Could not find or import module %s at path '%s'" % (modname, path))
                mod = None
            # we have to close the file handle manually
            result[0].close()
    return mod


def all_from_module(module):
    """
    Return all global-level variables from a module as a dict
    """
    mod = mod_import(module)
    return dict((key, val) for key, val in mod.__dict__.items()
                            if not (key.startswith("_") or ismodule(val)))


def variable_from_module(module, variable=None, default=None):
    """
    Retrieve a variable or list of variables from a module. The variable(s)
    must be defined globally in the module. If no variable is given (or a
    list entry is None), all global variables are extracted from the module.

    If module cannot be imported or given variable not found, default
    is returned.

    Args:
      module (string or module)- python path, absolute path or a module
      variable (string or iterable) - single variable name or iterable of
                                      variable names to extract
      default (string) - default value to use if a variable fails
                         to be extracted. Ignored if variable is not given
    Returns:
      a single value or a list of values depending on the type of
        'variable' argument. Errors in lists are replaced by the
        'default' argument.
    """

    if not module:
        return default

    mod = mod_import(module)

    if variable:
        result = []
        for var in make_iter(variable):
            if var:
                # try to pick a named variable
                result.append(mod.__dict__.get(var, default))
    else:
        # get all
        result = [val for key, val in mod.__dict__.items()
                         if not (key.startswith("_") or ismodule(val))]

    if len(result) == 1:
        return result[0]
    return result


def string_from_module(module, variable=None, default=None):
    """
    This is a wrapper for variable_from_module that requires return
    value to be a string to pass. It's primarily used by login screen.
    """
    val = variable_from_module(module, variable=variable, default=default)
    if isinstance(val, basestring):
        return val
    elif is_iter(val):
        result = [v for v in val if isinstance(v, basestring)]
        return result if result else default
    return default

def random_string_from_module(module):
    """
    Returns a random global string from a module
    """
    string = string_from_module(module)
    if is_iter(string):
        string = random.choice(string)
    return string

def init_new_player(player):
    """
    Helper method to call all hooks, set flags etc on a newly created
    player (and potentially their character, if it exists already)
    """
    # the FIRST_LOGIN flags are necessary for the system to call
    # the relevant first-login hooks.
    #if player.character:
    #    player.character.db.FIRST_LOGIN = True
    player.db.FIRST_LOGIN = True


def string_similarity(string1, string2):
    """
    This implements a "cosine-similarity" algorithm as described for example in
       Proceedings of the 22nd International Conference on Computation
       Linguistics (Coling 2008), pages 593-600, Manchester, August 2008
    The measure-vectors used is simply a "bag of words" type histogram
    (but for letters).

    The function returns a value 0...1 rating how similar the two strings
    are. The strings can contain multiple words.
    """
    vocabulary = set(list(string1 + string2))
    vec1 = [string1.count(v) for v in vocabulary]
    vec2 = [string2.count(v) for v in vocabulary]
    try:
        return float(sum(vec1[i] * vec2[i] for i in range(len(vocabulary)))) / \
               (math.sqrt(sum(v1**2 for v1 in vec1)) * math.sqrt(sum(v2**2 for v2 in vec2)))
    except ZeroDivisionError:
        # can happen if empty-string cmdnames appear for some reason.
        # This is a no-match.
        return 0


def string_suggestions(string, vocabulary, cutoff=0.6, maxnum=3):
    """
    Given a string and a vocabulary, return a match or a list of suggestsion
    based on string similarity.

    Args:
        string (str)- a string to search for
        vocabulary (iterable) - a list of available strings
        cutoff (int, 0-1) - limit the similarity matches (higher, the more
                            exact is required)
        maxnum (int) - maximum number of suggestions to return
    Returns:
        list of suggestions from vocabulary (could be empty if there are
        no matches)
    """
    return [tup[1] for tup in sorted([(string_similarity(string, sugg), sugg)
                                       for sugg in vocabulary],
                                           key=lambda tup: tup[0], reverse=True)
                                           if tup[0] >= cutoff][:maxnum]


def string_partial_matching(alternatives, inp, ret_index=True):
    """
    Partially matches a string based on a list of alternatives. Matching
    is made from the start of each subword in each alternative. Case is not
    important. So e.g. "bi sh sw" or just "big" or "shiny" or "sw" will match
    "Big shiny sword". Scoring is done to allow to separate by most common
    demoninator. You will get multiple matches returned if appropriate.

    Input:
        alternatives (list of str) - list of possible strings to match
        inp (str) - search criterion
        ret_index (bool) - return list of indices (from alternatives
                           array) or strings
    Returns:
        list of matching indices or strings, or an empty list

    """
    if not alternatives or not inp:
        return []

    matches = defaultdict(list)
    inp_words = inp.lower().split()
    for altindex, alt in enumerate(alternatives):
        alt_words = alt.lower().split()
        last_index = 0
        score = 0
        for inp_word in inp_words:
            # loop over parts, making sure only to visit each part once
            # (this will invalidate input in the wrong word order)
            submatch = [last_index + alt_num for alt_num, alt_word
                        in enumerate(alt_words[last_index:])
                                     if alt_word.startswith(inp_word)]
            if submatch:
                last_index = min(submatch) + 1
                score += 1
            else:
                score = 0
                break
        if score:
            if ret_index:
                matches[score].append(altindex)
            else:
                matches[score].append(alt)
    if matches:
        return matches[max(matches)]
    return []


def format_table(table, extra_space=1):
    """
    Note: src.utils.prettytable is more powerful than this, but this
    function can be useful when the number of columns and rows are
    unknown and must be calculated on the fly.

    Takes a table of collumns: [[val,val,val,...], [val,val,val,...], ...]
    where each val will be placed on a separate row in the column. All
    collumns must have the same number of rows (some positions may be
    empty though).

    The function formats the columns to be as wide as the widest member
    of each column.

    extra_space defines how much extra padding should minimum be left between
    collumns.

    print the resulting list e.g. with

    for ir, row in enumarate(ftable):
        if ir == 0:
            # make first row white
            string += "\n{w" + ""join(row) + "{n"
        else:
            string += "\n" + "".join(row)
    print string

    """
    if not table:
        return [[]]

    max_widths = [max([len(str(val)) for val in col]) for col in table]
    ftable = []
    for irow in range(len(table[0])):
        ftable.append([str(col[irow]).ljust(max_widths[icol]) + " " * extra_space
                       for icol, col in enumerate(table)])
    return ftable


def get_evennia_pids():
    """
    Get the currently valids PIDs (Process IDs) of the Portal and Server
    by trying to access an PID file. This can be used to determine if we
    are in a subprocess by something like

     self_pid = os.getpid()
     server_pid, portal_pid = get_evennia_pids()
     is_subprocess = self_pid not in (server_pid, portal_pid)

    """
    server_pidfile = os.path.join(settings.GAME_DIR, 'server.pid')
    portal_pidfile = os.path.join(settings.GAME_DIR, 'portal.pid')
    server_pid, portal_pid = None, None
    if os.path.exists(server_pidfile):
        f = open(server_pidfile, 'r')
        server_pid = f.read()
        f.close()
    if os.path.exists(portal_pidfile):
        f = open(portal_pidfile, 'r')
        portal_pid = f.read()
        f.close()
    if server_pid and portal_pid:
        return int(server_pid), int(portal_pid)
    return None, None

########NEW FILE########
__FILENAME__ = backends
from django.contrib.auth.backends import ModelBackend
from django.contrib.auth import get_user_model

class CaseInsensitiveModelBackend(ModelBackend):
  """
  By default ModelBackend does case _sensitive_ username authentication, which isn't what is
  generally expected.  This backend supports case insensitive username authentication.
  """
  def authenticate(self, username=None, password=None):
    User = get_user_model()
    try:
      user = User.objects.get(username__iexact=username)
      if user.check_password(password):
        return user
      else:
        return None
    except User.DoesNotExist:
      return None

########NEW FILE########
__FILENAME__ = admin
#
# This makes the news model visible in the admin web interface
# so one can add/edit/delete news items etc. 
#

from django.contrib import admin
from src.web.news.models import NewsTopic, NewsEntry

class NewsTopicAdmin(admin.ModelAdmin):
    list_display = ('name', 'icon')
admin.site.register(NewsTopic, NewsTopicAdmin)

class NewsEntryAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'topic', 'date_posted')
    list_filter = ('topic',)
    search_fields = ['title']
admin.site.register(NewsEntry, NewsEntryAdmin)

########NEW FILE########
__FILENAME__ = models
#
# This module implements a simple news entry system
# for the evennia website. One needs to use the
# admin interface to add/edit/delete entries.
#

from django.db import models
from django.contrib.auth import get_user_model

User = get_user_model()

class NewsTopic(models.Model):
    """
    Represents a news topic.
    """
    name = models.CharField(max_length=75, unique=True)
    description = models.TextField(blank=True)
    icon = models.ImageField(upload_to='newstopic_icons',
                             default='newstopic_icons/default.png',
                             blank=True, help_text="Image for the news topic.")

    def __str__(self):
        try:
            return self.name
        except:
            return "Invalid"

    class Meta:
        ordering = ['name']

class NewsEntry(models.Model):
    """
    An individual news entry.
    """
    author = models.ForeignKey(User, related_name='author')
    title = models.CharField(max_length=255)
    body = models.TextField()
    topic = models.ForeignKey(NewsTopic, related_name='newstopic')
    date_posted = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

    class Meta:
        ordering = ('-date_posted',)
        verbose_name_plural = "News entries"


########NEW FILE########
__FILENAME__ = urls
"""
This structures the url tree for the news application.
It is imported from the root handler, game.web.urls.py.
"""

from django.conf.urls import *

urlpatterns = patterns('src.web.news.views',
     (r'^show/(?P<entry_id>\d+)/$', 'show_news'),
     (r'^archive/$', 'news_archive'),
     (r'^search/$', 'search_form'),
     (r'^search/results/$', 'search_results'),
)

########NEW FILE########
__FILENAME__ = views

"""
This is a very simple news application, with most of the expected features
like news-categories/topics and searchable archives.

"""

from django.views.generic import ListView
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from django.conf import settings
from django.http import HttpResponseRedirect
from django.contrib.auth.models import User
from django import forms
from django.db.models import Q

from src.web.news.models import NewsTopic, NewsEntry

# The sidebar text to be included as a variable on each page. There's got to
# be a better, cleaner way to include this on every page.
sidebar = """
    <p class='doNotDisplay doNotPrint'>This page&rsquo;s menu:</p>
    <ul id='side-bar'>
      <li><a href='/news/archive'>News Archive</a></li>
      <li><a href='/news/search'>Search News</a></li>
    </ul>
"""

class SearchForm(forms.Form):
    """
    Class to represent a news search form under Django's newforms. This is used
    to validate the input on the search_form view, as well as the search_results
    view when we're picking the query out of GET. This makes searching safe
    via the search form or by directly inputing values via GET key pairs.
    """
    search_terms = forms.CharField(max_length=100, min_length=3, required=True)

def show_news(request, entry_id):
    """
    Show an individual news entry. Display some basic information along with
    the title and content.
    """
    news_entry = get_object_or_404(NewsEntry, id=entry_id)

    pagevars = {
        "page_title": "News Entry",
        "news_entry": news_entry,
        "sidebar": sidebar
    }

    context_instance = RequestContext(request)
    return render_to_response('news/show_entry.html', pagevars, context_instance)

def news_archive(request):
    """
    Shows an archive of news entries.

    TODO: Expand this a bit to allow filtering by month/year.
    """
    news_entries = NewsEntry.objects.all().order_by('-date_posted')
    # TODO: Move this to either settings.py or the SQL configuration.
    entries_per_page = 15

    pagevars = {
        "page_title": "News Archive",
        "browse_url": "/news/archive",
        "sidebar": sidebar
    }
    view = ListView.as_view(queryset=news_entries)
    return view(request, template_name='news/archive.html',  \
        extra_context=pagevars, paginate_by=entries_per_page)

def search_form(request):
    """
    Render the news search form. Don't handle much validation at all. If the
    user enters a search term that meets the minimum, send them on their way
    to the results page.
    """
    if request.method == 'GET':
        # A GET request was sent to the search page, load the value and
        # validate it.
        search_form = SearchForm(request.GET)
        if search_form.is_valid():
            # If the input is good, send them to the results page with the
            # query attached in GET variables.
            return HttpResponseRedirect('/news/search/results/?search_terms='+ search_form.cleaned_data['search_terms'])
    else:
        # Brand new search, nothing has been sent just yet.
        search_form = SearchForm()

    pagevars = {
        "page_title": "Search News",
        "search_form": search_form,
        "debug": settings.DEBUG,
        "sidebar": sidebar
    }

    context_instance = RequestContext(request)
    return render_to_response('news/search_form.html', pagevars, context_instance)

def search_results(request):
    """
    Shows an archive of news entries. Use the generic news browsing template.
    """
    # TODO: Move this to either settings.py or the SQL configuration.
    entries_per_page = 15

    # Load the form values from GET to validate against.
    search_form = SearchForm(request.GET)
    # You have to call is_valid() or cleaned_data won't be populated.
    valid_search = search_form.is_valid()
    # This is the safe data that we can pass to queries without huge worry of
    # badStuff(tm).
    cleaned_get = search_form.cleaned_data

    # Perform searches that match the title and contents.
    # TODO: Allow the user to specify what to match against and in what
    # topics/categories.
    news_entries = NewsEntry.objects.filter(Q(title__contains=cleaned_get['search_terms']) | Q(body__contains=cleaned_get['search_terms']))

    pagevars = {
        "game_name": settings.SERVERNAME,
        "page_title": "Search Results",
        "searchtext": cleaned_get['search_terms'],
        "browse_url": "/news/search/results",
        "sidebar": sidebar
    }
    view = ListView.as_view(queryset=news_entries)
    return view(request, news_entries, template_name='news/archive.html', extra_context=pagevars, paginate_by=entries_per_page)

########NEW FILE########
__FILENAME__ = urls
#
# File that determines what each URL points to. This uses _Python_ regular
# expressions, not Perl's.
#
# See:
# http://diveintopython.org/regular_expressions/street_addresses.html#re.matching.2.3
#

from django.conf.urls import *
from django.conf import settings
from django.contrib import admin
from django.views.generic import RedirectView

# fix to resolve lazy-loading bug
# https://code.djangoproject.com/ticket/10405#comment:11
from django.db.models.loading import cache as model_cache
if not model_cache.loaded:
    model_cache.get_models()

# loop over all settings.INSTALLED_APPS and execute code in
# files named admin.py in each such app (this will add those
# models to the admin site)
admin.autodiscover()

# Setup the root url tree from /

urlpatterns = patterns('',
    # User Authentication
    url(r'^accounts/login',  'django.contrib.auth.views.login'),
    url(r'^accounts/logout', 'django.contrib.auth.views.logout'),

    # Front page
    url(r'^', include('src.web.website.urls')),
    # News stuff
    # url(r'^news/', include('src.web.news.urls')),

    # Page place-holder for things that aren't implemented yet.
    url(r'^tbi/', 'src.web.website.views.to_be_implemented'),

    # Admin interface
    url(r'^admin/doc/', include('django.contrib.admindocs.urls')),
    url(r'^admin/', include(admin.site.urls)),

    # favicon
    url(r'^favicon\.ico$',  RedirectView.as_view(url='/media/images/favicon.ico')),

    # ajax stuff
    url(r'^webclient/',include('src.web.webclient.urls')),
)

# This sets up the server if the user want to run the Django
# test server (this should normally not be needed).
if settings.SERVE_MEDIA:
    urlpatterns += patterns('',
        (r'^media/(?P<path>.*)$', 'django.views.static.serve', {'document_root': settings.MEDIA_ROOT}),
    )

########NEW FILE########
__FILENAME__ = general_context
#
# This file defines global variables that will always be 
# available in a view context without having to repeatedly
# include it. For this to work, this file is included in 
# the settings file, in the TEMPLATE_CONTEXT_PROCESSORS 
# tuple. 
#

from django.db import models
from django.conf import settings
from src.utils.utils import get_evennia_version

# Determine the site name and server version

try:
    GAME_NAME = settings.SERVERNAME.strip()
except AttributeError:
    GAME_NAME = "Evennia"
SERVER_VERSION = get_evennia_version()


# Setup lists of the most relevant apps so 
# the adminsite becomes more readable. 

PLAYER_RELATED = ['Players']
GAME_ENTITIES = ['Objects', 'Scripts', 'Comms', 'Help']
GAME_SETUP = ['Permissions', 'Config']
CONNECTIONS = ['Irc', 'Imc2']
WEBSITE = ['Flatpages', 'News', 'Sites']


# The main context processor function

def general_context(request):
    """
    Returns common Evennia-related context stuff, which
    is automatically added to context of all views.
    """
    return {
        'game_name': GAME_NAME,
        'game_slogan': SERVER_VERSION,
        'evennia_userapps': PLAYER_RELATED,
        'evennia_entityapps': GAME_ENTITIES,
        'evennia_setupapps': GAME_SETUP,
        'evennia_connectapps': CONNECTIONS,
        'evennia_websiteapps':WEBSITE,
        "webclient_enabled" : settings.WEBCLIENT_ENABLED
    }

########NEW FILE########
__FILENAME__ = models
#
# Define database entities for the app. 
#

from django.db import models



########NEW FILE########
__FILENAME__ = urls
"""
This structures the (simple) structure of the
webpage 'application'.
"""
from django.conf.urls import *

urlpatterns = patterns('',
   url(r'^$', 'src.web.webclient.views.webclient'),)

########NEW FILE########
__FILENAME__ = views

"""
This contains a simple view for rendering the webclient
page and serve it eventual static content.

"""

from django.shortcuts import render_to_response, redirect
from django.template import RequestContext
from django.conf import settings
from src.server.sessionhandler import SESSIONS

def webclient(request):
    """
    Webclient page template loading.
    """

    # analyze request to find which port we are on
    if int(request.META["SERVER_PORT"]) == 8000:
        # we relay webclient to the portal port
        print "Called from port 8000!"
        #return redirect("http://localhost:8001/webclient/", permanent=True)

    # as an example we send the number of connected players to the template
    pagevars = {'num_players_connected': SESSIONS.player_count()}

    context_instance = RequestContext(request)
    return render_to_response('webclient.html', pagevars, context_instance)

########NEW FILE########
__FILENAME__ = models
#
# Define database entities for the app. 
#

from django.db import models



########NEW FILE########
__FILENAME__ = urls
"""
This structures the (simple) structure of the
webpage 'application'.
"""

from django.conf.urls import *

urlpatterns = patterns('src.web.website.views',
     (r'^$', 'page_index'),
)

########NEW FILE########
__FILENAME__ = views

"""
This file contains the generic, assorted views that don't fall under one of
the other applications. Views are django's way of processing e.g. html
templates on the fly.

"""
from django.shortcuts import render_to_response
from django.template import RequestContext
#from django.contrib.auth.models import User
from django.conf import settings

from src.objects.models import ObjectDB
#from src.typeclasses.models import TypedObject
from src.players.models import PlayerDB
from src.web.news.models import NewsEntry

_BASE_CHAR_TYPECLASS = settings.BASE_CHARACTER_TYPECLASS

def page_index(request):
    """
    Main root page.
    """
    # Some misc. configurable stuff.
    # TODO: Move this to either SQL or settings.py based configuration.
    fpage_player_limit = 4
    fpage_news_entries = 2

    # A QuerySet of recent news entries.
    news_entries = NewsEntry.objects.all().order_by('-date_posted')[:fpage_news_entries]
    # A QuerySet of the most recently connected players.
    recent_users = PlayerDB.objects.get_recently_connected_players()[:fpage_player_limit]
    nplyrs_conn_recent = len(recent_users) or "none"
    nplyrs = PlayerDB.objects.num_total_players() or "none"
    nplyrs_reg_recent = len(PlayerDB.objects.get_recently_created_players()) or "none"
    nsess = len(PlayerDB.objects.get_connected_players()) or "noone"

    nobjs = ObjectDB.objects.all().count()
    nrooms = ObjectDB.objects.filter(db_location__isnull=True).exclude(db_typeclass_path=_BASE_CHAR_TYPECLASS).count()
    nexits = ObjectDB.objects.filter(db_location__isnull=False, db_destination__isnull=False).count()
    nchars = ObjectDB.objects.filter(db_typeclass_path=_BASE_CHAR_TYPECLASS).count()
    nothers = nobjs - nrooms - nchars - nexits

    pagevars = {
        "page_title": "Front Page",
        "news_entries": news_entries,
        "players_connected_recent": recent_users,
        "num_players_connected": nsess or "noone",
        "num_players_registered": nplyrs or "no",
        "num_players_connected_recent": nplyrs_conn_recent or "no",
        "num_players_registered_recent": nplyrs_reg_recent or "noone",
        "num_rooms": nrooms or "none",
        "num_exits": nexits or "no",
        "num_objects" : nobjs or "none",
        "num_characters": nchars or "no",
        "num_others": nothers or "no"
    }

    context_instance = RequestContext(request)
    return render_to_response('index.html', pagevars, context_instance)

def to_be_implemented(request):
    """
    A notice letting the user know that this particular feature hasn't been
    implemented yet.
    """

    pagevars = {
        "page_title": "To Be Implemented...",
    }

    context_instance = RequestContext(request)
    return render_to_response('tbi.html', pagevars, context_instance)



########NEW FILE########
