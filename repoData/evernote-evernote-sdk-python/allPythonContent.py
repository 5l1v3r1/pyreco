__FILENAME__ = client
import sys
import functools
import inspect
import re
import oauth2 as oauth
import urllib
import urlparse

import evernote.edam.userstore.UserStore as UserStore
import evernote.edam.notestore.NoteStore as NoteStore
import evernote.edam.userstore.constants as UserStoreConstants

import thrift.protocol.TBinaryProtocol as TBinaryProtocol
import thrift.transport.THttpClient as THttpClient


class EvernoteClient(object):

    def __init__(self, **options):
        self.consumer_key = options.get('consumer_key')
        self.consumer_secret = options.get('consumer_secret')
        self.sandbox = options.get('sandbox', True)
        if self.sandbox:
            default_service_host = 'sandbox.evernote.com'
        else:
            default_service_host = 'www.evernote.com'
        self.service_host = options.get('service_host', default_service_host)
        self.additional_headers = options.get('additional_headers', {})
        self.token = options.get('token')
        self.secret = options.get('secret')

    def get_request_token(self, callback_url):
        client = self._get_oauth_client()
        request_url = '%s?oauth_callback=%s' % (
            self._get_endpoint('oauth'), urllib.quote(callback_url))

        resp, content = client.request(request_url, 'GET')
        request_token = dict(urlparse.parse_qsl(content))
        return request_token

    def get_authorize_url(self, request_token):
        return '%s?oauth_token=%s' % (
            self._get_endpoint('OAuth.action'),
            urllib.quote(request_token['oauth_token']))

    def get_access_token(
        self, oauth_token, oauth_token_secret, oauth_verifier
    ):
        token = oauth.Token(oauth_token, oauth_token_secret)
        token.set_verifier(oauth_verifier)
        client = self._get_oauth_client(token)

        resp, content = client.request(self._get_endpoint('oauth'), 'POST')
        access_token = dict(urlparse.parse_qsl(content))
        self.token = access_token['oauth_token']
        return self.token

    def get_user_store(self):
        user_store_uri = self._get_endpoint("/edam/user")
        store = Store(self.token, UserStore.Client, user_store_uri)
        if not store:  # Trick for PyDev code completion
            store = UserStore.Client()
            raise Exception('Should never reach here')
        return store

    def get_note_store(self):
        user_store = self.get_user_store()
        note_store_uri = user_store.getNoteStoreUrl()
        store = Store(self.token, NoteStore.Client, note_store_uri)
        if not store:  # Trick for PyDev code completion
            store = NoteStore.Client()
            raise Exception('Should never reach here')
        return store

    def get_shared_note_store(self, linkedNotebook):
        note_store_uri = linkedNotebook.noteStoreUrl
        note_store = Store(self.token, NoteStore.Client, note_store_uri)
        shared_auth = note_store.authenticateToSharedNotebook(
            linkedNotebook.shareKey)
        shared_token = shared_auth.authenticationToken
        store = Store(shared_token, NoteStore.Client, note_store_uri)
        if not store:  # Trick for PyDev code completion
            store = NoteStore.Client()
            raise Exception('Should never reach here')
        return store

    def get_business_note_store(self):
        user_store = self.get_user_store()
        biz_auth = user_store.authenticateToBusiness()
        biz_token = biz_auth.authenticationToken
        note_store_uri = biz_auth.noteStoreUrl
        store = Store(biz_token, NoteStore.Client, note_store_uri)
        if not store:  # Trick for PyDev code completion
            store = NoteStore.Client()
            raise Exception('Should never reach here')
        return store

    def _get_oauth_client(self, token=None):
        consumer = oauth.Consumer(self.consumer_key, self.consumer_secret)
        if token:
            client = oauth.Client(consumer, token)
        else:
            client = oauth.Client(consumer)
        return client

    def _get_endpoint(self, path=None):
        url = "https://%s" % (self.service_host)
        if path is not None:
            url += "/%s" % path
        return url


class Store(object):

    def __init__(self, token, client_class, store_url):
        self.token = token
        m = re.search(':A=(.+):', token)
        if m:
            self._user_agent_id = m.groups()[0]
        else:
            self._user_agent_id = ''
        self._client = self._get_thrift_client(client_class, store_url)

    def __getattr__(self, name):
        def delegate_method(*args, **kwargs):
            targetMethod = getattr(self._client, name, None)
            if targetMethod is None:
                return object.__getattribute__(self, name)(*args, **kwargs)

            org_args = inspect.getargspec(targetMethod).args
            if len(org_args) == len(args) + 1:
                return targetMethod(*args, **kwargs)
            elif 'authenticationToken' in org_args:
                skip_args = ['self', 'authenticationToken']
                arg_names = [i for i in org_args if i not in skip_args]
                return functools.partial(
                    targetMethod, authenticationToken=self.token
                )(**dict(zip(arg_names, args)))
            else:
                return targetMethod(*args, **kwargs)

        return delegate_method

    def _get_thrift_client(self, client_class, url):
        http_client = THttpClient.THttpClient(url)
        http_client.addHeaders(**{
            'User-Agent': "%s / %s; Python / %s;"
            % (self._user_agent_id, self._get_sdk_version(), sys.version)
        })

        thrift_protocol = TBinaryProtocol.TBinaryProtocol(http_client)
        return client_class(thrift_protocol)

    def _get_sdk_version(self):
        return '%s.%s' % (
            UserStoreConstants.EDAM_VERSION_MAJOR,
            UserStoreConstants.EDAM_VERSION_MINOR
        )

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *


########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class EDAMErrorCode(object):
  """
  Numeric codes indicating the type of error that occurred on the
  service.
  <dl>
    <dt>UNKNOWN</dt>
      <dd>No information available about the error</dd>
    <dt>BAD_DATA_FORMAT</dt>
      <dd>The format of the request data was incorrect</dd>
    <dt>PERMISSION_DENIED</dt>
      <dd>Not permitted to perform action</dd>
    <dt>INTERNAL_ERROR</dt>
      <dd>Unexpected problem with the service</dd>
    <dt>DATA_REQUIRED</dt>
      <dd>A required parameter/field was absent</dd>
    <dt>LIMIT_REACHED</dt>
      <dd>Operation denied due to data model limit</dd>
    <dt>QUOTA_REACHED</dt>
      <dd>Operation denied due to user storage limit</dd>
    <dt>INVALID_AUTH</dt>
      <dd>Username and/or password incorrect</dd>
    <dt>AUTH_EXPIRED</dt>
      <dd>Authentication token expired</dd>
    <dt>DATA_CONFLICT</dt>
      <dd>Change denied due to data model conflict</dd>
    <dt>ENML_VALIDATION</dt>
      <dd>Content of submitted note was malformed</dd>
    <dt>SHARD_UNAVAILABLE</dt>
      <dd>Service shard with account data is temporarily down</dd>
    <dt>LEN_TOO_SHORT</dt>
      <dd>Operation denied due to data model limit, where something such
          as a string length was too short</dd>
    <dt>LEN_TOO_LONG</dt>
      <dd>Operation denied due to data model limit, where something such
          as a string length was too long</dd>
    <dt>TOO_FEW</dt>
      <dd>Operation denied due to data model limit, where there were
          too few of something.</dd>
    <dt>TOO_MANY</dt>
      <dd>Operation denied due to data model limit, where there were
          too many of something.</dd>
    <dt>UNSUPPORTED_OPERATION</dt>
      <dd>Operation denied because it is currently unsupported.</dd>
    <dt>TAKEN_DOWN</dt>
      <dd>Operation denied because access to the corresponding object is
          prohibited in response to a take-down notice.</dd>
    <dt>RATE_LIMIT_REACHED</dt>
      <dd>Operation denied because the calling application has reached
          its hourly API call limit for this user.</dd>
  </dl>
  """
  UNKNOWN = 1
  BAD_DATA_FORMAT = 2
  PERMISSION_DENIED = 3
  INTERNAL_ERROR = 4
  DATA_REQUIRED = 5
  LIMIT_REACHED = 6
  QUOTA_REACHED = 7
  INVALID_AUTH = 8
  AUTH_EXPIRED = 9
  DATA_CONFLICT = 10
  ENML_VALIDATION = 11
  SHARD_UNAVAILABLE = 12
  LEN_TOO_SHORT = 13
  LEN_TOO_LONG = 14
  TOO_FEW = 15
  TOO_MANY = 16
  UNSUPPORTED_OPERATION = 17
  TAKEN_DOWN = 18
  RATE_LIMIT_REACHED = 19

  _VALUES_TO_NAMES = {
    1: "UNKNOWN",
    2: "BAD_DATA_FORMAT",
    3: "PERMISSION_DENIED",
    4: "INTERNAL_ERROR",
    5: "DATA_REQUIRED",
    6: "LIMIT_REACHED",
    7: "QUOTA_REACHED",
    8: "INVALID_AUTH",
    9: "AUTH_EXPIRED",
    10: "DATA_CONFLICT",
    11: "ENML_VALIDATION",
    12: "SHARD_UNAVAILABLE",
    13: "LEN_TOO_SHORT",
    14: "LEN_TOO_LONG",
    15: "TOO_FEW",
    16: "TOO_MANY",
    17: "UNSUPPORTED_OPERATION",
    18: "TAKEN_DOWN",
    19: "RATE_LIMIT_REACHED",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 1,
    "BAD_DATA_FORMAT": 2,
    "PERMISSION_DENIED": 3,
    "INTERNAL_ERROR": 4,
    "DATA_REQUIRED": 5,
    "LIMIT_REACHED": 6,
    "QUOTA_REACHED": 7,
    "INVALID_AUTH": 8,
    "AUTH_EXPIRED": 9,
    "DATA_CONFLICT": 10,
    "ENML_VALIDATION": 11,
    "SHARD_UNAVAILABLE": 12,
    "LEN_TOO_SHORT": 13,
    "LEN_TOO_LONG": 14,
    "TOO_FEW": 15,
    "TOO_MANY": 16,
    "UNSUPPORTED_OPERATION": 17,
    "TAKEN_DOWN": 18,
    "RATE_LIMIT_REACHED": 19,
  }


class EDAMUserException(TException):
  """
  This exception is thrown by EDAM procedures when a call fails as a result of
  a problem that a caller may be able to resolve.  For example, if the user
  attempts to add a note to their account which would exceed their storage
  quota, this type of exception may be thrown to indicate the source of the
  error so that they can choose an alternate action.
  
  This exception would not be used for internal system errors that do not
  reflect user actions, but rather reflect a problem within the service that
  the user cannot resolve.
  
  errorCode:  The numeric code indicating the type of error that occurred.
    must be one of the values of EDAMErrorCode.
  
  parameter:  If the error applied to a particular input parameter, this will
    indicate which parameter.
  
  Attributes:
   - errorCode
   - parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'parameter', None, None, ), # 2
  )

  def __init__(self, errorCode=None, parameter=None,):
    self.errorCode = errorCode
    self.parameter = parameter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parameter = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDAMUserException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 1)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.parameter is not None:
      oprot.writeFieldBegin('parameter', TType.STRING, 2)
      oprot.writeString(self.parameter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.errorCode is None:
      raise TProtocol.TProtocolException(message='Required field errorCode is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EDAMSystemException(TException):
  """
  This exception is thrown by EDAM procedures when a call fails as a result of
  a problem in the service that could not be changed through caller action.
  
  errorCode:  The numeric code indicating the type of error that occurred.
    must be one of the values of EDAMErrorCode.
  
  message:  This may contain additional information about the error
  
  rateLimitDuration:  Indicates the minimum number of seconds that an application should
    expect subsequent API calls for this user to fail. The application should not retry
    API requests for the user until at least this many seconds have passed. Present only
    when errorCode is RATE_LIMIT_REACHED,
  
  Attributes:
   - errorCode
   - message
   - rateLimitDuration
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'message', None, None, ), # 2
    (3, TType.I32, 'rateLimitDuration', None, None, ), # 3
  )

  def __init__(self, errorCode=None, message=None, rateLimitDuration=None,):
    self.errorCode = errorCode
    self.message = message
    self.rateLimitDuration = rateLimitDuration

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.rateLimitDuration = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDAMSystemException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 1)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 2)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.rateLimitDuration is not None:
      oprot.writeFieldBegin('rateLimitDuration', TType.I32, 3)
      oprot.writeI32(self.rateLimitDuration)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.errorCode is None:
      raise TProtocol.TProtocolException(message='Required field errorCode is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EDAMNotFoundException(TException):
  """
  This exception is thrown by EDAM procedures when a caller asks to perform
  an operation on an object that does not exist.  This may be thrown based on an invalid
  primary identifier (e.g. a bad GUID), or when the caller refers to an object
  by another unique identifier (e.g. a User's email address).
  
  identifier:  A description of the object that was not found on the server.
    For example, "Note.notebookGuid" when a caller attempts to create a note in a
    notebook that does not exist in the user's account.
  
  key:  The value passed from the client in the identifier, which was not
    found. For example, the GUID that was not found.
  
  Attributes:
   - identifier
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'identifier', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, identifier=None, key=None,):
    self.identifier = identifier
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.identifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDAMNotFoundException')
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.STRING, 1)
      oprot.writeString(self.identifier)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *

EDAM_ATTRIBUTE_LEN_MIN = 1
EDAM_ATTRIBUTE_LEN_MAX = 4096
EDAM_ATTRIBUTE_REGEX = "^[^\\p{Cc}\\p{Zl}\\p{Zp}]{1,4096}$"
EDAM_ATTRIBUTE_LIST_MAX = 100
EDAM_ATTRIBUTE_MAP_MAX = 100
EDAM_GUID_LEN_MIN = 36
EDAM_GUID_LEN_MAX = 36
EDAM_GUID_REGEX = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
EDAM_EMAIL_LEN_MIN = 6
EDAM_EMAIL_LEN_MAX = 255
EDAM_EMAIL_LOCAL_REGEX = "^[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(\\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*$"
EDAM_EMAIL_DOMAIN_REGEX = "^[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*\\.([A-Za-z]{2,})$"
EDAM_EMAIL_REGEX = "^[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(\\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*\\.([A-Za-z]{2,})$"
EDAM_VAT_REGEX = "^((AT)?U[0-9]{8}|(BE)?0?[0-9]{9}|(BG)?[0-9]{9,10}|(CY)?[0-9]{8}L|(CZ)?[0-9]{8,10}|(DE)?[0-9]{9}|(DK)?[0-9]{8}|(EE)?[0-9]{9}|(EL|GR)?[0-9]{9}|(ES)?[0-9A-Z][0-9]{7}[0-9A-Z]|(FI)?[0-9]{8}|(FR)?[0-9A-Z]{2}[0-9]{9}|(GB)?([0-9]{9}([0-9]{3})?|[A-Z]{2}[0-9]{3})|(HU)?[0-9]{8}|(IE)?[0-9]S[0-9]{5}L|(IT)?[0-9]{11}|(LT)?([0-9]{9}|[0-9]{12})|(LU)?[0-9]{8}|(LV)?[0-9]{11}|(MT)?[0-9]{8}|(NL)?[0-9]{9}B[0-9]{2}|(PL)?[0-9]{10}|(PT)?[0-9]{9}|(RO)?[0-9]{2,10}|(SE)?[0-9]{12}|(SI)?[0-9]{8}|(SK)?[0-9]{10})|[0-9]{9}MVA|[0-9]{6}|CHE[0-9]{9}(TVA|MWST|IVA)$"
EDAM_TIMEZONE_LEN_MIN = 1
EDAM_TIMEZONE_LEN_MAX = 32
EDAM_TIMEZONE_REGEX = "^([A-Za-z_-]+(/[A-Za-z_-]+)*)|(GMT(-|\\+)[0-9]{1,2}(:[0-9]{2})?)$"
EDAM_MIME_LEN_MIN = 3
EDAM_MIME_LEN_MAX = 255
EDAM_MIME_REGEX = "^[A-Za-z]+/[A-Za-z0-9._+-]+$"
EDAM_MIME_TYPE_GIF = "image/gif"
EDAM_MIME_TYPE_JPEG = "image/jpeg"
EDAM_MIME_TYPE_PNG = "image/png"
EDAM_MIME_TYPE_WAV = "audio/wav"
EDAM_MIME_TYPE_MP3 = "audio/mpeg"
EDAM_MIME_TYPE_AMR = "audio/amr"
EDAM_MIME_TYPE_AAC = "audio/aac"
EDAM_MIME_TYPE_M4A = "audio/mp4"
EDAM_MIME_TYPE_MP4_VIDEO = "video/mp4"
EDAM_MIME_TYPE_INK = "application/vnd.evernote.ink"
EDAM_MIME_TYPE_PDF = "application/pdf"
EDAM_MIME_TYPE_DEFAULT = "application/octet-stream"
EDAM_MIME_TYPES = set([
  "image/gif",
  "image/jpeg",
  "image/png",
  "audio/wav",
  "audio/mpeg",
  "audio/amr",
  "application/vnd.evernote.ink",
  "application/pdf",
  "video/mp4",
  "audio/aac",
  "audio/mp4",
])
EDAM_INDEXABLE_RESOURCE_MIME_TYPES = set([
  "application/msword",
  "application/mspowerpoint",
  "application/excel",
  "application/vnd.ms-word",
  "application/vnd.ms-powerpoint",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/vnd.apple.pages",
  "application/vnd.apple.numbers",
  "application/vnd.apple.keynote",
  "application/x-iwork-pages-sffpages",
  "application/x-iwork-numbers-sffnumbers",
  "application/x-iwork-keynote-sffkey",
])
EDAM_SEARCH_QUERY_LEN_MIN = 0
EDAM_SEARCH_QUERY_LEN_MAX = 1024
EDAM_SEARCH_QUERY_REGEX = "^[^\\p{Cc}\\p{Zl}\\p{Zp}]{0,1024}$"
EDAM_HASH_LEN = 16
EDAM_USER_USERNAME_LEN_MIN = 1
EDAM_USER_USERNAME_LEN_MAX = 64
EDAM_USER_USERNAME_REGEX = "^[a-z0-9]([a-z0-9_-]{0,62}[a-z0-9])?$"
EDAM_USER_NAME_LEN_MIN = 1
EDAM_USER_NAME_LEN_MAX = 255
EDAM_USER_NAME_REGEX = "^[^\\p{Cc}\\p{Zl}\\p{Zp}]{1,255}$"
EDAM_TAG_NAME_LEN_MIN = 1
EDAM_TAG_NAME_LEN_MAX = 100
EDAM_TAG_NAME_REGEX = "^[^,\\p{Cc}\\p{Z}]([^,\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^,\\p{Cc}\\p{Z}])?$"
EDAM_NOTE_TITLE_LEN_MIN = 1
EDAM_NOTE_TITLE_LEN_MAX = 255
EDAM_NOTE_TITLE_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,253}[^\\p{Cc}\\p{Z}])?$"
EDAM_NOTE_CONTENT_LEN_MIN = 0
EDAM_NOTE_CONTENT_LEN_MAX = 5242880
EDAM_APPLICATIONDATA_NAME_LEN_MIN = 3
EDAM_APPLICATIONDATA_NAME_LEN_MAX = 32
EDAM_APPLICATIONDATA_VALUE_LEN_MIN = 0
EDAM_APPLICATIONDATA_VALUE_LEN_MAX = 4092
EDAM_APPLICATIONDATA_ENTRY_LEN_MAX = 4095
EDAM_APPLICATIONDATA_NAME_REGEX = "^[A-Za-z0-9_.-]{3,32}$"
EDAM_APPLICATIONDATA_VALUE_REGEX = "^[^\\p{Cc}]{0,4092}$"
EDAM_NOTEBOOK_NAME_LEN_MIN = 1
EDAM_NOTEBOOK_NAME_LEN_MAX = 100
EDAM_NOTEBOOK_NAME_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^\\p{Cc}\\p{Z}])?$"
EDAM_NOTEBOOK_STACK_LEN_MIN = 1
EDAM_NOTEBOOK_STACK_LEN_MAX = 100
EDAM_NOTEBOOK_STACK_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^\\p{Cc}\\p{Z}])?$"
EDAM_PUBLISHING_URI_LEN_MIN = 1
EDAM_PUBLISHING_URI_LEN_MAX = 255
EDAM_PUBLISHING_URI_REGEX = "^[a-zA-Z0-9.~_+-]{1,255}$"
EDAM_PUBLISHING_URI_PROHIBITED = set([
  "..",
])
EDAM_PUBLISHING_DESCRIPTION_LEN_MIN = 1
EDAM_PUBLISHING_DESCRIPTION_LEN_MAX = 200
EDAM_PUBLISHING_DESCRIPTION_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,198}[^\\p{Cc}\\p{Z}])?$"
EDAM_SAVED_SEARCH_NAME_LEN_MIN = 1
EDAM_SAVED_SEARCH_NAME_LEN_MAX = 100
EDAM_SAVED_SEARCH_NAME_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^\\p{Cc}\\p{Z}])?$"
EDAM_USER_PASSWORD_LEN_MIN = 6
EDAM_USER_PASSWORD_LEN_MAX = 64
EDAM_USER_PASSWORD_REGEX = "^[A-Za-z0-9!#$%&'()*+,./:;<=>?@^_`{|}~\\[\\]\\\\-]{6,64}$"
EDAM_BUSINESS_URI_LEN_MAX = 32
EDAM_NOTE_TAGS_MAX = 100
EDAM_NOTE_RESOURCES_MAX = 1000
EDAM_USER_TAGS_MAX = 100000
EDAM_BUSINESS_TAGS_MAX = 100000
EDAM_USER_SAVED_SEARCHES_MAX = 100
EDAM_USER_NOTES_MAX = 100000
EDAM_BUSINESS_NOTES_MAX = 500000
EDAM_USER_NOTEBOOKS_MAX = 250
EDAM_BUSINESS_NOTEBOOKS_MAX = 5000
EDAM_USER_RECENT_MAILED_ADDRESSES_MAX = 10
EDAM_USER_MAIL_LIMIT_DAILY_FREE = 50
EDAM_USER_MAIL_LIMIT_DAILY_PREMIUM = 200
EDAM_USER_UPLOAD_LIMIT_FREE = 62914560
EDAM_USER_UPLOAD_LIMIT_PREMIUM = 1073741824
EDAM_USER_UPLOAD_LIMIT_BUSINESS = 2147483647
EDAM_NOTE_SIZE_MAX_FREE = 26214400
EDAM_NOTE_SIZE_MAX_PREMIUM = 104857600
EDAM_RESOURCE_SIZE_MAX_FREE = 26214400
EDAM_RESOURCE_SIZE_MAX_PREMIUM = 104857600
EDAM_USER_LINKED_NOTEBOOK_MAX = 100
EDAM_USER_LINKED_NOTEBOOK_MAX_PREMIUM = 250
EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX = 250
EDAM_NOTE_CONTENT_CLASS_LEN_MIN = 3
EDAM_NOTE_CONTENT_CLASS_LEN_MAX = 32
EDAM_NOTE_CONTENT_CLASS_REGEX = "^[A-Za-z0-9_.-]{3,32}$"
EDAM_HELLO_APP_CONTENT_CLASS_PREFIX = "evernote.hello."
EDAM_FOOD_APP_CONTENT_CLASS_PREFIX = "evernote.food."
EDAM_CONTENT_CLASS_HELLO_ENCOUNTER = "evernote.hello.encounter"
EDAM_CONTENT_CLASS_HELLO_PROFILE = "evernote.hello.profile"
EDAM_CONTENT_CLASS_FOOD_MEAL = "evernote.food.meal"
EDAM_CONTENT_CLASS_SKITCH_PREFIX = "evernote.skitch"
EDAM_CONTENT_CLASS_SKITCH = "evernote.skitch"
EDAM_CONTENT_CLASS_SKITCH_PDF = "evernote.skitch.pdf"
EDAM_CONTENT_CLASS_PENULTIMATE_PREFIX = "evernote.penultimate."
EDAM_CONTENT_CLASS_PENULTIMATE_NOTEBOOK = "evernote.penultimate.notebook"
EDAM_RELATED_PLAINTEXT_LEN_MIN = 1
EDAM_RELATED_PLAINTEXT_LEN_MAX = 131072
EDAM_RELATED_MAX_NOTES = 25
EDAM_RELATED_MAX_NOTEBOOKS = 1
EDAM_RELATED_MAX_TAGS = 25
EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MIN = 1
EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MAX = 200
EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,198}[^\\p{Cc}\\p{Z}])?$"
EDAM_BUSINESS_PHONE_NUMBER_LEN_MAX = 20
EDAM_PREFERENCE_NAME_LEN_MIN = 3
EDAM_PREFERENCE_NAME_LEN_MAX = 32
EDAM_PREFERENCE_VALUE_LEN_MIN = 1
EDAM_PREFERENCE_VALUE_LEN_MAX = 1024
EDAM_MAX_PREFERENCES = 100
EDAM_MAX_VALUES_PER_PREFERENCE = 256
EDAM_PREFERENCE_NAME_REGEX = "^[A-Za-z0-9_.-]{3,32}$"
EDAM_PREFERENCE_VALUE_REGEX = "^[^\\p{Cc}]{1,1024}$"
EDAM_PREFERENCE_SHORTCUTS = "evernote.shortcuts"
EDAM_PREFERENCE_SHORTCUTS_MAX_VALUES = 250
EDAM_DEVICE_ID_LEN_MAX = 32
EDAM_DEVICE_ID_REGEX = "^[^\\p{Cc}]{1,32}$"
EDAM_DEVICE_DESCRIPTION_LEN_MAX = 64
EDAM_DEVICE_DESCRIPTION_REGEX = "^[^\\p{Cc}]{1,64}$"
EDAM_SEARCH_SUGGESTIONS_MAX = 10
EDAM_SEARCH_SUGGESTIONS_PREFIX_LEN_MAX = 1024
EDAM_SEARCH_SUGGESTIONS_PREFIX_LEN_MIN = 2

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *


########NEW FILE########
__FILENAME__ = NoteStore
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def getSyncState(self, authenticationToken):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getSyncStateWithMetrics(self, authenticationToken, clientMetrics):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    This version of 'getSyncState' allows the client to upload coarse-
    grained usage metrics to the service.
    
    @param clientMetrics  see the documentation of the ClientUsageMetrics
      structure for an explanation of the fields that clients can pass to
      the service.
    
    Parameters:
     - authenticationToken
     - clientMetrics
    """
    pass

  def getSyncChunk(self, authenticationToken, afterUSN, maxEntries, fullSyncOnly):
    """
    DEPRECATED - use getFilteredSyncChunk.
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    pass

  def getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
    """
    Asks the NoteStore to provide the state of the account in order of
    last modification.  This request retrieves one block of the server's
    state so that a client can make several small requests against a large
    account rather than getting the entire state in one big message.
    This call gives fine-grained control of the data that will
    be received by a client by omitting data elements that a client doesn't
    need. This may reduce network traffic and sync times.
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
    
    @param filter
      The caller must set some of the flags in this structure to specify which
      data types should be returned during the synchronization.  See
      the SyncChunkFilter structure for information on each flag.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - filter
    """
    pass

  def getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
    """
    Asks the NoteStore to provide information about the status of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncState, but may omit
    SyncState.uploaded if the caller doesn't have permission to write to
    the linked notebook.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    pass

  def getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
    """
    Asks the NoteStore to provide information about the contents of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncChunk, but will only
    contain entries that are visible to the caller.  I.e. only that particular
    Notebook will be visible, along with its Notes, and Tags on those Notes.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.  This must contain the valid fields
      for either a shared notebook (e.g. shareKey)
      or a public notebook (e.g. username, uri)
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
      Applications should not request more than 256 objects at a time,
      and must handle the case where the service returns less than the
      requested number of objects in a given request even though more
      objects are available on the service.
    
    @param fullSyncOnly
      If true, then the client only wants initial data for a full sync.
      In this case, the service will not return any expunged objects,
      and will not return any Resources, since these are also provided
      in their corresponding Notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "LinkedNotebook" - if the provided information doesn't match any
        valid notebook
      </li>
      <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
        valid notebook
      </li>
      <li> "SharedNotebook.id" - if the provided information indicates a
         shared notebook that no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    pass

  def listNotebooks(self, authenticationToken):
    """
    Returns a list of all of the notebooks in the account.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getNotebook(self, authenticationToken, guid):
    """
    Returns the current state of the notebook with the provided GUID.
    The notebook may be active or deleted (but not expunged).
    
    @param guid
      The GUID of the notebook to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getDefaultNotebook(self, authenticationToken):
    """
    Returns the notebook that should be used to store new notes in the
    user's account when no other notebooks are specified.
    
    Parameters:
     - authenticationToken
    """
    pass

  def createNotebook(self, authenticationToken, notebook):
    """
    Asks the service to make a notebook with the provided name.
    
    @param notebook
      The desired fields for the notebook must be provided on this
      object.  The name of the notebook must be set, and either the 'active'
      or 'defaultNotebook' fields may be set by the client at creation.
      If a notebook exists in the account with the same name (via
      case-insensitive compare), this will throw an EDAMUserException.
    
    @return
      The newly created Notebook.  The server-side GUID will be
      saved in this object's 'guid' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
      <li> LIMIT_REACHED "Notebook" - at max number of notebooks
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    pass

  def updateNotebook(self, authenticationToken, notebook):
    """
    Submits notebook changes to the service.  The provided data must include
    the notebook's guid field for identification.
    
    @param notebook
      The notebook object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    pass

  def expungeNotebook(self, authenticationToken, guid):
    """
    Permanently removes the notebook from the user's account.
    After this action, the notebook is no longer available for undeletion, etc.
    If the notebook contains any Notes, they will be moved to the current
    default notebook and moved into the trash (i.e. Note.active=false).
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the notebook to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def listTags(self, authenticationToken):
    """
    Returns a list of the tags in the account.  Evernote does not support
    the undeletion of tags, so this will only include active tags.
    
    Parameters:
     - authenticationToken
    """
    pass

  def listTagsByNotebook(self, authenticationToken, notebookGuid):
    """
    Returns a list of the tags that are applied to at least one note within
    the provided notebook.  If the notebook is public, the authenticationToken
    may be ignored.
    
    @param notebookGuid
       the GUID of the notebook to use to find tags
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - notebook not found by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
    """
    pass

  def getTag(self, authenticationToken, guid):
    """
    Returns the current state of the Tag with the provided GUID.
    
    @param guid
      The GUID of the tag to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def createTag(self, authenticationToken, tag):
    """
    Asks the service to make a tag with a set of information.
    
    @param tag
      The desired list of fields for the tag are specified in this
      object.  The caller must specify the tag name, and may provide
      the parentGUID.
    
    @return
      The newly created Tag.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> LIMIT_REACHED "Tag" - at max number of tags
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.parentGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    pass

  def updateTag(self, authenticationToken, tag):
    """
    Submits tag changes to the service.  The provided data must include
    the tag's guid field for identification.  The service will apply
    updates to the following tag fields:  name, parentGuid
    
    @param tag
      The tag object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
      <li> "Tag.parentGuid" - parent not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    pass

  def untagAll(self, authenticationToken, guid):
    """
    Removes the provided tag from every note that is currently tagged with
    this tag.  If this operation is successful, the tag will still be in
    the account, but it will not be tagged on any notes.
    
    This function is not indended for use by full synchronizing clients, since
    it does not provide enough result information to the client to reconcile
    the local state without performing a follow-up sync from the service.  This
    is intended for "thin clients" that need to efficiently support this as
    a UI operation.
    
    @param guid
      The GUID of the tag to remove from all notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def expungeTag(self, authenticationToken, guid):
    """
    Permanently deletes the tag with the provided GUID, if present.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the tag to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def listSearches(self, authenticationToken):
    """
    Returns a list of the searches in the account.  Evernote does not support
    the undeletion of searches, so this will only include active searches.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getSearch(self, authenticationToken, guid):
    """
    Returns the current state of the search with the provided GUID.
    
    @param guid
      The GUID of the search to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def createSearch(self, authenticationToken, search):
    """
    Asks the service to make a saved search with a set of information.
    
    @param search
      The desired list of fields for the search are specified in this
      object. The caller must specify the name and query for the
      search, and may optionally specify a search scope.
      The SavedSearch.format field is ignored by the service.
    
    @return
      The newly created SavedSearch.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    pass

  def updateSearch(self, authenticationToken, search):
    """
    Submits search changes to the service. The provided data must include
    the search's guid field for identification. The service will apply
    updates to the following search fields: name, query, and scope.
    
    @param search
      The search object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    pass

  def expungeSearch(self, authenticationToken, guid):
    """
    Permanently deletes the saved search with the provided GUID, if present.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the search to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def findNotes(self, authenticationToken, filter, offset, maxNotes):
    """
    DEPRECATED. Use findNotesMetadata.
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
    """
    pass

  def findNoteOffset(self, authenticationToken, filter, guid):
    """
    Finds the position of a note within a sorted subset of all of the user's
    notes. This may be useful for thin clients that are displaying a paginated
    listing of a large account, which need to know where a particular note
    sits in the list without retrieving all notes first.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @return
      If the note with the provided GUID is found within the matching note
      list, this will return the offset of that note within that list (where
      the first offset is 0).  If the note is not found within the set of
      notes, this will return -1.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - guid
    """
    pass

  def findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
    """
    Used to find the high-level information about a set of the notes from a
    user's account based on various criteria specified via a NoteFilter object.
    <p/>
    Web applications that wish to periodically check for new content in a user's
    Evernote account should consider using webhooks instead of polling this API.
    See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
    for more information.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param offset
      The numeric index of the first note to show within the sorted
      results.  The numbering scheme starts with "0".  This can be used for
      pagination.
    
    @param maxNotes
      The mximum notes to return in this query.  The service will return a set
      of notes that is no larger than this number, but may return fewer notes
      if needed.  The NoteList.totalNotes field in the return value will
      indicate whether there are more values available after the returned set.
    
    @param resultSpec
      This specifies which information should be returned for each matching
      Note. The fields on this structure can be used to eliminate data that
      the client doesn't need, which will reduce the time and bandwidth
      to receive and process the reply.
    
    @return
      The list of notes that match the criteria.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
     - resultSpec
    """
    pass

  def findNoteCounts(self, authenticationToken, filter, withTrash):
    """
    This function is used to determine how many notes are found for each
    notebook and tag in the user's account, given a current set of filter
    parameters that determine the current selection.  This function will
    return a structure that gives the note count for each notebook and tag
    that has at least one note under the requested filter.  Any notebook or
    tag that has zero notes in the filtered set will not be listed in the
    reply to this function (so they can be assumed to be 0).
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The note selection filter that is currently being applied.  The note
      counts are to be calculated with this filter applied to the total set
      of notes in the user's account.
    
    @param withTrash
      If true, then the NoteCollectionCounts.trashCount will be calculated
      and supplied in the reply. Otherwise, the trash value will be omitted.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - withTrash
    """
    pass

  def getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    Returns the current state of the note in the service with the provided
    GUID.  The ENML contents of the note will only be provided if the
    'withContent' parameter is true.  The service will include the meta-data
    for each resource in the note, but the binary contents of the resources
    and their recognition data will be omitted.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  The applicationData
    fields are returned as keysOnly.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param withContent
      If true, the note will include the ENML contents of its
      'content' field.
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withContent
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    pass

  def getNoteApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the note identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getNoteApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the note identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID</li>
      <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the note identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    pass

  def unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the note identified by 'guid'. Silently ignores an unset of a
    non-existing key.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def getNoteContent(self, authenticationToken, guid):
    """
    Returns XHTML contents of the note with the provided GUID.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
    """
    Returns a block of the extracted plain text contents of the note with the
    provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capabilities to extract all of the searchable
    text content from the note and its resources.
    
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param noteOnly
      If true, this will only return the text extracted from the ENML contents
      of the note itself.  If false, this will also include the extracted text
      from any text-bearing resources (PDF, recognized images)
    
    @param tokenizeForIndexing
      If true, this will break the text into cleanly separated and sanitized
      tokens.  If false, this will return the more raw text extraction, with
      its original punctuation, capitalization, spacing, etc.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - noteOnly
     - tokenizeForIndexing
    """
    pass

  def getResourceSearchText(self, authenticationToken, guid):
    """
    Returns a block of the extracted plain text contents of the resource with
    the provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capability to extract all of the searchable
    text content from a resource.
    
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getNoteTagNames(self, authenticationToken, guid):
    """
    Returns a list of the names of the tags for the note with the provided
    guid.  This can be used with authentication to get the tags for a
    user's own note, or can be used without valid authentication to retrieve
    the names of the tags for a note in a public notebook.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def createNote(self, authenticationToken, note):
    """
    Asks the service to make a note with the provided set of information.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service.
    
    @return
      The newly created Note from the service.  The server-side
      GUIDs for the Note and any Resources will be saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.notebookGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    pass

  def updateNote(self, authenticationToken, note):
    """
    Submit a set of changes to a note to the service.  The provided data
    must include the note's guid field for identification. The note's
    title must also be set.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service. With the exception of the note's title and guid, fields
      that are not being changed do not need to be set. If the content is not
      being modified, note.content should be left unset. If the list of
      resources is not being modified, note.resources should be left unset.
    
    @return
      The metadata (no contents) for the Note on the server after the update
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID
      </li>
      <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    pass

  def deleteNote(self, authenticationToken, guid):
    """
    Moves the note into the trash. The note may still be undeleted, unless it
    is expunged.  This is equivalent to calling updateNote() after setting
    Note.active = false
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't have permission to
             update the note.
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      </li>
    </ul>
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def expungeNote(self, authenticationToken, guid):
    """
    Permanently removes a Note, and all of its Resources,
    from the service.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def expungeNotes(self, authenticationToken, noteGuids):
    """
    Permanently removes a list of Notes, and all of their Resources, from
    the service.  This should be invoked with a small number of Note GUIDs
    (e.g. 100 or less) on each call.  To expunge a larger number of notes,
    call this method multiple times.  This should also be used to reduce the
    number of Notes in a notebook before calling expungeNotebook() or
    in the trash before calling expungeInactiveNotes(), since these calls may
    be prohibitively slow if there are more than a few hundred notes.
    If an exception is thrown for any of the GUIDs, then none of the notes
    will be deleted.  I.e. this call can be treated as an atomic transaction.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param noteGuids
      The list of GUIDs for the Notes to remove.
    
    @return
      The account's updateCount at the end of this operation
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuids
    """
    pass

  def expungeInactiveNotes(self, authenticationToken):
    """
    Permanently removes all of the Notes that are currently marked as
    inactive.  This is equivalent to "emptying the trash", and these Notes
    will be gone permanently.
    <p/>
    This operation may be relatively slow if the account contains a large
    number of inactive Notes.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @return
       The number of notes that were expunged.
    
    Parameters:
     - authenticationToken
    """
    pass

  def copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
    """
    Performs a deep copy of the Note with the provided GUID 'noteGuid' into
    the Notebook with the provided GUID 'toNotebookGuid'.
    The caller must be the owner of both the Note and the Notebook.
    This creates a new Note in the destination Notebook with new content and
    Resources that match all of the content and Resources from the original
    Note, but with new GUID identifiers.
    The original Note is not modified by this operation.
    The copied note is considered as an "upload" for the purpose of upload
    transfer limit calculation, so its size is added to the upload count for
    the owner.
    
    @param noteGuid
      The GUID of the Note to copy.
    
    @param toNotebookGuid
      The GUID of the Notebook that should receive the new Note.
    
    @return
      The metadata for the new Note that was created.  This will include the
      new GUID for this Note (and any copied Resources), but will not include
      the content body or the binary bodies of any Resources.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - toNotebookGuid
    """
    pass

  def listNoteVersions(self, authenticationToken, noteGuid):
    """
    Returns a list of the prior versions of a particular note that are
    saved within the service.  These prior versions are stored to provide a
    recovery from unintentional removal of content from a note. The identifiers
    that are returned by this call can be used with getNoteVersion to retrieve
    the previous note.
    The identifiers will be listed from the most recent versions to the oldest.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
    """
    pass

  def getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    This can be used to retrieve a previous version of a Note after it has been
    updated within the service.  The caller must identify the note (via its
    guid) and the version (via the updateSequenceNumber of that version).
    to find a listing of the stored version USNs for a note, call
    listNoteVersions.
    This call is only available for notes in Premium accounts.  (I.e. access
    to past versions of Notes is a Premium-only feature.)
    
    @param noteGuid
      The GUID of the note to be retrieved.
    
    @param updateSequenceNum
      The USN of the version of the note that is being retrieved
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
      <li> PERMISSION_DENIED "updateSequenceNum" -
        The account isn't permitted to access previous versions of notes.
        (i.e. this is a Free account.)
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
      <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
         the corresponding USN.
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - updateSequenceNum
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    pass

  def getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
    """
    Returns the current state of the resource in the service with the
    provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  Only the
    keys for the applicationData will be returned.
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withAttributes
      If true, the Resource will include the attributes
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withData
     - withRecognition
     - withAttributes
     - withAlternateData
    """
    pass

  def getResourceApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the Resource identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getResourceApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the Resource identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - Resource not found, by GUID</li>
      <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the Resource identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    pass

  def unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the Resource identified by 'guid'.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def updateResource(self, authenticationToken, resource):
    """
    Submit a set of changes to a resource to the service.  This can be used
    to update the meta-data about the resource, but cannot be used to change
    the binary contents of the resource (including the length and hash).  These
    cannot be changed directly without creating a new resource and removing the
    old one via updateNote.
    
    @param resource
      A Resource object containing the desired fields to be populated on
      the service.  The service will attempt to update the resource with the
      following fields from the client:
      <ul>
         <li>guid:  must be provided to identify the resource
         </li>
         <li>mime
         </li>
         <li>width
         </li>
         <li>height
         </li>
         <li>duration
         </li>
         <li>attributes:  optional.  if present, the set of attributes will
              be replaced.
         </li>
      </ul>
    
    @return
      The Update Sequence Number of the resource after the changes have been
      applied.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - resource
    """
    pass

  def getResourceData(self, authenticationToken, guid):
    """
    Returns binary data of the resource with the provided GUID.  For
    example, if this were an image resource, this would contain the
    raw bits of the image.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
    """
    Returns the current state of a resource, referenced by containing
    note GUID and resource content hash.
    
    @param noteGuid
      The GUID of the note that holds the resource to be retrieved.
    
    @param contentHash
      The MD5 checksum of the resource within that note. Note that
      this is the binary checksum, for example from Resource.data.bodyHash,
      and not the hex-encoded checksum that is used within an en-media
      tag in a note body.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body.
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      </li>
      <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note" - not found, by guid
      </li>
      <li> "Resource" - not found, by hash
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - contentHash
     - withData
     - withRecognition
     - withAlternateData
    """
    pass

  def getResourceRecognition(self, authenticationToken, guid):
    """
    Returns the binary contents of the recognition index for the resource
    with the provided GUID.  If the caller asks about a resource that has
    no recognition data, this will throw EDAMNotFoundException.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.recognition" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceAlternateData(self, authenticationToken, guid):
    """
    If the Resource with the provided GUID has an alternate data representation
    (indicated via the Resource.alternateData field), then this request can
    be used to retrieve the binary contents of that alternate data file.
    If the caller asks about a resource that has no alternate data form, this
    will throw EDAMNotFoundException.
    
    @param guid
       The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.alternateData" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceAttributes(self, authenticationToken, guid):
    """
    Returns the set of attributes for the Resource with the provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose attributes should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getPublicNotebook(self, userId, publicUri):
    """
    <p>
    Looks for a user account with the provided userId on this NoteStore
    shard and determines whether that account contains a public notebook
    with the given URI.  If the account is not found, or no public notebook
    exists with this URI, this will throw an EDAMNotFoundException,
    otherwise this will return the information for that Notebook.
    </p>
    <p>
    If a notebook is visible on the web with a full URL like
    http://www.evernote.com/pub/sethdemo/api
    Then 'sethdemo' is the username that can be used to look up the userId,
    and 'api' is the publicUri.
    </p>
    
    @param userId
       The numeric identifier for the user who owns the public notebook.
       To find this value based on a username string, you can invoke
       UserStore.getPublicUserInfo
    
    @param publicUri
       The uri string for the public notebook, from Notebook.publishing.uri.
    
    @throws EDAMNotFoundException <ul>
      <li>"Publishing.uri" - not found, by URI</li>
    </ul>
    
    @throws EDAMSystemException <ul>
      <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
        taken down (for all requesters).</li>
      <li> TAKEN_DOWN "Country" - The specified public notebook is taken
        down for the requester because of an IP-based country lookup.</li>
    </ul>
    
    Parameters:
     - userId
     - publicUri
    """
    pass

  def createSharedNotebook(self, authenticationToken, sharedNotebook):
    """
    Used to construct a shared notebook object. The constructed notebook will
    contain a "share key" which serve as a unique identifer and access token
    for a user to access the notebook of the shared notebook owner.
    
    @param sharedNotebook
      A shared notebook object populated with the email address of the share
      recipient, the notebook guid and the access permissions. All other
      attributes of the shared object are ignored. The SharedNotebook.allowPreview
      field must be explicitly set with either a true or false value.
    
    @return
      The fully populated SharedNotebook object including the server assigned
      share id and shareKey which can both be used to uniquely identify the
      SharedNotebook.
    
    @throws EDAMUserException <ul>
      <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
      <li>BAD_DATA_FORMAT "requireLogin" - if the SharedNotebook.allowPreview field was
          not set, and the SharedNotebook.requireLogin was also not set or was set to
          false.</li>
      <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
          recipientSettings is set in the sharedNotebook.  Only the recipient
          can set these values via the setSharedNotebookRecipientSettings
          method.
      </li>
      </ul>
    @throws EDAMNotFoundException <ul>
      <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
      </li>
      </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebook
    """
    pass

  def updateSharedNotebook(self, authenticationToken, sharedNotebook):
    """
    Update a SharedNotebook object.
    
    @param authenticationToken
      Must be an authentication token from the owner or a shared notebook
      authentication token or business authentication token with sufficient
      permissions to change invitations for a notebook.
    
    @param sharedNotebook
     The SharedNotebook object containing the requested changes.
     The "id" of the shared notebook must be set to allow the service
     to identify the SharedNotebook to be updated. In addition, you MUST set
     the email, permission, and allowPreview fields to the desired values.
     All other fields will be ignored if set.
    
    @return
     The Update Serial Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li>UNSUPPORTED_OPERATION "updateSharedNotebook" - if this service instance does not support shared notebooks.</li>
      <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid.</li>
      <li>DATA_REQUIRED "SharedNotebook.id" - if the id field was not set.</li>
      <li>DATA_REQUIRED "SharedNotebook.privilege" - if the privilege field was not set.</li>
      <li>DATA_REQUIRED "SharedNotebook.allowPreview" - if the allowPreview field was not set.</li>
      </ul>
    @throws EDAMNotFoundException <ul>
      <li>SharedNotebook.id - if no shared notebook with the specified ID was found.
      </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebook
    """
    pass

  def setSharedNotebookRecipientSettings(self, authenticationToken, sharedNotebookId, recipientSettings):
    """
    Set values for the recipient settings associated with a shared notebook.  Having
    update rights to the shared notebook record itself has no effect on this call;
    only the recipient of the shared notebook can can the recipient settings.
    
    If you do <i>not</i> wish to, or cannot, change one of the reminderNotifyEmail or
    reminderNotifyInApp fields, you must leave that field unset in recipientSettings.
    This method will skip that field for updates and leave the existing state as
    it is.
    
    @return The update sequence number of the account to which the shared notebook
      belongs, which is the account from which we are sharing a notebook.
    
    @throws EDAMNotFoundException "sharedNotebookId" - Thrown if the service does not
      have a shared notebook record for the sharedNotebookId on the given shard.  If you
      receive this exception, it is probable that the shared notebook record has
      been revoked or expired, or that you accessed the wrong shard.
    
    @throws EDAMUserException <ul>
      <li>PEMISSION_DENIED "authenticationToken" - If you do not have permission to set
          the recipient settings for the shared notebook.  Only the recipient has
          permission to do this.
      <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting whether
          or not you want to receive reminder e-mail notifications is possible on
          a business notebook in the business to which the user belongs.  All
          others can safely unset the reminderNotifyEmail field from the
          recipientSettings parameter.
    </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebookId
     - recipientSettings
    """
    pass

  def sendMessageToSharedNotebookMembers(self, authenticationToken, notebookGuid, messageText, recipients):
    """
    Send a reminder message to some or all of the email addresses that a notebook has been
    shared with. The message includes the current link to view the notebook.
    @param authenticationToken
      The auth token of the user with permissions to share the notebook
    @param notebookGuid
      The guid of the shared notebook
    @param messageText
     User provided text to include in the email
    @param recipients
     The email addresses of the recipients. If this list is empty then all of the
     users that the notebook has been shared with are emailed.
     If an email address doesn't correspond to share invite members then that address
     is ignored.
    @return
     The number of messages sent
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "(recipients)" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> PERMISSION_DENIED "Notebook.guid" - The user doesn't have permission to
        send a message for the specified notebook.
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
     - messageText
     - recipients
    """
    pass

  def listSharedNotebooks(self, authenticationToken):
    """
    Lists the collection of shared notebooks for all notebooks in the
    users account.
    
    @return
     The list of all SharedNotebooks for the user
    
    Parameters:
     - authenticationToken
    """
    pass

  def expungeSharedNotebooks(self, authenticationToken, sharedNotebookIds):
    """
    Expunges the SharedNotebooks in the user's account using the
    SharedNotebook.id as the identifier.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param
      sharedNotebookIds - a list of ShardNotebook.id longs identifying the
          objects to delete permanently.
    
    @return
      The account's update sequence number.
    
    Parameters:
     - authenticationToken
     - sharedNotebookIds
    """
    pass

  def createLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    Asks the service to make a linked notebook with the provided name, username
    of the owner and identifiers provided. A linked notebook can be either a
    link to a public notebook or to a private shared notebook.
    
    @param linkedNotebook
      The desired fields for the linked notebook must be provided on this
      object.  The name of the linked notebook must be set. Either a username
      uri or a shard id and share key must be provided otherwise a
      EDAMUserException is thrown.
    
    @return
      The newly created LinkedNotebook.  The server-side id will be
      saved in this object's 'id' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
        if public notebook set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.shareKey" -
        if private notebook set but bad shareKey
      </li>
      <li> DATA_REQUIRED "LinkedNotebook.shardId" -
        if private notebook but shard id not provided
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    pass

  def updateLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    @param linkedNotebook
      Updates the name of a linked notebook.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    pass

  def listLinkedNotebooks(self, authenticationToken):
    """
    Returns a list of linked notebooks
    
    Parameters:
     - authenticationToken
    """
    pass

  def expungeLinkedNotebook(self, authenticationToken, guid):
    """
    Permanently expunges the linked notebook from the account.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      from the account.
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def authenticateToSharedNotebook(self, shareKey, authenticationToken):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a shared notebook from someone else's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve notes, and if the permissions in the shared
    notebook are sufficient, to make changes to the contents of the notebook.
    
    @param shareKey
      The 'shareKey' identifier from the SharedNotebook that was granted to
      some recipient.  This string internally encodes the notebook identifier
      and a security signature.
    
    @param authenticationToken
      If a non-empty string is provided, this is the full user-based
      authentication token that identifies the user who is currently logged in
      and trying to access the shared notebook.  This may be required if the
      notebook was created with 'requireLogin'.
      If this string is empty, the service will attempt to authenticate to the
      shared notebook without any logged in user.
    
    @throws EDAMSystemException <ul>
      <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string
      </li>
      <li> INVALID_AUTH "shareKey" - bad signature on shareKey string
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
             no valid authentication token was provided.
      </li>
      <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
             and another username has already been bound to this notebook.
      </li>
    </ul>
    
    Parameters:
     - shareKey
     - authenticationToken
    """
    pass

  def getSharedNotebookByAuth(self, authenticationToken):
    """
    This function is used to retrieve extended information about a shared
    notebook by a guest who has already authenticated to access that notebook.
    This requires an 'authenticationToken' parameter which should be the
    resut of a call to authenticateToSharedNotebook(...).
    I.e. this is the token that gives access to the particular shared notebook
    in someone else's account -- it's not the authenticationToken for the
    owner of the notebook itself.
    
    @param authenticationToken
      Should be the authentication token retrieved from the reply of
      authenticateToSharedNotebook(), proving access to a particular shared
      notebook.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "authenticationToken" -
             authentication token doesn't correspond to a valid shared notebook
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
    """
    pass

  def emailNote(self, authenticationToken, parameters):
    """
    Attempts to send a single note to one or more email recipients.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param authenticationToken
       The note will be sent as the user logged in via this token, using that
       user's registered email address.  If the authenticated user doesn't
       have permission to read that note, the emailing will fail.
    
    @param parameters
       The note must be specified either by GUID (in which case it will be
       sent using the existing data in the service), or else the full Note
       must be passed to this call.  This also specifies the additional
       email fields that will be used in the email.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> BAD_DATA_FORMAT "(email address)" -
        email address malformed
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
        if there are no To: or Cc: addresses provided.
      </li>
      <li> DATA_REQUIRED "Note.title" -
        if the caller provides a Note parameter with no title
      </li>
      <li> DATA_REQUIRED "Note.content" -
        if the caller provides a Note parameter with no content
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.note" -
        if no guid or note provided
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - parameters
    """
    pass

  def shareNote(self, authenticationToken, guid):
    """
    If this note is not already shared (via its own direct URL), then this
    will start sharing that note.
    This will return the secret "Note Key" for this note that
    can currently be used in conjunction with the Note's GUID to gain direct
    read-only access to the Note.
    If the note is already shared, then this won't make any changes to the
    note, and the existing "Note Key" will be returned.  The only way to change
    the Note Key for an existing note is to stopSharingNote first, and then
    call this function.
    
    @param guid
      The GUID of the note to be shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def stopSharingNote(self, authenticationToken, guid):
    """
    If this note is not already shared then this will stop sharing that note
    and invalidate its "Note Key", so any existing URLs to access that Note
    will stop working.
    If the Note is not shared, then this function will do nothing.
    
    @param guid
      The GUID of the note to be un-shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def authenticateToSharedNote(self, guid, noteKey, authenticationToken):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a single Note which was individually shared
    from someone's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve the Note and its directly-referenced children.
    
    @param guid
      The GUID identifying this Note on this shard.
    
    @param noteKey
      The 'noteKey' identifier from the Note that was originally created via
      a call to shareNote() and then given to a recipient to access.
    
    @param authenticationToken
      An optional authenticationToken that identifies the user accessing the
      shared note. This parameter may be required to access some shared notes.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
        shared, or the noteKey doesn't match the current key for this note
      </li>
      <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
        required to access this Note, but either no authentication token or a
        "non-owner" authentication token was provided.
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "guid" - the note with that GUID is not found
      </li>
    </ul>
    
    @throws EDAMSystemException <ul>
      <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
        all requesters).
      </li>
      <li> TAKEN_DOWN "Country" - The specified shared note is taken down
        for the requester because of an IP-based country lookup.
      </ul>
    </ul>
    
    Parameters:
     - guid
     - noteKey
     - authenticationToken
    """
    pass

  def findRelated(self, authenticationToken, query, resultSpec):
    """
    Identify related entities on the service, such as notes,
    notebooks, and tags related to notes or content.
    
    @param query
      The information about which we are finding related entities.
    
    @param resultSpec
      Allows the client to indicate the type and quantity of
      information to be returned, allowing a saving of time and
      bandwidth.
    
    @return
      The result of the query, with information considered
      to likely be relevantly related to the information
      described by the query.
    
    @throws EDAMUserException <ul>
      <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
        a zero-length plain text value.
      </li>
      <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
        invalid Note GUID, that is, one that does not match the constraints
        defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
      <li>PERMISSION_DENIED "Note" - If the caller does not have access to
        the note identified by RelatedQuery.noteGuid.
      </li>
      <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
        in the result spec.
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li>"RelatedQuery.noteGuid" - the note with that GUID is not
        found, if that field has been set in the query.
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - query
     - resultSpec
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getSyncState(self, authenticationToken):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    
    Parameters:
     - authenticationToken
    """
    self.send_getSyncState(authenticationToken)
    return self.recv_getSyncState()

  def send_getSyncState(self, authenticationToken):
    self._oprot.writeMessageBegin('getSyncState', TMessageType.CALL, self._seqid)
    args = getSyncState_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSyncState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSyncState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncState failed: unknown result");

  def getSyncStateWithMetrics(self, authenticationToken, clientMetrics):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    This version of 'getSyncState' allows the client to upload coarse-
    grained usage metrics to the service.
    
    @param clientMetrics  see the documentation of the ClientUsageMetrics
      structure for an explanation of the fields that clients can pass to
      the service.
    
    Parameters:
     - authenticationToken
     - clientMetrics
    """
    self.send_getSyncStateWithMetrics(authenticationToken, clientMetrics)
    return self.recv_getSyncStateWithMetrics()

  def send_getSyncStateWithMetrics(self, authenticationToken, clientMetrics):
    self._oprot.writeMessageBegin('getSyncStateWithMetrics', TMessageType.CALL, self._seqid)
    args = getSyncStateWithMetrics_args()
    args.authenticationToken = authenticationToken
    args.clientMetrics = clientMetrics
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSyncStateWithMetrics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSyncStateWithMetrics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncStateWithMetrics failed: unknown result");

  def getSyncChunk(self, authenticationToken, afterUSN, maxEntries, fullSyncOnly):
    """
    DEPRECATED - use getFilteredSyncChunk.
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    self.send_getSyncChunk(authenticationToken, afterUSN, maxEntries, fullSyncOnly)
    return self.recv_getSyncChunk()

  def send_getSyncChunk(self, authenticationToken, afterUSN, maxEntries, fullSyncOnly):
    self._oprot.writeMessageBegin('getSyncChunk', TMessageType.CALL, self._seqid)
    args = getSyncChunk_args()
    args.authenticationToken = authenticationToken
    args.afterUSN = afterUSN
    args.maxEntries = maxEntries
    args.fullSyncOnly = fullSyncOnly
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSyncChunk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSyncChunk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncChunk failed: unknown result");

  def getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
    """
    Asks the NoteStore to provide the state of the account in order of
    last modification.  This request retrieves one block of the server's
    state so that a client can make several small requests against a large
    account rather than getting the entire state in one big message.
    This call gives fine-grained control of the data that will
    be received by a client by omitting data elements that a client doesn't
    need. This may reduce network traffic and sync times.
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
    
    @param filter
      The caller must set some of the flags in this structure to specify which
      data types should be returned during the synchronization.  See
      the SyncChunkFilter structure for information on each flag.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - filter
    """
    self.send_getFilteredSyncChunk(authenticationToken, afterUSN, maxEntries, filter)
    return self.recv_getFilteredSyncChunk()

  def send_getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
    self._oprot.writeMessageBegin('getFilteredSyncChunk', TMessageType.CALL, self._seqid)
    args = getFilteredSyncChunk_args()
    args.authenticationToken = authenticationToken
    args.afterUSN = afterUSN
    args.maxEntries = maxEntries
    args.filter = filter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFilteredSyncChunk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFilteredSyncChunk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilteredSyncChunk failed: unknown result");

  def getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
    """
    Asks the NoteStore to provide information about the status of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncState, but may omit
    SyncState.uploaded if the caller doesn't have permission to write to
    the linked notebook.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    self.send_getLinkedNotebookSyncState(authenticationToken, linkedNotebook)
    return self.recv_getLinkedNotebookSyncState()

  def send_getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
    self._oprot.writeMessageBegin('getLinkedNotebookSyncState', TMessageType.CALL, self._seqid)
    args = getLinkedNotebookSyncState_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLinkedNotebookSyncState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLinkedNotebookSyncState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkedNotebookSyncState failed: unknown result");

  def getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
    """
    Asks the NoteStore to provide information about the contents of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncChunk, but will only
    contain entries that are visible to the caller.  I.e. only that particular
    Notebook will be visible, along with its Notes, and Tags on those Notes.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.  This must contain the valid fields
      for either a shared notebook (e.g. shareKey)
      or a public notebook (e.g. username, uri)
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
      Applications should not request more than 256 objects at a time,
      and must handle the case where the service returns less than the
      requested number of objects in a given request even though more
      objects are available on the service.
    
    @param fullSyncOnly
      If true, then the client only wants initial data for a full sync.
      In this case, the service will not return any expunged objects,
      and will not return any Resources, since these are also provided
      in their corresponding Notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "LinkedNotebook" - if the provided information doesn't match any
        valid notebook
      </li>
      <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
        valid notebook
      </li>
      <li> "SharedNotebook.id" - if the provided information indicates a
         shared notebook that no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    self.send_getLinkedNotebookSyncChunk(authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly)
    return self.recv_getLinkedNotebookSyncChunk()

  def send_getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
    self._oprot.writeMessageBegin('getLinkedNotebookSyncChunk', TMessageType.CALL, self._seqid)
    args = getLinkedNotebookSyncChunk_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.afterUSN = afterUSN
    args.maxEntries = maxEntries
    args.fullSyncOnly = fullSyncOnly
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLinkedNotebookSyncChunk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLinkedNotebookSyncChunk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkedNotebookSyncChunk failed: unknown result");

  def listNotebooks(self, authenticationToken):
    """
    Returns a list of all of the notebooks in the account.
    
    Parameters:
     - authenticationToken
    """
    self.send_listNotebooks(authenticationToken)
    return self.recv_listNotebooks()

  def send_listNotebooks(self, authenticationToken):
    self._oprot.writeMessageBegin('listNotebooks', TMessageType.CALL, self._seqid)
    args = listNotebooks_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNotebooks failed: unknown result");

  def getNotebook(self, authenticationToken, guid):
    """
    Returns the current state of the notebook with the provided GUID.
    The notebook may be active or deleted (but not expunged).
    
    @param guid
      The GUID of the notebook to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNotebook(authenticationToken, guid)
    return self.recv_getNotebook()

  def send_getNotebook(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNotebook', TMessageType.CALL, self._seqid)
    args = getNotebook_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNotebook failed: unknown result");

  def getDefaultNotebook(self, authenticationToken):
    """
    Returns the notebook that should be used to store new notes in the
    user's account when no other notebooks are specified.
    
    Parameters:
     - authenticationToken
    """
    self.send_getDefaultNotebook(authenticationToken)
    return self.recv_getDefaultNotebook()

  def send_getDefaultNotebook(self, authenticationToken):
    self._oprot.writeMessageBegin('getDefaultNotebook', TMessageType.CALL, self._seqid)
    args = getDefaultNotebook_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDefaultNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDefaultNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDefaultNotebook failed: unknown result");

  def createNotebook(self, authenticationToken, notebook):
    """
    Asks the service to make a notebook with the provided name.
    
    @param notebook
      The desired fields for the notebook must be provided on this
      object.  The name of the notebook must be set, and either the 'active'
      or 'defaultNotebook' fields may be set by the client at creation.
      If a notebook exists in the account with the same name (via
      case-insensitive compare), this will throw an EDAMUserException.
    
    @return
      The newly created Notebook.  The server-side GUID will be
      saved in this object's 'guid' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
      <li> LIMIT_REACHED "Notebook" - at max number of notebooks
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    self.send_createNotebook(authenticationToken, notebook)
    return self.recv_createNotebook()

  def send_createNotebook(self, authenticationToken, notebook):
    self._oprot.writeMessageBegin('createNotebook', TMessageType.CALL, self._seqid)
    args = createNotebook_args()
    args.authenticationToken = authenticationToken
    args.notebook = notebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createNotebook failed: unknown result");

  def updateNotebook(self, authenticationToken, notebook):
    """
    Submits notebook changes to the service.  The provided data must include
    the notebook's guid field for identification.
    
    @param notebook
      The notebook object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    self.send_updateNotebook(authenticationToken, notebook)
    return self.recv_updateNotebook()

  def send_updateNotebook(self, authenticationToken, notebook):
    self._oprot.writeMessageBegin('updateNotebook', TMessageType.CALL, self._seqid)
    args = updateNotebook_args()
    args.authenticationToken = authenticationToken
    args.notebook = notebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNotebook failed: unknown result");

  def expungeNotebook(self, authenticationToken, guid):
    """
    Permanently removes the notebook from the user's account.
    After this action, the notebook is no longer available for undeletion, etc.
    If the notebook contains any Notes, they will be moved to the current
    default notebook and moved into the trash (i.e. Note.active=false).
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the notebook to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeNotebook(authenticationToken, guid)
    return self.recv_expungeNotebook()

  def send_expungeNotebook(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeNotebook', TMessageType.CALL, self._seqid)
    args = expungeNotebook_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNotebook failed: unknown result");

  def listTags(self, authenticationToken):
    """
    Returns a list of the tags in the account.  Evernote does not support
    the undeletion of tags, so this will only include active tags.
    
    Parameters:
     - authenticationToken
    """
    self.send_listTags(authenticationToken)
    return self.recv_listTags()

  def send_listTags(self, authenticationToken):
    self._oprot.writeMessageBegin('listTags', TMessageType.CALL, self._seqid)
    args = listTags_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listTags(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listTags_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result");

  def listTagsByNotebook(self, authenticationToken, notebookGuid):
    """
    Returns a list of the tags that are applied to at least one note within
    the provided notebook.  If the notebook is public, the authenticationToken
    may be ignored.
    
    @param notebookGuid
       the GUID of the notebook to use to find tags
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - notebook not found by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
    """
    self.send_listTagsByNotebook(authenticationToken, notebookGuid)
    return self.recv_listTagsByNotebook()

  def send_listTagsByNotebook(self, authenticationToken, notebookGuid):
    self._oprot.writeMessageBegin('listTagsByNotebook', TMessageType.CALL, self._seqid)
    args = listTagsByNotebook_args()
    args.authenticationToken = authenticationToken
    args.notebookGuid = notebookGuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listTagsByNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listTagsByNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTagsByNotebook failed: unknown result");

  def getTag(self, authenticationToken, guid):
    """
    Returns the current state of the Tag with the provided GUID.
    
    @param guid
      The GUID of the tag to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getTag(authenticationToken, guid)
    return self.recv_getTag()

  def send_getTag(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getTag', TMessageType.CALL, self._seqid)
    args = getTag_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result");

  def createTag(self, authenticationToken, tag):
    """
    Asks the service to make a tag with a set of information.
    
    @param tag
      The desired list of fields for the tag are specified in this
      object.  The caller must specify the tag name, and may provide
      the parentGUID.
    
    @return
      The newly created Tag.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> LIMIT_REACHED "Tag" - at max number of tags
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.parentGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    self.send_createTag(authenticationToken, tag)
    return self.recv_createTag()

  def send_createTag(self, authenticationToken, tag):
    self._oprot.writeMessageBegin('createTag', TMessageType.CALL, self._seqid)
    args = createTag_args()
    args.authenticationToken = authenticationToken
    args.tag = tag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result");

  def updateTag(self, authenticationToken, tag):
    """
    Submits tag changes to the service.  The provided data must include
    the tag's guid field for identification.  The service will apply
    updates to the following tag fields:  name, parentGuid
    
    @param tag
      The tag object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
      <li> "Tag.parentGuid" - parent not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    self.send_updateTag(authenticationToken, tag)
    return self.recv_updateTag()

  def send_updateTag(self, authenticationToken, tag):
    self._oprot.writeMessageBegin('updateTag', TMessageType.CALL, self._seqid)
    args = updateTag_args()
    args.authenticationToken = authenticationToken
    args.tag = tag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateTag failed: unknown result");

  def untagAll(self, authenticationToken, guid):
    """
    Removes the provided tag from every note that is currently tagged with
    this tag.  If this operation is successful, the tag will still be in
    the account, but it will not be tagged on any notes.
    
    This function is not indended for use by full synchronizing clients, since
    it does not provide enough result information to the client to reconcile
    the local state without performing a follow-up sync from the service.  This
    is intended for "thin clients" that need to efficiently support this as
    a UI operation.
    
    @param guid
      The GUID of the tag to remove from all notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_untagAll(authenticationToken, guid)
    self.recv_untagAll()

  def send_untagAll(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('untagAll', TMessageType.CALL, self._seqid)
    args = untagAll_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_untagAll(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = untagAll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    return

  def expungeTag(self, authenticationToken, guid):
    """
    Permanently deletes the tag with the provided GUID, if present.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the tag to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeTag(authenticationToken, guid)
    return self.recv_expungeTag()

  def send_expungeTag(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeTag', TMessageType.CALL, self._seqid)
    args = expungeTag_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeTag failed: unknown result");

  def listSearches(self, authenticationToken):
    """
    Returns a list of the searches in the account.  Evernote does not support
    the undeletion of searches, so this will only include active searches.
    
    Parameters:
     - authenticationToken
    """
    self.send_listSearches(authenticationToken)
    return self.recv_listSearches()

  def send_listSearches(self, authenticationToken):
    self._oprot.writeMessageBegin('listSearches', TMessageType.CALL, self._seqid)
    args = listSearches_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSearches(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listSearches_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSearches failed: unknown result");

  def getSearch(self, authenticationToken, guid):
    """
    Returns the current state of the search with the provided GUID.
    
    @param guid
      The GUID of the search to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getSearch(authenticationToken, guid)
    return self.recv_getSearch()

  def send_getSearch(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getSearch', TMessageType.CALL, self._seqid)
    args = getSearch_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSearch failed: unknown result");

  def createSearch(self, authenticationToken, search):
    """
    Asks the service to make a saved search with a set of information.
    
    @param search
      The desired list of fields for the search are specified in this
      object. The caller must specify the name and query for the
      search, and may optionally specify a search scope.
      The SavedSearch.format field is ignored by the service.
    
    @return
      The newly created SavedSearch.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    self.send_createSearch(authenticationToken, search)
    return self.recv_createSearch()

  def send_createSearch(self, authenticationToken, search):
    self._oprot.writeMessageBegin('createSearch', TMessageType.CALL, self._seqid)
    args = createSearch_args()
    args.authenticationToken = authenticationToken
    args.search = search
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createSearch failed: unknown result");

  def updateSearch(self, authenticationToken, search):
    """
    Submits search changes to the service. The provided data must include
    the search's guid field for identification. The service will apply
    updates to the following search fields: name, query, and scope.
    
    @param search
      The search object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    self.send_updateSearch(authenticationToken, search)
    return self.recv_updateSearch()

  def send_updateSearch(self, authenticationToken, search):
    self._oprot.writeMessageBegin('updateSearch', TMessageType.CALL, self._seqid)
    args = updateSearch_args()
    args.authenticationToken = authenticationToken
    args.search = search
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateSearch failed: unknown result");

  def expungeSearch(self, authenticationToken, guid):
    """
    Permanently deletes the saved search with the provided GUID, if present.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the search to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeSearch(authenticationToken, guid)
    return self.recv_expungeSearch()

  def send_expungeSearch(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeSearch', TMessageType.CALL, self._seqid)
    args = expungeSearch_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeSearch failed: unknown result");

  def findNotes(self, authenticationToken, filter, offset, maxNotes):
    """
    DEPRECATED. Use findNotesMetadata.
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
    """
    self.send_findNotes(authenticationToken, filter, offset, maxNotes)
    return self.recv_findNotes()

  def send_findNotes(self, authenticationToken, filter, offset, maxNotes):
    self._oprot.writeMessageBegin('findNotes', TMessageType.CALL, self._seqid)
    args = findNotes_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.offset = offset
    args.maxNotes = maxNotes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNotes failed: unknown result");

  def findNoteOffset(self, authenticationToken, filter, guid):
    """
    Finds the position of a note within a sorted subset of all of the user's
    notes. This may be useful for thin clients that are displaying a paginated
    listing of a large account, which need to know where a particular note
    sits in the list without retrieving all notes first.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @return
      If the note with the provided GUID is found within the matching note
      list, this will return the offset of that note within that list (where
      the first offset is 0).  If the note is not found within the set of
      notes, this will return -1.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - guid
    """
    self.send_findNoteOffset(authenticationToken, filter, guid)
    return self.recv_findNoteOffset()

  def send_findNoteOffset(self, authenticationToken, filter, guid):
    self._oprot.writeMessageBegin('findNoteOffset', TMessageType.CALL, self._seqid)
    args = findNoteOffset_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNoteOffset(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNoteOffset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNoteOffset failed: unknown result");

  def findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
    """
    Used to find the high-level information about a set of the notes from a
    user's account based on various criteria specified via a NoteFilter object.
    <p/>
    Web applications that wish to periodically check for new content in a user's
    Evernote account should consider using webhooks instead of polling this API.
    See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
    for more information.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param offset
      The numeric index of the first note to show within the sorted
      results.  The numbering scheme starts with "0".  This can be used for
      pagination.
    
    @param maxNotes
      The mximum notes to return in this query.  The service will return a set
      of notes that is no larger than this number, but may return fewer notes
      if needed.  The NoteList.totalNotes field in the return value will
      indicate whether there are more values available after the returned set.
    
    @param resultSpec
      This specifies which information should be returned for each matching
      Note. The fields on this structure can be used to eliminate data that
      the client doesn't need, which will reduce the time and bandwidth
      to receive and process the reply.
    
    @return
      The list of notes that match the criteria.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
     - resultSpec
    """
    self.send_findNotesMetadata(authenticationToken, filter, offset, maxNotes, resultSpec)
    return self.recv_findNotesMetadata()

  def send_findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
    self._oprot.writeMessageBegin('findNotesMetadata', TMessageType.CALL, self._seqid)
    args = findNotesMetadata_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.offset = offset
    args.maxNotes = maxNotes
    args.resultSpec = resultSpec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNotesMetadata(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNotesMetadata_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNotesMetadata failed: unknown result");

  def findNoteCounts(self, authenticationToken, filter, withTrash):
    """
    This function is used to determine how many notes are found for each
    notebook and tag in the user's account, given a current set of filter
    parameters that determine the current selection.  This function will
    return a structure that gives the note count for each notebook and tag
    that has at least one note under the requested filter.  Any notebook or
    tag that has zero notes in the filtered set will not be listed in the
    reply to this function (so they can be assumed to be 0).
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The note selection filter that is currently being applied.  The note
      counts are to be calculated with this filter applied to the total set
      of notes in the user's account.
    
    @param withTrash
      If true, then the NoteCollectionCounts.trashCount will be calculated
      and supplied in the reply. Otherwise, the trash value will be omitted.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - withTrash
    """
    self.send_findNoteCounts(authenticationToken, filter, withTrash)
    return self.recv_findNoteCounts()

  def send_findNoteCounts(self, authenticationToken, filter, withTrash):
    self._oprot.writeMessageBegin('findNoteCounts', TMessageType.CALL, self._seqid)
    args = findNoteCounts_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.withTrash = withTrash
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNoteCounts(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNoteCounts_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNoteCounts failed: unknown result");

  def getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    Returns the current state of the note in the service with the provided
    GUID.  The ENML contents of the note will only be provided if the
    'withContent' parameter is true.  The service will include the meta-data
    for each resource in the note, but the binary contents of the resources
    and their recognition data will be omitted.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  The applicationData
    fields are returned as keysOnly.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param withContent
      If true, the note will include the ENML contents of its
      'content' field.
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withContent
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    self.send_getNote(authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData)
    return self.recv_getNote()

  def send_getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    self._oprot.writeMessageBegin('getNote', TMessageType.CALL, self._seqid)
    args = getNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.withContent = withContent
    args.withResourcesData = withResourcesData
    args.withResourcesRecognition = withResourcesRecognition
    args.withResourcesAlternateData = withResourcesAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNote failed: unknown result");

  def getNoteApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the note identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getNoteApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNoteApplicationData(authenticationToken, guid)
    return self.recv_getNoteApplicationData()

  def send_getNoteApplicationData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNoteApplicationData', TMessageType.CALL, self._seqid)
    args = getNoteApplicationData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteApplicationData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteApplicationData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteApplicationData failed: unknown result");

  def getNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the note identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID</li>
      <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_getNoteApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_getNoteApplicationDataEntry()

  def send_getNoteApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('getNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = getNoteApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteApplicationDataEntry failed: unknown result");

  def setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the note identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    self.send_setNoteApplicationDataEntry(authenticationToken, guid, key, value)
    return self.recv_setNoteApplicationDataEntry()

  def send_setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
    self._oprot.writeMessageBegin('setNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = setNoteApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setNoteApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setNoteApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setNoteApplicationDataEntry failed: unknown result");

  def unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the note identified by 'guid'. Silently ignores an unset of a
    non-existing key.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_unsetNoteApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_unsetNoteApplicationDataEntry()

  def send_unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('unsetNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = unsetNoteApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unsetNoteApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unsetNoteApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetNoteApplicationDataEntry failed: unknown result");

  def getNoteContent(self, authenticationToken, guid):
    """
    Returns XHTML contents of the note with the provided GUID.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNoteContent(authenticationToken, guid)
    return self.recv_getNoteContent()

  def send_getNoteContent(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNoteContent', TMessageType.CALL, self._seqid)
    args = getNoteContent_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteContent(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteContent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteContent failed: unknown result");

  def getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
    """
    Returns a block of the extracted plain text contents of the note with the
    provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capabilities to extract all of the searchable
    text content from the note and its resources.
    
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param noteOnly
      If true, this will only return the text extracted from the ENML contents
      of the note itself.  If false, this will also include the extracted text
      from any text-bearing resources (PDF, recognized images)
    
    @param tokenizeForIndexing
      If true, this will break the text into cleanly separated and sanitized
      tokens.  If false, this will return the more raw text extraction, with
      its original punctuation, capitalization, spacing, etc.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - noteOnly
     - tokenizeForIndexing
    """
    self.send_getNoteSearchText(authenticationToken, guid, noteOnly, tokenizeForIndexing)
    return self.recv_getNoteSearchText()

  def send_getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
    self._oprot.writeMessageBegin('getNoteSearchText', TMessageType.CALL, self._seqid)
    args = getNoteSearchText_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.noteOnly = noteOnly
    args.tokenizeForIndexing = tokenizeForIndexing
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteSearchText(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteSearchText_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteSearchText failed: unknown result");

  def getResourceSearchText(self, authenticationToken, guid):
    """
    Returns a block of the extracted plain text contents of the resource with
    the provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capability to extract all of the searchable
    text content from a resource.
    
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceSearchText(authenticationToken, guid)
    return self.recv_getResourceSearchText()

  def send_getResourceSearchText(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceSearchText', TMessageType.CALL, self._seqid)
    args = getResourceSearchText_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceSearchText(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceSearchText_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceSearchText failed: unknown result");

  def getNoteTagNames(self, authenticationToken, guid):
    """
    Returns a list of the names of the tags for the note with the provided
    guid.  This can be used with authentication to get the tags for a
    user's own note, or can be used without valid authentication to retrieve
    the names of the tags for a note in a public notebook.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNoteTagNames(authenticationToken, guid)
    return self.recv_getNoteTagNames()

  def send_getNoteTagNames(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNoteTagNames', TMessageType.CALL, self._seqid)
    args = getNoteTagNames_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteTagNames(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteTagNames_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteTagNames failed: unknown result");

  def createNote(self, authenticationToken, note):
    """
    Asks the service to make a note with the provided set of information.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service.
    
    @return
      The newly created Note from the service.  The server-side
      GUIDs for the Note and any Resources will be saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.notebookGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    self.send_createNote(authenticationToken, note)
    return self.recv_createNote()

  def send_createNote(self, authenticationToken, note):
    self._oprot.writeMessageBegin('createNote', TMessageType.CALL, self._seqid)
    args = createNote_args()
    args.authenticationToken = authenticationToken
    args.note = note
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createNote failed: unknown result");

  def updateNote(self, authenticationToken, note):
    """
    Submit a set of changes to a note to the service.  The provided data
    must include the note's guid field for identification. The note's
    title must also be set.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service. With the exception of the note's title and guid, fields
      that are not being changed do not need to be set. If the content is not
      being modified, note.content should be left unset. If the list of
      resources is not being modified, note.resources should be left unset.
    
    @return
      The metadata (no contents) for the Note on the server after the update
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID
      </li>
      <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    self.send_updateNote(authenticationToken, note)
    return self.recv_updateNote()

  def send_updateNote(self, authenticationToken, note):
    self._oprot.writeMessageBegin('updateNote', TMessageType.CALL, self._seqid)
    args = updateNote_args()
    args.authenticationToken = authenticationToken
    args.note = note
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNote failed: unknown result");

  def deleteNote(self, authenticationToken, guid):
    """
    Moves the note into the trash. The note may still be undeleted, unless it
    is expunged.  This is equivalent to calling updateNote() after setting
    Note.active = false
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't have permission to
             update the note.
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      </li>
    </ul>
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_deleteNote(authenticationToken, guid)
    return self.recv_deleteNote()

  def send_deleteNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('deleteNote', TMessageType.CALL, self._seqid)
    args = deleteNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNote failed: unknown result");

  def expungeNote(self, authenticationToken, guid):
    """
    Permanently removes a Note, and all of its Resources,
    from the service.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeNote(authenticationToken, guid)
    return self.recv_expungeNote()

  def send_expungeNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeNote', TMessageType.CALL, self._seqid)
    args = expungeNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNote failed: unknown result");

  def expungeNotes(self, authenticationToken, noteGuids):
    """
    Permanently removes a list of Notes, and all of their Resources, from
    the service.  This should be invoked with a small number of Note GUIDs
    (e.g. 100 or less) on each call.  To expunge a larger number of notes,
    call this method multiple times.  This should also be used to reduce the
    number of Notes in a notebook before calling expungeNotebook() or
    in the trash before calling expungeInactiveNotes(), since these calls may
    be prohibitively slow if there are more than a few hundred notes.
    If an exception is thrown for any of the GUIDs, then none of the notes
    will be deleted.  I.e. this call can be treated as an atomic transaction.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param noteGuids
      The list of GUIDs for the Notes to remove.
    
    @return
      The account's updateCount at the end of this operation
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuids
    """
    self.send_expungeNotes(authenticationToken, noteGuids)
    return self.recv_expungeNotes()

  def send_expungeNotes(self, authenticationToken, noteGuids):
    self._oprot.writeMessageBegin('expungeNotes', TMessageType.CALL, self._seqid)
    args = expungeNotes_args()
    args.authenticationToken = authenticationToken
    args.noteGuids = noteGuids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeNotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeNotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNotes failed: unknown result");

  def expungeInactiveNotes(self, authenticationToken):
    """
    Permanently removes all of the Notes that are currently marked as
    inactive.  This is equivalent to "emptying the trash", and these Notes
    will be gone permanently.
    <p/>
    This operation may be relatively slow if the account contains a large
    number of inactive Notes.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @return
       The number of notes that were expunged.
    
    Parameters:
     - authenticationToken
    """
    self.send_expungeInactiveNotes(authenticationToken)
    return self.recv_expungeInactiveNotes()

  def send_expungeInactiveNotes(self, authenticationToken):
    self._oprot.writeMessageBegin('expungeInactiveNotes', TMessageType.CALL, self._seqid)
    args = expungeInactiveNotes_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeInactiveNotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeInactiveNotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeInactiveNotes failed: unknown result");

  def copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
    """
    Performs a deep copy of the Note with the provided GUID 'noteGuid' into
    the Notebook with the provided GUID 'toNotebookGuid'.
    The caller must be the owner of both the Note and the Notebook.
    This creates a new Note in the destination Notebook with new content and
    Resources that match all of the content and Resources from the original
    Note, but with new GUID identifiers.
    The original Note is not modified by this operation.
    The copied note is considered as an "upload" for the purpose of upload
    transfer limit calculation, so its size is added to the upload count for
    the owner.
    
    @param noteGuid
      The GUID of the Note to copy.
    
    @param toNotebookGuid
      The GUID of the Notebook that should receive the new Note.
    
    @return
      The metadata for the new Note that was created.  This will include the
      new GUID for this Note (and any copied Resources), but will not include
      the content body or the binary bodies of any Resources.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - toNotebookGuid
    """
    self.send_copyNote(authenticationToken, noteGuid, toNotebookGuid)
    return self.recv_copyNote()

  def send_copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
    self._oprot.writeMessageBegin('copyNote', TMessageType.CALL, self._seqid)
    args = copyNote_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.toNotebookGuid = toNotebookGuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_copyNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = copyNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "copyNote failed: unknown result");

  def listNoteVersions(self, authenticationToken, noteGuid):
    """
    Returns a list of the prior versions of a particular note that are
    saved within the service.  These prior versions are stored to provide a
    recovery from unintentional removal of content from a note. The identifiers
    that are returned by this call can be used with getNoteVersion to retrieve
    the previous note.
    The identifiers will be listed from the most recent versions to the oldest.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
    """
    self.send_listNoteVersions(authenticationToken, noteGuid)
    return self.recv_listNoteVersions()

  def send_listNoteVersions(self, authenticationToken, noteGuid):
    self._oprot.writeMessageBegin('listNoteVersions', TMessageType.CALL, self._seqid)
    args = listNoteVersions_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNoteVersions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNoteVersions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNoteVersions failed: unknown result");

  def getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    This can be used to retrieve a previous version of a Note after it has been
    updated within the service.  The caller must identify the note (via its
    guid) and the version (via the updateSequenceNumber of that version).
    to find a listing of the stored version USNs for a note, call
    listNoteVersions.
    This call is only available for notes in Premium accounts.  (I.e. access
    to past versions of Notes is a Premium-only feature.)
    
    @param noteGuid
      The GUID of the note to be retrieved.
    
    @param updateSequenceNum
      The USN of the version of the note that is being retrieved
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
      <li> PERMISSION_DENIED "updateSequenceNum" -
        The account isn't permitted to access previous versions of notes.
        (i.e. this is a Free account.)
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
      <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
         the corresponding USN.
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - updateSequenceNum
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    self.send_getNoteVersion(authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData)
    return self.recv_getNoteVersion()

  def send_getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    self._oprot.writeMessageBegin('getNoteVersion', TMessageType.CALL, self._seqid)
    args = getNoteVersion_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.updateSequenceNum = updateSequenceNum
    args.withResourcesData = withResourcesData
    args.withResourcesRecognition = withResourcesRecognition
    args.withResourcesAlternateData = withResourcesAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteVersion failed: unknown result");

  def getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
    """
    Returns the current state of the resource in the service with the
    provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  Only the
    keys for the applicationData will be returned.
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withAttributes
      If true, the Resource will include the attributes
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withData
     - withRecognition
     - withAttributes
     - withAlternateData
    """
    self.send_getResource(authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData)
    return self.recv_getResource()

  def send_getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
    self._oprot.writeMessageBegin('getResource', TMessageType.CALL, self._seqid)
    args = getResource_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.withData = withData
    args.withRecognition = withRecognition
    args.withAttributes = withAttributes
    args.withAlternateData = withAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResource(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResource_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResource failed: unknown result");

  def getResourceApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the Resource identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getResourceApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceApplicationData(authenticationToken, guid)
    return self.recv_getResourceApplicationData()

  def send_getResourceApplicationData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceApplicationData', TMessageType.CALL, self._seqid)
    args = getResourceApplicationData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceApplicationData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceApplicationData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceApplicationData failed: unknown result");

  def getResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the Resource identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - Resource not found, by GUID</li>
      <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_getResourceApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_getResourceApplicationDataEntry()

  def send_getResourceApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('getResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = getResourceApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceApplicationDataEntry failed: unknown result");

  def setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the Resource identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    self.send_setResourceApplicationDataEntry(authenticationToken, guid, key, value)
    return self.recv_setResourceApplicationDataEntry()

  def send_setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
    self._oprot.writeMessageBegin('setResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = setResourceApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setResourceApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setResourceApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setResourceApplicationDataEntry failed: unknown result");

  def unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the Resource identified by 'guid'.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_unsetResourceApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_unsetResourceApplicationDataEntry()

  def send_unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('unsetResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = unsetResourceApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unsetResourceApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unsetResourceApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetResourceApplicationDataEntry failed: unknown result");

  def updateResource(self, authenticationToken, resource):
    """
    Submit a set of changes to a resource to the service.  This can be used
    to update the meta-data about the resource, but cannot be used to change
    the binary contents of the resource (including the length and hash).  These
    cannot be changed directly without creating a new resource and removing the
    old one via updateNote.
    
    @param resource
      A Resource object containing the desired fields to be populated on
      the service.  The service will attempt to update the resource with the
      following fields from the client:
      <ul>
         <li>guid:  must be provided to identify the resource
         </li>
         <li>mime
         </li>
         <li>width
         </li>
         <li>height
         </li>
         <li>duration
         </li>
         <li>attributes:  optional.  if present, the set of attributes will
              be replaced.
         </li>
      </ul>
    
    @return
      The Update Sequence Number of the resource after the changes have been
      applied.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - resource
    """
    self.send_updateResource(authenticationToken, resource)
    return self.recv_updateResource()

  def send_updateResource(self, authenticationToken, resource):
    self._oprot.writeMessageBegin('updateResource', TMessageType.CALL, self._seqid)
    args = updateResource_args()
    args.authenticationToken = authenticationToken
    args.resource = resource
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateResource(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateResource_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateResource failed: unknown result");

  def getResourceData(self, authenticationToken, guid):
    """
    Returns binary data of the resource with the provided GUID.  For
    example, if this were an image resource, this would contain the
    raw bits of the image.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceData(authenticationToken, guid)
    return self.recv_getResourceData()

  def send_getResourceData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceData', TMessageType.CALL, self._seqid)
    args = getResourceData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceData failed: unknown result");

  def getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
    """
    Returns the current state of a resource, referenced by containing
    note GUID and resource content hash.
    
    @param noteGuid
      The GUID of the note that holds the resource to be retrieved.
    
    @param contentHash
      The MD5 checksum of the resource within that note. Note that
      this is the binary checksum, for example from Resource.data.bodyHash,
      and not the hex-encoded checksum that is used within an en-media
      tag in a note body.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body.
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      </li>
      <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note" - not found, by guid
      </li>
      <li> "Resource" - not found, by hash
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - contentHash
     - withData
     - withRecognition
     - withAlternateData
    """
    self.send_getResourceByHash(authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData)
    return self.recv_getResourceByHash()

  def send_getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
    self._oprot.writeMessageBegin('getResourceByHash', TMessageType.CALL, self._seqid)
    args = getResourceByHash_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.contentHash = contentHash
    args.withData = withData
    args.withRecognition = withRecognition
    args.withAlternateData = withAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceByHash(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceByHash_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceByHash failed: unknown result");

  def getResourceRecognition(self, authenticationToken, guid):
    """
    Returns the binary contents of the recognition index for the resource
    with the provided GUID.  If the caller asks about a resource that has
    no recognition data, this will throw EDAMNotFoundException.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.recognition" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceRecognition(authenticationToken, guid)
    return self.recv_getResourceRecognition()

  def send_getResourceRecognition(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceRecognition', TMessageType.CALL, self._seqid)
    args = getResourceRecognition_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceRecognition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceRecognition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceRecognition failed: unknown result");

  def getResourceAlternateData(self, authenticationToken, guid):
    """
    If the Resource with the provided GUID has an alternate data representation
    (indicated via the Resource.alternateData field), then this request can
    be used to retrieve the binary contents of that alternate data file.
    If the caller asks about a resource that has no alternate data form, this
    will throw EDAMNotFoundException.
    
    @param guid
       The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.alternateData" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceAlternateData(authenticationToken, guid)
    return self.recv_getResourceAlternateData()

  def send_getResourceAlternateData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceAlternateData', TMessageType.CALL, self._seqid)
    args = getResourceAlternateData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceAlternateData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceAlternateData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceAlternateData failed: unknown result");

  def getResourceAttributes(self, authenticationToken, guid):
    """
    Returns the set of attributes for the Resource with the provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose attributes should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceAttributes(authenticationToken, guid)
    return self.recv_getResourceAttributes()

  def send_getResourceAttributes(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceAttributes', TMessageType.CALL, self._seqid)
    args = getResourceAttributes_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceAttributes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceAttributes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceAttributes failed: unknown result");

  def getPublicNotebook(self, userId, publicUri):
    """
    <p>
    Looks for a user account with the provided userId on this NoteStore
    shard and determines whether that account contains a public notebook
    with the given URI.  If the account is not found, or no public notebook
    exists with this URI, this will throw an EDAMNotFoundException,
    otherwise this will return the information for that Notebook.
    </p>
    <p>
    If a notebook is visible on the web with a full URL like
    http://www.evernote.com/pub/sethdemo/api
    Then 'sethdemo' is the username that can be used to look up the userId,
    and 'api' is the publicUri.
    </p>
    
    @param userId
       The numeric identifier for the user who owns the public notebook.
       To find this value based on a username string, you can invoke
       UserStore.getPublicUserInfo
    
    @param publicUri
       The uri string for the public notebook, from Notebook.publishing.uri.
    
    @throws EDAMNotFoundException <ul>
      <li>"Publishing.uri" - not found, by URI</li>
    </ul>
    
    @throws EDAMSystemException <ul>
      <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
        taken down (for all requesters).</li>
      <li> TAKEN_DOWN "Country" - The specified public notebook is taken
        down for the requester because of an IP-based country lookup.</li>
    </ul>
    
    Parameters:
     - userId
     - publicUri
    """
    self.send_getPublicNotebook(userId, publicUri)
    return self.recv_getPublicNotebook()

  def send_getPublicNotebook(self, userId, publicUri):
    self._oprot.writeMessageBegin('getPublicNotebook', TMessageType.CALL, self._seqid)
    args = getPublicNotebook_args()
    args.userId = userId
    args.publicUri = publicUri
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPublicNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPublicNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicNotebook failed: unknown result");

  def createSharedNotebook(self, authenticationToken, sharedNotebook):
    """
    Used to construct a shared notebook object. The constructed notebook will
    contain a "share key" which serve as a unique identifer and access token
    for a user to access the notebook of the shared notebook owner.
    
    @param sharedNotebook
      A shared notebook object populated with the email address of the share
      recipient, the notebook guid and the access permissions. All other
      attributes of the shared object are ignored. The SharedNotebook.allowPreview
      field must be explicitly set with either a true or false value.
    
    @return
      The fully populated SharedNotebook object including the server assigned
      share id and shareKey which can both be used to uniquely identify the
      SharedNotebook.
    
    @throws EDAMUserException <ul>
      <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
      <li>BAD_DATA_FORMAT "requireLogin" - if the SharedNotebook.allowPreview field was
          not set, and the SharedNotebook.requireLogin was also not set or was set to
          false.</li>
      <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
          recipientSettings is set in the sharedNotebook.  Only the recipient
          can set these values via the setSharedNotebookRecipientSettings
          method.
      </li>
      </ul>
    @throws EDAMNotFoundException <ul>
      <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
      </li>
      </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebook
    """
    self.send_createSharedNotebook(authenticationToken, sharedNotebook)
    return self.recv_createSharedNotebook()

  def send_createSharedNotebook(self, authenticationToken, sharedNotebook):
    self._oprot.writeMessageBegin('createSharedNotebook', TMessageType.CALL, self._seqid)
    args = createSharedNotebook_args()
    args.authenticationToken = authenticationToken
    args.sharedNotebook = sharedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createSharedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createSharedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createSharedNotebook failed: unknown result");

  def updateSharedNotebook(self, authenticationToken, sharedNotebook):
    """
    Update a SharedNotebook object.
    
    @param authenticationToken
      Must be an authentication token from the owner or a shared notebook
      authentication token or business authentication token with sufficient
      permissions to change invitations for a notebook.
    
    @param sharedNotebook
     The SharedNotebook object containing the requested changes.
     The "id" of the shared notebook must be set to allow the service
     to identify the SharedNotebook to be updated. In addition, you MUST set
     the email, permission, and allowPreview fields to the desired values.
     All other fields will be ignored if set.
    
    @return
     The Update Serial Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li>UNSUPPORTED_OPERATION "updateSharedNotebook" - if this service instance does not support shared notebooks.</li>
      <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid.</li>
      <li>DATA_REQUIRED "SharedNotebook.id" - if the id field was not set.</li>
      <li>DATA_REQUIRED "SharedNotebook.privilege" - if the privilege field was not set.</li>
      <li>DATA_REQUIRED "SharedNotebook.allowPreview" - if the allowPreview field was not set.</li>
      </ul>
    @throws EDAMNotFoundException <ul>
      <li>SharedNotebook.id - if no shared notebook with the specified ID was found.
      </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebook
    """
    self.send_updateSharedNotebook(authenticationToken, sharedNotebook)
    return self.recv_updateSharedNotebook()

  def send_updateSharedNotebook(self, authenticationToken, sharedNotebook):
    self._oprot.writeMessageBegin('updateSharedNotebook', TMessageType.CALL, self._seqid)
    args = updateSharedNotebook_args()
    args.authenticationToken = authenticationToken
    args.sharedNotebook = sharedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateSharedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateSharedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateSharedNotebook failed: unknown result");

  def setSharedNotebookRecipientSettings(self, authenticationToken, sharedNotebookId, recipientSettings):
    """
    Set values for the recipient settings associated with a shared notebook.  Having
    update rights to the shared notebook record itself has no effect on this call;
    only the recipient of the shared notebook can can the recipient settings.
    
    If you do <i>not</i> wish to, or cannot, change one of the reminderNotifyEmail or
    reminderNotifyInApp fields, you must leave that field unset in recipientSettings.
    This method will skip that field for updates and leave the existing state as
    it is.
    
    @return The update sequence number of the account to which the shared notebook
      belongs, which is the account from which we are sharing a notebook.
    
    @throws EDAMNotFoundException "sharedNotebookId" - Thrown if the service does not
      have a shared notebook record for the sharedNotebookId on the given shard.  If you
      receive this exception, it is probable that the shared notebook record has
      been revoked or expired, or that you accessed the wrong shard.
    
    @throws EDAMUserException <ul>
      <li>PEMISSION_DENIED "authenticationToken" - If you do not have permission to set
          the recipient settings for the shared notebook.  Only the recipient has
          permission to do this.
      <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting whether
          or not you want to receive reminder e-mail notifications is possible on
          a business notebook in the business to which the user belongs.  All
          others can safely unset the reminderNotifyEmail field from the
          recipientSettings parameter.
    </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebookId
     - recipientSettings
    """
    self.send_setSharedNotebookRecipientSettings(authenticationToken, sharedNotebookId, recipientSettings)
    return self.recv_setSharedNotebookRecipientSettings()

  def send_setSharedNotebookRecipientSettings(self, authenticationToken, sharedNotebookId, recipientSettings):
    self._oprot.writeMessageBegin('setSharedNotebookRecipientSettings', TMessageType.CALL, self._seqid)
    args = setSharedNotebookRecipientSettings_args()
    args.authenticationToken = authenticationToken
    args.sharedNotebookId = sharedNotebookId
    args.recipientSettings = recipientSettings
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setSharedNotebookRecipientSettings(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setSharedNotebookRecipientSettings_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setSharedNotebookRecipientSettings failed: unknown result");

  def sendMessageToSharedNotebookMembers(self, authenticationToken, notebookGuid, messageText, recipients):
    """
    Send a reminder message to some or all of the email addresses that a notebook has been
    shared with. The message includes the current link to view the notebook.
    @param authenticationToken
      The auth token of the user with permissions to share the notebook
    @param notebookGuid
      The guid of the shared notebook
    @param messageText
     User provided text to include in the email
    @param recipients
     The email addresses of the recipients. If this list is empty then all of the
     users that the notebook has been shared with are emailed.
     If an email address doesn't correspond to share invite members then that address
     is ignored.
    @return
     The number of messages sent
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "(recipients)" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> PERMISSION_DENIED "Notebook.guid" - The user doesn't have permission to
        send a message for the specified notebook.
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
     - messageText
     - recipients
    """
    self.send_sendMessageToSharedNotebookMembers(authenticationToken, notebookGuid, messageText, recipients)
    return self.recv_sendMessageToSharedNotebookMembers()

  def send_sendMessageToSharedNotebookMembers(self, authenticationToken, notebookGuid, messageText, recipients):
    self._oprot.writeMessageBegin('sendMessageToSharedNotebookMembers', TMessageType.CALL, self._seqid)
    args = sendMessageToSharedNotebookMembers_args()
    args.authenticationToken = authenticationToken
    args.notebookGuid = notebookGuid
    args.messageText = messageText
    args.recipients = recipients
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendMessageToSharedNotebookMembers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendMessageToSharedNotebookMembers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendMessageToSharedNotebookMembers failed: unknown result");

  def listSharedNotebooks(self, authenticationToken):
    """
    Lists the collection of shared notebooks for all notebooks in the
    users account.
    
    @return
     The list of all SharedNotebooks for the user
    
    Parameters:
     - authenticationToken
    """
    self.send_listSharedNotebooks(authenticationToken)
    return self.recv_listSharedNotebooks()

  def send_listSharedNotebooks(self, authenticationToken):
    self._oprot.writeMessageBegin('listSharedNotebooks', TMessageType.CALL, self._seqid)
    args = listSharedNotebooks_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSharedNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listSharedNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSharedNotebooks failed: unknown result");

  def expungeSharedNotebooks(self, authenticationToken, sharedNotebookIds):
    """
    Expunges the SharedNotebooks in the user's account using the
    SharedNotebook.id as the identifier.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param
      sharedNotebookIds - a list of ShardNotebook.id longs identifying the
          objects to delete permanently.
    
    @return
      The account's update sequence number.
    
    Parameters:
     - authenticationToken
     - sharedNotebookIds
    """
    self.send_expungeSharedNotebooks(authenticationToken, sharedNotebookIds)
    return self.recv_expungeSharedNotebooks()

  def send_expungeSharedNotebooks(self, authenticationToken, sharedNotebookIds):
    self._oprot.writeMessageBegin('expungeSharedNotebooks', TMessageType.CALL, self._seqid)
    args = expungeSharedNotebooks_args()
    args.authenticationToken = authenticationToken
    args.sharedNotebookIds = sharedNotebookIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeSharedNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeSharedNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeSharedNotebooks failed: unknown result");

  def createLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    Asks the service to make a linked notebook with the provided name, username
    of the owner and identifiers provided. A linked notebook can be either a
    link to a public notebook or to a private shared notebook.
    
    @param linkedNotebook
      The desired fields for the linked notebook must be provided on this
      object.  The name of the linked notebook must be set. Either a username
      uri or a shard id and share key must be provided otherwise a
      EDAMUserException is thrown.
    
    @return
      The newly created LinkedNotebook.  The server-side id will be
      saved in this object's 'id' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
        if public notebook set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.shareKey" -
        if private notebook set but bad shareKey
      </li>
      <li> DATA_REQUIRED "LinkedNotebook.shardId" -
        if private notebook but shard id not provided
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    self.send_createLinkedNotebook(authenticationToken, linkedNotebook)
    return self.recv_createLinkedNotebook()

  def send_createLinkedNotebook(self, authenticationToken, linkedNotebook):
    self._oprot.writeMessageBegin('createLinkedNotebook', TMessageType.CALL, self._seqid)
    args = createLinkedNotebook_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createLinkedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createLinkedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createLinkedNotebook failed: unknown result");

  def updateLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    @param linkedNotebook
      Updates the name of a linked notebook.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    self.send_updateLinkedNotebook(authenticationToken, linkedNotebook)
    return self.recv_updateLinkedNotebook()

  def send_updateLinkedNotebook(self, authenticationToken, linkedNotebook):
    self._oprot.writeMessageBegin('updateLinkedNotebook', TMessageType.CALL, self._seqid)
    args = updateLinkedNotebook_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateLinkedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateLinkedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateLinkedNotebook failed: unknown result");

  def listLinkedNotebooks(self, authenticationToken):
    """
    Returns a list of linked notebooks
    
    Parameters:
     - authenticationToken
    """
    self.send_listLinkedNotebooks(authenticationToken)
    return self.recv_listLinkedNotebooks()

  def send_listLinkedNotebooks(self, authenticationToken):
    self._oprot.writeMessageBegin('listLinkedNotebooks', TMessageType.CALL, self._seqid)
    args = listLinkedNotebooks_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listLinkedNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listLinkedNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listLinkedNotebooks failed: unknown result");

  def expungeLinkedNotebook(self, authenticationToken, guid):
    """
    Permanently expunges the linked notebook from the account.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      from the account.
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeLinkedNotebook(authenticationToken, guid)
    return self.recv_expungeLinkedNotebook()

  def send_expungeLinkedNotebook(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeLinkedNotebook', TMessageType.CALL, self._seqid)
    args = expungeLinkedNotebook_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeLinkedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeLinkedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeLinkedNotebook failed: unknown result");

  def authenticateToSharedNotebook(self, shareKey, authenticationToken):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a shared notebook from someone else's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve notes, and if the permissions in the shared
    notebook are sufficient, to make changes to the contents of the notebook.
    
    @param shareKey
      The 'shareKey' identifier from the SharedNotebook that was granted to
      some recipient.  This string internally encodes the notebook identifier
      and a security signature.
    
    @param authenticationToken
      If a non-empty string is provided, this is the full user-based
      authentication token that identifies the user who is currently logged in
      and trying to access the shared notebook.  This may be required if the
      notebook was created with 'requireLogin'.
      If this string is empty, the service will attempt to authenticate to the
      shared notebook without any logged in user.
    
    @throws EDAMSystemException <ul>
      <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string
      </li>
      <li> INVALID_AUTH "shareKey" - bad signature on shareKey string
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
             no valid authentication token was provided.
      </li>
      <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
             and another username has already been bound to this notebook.
      </li>
    </ul>
    
    Parameters:
     - shareKey
     - authenticationToken
    """
    self.send_authenticateToSharedNotebook(shareKey, authenticationToken)
    return self.recv_authenticateToSharedNotebook()

  def send_authenticateToSharedNotebook(self, shareKey, authenticationToken):
    self._oprot.writeMessageBegin('authenticateToSharedNotebook', TMessageType.CALL, self._seqid)
    args = authenticateToSharedNotebook_args()
    args.shareKey = shareKey
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticateToSharedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticateToSharedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToSharedNotebook failed: unknown result");

  def getSharedNotebookByAuth(self, authenticationToken):
    """
    This function is used to retrieve extended information about a shared
    notebook by a guest who has already authenticated to access that notebook.
    This requires an 'authenticationToken' parameter which should be the
    resut of a call to authenticateToSharedNotebook(...).
    I.e. this is the token that gives access to the particular shared notebook
    in someone else's account -- it's not the authenticationToken for the
    owner of the notebook itself.
    
    @param authenticationToken
      Should be the authentication token retrieved from the reply of
      authenticateToSharedNotebook(), proving access to a particular shared
      notebook.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "authenticationToken" -
             authentication token doesn't correspond to a valid shared notebook
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
    """
    self.send_getSharedNotebookByAuth(authenticationToken)
    return self.recv_getSharedNotebookByAuth()

  def send_getSharedNotebookByAuth(self, authenticationToken):
    self._oprot.writeMessageBegin('getSharedNotebookByAuth', TMessageType.CALL, self._seqid)
    args = getSharedNotebookByAuth_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSharedNotebookByAuth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSharedNotebookByAuth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSharedNotebookByAuth failed: unknown result");

  def emailNote(self, authenticationToken, parameters):
    """
    Attempts to send a single note to one or more email recipients.
    <p/>
    NOTE: This function is generally not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param authenticationToken
       The note will be sent as the user logged in via this token, using that
       user's registered email address.  If the authenticated user doesn't
       have permission to read that note, the emailing will fail.
    
    @param parameters
       The note must be specified either by GUID (in which case it will be
       sent using the existing data in the service), or else the full Note
       must be passed to this call.  This also specifies the additional
       email fields that will be used in the email.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> BAD_DATA_FORMAT "(email address)" -
        email address malformed
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
        if there are no To: or Cc: addresses provided.
      </li>
      <li> DATA_REQUIRED "Note.title" -
        if the caller provides a Note parameter with no title
      </li>
      <li> DATA_REQUIRED "Note.content" -
        if the caller provides a Note parameter with no content
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.note" -
        if no guid or note provided
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - parameters
    """
    self.send_emailNote(authenticationToken, parameters)
    self.recv_emailNote()

  def send_emailNote(self, authenticationToken, parameters):
    self._oprot.writeMessageBegin('emailNote', TMessageType.CALL, self._seqid)
    args = emailNote_args()
    args.authenticationToken = authenticationToken
    args.parameters = parameters
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_emailNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = emailNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    return

  def shareNote(self, authenticationToken, guid):
    """
    If this note is not already shared (via its own direct URL), then this
    will start sharing that note.
    This will return the secret "Note Key" for this note that
    can currently be used in conjunction with the Note's GUID to gain direct
    read-only access to the Note.
    If the note is already shared, then this won't make any changes to the
    note, and the existing "Note Key" will be returned.  The only way to change
    the Note Key for an existing note is to stopSharingNote first, and then
    call this function.
    
    @param guid
      The GUID of the note to be shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_shareNote(authenticationToken, guid)
    return self.recv_shareNote()

  def send_shareNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('shareNote', TMessageType.CALL, self._seqid)
    args = shareNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shareNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = shareNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "shareNote failed: unknown result");

  def stopSharingNote(self, authenticationToken, guid):
    """
    If this note is not already shared then this will stop sharing that note
    and invalidate its "Note Key", so any existing URLs to access that Note
    will stop working.
    If the Note is not shared, then this function will do nothing.
    
    @param guid
      The GUID of the note to be un-shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_stopSharingNote(authenticationToken, guid)
    self.recv_stopSharingNote()

  def send_stopSharingNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('stopSharingNote', TMessageType.CALL, self._seqid)
    args = stopSharingNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopSharingNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopSharingNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    return

  def authenticateToSharedNote(self, guid, noteKey, authenticationToken):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a single Note which was individually shared
    from someone's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve the Note and its directly-referenced children.
    
    @param guid
      The GUID identifying this Note on this shard.
    
    @param noteKey
      The 'noteKey' identifier from the Note that was originally created via
      a call to shareNote() and then given to a recipient to access.
    
    @param authenticationToken
      An optional authenticationToken that identifies the user accessing the
      shared note. This parameter may be required to access some shared notes.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
        shared, or the noteKey doesn't match the current key for this note
      </li>
      <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
        required to access this Note, but either no authentication token or a
        "non-owner" authentication token was provided.
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "guid" - the note with that GUID is not found
      </li>
    </ul>
    
    @throws EDAMSystemException <ul>
      <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
        all requesters).
      </li>
      <li> TAKEN_DOWN "Country" - The specified shared note is taken down
        for the requester because of an IP-based country lookup.
      </ul>
    </ul>
    
    Parameters:
     - guid
     - noteKey
     - authenticationToken
    """
    self.send_authenticateToSharedNote(guid, noteKey, authenticationToken)
    return self.recv_authenticateToSharedNote()

  def send_authenticateToSharedNote(self, guid, noteKey, authenticationToken):
    self._oprot.writeMessageBegin('authenticateToSharedNote', TMessageType.CALL, self._seqid)
    args = authenticateToSharedNote_args()
    args.guid = guid
    args.noteKey = noteKey
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticateToSharedNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticateToSharedNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToSharedNote failed: unknown result");

  def findRelated(self, authenticationToken, query, resultSpec):
    """
    Identify related entities on the service, such as notes,
    notebooks, and tags related to notes or content.
    
    @param query
      The information about which we are finding related entities.
    
    @param resultSpec
      Allows the client to indicate the type and quantity of
      information to be returned, allowing a saving of time and
      bandwidth.
    
    @return
      The result of the query, with information considered
      to likely be relevantly related to the information
      described by the query.
    
    @throws EDAMUserException <ul>
      <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
        a zero-length plain text value.
      </li>
      <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
        invalid Note GUID, that is, one that does not match the constraints
        defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
      <li>PERMISSION_DENIED "Note" - If the caller does not have access to
        the note identified by RelatedQuery.noteGuid.
      </li>
      <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
        in the result spec.
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li>"RelatedQuery.noteGuid" - the note with that GUID is not
        found, if that field has been set in the query.
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - query
     - resultSpec
    """
    self.send_findRelated(authenticationToken, query, resultSpec)
    return self.recv_findRelated()

  def send_findRelated(self, authenticationToken, query, resultSpec):
    self._oprot.writeMessageBegin('findRelated', TMessageType.CALL, self._seqid)
    args = findRelated_args()
    args.authenticationToken = authenticationToken
    args.query = query
    args.resultSpec = resultSpec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findRelated(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findRelated_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findRelated failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getSyncState"] = Processor.process_getSyncState
    self._processMap["getSyncStateWithMetrics"] = Processor.process_getSyncStateWithMetrics
    self._processMap["getSyncChunk"] = Processor.process_getSyncChunk
    self._processMap["getFilteredSyncChunk"] = Processor.process_getFilteredSyncChunk
    self._processMap["getLinkedNotebookSyncState"] = Processor.process_getLinkedNotebookSyncState
    self._processMap["getLinkedNotebookSyncChunk"] = Processor.process_getLinkedNotebookSyncChunk
    self._processMap["listNotebooks"] = Processor.process_listNotebooks
    self._processMap["getNotebook"] = Processor.process_getNotebook
    self._processMap["getDefaultNotebook"] = Processor.process_getDefaultNotebook
    self._processMap["createNotebook"] = Processor.process_createNotebook
    self._processMap["updateNotebook"] = Processor.process_updateNotebook
    self._processMap["expungeNotebook"] = Processor.process_expungeNotebook
    self._processMap["listTags"] = Processor.process_listTags
    self._processMap["listTagsByNotebook"] = Processor.process_listTagsByNotebook
    self._processMap["getTag"] = Processor.process_getTag
    self._processMap["createTag"] = Processor.process_createTag
    self._processMap["updateTag"] = Processor.process_updateTag
    self._processMap["untagAll"] = Processor.process_untagAll
    self._processMap["expungeTag"] = Processor.process_expungeTag
    self._processMap["listSearches"] = Processor.process_listSearches
    self._processMap["getSearch"] = Processor.process_getSearch
    self._processMap["createSearch"] = Processor.process_createSearch
    self._processMap["updateSearch"] = Processor.process_updateSearch
    self._processMap["expungeSearch"] = Processor.process_expungeSearch
    self._processMap["findNotes"] = Processor.process_findNotes
    self._processMap["findNoteOffset"] = Processor.process_findNoteOffset
    self._processMap["findNotesMetadata"] = Processor.process_findNotesMetadata
    self._processMap["findNoteCounts"] = Processor.process_findNoteCounts
    self._processMap["getNote"] = Processor.process_getNote
    self._processMap["getNoteApplicationData"] = Processor.process_getNoteApplicationData
    self._processMap["getNoteApplicationDataEntry"] = Processor.process_getNoteApplicationDataEntry
    self._processMap["setNoteApplicationDataEntry"] = Processor.process_setNoteApplicationDataEntry
    self._processMap["unsetNoteApplicationDataEntry"] = Processor.process_unsetNoteApplicationDataEntry
    self._processMap["getNoteContent"] = Processor.process_getNoteContent
    self._processMap["getNoteSearchText"] = Processor.process_getNoteSearchText
    self._processMap["getResourceSearchText"] = Processor.process_getResourceSearchText
    self._processMap["getNoteTagNames"] = Processor.process_getNoteTagNames
    self._processMap["createNote"] = Processor.process_createNote
    self._processMap["updateNote"] = Processor.process_updateNote
    self._processMap["deleteNote"] = Processor.process_deleteNote
    self._processMap["expungeNote"] = Processor.process_expungeNote
    self._processMap["expungeNotes"] = Processor.process_expungeNotes
    self._processMap["expungeInactiveNotes"] = Processor.process_expungeInactiveNotes
    self._processMap["copyNote"] = Processor.process_copyNote
    self._processMap["listNoteVersions"] = Processor.process_listNoteVersions
    self._processMap["getNoteVersion"] = Processor.process_getNoteVersion
    self._processMap["getResource"] = Processor.process_getResource
    self._processMap["getResourceApplicationData"] = Processor.process_getResourceApplicationData
    self._processMap["getResourceApplicationDataEntry"] = Processor.process_getResourceApplicationDataEntry
    self._processMap["setResourceApplicationDataEntry"] = Processor.process_setResourceApplicationDataEntry
    self._processMap["unsetResourceApplicationDataEntry"] = Processor.process_unsetResourceApplicationDataEntry
    self._processMap["updateResource"] = Processor.process_updateResource
    self._processMap["getResourceData"] = Processor.process_getResourceData
    self._processMap["getResourceByHash"] = Processor.process_getResourceByHash
    self._processMap["getResourceRecognition"] = Processor.process_getResourceRecognition
    self._processMap["getResourceAlternateData"] = Processor.process_getResourceAlternateData
    self._processMap["getResourceAttributes"] = Processor.process_getResourceAttributes
    self._processMap["getPublicNotebook"] = Processor.process_getPublicNotebook
    self._processMap["createSharedNotebook"] = Processor.process_createSharedNotebook
    self._processMap["updateSharedNotebook"] = Processor.process_updateSharedNotebook
    self._processMap["setSharedNotebookRecipientSettings"] = Processor.process_setSharedNotebookRecipientSettings
    self._processMap["sendMessageToSharedNotebookMembers"] = Processor.process_sendMessageToSharedNotebookMembers
    self._processMap["listSharedNotebooks"] = Processor.process_listSharedNotebooks
    self._processMap["expungeSharedNotebooks"] = Processor.process_expungeSharedNotebooks
    self._processMap["createLinkedNotebook"] = Processor.process_createLinkedNotebook
    self._processMap["updateLinkedNotebook"] = Processor.process_updateLinkedNotebook
    self._processMap["listLinkedNotebooks"] = Processor.process_listLinkedNotebooks
    self._processMap["expungeLinkedNotebook"] = Processor.process_expungeLinkedNotebook
    self._processMap["authenticateToSharedNotebook"] = Processor.process_authenticateToSharedNotebook
    self._processMap["getSharedNotebookByAuth"] = Processor.process_getSharedNotebookByAuth
    self._processMap["emailNote"] = Processor.process_emailNote
    self._processMap["shareNote"] = Processor.process_shareNote
    self._processMap["stopSharingNote"] = Processor.process_stopSharingNote
    self._processMap["authenticateToSharedNote"] = Processor.process_authenticateToSharedNote
    self._processMap["findRelated"] = Processor.process_findRelated

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getSyncState(self, seqid, iprot, oprot):
    args = getSyncState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSyncState_result()
    try:
      result.success = self._handler.getSyncState(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSyncState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSyncStateWithMetrics(self, seqid, iprot, oprot):
    args = getSyncStateWithMetrics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSyncStateWithMetrics_result()
    try:
      result.success = self._handler.getSyncStateWithMetrics(args.authenticationToken, args.clientMetrics)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSyncStateWithMetrics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSyncChunk(self, seqid, iprot, oprot):
    args = getSyncChunk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSyncChunk_result()
    try:
      result.success = self._handler.getSyncChunk(args.authenticationToken, args.afterUSN, args.maxEntries, args.fullSyncOnly)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSyncChunk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFilteredSyncChunk(self, seqid, iprot, oprot):
    args = getFilteredSyncChunk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFilteredSyncChunk_result()
    try:
      result.success = self._handler.getFilteredSyncChunk(args.authenticationToken, args.afterUSN, args.maxEntries, args.filter)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getFilteredSyncChunk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLinkedNotebookSyncState(self, seqid, iprot, oprot):
    args = getLinkedNotebookSyncState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLinkedNotebookSyncState_result()
    try:
      result.success = self._handler.getLinkedNotebookSyncState(args.authenticationToken, args.linkedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getLinkedNotebookSyncState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLinkedNotebookSyncChunk(self, seqid, iprot, oprot):
    args = getLinkedNotebookSyncChunk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLinkedNotebookSyncChunk_result()
    try:
      result.success = self._handler.getLinkedNotebookSyncChunk(args.authenticationToken, args.linkedNotebook, args.afterUSN, args.maxEntries, args.fullSyncOnly)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getLinkedNotebookSyncChunk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNotebooks(self, seqid, iprot, oprot):
    args = listNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNotebooks_result()
    try:
      result.success = self._handler.listNotebooks(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNotebook(self, seqid, iprot, oprot):
    args = getNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNotebook_result()
    try:
      result.success = self._handler.getNotebook(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDefaultNotebook(self, seqid, iprot, oprot):
    args = getDefaultNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDefaultNotebook_result()
    try:
      result.success = self._handler.getDefaultNotebook(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getDefaultNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createNotebook(self, seqid, iprot, oprot):
    args = createNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createNotebook_result()
    try:
      result.success = self._handler.createNotebook(args.authenticationToken, args.notebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateNotebook(self, seqid, iprot, oprot):
    args = updateNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateNotebook_result()
    try:
      result.success = self._handler.updateNotebook(args.authenticationToken, args.notebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeNotebook(self, seqid, iprot, oprot):
    args = expungeNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeNotebook_result()
    try:
      result.success = self._handler.expungeNotebook(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listTags(self, seqid, iprot, oprot):
    args = listTags_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTags_result()
    try:
      result.success = self._handler.listTags(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listTags", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listTagsByNotebook(self, seqid, iprot, oprot):
    args = listTagsByNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTagsByNotebook_result()
    try:
      result.success = self._handler.listTagsByNotebook(args.authenticationToken, args.notebookGuid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("listTagsByNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTag(self, seqid, iprot, oprot):
    args = getTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTag_result()
    try:
      result.success = self._handler.getTag(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createTag(self, seqid, iprot, oprot):
    args = createTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createTag_result()
    try:
      result.success = self._handler.createTag(args.authenticationToken, args.tag)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("createTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateTag(self, seqid, iprot, oprot):
    args = updateTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateTag_result()
    try:
      result.success = self._handler.updateTag(args.authenticationToken, args.tag)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_untagAll(self, seqid, iprot, oprot):
    args = untagAll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = untagAll_result()
    try:
      self._handler.untagAll(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("untagAll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeTag(self, seqid, iprot, oprot):
    args = expungeTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeTag_result()
    try:
      result.success = self._handler.expungeTag(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSearches(self, seqid, iprot, oprot):
    args = listSearches_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSearches_result()
    try:
      result.success = self._handler.listSearches(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listSearches", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSearch(self, seqid, iprot, oprot):
    args = getSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSearch_result()
    try:
      result.success = self._handler.getSearch(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createSearch(self, seqid, iprot, oprot):
    args = createSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createSearch_result()
    try:
      result.success = self._handler.createSearch(args.authenticationToken, args.search)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateSearch(self, seqid, iprot, oprot):
    args = updateSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateSearch_result()
    try:
      result.success = self._handler.updateSearch(args.authenticationToken, args.search)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeSearch(self, seqid, iprot, oprot):
    args = expungeSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeSearch_result()
    try:
      result.success = self._handler.expungeSearch(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNotes(self, seqid, iprot, oprot):
    args = findNotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNotes_result()
    try:
      result.success = self._handler.findNotes(args.authenticationToken, args.filter, args.offset, args.maxNotes)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNoteOffset(self, seqid, iprot, oprot):
    args = findNoteOffset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNoteOffset_result()
    try:
      result.success = self._handler.findNoteOffset(args.authenticationToken, args.filter, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNoteOffset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNotesMetadata(self, seqid, iprot, oprot):
    args = findNotesMetadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNotesMetadata_result()
    try:
      result.success = self._handler.findNotesMetadata(args.authenticationToken, args.filter, args.offset, args.maxNotes, args.resultSpec)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNotesMetadata", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNoteCounts(self, seqid, iprot, oprot):
    args = findNoteCounts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNoteCounts_result()
    try:
      result.success = self._handler.findNoteCounts(args.authenticationToken, args.filter, args.withTrash)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNoteCounts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNote(self, seqid, iprot, oprot):
    args = getNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNote_result()
    try:
      result.success = self._handler.getNote(args.authenticationToken, args.guid, args.withContent, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteApplicationData(self, seqid, iprot, oprot):
    args = getNoteApplicationData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteApplicationData_result()
    try:
      result.success = self._handler.getNoteApplicationData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteApplicationData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteApplicationDataEntry(self, seqid, iprot, oprot):
    args = getNoteApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteApplicationDataEntry_result()
    try:
      result.success = self._handler.getNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setNoteApplicationDataEntry(self, seqid, iprot, oprot):
    args = setNoteApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setNoteApplicationDataEntry_result()
    try:
      result.success = self._handler.setNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("setNoteApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unsetNoteApplicationDataEntry(self, seqid, iprot, oprot):
    args = unsetNoteApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unsetNoteApplicationDataEntry_result()
    try:
      result.success = self._handler.unsetNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("unsetNoteApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteContent(self, seqid, iprot, oprot):
    args = getNoteContent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteContent_result()
    try:
      result.success = self._handler.getNoteContent(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteContent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteSearchText(self, seqid, iprot, oprot):
    args = getNoteSearchText_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteSearchText_result()
    try:
      result.success = self._handler.getNoteSearchText(args.authenticationToken, args.guid, args.noteOnly, args.tokenizeForIndexing)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteSearchText", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceSearchText(self, seqid, iprot, oprot):
    args = getResourceSearchText_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceSearchText_result()
    try:
      result.success = self._handler.getResourceSearchText(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceSearchText", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteTagNames(self, seqid, iprot, oprot):
    args = getNoteTagNames_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteTagNames_result()
    try:
      result.success = self._handler.getNoteTagNames(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteTagNames", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createNote(self, seqid, iprot, oprot):
    args = createNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createNote_result()
    try:
      result.success = self._handler.createNote(args.authenticationToken, args.note)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("createNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateNote(self, seqid, iprot, oprot):
    args = updateNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateNote_result()
    try:
      result.success = self._handler.updateNote(args.authenticationToken, args.note)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteNote(self, seqid, iprot, oprot):
    args = deleteNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteNote_result()
    try:
      result.success = self._handler.deleteNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("deleteNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeNote(self, seqid, iprot, oprot):
    args = expungeNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeNote_result()
    try:
      result.success = self._handler.expungeNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeNotes(self, seqid, iprot, oprot):
    args = expungeNotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeNotes_result()
    try:
      result.success = self._handler.expungeNotes(args.authenticationToken, args.noteGuids)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeNotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeInactiveNotes(self, seqid, iprot, oprot):
    args = expungeInactiveNotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeInactiveNotes_result()
    try:
      result.success = self._handler.expungeInactiveNotes(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("expungeInactiveNotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_copyNote(self, seqid, iprot, oprot):
    args = copyNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = copyNote_result()
    try:
      result.success = self._handler.copyNote(args.authenticationToken, args.noteGuid, args.toNotebookGuid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("copyNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNoteVersions(self, seqid, iprot, oprot):
    args = listNoteVersions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNoteVersions_result()
    try:
      result.success = self._handler.listNoteVersions(args.authenticationToken, args.noteGuid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("listNoteVersions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteVersion(self, seqid, iprot, oprot):
    args = getNoteVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteVersion_result()
    try:
      result.success = self._handler.getNoteVersion(args.authenticationToken, args.noteGuid, args.updateSequenceNum, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResource(self, seqid, iprot, oprot):
    args = getResource_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResource_result()
    try:
      result.success = self._handler.getResource(args.authenticationToken, args.guid, args.withData, args.withRecognition, args.withAttributes, args.withAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResource", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceApplicationData(self, seqid, iprot, oprot):
    args = getResourceApplicationData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceApplicationData_result()
    try:
      result.success = self._handler.getResourceApplicationData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceApplicationData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceApplicationDataEntry(self, seqid, iprot, oprot):
    args = getResourceApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceApplicationDataEntry_result()
    try:
      result.success = self._handler.getResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setResourceApplicationDataEntry(self, seqid, iprot, oprot):
    args = setResourceApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setResourceApplicationDataEntry_result()
    try:
      result.success = self._handler.setResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("setResourceApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unsetResourceApplicationDataEntry(self, seqid, iprot, oprot):
    args = unsetResourceApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unsetResourceApplicationDataEntry_result()
    try:
      result.success = self._handler.unsetResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("unsetResourceApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateResource(self, seqid, iprot, oprot):
    args = updateResource_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateResource_result()
    try:
      result.success = self._handler.updateResource(args.authenticationToken, args.resource)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateResource", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceData(self, seqid, iprot, oprot):
    args = getResourceData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceData_result()
    try:
      result.success = self._handler.getResourceData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceByHash(self, seqid, iprot, oprot):
    args = getResourceByHash_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceByHash_result()
    try:
      result.success = self._handler.getResourceByHash(args.authenticationToken, args.noteGuid, args.contentHash, args.withData, args.withRecognition, args.withAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceByHash", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceRecognition(self, seqid, iprot, oprot):
    args = getResourceRecognition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceRecognition_result()
    try:
      result.success = self._handler.getResourceRecognition(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceRecognition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceAlternateData(self, seqid, iprot, oprot):
    args = getResourceAlternateData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceAlternateData_result()
    try:
      result.success = self._handler.getResourceAlternateData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceAlternateData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceAttributes(self, seqid, iprot, oprot):
    args = getResourceAttributes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceAttributes_result()
    try:
      result.success = self._handler.getResourceAttributes(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceAttributes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPublicNotebook(self, seqid, iprot, oprot):
    args = getPublicNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPublicNotebook_result()
    try:
      result.success = self._handler.getPublicNotebook(args.userId, args.publicUri)
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getPublicNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createSharedNotebook(self, seqid, iprot, oprot):
    args = createSharedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createSharedNotebook_result()
    try:
      result.success = self._handler.createSharedNotebook(args.authenticationToken, args.sharedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createSharedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateSharedNotebook(self, seqid, iprot, oprot):
    args = updateSharedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateSharedNotebook_result()
    try:
      result.success = self._handler.updateSharedNotebook(args.authenticationToken, args.sharedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("updateSharedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setSharedNotebookRecipientSettings(self, seqid, iprot, oprot):
    args = setSharedNotebookRecipientSettings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setSharedNotebookRecipientSettings_result()
    try:
      result.success = self._handler.setSharedNotebookRecipientSettings(args.authenticationToken, args.sharedNotebookId, args.recipientSettings)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("setSharedNotebookRecipientSettings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendMessageToSharedNotebookMembers(self, seqid, iprot, oprot):
    args = sendMessageToSharedNotebookMembers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendMessageToSharedNotebookMembers_result()
    try:
      result.success = self._handler.sendMessageToSharedNotebookMembers(args.authenticationToken, args.notebookGuid, args.messageText, args.recipients)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("sendMessageToSharedNotebookMembers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSharedNotebooks(self, seqid, iprot, oprot):
    args = listSharedNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSharedNotebooks_result()
    try:
      result.success = self._handler.listSharedNotebooks(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listSharedNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeSharedNotebooks(self, seqid, iprot, oprot):
    args = expungeSharedNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeSharedNotebooks_result()
    try:
      result.success = self._handler.expungeSharedNotebooks(args.authenticationToken, args.sharedNotebookIds)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("expungeSharedNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createLinkedNotebook(self, seqid, iprot, oprot):
    args = createLinkedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createLinkedNotebook_result()
    try:
      result.success = self._handler.createLinkedNotebook(args.authenticationToken, args.linkedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createLinkedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateLinkedNotebook(self, seqid, iprot, oprot):
    args = updateLinkedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateLinkedNotebook_result()
    try:
      result.success = self._handler.updateLinkedNotebook(args.authenticationToken, args.linkedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("updateLinkedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listLinkedNotebooks(self, seqid, iprot, oprot):
    args = listLinkedNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listLinkedNotebooks_result()
    try:
      result.success = self._handler.listLinkedNotebooks(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listLinkedNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeLinkedNotebook(self, seqid, iprot, oprot):
    args = expungeLinkedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeLinkedNotebook_result()
    try:
      result.success = self._handler.expungeLinkedNotebook(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("expungeLinkedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticateToSharedNotebook(self, seqid, iprot, oprot):
    args = authenticateToSharedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateToSharedNotebook_result()
    try:
      result.success = self._handler.authenticateToSharedNotebook(args.shareKey, args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticateToSharedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSharedNotebookByAuth(self, seqid, iprot, oprot):
    args = getSharedNotebookByAuth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSharedNotebookByAuth_result()
    try:
      result.success = self._handler.getSharedNotebookByAuth(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSharedNotebookByAuth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_emailNote(self, seqid, iprot, oprot):
    args = emailNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = emailNote_result()
    try:
      self._handler.emailNote(args.authenticationToken, args.parameters)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("emailNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shareNote(self, seqid, iprot, oprot):
    args = shareNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shareNote_result()
    try:
      result.success = self._handler.shareNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("shareNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopSharingNote(self, seqid, iprot, oprot):
    args = stopSharingNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopSharingNote_result()
    try:
      self._handler.stopSharingNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("stopSharingNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticateToSharedNote(self, seqid, iprot, oprot):
    args = authenticateToSharedNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateToSharedNote_result()
    try:
      result.success = self._handler.authenticateToSharedNote(args.guid, args.noteKey, args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticateToSharedNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findRelated(self, seqid, iprot, oprot):
    args = findRelated_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findRelated_result()
    try:
      result.success = self._handler.findRelated(args.authenticationToken, args.query, args.resultSpec)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findRelated", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getSyncState_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncState_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncState_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncState, SyncState.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncStateWithMetrics_args(object):
  """
  Attributes:
   - authenticationToken
   - clientMetrics
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'clientMetrics', (ClientUsageMetrics, ClientUsageMetrics.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, clientMetrics=None,):
    self.authenticationToken = authenticationToken
    self.clientMetrics = clientMetrics

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.clientMetrics = ClientUsageMetrics()
          self.clientMetrics.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncStateWithMetrics_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.clientMetrics is not None:
      oprot.writeFieldBegin('clientMetrics', TType.STRUCT, 2)
      self.clientMetrics.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncStateWithMetrics_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncState, SyncState.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncStateWithMetrics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncChunk_args(object):
  """
  Attributes:
   - authenticationToken
   - afterUSN
   - maxEntries
   - fullSyncOnly
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.I32, 'afterUSN', None, None, ), # 2
    (3, TType.I32, 'maxEntries', None, None, ), # 3
    (4, TType.BOOL, 'fullSyncOnly', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, afterUSN=None, maxEntries=None, fullSyncOnly=None,):
    self.authenticationToken = authenticationToken
    self.afterUSN = afterUSN
    self.maxEntries = maxEntries
    self.fullSyncOnly = fullSyncOnly

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.afterUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxEntries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.fullSyncOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncChunk_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.afterUSN is not None:
      oprot.writeFieldBegin('afterUSN', TType.I32, 2)
      oprot.writeI32(self.afterUSN)
      oprot.writeFieldEnd()
    if self.maxEntries is not None:
      oprot.writeFieldBegin('maxEntries', TType.I32, 3)
      oprot.writeI32(self.maxEntries)
      oprot.writeFieldEnd()
    if self.fullSyncOnly is not None:
      oprot.writeFieldBegin('fullSyncOnly', TType.BOOL, 4)
      oprot.writeBool(self.fullSyncOnly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncChunk_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncChunk, SyncChunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncChunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncChunk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFilteredSyncChunk_args(object):
  """
  Attributes:
   - authenticationToken
   - afterUSN
   - maxEntries
   - filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.I32, 'afterUSN', None, None, ), # 2
    (3, TType.I32, 'maxEntries', None, None, ), # 3
    (4, TType.STRUCT, 'filter', (SyncChunkFilter, SyncChunkFilter.thrift_spec), None, ), # 4
  )

  def __init__(self, authenticationToken=None, afterUSN=None, maxEntries=None, filter=None,):
    self.authenticationToken = authenticationToken
    self.afterUSN = afterUSN
    self.maxEntries = maxEntries
    self.filter = filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.afterUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxEntries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.filter = SyncChunkFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFilteredSyncChunk_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.afterUSN is not None:
      oprot.writeFieldBegin('afterUSN', TType.I32, 2)
      oprot.writeI32(self.afterUSN)
      oprot.writeFieldEnd()
    if self.maxEntries is not None:
      oprot.writeFieldBegin('maxEntries', TType.I32, 3)
      oprot.writeI32(self.maxEntries)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 4)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFilteredSyncChunk_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncChunk, SyncChunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncChunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFilteredSyncChunk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncState_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncState_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncState_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncState, SyncState.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncChunk_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
   - afterUSN
   - maxEntries
   - fullSyncOnly
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
    (3, TType.I32, 'afterUSN', None, None, ), # 3
    (4, TType.I32, 'maxEntries', None, None, ), # 4
    (5, TType.BOOL, 'fullSyncOnly', None, None, ), # 5
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None, afterUSN=None, maxEntries=None, fullSyncOnly=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook
    self.afterUSN = afterUSN
    self.maxEntries = maxEntries
    self.fullSyncOnly = fullSyncOnly

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.afterUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxEntries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.fullSyncOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncChunk_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    if self.afterUSN is not None:
      oprot.writeFieldBegin('afterUSN', TType.I32, 3)
      oprot.writeI32(self.afterUSN)
      oprot.writeFieldEnd()
    if self.maxEntries is not None:
      oprot.writeFieldBegin('maxEntries', TType.I32, 4)
      oprot.writeI32(self.maxEntries)
      oprot.writeFieldEnd()
    if self.fullSyncOnly is not None:
      oprot.writeFieldBegin('fullSyncOnly', TType.BOOL, 5)
      oprot.writeBool(self.fullSyncOnly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncChunk_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncChunk, SyncChunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncChunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncChunk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype196, _size193) = iprot.readListBegin()
          for _i197 in xrange(_size193):
            _elem198 = evernote.edam.type.ttypes.Notebook()
            _elem198.read(iprot)
            self.success.append(_elem198)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter199 in self.success:
        iter199.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDefaultNotebook_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDefaultNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDefaultNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDefaultNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - notebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'notebook', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, notebook=None,):
    self.authenticationToken = authenticationToken
    self.notebook = notebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notebook = evernote.edam.type.ttypes.Notebook()
          self.notebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebook is not None:
      oprot.writeFieldBegin('notebook', TType.STRUCT, 2)
      self.notebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - notebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'notebook', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, notebook=None,):
    self.authenticationToken = authenticationToken
    self.notebook = notebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notebook = evernote.edam.type.ttypes.Notebook()
          self.notebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebook is not None:
      oprot.writeFieldBegin('notebook', TType.STRUCT, 2)
      self.notebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTags_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTags_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTags_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype203, _size200) = iprot.readListBegin()
          for _i204 in xrange(_size200):
            _elem205 = evernote.edam.type.ttypes.Tag()
            _elem205.read(iprot)
            self.success.append(_elem205)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTags_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter206 in self.success:
        iter206.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTagsByNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - notebookGuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'notebookGuid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, notebookGuid=None,):
    self.authenticationToken = authenticationToken
    self.notebookGuid = notebookGuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTagsByNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTagsByNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype210, _size207) = iprot.readListBegin()
          for _i211 in xrange(_size207):
            _elem212 = evernote.edam.type.ttypes.Tag()
            _elem212.read(iprot)
            self.success.append(_elem212)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTagsByNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter213 in self.success:
        iter213.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTag_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Tag()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTag_args(object):
  """
  Attributes:
   - authenticationToken
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'tag', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, tag=None,):
    self.authenticationToken = authenticationToken
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tag = evernote.edam.type.ttypes.Tag()
          self.tag.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRUCT, 2)
      self.tag.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Tag()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateTag_args(object):
  """
  Attributes:
   - authenticationToken
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'tag', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, tag=None,):
    self.authenticationToken = authenticationToken
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tag = evernote.edam.type.ttypes.Tag()
          self.tag.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRUCT, 2)
      self.tag.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class untagAll_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('untagAll_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class untagAll_result(object):
  """
  Attributes:
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, userException=None, systemException=None, notFoundException=None,):
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('untagAll_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeTag_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSearches_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSearches_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSearches_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype217, _size214) = iprot.readListBegin()
          for _i218 in xrange(_size214):
            _elem219 = evernote.edam.type.ttypes.SavedSearch()
            _elem219.read(iprot)
            self.success.append(_elem219)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSearches_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter220 in self.success:
        iter220.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SavedSearch()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - search
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'search', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, search=None,):
    self.authenticationToken = authenticationToken
    self.search = search

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.search = evernote.edam.type.ttypes.SavedSearch()
          self.search.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.search is not None:
      oprot.writeFieldBegin('search', TType.STRUCT, 2)
      self.search.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SavedSearch()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - search
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'search', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, search=None,):
    self.authenticationToken = authenticationToken
    self.search = search

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.search = evernote.edam.type.ttypes.SavedSearch()
          self.search.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.search is not None:
      oprot.writeFieldBegin('search', TType.STRUCT, 2)
      self.search.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotes_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - offset
   - maxNotes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.I32, 'maxNotes', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, filter=None, offset=None, maxNotes=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.offset = offset
    self.maxNotes = maxNotes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.maxNotes is not None:
      oprot.writeFieldBegin('maxNotes', TType.I32, 4)
      oprot.writeI32(self.maxNotes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NoteList, NoteList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NoteList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteOffset_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.STRING, 'guid', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, filter=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteOffset_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 3)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteOffset_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteOffset_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotesMetadata_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - offset
   - maxNotes
   - resultSpec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.I32, 'maxNotes', None, None, ), # 4
    (5, TType.STRUCT, 'resultSpec', (NotesMetadataResultSpec, NotesMetadataResultSpec.thrift_spec), None, ), # 5
  )

  def __init__(self, authenticationToken=None, filter=None, offset=None, maxNotes=None, resultSpec=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.offset = offset
    self.maxNotes = maxNotes
    self.resultSpec = resultSpec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.resultSpec = NotesMetadataResultSpec()
          self.resultSpec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotesMetadata_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.maxNotes is not None:
      oprot.writeFieldBegin('maxNotes', TType.I32, 4)
      oprot.writeI32(self.maxNotes)
      oprot.writeFieldEnd()
    if self.resultSpec is not None:
      oprot.writeFieldBegin('resultSpec', TType.STRUCT, 5)
      self.resultSpec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotesMetadata_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NotesMetadataList, NotesMetadataList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NotesMetadataList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotesMetadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteCounts_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - withTrash
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'withTrash', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, filter=None, withTrash=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.withTrash = withTrash

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.withTrash = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteCounts_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.withTrash is not None:
      oprot.writeFieldBegin('withTrash', TType.BOOL, 3)
      oprot.writeBool(self.withTrash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteCounts_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NoteCollectionCounts, NoteCollectionCounts.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NoteCollectionCounts()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteCounts_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - withContent
   - withResourcesData
   - withResourcesRecognition
   - withResourcesAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.BOOL, 'withContent', None, None, ), # 3
    (4, TType.BOOL, 'withResourcesData', None, None, ), # 4
    (5, TType.BOOL, 'withResourcesRecognition', None, None, ), # 5
    (6, TType.BOOL, 'withResourcesAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, guid=None, withContent=None, withResourcesData=None, withResourcesRecognition=None, withResourcesAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.withContent = withContent
    self.withResourcesData = withResourcesData
    self.withResourcesRecognition = withResourcesRecognition
    self.withResourcesAlternateData = withResourcesAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.withContent = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withResourcesData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withResourcesRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withResourcesAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.withContent is not None:
      oprot.writeFieldBegin('withContent', TType.BOOL, 3)
      oprot.writeBool(self.withContent)
      oprot.writeFieldEnd()
    if self.withResourcesData is not None:
      oprot.writeFieldBegin('withResourcesData', TType.BOOL, 4)
      oprot.writeBool(self.withResourcesData)
      oprot.writeFieldEnd()
    if self.withResourcesRecognition is not None:
      oprot.writeFieldBegin('withResourcesRecognition', TType.BOOL, 5)
      oprot.writeBool(self.withResourcesRecognition)
      oprot.writeFieldEnd()
    if self.withResourcesAlternateData is not None:
      oprot.writeFieldBegin('withResourcesAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withResourcesAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.LazyMap, evernote.edam.type.ttypes.LazyMap.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.LazyMap()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setNoteApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
    (4, TType.STRING, 'value', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, guid=None, key=None, value=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setNoteApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setNoteApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setNoteApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetNoteApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetNoteApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetNoteApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetNoteApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteContent_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteContent_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteContent_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteContent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteSearchText_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - noteOnly
   - tokenizeForIndexing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.BOOL, 'noteOnly', None, None, ), # 3
    (4, TType.BOOL, 'tokenizeForIndexing', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, guid=None, noteOnly=None, tokenizeForIndexing=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.noteOnly = noteOnly
    self.tokenizeForIndexing = tokenizeForIndexing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.noteOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.tokenizeForIndexing = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteSearchText_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.noteOnly is not None:
      oprot.writeFieldBegin('noteOnly', TType.BOOL, 3)
      oprot.writeBool(self.noteOnly)
      oprot.writeFieldEnd()
    if self.tokenizeForIndexing is not None:
      oprot.writeFieldBegin('tokenizeForIndexing', TType.BOOL, 4)
      oprot.writeBool(self.tokenizeForIndexing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteSearchText_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteSearchText_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceSearchText_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceSearchText_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceSearchText_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceSearchText_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteTagNames_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteTagNames_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteTagNames_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype224, _size221) = iprot.readListBegin()
          for _i225 in xrange(_size221):
            _elem226 = iprot.readString();
            self.success.append(_elem226)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteTagNames_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter227 in self.success:
        oprot.writeString(iter227)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNote_args(object):
  """
  Attributes:
   - authenticationToken
   - note
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, note=None,):
    self.authenticationToken = authenticationToken
    self.note = note

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNote_args(object):
  """
  Attributes:
   - authenticationToken
   - note
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, note=None,):
    self.authenticationToken = authenticationToken
    self.note = note

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotes_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuids
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.LIST, 'noteGuids', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, authenticationToken=None, noteGuids=None,):
    self.authenticationToken = authenticationToken
    self.noteGuids = noteGuids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.noteGuids = []
          (_etype231, _size228) = iprot.readListBegin()
          for _i232 in xrange(_size228):
            _elem233 = iprot.readString();
            self.noteGuids.append(_elem233)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuids is not None:
      oprot.writeFieldBegin('noteGuids', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.noteGuids))
      for iter234 in self.noteGuids:
        oprot.writeString(iter234)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeInactiveNotes_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeInactiveNotes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeInactiveNotes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeInactiveNotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class copyNote_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
   - toNotebookGuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.STRING, 'toNotebookGuid', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, noteGuid=None, toNotebookGuid=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid
    self.toNotebookGuid = toNotebookGuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.toNotebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('copyNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.toNotebookGuid is not None:
      oprot.writeFieldBegin('toNotebookGuid', TType.STRING, 3)
      oprot.writeString(self.toNotebookGuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class copyNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('copyNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNoteVersions_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, noteGuid=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNoteVersions_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNoteVersions_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NoteVersionId, NoteVersionId.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype238, _size235) = iprot.readListBegin()
          for _i239 in xrange(_size235):
            _elem240 = NoteVersionId()
            _elem240.read(iprot)
            self.success.append(_elem240)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNoteVersions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter241 in self.success:
        iter241.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteVersion_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
   - updateSequenceNum
   - withResourcesData
   - withResourcesRecognition
   - withResourcesAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.I32, 'updateSequenceNum', None, None, ), # 3
    (4, TType.BOOL, 'withResourcesData', None, None, ), # 4
    (5, TType.BOOL, 'withResourcesRecognition', None, None, ), # 5
    (6, TType.BOOL, 'withResourcesAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, noteGuid=None, updateSequenceNum=None, withResourcesData=None, withResourcesRecognition=None, withResourcesAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid
    self.updateSequenceNum = updateSequenceNum
    self.withResourcesData = withResourcesData
    self.withResourcesRecognition = withResourcesRecognition
    self.withResourcesAlternateData = withResourcesAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withResourcesData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withResourcesRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withResourcesAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteVersion_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 3)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.withResourcesData is not None:
      oprot.writeFieldBegin('withResourcesData', TType.BOOL, 4)
      oprot.writeBool(self.withResourcesData)
      oprot.writeFieldEnd()
    if self.withResourcesRecognition is not None:
      oprot.writeFieldBegin('withResourcesRecognition', TType.BOOL, 5)
      oprot.writeBool(self.withResourcesRecognition)
      oprot.writeFieldEnd()
    if self.withResourcesAlternateData is not None:
      oprot.writeFieldBegin('withResourcesAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withResourcesAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteVersion_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResource_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - withData
   - withRecognition
   - withAttributes
   - withAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.BOOL, 'withData', None, None, ), # 3
    (4, TType.BOOL, 'withRecognition', None, None, ), # 4
    (5, TType.BOOL, 'withAttributes', None, None, ), # 5
    (6, TType.BOOL, 'withAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, guid=None, withData=None, withRecognition=None, withAttributes=None, withAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.withData = withData
    self.withRecognition = withRecognition
    self.withAttributes = withAttributes
    self.withAlternateData = withAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.withData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResource_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.withData is not None:
      oprot.writeFieldBegin('withData', TType.BOOL, 3)
      oprot.writeBool(self.withData)
      oprot.writeFieldEnd()
    if self.withRecognition is not None:
      oprot.writeFieldBegin('withRecognition', TType.BOOL, 4)
      oprot.writeBool(self.withRecognition)
      oprot.writeFieldEnd()
    if self.withAttributes is not None:
      oprot.writeFieldBegin('withAttributes', TType.BOOL, 5)
      oprot.writeBool(self.withAttributes)
      oprot.writeFieldEnd()
    if self.withAlternateData is not None:
      oprot.writeFieldBegin('withAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResource_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Resource()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResource_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.LazyMap, evernote.edam.type.ttypes.LazyMap.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.LazyMap()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setResourceApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
    (4, TType.STRING, 'value', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, guid=None, key=None, value=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setResourceApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setResourceApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setResourceApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetResourceApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetResourceApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetResourceApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetResourceApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateResource_args(object):
  """
  Attributes:
   - authenticationToken
   - resource
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'resource', (evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, resource=None,):
    self.authenticationToken = authenticationToken
    self.resource = resource

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.resource = evernote.edam.type.ttypes.Resource()
          self.resource.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateResource_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRUCT, 2)
      self.resource.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateResource_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateResource_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceByHash_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
   - contentHash
   - withData
   - withRecognition
   - withAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.STRING, 'contentHash', None, None, ), # 3
    (4, TType.BOOL, 'withData', None, None, ), # 4
    (5, TType.BOOL, 'withRecognition', None, None, ), # 5
    (6, TType.BOOL, 'withAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, noteGuid=None, contentHash=None, withData=None, withRecognition=None, withAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid
    self.contentHash = contentHash
    self.withData = withData
    self.withRecognition = withRecognition
    self.withAlternateData = withAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.contentHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceByHash_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.contentHash is not None:
      oprot.writeFieldBegin('contentHash', TType.STRING, 3)
      oprot.writeString(self.contentHash)
      oprot.writeFieldEnd()
    if self.withData is not None:
      oprot.writeFieldBegin('withData', TType.BOOL, 4)
      oprot.writeBool(self.withData)
      oprot.writeFieldEnd()
    if self.withRecognition is not None:
      oprot.writeFieldBegin('withRecognition', TType.BOOL, 5)
      oprot.writeBool(self.withRecognition)
      oprot.writeFieldEnd()
    if self.withAlternateData is not None:
      oprot.writeFieldBegin('withAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceByHash_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Resource()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceByHash_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceRecognition_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceRecognition_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceRecognition_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceRecognition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAlternateData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAlternateData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAlternateData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAlternateData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAttributes_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAttributes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAttributes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.ResourceAttributes, evernote.edam.type.ttypes.ResourceAttributes.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.ResourceAttributes()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAttributes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicNotebook_args(object):
  """
  Attributes:
   - userId
   - publicUri
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
    (2, TType.STRING, 'publicUri', None, None, ), # 2
  )

  def __init__(self, userId=None, publicUri=None,):
    self.userId = userId
    self.publicUri = publicUri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.publicUri = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicNotebook_args')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.publicUri is not None:
      oprot.writeFieldBegin('publicUri', TType.STRING, 2)
      oprot.writeString(self.publicUri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicNotebook_result(object):
  """
  Attributes:
   - success
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, systemException=None, notFoundException=None,):
    self.success = success
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 1)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSharedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - sharedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'sharedNotebook', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, sharedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.sharedNotebook = sharedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sharedNotebook = evernote.edam.type.ttypes.SharedNotebook()
          self.sharedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSharedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.sharedNotebook is not None:
      oprot.writeFieldBegin('sharedNotebook', TType.STRUCT, 2)
      self.sharedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSharedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SharedNotebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSharedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSharedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - sharedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'sharedNotebook', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, sharedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.sharedNotebook = sharedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sharedNotebook = evernote.edam.type.ttypes.SharedNotebook()
          self.sharedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSharedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.sharedNotebook is not None:
      oprot.writeFieldBegin('sharedNotebook', TType.STRUCT, 2)
      self.sharedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSharedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSharedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSharedNotebookRecipientSettings_args(object):
  """
  Attributes:
   - authenticationToken
   - sharedNotebookId
   - recipientSettings
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.I64, 'sharedNotebookId', None, None, ), # 2
    (3, TType.STRUCT, 'recipientSettings', (evernote.edam.type.ttypes.SharedNotebookRecipientSettings, evernote.edam.type.ttypes.SharedNotebookRecipientSettings.thrift_spec), None, ), # 3
  )

  def __init__(self, authenticationToken=None, sharedNotebookId=None, recipientSettings=None,):
    self.authenticationToken = authenticationToken
    self.sharedNotebookId = sharedNotebookId
    self.recipientSettings = recipientSettings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.sharedNotebookId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.recipientSettings = evernote.edam.type.ttypes.SharedNotebookRecipientSettings()
          self.recipientSettings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSharedNotebookRecipientSettings_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.sharedNotebookId is not None:
      oprot.writeFieldBegin('sharedNotebookId', TType.I64, 2)
      oprot.writeI64(self.sharedNotebookId)
      oprot.writeFieldEnd()
    if self.recipientSettings is not None:
      oprot.writeFieldBegin('recipientSettings', TType.STRUCT, 3)
      self.recipientSettings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setSharedNotebookRecipientSettings_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setSharedNotebookRecipientSettings_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendMessageToSharedNotebookMembers_args(object):
  """
  Attributes:
   - authenticationToken
   - notebookGuid
   - messageText
   - recipients
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'notebookGuid', None, None, ), # 2
    (3, TType.STRING, 'messageText', None, None, ), # 3
    (4, TType.LIST, 'recipients', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, authenticationToken=None, notebookGuid=None, messageText=None, recipients=None,):
    self.authenticationToken = authenticationToken
    self.notebookGuid = notebookGuid
    self.messageText = messageText
    self.recipients = recipients

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.messageText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.recipients = []
          (_etype245, _size242) = iprot.readListBegin()
          for _i246 in xrange(_size242):
            _elem247 = iprot.readString();
            self.recipients.append(_elem247)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendMessageToSharedNotebookMembers_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.messageText is not None:
      oprot.writeFieldBegin('messageText', TType.STRING, 3)
      oprot.writeString(self.messageText)
      oprot.writeFieldEnd()
    if self.recipients is not None:
      oprot.writeFieldBegin('recipients', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.recipients))
      for iter248 in self.recipients:
        oprot.writeString(iter248)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendMessageToSharedNotebookMembers_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendMessageToSharedNotebookMembers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSharedNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSharedNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSharedNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype252, _size249) = iprot.readListBegin()
          for _i253 in xrange(_size249):
            _elem254 = evernote.edam.type.ttypes.SharedNotebook()
            _elem254.read(iprot)
            self.success.append(_elem254)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSharedNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter255 in self.success:
        iter255.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSharedNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
   - sharedNotebookIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.LIST, 'sharedNotebookIds', (TType.I64,None), None, ), # 2
  )

  def __init__(self, authenticationToken=None, sharedNotebookIds=None,):
    self.authenticationToken = authenticationToken
    self.sharedNotebookIds = sharedNotebookIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sharedNotebookIds = []
          (_etype259, _size256) = iprot.readListBegin()
          for _i260 in xrange(_size256):
            _elem261 = iprot.readI64();
            self.sharedNotebookIds.append(_elem261)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSharedNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.sharedNotebookIds is not None:
      oprot.writeFieldBegin('sharedNotebookIds', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.sharedNotebookIds))
      for iter262 in self.sharedNotebookIds:
        oprot.writeI64(iter262)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSharedNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSharedNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLinkedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLinkedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLinkedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.LinkedNotebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLinkedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateLinkedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateLinkedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateLinkedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateLinkedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listLinkedNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listLinkedNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listLinkedNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype266, _size263) = iprot.readListBegin()
          for _i267 in xrange(_size263):
            _elem268 = evernote.edam.type.ttypes.LinkedNotebook()
            _elem268.read(iprot)
            self.success.append(_elem268)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listLinkedNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter269 in self.success:
        iter269.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeLinkedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeLinkedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeLinkedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeLinkedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNotebook_args(object):
  """
  Attributes:
   - shareKey
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'shareKey', None, None, ), # 1
    (2, TType.STRING, 'authenticationToken', None, None, ), # 2
  )

  def __init__(self, shareKey=None, authenticationToken=None,):
    self.shareKey = shareKey
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.shareKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNotebook_args')
    if self.shareKey is not None:
      oprot.writeFieldBegin('shareKey', TType.STRING, 1)
      oprot.writeString(self.shareKey)
      oprot.writeFieldEnd()
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 2)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.userstore.ttypes.AuthenticationResult, evernote.edam.userstore.ttypes.AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.userstore.ttypes.AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSharedNotebookByAuth_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSharedNotebookByAuth_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSharedNotebookByAuth_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SharedNotebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSharedNotebookByAuth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emailNote_args(object):
  """
  Attributes:
   - authenticationToken
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'parameters', (NoteEmailParameters, NoteEmailParameters.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, parameters=None,):
    self.authenticationToken = authenticationToken
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.parameters = NoteEmailParameters()
          self.parameters.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emailNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.STRUCT, 2)
      self.parameters.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emailNote_result(object):
  """
  Attributes:
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, userException=None, notFoundException=None, systemException=None,):
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emailNote_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareNote_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopSharingNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopSharingNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopSharingNote_result(object):
  """
  Attributes:
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, userException=None, notFoundException=None, systemException=None,):
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopSharingNote_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNote_args(object):
  """
  Attributes:
   - guid
   - noteKey
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'noteKey', None, None, ), # 2
    (3, TType.STRING, 'authenticationToken', None, None, ), # 3
  )

  def __init__(self, guid=None, noteKey=None, authenticationToken=None,):
    self.guid = guid
    self.noteKey = noteKey
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNote_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.noteKey is not None:
      oprot.writeFieldBegin('noteKey', TType.STRING, 2)
      oprot.writeString(self.noteKey)
      oprot.writeFieldEnd()
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 3)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNote_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.userstore.ttypes.AuthenticationResult, evernote.edam.userstore.ttypes.AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.userstore.ttypes.AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findRelated_args(object):
  """
  Attributes:
   - authenticationToken
   - query
   - resultSpec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'query', (RelatedQuery, RelatedQuery.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'resultSpec', (RelatedResultSpec, RelatedResultSpec.thrift_spec), None, ), # 3
  )

  def __init__(self, authenticationToken=None, query=None, resultSpec=None,):
    self.authenticationToken = authenticationToken
    self.query = query
    self.resultSpec = resultSpec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query = RelatedQuery()
          self.query.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.resultSpec = RelatedResultSpec()
          self.resultSpec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findRelated_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRUCT, 2)
      self.query.write(oprot)
      oprot.writeFieldEnd()
    if self.resultSpec is not None:
      oprot.writeFieldBegin('resultSpec', TType.STRUCT, 3)
      self.resultSpec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findRelated_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RelatedResult, RelatedResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RelatedResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findRelated_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.userstore.ttypes
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes
import evernote.edam.limits.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class SyncState(object):
  """
   This structure encapsulates the information about the state of the
   user's account for the purpose of "state based" synchronization.
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server's current date and time.
     </dd>
  
   <dt>fullSyncBefore</dt>
     <dd>
     The cutoff date and time for client caches to be
     updated via incremental synchronization.  Any clients that were last
     synched with the server before this date/time must do a full resync of all
     objects.  This cutoff point will change over time as archival data is
     deleted or special circumstances on the service require resynchronization.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
  
   <dt>uploaded</dt>
     <dd>
     The total number of bytes that have been uploaded to
     this account in the current monthly period.  This can be compared against
     Accounting.uploadLimit (from the UserStore) to determine how close the user
     is to their monthly upload limit.
     This value may not be present if the SyncState has been retrieved by
     a caller that only has read access to the account.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - fullSyncBefore
   - updateCount
   - uploaded
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.I64, 'fullSyncBefore', None, None, ), # 2
    (3, TType.I32, 'updateCount', None, None, ), # 3
    (4, TType.I64, 'uploaded', None, None, ), # 4
  )

  def __init__(self, currentTime=None, fullSyncBefore=None, updateCount=None, uploaded=None,):
    self.currentTime = currentTime
    self.fullSyncBefore = fullSyncBefore
    self.updateCount = updateCount
    self.uploaded = uploaded

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.fullSyncBefore = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.uploaded = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncState')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.fullSyncBefore is not None:
      oprot.writeFieldBegin('fullSyncBefore', TType.I64, 2)
      oprot.writeI64(self.fullSyncBefore)
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 3)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    if self.uploaded is not None:
      oprot.writeFieldBegin('uploaded', TType.I64, 4)
      oprot.writeI64(self.uploaded)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.fullSyncBefore is None:
      raise TProtocol.TProtocolException(message='Required field fullSyncBefore is unset!')
    if self.updateCount is None:
      raise TProtocol.TProtocolException(message='Required field updateCount is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SyncChunk(object):
  """
   This structure is given out by the NoteStore when a client asks to
   receive the current state of an account.  The client asks for the server's
   state one chunk at a time in order to allow clients to retrieve the state
   of a large account without needing to transfer the entire account in
   a single message.
  
   The server always gives SyncChunks using an ascending series of Update
   Sequence Numbers (USNs).
  
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server's current date and time.
     </dd>
  
   <dt>chunkHighUSN</dt>
     <dd>
     The highest USN for any of the data objects represented
     in this sync chunk.  If there are no objects in the chunk, this will not be
     set.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     The total number of updates that have been performed in
     the service for this account.  This is equal to the highest USN within the
     account at the point that this SyncChunk was generated.  If updateCount
     and chunkHighUSN are identical, that means that this is the last chunk
     in the account ... there is no more recent information.
     </dd>
  
   <dt>notes</dt>
     <dd>
     If present, this is a list of non-expunged notes that
     have a USN in this chunk.  This will include notes that are "deleted"
     but not expunged (i.e. in the trash).  The notes will include their list
     of tags and resources, but the note content, resource content, resource
     recognition data and resource alternate data will not be supplied.
     </dd>
  
   <dt>notebooks</dt>
     <dd>
     If present, this is a list of non-expunged notebooks that
     have a USN in this chunk.  This will include notebooks that are "deleted"
     but not expunged (i.e. in the trash).
     </dd>
  
   <dt>tags</dt>
     <dd>
     If present, this is a list of the non-expunged tags that have a
     USN in this chunk.
     </dd>
  
   <dt>searches</dt>
     <dd>
     If present, this is a list of non-expunged searches that
     have a USN in this chunk.
     </dd>
  
   <dt>resources</dt>
     <dd>
     If present, this is a list of the non-expunged resources
     that have a USN in this chunk.  This will include the metadata for each
     resource, but not its binary contents or recognition data, which must be
     retrieved separately.
     </dd>
  
   <dt>expungedNotes</dt>
     <dd>
     If present, the GUIDs of all of the notes that were
     permanently expunged in this chunk.
     </dd>
  
   <dt>expungedNotebooks</dt>
     <dd>
     If present, the GUIDs of all of the notebooks that
     were permanently expunged in this chunk.  When a notebook is expunged,
     this implies that all of its child notes (and their resources) were
     also expunged.
     </dd>
  
   <dt>expungedTags</dt>
     <dd>
     If present, the GUIDs of all of the tags that were
     permanently expunged in this chunk.
     </dd>
  
   <dt>expungedSearches</dt>
     <dd>
     If present, the GUIDs of all of the saved searches
     that were permanently expunged in this chunk.
     </dd>
  
   <dt>linkedNotebooks</dt>
     <dd>
     If present, this is a list of non-expunged LinkedNotebooks that
     have a USN in this chunk.
     </dd>
  
   <dt>expungedLinkedNotebooks</dt>
     <dd>
     If present, the GUIDs of all of the LinkedNotebooks
     that were permanently expunged in this chunk.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - chunkHighUSN
   - updateCount
   - notes
   - notebooks
   - tags
   - searches
   - resources
   - expungedNotes
   - expungedNotebooks
   - expungedTags
   - expungedSearches
   - linkedNotebooks
   - expungedLinkedNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.I32, 'chunkHighUSN', None, None, ), # 2
    (3, TType.I32, 'updateCount', None, None, ), # 3
    (4, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'notebooks', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'tags', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'searches', (TType.STRUCT,(evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'resources', (TType.STRUCT,(evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'expungedNotes', (TType.STRING,None), None, ), # 9
    (10, TType.LIST, 'expungedNotebooks', (TType.STRING,None), None, ), # 10
    (11, TType.LIST, 'expungedTags', (TType.STRING,None), None, ), # 11
    (12, TType.LIST, 'expungedSearches', (TType.STRING,None), None, ), # 12
    (13, TType.LIST, 'linkedNotebooks', (TType.STRUCT,(evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec)), None, ), # 13
    (14, TType.LIST, 'expungedLinkedNotebooks', (TType.STRING,None), None, ), # 14
  )

  def __init__(self, currentTime=None, chunkHighUSN=None, updateCount=None, notes=None, notebooks=None, tags=None, searches=None, resources=None, expungedNotes=None, expungedNotebooks=None, expungedTags=None, expungedSearches=None, linkedNotebooks=None, expungedLinkedNotebooks=None,):
    self.currentTime = currentTime
    self.chunkHighUSN = chunkHighUSN
    self.updateCount = updateCount
    self.notes = notes
    self.notebooks = notebooks
    self.tags = tags
    self.searches = searches
    self.resources = resources
    self.expungedNotes = expungedNotes
    self.expungedNotebooks = expungedNotebooks
    self.expungedTags = expungedTags
    self.expungedSearches = expungedSearches
    self.linkedNotebooks = linkedNotebooks
    self.expungedLinkedNotebooks = expungedLinkedNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.chunkHighUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.notes = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = evernote.edam.type.ttypes.Note()
            _elem5.read(iprot)
            self.notes.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.notebooks = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = evernote.edam.type.ttypes.Notebook()
            _elem11.read(iprot)
            self.notebooks.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.tags = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = evernote.edam.type.ttypes.Tag()
            _elem17.read(iprot)
            self.tags.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.searches = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = evernote.edam.type.ttypes.SavedSearch()
            _elem23.read(iprot)
            self.searches.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.resources = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = evernote.edam.type.ttypes.Resource()
            _elem29.read(iprot)
            self.resources.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.expungedNotes = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.expungedNotes.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.expungedNotebooks = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.expungedNotebooks.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.expungedTags = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.expungedTags.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.expungedSearches = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readString();
            self.expungedSearches.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.linkedNotebooks = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = evernote.edam.type.ttypes.LinkedNotebook()
            _elem59.read(iprot)
            self.linkedNotebooks.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.expungedLinkedNotebooks = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = iprot.readString();
            self.expungedLinkedNotebooks.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncChunk')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.chunkHighUSN is not None:
      oprot.writeFieldBegin('chunkHighUSN', TType.I32, 2)
      oprot.writeI32(self.chunkHighUSN)
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 3)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter66 in self.notes:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.notebooks is not None:
      oprot.writeFieldBegin('notebooks', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
      for iter67 in self.notebooks:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter68 in self.tags:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searches is not None:
      oprot.writeFieldBegin('searches', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.searches))
      for iter69 in self.searches:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.resources))
      for iter70 in self.resources:
        iter70.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedNotes is not None:
      oprot.writeFieldBegin('expungedNotes', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.expungedNotes))
      for iter71 in self.expungedNotes:
        oprot.writeString(iter71)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedNotebooks is not None:
      oprot.writeFieldBegin('expungedNotebooks', TType.LIST, 10)
      oprot.writeListBegin(TType.STRING, len(self.expungedNotebooks))
      for iter72 in self.expungedNotebooks:
        oprot.writeString(iter72)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedTags is not None:
      oprot.writeFieldBegin('expungedTags', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.expungedTags))
      for iter73 in self.expungedTags:
        oprot.writeString(iter73)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedSearches is not None:
      oprot.writeFieldBegin('expungedSearches', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.expungedSearches))
      for iter74 in self.expungedSearches:
        oprot.writeString(iter74)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.linkedNotebooks is not None:
      oprot.writeFieldBegin('linkedNotebooks', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.linkedNotebooks))
      for iter75 in self.linkedNotebooks:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedLinkedNotebooks is not None:
      oprot.writeFieldBegin('expungedLinkedNotebooks', TType.LIST, 14)
      oprot.writeListBegin(TType.STRING, len(self.expungedLinkedNotebooks))
      for iter76 in self.expungedLinkedNotebooks:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.updateCount is None:
      raise TProtocol.TProtocolException(message='Required field updateCount is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SyncChunkFilter(object):
  """
   This structure is used with the 'getFilteredSyncChunk' call to provide
   fine-grained control over the data that's returned when a client needs
   to synchronize with the service. Each flag in this structure specifies
   whether to include one class of data in the results of that call.
  
  <dl>
   <dt>includeNotes</dt>
     <dd>
     If true, then the server will include the SyncChunks.notes field
     </dd>
  
   <dt>includeNoteResources</dt>
     <dd>
     If true, then the server will include the 'resources' field on all of
     the Notes that are in SyncChunk.notes.
     If 'includeNotes' is false, then this will have no effect.
     </dd>
  
   <dt>includeNoteAttributes</dt>
     <dd>
     If true, then the server will include the 'attributes' field on all of
     the Notes that are in SyncChunks.notes.
     If 'includeNotes' is false, then this will have no effect.
     </dd>
  
   <dt>includeNotebooks</dt>
     <dd>
     If true, then the server will include the SyncChunks.notebooks field
     </dd>
  
   <dt>includeTags</dt>
     <dd>
     If true, then the server will include the SyncChunks.tags field
     </dd>
  
   <dt>includeSearches</dt>
     <dd>
     If true, then the server will include the SyncChunks.searches field
     </dd>
  
   <dt>includeResources</dt>
     <dd>
     If true, then the server will include the SyncChunks.resources field.
     Since the Resources are also provided with their Note
     (in the Notes.resources list), this is primarily useful for clients that
     want to watch for changes to individual Resources due to recognition data
     being added.
     </dd>
  
   <dt>includeLinkedNotebooks</dt>
     <dd>
     If true, then the server will include the SyncChunks.linkedNotebooks field.
     </dd>
  
   <dt>includeExpunged</dt>
     <dd>
     If true, then the server will include the 'expunged' data for any type
     of included data.  For example, if 'includeTags' and 'includeExpunged'
     are both true, then the SyncChunks.expungedTags field will be set with
     the GUIDs of tags that have been expunged from the server.
     </dd>
  
   <dt>includeNoteApplicationDataFullMap</dt>
     <dd>
     If true, then the values for the applicationData map will be filled
     in, assuming notes and note attributes are being returned.  Otherwise,
     only the keysOnly field will be filled in.
     </dd>
  
   <dt>includeResourceApplicationDataFullMap</dt>
     <dd>
     If true, then the fullMap values for the applicationData map will be
     filled in, assuming resources and resource attributes are being returned
     (includeResources is true).  Otherwise, only the keysOnly field will be
     filled in.
     </dd>
  
   <dt>includeNoteResourceApplicationDataFullMap</dt>
     <dd>
     If true, then the fullMap values for the applicationData map will be
     filled in for resources found inside of notes, assuming resources are
     being returned in notes (includeNoteResources is true).  Otherwise,
     only the keysOnly field will be filled in.
     </dd>
  
   <dt>requireNoteContentClass</dt>
     <dd>
     If set, then only send notes whose content class matches this value.
     The value can be a literal match or, if the last character is an
     asterisk, a prefix match.
     </dd>
   </dl>
  
  Attributes:
   - includeNotes
   - includeNoteResources
   - includeNoteAttributes
   - includeNotebooks
   - includeTags
   - includeSearches
   - includeResources
   - includeLinkedNotebooks
   - includeExpunged
   - includeNoteApplicationDataFullMap
   - includeResourceApplicationDataFullMap
   - includeNoteResourceApplicationDataFullMap
   - requireNoteContentClass
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'includeNotes', None, None, ), # 1
    (2, TType.BOOL, 'includeNoteResources', None, None, ), # 2
    (3, TType.BOOL, 'includeNoteAttributes', None, None, ), # 3
    (4, TType.BOOL, 'includeNotebooks', None, None, ), # 4
    (5, TType.BOOL, 'includeTags', None, None, ), # 5
    (6, TType.BOOL, 'includeSearches', None, None, ), # 6
    (7, TType.BOOL, 'includeResources', None, None, ), # 7
    (8, TType.BOOL, 'includeLinkedNotebooks', None, None, ), # 8
    (9, TType.BOOL, 'includeExpunged', None, None, ), # 9
    (10, TType.BOOL, 'includeNoteApplicationDataFullMap', None, None, ), # 10
    (11, TType.STRING, 'requireNoteContentClass', None, None, ), # 11
    (12, TType.BOOL, 'includeResourceApplicationDataFullMap', None, None, ), # 12
    (13, TType.BOOL, 'includeNoteResourceApplicationDataFullMap', None, None, ), # 13
  )

  def __init__(self, includeNotes=None, includeNoteResources=None, includeNoteAttributes=None, includeNotebooks=None, includeTags=None, includeSearches=None, includeResources=None, includeLinkedNotebooks=None, includeExpunged=None, includeNoteApplicationDataFullMap=None, includeResourceApplicationDataFullMap=None, includeNoteResourceApplicationDataFullMap=None, requireNoteContentClass=None,):
    self.includeNotes = includeNotes
    self.includeNoteResources = includeNoteResources
    self.includeNoteAttributes = includeNoteAttributes
    self.includeNotebooks = includeNotebooks
    self.includeTags = includeTags
    self.includeSearches = includeSearches
    self.includeResources = includeResources
    self.includeLinkedNotebooks = includeLinkedNotebooks
    self.includeExpunged = includeExpunged
    self.includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap
    self.includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap
    self.includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap
    self.requireNoteContentClass = requireNoteContentClass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.includeNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.includeNoteResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.includeNoteAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.includeNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeTags = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeSearches = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.includeResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.includeLinkedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.includeExpunged = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.includeNoteApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.includeResourceApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.includeNoteResourceApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.requireNoteContentClass = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncChunkFilter')
    if self.includeNotes is not None:
      oprot.writeFieldBegin('includeNotes', TType.BOOL, 1)
      oprot.writeBool(self.includeNotes)
      oprot.writeFieldEnd()
    if self.includeNoteResources is not None:
      oprot.writeFieldBegin('includeNoteResources', TType.BOOL, 2)
      oprot.writeBool(self.includeNoteResources)
      oprot.writeFieldEnd()
    if self.includeNoteAttributes is not None:
      oprot.writeFieldBegin('includeNoteAttributes', TType.BOOL, 3)
      oprot.writeBool(self.includeNoteAttributes)
      oprot.writeFieldEnd()
    if self.includeNotebooks is not None:
      oprot.writeFieldBegin('includeNotebooks', TType.BOOL, 4)
      oprot.writeBool(self.includeNotebooks)
      oprot.writeFieldEnd()
    if self.includeTags is not None:
      oprot.writeFieldBegin('includeTags', TType.BOOL, 5)
      oprot.writeBool(self.includeTags)
      oprot.writeFieldEnd()
    if self.includeSearches is not None:
      oprot.writeFieldBegin('includeSearches', TType.BOOL, 6)
      oprot.writeBool(self.includeSearches)
      oprot.writeFieldEnd()
    if self.includeResources is not None:
      oprot.writeFieldBegin('includeResources', TType.BOOL, 7)
      oprot.writeBool(self.includeResources)
      oprot.writeFieldEnd()
    if self.includeLinkedNotebooks is not None:
      oprot.writeFieldBegin('includeLinkedNotebooks', TType.BOOL, 8)
      oprot.writeBool(self.includeLinkedNotebooks)
      oprot.writeFieldEnd()
    if self.includeExpunged is not None:
      oprot.writeFieldBegin('includeExpunged', TType.BOOL, 9)
      oprot.writeBool(self.includeExpunged)
      oprot.writeFieldEnd()
    if self.includeNoteApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeNoteApplicationDataFullMap', TType.BOOL, 10)
      oprot.writeBool(self.includeNoteApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.requireNoteContentClass is not None:
      oprot.writeFieldBegin('requireNoteContentClass', TType.STRING, 11)
      oprot.writeString(self.requireNoteContentClass)
      oprot.writeFieldEnd()
    if self.includeResourceApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeResourceApplicationDataFullMap', TType.BOOL, 12)
      oprot.writeBool(self.includeResourceApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.includeNoteResourceApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeNoteResourceApplicationDataFullMap', TType.BOOL, 13)
      oprot.writeBool(self.includeNoteResourceApplicationDataFullMap)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteFilter(object):
  """
   A list of criteria that are used to indicate which notes are desired from
   the account.  This is used in queries to the NoteStore to determine
   which notes should be retrieved.
  
  <dl>
   <dt>order</dt>
     <dd>
     The NoteSortOrder value indicating what criterion should be
     used to sort the results of the filter.
     </dd>
  
   <dt>ascending</dt>
     <dd>
     If true, the results will be ascending in the requested
     sort order.  If false, the results will be descending.
     </dd>
  
   <dt>words</dt>
     <dd>
     If present, a search query string that will filter the set of notes to be returned.
     Accepts the full search grammar documented in the Evernote API Overview.
     </dd>
  
   <dt>notebookGuid</dt>
     <dd>
     If present, the Guid of the notebook that must contain
     the notes.
     </dd>
  
   <dt>tagGuids</dt>
     <dd>
     If present, the list of tags (by GUID) that must be present
     on the notes.
     </dd>
  
   <dt>timeZone</dt>
     <dd>
     The zone ID for the user, which will be used to interpret
     any dates or times in the queries that do not include their desired zone
     information.
     For example, if a query requests notes created "yesterday", this
     will be evaluated from the provided time zone, if provided.
     The format must be encoded as a standard zone ID such as
     "America/Los_Angeles".
     </dd>
  
   <dt>inactive</dt>
     <dd>
     If true, then only notes that are not active (i.e. notes in
     the Trash) will be returned. Otherwise, only active notes will be returned.
     There is no way to find both active and inactive notes in a single query.
     </dd>
  
   <dt>emphasized</dt>
     <dd>
     If present, a search query string that may or may not influence the notes
     to be returned, both in terms of coverage as well as of order. Think of it
     as a wish list, not a requirement.
     Accepts the full search grammar documented in the Evernote API Overview.
     </dd>
   </dl>
  
  Attributes:
   - order
   - ascending
   - words
   - notebookGuid
   - tagGuids
   - timeZone
   - inactive
   - emphasized
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'order', None, None, ), # 1
    (2, TType.BOOL, 'ascending', None, None, ), # 2
    (3, TType.STRING, 'words', None, None, ), # 3
    (4, TType.STRING, 'notebookGuid', None, None, ), # 4
    (5, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'timeZone', None, None, ), # 6
    (7, TType.BOOL, 'inactive', None, None, ), # 7
    (8, TType.STRING, 'emphasized', None, None, ), # 8
  )

  def __init__(self, order=None, ascending=None, words=None, notebookGuid=None, tagGuids=None, timeZone=None, inactive=None, emphasized=None,):
    self.order = order
    self.ascending = ascending
    self.words = words
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.timeZone = timeZone
    self.inactive = inactive
    self.emphasized = emphasized

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.words = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.tagGuids.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.timeZone = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.inactive = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.emphasized = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteFilter')
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 1)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 2)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.words is not None:
      oprot.writeFieldBegin('words', TType.STRING, 3)
      oprot.writeString(self.words)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 4)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter83 in self.tagGuids:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timeZone is not None:
      oprot.writeFieldBegin('timeZone', TType.STRING, 6)
      oprot.writeString(self.timeZone)
      oprot.writeFieldEnd()
    if self.inactive is not None:
      oprot.writeFieldBegin('inactive', TType.BOOL, 7)
      oprot.writeBool(self.inactive)
      oprot.writeFieldEnd()
    if self.emphasized is not None:
      oprot.writeFieldBegin('emphasized', TType.STRING, 8)
      oprot.writeString(self.emphasized)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteList(object):
  """
   A small structure for returning a list of notes out of a larger set.
  
  <dl>
   <dt>startIndex</dt>
     <dd>
     The starting index within the overall set of notes.  This
     is also the number of notes that are "before" this list in the set.
     </dd>
  
   <dt>totalNotes</dt>
     <dd>
     The number of notes in the larger set.  This can be used
     to calculate how many notes are "after" this note in the set.
     (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
     </dd>
  
   <dt>notes</dt>
     <dd>
     The list of notes from this range.  The Notes will include all
     metadata (attributes, resources, etc.), but will not include the ENML
     content of the note or the binary contents of any resources.
     </dd>
  
   <dt>stoppedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included words that are not indexed or searched by the service,
     this will include a list of those ignored words.
     </dd>
  
   <dt>searchedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included viable search words or quoted expressions, this will
     include a list of those words.  Any stopped words will not be included
     in this list.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
   </dl>
  
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = evernote.edam.type.ttypes.Note()
            _elem89.read(iprot)
            self.notes.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readString();
            self.stoppedWords.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = iprot.readString();
            self.searchedWords.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteList')
    if self.startIndex is not None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes is not None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter102 in self.notes:
        iter102.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords is not None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter103 in self.stoppedWords:
        oprot.writeString(iter103)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords is not None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter104 in self.searchedWords:
        oprot.writeString(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startIndex is None:
      raise TProtocol.TProtocolException(message='Required field startIndex is unset!')
    if self.totalNotes is None:
      raise TProtocol.TProtocolException(message='Required field totalNotes is unset!')
    if self.notes is None:
      raise TProtocol.TProtocolException(message='Required field notes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteMetadata(object):
  """
  This structure is used in the set of results returned by the
  findNotesMetadata function.  It represents the high-level information about
  a single Note, without some of the larger deep structure.  This allows
  for the information about a list of Notes to be returned relatively quickly
  with less marshalling and data transfer to remote clients.
  Most fields in this structure are identical to the corresponding field in
  the Note structure, with the exception of:
  
  <dl>
  <dt>largestResourceMime</dt>
    <dd>If set, then this will contain the MIME type of the largest Resource
    (in bytes) within the Note.  This may be useful, for example, to choose
    an appropriate icon or thumbnail to represent the Note.
    </dd>
  
  <dt>largestResourceSize</dt>
   <dd>If set, this will contain the size of the largest Resource file, in
   bytes, within the Note.  This may be useful, for example, to decide whether
   to ask the server for a thumbnail to represent the Note.
   </dd>
  </dl>
  
  Attributes:
   - guid
   - title
   - contentLength
   - created
   - updated
   - deleted
   - updateSequenceNum
   - notebookGuid
   - tagGuids
   - attributes
   - largestResourceMime
   - largestResourceSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'title', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.I32, 'contentLength', None, None, ), # 5
    (6, TType.I64, 'created', None, None, ), # 6
    (7, TType.I64, 'updated', None, None, ), # 7
    (8, TType.I64, 'deleted', None, None, ), # 8
    None, # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ), # 10
    (11, TType.STRING, 'notebookGuid', None, None, ), # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 12
    None, # 13
    (14, TType.STRUCT, 'attributes', (evernote.edam.type.ttypes.NoteAttributes, evernote.edam.type.ttypes.NoteAttributes.thrift_spec), None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.STRING, 'largestResourceMime', None, None, ), # 20
    (21, TType.I32, 'largestResourceSize', None, None, ), # 21
  )

  def __init__(self, guid=None, title=None, contentLength=None, created=None, updated=None, deleted=None, updateSequenceNum=None, notebookGuid=None, tagGuids=None, attributes=None, largestResourceMime=None, largestResourceSize=None,):
    self.guid = guid
    self.title = title
    self.contentLength = contentLength
    self.created = created
    self.updated = updated
    self.deleted = deleted
    self.updateSequenceNum = updateSequenceNum
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.attributes = attributes
    self.largestResourceMime = largestResourceMime
    self.largestResourceSize = largestResourceSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.contentLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.deleted = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readString();
            self.tagGuids.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.attributes = evernote.edam.type.ttypes.NoteAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.largestResourceMime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.I32:
          self.largestResourceSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteMetadata')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 2)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.contentLength is not None:
      oprot.writeFieldBegin('contentLength', TType.I32, 5)
      oprot.writeI32(self.contentLength)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 6)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 7)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.I64, 8)
      oprot.writeI64(self.deleted)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter111 in self.tagGuids:
        oprot.writeString(iter111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.largestResourceMime is not None:
      oprot.writeFieldBegin('largestResourceMime', TType.STRING, 20)
      oprot.writeString(self.largestResourceMime)
      oprot.writeFieldEnd()
    if self.largestResourceSize is not None:
      oprot.writeFieldBegin('largestResourceSize', TType.I32, 21)
      oprot.writeI32(self.largestResourceSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guid is None:
      raise TProtocol.TProtocolException(message='Required field guid is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotesMetadataList(object):
  """
   This structure is returned from calls to the findNotesMetadata function to
   give the high-level metadata about a subset of Notes that are found to
   match a specified NoteFilter in a search.
  
  <dl>
   <dt>startIndex</dt>
     <dd>
     The starting index within the overall set of notes.  This
     is also the number of notes that are "before" this list in the set.
     </dd>
  
   <dt>totalNotes</dt>
     <dd>
     The number of notes in the larger set.  This can be used
     to calculate how many notes are "after" this note in the set.
     (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
     </dd>
  
   <dt>notes</dt>
     <dd>
     The list of metadata for Notes in this range.  The set of optional fields
     that are set in each metadata structure will depend on the
     NotesMetadataResultSpec provided by the caller when the search was
     performed.  Only the 'guid' field will be guaranteed to be set in each
     Note.
     </dd>
  
   <dt>stoppedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included words that are not indexed or searched by the service,
     this will include a list of those ignored words.
     </dd>
  
   <dt>searchedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included viable search words or quoted expressions, this will
     include a list of those words.  Any stopped words will not be included
     in this list.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
   </dl>
  
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(NoteMetadata, NoteMetadata.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = NoteMetadata()
            _elem117.read(iprot)
            self.notes.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readString();
            self.stoppedWords.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = iprot.readString();
            self.searchedWords.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotesMetadataList')
    if self.startIndex is not None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes is not None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter130 in self.notes:
        iter130.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords is not None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter131 in self.stoppedWords:
        oprot.writeString(iter131)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords is not None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter132 in self.searchedWords:
        oprot.writeString(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startIndex is None:
      raise TProtocol.TProtocolException(message='Required field startIndex is unset!')
    if self.totalNotes is None:
      raise TProtocol.TProtocolException(message='Required field totalNotes is unset!')
    if self.notes is None:
      raise TProtocol.TProtocolException(message='Required field notes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotesMetadataResultSpec(object):
  """
  This structure is provided to the findNotesMetadata function to specify
  the subset of fields that should be included in each NoteMetadata element
  that is returned in the NotesMetadataList.
  Each field on this structure is a boolean flag that indicates whether the
  corresponding field should be included in the NoteMetadata structure when
  it is returned.  For example, if the 'includeTitle' field is set on this
  structure when calling findNotesMetadata, then each NoteMetadata in the
  list should have its 'title' field set.
  If one of the fields in this spec is not set, then it will be treated as
  'false' by the server, so the default behavior is to include nothing in
  replies (but the mandatory GUID)
  
  Attributes:
   - includeTitle
   - includeContentLength
   - includeCreated
   - includeUpdated
   - includeDeleted
   - includeUpdateSequenceNum
   - includeNotebookGuid
   - includeTagGuids
   - includeAttributes
   - includeLargestResourceMime
   - includeLargestResourceSize
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.BOOL, 'includeTitle', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.BOOL, 'includeContentLength', None, None, ), # 5
    (6, TType.BOOL, 'includeCreated', None, None, ), # 6
    (7, TType.BOOL, 'includeUpdated', None, None, ), # 7
    (8, TType.BOOL, 'includeDeleted', None, None, ), # 8
    None, # 9
    (10, TType.BOOL, 'includeUpdateSequenceNum', None, None, ), # 10
    (11, TType.BOOL, 'includeNotebookGuid', None, None, ), # 11
    (12, TType.BOOL, 'includeTagGuids', None, None, ), # 12
    None, # 13
    (14, TType.BOOL, 'includeAttributes', None, None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'includeLargestResourceMime', None, None, ), # 20
    (21, TType.BOOL, 'includeLargestResourceSize', None, None, ), # 21
  )

  def __init__(self, includeTitle=None, includeContentLength=None, includeCreated=None, includeUpdated=None, includeDeleted=None, includeUpdateSequenceNum=None, includeNotebookGuid=None, includeTagGuids=None, includeAttributes=None, includeLargestResourceMime=None, includeLargestResourceSize=None,):
    self.includeTitle = includeTitle
    self.includeContentLength = includeContentLength
    self.includeCreated = includeCreated
    self.includeUpdated = includeUpdated
    self.includeDeleted = includeDeleted
    self.includeUpdateSequenceNum = includeUpdateSequenceNum
    self.includeNotebookGuid = includeNotebookGuid
    self.includeTagGuids = includeTagGuids
    self.includeAttributes = includeAttributes
    self.includeLargestResourceMime = includeLargestResourceMime
    self.includeLargestResourceSize = includeLargestResourceSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.includeTitle = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeContentLength = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeCreated = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.includeUpdated = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.includeDeleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.includeUpdateSequenceNum = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.includeNotebookGuid = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.includeTagGuids = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.includeAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.includeLargestResourceMime = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.BOOL:
          self.includeLargestResourceSize = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotesMetadataResultSpec')
    if self.includeTitle is not None:
      oprot.writeFieldBegin('includeTitle', TType.BOOL, 2)
      oprot.writeBool(self.includeTitle)
      oprot.writeFieldEnd()
    if self.includeContentLength is not None:
      oprot.writeFieldBegin('includeContentLength', TType.BOOL, 5)
      oprot.writeBool(self.includeContentLength)
      oprot.writeFieldEnd()
    if self.includeCreated is not None:
      oprot.writeFieldBegin('includeCreated', TType.BOOL, 6)
      oprot.writeBool(self.includeCreated)
      oprot.writeFieldEnd()
    if self.includeUpdated is not None:
      oprot.writeFieldBegin('includeUpdated', TType.BOOL, 7)
      oprot.writeBool(self.includeUpdated)
      oprot.writeFieldEnd()
    if self.includeDeleted is not None:
      oprot.writeFieldBegin('includeDeleted', TType.BOOL, 8)
      oprot.writeBool(self.includeDeleted)
      oprot.writeFieldEnd()
    if self.includeUpdateSequenceNum is not None:
      oprot.writeFieldBegin('includeUpdateSequenceNum', TType.BOOL, 10)
      oprot.writeBool(self.includeUpdateSequenceNum)
      oprot.writeFieldEnd()
    if self.includeNotebookGuid is not None:
      oprot.writeFieldBegin('includeNotebookGuid', TType.BOOL, 11)
      oprot.writeBool(self.includeNotebookGuid)
      oprot.writeFieldEnd()
    if self.includeTagGuids is not None:
      oprot.writeFieldBegin('includeTagGuids', TType.BOOL, 12)
      oprot.writeBool(self.includeTagGuids)
      oprot.writeFieldEnd()
    if self.includeAttributes is not None:
      oprot.writeFieldBegin('includeAttributes', TType.BOOL, 14)
      oprot.writeBool(self.includeAttributes)
      oprot.writeFieldEnd()
    if self.includeLargestResourceMime is not None:
      oprot.writeFieldBegin('includeLargestResourceMime', TType.BOOL, 20)
      oprot.writeBool(self.includeLargestResourceMime)
      oprot.writeFieldEnd()
    if self.includeLargestResourceSize is not None:
      oprot.writeFieldBegin('includeLargestResourceSize', TType.BOOL, 21)
      oprot.writeBool(self.includeLargestResourceSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteCollectionCounts(object):
  """
   A data structure representing the number of notes for each notebook
   and tag with a non-zero set of applicable notes.
  
  <dl>
   <dt>notebookCounts</dt>
     <dd>
     A mapping from the Notebook GUID to the number of
     notes (from some selection) that are in the corresponding notebook.
     </dd>
  
   <dt>tagCounts</dt>
     <dd>
     A mapping from the Tag GUID to the number of notes (from some
     selection) that have the corresponding tag.
     </dd>
  
   <dt>trashCount</dt>
     <dd>
     If this is set, then this is the number of notes that are in the trash.
     If this is not set, then the number of notes in the trash hasn't been
     reported.  (I.e. if there are no notes in the trash, this will be set
     to 0.)
     </dd>
   </dl>
  
  Attributes:
   - notebookCounts
   - tagCounts
   - trashCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'notebookCounts', (TType.STRING,None,TType.I32,None), None, ), # 1
    (2, TType.MAP, 'tagCounts', (TType.STRING,None,TType.I32,None), None, ), # 2
    (3, TType.I32, 'trashCount', None, None, ), # 3
  )

  def __init__(self, notebookCounts=None, tagCounts=None, trashCount=None,):
    self.notebookCounts = notebookCounts
    self.tagCounts = tagCounts
    self.trashCount = trashCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.notebookCounts = {}
          (_ktype134, _vtype135, _size133 ) = iprot.readMapBegin() 
          for _i137 in xrange(_size133):
            _key138 = iprot.readString();
            _val139 = iprot.readI32();
            self.notebookCounts[_key138] = _val139
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.tagCounts = {}
          (_ktype141, _vtype142, _size140 ) = iprot.readMapBegin() 
          for _i144 in xrange(_size140):
            _key145 = iprot.readString();
            _val146 = iprot.readI32();
            self.tagCounts[_key145] = _val146
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trashCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteCollectionCounts')
    if self.notebookCounts is not None:
      oprot.writeFieldBegin('notebookCounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.notebookCounts))
      for kiter147,viter148 in self.notebookCounts.items():
        oprot.writeString(kiter147)
        oprot.writeI32(viter148)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.tagCounts is not None:
      oprot.writeFieldBegin('tagCounts', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.tagCounts))
      for kiter149,viter150 in self.tagCounts.items():
        oprot.writeString(kiter149)
        oprot.writeI32(viter150)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.trashCount is not None:
      oprot.writeFieldBegin('trashCount', TType.I32, 3)
      oprot.writeI32(self.trashCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteEmailParameters(object):
  """
  Parameters that must be given to the NoteStore emailNote call. These allow
  the caller to specify the note to send, the recipient addresses, etc.
  
  <dl>
   <dt>guid</dt>
     <dd>
       If set, this must be the GUID of a note within the user's account that
       should be retrieved from the service and sent as email.  If not set,
       the 'note' field must be provided instead.
     </dd>
  
   <dt>note</dt>
     <dd>
       If the 'guid' field is not set, this field must be provided, including
       the full contents of the note note (and all of its Resources) to send.
       This can be used for a Note that as not been created in the service,
       for example by a local client with local notes.
     </dd>
  
   <dt>toAddresses</dt>
     <dd>
       If provided, this should contain a list of the SMTP email addresses
       that should be included in the "To:" line of the email.
       Callers must specify at least one "to" or "cc" email address.
     </dd>
  
   <dt>ccAddresses</dt>
     <dd>
       If provided, this should contain a list of the SMTP email addresses
       that should be included in the "Cc:" line of the email.
       Callers must specify at least one "to" or "cc" email address.
     </dd>
  
   <dt>subject</dt>
     <dd>
       If provided, this should contain the subject line of the email that
       will be sent.  If not provided, the title of the note will be used
       as the subject of the email.
     </dd>
  
   <dt>message</dt>
     <dd>
       If provided, this is additional personal text that should be included
       into the email as a message from the owner to the recipient(s).
     </dd>
  </dl>
  
  Attributes:
   - guid
   - note
   - toAddresses
   - ccAddresses
   - subject
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
    (3, TType.LIST, 'toAddresses', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'ccAddresses', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'subject', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
  )

  def __init__(self, guid=None, note=None, toAddresses=None, ccAddresses=None, subject=None, message=None,):
    self.guid = guid
    self.note = note
    self.toAddresses = toAddresses
    self.ccAddresses = ccAddresses
    self.subject = subject
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.toAddresses = []
          (_etype154, _size151) = iprot.readListBegin()
          for _i155 in xrange(_size151):
            _elem156 = iprot.readString();
            self.toAddresses.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ccAddresses = []
          (_etype160, _size157) = iprot.readListBegin()
          for _i161 in xrange(_size157):
            _elem162 = iprot.readString();
            self.ccAddresses.append(_elem162)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.subject = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteEmailParameters')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    if self.toAddresses is not None:
      oprot.writeFieldBegin('toAddresses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.toAddresses))
      for iter163 in self.toAddresses:
        oprot.writeString(iter163)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccAddresses is not None:
      oprot.writeFieldBegin('ccAddresses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.ccAddresses))
      for iter164 in self.ccAddresses:
        oprot.writeString(iter164)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.subject is not None:
      oprot.writeFieldBegin('subject', TType.STRING, 5)
      oprot.writeString(self.subject)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteVersionId(object):
  """
  Identifying information about previous versions of a note that are backed up
  within Evernote's servers.  Used in the return value of the listNoteVersions
  call.
  
  <dl>
   <dt>updateSequenceNum</dt>
   <dd>
     The update sequence number for the Note when it last had this content.
     This serves to uniquely identify each version of the note, since USN
     values are unique within an account for each update.
   </dd>
   <dt>updated</dt>
   <dd>
     The 'updated' time that was set on the Note when it had this version
     of the content.  This is the user-modifiable modification time on the
     note, so it's not reliable for guaranteeing the order of various
     versions.  (E.g. if someone modifies the note, then changes this time
     manually into the past and then updates the note again.)
   </dd>
   <dt>saved</dt>
   <dd>
     A timestamp that holds the date and time when this version of the note
     was backed up by Evernote's servers.  This
   </dd>
   <dt>title</dt>
   <dd>
     The title of the note when this particular version was saved.  (The
     current title of the note may differ from this value.)
   </dd>
  </dl>
  
  Attributes:
   - updateSequenceNum
   - updated
   - saved
   - title
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ), # 1
    (2, TType.I64, 'updated', None, None, ), # 2
    (3, TType.I64, 'saved', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
  )

  def __init__(self, updateSequenceNum=None, updated=None, saved=None, title=None,):
    self.updateSequenceNum = updateSequenceNum
    self.updated = updated
    self.saved = saved
    self.title = title

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.saved = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteVersionId')
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 2)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.saved is not None:
      oprot.writeFieldBegin('saved', TType.I64, 3)
      oprot.writeI64(self.saved)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.updateSequenceNum is None:
      raise TProtocol.TProtocolException(message='Required field updateSequenceNum is unset!')
    if self.updated is None:
      raise TProtocol.TProtocolException(message='Required field updated is unset!')
    if self.saved is None:
      raise TProtocol.TProtocolException(message='Required field saved is unset!')
    if self.title is None:
      raise TProtocol.TProtocolException(message='Required field title is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClientUsageMetrics(object):
  """
  This structure is passed from clients to the Evernote service when they wish
  to relay coarse-grained usage metrics to the service to help improve
  products.
  
  <dl>
   <dt>sessions</dt>
   <dd>
     This field contains a count of the number of usage "sessions" that have
     occurred with this client which have not previously been reported to
     the service.
     A "session" is defined as one of the 96 fifteen-minute intervals of the
     day when someone used Evernote's interface at least once.
     So if a user interacts with an Evernote client at 12:18, 12:24, and 12:36,
     and then the client synchronizes at 12:39, it would report that there were
     two previously-unreported sessions (one session for the 12:15-12:30 time
     period, and one for the 12:30-12:45 period).
     If the user used Evernote again at 12:41 and synchronized at 12:43, it
     would not report any new sessions, because the 12:30-12:45 session had
     already been reported.
   </dd>
  </dl>
  
  Attributes:
   - sessions
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sessions', None, None, ), # 1
  )

  def __init__(self, sessions=None,):
    self.sessions = sessions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sessions = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClientUsageMetrics')
    if self.sessions is not None:
      oprot.writeFieldBegin('sessions', TType.I32, 1)
      oprot.writeI32(self.sessions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RelatedQuery(object):
  """
  A description of the thing for which we are searching for related
  entities.
  
  You must specify either <em>noteGuid</em> or <em>plainText</em>, but
  not both. <em>filter</em> and <em>referenceUri</em> are optional.
  
  <dl>
  <dt>noteGuid</dt>
  <dd>The GUID of an existing note in your account for which related
      entities will be found.</dd>
  
  <dt>plainText</dt>
  <dd>A string of plain text for which to find related entities.
      You should provide a text block with a number of characters between
      EDAM_RELATED_PLAINTEXT_LEN_MIN and EDAM_RELATED_PLAINTEXT_LEN_MAX.
      </dd>
  
  <dt>filter</dt>
  <dd>The list of criteria that will constrain the notes being considered
      related.
      Please note that some of the parameters may be ignored, such as
      <em>order</em> and <em>ascending</em>.
  </dd>
  
  <dt>referenceUri</dt>
  <dd>A URI string specifying a reference entity, around which "relatedness"
      should be based. This can be an URL pointing to a web page, for example.
  </dd>
  </dl>
  
  Attributes:
   - noteGuid
   - plainText
   - filter
   - referenceUri
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'noteGuid', None, None, ), # 1
    (2, TType.STRING, 'plainText', None, None, ), # 2
    (3, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 3
    (4, TType.STRING, 'referenceUri', None, None, ), # 4
  )

  def __init__(self, noteGuid=None, plainText=None, filter=None, referenceUri=None,):
    self.noteGuid = noteGuid
    self.plainText = plainText
    self.filter = filter
    self.referenceUri = referenceUri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.plainText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.referenceUri = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RelatedQuery')
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 1)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.plainText is not None:
      oprot.writeFieldBegin('plainText', TType.STRING, 2)
      oprot.writeString(self.plainText)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 3)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.referenceUri is not None:
      oprot.writeFieldBegin('referenceUri', TType.STRING, 4)
      oprot.writeString(self.referenceUri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RelatedResult(object):
  """
  The result of calling findRelated().  The contents of the notes,
  notebooks, and tags fields will be in decreasing order of expected
  relevance.  It is possible that fewer results than requested will be
  returned even if there are enough distinct entities in the account
  in cases where the relevance is estimated to be low.
  
  <dl>
  <dt>notes</dt>
  <dd>If notes have been requested to be included, this will be the
      list of notes.</dd>
  
  <dt>notebooks</dt>
  <dd>If notebooks have been requested to be included, this will be the
      list of notebooks.</dd>
  
  <dt>tags</dt>
  <dd>If tags have been requested to be included, this will be the list
      of tags.</dd>
  </dl>
  
  <dt>containingNotebooks</dt>
  <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
      in the RelatedResultSpec, return the list of notebooks to
      to which the returned related notes belong. The notebooks in this
      list will occur once per notebook GUID and are represented as
      NotebookDescriptor objects.</dd>
  </dl>
  </dl>
  
  Attributes:
   - notes
   - notebooks
   - tags
   - containingNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'notebooks', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'tags', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'containingNotebooks', (TType.STRUCT,(evernote.edam.type.ttypes.NotebookDescriptor, evernote.edam.type.ttypes.NotebookDescriptor.thrift_spec)), None, ), # 4
  )

  def __init__(self, notes=None, notebooks=None, tags=None, containingNotebooks=None,):
    self.notes = notes
    self.notebooks = notebooks
    self.tags = tags
    self.containingNotebooks = containingNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.notes = []
          (_etype168, _size165) = iprot.readListBegin()
          for _i169 in xrange(_size165):
            _elem170 = evernote.edam.type.ttypes.Note()
            _elem170.read(iprot)
            self.notes.append(_elem170)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.notebooks = []
          (_etype174, _size171) = iprot.readListBegin()
          for _i175 in xrange(_size171):
            _elem176 = evernote.edam.type.ttypes.Notebook()
            _elem176.read(iprot)
            self.notebooks.append(_elem176)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tags = []
          (_etype180, _size177) = iprot.readListBegin()
          for _i181 in xrange(_size177):
            _elem182 = evernote.edam.type.ttypes.Tag()
            _elem182.read(iprot)
            self.tags.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.containingNotebooks = []
          (_etype186, _size183) = iprot.readListBegin()
          for _i187 in xrange(_size183):
            _elem188 = evernote.edam.type.ttypes.NotebookDescriptor()
            _elem188.read(iprot)
            self.containingNotebooks.append(_elem188)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RelatedResult')
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter189 in self.notes:
        iter189.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.notebooks is not None:
      oprot.writeFieldBegin('notebooks', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
      for iter190 in self.notebooks:
        iter190.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter191 in self.tags:
        iter191.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.containingNotebooks is not None:
      oprot.writeFieldBegin('containingNotebooks', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.containingNotebooks))
      for iter192 in self.containingNotebooks:
        iter192.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RelatedResultSpec(object):
  """
  A description of the thing for which the service will find related
  entities, via findRelated(), together with a description of what
  type of entities and how many you are seeking in the
  RelatedResult.
  
  <dl>
  <dt>maxNotes</dt>
  <dd>Return notes that are related to the query, but no more than
      this many.  Any value greater than EDAM_RELATED_MAX_NOTES
      will be silently capped.  If you do not set this field, then
      no notes will be returned.</dd>
  
  <dt>maxNotebooks</dt>
  <dd>Return notebooks that are related to the query, but no more than
      this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
      will be silently capped.  If you do not set this field, then
      no notebooks will be returned.</dd>
  
  <dt>maxTags</dt>
  <dd>Return tags that are related to the query, but no more than
      this many.  Any value greater than EDAM_RELATED_MAX_TAGS
      will be silently capped.  If you do not set this field, then
      no tags will be returned.</dd>
  </dl>
  
  <dt>writableNotebooksOnly</dt>
  <dd>Require that all returned related notebooks are writable.
      The user will be able to create notes in all returned notebooks.
      However, individual notes returned may still belong to notebooks
      in which the user lacks the ability to create notes.</dd>
  </dl>
  
  <dt>includeContainingNotebooks</dt>
  <dd>If set to <code>true</code>, return the containingNotebooks field
      in the RelatedResult, which will contain the list of notebooks to
      to which the returned related notes belong.</dd>
  </dl>
  </dl>
  
  Attributes:
   - maxNotes
   - maxNotebooks
   - maxTags
   - writableNotebooksOnly
   - includeContainingNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'maxNotes', None, None, ), # 1
    (2, TType.I32, 'maxNotebooks', None, None, ), # 2
    (3, TType.I32, 'maxTags', None, None, ), # 3
    (4, TType.BOOL, 'writableNotebooksOnly', None, None, ), # 4
    (5, TType.BOOL, 'includeContainingNotebooks', None, None, ), # 5
  )

  def __init__(self, maxNotes=None, maxNotebooks=None, maxTags=None, writableNotebooksOnly=None, includeContainingNotebooks=None,):
    self.maxNotes = maxNotes
    self.maxNotebooks = maxNotebooks
    self.maxTags = maxTags
    self.writableNotebooksOnly = writableNotebooksOnly
    self.includeContainingNotebooks = includeContainingNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.maxNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxNotebooks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxTags = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.writableNotebooksOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeContainingNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RelatedResultSpec')
    if self.maxNotes is not None:
      oprot.writeFieldBegin('maxNotes', TType.I32, 1)
      oprot.writeI32(self.maxNotes)
      oprot.writeFieldEnd()
    if self.maxNotebooks is not None:
      oprot.writeFieldBegin('maxNotebooks', TType.I32, 2)
      oprot.writeI32(self.maxNotebooks)
      oprot.writeFieldEnd()
    if self.maxTags is not None:
      oprot.writeFieldBegin('maxTags', TType.I32, 3)
      oprot.writeI32(self.maxTags)
      oprot.writeFieldEnd()
    if self.writableNotebooksOnly is not None:
      oprot.writeFieldBegin('writableNotebooksOnly', TType.BOOL, 4)
      oprot.writeBool(self.writableNotebooksOnly)
      oprot.writeFieldEnd()
    if self.includeContainingNotebooks is not None:
      oprot.writeFieldBegin('includeContainingNotebooks', TType.BOOL, 5)
      oprot.writeBool(self.includeContainingNotebooks)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *

CLASSIFICATION_RECIPE_USER_NON_RECIPE = "000"
CLASSIFICATION_RECIPE_USER_RECIPE = "001"
CLASSIFICATION_RECIPE_SERVICE_RECIPE = "002"
EDAM_NOTE_SOURCE_WEB_CLIP = "web.clip"
EDAM_NOTE_SOURCE_MAIL_CLIP = "mail.clip"
EDAM_NOTE_SOURCE_MAIL_SMTP_GATEWAY = "mail.smtp"

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.limits.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class PrivilegeLevel(object):
  """
  This enumeration defines the possible permission levels for a user.
  Free accounts will have a level of NORMAL and paid Premium accounts
  will have a level of PREMIUM.
  """
  NORMAL = 1
  PREMIUM = 3
  VIP = 5
  MANAGER = 7
  SUPPORT = 8
  ADMIN = 9

  _VALUES_TO_NAMES = {
    1: "NORMAL",
    3: "PREMIUM",
    5: "VIP",
    7: "MANAGER",
    8: "SUPPORT",
    9: "ADMIN",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 1,
    "PREMIUM": 3,
    "VIP": 5,
    "MANAGER": 7,
    "SUPPORT": 8,
    "ADMIN": 9,
  }

class QueryFormat(object):
  """
  Every search query is specified as a sequence of characters.
  Currently, only the USER query format is supported.
  """
  USER = 1
  SEXP = 2

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "SEXP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "SEXP": 2,
  }

class NoteSortOrder(object):
  """
  This enumeration defines the possible sort ordering for notes when
  they are returned from a search result.
  """
  CREATED = 1
  UPDATED = 2
  RELEVANCE = 3
  UPDATE_SEQUENCE_NUMBER = 4
  TITLE = 5

  _VALUES_TO_NAMES = {
    1: "CREATED",
    2: "UPDATED",
    3: "RELEVANCE",
    4: "UPDATE_SEQUENCE_NUMBER",
    5: "TITLE",
  }

  _NAMES_TO_VALUES = {
    "CREATED": 1,
    "UPDATED": 2,
    "RELEVANCE": 3,
    "UPDATE_SEQUENCE_NUMBER": 4,
    "TITLE": 5,
  }

class PremiumOrderStatus(object):
  """
  This enumeration defines the possible states of a premium account
  
  NONE:    the user has never attempted to become a premium subscriber
  
  PENDING: the user has requested a premium account but their charge has not
    been confirmed
  
  ACTIVE:  the user has been charged and their premium account is in good
   standing
  
  FAILED:  the system attempted to charge the was denied. Their premium
    privileges have been revoked. We will periodically attempt to re-validate
    their order.
  
  CANCELLATION_PENDING: the user has requested that no further charges be made
    but the current account is still active.
  
  CANCELED: the premium account was canceled either because of failure to pay
    or user cancelation. No more attempts will be made to activate the account.
  """
  NONE = 0
  PENDING = 1
  ACTIVE = 2
  FAILED = 3
  CANCELLATION_PENDING = 4
  CANCELED = 5

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "PENDING",
    2: "ACTIVE",
    3: "FAILED",
    4: "CANCELLATION_PENDING",
    5: "CANCELED",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "PENDING": 1,
    "ACTIVE": 2,
    "FAILED": 3,
    "CANCELLATION_PENDING": 4,
    "CANCELED": 5,
  }

class SharedNotebookPrivilegeLevel(object):
  """
  Privilege levels for accessing shared notebooks.
  
  READ_NOTEBOOK: Recipient is able to read the contents of the shared notebook
    but does to have access to information about other recipients of the
    notebook or the activity stream information.
  
  MODIFY_NOTEBOOK_PLUS_ACTIVITY: Recipient has rights to read and modify the contents
    of the shared notebook, including the right to move notes to the trash and to create
    notes in the notebook.  The recipient can also access information about other
    recipients and the activity stream.
  
  READ_NOTEBOOK_PLUS_ACTIVITY: Recipient has READ_NOTEBOOK rights and can also
    access information about other recipients and the activity stream.
  
  GROUP: If the user belongs to a group, such as a Business, that has a defined
    privilege level, use the privilege level of the group as the privilege for
    the individual.
  
  FULL_ACCESS: Recipient has full rights to the shared notebook and recipient lists,
    including privilege to revoke and create invitations and to change privilege
    levels on invitations for individuals.  This privilege level is primarily intended
    for use by individual shares.
  
  BUSINESS_FULL_ACCESS: Intended for use with Business Notebooks, a
  BUSINESS_FULL_ACCESS level is FULL_ACCESS with the additional rights to
  change how the notebook will appear in the business library, including the
  rights to publish and unpublish the notebook from the library.
  """
  READ_NOTEBOOK = 0
  MODIFY_NOTEBOOK_PLUS_ACTIVITY = 1
  READ_NOTEBOOK_PLUS_ACTIVITY = 2
  GROUP = 3
  FULL_ACCESS = 4
  BUSINESS_FULL_ACCESS = 5

  _VALUES_TO_NAMES = {
    0: "READ_NOTEBOOK",
    1: "MODIFY_NOTEBOOK_PLUS_ACTIVITY",
    2: "READ_NOTEBOOK_PLUS_ACTIVITY",
    3: "GROUP",
    4: "FULL_ACCESS",
    5: "BUSINESS_FULL_ACCESS",
  }

  _NAMES_TO_VALUES = {
    "READ_NOTEBOOK": 0,
    "MODIFY_NOTEBOOK_PLUS_ACTIVITY": 1,
    "READ_NOTEBOOK_PLUS_ACTIVITY": 2,
    "GROUP": 3,
    "FULL_ACCESS": 4,
    "BUSINESS_FULL_ACCESS": 5,
  }

class SponsoredGroupRole(object):
  """
  Enumeration of the roles that a User can have within a sponsored group.
  
  GROUP_MEMBER: The user is a member of the group with no special privileges.
  
  GROUP_ADMIN: The user is an administrator within the group.
  
  GROUP_OWNER: The user is the owner of the group.
  """
  GROUP_MEMBER = 1
  GROUP_ADMIN = 2
  GROUP_OWNER = 3

  _VALUES_TO_NAMES = {
    1: "GROUP_MEMBER",
    2: "GROUP_ADMIN",
    3: "GROUP_OWNER",
  }

  _NAMES_TO_VALUES = {
    "GROUP_MEMBER": 1,
    "GROUP_ADMIN": 2,
    "GROUP_OWNER": 3,
  }

class BusinessUserRole(object):
  """
  Enumeration of the roles that a User can have within an Evernote Business account.
  
  ADMIN: The user is an administrator of the Evernote Business account.
  
  NORMAL: The user is a regular user within the Evernote Business account.
  """
  ADMIN = 1
  NORMAL = 2

  _VALUES_TO_NAMES = {
    1: "ADMIN",
    2: "NORMAL",
  }

  _NAMES_TO_VALUES = {
    "ADMIN": 1,
    "NORMAL": 2,
  }

class SharedNotebookInstanceRestrictions(object):
  """
  An enumeration describing restrictions on the domain of shared notebook
  instances that are valid for a given operation, as used, for example, in
  NotebookRestrictions.
  
  ONLY_JOINED_OR_PREVIEW: The domain consists of shared notebooks that
    "belong" to the recipient or still available for preview by any recipient.
    Shared notebooks that the recipient has joined (the username has already been
    assigned to our user) are in the domain.  Additionally, shared notebooks
    that allow preview and have not yet been joined are in the domain.
  
  NO_SHARED_NOTEBOOKS: No shared notebooks are applicable to the operation.
  """
  ONLY_JOINED_OR_PREVIEW = 1
  NO_SHARED_NOTEBOOKS = 2

  _VALUES_TO_NAMES = {
    1: "ONLY_JOINED_OR_PREVIEW",
    2: "NO_SHARED_NOTEBOOKS",
  }

  _NAMES_TO_VALUES = {
    "ONLY_JOINED_OR_PREVIEW": 1,
    "NO_SHARED_NOTEBOOKS": 2,
  }

class ReminderEmailConfig(object):
  """
  An enumeration describing the configuration state related to receiving
  reminder e-mails from the service.  Reminder e-mails summarize notes
  based on their Note.attributes.reminderTime values.
  
  DO_NOT_SEND: The user has selected to not receive reminder e-mail.
  
  SEND_DAILY_EMAIL: The user has selected to receive reminder e-mail for those
    days when there is a reminder.
  """
  DO_NOT_SEND = 1
  SEND_DAILY_EMAIL = 2

  _VALUES_TO_NAMES = {
    1: "DO_NOT_SEND",
    2: "SEND_DAILY_EMAIL",
  }

  _NAMES_TO_VALUES = {
    "DO_NOT_SEND": 1,
    "SEND_DAILY_EMAIL": 2,
  }


class Data(object):
  """
   In several places, EDAM exchanges blocks of bytes of data for a component
   which may be relatively large.  For example:  the contents of a clipped
   HTML note, the bytes of an embedded image, or the recognition XML for
   a large image.  This structure is used in the protocol to represent
   any of those large blocks of data when they are transmitted or when
   they are only referenced their metadata.
  
  <dl>
   <dt>bodyHash</dt>
     <dd>This field carries a one-way hash of the contents of the
     data body, in binary form.  The hash function is MD5<br/>
     Length:  EDAM_HASH_LEN (exactly)
     </dd>
  
   <dt>size</dt>
     <dd>The length, in bytes, of the data body.
     </dd>
  
   <dt>body</dt>
     <dd>This field is set to contain the binary contents of the data
     whenever the resource is being transferred.  If only metadata is
     being exchanged, this field will be empty.  For example, a client could
     notify the service about the change to an attribute for a resource
     without transmitting the binary resource contents.
     </dd>
   </dl>
  
  Attributes:
   - bodyHash
   - size
   - body
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bodyHash', None, None, ), # 1
    (2, TType.I32, 'size', None, None, ), # 2
    (3, TType.STRING, 'body', None, None, ), # 3
  )

  def __init__(self, bodyHash=None, size=None, body=None,):
    self.bodyHash = bodyHash
    self.size = size
    self.body = body

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bodyHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.body = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Data')
    if self.bodyHash is not None:
      oprot.writeFieldBegin('bodyHash', TType.STRING, 1)
      oprot.writeString(self.bodyHash)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I32, 2)
      oprot.writeI32(self.size)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRING, 3)
      oprot.writeString(self.body)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserAttributes(object):
  """
   A structure holding the optional attributes that can be stored
   on a User.  These are generally less critical than the core User fields.
  
  <dl>
   <dt>defaultLocationName</dt>
     <dd>the location string that should be associated
     with the user in order to determine where notes are taken if not otherwise
     specified.<br/>
     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>defaultLatitude</dt>
     <dd>if set, this is the latitude that should be
     assigned to any notes that have no other latitude information.
     </dd>
  
   <dt>defaultLongitude</dt>
     <dd>if set, this is the longitude that should be
     assigned to any notes that have no other longitude information.
     </dd>
  
   <dt>preactivation</dt>
     <dd>if set, the user account is not yet confirmed for
     login.  I.e. the account has been created, but we are still waiting for
     the user to complete the activation step.
     </dd>
  
   <dt>viewedPromotions</dt>
     <dd>a list of promotions the user has seen.
      This list may occasionally be modified by the system when promotions are
      no longer available.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>incomingEmailAddress</dt>
     <dd>if set, this is the email address that the
      user may send email to in order to add an email note directly into the
      account via the SMTP email gateway.  This is the part of the email
      address before the '@' symbol ... our domain is not included.
      If this is not set, the user may not add notes via the gateway.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>recentMailedAddresses</dt>
     <dd>if set, this will contain a list of email
      addresses that have recently been used as recipients
      of outbound emails by the user.  This can be used to pre-populate a
      list of possible destinations when a user wishes to send a note via
      email.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX each<br/>
      Max:  EDAM_USER_RECENT_MAILED_ADDRESSES_MAX entries
     </dd>
  
   <dt>comments</dt>
     <dd>Free-form text field that may hold general support
      information, etc.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>dateAgreedToTermsOfService</dt>
     <dd>The date/time when the user agreed to
      the terms of service.  This can be used as the effective "start date"
      for the account.
     </dd>
  
   <dt>maxReferrals</dt>
     <dd>The number of referrals that the user is permitted
      to make.
     </dd>
  
   <dt>referralCount</dt>
     <dd>The number of referrals sent from this account.
     </dd>
  
   <dt>refererCode</dt>
     <dd>A code indicating where the user was sent from. AKA
      promotion code
     </dd>
  
   <dt>sentEmailDate</dt>
     <dd>The most recent date when the user sent outbound
      emails from the service.  Used with sentEmailCount to limit the number
      of emails that can be sent per day.
     </dd>
  
   <dt>sentEmailCount</dt>
     <dd>The number of emails that were sent from the user
      via the service on sentEmailDate.  Used to enforce a limit on the number
      of emails per user per day to prevent spamming.
     </dd>
  
   <dt>dailyEmailLimit</dt>
     <dd>If set, this is the maximum number of emails that
      may be sent in a given day from this account.  If unset, the server will
      use the configured default limit.
     </dd>
  
   <dt>emailOptOutDate</dt>
     <dd>If set, this is the date when the user asked
      to be excluded from offers and promotions sent by Evernote.  If not set,
      then the user currently agrees to receive these messages.
     </dd>
  
   <dt>partnerEmailOptInDate</dt>
     <dd>If set, this is the date when the user asked
      to be included in offers and promotions sent by Evernote's partners.
      If not sent, then the user currently does not agree to receive these
      emails.
     </dd>
  
   <dt>preferredLanguage</dt>
     <dd>a 2 character language codes based on:
         http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt used for
        localization purposes to determine what language to use for the web
        interface and for other direct communication (e.g. emails).
     </dd>
  
   <dt>preferredCountry</dt>
     <dd>Preferred country code based on ISO 3166-1-alpha-2 indicating the
     users preferred country</dd>
  
   <dt>clipFullPage</dt>
     <dd>Boolean flag set to true if the user wants to clip full pages by
     default when they use the web clipper without a selection.</dd>
  
   <dt>twitterUserName</dt>
     <dd>The username of the account of someone who has chosen to enable
     Twittering into Evernote.  This value is subject to change, since users
     may change their Twitter user name.</dd>
  
   <dt>twitterId</dt>
     <dd>The unique identifier of the user's Twitter account if that user
     has chosen to enable Twittering into Evernote.</dd>
  
   <dt>groupName</dt>
     <dd>A name identifier used to identify a particular set of branding and
      light customization.</dd>
  
   <dt>recognitionLanguage</dt>
     <dd>a 2 character language codes based on:
         http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt
         If set, this is used to determine the language that should be used
         when processing images and PDF files to find text.
         If not set, then the 'preferredLanguage' will be used.
     </dd>
  
   <dt>educationalInstitution</dt>
     <dd>a flag indicating that the user is part of an educational institution which
     makes them eligible for discounts on bulk purchases
     </dd>
  
   <dt>businessAddress</dt>
     <dd>A string recording the business address of a Sponsored Account user who has requested invoicing.
     </dd>
  
   <dt>hideSponsorBilling</dt>
     <dd>A flag indicating whether to hide the billing information on a sponsored
         account owner's settings page
     </dd>
  
   <dt>taxExempt</dt>
     <dd>A flag indicating the user's sponsored group is exempt from sale tax
     </dd>
  
   <dt>useEmailAutoFiling</dt>
     <dd>A flag indicating whether the user chooses to allow Evernote to automatically
         file and tag emailed notes
     </dd>
  
   <dt>reminderEmailConfig</dt>
     <dd>Configuration state for whether or not the user wishes to receive
         reminder e-mail.  This setting applies to both the reminder e-mail sent
         for personal reminder notes and for the reminder e-mail sent for reminder
         notes in the user's business notebooks that the user has configured for
         e-mail notifications.
     </dd>
   </dl>
  
  Attributes:
   - defaultLocationName
   - defaultLatitude
   - defaultLongitude
   - preactivation
   - viewedPromotions
   - incomingEmailAddress
   - recentMailedAddresses
   - comments
   - dateAgreedToTermsOfService
   - maxReferrals
   - referralCount
   - refererCode
   - sentEmailDate
   - sentEmailCount
   - dailyEmailLimit
   - emailOptOutDate
   - partnerEmailOptInDate
   - preferredLanguage
   - preferredCountry
   - clipFullPage
   - twitterUserName
   - twitterId
   - groupName
   - recognitionLanguage
   - referralProof
   - educationalDiscount
   - businessAddress
   - hideSponsorBilling
   - taxExempt
   - useEmailAutoFiling
   - reminderEmailConfig
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'defaultLocationName', None, None, ), # 1
    (2, TType.DOUBLE, 'defaultLatitude', None, None, ), # 2
    (3, TType.DOUBLE, 'defaultLongitude', None, None, ), # 3
    (4, TType.BOOL, 'preactivation', None, None, ), # 4
    (5, TType.LIST, 'viewedPromotions', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'incomingEmailAddress', None, None, ), # 6
    (7, TType.LIST, 'recentMailedAddresses', (TType.STRING,None), None, ), # 7
    None, # 8
    (9, TType.STRING, 'comments', None, None, ), # 9
    None, # 10
    (11, TType.I64, 'dateAgreedToTermsOfService', None, None, ), # 11
    (12, TType.I32, 'maxReferrals', None, None, ), # 12
    (13, TType.I32, 'referralCount', None, None, ), # 13
    (14, TType.STRING, 'refererCode', None, None, ), # 14
    (15, TType.I64, 'sentEmailDate', None, None, ), # 15
    (16, TType.I32, 'sentEmailCount', None, None, ), # 16
    (17, TType.I32, 'dailyEmailLimit', None, None, ), # 17
    (18, TType.I64, 'emailOptOutDate', None, None, ), # 18
    (19, TType.I64, 'partnerEmailOptInDate', None, None, ), # 19
    (20, TType.STRING, 'preferredLanguage', None, None, ), # 20
    (21, TType.STRING, 'preferredCountry', None, None, ), # 21
    (22, TType.BOOL, 'clipFullPage', None, None, ), # 22
    (23, TType.STRING, 'twitterUserName', None, None, ), # 23
    (24, TType.STRING, 'twitterId', None, None, ), # 24
    (25, TType.STRING, 'groupName', None, None, ), # 25
    (26, TType.STRING, 'recognitionLanguage', None, None, ), # 26
    None, # 27
    (28, TType.STRING, 'referralProof', None, None, ), # 28
    (29, TType.BOOL, 'educationalDiscount', None, None, ), # 29
    (30, TType.STRING, 'businessAddress', None, None, ), # 30
    (31, TType.BOOL, 'hideSponsorBilling', None, None, ), # 31
    (32, TType.BOOL, 'taxExempt', None, None, ), # 32
    (33, TType.BOOL, 'useEmailAutoFiling', None, None, ), # 33
    (34, TType.I32, 'reminderEmailConfig', None, None, ), # 34
  )

  def __init__(self, defaultLocationName=None, defaultLatitude=None, defaultLongitude=None, preactivation=None, viewedPromotions=None, incomingEmailAddress=None, recentMailedAddresses=None, comments=None, dateAgreedToTermsOfService=None, maxReferrals=None, referralCount=None, refererCode=None, sentEmailDate=None, sentEmailCount=None, dailyEmailLimit=None, emailOptOutDate=None, partnerEmailOptInDate=None, preferredLanguage=None, preferredCountry=None, clipFullPage=None, twitterUserName=None, twitterId=None, groupName=None, recognitionLanguage=None, referralProof=None, educationalDiscount=None, businessAddress=None, hideSponsorBilling=None, taxExempt=None, useEmailAutoFiling=None, reminderEmailConfig=None,):
    self.defaultLocationName = defaultLocationName
    self.defaultLatitude = defaultLatitude
    self.defaultLongitude = defaultLongitude
    self.preactivation = preactivation
    self.viewedPromotions = viewedPromotions
    self.incomingEmailAddress = incomingEmailAddress
    self.recentMailedAddresses = recentMailedAddresses
    self.comments = comments
    self.dateAgreedToTermsOfService = dateAgreedToTermsOfService
    self.maxReferrals = maxReferrals
    self.referralCount = referralCount
    self.refererCode = refererCode
    self.sentEmailDate = sentEmailDate
    self.sentEmailCount = sentEmailCount
    self.dailyEmailLimit = dailyEmailLimit
    self.emailOptOutDate = emailOptOutDate
    self.partnerEmailOptInDate = partnerEmailOptInDate
    self.preferredLanguage = preferredLanguage
    self.preferredCountry = preferredCountry
    self.clipFullPage = clipFullPage
    self.twitterUserName = twitterUserName
    self.twitterId = twitterId
    self.groupName = groupName
    self.recognitionLanguage = recognitionLanguage
    self.referralProof = referralProof
    self.educationalDiscount = educationalDiscount
    self.businessAddress = businessAddress
    self.hideSponsorBilling = hideSponsorBilling
    self.taxExempt = taxExempt
    self.useEmailAutoFiling = useEmailAutoFiling
    self.reminderEmailConfig = reminderEmailConfig

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.defaultLocationName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.defaultLatitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.defaultLongitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.preactivation = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.viewedPromotions = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.viewedPromotions.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.incomingEmailAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.recentMailedAddresses = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readString();
            self.recentMailedAddresses.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.dateAgreedToTermsOfService = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.maxReferrals = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.referralCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.refererCode = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.sentEmailDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I32:
          self.sentEmailCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I32:
          self.dailyEmailLimit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I64:
          self.emailOptOutDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I64:
          self.partnerEmailOptInDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.preferredLanguage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.preferredCountry = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.BOOL:
          self.clipFullPage = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.twitterUserName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.twitterId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRING:
          self.groupName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.STRING:
          self.recognitionLanguage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.STRING:
          self.referralProof = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.BOOL:
          self.educationalDiscount = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRING:
          self.businessAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.BOOL:
          self.hideSponsorBilling = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.BOOL:
          self.taxExempt = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 33:
        if ftype == TType.BOOL:
          self.useEmailAutoFiling = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 34:
        if ftype == TType.I32:
          self.reminderEmailConfig = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserAttributes')
    if self.defaultLocationName is not None:
      oprot.writeFieldBegin('defaultLocationName', TType.STRING, 1)
      oprot.writeString(self.defaultLocationName)
      oprot.writeFieldEnd()
    if self.defaultLatitude is not None:
      oprot.writeFieldBegin('defaultLatitude', TType.DOUBLE, 2)
      oprot.writeDouble(self.defaultLatitude)
      oprot.writeFieldEnd()
    if self.defaultLongitude is not None:
      oprot.writeFieldBegin('defaultLongitude', TType.DOUBLE, 3)
      oprot.writeDouble(self.defaultLongitude)
      oprot.writeFieldEnd()
    if self.preactivation is not None:
      oprot.writeFieldBegin('preactivation', TType.BOOL, 4)
      oprot.writeBool(self.preactivation)
      oprot.writeFieldEnd()
    if self.viewedPromotions is not None:
      oprot.writeFieldBegin('viewedPromotions', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.viewedPromotions))
      for iter12 in self.viewedPromotions:
        oprot.writeString(iter12)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.incomingEmailAddress is not None:
      oprot.writeFieldBegin('incomingEmailAddress', TType.STRING, 6)
      oprot.writeString(self.incomingEmailAddress)
      oprot.writeFieldEnd()
    if self.recentMailedAddresses is not None:
      oprot.writeFieldBegin('recentMailedAddresses', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.recentMailedAddresses))
      for iter13 in self.recentMailedAddresses:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 9)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    if self.dateAgreedToTermsOfService is not None:
      oprot.writeFieldBegin('dateAgreedToTermsOfService', TType.I64, 11)
      oprot.writeI64(self.dateAgreedToTermsOfService)
      oprot.writeFieldEnd()
    if self.maxReferrals is not None:
      oprot.writeFieldBegin('maxReferrals', TType.I32, 12)
      oprot.writeI32(self.maxReferrals)
      oprot.writeFieldEnd()
    if self.referralCount is not None:
      oprot.writeFieldBegin('referralCount', TType.I32, 13)
      oprot.writeI32(self.referralCount)
      oprot.writeFieldEnd()
    if self.refererCode is not None:
      oprot.writeFieldBegin('refererCode', TType.STRING, 14)
      oprot.writeString(self.refererCode)
      oprot.writeFieldEnd()
    if self.sentEmailDate is not None:
      oprot.writeFieldBegin('sentEmailDate', TType.I64, 15)
      oprot.writeI64(self.sentEmailDate)
      oprot.writeFieldEnd()
    if self.sentEmailCount is not None:
      oprot.writeFieldBegin('sentEmailCount', TType.I32, 16)
      oprot.writeI32(self.sentEmailCount)
      oprot.writeFieldEnd()
    if self.dailyEmailLimit is not None:
      oprot.writeFieldBegin('dailyEmailLimit', TType.I32, 17)
      oprot.writeI32(self.dailyEmailLimit)
      oprot.writeFieldEnd()
    if self.emailOptOutDate is not None:
      oprot.writeFieldBegin('emailOptOutDate', TType.I64, 18)
      oprot.writeI64(self.emailOptOutDate)
      oprot.writeFieldEnd()
    if self.partnerEmailOptInDate is not None:
      oprot.writeFieldBegin('partnerEmailOptInDate', TType.I64, 19)
      oprot.writeI64(self.partnerEmailOptInDate)
      oprot.writeFieldEnd()
    if self.preferredLanguage is not None:
      oprot.writeFieldBegin('preferredLanguage', TType.STRING, 20)
      oprot.writeString(self.preferredLanguage)
      oprot.writeFieldEnd()
    if self.preferredCountry is not None:
      oprot.writeFieldBegin('preferredCountry', TType.STRING, 21)
      oprot.writeString(self.preferredCountry)
      oprot.writeFieldEnd()
    if self.clipFullPage is not None:
      oprot.writeFieldBegin('clipFullPage', TType.BOOL, 22)
      oprot.writeBool(self.clipFullPage)
      oprot.writeFieldEnd()
    if self.twitterUserName is not None:
      oprot.writeFieldBegin('twitterUserName', TType.STRING, 23)
      oprot.writeString(self.twitterUserName)
      oprot.writeFieldEnd()
    if self.twitterId is not None:
      oprot.writeFieldBegin('twitterId', TType.STRING, 24)
      oprot.writeString(self.twitterId)
      oprot.writeFieldEnd()
    if self.groupName is not None:
      oprot.writeFieldBegin('groupName', TType.STRING, 25)
      oprot.writeString(self.groupName)
      oprot.writeFieldEnd()
    if self.recognitionLanguage is not None:
      oprot.writeFieldBegin('recognitionLanguage', TType.STRING, 26)
      oprot.writeString(self.recognitionLanguage)
      oprot.writeFieldEnd()
    if self.referralProof is not None:
      oprot.writeFieldBegin('referralProof', TType.STRING, 28)
      oprot.writeString(self.referralProof)
      oprot.writeFieldEnd()
    if self.educationalDiscount is not None:
      oprot.writeFieldBegin('educationalDiscount', TType.BOOL, 29)
      oprot.writeBool(self.educationalDiscount)
      oprot.writeFieldEnd()
    if self.businessAddress is not None:
      oprot.writeFieldBegin('businessAddress', TType.STRING, 30)
      oprot.writeString(self.businessAddress)
      oprot.writeFieldEnd()
    if self.hideSponsorBilling is not None:
      oprot.writeFieldBegin('hideSponsorBilling', TType.BOOL, 31)
      oprot.writeBool(self.hideSponsorBilling)
      oprot.writeFieldEnd()
    if self.taxExempt is not None:
      oprot.writeFieldBegin('taxExempt', TType.BOOL, 32)
      oprot.writeBool(self.taxExempt)
      oprot.writeFieldEnd()
    if self.useEmailAutoFiling is not None:
      oprot.writeFieldBegin('useEmailAutoFiling', TType.BOOL, 33)
      oprot.writeBool(self.useEmailAutoFiling)
      oprot.writeFieldEnd()
    if self.reminderEmailConfig is not None:
      oprot.writeFieldBegin('reminderEmailConfig', TType.I32, 34)
      oprot.writeI32(self.reminderEmailConfig)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Accounting(object):
  """
   This represents the bookkeeping information for the user's subscription.
  
  <dl>
   <dt>uploadLimit</dt>
     <dd>The number of bytes that can be uploaded to the account
     in the current month.  For new notes that are created, this is the length
     of the note content (in Unicode characters) plus the size of each resource
     (in bytes).  For edited notes, this is the the difference between the old
     length and the new length (if this is greater than 0) plus the size of
     each new resource.
     </dd>
   <dt>uploadLimitEnd</dt>
     <dd>The date and time when the current upload limit
     expires.  At this time, the monthly upload count reverts to 0 and a new
     limit is imposed.  This date and time is exclusive, so this is effectively
     the start of the new month.
     </dd>
   <dt>uploadLimitNextMonth</dt>
     <dd> When uploadLimitEnd is reached, the service
     will change uploadLimit to uploadLimitNextMonth. If a premium account is
     canceled, this mechanism will reset the quota appropriately.
     </dd>
   <dt>premiumServiceStatus</dt>
     <dd>Indicates the phases of a premium account
     during the billing process.
     </dd>
   <dt>premiumOrderNumber</dt>
     <dd>The order number used by the commerce system to
     process recurring payments
     </dd>
   <dt>premiumServiceStart</dt>
     <dd>The start date when this premium promotion
     began (this number will get overwritten if a premium service is canceled
     and then re-activated).
     </dd>
   <dt>premiumCommerceService</dt>
     <dd>The commerce system used (paypal, Google
     checkout, etc)
     </dd>
   <dt>premiumServiceSKU</dt>
     <dd>The code associated with the purchase eg. monthly
     or annual purchase. Clients should interpret this value and localize it.
     </dd>
   <dt>lastSuccessfulCharge</dt>
     <dd>Date the last time the user was charged.
     Null if never charged.
     </dd>
   <dt>lastFailedCharge</dt>
     <dd>Date the last time a charge was attempted and
     failed.
     </dd>
   <dt>lastFailedChargeReason</dt>
     <dd>Reason provided for the charge failure
     </dd>
   <dt>nextPaymentDue</dt>
     <dd>The end of the billing cycle. This could be in the
     past if there are failed charges.
     </dd>
   <dt>premiumLockUntil</dt>
     <dd>An internal variable to manage locking operations
     on the commerce variables.
     </dd>
   <dt>updated</dt>
     <dd>The date any modification where made to this record.
     </dd>
   <dt>premiumSubscriptionNumber</dt>
     <dd>The number number identifying the
     recurring subscription used to make the recurring charges.
     </dd>
   <dt>lastRequestedCharge</dt>
     <dd>Date charge last attempted</dd>
   <dt>currency</dt>
     <dd>ISO 4217 currency code</dd>
   <dt>unitPrice</dt>
     <dd>charge in the smallest unit of the currency (e.g. cents for USD)</dd>
   <dt>businessId</dt>
     <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
   <dt>businessName</dt>
     <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
   <dt>businessRole</dt>
     <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
   <dt>unitDiscount</dt>
     <dd>discount per seat in negative amount and smallest unit of the currency (e.g. cents for USD)</dd>
   <dt>nextChargeDate</dt>
     <dd>The next time the user will be charged, may or may not be the same as nextPaymentDue</dd>
   </dl>
  
  Attributes:
   - uploadLimit
   - uploadLimitEnd
   - uploadLimitNextMonth
   - premiumServiceStatus
   - premiumOrderNumber
   - premiumCommerceService
   - premiumServiceStart
   - premiumServiceSKU
   - lastSuccessfulCharge
   - lastFailedCharge
   - lastFailedChargeReason
   - nextPaymentDue
   - premiumLockUntil
   - updated
   - premiumSubscriptionNumber
   - lastRequestedCharge
   - currency
   - unitPrice
   - businessId
   - businessName
   - businessRole
   - unitDiscount
   - nextChargeDate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'uploadLimit', None, None, ), # 1
    (2, TType.I64, 'uploadLimitEnd', None, None, ), # 2
    (3, TType.I64, 'uploadLimitNextMonth', None, None, ), # 3
    (4, TType.I32, 'premiumServiceStatus', None, None, ), # 4
    (5, TType.STRING, 'premiumOrderNumber', None, None, ), # 5
    (6, TType.STRING, 'premiumCommerceService', None, None, ), # 6
    (7, TType.I64, 'premiumServiceStart', None, None, ), # 7
    (8, TType.STRING, 'premiumServiceSKU', None, None, ), # 8
    (9, TType.I64, 'lastSuccessfulCharge', None, None, ), # 9
    (10, TType.I64, 'lastFailedCharge', None, None, ), # 10
    (11, TType.STRING, 'lastFailedChargeReason', None, None, ), # 11
    (12, TType.I64, 'nextPaymentDue', None, None, ), # 12
    (13, TType.I64, 'premiumLockUntil', None, None, ), # 13
    (14, TType.I64, 'updated', None, None, ), # 14
    None, # 15
    (16, TType.STRING, 'premiumSubscriptionNumber', None, None, ), # 16
    (17, TType.I64, 'lastRequestedCharge', None, None, ), # 17
    (18, TType.STRING, 'currency', None, None, ), # 18
    (19, TType.I32, 'unitPrice', None, None, ), # 19
    (20, TType.I32, 'businessId', None, None, ), # 20
    (21, TType.STRING, 'businessName', None, None, ), # 21
    (22, TType.I32, 'businessRole', None, None, ), # 22
    (23, TType.I32, 'unitDiscount', None, None, ), # 23
    (24, TType.I64, 'nextChargeDate', None, None, ), # 24
  )

  def __init__(self, uploadLimit=None, uploadLimitEnd=None, uploadLimitNextMonth=None, premiumServiceStatus=None, premiumOrderNumber=None, premiumCommerceService=None, premiumServiceStart=None, premiumServiceSKU=None, lastSuccessfulCharge=None, lastFailedCharge=None, lastFailedChargeReason=None, nextPaymentDue=None, premiumLockUntil=None, updated=None, premiumSubscriptionNumber=None, lastRequestedCharge=None, currency=None, unitPrice=None, businessId=None, businessName=None, businessRole=None, unitDiscount=None, nextChargeDate=None,):
    self.uploadLimit = uploadLimit
    self.uploadLimitEnd = uploadLimitEnd
    self.uploadLimitNextMonth = uploadLimitNextMonth
    self.premiumServiceStatus = premiumServiceStatus
    self.premiumOrderNumber = premiumOrderNumber
    self.premiumCommerceService = premiumCommerceService
    self.premiumServiceStart = premiumServiceStart
    self.premiumServiceSKU = premiumServiceSKU
    self.lastSuccessfulCharge = lastSuccessfulCharge
    self.lastFailedCharge = lastFailedCharge
    self.lastFailedChargeReason = lastFailedChargeReason
    self.nextPaymentDue = nextPaymentDue
    self.premiumLockUntil = premiumLockUntil
    self.updated = updated
    self.premiumSubscriptionNumber = premiumSubscriptionNumber
    self.lastRequestedCharge = lastRequestedCharge
    self.currency = currency
    self.unitPrice = unitPrice
    self.businessId = businessId
    self.businessName = businessName
    self.businessRole = businessRole
    self.unitDiscount = unitDiscount
    self.nextChargeDate = nextChargeDate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.uploadLimit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.uploadLimitEnd = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.uploadLimitNextMonth = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.premiumServiceStatus = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.premiumOrderNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.premiumCommerceService = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.premiumServiceStart = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.premiumServiceSKU = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.lastSuccessfulCharge = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.lastFailedCharge = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.lastFailedChargeReason = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.nextPaymentDue = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.premiumLockUntil = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.premiumSubscriptionNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.lastRequestedCharge = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.currency = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I32:
          self.unitPrice = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I32:
          self.businessId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.businessName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.I32:
          self.businessRole = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.I32:
          self.unitDiscount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.I64:
          self.nextChargeDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Accounting')
    if self.uploadLimit is not None:
      oprot.writeFieldBegin('uploadLimit', TType.I64, 1)
      oprot.writeI64(self.uploadLimit)
      oprot.writeFieldEnd()
    if self.uploadLimitEnd is not None:
      oprot.writeFieldBegin('uploadLimitEnd', TType.I64, 2)
      oprot.writeI64(self.uploadLimitEnd)
      oprot.writeFieldEnd()
    if self.uploadLimitNextMonth is not None:
      oprot.writeFieldBegin('uploadLimitNextMonth', TType.I64, 3)
      oprot.writeI64(self.uploadLimitNextMonth)
      oprot.writeFieldEnd()
    if self.premiumServiceStatus is not None:
      oprot.writeFieldBegin('premiumServiceStatus', TType.I32, 4)
      oprot.writeI32(self.premiumServiceStatus)
      oprot.writeFieldEnd()
    if self.premiumOrderNumber is not None:
      oprot.writeFieldBegin('premiumOrderNumber', TType.STRING, 5)
      oprot.writeString(self.premiumOrderNumber)
      oprot.writeFieldEnd()
    if self.premiumCommerceService is not None:
      oprot.writeFieldBegin('premiumCommerceService', TType.STRING, 6)
      oprot.writeString(self.premiumCommerceService)
      oprot.writeFieldEnd()
    if self.premiumServiceStart is not None:
      oprot.writeFieldBegin('premiumServiceStart', TType.I64, 7)
      oprot.writeI64(self.premiumServiceStart)
      oprot.writeFieldEnd()
    if self.premiumServiceSKU is not None:
      oprot.writeFieldBegin('premiumServiceSKU', TType.STRING, 8)
      oprot.writeString(self.premiumServiceSKU)
      oprot.writeFieldEnd()
    if self.lastSuccessfulCharge is not None:
      oprot.writeFieldBegin('lastSuccessfulCharge', TType.I64, 9)
      oprot.writeI64(self.lastSuccessfulCharge)
      oprot.writeFieldEnd()
    if self.lastFailedCharge is not None:
      oprot.writeFieldBegin('lastFailedCharge', TType.I64, 10)
      oprot.writeI64(self.lastFailedCharge)
      oprot.writeFieldEnd()
    if self.lastFailedChargeReason is not None:
      oprot.writeFieldBegin('lastFailedChargeReason', TType.STRING, 11)
      oprot.writeString(self.lastFailedChargeReason)
      oprot.writeFieldEnd()
    if self.nextPaymentDue is not None:
      oprot.writeFieldBegin('nextPaymentDue', TType.I64, 12)
      oprot.writeI64(self.nextPaymentDue)
      oprot.writeFieldEnd()
    if self.premiumLockUntil is not None:
      oprot.writeFieldBegin('premiumLockUntil', TType.I64, 13)
      oprot.writeI64(self.premiumLockUntil)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 14)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.premiumSubscriptionNumber is not None:
      oprot.writeFieldBegin('premiumSubscriptionNumber', TType.STRING, 16)
      oprot.writeString(self.premiumSubscriptionNumber)
      oprot.writeFieldEnd()
    if self.lastRequestedCharge is not None:
      oprot.writeFieldBegin('lastRequestedCharge', TType.I64, 17)
      oprot.writeI64(self.lastRequestedCharge)
      oprot.writeFieldEnd()
    if self.currency is not None:
      oprot.writeFieldBegin('currency', TType.STRING, 18)
      oprot.writeString(self.currency)
      oprot.writeFieldEnd()
    if self.unitPrice is not None:
      oprot.writeFieldBegin('unitPrice', TType.I32, 19)
      oprot.writeI32(self.unitPrice)
      oprot.writeFieldEnd()
    if self.businessId is not None:
      oprot.writeFieldBegin('businessId', TType.I32, 20)
      oprot.writeI32(self.businessId)
      oprot.writeFieldEnd()
    if self.businessName is not None:
      oprot.writeFieldBegin('businessName', TType.STRING, 21)
      oprot.writeString(self.businessName)
      oprot.writeFieldEnd()
    if self.businessRole is not None:
      oprot.writeFieldBegin('businessRole', TType.I32, 22)
      oprot.writeI32(self.businessRole)
      oprot.writeFieldEnd()
    if self.unitDiscount is not None:
      oprot.writeFieldBegin('unitDiscount', TType.I32, 23)
      oprot.writeI32(self.unitDiscount)
      oprot.writeFieldEnd()
    if self.nextChargeDate is not None:
      oprot.writeFieldBegin('nextChargeDate', TType.I64, 24)
      oprot.writeI64(self.nextChargeDate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BusinessUserInfo(object):
  """
  This structure is used to provide information about an Evernote Business
  membership, for members who are part of a business.
  
  <dl>
  <dt>businessId</dt>
    <dd>The ID of the Evernote Business account that the user is a member of.
  <dt>businessName</dt>
    <dd>The human-readable name of the Evernote Business account that the user
        is a member of.</dd>
  <dt>role</dt>
    <dd>The role of the user within the Evernote Business account that
        they are a member of.</dd>
  <dt>email</dt>
    <dd>An e-mail address that will be used by the service in the context of your
        Evernote Business activities.  For example, this e-mail address will be used
        when you e-mail a business note, when you update notes in the account of
        your business, etc.  The business e-mail cannot be used for identification
        purposes such as for logging into the service.
    </dd>
  </dl>
  
  Attributes:
   - businessId
   - businessName
   - role
   - email
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'businessId', None, None, ), # 1
    (2, TType.STRING, 'businessName', None, None, ), # 2
    (3, TType.I32, 'role', None, None, ), # 3
    (4, TType.STRING, 'email', None, None, ), # 4
  )

  def __init__(self, businessId=None, businessName=None, role=None, email=None,):
    self.businessId = businessId
    self.businessName = businessName
    self.role = role
    self.email = email

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.businessId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.businessName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.role = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.email = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BusinessUserInfo')
    if self.businessId is not None:
      oprot.writeFieldBegin('businessId', TType.I32, 1)
      oprot.writeI32(self.businessId)
      oprot.writeFieldEnd()
    if self.businessName is not None:
      oprot.writeFieldBegin('businessName', TType.STRING, 2)
      oprot.writeString(self.businessName)
      oprot.writeFieldEnd()
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.I32, 3)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 4)
      oprot.writeString(self.email)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PremiumInfo(object):
  """
   This structure is used to provide information about a user's Premium account.
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server-side date and time when this data was generated.
     </dd>
   <dt>premium</dt>
     <dd>
     True if the user's account is Premium.
     </dd>
   <dt>premiumRecurring</dt>
     <dd>
     True if the user's account is Premium and has a recurring payment method.
     </dd>
   <dt>premiumExpirationDate</dt>
     <dd>
     The date when the user's Premium account expires, or the date when the
     user's account is due for payment if it has a recurring payment method.
     </dd>
   <dt>premiumExtendable</dt>
     <dd>
     True if the user is eligible for purchasing Premium account extensions.
     </dd>
   <dt>premiumPending</dt>
     <dd>
     True if the user's Premium account is pending payment confirmation
     </dd>
   <dt>premiumCancellationPending</dt>
     <dd>
     True if the user has requested that no further charges to be made; the
     Premium account will remain active until it expires.
     </dd>
   <dt>canPurchaseUploadAllowance</dt>
     <dd>
     True if the user is eligible for purchasing additional upload allowance.
     </dd>
   <dt>sponsoredGroupName</dt>
     <dd>
     The name of the sponsored group that the user is part of.
     </dd>
   <dt>sponsoredGroupRole</dt>
     <dd>
     DEPRECATED - will be removed in a future update.
     </dd>
   <dt>premiumUpgradable</dt>
     <dd>
     True if the user is eligible for purchasing Premium account upgrade.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - premium
   - premiumRecurring
   - premiumExpirationDate
   - premiumExtendable
   - premiumPending
   - premiumCancellationPending
   - canPurchaseUploadAllowance
   - sponsoredGroupName
   - sponsoredGroupRole
   - premiumUpgradable
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.BOOL, 'premium', None, None, ), # 2
    (3, TType.BOOL, 'premiumRecurring', None, None, ), # 3
    (4, TType.I64, 'premiumExpirationDate', None, None, ), # 4
    (5, TType.BOOL, 'premiumExtendable', None, None, ), # 5
    (6, TType.BOOL, 'premiumPending', None, None, ), # 6
    (7, TType.BOOL, 'premiumCancellationPending', None, None, ), # 7
    (8, TType.BOOL, 'canPurchaseUploadAllowance', None, None, ), # 8
    (9, TType.STRING, 'sponsoredGroupName', None, None, ), # 9
    (10, TType.I32, 'sponsoredGroupRole', None, None, ), # 10
    (11, TType.BOOL, 'premiumUpgradable', None, None, ), # 11
  )

  def __init__(self, currentTime=None, premium=None, premiumRecurring=None, premiumExpirationDate=None, premiumExtendable=None, premiumPending=None, premiumCancellationPending=None, canPurchaseUploadAllowance=None, sponsoredGroupName=None, sponsoredGroupRole=None, premiumUpgradable=None,):
    self.currentTime = currentTime
    self.premium = premium
    self.premiumRecurring = premiumRecurring
    self.premiumExpirationDate = premiumExpirationDate
    self.premiumExtendable = premiumExtendable
    self.premiumPending = premiumPending
    self.premiumCancellationPending = premiumCancellationPending
    self.canPurchaseUploadAllowance = canPurchaseUploadAllowance
    self.sponsoredGroupName = sponsoredGroupName
    self.sponsoredGroupRole = sponsoredGroupRole
    self.premiumUpgradable = premiumUpgradable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.premium = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.premiumRecurring = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.premiumExpirationDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.premiumExtendable = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.premiumPending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.premiumCancellationPending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.canPurchaseUploadAllowance = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.sponsoredGroupName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.sponsoredGroupRole = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.premiumUpgradable = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PremiumInfo')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.premium is not None:
      oprot.writeFieldBegin('premium', TType.BOOL, 2)
      oprot.writeBool(self.premium)
      oprot.writeFieldEnd()
    if self.premiumRecurring is not None:
      oprot.writeFieldBegin('premiumRecurring', TType.BOOL, 3)
      oprot.writeBool(self.premiumRecurring)
      oprot.writeFieldEnd()
    if self.premiumExpirationDate is not None:
      oprot.writeFieldBegin('premiumExpirationDate', TType.I64, 4)
      oprot.writeI64(self.premiumExpirationDate)
      oprot.writeFieldEnd()
    if self.premiumExtendable is not None:
      oprot.writeFieldBegin('premiumExtendable', TType.BOOL, 5)
      oprot.writeBool(self.premiumExtendable)
      oprot.writeFieldEnd()
    if self.premiumPending is not None:
      oprot.writeFieldBegin('premiumPending', TType.BOOL, 6)
      oprot.writeBool(self.premiumPending)
      oprot.writeFieldEnd()
    if self.premiumCancellationPending is not None:
      oprot.writeFieldBegin('premiumCancellationPending', TType.BOOL, 7)
      oprot.writeBool(self.premiumCancellationPending)
      oprot.writeFieldEnd()
    if self.canPurchaseUploadAllowance is not None:
      oprot.writeFieldBegin('canPurchaseUploadAllowance', TType.BOOL, 8)
      oprot.writeBool(self.canPurchaseUploadAllowance)
      oprot.writeFieldEnd()
    if self.sponsoredGroupName is not None:
      oprot.writeFieldBegin('sponsoredGroupName', TType.STRING, 9)
      oprot.writeString(self.sponsoredGroupName)
      oprot.writeFieldEnd()
    if self.sponsoredGroupRole is not None:
      oprot.writeFieldBegin('sponsoredGroupRole', TType.I32, 10)
      oprot.writeI32(self.sponsoredGroupRole)
      oprot.writeFieldEnd()
    if self.premiumUpgradable is not None:
      oprot.writeFieldBegin('premiumUpgradable', TType.BOOL, 11)
      oprot.writeBool(self.premiumUpgradable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.premium is None:
      raise TProtocol.TProtocolException(message='Required field premium is unset!')
    if self.premiumRecurring is None:
      raise TProtocol.TProtocolException(message='Required field premiumRecurring is unset!')
    if self.premiumExtendable is None:
      raise TProtocol.TProtocolException(message='Required field premiumExtendable is unset!')
    if self.premiumPending is None:
      raise TProtocol.TProtocolException(message='Required field premiumPending is unset!')
    if self.premiumCancellationPending is None:
      raise TProtocol.TProtocolException(message='Required field premiumCancellationPending is unset!')
    if self.canPurchaseUploadAllowance is None:
      raise TProtocol.TProtocolException(message='Required field canPurchaseUploadAllowance is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User(object):
  """
   This represents the information about a single user account.
  <dl>
   <dt>id</dt>
     <dd>The unique numeric identifier for the account, which will not
     change for the lifetime of the account.
     </dd>
  
   <dt>username</dt>
     <dd>The name that uniquely identifies a single user account. This name
     may be presented by the user, along with their password, to log into
     their account.
     May only contain a-z, 0-9, or '-', and may not start or end with the '-'
     <br/>
     Length:  EDAM_USER_USERNAME_LEN_MIN - EDAM_USER_USERNAME_LEN_MAX
     <br/>
     Regex:  EDAM_USER_USERNAME_REGEX
     </dd>
  
   <dt>email</dt>
     <dd>The email address registered for the user.  Must comply with
     RFC 2821 and RFC 2822.<br/>
     Third party applications that authenticate using OAuth do not have
     access to this field.
     Length:  EDAM_EMAIL_LEN_MIN - EDAM_EMAIL_LEN_MAX
     <br/>
     Regex:  EDAM_EMAIL_REGEX
     </dd>
  
   <dt>name</dt>
     <dd>The printable name of the user, which may be a combination
     of given and family names.  This is used instead of separate "first"
     and "last" names due to variations in international name format/order.
     May not start or end with a whitespace character.  May contain any
     character but carriage return or newline (Unicode classes Zl and Zp).
     <br/>
     Length:  EDAM_USER_NAME_LEN_MIN - EDAM_USER_NAME_LEN_MAX
     <br/>
     Regex:  EDAM_USER_NAME_REGEX
     </dd>
  
   <dt>timezone</dt>
     <dd>The zone ID for the user's default location.  If present,
     this may be used to localize the display of any timestamp for which no
     other timezone is available.
     The format must be encoded as a standard zone ID such as
     "America/Los_Angeles" or "GMT+08:00"
     <br/>
     Length:  EDAM_TIMEZONE_LEN_MIN - EDAM_TIMEZONE_LEN_MAX
     <br/>
     Regex:  EDAM_TIMEZONE_REGEX
     </dd>
  
   <dt>privilege</dt>
     <dd>The level of access permitted for the user.
     </dd>
  
   <dt>created</dt>
     <dd>The date and time when this user account was created in the
     service.
     </dd>
  
   <dt>updated</dt>
     <dd>The date and time when this user account was last modified
     in the service.
     </dd>
  
   <dt>deleted</dt>
     <dd>If the account has been deleted from the system (e.g. as
     the result of a legal request by the user), the date and time of the
     deletion will be represented here.  If not, this value will not be set.
     </dd>
  
   <dt>active</dt>
     <dd>If the user account is available for login and
     synchronization, this flag will be set to true.
     </dd>
  
   <dt>shardId</dt>
     <dd>DEPRECATED - Client applications should have no need to use this field.
     </dd>
  
   <dt>attributes</dt>
     <dd>If present, this will contain a list of the attributes
     for this user account.
     </dd>
  
   <dt>accounting</dt>
     <dd>Bookkeeping information for the user's subscription.
     </dd>
  
   <dt>premiumInfo</dt>
     <dd>If present, this will contain a set of commerce information
     relating to the user's premium service level.
     </dd>
  
   <dt>businessUserInfo</dt>
     <dd>If present, this will contain a set of business information
     relating to the user's business membership.  If not present, the
     user is not currently part of a business.
     </dd>
   </dl>
  
  Attributes:
   - id
   - username
   - email
   - name
   - timezone
   - privilege
   - created
   - updated
   - deleted
   - active
   - shardId
   - attributes
   - accounting
   - premiumInfo
   - businessUserInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'username', None, None, ), # 2
    (3, TType.STRING, 'email', None, None, ), # 3
    (4, TType.STRING, 'name', None, None, ), # 4
    None, # 5
    (6, TType.STRING, 'timezone', None, None, ), # 6
    (7, TType.I32, 'privilege', None, None, ), # 7
    None, # 8
    (9, TType.I64, 'created', None, None, ), # 9
    (10, TType.I64, 'updated', None, None, ), # 10
    (11, TType.I64, 'deleted', None, None, ), # 11
    None, # 12
    (13, TType.BOOL, 'active', None, None, ), # 13
    (14, TType.STRING, 'shardId', None, None, ), # 14
    (15, TType.STRUCT, 'attributes', (UserAttributes, UserAttributes.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'accounting', (Accounting, Accounting.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'premiumInfo', (PremiumInfo, PremiumInfo.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'businessUserInfo', (BusinessUserInfo, BusinessUserInfo.thrift_spec), None, ), # 18
  )

  def __init__(self, id=None, username=None, email=None, name=None, timezone=None, privilege=None, created=None, updated=None, deleted=None, active=None, shardId=None, attributes=None, accounting=None, premiumInfo=None, businessUserInfo=None,):
    self.id = id
    self.username = username
    self.email = email
    self.name = name
    self.timezone = timezone
    self.privilege = privilege
    self.created = created
    self.updated = updated
    self.deleted = deleted
    self.active = active
    self.shardId = shardId
    self.attributes = attributes
    self.accounting = accounting
    self.premiumInfo = premiumInfo
    self.businessUserInfo = businessUserInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.timezone = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.deleted = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.shardId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.attributes = UserAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.accounting = Accounting()
          self.accounting.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.premiumInfo = PremiumInfo()
          self.premiumInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.businessUserInfo = BusinessUserInfo()
          self.businessUserInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 2)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 3)
      oprot.writeString(self.email)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.timezone is not None:
      oprot.writeFieldBegin('timezone', TType.STRING, 6)
      oprot.writeString(self.timezone)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 7)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 9)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 10)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.I64, 11)
      oprot.writeI64(self.deleted)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 13)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.shardId is not None:
      oprot.writeFieldBegin('shardId', TType.STRING, 14)
      oprot.writeString(self.shardId)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 15)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.accounting is not None:
      oprot.writeFieldBegin('accounting', TType.STRUCT, 16)
      self.accounting.write(oprot)
      oprot.writeFieldEnd()
    if self.premiumInfo is not None:
      oprot.writeFieldBegin('premiumInfo', TType.STRUCT, 17)
      self.premiumInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.businessUserInfo is not None:
      oprot.writeFieldBegin('businessUserInfo', TType.STRUCT, 18)
      self.businessUserInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Tag(object):
  """
   A tag within a user's account is a unique name which may be organized
   a simple hierarchy.
  <dl>
   <dt>guid</dt>
     <dd>The unique identifier of this tag. Will be set by the service,
     so may be omitted by the client when creating the Tag.
     <br/>
     Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
     <br/>
     Regex:  EDAM_GUID_REGEX
     </dd>
  
   <dt>name</dt>
     <dd>A sequence of characters representing the tag's identifier.
     Case is preserved, but is ignored for comparisons.
     This means that an account may only have one tag with a given name, via
     case-insensitive comparison, so an account may not have both "food" and
     "Food" tags.
     May not contain a comma (','), and may not begin or end with a space.
     <br/>
     Length:  EDAM_TAG_NAME_LEN_MIN - EDAM_TAG_NAME_LEN_MAX
     <br/>
     Regex:  EDAM_TAG_NAME_REGEX
     </dd>
  
   <dt>parentGuid</dt>
     <dd>If this is set, then this is the GUID of the tag that
     holds this tag within the tag organizational hierarchy.  If this is
     not set, then the tag has no parent and it is a "top level" tag.
     Cycles are not allowed (e.g. a->parent->parent == a) and will be
     rejected by the service.
     <br/>
     Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
     <br/>
     Regex:  EDAM_GUID_REGEX
     </dd>
  
   <dt>updateSequenceNum</dt>
     <dd>A number identifying the last transaction to
     modify the state of this object.  The USN values are sequential within an
     account, and can be used to compare the order of modifications within the
     service.
     </dd>
   </dl>
  
  Attributes:
   - guid
   - name
   - parentGuid
   - updateSequenceNum
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'parentGuid', None, None, ), # 3
    (4, TType.I32, 'updateSequenceNum', None, None, ), # 4
  )

  def __init__(self, guid=None, name=None, parentGuid=None, updateSequenceNum=None,):
    self.guid = guid
    self.name = name
    self.parentGuid = parentGuid
    self.updateSequenceNum = updateSequenceNum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.parentGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tag')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.parentGuid is not None:
      oprot.writeFieldBegin('parentGuid', TType.STRING, 3)
      oprot.writeString(self.parentGuid)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 4)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LazyMap(object):
  """
  A structure that wraps a map of name/value pairs whose values are not
  always present in the structure in order to reduce space when obtaining
  batches of entities that contain the map.
  
  When the server provides the client with a LazyMap, it will fill in either
  the keysOnly field or the fullMap field, but never both, based on the API
  and parameters.
  
  When a client provides a LazyMap to the server as part of an update to
  an object, the server will only update the LazyMap if the fullMap field is
  set. If the fullMap field is not set, the server will not make any changes
  to the map.
  
  Check the API documentation of the individual calls involving the LazyMap
  for full details including the constraints of the names and values of the
  map.
  
  <dl>
  <dt>keysOnly</dt>
    <dd>The set of keys for the map.  This field is ignored by the
        server when set.
    </dd>
  
  <dt>fullMap</dt>
    <dd>The complete map, including all keys and values.
    </dd>
  </dl>
  
  Attributes:
   - keysOnly
   - fullMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'keysOnly', (TType.STRING,None), None, ), # 1
    (2, TType.MAP, 'fullMap', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, keysOnly=None, fullMap=None,):
    self.keysOnly = keysOnly
    self.fullMap = fullMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.keysOnly = set()
          (_etype17, _size14) = iprot.readSetBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.keysOnly.add(_elem19)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.fullMap = {}
          (_ktype21, _vtype22, _size20 ) = iprot.readMapBegin() 
          for _i24 in xrange(_size20):
            _key25 = iprot.readString();
            _val26 = iprot.readString();
            self.fullMap[_key25] = _val26
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LazyMap')
    if self.keysOnly is not None:
      oprot.writeFieldBegin('keysOnly', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.keysOnly))
      for iter27 in self.keysOnly:
        oprot.writeString(iter27)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.fullMap is not None:
      oprot.writeFieldBegin('fullMap', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fullMap))
      for kiter28,viter29 in self.fullMap.items():
        oprot.writeString(kiter28)
        oprot.writeString(viter29)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceAttributes(object):
  """
  Structure holding the optional attributes of a Resource
  <dl>
  <dt>sourceURL</dt>
    <dd>the original location where the resource was hosted
    <br/>
     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>timestamp</dt>
    <dd>the date and time that is associated with this resource
    (e.g. the time embedded in an image from a digital camera with a clock)
    </dd>
  
  <dt>latitude</dt>
    <dd>the latitude where the resource was captured
    </dd>
  
  <dt>longitude</dt>
    <dd>the longitude where the resource was captured
    </dd>
  
  <dt>altitude</dt>
    <dd>the altitude where the resource was captured
    </dd>
  
  <dt>cameraMake</dt>
    <dd>information about an image's camera, e.g. as embedded in
    the image's EXIF data
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>cameraModel</dt>
    <dd>information about an image's camera, e.g. as embedded
    in the image's EXIF data
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>clientWillIndex</dt>
    <dd>if true, then the original client that submitted
    the resource plans to submit the recognition index for this resource at a
    later time.
    </dd>
  
  <dt>recoType</dt>
    <dd>DEPRECATED - this field is no longer set by the service, so should
      be ignored.
    </dd>
  
  <dt>fileName</dt>
    <dd>if the resource came from a source that provided an
    explicit file name, the original name will be stored here.  Many resources
    come from unnamed sources, so this will not always be set.
    </dd>
  
  <dt>attachment</dt>
    <dd>this will be true if the resource should be displayed as an attachment,
    or false if the resource should be displayed inline (if possible).
    </dd>
  
  <dt>applicationData</dt>
  <dd>Provides a location for applications to store a relatively small
  (4kb) blob of data associated with a Resource that is not visible to the user
  and that is opaque to the Evernote service. A single application may use at most
  one entry in this map, using its API consumer key as the map key. See the
  documentation for LazyMap for a description of when the actual map values
  are returned by the service.
  <p>To safely add or modify your application's entry in the map, use
  NoteStore.setResourceApplicationDataEntry. To safely remove your application's
  entry from the map, use NoteStore.unsetResourceApplicationDataEntry.</p>
  Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
  <br/>
  Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
  <br/>
  Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
  </dd>
  
  </dl>
  
  Attributes:
   - sourceURL
   - timestamp
   - latitude
   - longitude
   - altitude
   - cameraMake
   - cameraModel
   - clientWillIndex
   - recoType
   - fileName
   - attachment
   - applicationData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sourceURL', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.DOUBLE, 'latitude', None, None, ), # 3
    (4, TType.DOUBLE, 'longitude', None, None, ), # 4
    (5, TType.DOUBLE, 'altitude', None, None, ), # 5
    (6, TType.STRING, 'cameraMake', None, None, ), # 6
    (7, TType.STRING, 'cameraModel', None, None, ), # 7
    (8, TType.BOOL, 'clientWillIndex', None, None, ), # 8
    (9, TType.STRING, 'recoType', None, None, ), # 9
    (10, TType.STRING, 'fileName', None, None, ), # 10
    (11, TType.BOOL, 'attachment', None, None, ), # 11
    (12, TType.STRUCT, 'applicationData', (LazyMap, LazyMap.thrift_spec), None, ), # 12
  )

  def __init__(self, sourceURL=None, timestamp=None, latitude=None, longitude=None, altitude=None, cameraMake=None, cameraModel=None, clientWillIndex=None, recoType=None, fileName=None, attachment=None, applicationData=None,):
    self.sourceURL = sourceURL
    self.timestamp = timestamp
    self.latitude = latitude
    self.longitude = longitude
    self.altitude = altitude
    self.cameraMake = cameraMake
    self.cameraModel = cameraModel
    self.clientWillIndex = clientWillIndex
    self.recoType = recoType
    self.fileName = fileName
    self.attachment = attachment
    self.applicationData = applicationData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sourceURL = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.latitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.longitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.altitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.cameraMake = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.cameraModel = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.clientWillIndex = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.recoType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.attachment = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.applicationData = LazyMap()
          self.applicationData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceAttributes')
    if self.sourceURL is not None:
      oprot.writeFieldBegin('sourceURL', TType.STRING, 1)
      oprot.writeString(self.sourceURL)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.latitude is not None:
      oprot.writeFieldBegin('latitude', TType.DOUBLE, 3)
      oprot.writeDouble(self.latitude)
      oprot.writeFieldEnd()
    if self.longitude is not None:
      oprot.writeFieldBegin('longitude', TType.DOUBLE, 4)
      oprot.writeDouble(self.longitude)
      oprot.writeFieldEnd()
    if self.altitude is not None:
      oprot.writeFieldBegin('altitude', TType.DOUBLE, 5)
      oprot.writeDouble(self.altitude)
      oprot.writeFieldEnd()
    if self.cameraMake is not None:
      oprot.writeFieldBegin('cameraMake', TType.STRING, 6)
      oprot.writeString(self.cameraMake)
      oprot.writeFieldEnd()
    if self.cameraModel is not None:
      oprot.writeFieldBegin('cameraModel', TType.STRING, 7)
      oprot.writeString(self.cameraModel)
      oprot.writeFieldEnd()
    if self.clientWillIndex is not None:
      oprot.writeFieldBegin('clientWillIndex', TType.BOOL, 8)
      oprot.writeBool(self.clientWillIndex)
      oprot.writeFieldEnd()
    if self.recoType is not None:
      oprot.writeFieldBegin('recoType', TType.STRING, 9)
      oprot.writeString(self.recoType)
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 10)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    if self.attachment is not None:
      oprot.writeFieldBegin('attachment', TType.BOOL, 11)
      oprot.writeBool(self.attachment)
      oprot.writeFieldEnd()
    if self.applicationData is not None:
      oprot.writeFieldBegin('applicationData', TType.STRUCT, 12)
      self.applicationData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Resource(object):
  """
  Every media file that is embedded or attached to a note is represented
  through a Resource entry.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this resource.  Will be set whenever
    a resource is retrieved from the service, but may be null when a client
    is creating a resource.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>noteGuid</dt>
    <dd>The unique identifier of the Note that holds this
    Resource. Will be set whenever the resource is retrieved from the service,
    but may be null when a client is creating a resource.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>data</dt>
    <dd>The contents of the resource.
    Maximum length:  The data.body is limited to EDAM_RESOURCE_SIZE_MAX_FREE
    for free accounts and EDAM_RESOURCE_SIZE_MAX_PREMIUM for premium accounts.
    </dd>
  
  <dt>mime</dt>
    <dd>The MIME type for the embedded resource.  E.g. "image/gif"
    <br/>
    Length:  EDAM_MIME_LEN_MIN - EDAM_MIME_LEN_MAX
    <br/>
    Regex:  EDAM_MIME_REGEX
    </dd>
  
  <dt>width</dt>
    <dd>If set, this contains the display width of this resource, in
    pixels.
    </dd>
  
  <dt>height</dt>
    <dd>If set, this contains the display height of this resource,
    in pixels.
    </dd>
  
  <dt>duration</dt>
    <dd>DEPRECATED: ignored.
    </dd>
  
  <dt>active</dt>
    <dd>DEPRECATED: ignored.
    </dd>
  
  <dt>recognition</dt>
    <dd>If set, this will hold the encoded data that provides
    information on search and recognition within this resource.
    </dd>
  
  <dt>attributes</dt>
    <dd>A list of the attributes for this resource.
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object. The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>alternateData</dt>
    <dd>Some Resources may be assigned an alternate data format by the service
    which may be more appropriate for indexing or rendering than the original
    data provided by the user.  In these cases, the alternate data form will
    be available via this Data element.  If a Resource has no alternate form,
    this field will be unset.</dd>
  </dl>
  
  Attributes:
   - guid
   - noteGuid
   - data
   - mime
   - width
   - height
   - duration
   - active
   - recognition
   - attributes
   - updateSequenceNum
   - alternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.STRUCT, 'data', (Data, Data.thrift_spec), None, ), # 3
    (4, TType.STRING, 'mime', None, None, ), # 4
    (5, TType.I16, 'width', None, None, ), # 5
    (6, TType.I16, 'height', None, None, ), # 6
    (7, TType.I16, 'duration', None, None, ), # 7
    (8, TType.BOOL, 'active', None, None, ), # 8
    (9, TType.STRUCT, 'recognition', (Data, Data.thrift_spec), None, ), # 9
    None, # 10
    (11, TType.STRUCT, 'attributes', (ResourceAttributes, ResourceAttributes.thrift_spec), None, ), # 11
    (12, TType.I32, 'updateSequenceNum', None, None, ), # 12
    (13, TType.STRUCT, 'alternateData', (Data, Data.thrift_spec), None, ), # 13
  )

  def __init__(self, guid=None, noteGuid=None, data=None, mime=None, width=None, height=None, duration=None, active=None, recognition=None, attributes=None, updateSequenceNum=None, alternateData=None,):
    self.guid = guid
    self.noteGuid = noteGuid
    self.data = data
    self.mime = mime
    self.width = width
    self.height = height
    self.duration = duration
    self.active = active
    self.recognition = recognition
    self.attributes = attributes
    self.updateSequenceNum = updateSequenceNum
    self.alternateData = alternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.data = Data()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.width = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.height = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.duration = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.recognition = Data()
          self.recognition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.attributes = ResourceAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.alternateData = Data()
          self.alternateData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Resource')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 3)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.mime is not None:
      oprot.writeFieldBegin('mime', TType.STRING, 4)
      oprot.writeString(self.mime)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I16, 5)
      oprot.writeI16(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I16, 6)
      oprot.writeI16(self.height)
      oprot.writeFieldEnd()
    if self.duration is not None:
      oprot.writeFieldBegin('duration', TType.I16, 7)
      oprot.writeI16(self.duration)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 8)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.recognition is not None:
      oprot.writeFieldBegin('recognition', TType.STRUCT, 9)
      self.recognition.write(oprot)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 11)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 12)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.alternateData is not None:
      oprot.writeFieldBegin('alternateData', TType.STRUCT, 13)
      self.alternateData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteAttributes(object):
  """
  The list of optional attributes that can be stored on a note.
  <dl>
  <dt>subjectDate</dt>
    <dd>time that the note refers to
    </dd>
  
  <dt>latitude</dt>
    <dd>the latitude where the note was taken
    </dd>
  
  <dt>longitude</dt>
    <dd>the longitude where the note was taken
    </dd>
  
  <dt>altitude</dt>
    <dd>the altitude where the note was taken
    </dd>
  
  <dt>author</dt>
    <dd>the author of the content of the note
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>source</dt>
    <dd>the method that the note was added to the account, if the
    note wasn't directly authored in an Evernote desktop client.
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>sourceURL</dt>
    <dd>the original location where the resource was hosted. For web clips,
    this will be the URL of the page that was clipped.
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>sourceApplication</dt>
    <dd>an identifying string for the application that
    created this note.  This string does not have a guaranteed syntax or
    structure -- it is intended for human inspection and tracking.
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>shareDate</dt>
   <dd>The date and time when this note was directly shared via its own URL.
   This is only set on notes that were individually shared - it is independent
   of any notebook-level sharing of the containing notebook. This field
   is treated as "read-only" for clients; the server will ignore changes
   to this field from an external client.
   </dd>
  
  <dt>reminderOrder</dt>
  <dd>The set of notes with this parameter set are considered
  "reminders" and are to be treated specially by clients to give them
  higher UI prominence within a notebook.  The value is used to sort
  the reminder notes within the notebook with higher values
  representing greater prominence.  Outside of the context of a
  notebook, the value of this parameter is undefined.  The value is
  not intended to be compared to the values of reminder notes in
  other notebooks.  In order to allow clients to place a note at a
  higher precedence than other notes, you should never set a value
  greater than the current time (as defined for a Timetstamp). To
  place a note at higher precedence than existing notes, set the
  value to the current time as defined for a timestamp (milliseconds
  since the epoch).  Synchronizing clients must remember the time when
  the update was performed, using the local clock on the client,
  and use that value when they later upload the note to the service.
  Clients must not set the reminderOrder to the reminderTime as the
  reminderTime could be in the future.  Those two fields are never
  intended to be related.  The correct value for reminderOrder field
  for new notes is the "current" time when the user indicated that
  the note is a reminder.  Clients may implement a separate
  "sort by date" feature to show notes ordered by reminderTime.
  Whenever a reminderDoneTime or reminderTime is set but a
  reminderOrder is not set, the server will fill in the current
  server time for the reminderOrder field.</dd>
  
  <dt>reminderDoneTime</dt>
  <dd>The date and time when a user dismissed/"marked done" the reminder
  on the note.  Users typically do not manually set this value directly
  as it is set to the time when the user dismissed/"marked done" the
  reminder.</dd>
  
  <dt>reminderTime</dt>
  <dd>The date and time a user has selected to be reminded of the note.
  A note with this value set is known as a "reminder" and the user can
  be reminded, via e-mail or client-specific notifications, of the note
  when the time is reached or about to be reached.  When a user sets
  a reminder time on a note that has a reminder done time, and that
  reminder time is in the future, then the reminder done time should be
  cleared.  This should happen regardless of any existing reminder time
  that may have previously existed on the note.</dd>
  
  <dt>placeName</dt>
  <dd>Allows the user to assign a human-readable location name associated
  with a note. Users may assign values like 'Home' and 'Work'. Place
  names may also be populated with values from geonames database
  (e.g., a restaurant name). Applications are encouraged to normalize values
  so that grouping values by place name provides a useful result. Applications
  MUST NOT automatically add place name values based on geolocation without
  confirmation from the user; that is, the value in this field should be
  more useful than a simple automated lookup based on the note's latitude
  and longitude.</dd>
  
  <dt>contentClass</dt>
  <dd>The class (or type) of note. This field is used to indicate to
  clients that special structured information is represented within
  the note such that special rules apply when making
  modifications. If contentClass is set and the client
  application does not specifically support the specified class,
  the client MUST treat the note as read-only. In this case, the
  client MAY modify the note's notebook and tags via the
  Note.notebookGuid and Note.tagGuids fields.  The client MAY also
  modify the reminderOrder field as well as the reminderTime and
  reminderDoneTime fields.
  <p>Applications should set contentClass only when they are creating notes
  that contain structured information that needs to be maintained in order
  for the user to be able to use the note within that application.
  Setting contentClass makes a note read-only in other applications, so
  there is a trade-off when an application chooses to use contentClass.
  Applications that set contentClass when creating notes must use a contentClass
  string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
  Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
  <br/>
  Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
  </dd>
  
  <dt>applicationData</dt>
  <dd>Provides a location for applications to store a relatively small
  (4kb) blob of data that is not meant to be visible to the user and
  that is opaque to the Evernote service. A single application may use at most
  one entry in this map, using its API consumer key as the map key. See the
  documentation for LazyMap for a description of when the actual map values
  are returned by the service.
  <p>To safely add or modify your application's entry in the map, use
  NoteStore.setNoteApplicationDataEntry. To safely remove your application's
  entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
  Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
  <br/>
  Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
  <br/>
  Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
  </dd>
  
  <dt>creatorId</dt>
  <dd>The numeric user ID of the user who originally created the note.</dd>
  
  <dt>lastEditedBy</dt>
  <dd>An indication of who made the last change to the note.  If you are
  accessing the note via a shared notebook to which you have modification
  rights, or if you are the owner of the notebook to which the note belongs,
  then you have access to the value.  In this case, the value will be
  unset if the owner of the notebook containing the note was the last to
  make the modification, else it will be a string describing the
  guest who made the last edit.  If you do not have access to this value,
  it will be left unset.  This field is read-only by clients.  The server
  will ignore all values set by clients into this field.</dd>
  
  <dt>lastEditorId</dt>
  <dd>The numeric user ID of the user described in lastEditedBy.</dd>
  
  <dt>classifications</dt>
  <dd>A map of classifications applied to the note by clients or by the
  Evernote service. The key is the string name of the classification type,
  and the value is a constant that begins with CLASSIFICATION_.</dd>
  
  </dl>
  
  Attributes:
   - subjectDate
   - latitude
   - longitude
   - altitude
   - author
   - source
   - sourceURL
   - sourceApplication
   - shareDate
   - reminderOrder
   - reminderDoneTime
   - reminderTime
   - placeName
   - contentClass
   - applicationData
   - lastEditedBy
   - classifications
   - creatorId
   - lastEditorId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'subjectDate', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.DOUBLE, 'latitude', None, None, ), # 10
    (11, TType.DOUBLE, 'longitude', None, None, ), # 11
    (12, TType.DOUBLE, 'altitude', None, None, ), # 12
    (13, TType.STRING, 'author', None, None, ), # 13
    (14, TType.STRING, 'source', None, None, ), # 14
    (15, TType.STRING, 'sourceURL', None, None, ), # 15
    (16, TType.STRING, 'sourceApplication', None, None, ), # 16
    (17, TType.I64, 'shareDate', None, None, ), # 17
    (18, TType.I64, 'reminderOrder', None, None, ), # 18
    (19, TType.I64, 'reminderDoneTime', None, None, ), # 19
    (20, TType.I64, 'reminderTime', None, None, ), # 20
    (21, TType.STRING, 'placeName', None, None, ), # 21
    (22, TType.STRING, 'contentClass', None, None, ), # 22
    (23, TType.STRUCT, 'applicationData', (LazyMap, LazyMap.thrift_spec), None, ), # 23
    (24, TType.STRING, 'lastEditedBy', None, None, ), # 24
    None, # 25
    (26, TType.MAP, 'classifications', (TType.STRING,None,TType.STRING,None), None, ), # 26
    (27, TType.I32, 'creatorId', None, None, ), # 27
    (28, TType.I32, 'lastEditorId', None, None, ), # 28
  )

  def __init__(self, subjectDate=None, latitude=None, longitude=None, altitude=None, author=None, source=None, sourceURL=None, sourceApplication=None, shareDate=None, reminderOrder=None, reminderDoneTime=None, reminderTime=None, placeName=None, contentClass=None, applicationData=None, lastEditedBy=None, classifications=None, creatorId=None, lastEditorId=None,):
    self.subjectDate = subjectDate
    self.latitude = latitude
    self.longitude = longitude
    self.altitude = altitude
    self.author = author
    self.source = source
    self.sourceURL = sourceURL
    self.sourceApplication = sourceApplication
    self.shareDate = shareDate
    self.reminderOrder = reminderOrder
    self.reminderDoneTime = reminderDoneTime
    self.reminderTime = reminderTime
    self.placeName = placeName
    self.contentClass = contentClass
    self.applicationData = applicationData
    self.lastEditedBy = lastEditedBy
    self.classifications = classifications
    self.creatorId = creatorId
    self.lastEditorId = lastEditorId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.subjectDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.DOUBLE:
          self.latitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.DOUBLE:
          self.longitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.DOUBLE:
          self.altitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.author = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.sourceURL = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.sourceApplication = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.shareDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I64:
          self.reminderOrder = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I64:
          self.reminderDoneTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I64:
          self.reminderTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.placeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.contentClass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.applicationData = LazyMap()
          self.applicationData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.lastEditedBy = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.MAP:
          self.classifications = {}
          (_ktype31, _vtype32, _size30 ) = iprot.readMapBegin() 
          for _i34 in xrange(_size30):
            _key35 = iprot.readString();
            _val36 = iprot.readString();
            self.classifications[_key35] = _val36
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.I32:
          self.creatorId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.I32:
          self.lastEditorId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteAttributes')
    if self.subjectDate is not None:
      oprot.writeFieldBegin('subjectDate', TType.I64, 1)
      oprot.writeI64(self.subjectDate)
      oprot.writeFieldEnd()
    if self.latitude is not None:
      oprot.writeFieldBegin('latitude', TType.DOUBLE, 10)
      oprot.writeDouble(self.latitude)
      oprot.writeFieldEnd()
    if self.longitude is not None:
      oprot.writeFieldBegin('longitude', TType.DOUBLE, 11)
      oprot.writeDouble(self.longitude)
      oprot.writeFieldEnd()
    if self.altitude is not None:
      oprot.writeFieldBegin('altitude', TType.DOUBLE, 12)
      oprot.writeDouble(self.altitude)
      oprot.writeFieldEnd()
    if self.author is not None:
      oprot.writeFieldBegin('author', TType.STRING, 13)
      oprot.writeString(self.author)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 14)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.sourceURL is not None:
      oprot.writeFieldBegin('sourceURL', TType.STRING, 15)
      oprot.writeString(self.sourceURL)
      oprot.writeFieldEnd()
    if self.sourceApplication is not None:
      oprot.writeFieldBegin('sourceApplication', TType.STRING, 16)
      oprot.writeString(self.sourceApplication)
      oprot.writeFieldEnd()
    if self.shareDate is not None:
      oprot.writeFieldBegin('shareDate', TType.I64, 17)
      oprot.writeI64(self.shareDate)
      oprot.writeFieldEnd()
    if self.reminderOrder is not None:
      oprot.writeFieldBegin('reminderOrder', TType.I64, 18)
      oprot.writeI64(self.reminderOrder)
      oprot.writeFieldEnd()
    if self.reminderDoneTime is not None:
      oprot.writeFieldBegin('reminderDoneTime', TType.I64, 19)
      oprot.writeI64(self.reminderDoneTime)
      oprot.writeFieldEnd()
    if self.reminderTime is not None:
      oprot.writeFieldBegin('reminderTime', TType.I64, 20)
      oprot.writeI64(self.reminderTime)
      oprot.writeFieldEnd()
    if self.placeName is not None:
      oprot.writeFieldBegin('placeName', TType.STRING, 21)
      oprot.writeString(self.placeName)
      oprot.writeFieldEnd()
    if self.contentClass is not None:
      oprot.writeFieldBegin('contentClass', TType.STRING, 22)
      oprot.writeString(self.contentClass)
      oprot.writeFieldEnd()
    if self.applicationData is not None:
      oprot.writeFieldBegin('applicationData', TType.STRUCT, 23)
      self.applicationData.write(oprot)
      oprot.writeFieldEnd()
    if self.lastEditedBy is not None:
      oprot.writeFieldBegin('lastEditedBy', TType.STRING, 24)
      oprot.writeString(self.lastEditedBy)
      oprot.writeFieldEnd()
    if self.classifications is not None:
      oprot.writeFieldBegin('classifications', TType.MAP, 26)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.classifications))
      for kiter37,viter38 in self.classifications.items():
        oprot.writeString(kiter37)
        oprot.writeString(viter38)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.creatorId is not None:
      oprot.writeFieldBegin('creatorId', TType.I32, 27)
      oprot.writeI32(self.creatorId)
      oprot.writeFieldEnd()
    if self.lastEditorId is not None:
      oprot.writeFieldBegin('lastEditorId', TType.I32, 28)
      oprot.writeI32(self.lastEditorId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Note(object):
  """
  Represents a single note in the user's account.
  
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this note.  Will be set by the
    server, but will be omitted by clients calling NoteStore.createNote()
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>title</dt>
    <dd>The subject of the note.  Can't begin or end with a space.
    <br/>
    Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
    <br/>
    Regex:  EDAM_NOTE_TITLE_REGEX
    </dd>
  
  <dt>content</dt>
    <dd>The XHTML block that makes up the note.  This is
    the canonical form of the note's contents, so will include abstract
    Evernote tags for internal resource references.  A client may create
    a separate transformed version of this content for internal presentation,
    but the same canonical bytes should be used for transmission and
    comparison unless the user chooses to modify their content.
    <br/>
    Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
    </dd>
  
  <dt>contentHash</dt>
    <dd>The binary MD5 checksum of the UTF-8 encoded content
    body. This will always be set by the server, but clients may choose to omit
    this when they submit a note with content.
    <br/>
    Length:  EDAM_HASH_LEN (exactly)
    </dd>
  
  <dt>contentLength</dt>
    <dd>The number of Unicode characters in the content of
    the note.  This will always be set by the service, but clients may choose
    to omit this value when they submit a Note.
    </dd>
  
  <dt>created</dt>
    <dd>The date and time when the note was created in one of the
    clients.  In most cases, this will match the user's sense of when
    the note was created, and ordering between notes will be based on
    ordering of this field.  However, this is not a "reliable" timestamp
    if a client has an incorrect clock, so it cannot provide a true absolute
    ordering between notes.  Notes created directly through the service
    (e.g. via the web GUI) will have an absolutely ordered "created" value.
    </dd>
  
  <dt>updated</dt>
    <dd>The date and time when the note was last modified in one of
    the clients.  In most cases, this will match the user's sense of when
    the note was modified, but this field may not be absolutely reliable
    due to the possibility of client clock errors.
    </dd>
  
  <dt>deleted</dt>
    <dd>If present, the note is considered "deleted", and this
    stores the date and time when the note was deleted by one of the clients.
    In most cases, this will match the user's sense of when the note was
    deleted, but this field may be unreliable due to the possibility of
    client clock errors.
    </dd>
  
  <dt>active</dt>
    <dd>If the note is available for normal actions and viewing,
    this flag will be set to true.
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this note (including changes to the note's attributes
    or resources).  The USN values are sequential within an account,
    and can be used to compare the order of modifications within the service.
    </dd>
  
  <dt>notebookGuid</dt>
    <dd>The unique identifier of the notebook that contains
    this note.  If no notebookGuid is provided on a call to createNote(), the
    default notebook will be used instead.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>tagGuids</dt>
    <dd>A list of the GUID identifiers for tags that are applied to this note.
    This may be provided in a call to createNote() to unambiguously declare
    the tags that should be assigned to the new note.  Alternately, clients
    may pass the names of desired tags via the 'tagNames' field during
    note creation.
    If the list of tags are omitted on a call to createNote(), then
    the server will assume that no changes have been made to the resources.
    Maximum:  EDAM_NOTE_TAGS_MAX tags per note
    </dd>
  
  <dt>resources</dt>
    <dd>The list of resources that are embedded within this note.
    If the list of resources are omitted on a call to updateNote(), then
    the server will assume that no changes have been made to the resources.
    The binary contents of the resources must be provided when the resource
    is first sent to the service, but it will be omitted by the service when
    the Note is returned in the future.
    Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
    </dd>
  
  <dt>attributes</dt>
    <dd>A list of the attributes for this note.
    If the list of attributes are omitted on a call to updateNote(), then
    the server will assume that no changes have been made to the resources.
    </dd>
  
  <dt>tagNames</dt>
    <dd>May be provided by clients during calls to createNote() as an
    alternative to providing the tagGuids of existing tags.  If any tagNames
    are provided during createNote(), these will be found, or created if they
    don't already exist.  Created tags will have no parent (they will be at
    the top level of the tag panel).
    </dd>
  </dl>
  
  Attributes:
   - guid
   - title
   - content
   - contentHash
   - contentLength
   - created
   - updated
   - deleted
   - active
   - updateSequenceNum
   - notebookGuid
   - tagGuids
   - resources
   - attributes
   - tagNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'title', None, None, ), # 2
    (3, TType.STRING, 'content', None, None, ), # 3
    (4, TType.STRING, 'contentHash', None, None, ), # 4
    (5, TType.I32, 'contentLength', None, None, ), # 5
    (6, TType.I64, 'created', None, None, ), # 6
    (7, TType.I64, 'updated', None, None, ), # 7
    (8, TType.I64, 'deleted', None, None, ), # 8
    (9, TType.BOOL, 'active', None, None, ), # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ), # 10
    (11, TType.STRING, 'notebookGuid', None, None, ), # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 12
    (13, TType.LIST, 'resources', (TType.STRUCT,(Resource, Resource.thrift_spec)), None, ), # 13
    (14, TType.STRUCT, 'attributes', (NoteAttributes, NoteAttributes.thrift_spec), None, ), # 14
    (15, TType.LIST, 'tagNames', (TType.STRING,None), None, ), # 15
  )

  def __init__(self, guid=None, title=None, content=None, contentHash=None, contentLength=None, created=None, updated=None, deleted=None, active=None, updateSequenceNum=None, notebookGuid=None, tagGuids=None, resources=None, attributes=None, tagNames=None,):
    self.guid = guid
    self.title = title
    self.content = content
    self.contentHash = contentHash
    self.contentLength = contentLength
    self.created = created
    self.updated = updated
    self.deleted = deleted
    self.active = active
    self.updateSequenceNum = updateSequenceNum
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.resources = resources
    self.attributes = attributes
    self.tagNames = tagNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.content = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.contentHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.contentLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.deleted = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = iprot.readString();
            self.tagGuids.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.resources = []
          (_etype48, _size45) = iprot.readListBegin()
          for _i49 in xrange(_size45):
            _elem50 = Resource()
            _elem50.read(iprot)
            self.resources.append(_elem50)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.attributes = NoteAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.tagNames = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = iprot.readString();
            self.tagNames.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Note')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 2)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.content is not None:
      oprot.writeFieldBegin('content', TType.STRING, 3)
      oprot.writeString(self.content)
      oprot.writeFieldEnd()
    if self.contentHash is not None:
      oprot.writeFieldBegin('contentHash', TType.STRING, 4)
      oprot.writeString(self.contentHash)
      oprot.writeFieldEnd()
    if self.contentLength is not None:
      oprot.writeFieldBegin('contentLength', TType.I32, 5)
      oprot.writeI32(self.contentLength)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 6)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 7)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.I64, 8)
      oprot.writeI64(self.deleted)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 9)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter57 in self.tagGuids:
        oprot.writeString(iter57)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.resources))
      for iter58 in self.resources:
        iter58.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.tagNames is not None:
      oprot.writeFieldBegin('tagNames', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.tagNames))
      for iter59 in self.tagNames:
        oprot.writeString(iter59)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Publishing(object):
  """
  If a Notebook has been opened to the public, the Notebook will have a
  reference to one of these structures, which gives the location and optional
  description of the externally-visible public Notebook.
  <dl>
  <dt>uri</dt>
    <dd>If this field is present, then the notebook is published for
    mass consumption on the Internet under the provided URI, which is
    relative to a defined base publishing URI defined by the service.
    This field can only be modified via the web service GUI ... publishing
    cannot be modified via an offline client.
    <br/>
    Length:  EDAM_PUBLISHING_URI_LEN_MIN - EDAM_PUBLISHING_URI_LEN_MAX
    <br/>
    Regex:  EDAM_PUBLISHING_URI_REGEX
    </dd>
  
  <dt>order</dt>
    <dd>When the notes are publicly displayed, they will be sorted
    based on the requested criteria.
    </dd>
  
  <dt>ascending</dt>
    <dd>If this is set to true, then the public notes will be
    displayed in ascending order (e.g. from oldest to newest).  Otherwise,
    the notes will be displayed in descending order (e.g. newest to oldest).
    </dd>
  
  <dt>publicDescription</dt>
    <dd>This field may be used to provide a short
    description of the notebook, which may be displayed when (e.g.) the
    notebook is shown in a public view.  Can't begin or end with a space.
    <br/>
    Length:  EDAM_PUBLISHING_DESCRIPTION_LEN_MIN -
             EDAM_PUBLISHING_DESCRIPTION_LEN_MAX
    <br/>
    Regex:  EDAM_PUBLISHING_DESCRIPTION_REGEX
    </dd>
  
  </dl>
  
  Attributes:
   - uri
   - order
   - ascending
   - publicDescription
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uri', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
    (3, TType.BOOL, 'ascending', None, None, ), # 3
    (4, TType.STRING, 'publicDescription', None, None, ), # 4
  )

  def __init__(self, uri=None, order=None, ascending=None, publicDescription=None,):
    self.uri = uri
    self.order = order
    self.ascending = ascending
    self.publicDescription = publicDescription

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.publicDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Publishing')
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 1)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 3)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.publicDescription is not None:
      oprot.writeFieldBegin('publicDescription', TType.STRING, 4)
      oprot.writeString(self.publicDescription)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BusinessNotebook(object):
  """
  If a Notebook contained in an Evernote Business account has been published
  the to business library, the Notebook will have a reference to one of these
  structures, which specifies how the Notebook will be represented in the
  library.
  
  <dl>
  <dt>notebookDescription</dt>
    <dd>A short description of the notebook's content that will be displayed
        in the business library user interface. The description may not begin
        or end with whitespace.
    <br/>
    Length: EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MIN -
            EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MAX
    <br/>
    Regex:  EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_REGEX
    </dd>
  
  <dt>privilege</dt>
    <dd>The privileges that will be granted to users who join the notebook through
        the business library.
    </dd>
  
  <dt>recommended</dt>
    <dd>Whether the notebook should be "recommended" when displayed in the business
        library user interface.
    </dd>
  </dl>
  
  Attributes:
   - notebookDescription
   - privilege
   - recommended
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'notebookDescription', None, None, ), # 1
    (2, TType.I32, 'privilege', None, None, ), # 2
    (3, TType.BOOL, 'recommended', None, None, ), # 3
  )

  def __init__(self, notebookDescription=None, privilege=None, recommended=None,):
    self.notebookDescription = notebookDescription
    self.privilege = privilege
    self.recommended = recommended

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.notebookDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.recommended = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BusinessNotebook')
    if self.notebookDescription is not None:
      oprot.writeFieldBegin('notebookDescription', TType.STRING, 1)
      oprot.writeString(self.notebookDescription)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 2)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.recommended is not None:
      oprot.writeFieldBegin('recommended', TType.BOOL, 3)
      oprot.writeBool(self.recommended)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SavedSearchScope(object):
  """
  A structure defining the scope of a SavedSearch.
  
  <dl>
    <dt>includeAccount</dt>
    <dd>The search should include notes from the account that contains the SavedSearch.</dd>
  
    <dt>includePersonalLinkedNotebooks</dt>
    <dd>The search should include notes within those shared notebooks
    that the user has joined that are NOT business notebooks.</dd>
  
    <dt>includeBusinessLinkedNotebooks</dt>
    <dd>The search should include notes within those shared notebooks
    that the user has joined that are business notebooks in the business that
    the user is currently a member of.</dd>
  </dl>
  
  Attributes:
   - includeAccount
   - includePersonalLinkedNotebooks
   - includeBusinessLinkedNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'includeAccount', None, None, ), # 1
    (2, TType.BOOL, 'includePersonalLinkedNotebooks', None, None, ), # 2
    (3, TType.BOOL, 'includeBusinessLinkedNotebooks', None, None, ), # 3
  )

  def __init__(self, includeAccount=None, includePersonalLinkedNotebooks=None, includeBusinessLinkedNotebooks=None,):
    self.includeAccount = includeAccount
    self.includePersonalLinkedNotebooks = includePersonalLinkedNotebooks
    self.includeBusinessLinkedNotebooks = includeBusinessLinkedNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.includeAccount = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.includePersonalLinkedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.includeBusinessLinkedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SavedSearchScope')
    if self.includeAccount is not None:
      oprot.writeFieldBegin('includeAccount', TType.BOOL, 1)
      oprot.writeBool(self.includeAccount)
      oprot.writeFieldEnd()
    if self.includePersonalLinkedNotebooks is not None:
      oprot.writeFieldBegin('includePersonalLinkedNotebooks', TType.BOOL, 2)
      oprot.writeBool(self.includePersonalLinkedNotebooks)
      oprot.writeFieldEnd()
    if self.includeBusinessLinkedNotebooks is not None:
      oprot.writeFieldBegin('includeBusinessLinkedNotebooks', TType.BOOL, 3)
      oprot.writeBool(self.includeBusinessLinkedNotebooks)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SavedSearch(object):
  """
  A named search associated with the account that can be quickly re-used.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this search.  Will be set by the
    service, so may be omitted by the client when creating.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>name</dt>
    <dd>The name of the saved search to display in the GUI.  The
    account may only contain one search with a given name (case-insensitive
    compare). Can't begin or end with a space.
    <br/>
    Length:  EDAM_SAVED_SEARCH_NAME_LEN_MIN - EDAM_SAVED_SEARCH_NAME_LEN_MAX
    <br/>
    Regex:  EDAM_SAVED_SEARCH_NAME_REGEX
    </dd>
  
  <dt>query</dt>
    <dd>A string expressing the search to be performed.
    <br/>
    Length:  EDAM_SAVED_SEARCH_QUERY_LEN_MIN - EDAM_SAVED_SEARCH_QUERY_LEN_MAX
    </dd>
  
  <dt>format</dt>
    <dd>The format of the query string, to determine how to parse
    and process it.
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object.  The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>scope</dt>
    <dd><p>Specifies the set of notes that should be included in the search, if
     possible.</p>
     <p>Clients are expected to search as much of the desired scope as possible,
     with the understanding that a given client may not be able to cover the full
     specified scope. For example, when executing a search that includes notes in both
     the owner's account and business notebooks, a mobile client may choose to only
     search within the user's account because it is not capable of searching both
     scopes simultaneously. When a search across multiple scopes is not possible,
     a client may choose which scope to search based on the current application
     context. If a client cannot search any of the desired scopes, it should refuse
     to execute the search.</p>
     </dd>
  </dl>
  
  Attributes:
   - guid
   - name
   - query
   - format
   - updateSequenceNum
   - scope
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'query', None, None, ), # 3
    (4, TType.I32, 'format', None, None, ), # 4
    (5, TType.I32, 'updateSequenceNum', None, None, ), # 5
    (6, TType.STRUCT, 'scope', (SavedSearchScope, SavedSearchScope.thrift_spec), None, ), # 6
  )

  def __init__(self, guid=None, name=None, query=None, format=None, updateSequenceNum=None, scope=None,):
    self.guid = guid
    self.name = name
    self.query = query
    self.format = format
    self.updateSequenceNum = updateSequenceNum
    self.scope = scope

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.scope = SavedSearchScope()
          self.scope.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SavedSearch')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 3)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 4)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 5)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.scope is not None:
      oprot.writeFieldBegin('scope', TType.STRUCT, 6)
      self.scope.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SharedNotebookRecipientSettings(object):
  """
  Settings meant for the recipient of a shared notebook, such as
  for indicating which types of notifications the recipient wishes
  for reminders, etc.
  
  The reminderNotifyEmail and reminderNotifyInApp fields have a
  3-state read value but a 2-state write value.  On read, it is
  possible to observe "unset", true, or false.  The initial state is
  "unset".  When you choose to set a value, you may set it to either
  true or false, but you cannot unset the value.  Once one of these
  members has a true/false value, it will always have a true/false
  value.
  
  <dl>
  <dt>reminderNotifyEmail</dt>
  <dd>Indicates that the user wishes to receive daily e-mail notifications
      for reminders associated with the shared notebook.  This may be
      true only for business notebooks that belong to the business of
      which the user is a member.  You may only set this value on a
      notebook in your business.</dd>
  <dt>reminderNotifyInApp</dt>
  <dd>Indicates that the user wishes to receive notifications for
      reminders by applications that support providing such
      notifications.  The exact nature of the notification is defined
      by the individual applications.</dd>
  </dl>
  
  
  Attributes:
   - reminderNotifyEmail
   - reminderNotifyInApp
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'reminderNotifyEmail', None, None, ), # 1
    (2, TType.BOOL, 'reminderNotifyInApp', None, None, ), # 2
  )

  def __init__(self, reminderNotifyEmail=None, reminderNotifyInApp=None,):
    self.reminderNotifyEmail = reminderNotifyEmail
    self.reminderNotifyInApp = reminderNotifyInApp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.reminderNotifyEmail = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.reminderNotifyInApp = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SharedNotebookRecipientSettings')
    if self.reminderNotifyEmail is not None:
      oprot.writeFieldBegin('reminderNotifyEmail', TType.BOOL, 1)
      oprot.writeBool(self.reminderNotifyEmail)
      oprot.writeFieldEnd()
    if self.reminderNotifyInApp is not None:
      oprot.writeFieldBegin('reminderNotifyInApp', TType.BOOL, 2)
      oprot.writeBool(self.reminderNotifyInApp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SharedNotebook(object):
  """
  Shared notebooks represent a relationship between a notebook and a single
  share invitation recipient.
  <dl>
  <dt>id</dt>
  <dd>the primary identifier of the share</dd>
  
  <dt>userId</dt>
  <dd>the user id of the owner of the notebook</dd>
  
  <dt>notebookGuid</dt>
  <dd>the GUID of the associated notebook shared.</dd>
  
  <dt>email</dt>
  <dd>the email address of the recipient - used by the notebook
  owner to identify who they shared with.</dd>
  
  <dt>notebookModifiable</dt>
  <dd>(DEPRECATED) a flag indicating the share is read/write -otherwise it's read
      only.  This field is deprecated in favor of the new "privilege" field.</dd>
  
  <dt>requireLogin</dt>
  <dd>(DEPRECATED) indicates that a user must login to access the share.  This
      field is deprecated and will be "true" for all new shared notebooks.  It
      is read-only and ignored when creating or modifying a shared notebook,
      except that a shared notebook can be modified to require login.
      See "allowPreview" for information on privileges and shared notebooks.</dd>
  
  <dt>serviceCreated</dt>
  <dd>the date the owner first created the share with the specific email
    address</dd>
  
  <dt>serviceUpdated</dt>
  <dd>the date the shared notebook was last updated on the service.  This
      will be updated when authenticateToSharedNotebook is called the first
      time with a shared notebook requiring login (i.e. when the username is
      bound to that shared notebook).</dd>
  
  <dt>username</dt>
  <dd>the username of the user who can access this share.
    Once it's assigned it cannot be changed.</dd>
  
  <dt>privilege</dt>
  <dd>The privilege level granted to the notebook, activity stream, and
      invitations.  See the corresponding enumeration for details.</dd>
  
  <dt>allowPreview</dt>
  <dd>Whether or not to grant "READ_NOTEBOOK" privilege without an
      authentication token, for authenticateToSharedNotebook(...).  With
      the change to "requireLogin" always being true for new shared
      notebooks, this is the only way to access a shared notebook without
      an authorization token.  This setting expires after the first use
      of authenticateToSharedNotebook(...) with a valid authentication
      token.</dd>
  
  <dt>recipientSettings</dt>
  <dd>Settings intended for use only by the recipient of this shared
      notebook.  You should skip setting this value unless you want
      to change the value contained inside the structure, and only if
      you are the recipient.</dd>
  </dl>
  
  Attributes:
   - id
   - userId
   - notebookGuid
   - email
   - notebookModifiable
   - requireLogin
   - serviceCreated
   - serviceUpdated
   - shareKey
   - username
   - privilege
   - allowPreview
   - recipientSettings
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I32, 'userId', None, None, ), # 2
    (3, TType.STRING, 'notebookGuid', None, None, ), # 3
    (4, TType.STRING, 'email', None, None, ), # 4
    (5, TType.BOOL, 'notebookModifiable', None, None, ), # 5
    (6, TType.BOOL, 'requireLogin', None, None, ), # 6
    (7, TType.I64, 'serviceCreated', None, None, ), # 7
    (8, TType.STRING, 'shareKey', None, None, ), # 8
    (9, TType.STRING, 'username', None, None, ), # 9
    (10, TType.I64, 'serviceUpdated', None, None, ), # 10
    (11, TType.I32, 'privilege', None, None, ), # 11
    (12, TType.BOOL, 'allowPreview', None, None, ), # 12
    (13, TType.STRUCT, 'recipientSettings', (SharedNotebookRecipientSettings, SharedNotebookRecipientSettings.thrift_spec), None, ), # 13
  )

  def __init__(self, id=None, userId=None, notebookGuid=None, email=None, notebookModifiable=None, requireLogin=None, serviceCreated=None, serviceUpdated=None, shareKey=None, username=None, privilege=None, allowPreview=None, recipientSettings=None,):
    self.id = id
    self.userId = userId
    self.notebookGuid = notebookGuid
    self.email = email
    self.notebookModifiable = notebookModifiable
    self.requireLogin = requireLogin
    self.serviceCreated = serviceCreated
    self.serviceUpdated = serviceUpdated
    self.shareKey = shareKey
    self.username = username
    self.privilege = privilege
    self.allowPreview = allowPreview
    self.recipientSettings = recipientSettings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.notebookModifiable = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.requireLogin = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.serviceCreated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.serviceUpdated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.shareKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.allowPreview = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.recipientSettings = SharedNotebookRecipientSettings()
          self.recipientSettings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SharedNotebook')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 2)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 3)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 4)
      oprot.writeString(self.email)
      oprot.writeFieldEnd()
    if self.notebookModifiable is not None:
      oprot.writeFieldBegin('notebookModifiable', TType.BOOL, 5)
      oprot.writeBool(self.notebookModifiable)
      oprot.writeFieldEnd()
    if self.requireLogin is not None:
      oprot.writeFieldBegin('requireLogin', TType.BOOL, 6)
      oprot.writeBool(self.requireLogin)
      oprot.writeFieldEnd()
    if self.serviceCreated is not None:
      oprot.writeFieldBegin('serviceCreated', TType.I64, 7)
      oprot.writeI64(self.serviceCreated)
      oprot.writeFieldEnd()
    if self.shareKey is not None:
      oprot.writeFieldBegin('shareKey', TType.STRING, 8)
      oprot.writeString(self.shareKey)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 9)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.serviceUpdated is not None:
      oprot.writeFieldBegin('serviceUpdated', TType.I64, 10)
      oprot.writeI64(self.serviceUpdated)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 11)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.allowPreview is not None:
      oprot.writeFieldBegin('allowPreview', TType.BOOL, 12)
      oprot.writeBool(self.allowPreview)
      oprot.writeFieldEnd()
    if self.recipientSettings is not None:
      oprot.writeFieldBegin('recipientSettings', TType.STRUCT, 13)
      self.recipientSettings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotebookRestrictions(object):
  """
  This structure captures information about the types of operations
  that cannot be performed on a given notebook with a type of
  authenticated access and credentials.  The values filled into this
  structure are based on then-current values in the server database
  for shared notebooks and notebook publishing records, as well as
  information related to the authentication token.  Information from
  the authentication token includes the application that is accessing
  the server, as defined by the permissions granted by consumer (api)
  key, and the method used to obtain the token, for example via
  authenticateToSharedNotebook, authenticateToBusiness, etc.  Note
  that changes to values in this structure that are the result of
  shared notebook or publishing record changes are communicated to
  the client via a change in the notebook USN during sync.  It is
  important to use the same access method, parameters, and consumer
  key in order obtain correct results from the sync engine.
  
  The server has the final say on what is allowed as values may
  change between calls to obtain NotebookRestrictions instances
  and to operate on data on the service.
  
  If the following are set and true, then the given restriction is
  in effect, as accessed by the same authentication token from which
  the values were obtained.
  
  <dt>noReadNotes</dt>
    <dd>The client is not able to read notes from the service and
    the notebook is write-only.
    </dd>
  <dt>noCreateNotes</dt>
    <dd>The client may not create new notes in the notebook.
    </dd>
  <dt>noUpdateNotes</dt>
    <dd>The client may not update notes currently in the notebook.
    </dd>
  <dt>noExpungeNotes</dt>
    <dd>The client may not expunge notes currently in the notebook.
    </dd>
  <dt>noShareNotes</dt>
    <dd>The client may not share notes in the notebook via the
    shareNote method.
    </dd>
  <dt>noEmailNotes</dt>
    <dd>The client may not e-mail notes via the Evernote service by
    using the emailNote method.
    </dd>
  <dt>noSendMessageToRecipients</dt>
    <dd>The client may not send messages to the share recipients of
    the notebook.
    </dd>
  <dt>noUpdateNotebook</dt>
    <dd>The client may not update the Notebook object itself, for
    example, via the updateNotebook method.
    </dd>
  <dt>noExpungeNotebook</dt>
    <dd>The client may not expunge the Notebook object itself, for
    example, via the expungeNotebook method.
    </dd>
  <dt>noSetDefaultNotebook</dt>
    <dd>The client may not set this notebook to be the default notebook.
    The caller should leave Notebook.defaultNotebook unset.
    </dd>
  <dt>noSetNotebookStack</dt>
    <dd>If the client is able to update the Notebook, the Notebook.stack
    value may not be set.
    </dd>
  <dt>noPublishToPublic</dt>
    <dd>The client may not change the publish the notebook to the public.
    For example, business notebooks may not be shared publicly.
    </dd>
  <dt>noPublishToBusinessLibrary</dt>
    <dd>The client may not publish the notebook to the business library.
    </dd>
  <dt>noCreateTags</dt>
    <dd>The client may not complete an operation that results in a new tag
    being created in the owner's account.
    </dd>
  <dt>noUpdateTags</dt>
    <dd>The client may not update tags in the owner's account.
    </dd>
  <dt>noExpungeTags</dt>
    <dd>The client may not expunge tags in the owner's account.
    </dd>
  <dt>noSetParentTag</dt>
    <dd>If the client is able to create or update tags in the owner's account,
    then they will not be able to set the parent tag.  Leave the value unset.
    </dd>
  <dt>noCreateSharedNotebooks</dt>
    <dd>The client is unable to create shared notebooks for the notebook.
    </dd>
  <dt>updateWhichSharedNotebookRestrictions</dt>
    <dd>Restrictions on which shared notebook instances can be updated.  If the
    value is not set or null, then the client can update any of the shared notebooks
    associated with the notebook on which the NotebookRestrictions are defined.
    See the enumeration for further details.
    </dd>
  <dt>expungeWhichSharedNotebookRestrictions</dt>
    <dd>Restrictions on which shared notebook instances can be expunged.  If the
    value is not set or null, then the client can expunge any of the shared notebooks
    associated with the notebook on which the NotebookRestrictions are defined.
    See the enumeration for further details.
    </dd>
  
  Attributes:
   - noReadNotes
   - noCreateNotes
   - noUpdateNotes
   - noExpungeNotes
   - noShareNotes
   - noEmailNotes
   - noSendMessageToRecipients
   - noUpdateNotebook
   - noExpungeNotebook
   - noSetDefaultNotebook
   - noSetNotebookStack
   - noPublishToPublic
   - noPublishToBusinessLibrary
   - noCreateTags
   - noUpdateTags
   - noExpungeTags
   - noSetParentTag
   - noCreateSharedNotebooks
   - updateWhichSharedNotebookRestrictions
   - expungeWhichSharedNotebookRestrictions
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'noReadNotes', None, None, ), # 1
    (2, TType.BOOL, 'noCreateNotes', None, None, ), # 2
    (3, TType.BOOL, 'noUpdateNotes', None, None, ), # 3
    (4, TType.BOOL, 'noExpungeNotes', None, None, ), # 4
    (5, TType.BOOL, 'noShareNotes', None, None, ), # 5
    (6, TType.BOOL, 'noEmailNotes', None, None, ), # 6
    (7, TType.BOOL, 'noSendMessageToRecipients', None, None, ), # 7
    (8, TType.BOOL, 'noUpdateNotebook', None, None, ), # 8
    (9, TType.BOOL, 'noExpungeNotebook', None, None, ), # 9
    (10, TType.BOOL, 'noSetDefaultNotebook', None, None, ), # 10
    (11, TType.BOOL, 'noSetNotebookStack', None, None, ), # 11
    (12, TType.BOOL, 'noPublishToPublic', None, None, ), # 12
    (13, TType.BOOL, 'noPublishToBusinessLibrary', None, None, ), # 13
    (14, TType.BOOL, 'noCreateTags', None, None, ), # 14
    (15, TType.BOOL, 'noUpdateTags', None, None, ), # 15
    (16, TType.BOOL, 'noExpungeTags', None, None, ), # 16
    (17, TType.BOOL, 'noSetParentTag', None, None, ), # 17
    (18, TType.BOOL, 'noCreateSharedNotebooks', None, None, ), # 18
    (19, TType.I32, 'updateWhichSharedNotebookRestrictions', None, None, ), # 19
    (20, TType.I32, 'expungeWhichSharedNotebookRestrictions', None, None, ), # 20
  )

  def __init__(self, noReadNotes=None, noCreateNotes=None, noUpdateNotes=None, noExpungeNotes=None, noShareNotes=None, noEmailNotes=None, noSendMessageToRecipients=None, noUpdateNotebook=None, noExpungeNotebook=None, noSetDefaultNotebook=None, noSetNotebookStack=None, noPublishToPublic=None, noPublishToBusinessLibrary=None, noCreateTags=None, noUpdateTags=None, noExpungeTags=None, noSetParentTag=None, noCreateSharedNotebooks=None, updateWhichSharedNotebookRestrictions=None, expungeWhichSharedNotebookRestrictions=None,):
    self.noReadNotes = noReadNotes
    self.noCreateNotes = noCreateNotes
    self.noUpdateNotes = noUpdateNotes
    self.noExpungeNotes = noExpungeNotes
    self.noShareNotes = noShareNotes
    self.noEmailNotes = noEmailNotes
    self.noSendMessageToRecipients = noSendMessageToRecipients
    self.noUpdateNotebook = noUpdateNotebook
    self.noExpungeNotebook = noExpungeNotebook
    self.noSetDefaultNotebook = noSetDefaultNotebook
    self.noSetNotebookStack = noSetNotebookStack
    self.noPublishToPublic = noPublishToPublic
    self.noPublishToBusinessLibrary = noPublishToBusinessLibrary
    self.noCreateTags = noCreateTags
    self.noUpdateTags = noUpdateTags
    self.noExpungeTags = noExpungeTags
    self.noSetParentTag = noSetParentTag
    self.noCreateSharedNotebooks = noCreateSharedNotebooks
    self.updateWhichSharedNotebookRestrictions = updateWhichSharedNotebookRestrictions
    self.expungeWhichSharedNotebookRestrictions = expungeWhichSharedNotebookRestrictions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.noReadNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.noCreateNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.noUpdateNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.noExpungeNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.noShareNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.noEmailNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.noSendMessageToRecipients = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.noUpdateNotebook = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.noExpungeNotebook = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.noSetDefaultNotebook = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.noSetNotebookStack = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.noPublishToPublic = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.noPublishToBusinessLibrary = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.noCreateTags = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.noUpdateTags = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.noExpungeTags = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BOOL:
          self.noSetParentTag = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BOOL:
          self.noCreateSharedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I32:
          self.updateWhichSharedNotebookRestrictions = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I32:
          self.expungeWhichSharedNotebookRestrictions = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotebookRestrictions')
    if self.noReadNotes is not None:
      oprot.writeFieldBegin('noReadNotes', TType.BOOL, 1)
      oprot.writeBool(self.noReadNotes)
      oprot.writeFieldEnd()
    if self.noCreateNotes is not None:
      oprot.writeFieldBegin('noCreateNotes', TType.BOOL, 2)
      oprot.writeBool(self.noCreateNotes)
      oprot.writeFieldEnd()
    if self.noUpdateNotes is not None:
      oprot.writeFieldBegin('noUpdateNotes', TType.BOOL, 3)
      oprot.writeBool(self.noUpdateNotes)
      oprot.writeFieldEnd()
    if self.noExpungeNotes is not None:
      oprot.writeFieldBegin('noExpungeNotes', TType.BOOL, 4)
      oprot.writeBool(self.noExpungeNotes)
      oprot.writeFieldEnd()
    if self.noShareNotes is not None:
      oprot.writeFieldBegin('noShareNotes', TType.BOOL, 5)
      oprot.writeBool(self.noShareNotes)
      oprot.writeFieldEnd()
    if self.noEmailNotes is not None:
      oprot.writeFieldBegin('noEmailNotes', TType.BOOL, 6)
      oprot.writeBool(self.noEmailNotes)
      oprot.writeFieldEnd()
    if self.noSendMessageToRecipients is not None:
      oprot.writeFieldBegin('noSendMessageToRecipients', TType.BOOL, 7)
      oprot.writeBool(self.noSendMessageToRecipients)
      oprot.writeFieldEnd()
    if self.noUpdateNotebook is not None:
      oprot.writeFieldBegin('noUpdateNotebook', TType.BOOL, 8)
      oprot.writeBool(self.noUpdateNotebook)
      oprot.writeFieldEnd()
    if self.noExpungeNotebook is not None:
      oprot.writeFieldBegin('noExpungeNotebook', TType.BOOL, 9)
      oprot.writeBool(self.noExpungeNotebook)
      oprot.writeFieldEnd()
    if self.noSetDefaultNotebook is not None:
      oprot.writeFieldBegin('noSetDefaultNotebook', TType.BOOL, 10)
      oprot.writeBool(self.noSetDefaultNotebook)
      oprot.writeFieldEnd()
    if self.noSetNotebookStack is not None:
      oprot.writeFieldBegin('noSetNotebookStack', TType.BOOL, 11)
      oprot.writeBool(self.noSetNotebookStack)
      oprot.writeFieldEnd()
    if self.noPublishToPublic is not None:
      oprot.writeFieldBegin('noPublishToPublic', TType.BOOL, 12)
      oprot.writeBool(self.noPublishToPublic)
      oprot.writeFieldEnd()
    if self.noPublishToBusinessLibrary is not None:
      oprot.writeFieldBegin('noPublishToBusinessLibrary', TType.BOOL, 13)
      oprot.writeBool(self.noPublishToBusinessLibrary)
      oprot.writeFieldEnd()
    if self.noCreateTags is not None:
      oprot.writeFieldBegin('noCreateTags', TType.BOOL, 14)
      oprot.writeBool(self.noCreateTags)
      oprot.writeFieldEnd()
    if self.noUpdateTags is not None:
      oprot.writeFieldBegin('noUpdateTags', TType.BOOL, 15)
      oprot.writeBool(self.noUpdateTags)
      oprot.writeFieldEnd()
    if self.noExpungeTags is not None:
      oprot.writeFieldBegin('noExpungeTags', TType.BOOL, 16)
      oprot.writeBool(self.noExpungeTags)
      oprot.writeFieldEnd()
    if self.noSetParentTag is not None:
      oprot.writeFieldBegin('noSetParentTag', TType.BOOL, 17)
      oprot.writeBool(self.noSetParentTag)
      oprot.writeFieldEnd()
    if self.noCreateSharedNotebooks is not None:
      oprot.writeFieldBegin('noCreateSharedNotebooks', TType.BOOL, 18)
      oprot.writeBool(self.noCreateSharedNotebooks)
      oprot.writeFieldEnd()
    if self.updateWhichSharedNotebookRestrictions is not None:
      oprot.writeFieldBegin('updateWhichSharedNotebookRestrictions', TType.I32, 19)
      oprot.writeI32(self.updateWhichSharedNotebookRestrictions)
      oprot.writeFieldEnd()
    if self.expungeWhichSharedNotebookRestrictions is not None:
      oprot.writeFieldBegin('expungeWhichSharedNotebookRestrictions', TType.I32, 20)
      oprot.writeI32(self.expungeWhichSharedNotebookRestrictions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Notebook(object):
  """
  A unique container for a set of notes.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this notebook.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>name</dt>
    <dd>A sequence of characters representing the name of the
    notebook.  May be changed by clients, but the account may not contain two
    notebooks with names that are equal via a case-insensitive comparison.
    Can't begin or end with a space.
    <br/>
    Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
    <br/>
    Regex:  EDAM_NOTEBOOK_NAME_REGEX
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object.  The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>defaultNotebook</dt>
    <dd>If true, this notebook should be used for new notes
    whenever the user has not (or cannot) specify a desired target notebook.
    For example, if a note is submitted via SMTP email.
    The service will maintain at most one defaultNotebook per account.
    If a second notebook is created or updated with defaultNotebook set to
    true, the service will automatically update the prior notebook's
    defaultNotebook field to false.  If the default notebook is deleted
    (i.e. "active" set to false), the "defaultNotebook" field will be
    set to false by the service.  If the account has no default notebook
    set, the service will use the most recent notebook as the default.
    </dd>
  
  <dt>serviceCreated</dt>
    <dd>The time when this notebook was created on the
    service. This will be set on the service during creation, and the service
    will provide this value when it returns a Notebook to a client.
    The service will ignore this value if it is sent by clients.
    </dd>
  
  <dt>serviceUpdated</dt>
    <dd>The time when this notebook was last modified on the
    service.  This will be set on the service during creation, and the service
    will provide this value when it returns a Notebook to a client.
    The service will ignore this value if it is sent by clients.
    </dd>
  
  <dt>publishing</dt>
    <dd>If the Notebook has been opened for public access, or
    business users shared with their business (i.e. if 'published' is
    set to true), then this will point to the set of publishing
    information for the Notebook (URI, description, etc.).  A
    Notebook cannot be published without providing this information,
    but it will persist for later use if publishing is ever disabled
    on the Notebook.  Clients that do not wish to change the
    publishing behavior of a Notebook should not set this value when
    calling NoteStore.updateNotebook().
    </dd>
  
  <dt>published</dt>
    <dd>If this is set to true, then the Notebook will be
    accessible either to the public, or for business users to their business,
    via the 'publishing' specification, which must also be set.  If this is set
    to false, the Notebook will not be available to the public (or business).
    Clients that do not wish to change the publishing behavior of a Notebook
    should not set this value when calling NoteStore.updateNotebook().
    </dd>
  
  <dt>stack</dt>
    <dd>If this is set, then the notebook is visually contained within a stack
    of notebooks with this name.  All notebooks in the same account with the
    same 'stack' field are considered to be in the same stack.
    Notebooks with no stack set are "top level" and not contained within a
    stack.
    </dd>
  
  <dt>sharedNotebookIds</dt>
    <dd><i>DEPRECATED</i> - replaced by sharedNotebooks.</dd>
  
  <dt>sharedNotebooks</dt>
    <dd>The list of recipients to whom this notebook has been shared
    (one SharedNotebook object per recipient email address). This field will
    be unset if you do not have permission to access this data. If you are
    accessing the notebook as the owner or via a shared notebook that is
    modifiable, then you have access to this data and the value will be set.
    This field is read-only. Clients may not make changes to shared notebooks
    via this field.
    </dd>
  
  <dt>businessNotebook</dt>
    <dd>If the notebook is part of a business account and has been published to the
    business library, this will contain information for the library listing.
    The presence or absence of this field is not a reliable test of whether a given
    notebook is in fact a business notebook - the field is only used when a notebook is or
    has been published to the business library.
    </dd>
  
  <dt>contact</dt>
    <dd>Intended for use with Business accounts, this field identifies the user who
    has been designated as the "contact".  For notebooks created in business
    accounts, the server will automatically set this value to the user who created
    the notebook unless Notebook.contact.username has been set, in which that value
    will be used.  When updating a notebook, it is common to leave Notebook.contact
    field unset, indicating that no change to the value is being requested and that
    the existing value, if any, should be preserved.
    </dd>
  
  </dl>
  
  Attributes:
   - guid
   - name
   - updateSequenceNum
   - defaultNotebook
   - serviceCreated
   - serviceUpdated
   - publishing
   - published
   - stack
   - sharedNotebookIds
   - sharedNotebooks
   - businessNotebook
   - contact
   - restrictions
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.I32, 'updateSequenceNum', None, None, ), # 5
    (6, TType.BOOL, 'defaultNotebook', None, None, ), # 6
    (7, TType.I64, 'serviceCreated', None, None, ), # 7
    (8, TType.I64, 'serviceUpdated', None, None, ), # 8
    None, # 9
    (10, TType.STRUCT, 'publishing', (Publishing, Publishing.thrift_spec), None, ), # 10
    (11, TType.BOOL, 'published', None, None, ), # 11
    (12, TType.STRING, 'stack', None, None, ), # 12
    (13, TType.LIST, 'sharedNotebookIds', (TType.I64,None), None, ), # 13
    (14, TType.LIST, 'sharedNotebooks', (TType.STRUCT,(SharedNotebook, SharedNotebook.thrift_spec)), None, ), # 14
    (15, TType.STRUCT, 'businessNotebook', (BusinessNotebook, BusinessNotebook.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'contact', (User, User.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'restrictions', (NotebookRestrictions, NotebookRestrictions.thrift_spec), None, ), # 17
  )

  def __init__(self, guid=None, name=None, updateSequenceNum=None, defaultNotebook=None, serviceCreated=None, serviceUpdated=None, publishing=None, published=None, stack=None, sharedNotebookIds=None, sharedNotebooks=None, businessNotebook=None, contact=None, restrictions=None,):
    self.guid = guid
    self.name = name
    self.updateSequenceNum = updateSequenceNum
    self.defaultNotebook = defaultNotebook
    self.serviceCreated = serviceCreated
    self.serviceUpdated = serviceUpdated
    self.publishing = publishing
    self.published = published
    self.stack = stack
    self.sharedNotebookIds = sharedNotebookIds
    self.sharedNotebooks = sharedNotebooks
    self.businessNotebook = businessNotebook
    self.contact = contact
    self.restrictions = restrictions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.defaultNotebook = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.serviceCreated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.serviceUpdated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.publishing = Publishing()
          self.publishing.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.published = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.stack = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.sharedNotebookIds = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = iprot.readI64();
            self.sharedNotebookIds.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.sharedNotebooks = []
          (_etype69, _size66) = iprot.readListBegin()
          for _i70 in xrange(_size66):
            _elem71 = SharedNotebook()
            _elem71.read(iprot)
            self.sharedNotebooks.append(_elem71)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.businessNotebook = BusinessNotebook()
          self.businessNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.contact = User()
          self.contact.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.restrictions = NotebookRestrictions()
          self.restrictions.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Notebook')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 5)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.defaultNotebook is not None:
      oprot.writeFieldBegin('defaultNotebook', TType.BOOL, 6)
      oprot.writeBool(self.defaultNotebook)
      oprot.writeFieldEnd()
    if self.serviceCreated is not None:
      oprot.writeFieldBegin('serviceCreated', TType.I64, 7)
      oprot.writeI64(self.serviceCreated)
      oprot.writeFieldEnd()
    if self.serviceUpdated is not None:
      oprot.writeFieldBegin('serviceUpdated', TType.I64, 8)
      oprot.writeI64(self.serviceUpdated)
      oprot.writeFieldEnd()
    if self.publishing is not None:
      oprot.writeFieldBegin('publishing', TType.STRUCT, 10)
      self.publishing.write(oprot)
      oprot.writeFieldEnd()
    if self.published is not None:
      oprot.writeFieldBegin('published', TType.BOOL, 11)
      oprot.writeBool(self.published)
      oprot.writeFieldEnd()
    if self.stack is not None:
      oprot.writeFieldBegin('stack', TType.STRING, 12)
      oprot.writeString(self.stack)
      oprot.writeFieldEnd()
    if self.sharedNotebookIds is not None:
      oprot.writeFieldBegin('sharedNotebookIds', TType.LIST, 13)
      oprot.writeListBegin(TType.I64, len(self.sharedNotebookIds))
      for iter72 in self.sharedNotebookIds:
        oprot.writeI64(iter72)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sharedNotebooks is not None:
      oprot.writeFieldBegin('sharedNotebooks', TType.LIST, 14)
      oprot.writeListBegin(TType.STRUCT, len(self.sharedNotebooks))
      for iter73 in self.sharedNotebooks:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.businessNotebook is not None:
      oprot.writeFieldBegin('businessNotebook', TType.STRUCT, 15)
      self.businessNotebook.write(oprot)
      oprot.writeFieldEnd()
    if self.contact is not None:
      oprot.writeFieldBegin('contact', TType.STRUCT, 16)
      self.contact.write(oprot)
      oprot.writeFieldEnd()
    if self.restrictions is not None:
      oprot.writeFieldBegin('restrictions', TType.STRUCT, 17)
      self.restrictions.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LinkedNotebook(object):
  """
  A link in an users account that refers them to a public or individual share in
  another user's account.
  
  <dl>
  <dt>shareName</dt>
  <dd>the display name of the shared notebook.
    The link owner can change this.</dd>
  
  <dt>username</dt>
  <dd>the username of the user who owns the shared or public notebook</dd>
  
  <dt>shardId</dt>
  <dd>the shard ID of the notebook if the notebook is not public</dt>
  
  <dt>shareKey</dt>
  <dd>the secret key that provides access to the shared notebook</dd>
  
  <dt>uri</dt>
  <dd>the identifier of the public notebook</dd>
  
  <dt>guid</dt>
    <dd>The unique identifier of this linked notebook.  Will be set whenever
    a linked notebook is retrieved from the service, but may be null when a client
    is creating a linked notebook.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object.  The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>noteStoreUrl</dt>
    <dd>
    This field will contain the full URL that clients should use to make
    NoteStore requests to the server shard that contains that notebook's data.
    I.e. this is the URL that should be used to create the Thrift HTTP client
    transport to send messages to the NoteStore service for the account.
    </dd>
  
  <dt>webApiUrlPrefix:</dt>
    <dd>
    This field will contain the initial part of the URLs that should be used
    to make requests to Evernote's thin client "web API", which provide
    optimized operations for clients that aren't capable of manipulating
    the full contents of accounts via the full Thrift data model. Clients
    should concatenate the relative path for the various servlets onto the
    end of this string to construct the full URL, as documented on our
    developer web site.
    </dd>
  
  <dt>stack</dt>
    <dd>If this is set, then the notebook is visually contained within a stack
    of notebooks with this name.  All notebooks in the same account with the
    same 'stack' field are considered to be in the same stack.
    Notebooks with no stack set are "top level" and not contained within a
    stack.  The link owner can change this and this field is for the benefit
    of the link owner.
    </dd>
  
  <dt>businessId</dt>
    <dd>If set, this will be the unique identifier for the business that owns
    the notebook to which the linked notebook refers.
  
  </dl>
  
  Attributes:
   - shareName
   - username
   - shardId
   - shareKey
   - uri
   - guid
   - updateSequenceNum
   - noteStoreUrl
   - webApiUrlPrefix
   - stack
   - businessId
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'shareName', None, None, ), # 2
    (3, TType.STRING, 'username', None, None, ), # 3
    (4, TType.STRING, 'shardId', None, None, ), # 4
    (5, TType.STRING, 'shareKey', None, None, ), # 5
    (6, TType.STRING, 'uri', None, None, ), # 6
    (7, TType.STRING, 'guid', None, None, ), # 7
    (8, TType.I32, 'updateSequenceNum', None, None, ), # 8
    (9, TType.STRING, 'noteStoreUrl', None, None, ), # 9
    (10, TType.STRING, 'webApiUrlPrefix', None, None, ), # 10
    (11, TType.STRING, 'stack', None, None, ), # 11
    (12, TType.I32, 'businessId', None, None, ), # 12
  )

  def __init__(self, shareName=None, username=None, shardId=None, shareKey=None, uri=None, guid=None, updateSequenceNum=None, noteStoreUrl=None, webApiUrlPrefix=None, stack=None, businessId=None,):
    self.shareName = shareName
    self.username = username
    self.shardId = shardId
    self.shareKey = shareKey
    self.uri = uri
    self.guid = guid
    self.updateSequenceNum = updateSequenceNum
    self.noteStoreUrl = noteStoreUrl
    self.webApiUrlPrefix = webApiUrlPrefix
    self.stack = stack
    self.businessId = businessId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.shareName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.shardId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.shareKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.noteStoreUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.webApiUrlPrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.stack = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.businessId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LinkedNotebook')
    if self.shareName is not None:
      oprot.writeFieldBegin('shareName', TType.STRING, 2)
      oprot.writeString(self.shareName)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 3)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.shardId is not None:
      oprot.writeFieldBegin('shardId', TType.STRING, 4)
      oprot.writeString(self.shardId)
      oprot.writeFieldEnd()
    if self.shareKey is not None:
      oprot.writeFieldBegin('shareKey', TType.STRING, 5)
      oprot.writeString(self.shareKey)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 6)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 7)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 8)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.noteStoreUrl is not None:
      oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 9)
      oprot.writeString(self.noteStoreUrl)
      oprot.writeFieldEnd()
    if self.webApiUrlPrefix is not None:
      oprot.writeFieldBegin('webApiUrlPrefix', TType.STRING, 10)
      oprot.writeString(self.webApiUrlPrefix)
      oprot.writeFieldEnd()
    if self.stack is not None:
      oprot.writeFieldBegin('stack', TType.STRING, 11)
      oprot.writeString(self.stack)
      oprot.writeFieldEnd()
    if self.businessId is not None:
      oprot.writeFieldBegin('businessId', TType.I32, 12)
      oprot.writeI32(self.businessId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotebookDescriptor(object):
  """
  A structure that describes a notebook or a user's relationship with
  a notebook. NotebookDescriptor is expected to remain a lighter-weight
  structure when compared to Notebook.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of the notebook.
    </dd>
  
  <dt>notebookDisplayName</dt>
    <dd>A sequence of characters representing the name of the
    notebook.
    </dd>
  
  <dt>contactName</dt>
    <dd>The User.name value of the notebook's "contact".
    </dd>
  
  <dt>hasSharedNotebook</dt>
    <dd>Whether a SharedNotebook record exists between the calling user and this
    notebook.
    </dd>
  
  <dt>joinedUserCount</dt>
    <dd>The number of users who have joined this notebook.
    </dd>
  
  </dl>
  
  Attributes:
   - guid
   - notebookDisplayName
   - contactName
   - hasSharedNotebook
   - joinedUserCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'notebookDisplayName', None, None, ), # 2
    (3, TType.STRING, 'contactName', None, None, ), # 3
    (4, TType.BOOL, 'hasSharedNotebook', None, None, ), # 4
    (5, TType.I32, 'joinedUserCount', None, None, ), # 5
  )

  def __init__(self, guid=None, notebookDisplayName=None, contactName=None, hasSharedNotebook=None, joinedUserCount=None,):
    self.guid = guid
    self.notebookDisplayName = notebookDisplayName
    self.contactName = contactName
    self.hasSharedNotebook = hasSharedNotebook
    self.joinedUserCount = joinedUserCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.notebookDisplayName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.contactName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.hasSharedNotebook = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.joinedUserCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotebookDescriptor')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.notebookDisplayName is not None:
      oprot.writeFieldBegin('notebookDisplayName', TType.STRING, 2)
      oprot.writeString(self.notebookDisplayName)
      oprot.writeFieldEnd()
    if self.contactName is not None:
      oprot.writeFieldBegin('contactName', TType.STRING, 3)
      oprot.writeString(self.contactName)
      oprot.writeFieldEnd()
    if self.hasSharedNotebook is not None:
      oprot.writeFieldBegin('hasSharedNotebook', TType.BOOL, 4)
      oprot.writeBool(self.hasSharedNotebook)
      oprot.writeFieldEnd()
    if self.joinedUserCount is not None:
      oprot.writeFieldBegin('joinedUserCount', TType.I32, 5)
      oprot.writeI32(self.joinedUserCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *

EDAM_VERSION_MAJOR = 1
EDAM_VERSION_MINOR = 25

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class PublicUserInfo(object):
  """
   This structure is used to provide publicly-available user information
   about a particular account.
  <dl>
   <dt>userId:</dt>
     <dd>
     The unique numeric user identifier for the user account.
     </dd>
   <dt>shardId:</dt>
     <dd>
     DEPRECATED - Client applications should have no need to use this field.
     </dd>
   <dt>privilege:</dt>
     <dd>
     The privilege level of the account, to determine whether
     this is a Premium or Free account.
     </dd>
   <dt>noteStoreUrl:</dt>
     <dd>
     This field will contain the full URL that clients should use to make
     NoteStore requests to the server shard that contains that user's data.
     I.e. this is the URL that should be used to create the Thrift HTTP client
     transport to send messages to the NoteStore service for the account.
     </dd>
   <dt>webApiUrlPrefix:</dt>
     <dd>
     This field will contain the initial part of the URLs that should be used
     to make requests to Evernote's thin client "web API", which provide
     optimized operations for clients that aren't capable of manipulating
     the full contents of accounts via the full Thrift data model. Clients
     should concatenate the relative path for the various servlets onto the
     end of this string to construct the full URL, as documented on our
     developer web site.
     </dd>
   </dl>
  
  Attributes:
   - userId
   - shardId
   - privilege
   - username
   - noteStoreUrl
   - webApiUrlPrefix
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
    (2, TType.STRING, 'shardId', None, None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    (4, TType.STRING, 'username', None, None, ), # 4
    (5, TType.STRING, 'noteStoreUrl', None, None, ), # 5
    (6, TType.STRING, 'webApiUrlPrefix', None, None, ), # 6
  )

  def __init__(self, userId=None, shardId=None, privilege=None, username=None, noteStoreUrl=None, webApiUrlPrefix=None,):
    self.userId = userId
    self.shardId = shardId
    self.privilege = privilege
    self.username = username
    self.noteStoreUrl = noteStoreUrl
    self.webApiUrlPrefix = webApiUrlPrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.shardId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.noteStoreUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.webApiUrlPrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PublicUserInfo')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.shardId is not None:
      oprot.writeFieldBegin('shardId', TType.STRING, 2)
      oprot.writeString(self.shardId)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 4)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.noteStoreUrl is not None:
      oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 5)
      oprot.writeString(self.noteStoreUrl)
      oprot.writeFieldEnd()
    if self.webApiUrlPrefix is not None:
      oprot.writeFieldBegin('webApiUrlPrefix', TType.STRING, 6)
      oprot.writeString(self.webApiUrlPrefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    if self.shardId is None:
      raise TProtocol.TProtocolException(message='Required field shardId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthenticationResult(object):
  """
   When an authentication (or re-authentication) is performed, this structure
   provides the result to the client.
  <dl>
   <dt>currentTime:</dt>
     <dd>
     The server-side date and time when this result was
     generated.
     </dd>
   <dt>authenticationToken:</dt>
     <dd>
     Holds an opaque, ASCII-encoded token that can be
     used by the client to perform actions on a NoteStore.
     </dd>
   <dt>expiration:</dt>
     <dd>
     Holds the server-side date and time when the
     authentication token will expire.
     This time can be compared to "currentTime" to produce an expiration
     time that can be reconciled with the client's local clock.
     </dd>
   <dt>user:</dt>
     <dd>
     Holds the information about the account which was
     authenticated if this was a full authentication.  May be absent if this
     particular authentication did not require user information.
     </dd>
   <dt>publicUserInfo:</dt>
     <dd>
     If this authentication result was achieved without full permissions to
     access the full User structure, this field may be set to give back
     a more limited public set of data.
     </dd>
   <dt>noteStoreUrl:</dt>
     <dd>
     This field will contain the full URL that clients should use to make
     NoteStore requests to the server shard that contains that user's data.
     I.e. this is the URL that should be used to create the Thrift HTTP client
     transport to send messages to the NoteStore service for the account.
     </dd>
   <dt>webApiUrlPrefix:</dt>
     <dd>
     This field will contain the initial part of the URLs that should be used
     to make requests to Evernote's thin client "web API", which provide
     optimized operations for clients that aren't capable of manipulating
     the full contents of accounts via the full Thrift data model. Clients
     should concatenate the relative path for the various servlets onto the
     end of this string to construct the full URL, as documented on our
     developer web site.
     </dd>
   <dt>secondFactorRequired:</dt>
     <dd>
     If set to true, this field indicates that the user has enabled two-factor
     authentication and must enter their second factor in order to complete
     authentication. In this case the value of authenticationResult will be
     a short-lived authentication token that may only be used to make a
     subsequent call to completeTwoFactorAuthentication.
     </dd>
   <dt>secondFactorDeliveryHint:</dt>
     <dd>
     When secondFactorRequired is set to true, this field may contain a string
     describing the second factor delivery method that the user has configured.
     This will typically be an obfuscated mobile device number, such as
     "(xxx) xxx-x095". This string can be displayed to the user to remind them
     how to obtain the required second factor.
     TODO do we need to differentiate between SMS and voice delivery?
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - authenticationToken
   - expiration
   - user
   - publicUserInfo
   - noteStoreUrl
   - webApiUrlPrefix
   - secondFactorRequired
   - secondFactorDeliveryHint
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.STRING, 'authenticationToken', None, None, ), # 2
    (3, TType.I64, 'expiration', None, None, ), # 3
    (4, TType.STRUCT, 'user', (evernote.edam.type.ttypes.User, evernote.edam.type.ttypes.User.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'publicUserInfo', (PublicUserInfo, PublicUserInfo.thrift_spec), None, ), # 5
    (6, TType.STRING, 'noteStoreUrl', None, None, ), # 6
    (7, TType.STRING, 'webApiUrlPrefix', None, None, ), # 7
    (8, TType.BOOL, 'secondFactorRequired', None, None, ), # 8
    (9, TType.STRING, 'secondFactorDeliveryHint', None, None, ), # 9
  )

  def __init__(self, currentTime=None, authenticationToken=None, expiration=None, user=None, publicUserInfo=None, noteStoreUrl=None, webApiUrlPrefix=None, secondFactorRequired=None, secondFactorDeliveryHint=None,):
    self.currentTime = currentTime
    self.authenticationToken = authenticationToken
    self.expiration = expiration
    self.user = user
    self.publicUserInfo = publicUserInfo
    self.noteStoreUrl = noteStoreUrl
    self.webApiUrlPrefix = webApiUrlPrefix
    self.secondFactorRequired = secondFactorRequired
    self.secondFactorDeliveryHint = secondFactorDeliveryHint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.expiration = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.user = evernote.edam.type.ttypes.User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.publicUserInfo = PublicUserInfo()
          self.publicUserInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.noteStoreUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.webApiUrlPrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.secondFactorRequired = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.secondFactorDeliveryHint = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthenticationResult')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 2)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.expiration is not None:
      oprot.writeFieldBegin('expiration', TType.I64, 3)
      oprot.writeI64(self.expiration)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 4)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.publicUserInfo is not None:
      oprot.writeFieldBegin('publicUserInfo', TType.STRUCT, 5)
      self.publicUserInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.noteStoreUrl is not None:
      oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 6)
      oprot.writeString(self.noteStoreUrl)
      oprot.writeFieldEnd()
    if self.webApiUrlPrefix is not None:
      oprot.writeFieldBegin('webApiUrlPrefix', TType.STRING, 7)
      oprot.writeString(self.webApiUrlPrefix)
      oprot.writeFieldEnd()
    if self.secondFactorRequired is not None:
      oprot.writeFieldBegin('secondFactorRequired', TType.BOOL, 8)
      oprot.writeBool(self.secondFactorRequired)
      oprot.writeFieldEnd()
    if self.secondFactorDeliveryHint is not None:
      oprot.writeFieldBegin('secondFactorDeliveryHint', TType.STRING, 9)
      oprot.writeString(self.secondFactorDeliveryHint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.authenticationToken is None:
      raise TProtocol.TProtocolException(message='Required field authenticationToken is unset!')
    if self.expiration is None:
      raise TProtocol.TProtocolException(message='Required field expiration is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BootstrapSettings(object):
  """
   This structure describes a collection of bootstrap settings.
  <dl>
   <dt>serviceHost:</dt>
     <dd>
     The hostname and optional port for composing Evernote web service URLs.
     This URL can be used to access the UserStore and related services,
     but must not be used to compose the NoteStore URL. Client applications
     must handle serviceHost values that include only the hostname
     (e.g. www.evernote.com) or both the hostname and port (e.g. www.evernote.com:8080).
     If no port is specified, or if port 443 is specified, client applications must
     use the scheme "https" when composing URLs. Otherwise, a client must use the
     scheme "http".
   </dd>
   <dt>marketingUrl:</dt>
     <dd>
     The URL stem for the Evernote corporate marketing website, e.g. http://www.evernote.com.
     This stem can be used to compose website URLs. For example, the URL of the Evernote
     Trunk is composed by appending "/about/trunk/" to the value of marketingUrl.
     </dd>
   <dt>supportUrl:</dt>
     <dd>
     The full URL for the Evernote customer support website, e.g. https://support.evernote.com.
     </dd>
   <dt>accountEmailDomain:</dt>
     <dd>
     The domain used for an Evernote user's incoming email address, which allows notes to
     be emailed into an account. E.g. m.evernote.com.
     </dd>
   <dt>enableFacebookSharing:</dt>
     <dd>
     Whether the client application should enable sharing of notes on Facebook.
     </dd>
   <dt>enableGiftSubscriptions:</dt>
     <dd>
     Whether the client application should enable gift subscriptions.
     </dd>
   <dt>enableSupportTickets:</dt>
     <dd>
     Whether the client application should enable in-client creation of support tickets.
     </dd>
   <dt>enableSharedNotebooks:</dt>
     <dd>
     Whether the client application should enable shared notebooks.
     </dd>
   <dt>enableSingleNoteSharing:</dt>
     <dd>
     Whether the client application should enable single note sharing.
     </dd>
   <dt>enableSponsoredAccounts:</dt>
     <dd>
     Whether the client application should enable sponsored accounts.
     </dd>
   <dt>enableTwitterSharing:</dt>
     <dd>
     Whether the client application should enable sharing of notes on Twitter.
     </dd>
   </dl>
  
  Attributes:
   - serviceHost
   - marketingUrl
   - supportUrl
   - accountEmailDomain
   - enableFacebookSharing
   - enableGiftSubscriptions
   - enableSupportTickets
   - enableSharedNotebooks
   - enableSingleNoteSharing
   - enableSponsoredAccounts
   - enableTwitterSharing
   - enableLinkedInSharing
   - enablePublicNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serviceHost', None, None, ), # 1
    (2, TType.STRING, 'marketingUrl', None, None, ), # 2
    (3, TType.STRING, 'supportUrl', None, None, ), # 3
    (4, TType.STRING, 'accountEmailDomain', None, None, ), # 4
    (5, TType.BOOL, 'enableFacebookSharing', None, None, ), # 5
    (6, TType.BOOL, 'enableGiftSubscriptions', None, None, ), # 6
    (7, TType.BOOL, 'enableSupportTickets', None, None, ), # 7
    (8, TType.BOOL, 'enableSharedNotebooks', None, None, ), # 8
    (9, TType.BOOL, 'enableSingleNoteSharing', None, None, ), # 9
    (10, TType.BOOL, 'enableSponsoredAccounts', None, None, ), # 10
    (11, TType.BOOL, 'enableTwitterSharing', None, None, ), # 11
    (12, TType.BOOL, 'enableLinkedInSharing', None, None, ), # 12
    (13, TType.BOOL, 'enablePublicNotebooks', None, None, ), # 13
  )

  def __init__(self, serviceHost=None, marketingUrl=None, supportUrl=None, accountEmailDomain=None, enableFacebookSharing=None, enableGiftSubscriptions=None, enableSupportTickets=None, enableSharedNotebooks=None, enableSingleNoteSharing=None, enableSponsoredAccounts=None, enableTwitterSharing=None, enableLinkedInSharing=None, enablePublicNotebooks=None,):
    self.serviceHost = serviceHost
    self.marketingUrl = marketingUrl
    self.supportUrl = supportUrl
    self.accountEmailDomain = accountEmailDomain
    self.enableFacebookSharing = enableFacebookSharing
    self.enableGiftSubscriptions = enableGiftSubscriptions
    self.enableSupportTickets = enableSupportTickets
    self.enableSharedNotebooks = enableSharedNotebooks
    self.enableSingleNoteSharing = enableSingleNoteSharing
    self.enableSponsoredAccounts = enableSponsoredAccounts
    self.enableTwitterSharing = enableTwitterSharing
    self.enableLinkedInSharing = enableLinkedInSharing
    self.enablePublicNotebooks = enablePublicNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serviceHost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.marketingUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.supportUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accountEmailDomain = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enableFacebookSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enableGiftSubscriptions = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enableSupportTickets = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.enableSharedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enableSingleNoteSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.enableSponsoredAccounts = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.enableTwitterSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.enableLinkedInSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.enablePublicNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BootstrapSettings')
    if self.serviceHost is not None:
      oprot.writeFieldBegin('serviceHost', TType.STRING, 1)
      oprot.writeString(self.serviceHost)
      oprot.writeFieldEnd()
    if self.marketingUrl is not None:
      oprot.writeFieldBegin('marketingUrl', TType.STRING, 2)
      oprot.writeString(self.marketingUrl)
      oprot.writeFieldEnd()
    if self.supportUrl is not None:
      oprot.writeFieldBegin('supportUrl', TType.STRING, 3)
      oprot.writeString(self.supportUrl)
      oprot.writeFieldEnd()
    if self.accountEmailDomain is not None:
      oprot.writeFieldBegin('accountEmailDomain', TType.STRING, 4)
      oprot.writeString(self.accountEmailDomain)
      oprot.writeFieldEnd()
    if self.enableFacebookSharing is not None:
      oprot.writeFieldBegin('enableFacebookSharing', TType.BOOL, 5)
      oprot.writeBool(self.enableFacebookSharing)
      oprot.writeFieldEnd()
    if self.enableGiftSubscriptions is not None:
      oprot.writeFieldBegin('enableGiftSubscriptions', TType.BOOL, 6)
      oprot.writeBool(self.enableGiftSubscriptions)
      oprot.writeFieldEnd()
    if self.enableSupportTickets is not None:
      oprot.writeFieldBegin('enableSupportTickets', TType.BOOL, 7)
      oprot.writeBool(self.enableSupportTickets)
      oprot.writeFieldEnd()
    if self.enableSharedNotebooks is not None:
      oprot.writeFieldBegin('enableSharedNotebooks', TType.BOOL, 8)
      oprot.writeBool(self.enableSharedNotebooks)
      oprot.writeFieldEnd()
    if self.enableSingleNoteSharing is not None:
      oprot.writeFieldBegin('enableSingleNoteSharing', TType.BOOL, 9)
      oprot.writeBool(self.enableSingleNoteSharing)
      oprot.writeFieldEnd()
    if self.enableSponsoredAccounts is not None:
      oprot.writeFieldBegin('enableSponsoredAccounts', TType.BOOL, 10)
      oprot.writeBool(self.enableSponsoredAccounts)
      oprot.writeFieldEnd()
    if self.enableTwitterSharing is not None:
      oprot.writeFieldBegin('enableTwitterSharing', TType.BOOL, 11)
      oprot.writeBool(self.enableTwitterSharing)
      oprot.writeFieldEnd()
    if self.enableLinkedInSharing is not None:
      oprot.writeFieldBegin('enableLinkedInSharing', TType.BOOL, 12)
      oprot.writeBool(self.enableLinkedInSharing)
      oprot.writeFieldEnd()
    if self.enablePublicNotebooks is not None:
      oprot.writeFieldBegin('enablePublicNotebooks', TType.BOOL, 13)
      oprot.writeBool(self.enablePublicNotebooks)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.serviceHost is None:
      raise TProtocol.TProtocolException(message='Required field serviceHost is unset!')
    if self.marketingUrl is None:
      raise TProtocol.TProtocolException(message='Required field marketingUrl is unset!')
    if self.supportUrl is None:
      raise TProtocol.TProtocolException(message='Required field supportUrl is unset!')
    if self.accountEmailDomain is None:
      raise TProtocol.TProtocolException(message='Required field accountEmailDomain is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BootstrapProfile(object):
  """
   This structure describes a collection of bootstrap settings.
  <dl>
   <dt>name:</dt>
     <dd>
     The unique name of the profile, which is guaranteed to remain consistent across
     calls to getBootstrapInfo.
     </dd>
   <dt>settings:</dt>
     <dd>
     The settings for this profile.
     </dd>
   </dl>
  
  Attributes:
   - name
   - settings
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'settings', (BootstrapSettings, BootstrapSettings.thrift_spec), None, ), # 2
  )

  def __init__(self, name=None, settings=None,):
    self.name = name
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.settings = BootstrapSettings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BootstrapProfile')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 2)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.settings is None:
      raise TProtocol.TProtocolException(message='Required field settings is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BootstrapInfo(object):
  """
   This structure describes a collection of bootstrap profiles.
  <dl>
   <dt>profiles:</dt>
     <dd>
     List of one or more bootstrap profiles, in descending
     preference order.
     </dd>
   </dl>
  
  Attributes:
   - profiles
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'profiles', (TType.STRUCT,(BootstrapProfile, BootstrapProfile.thrift_spec)), None, ), # 1
  )

  def __init__(self, profiles=None,):
    self.profiles = profiles

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.profiles = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = BootstrapProfile()
            _elem5.read(iprot)
            self.profiles.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BootstrapInfo')
    if self.profiles is not None:
      oprot.writeFieldBegin('profiles', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.profiles))
      for iter6 in self.profiles:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.profiles is None:
      raise TProtocol.TProtocolException(message='Required field profiles is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = UserStore
#
# Autogenerated by Thrift Compiler
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  """
  Service:  UserStore
  <p>
  The UserStore service is primarily used by EDAM clients to establish
  authentication via username and password over a trusted connection (e.g.
  SSL).  A client's first call to this interface should be checkVersion() to
  ensure that the client's software is up to date.
  </p>
  All calls which require an authenticationToken may throw an
  EDAMUserException for the following reasons:
   <ul>
    <li> AUTH_EXPIRED "authenticationToken" - token has expired
    <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    <li> DATA_REQUIRED "authenticationToken" - token is empty
    <li> INVALID_AUTH "authenticationToken" - token signature is invalid
  </ul>
  """
  def checkVersion(self, clientName, edamVersionMajor, edamVersionMinor):
    """
    This should be the first call made by a client to the EDAM service.  It
    tells the service what protocol version is used by the client.  The
    service will then return true if the client is capable of talking to
    the service, and false if the client's protocol version is incompatible
    with the service, so the client must upgrade.  If a client receives a
    false value, it should report the incompatibility to the user and not
    continue with any more EDAM requests (UserStore or NoteStore).
    
    @param clientName
      This string provides some information about the client for
      tracking/logging on the service.  It should provide information about
      the client's software and platform. The structure should be:
      application/version; platform/version; [ device/version ]
      E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
    
    @param edamVersionMajor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MAJOR
      constant for the client.
    
    @param edamVersionMinor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MINOR
      constant for the client.
    
    Parameters:
     - clientName
     - edamVersionMajor
     - edamVersionMinor
    """
    pass

  def getBootstrapInfo(self, locale):
    """
    This provides bootstrap information to the client. Various bootstrap
    profiles and settings may be used by the client to configure itself.
    
    @param locale
      The client's current locale, expressed in language[_country]
      format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      language and country codes.
    
    @return
      The bootstrap information suitable for this client.
    
    Parameters:
     - locale
    """
    pass

  def authenticate(self, username, password, consumerKey, consumerSecret, supportsTwoFactor):
    """
    This is used to check a username and password in order to create a
    short-lived authentication session that can be used for further actions.
    
    This function is only available to Evernote's internal applications.
    Third party applications must authenticate using OAuth as
    described at
    <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
    
    @param username
      The username (not numeric user ID) for the account to
      authenticate against.  This function will also accept the user's
      registered email address in this parameter.
    
    @param password
      The plaintext password to check against the account.  Since
      this is not protected by the EDAM protocol, this information must be
      provided over a protected transport (e.g. SSL).
    
    @param consumerKey
      The "consumer key" portion of the API key issued to the client application
      by Evernote.
    
    @param consumerSecret
      The "consumer secret" portion of the API key issued to the client application
      by Evernote.
    
    @param supportsTwoFactor
      Whether the calling application supports two-factor authentication. If this
      parameter is false, this method will fail with the error code INVALID_AUTH and the
      parameter "password" when called for a user who has enabled two-factor
      authentication.
    
    @return
      <p>The result of the authentication.  If the authentication was successful,
      the AuthenticationResult.user field will be set with the full information
      about the User.</p>
      <p>If the user has two-factor authentication enabled,
      AuthenticationResult.secondFactorRequired will be set and
      AuthenticationResult.authenticationToken will contain a short-lived token
      that may only be used to complete the two-factor authentication process by calling
      UserStore.completeTwoFactorAuthentication.</p>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
      <li> DATA_REQUIRED "password" - password is empty
      <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      <li> INVALID_AUTH "username" - username not found
      <li> INVALID_AUTH "password" - password did not match
      <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
    </ul>
    
    Parameters:
     - username
     - password
     - consumerKey
     - consumerSecret
     - supportsTwoFactor
    """
    pass

  def authenticateLongSession(self, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor):
    """
    This is used to check a username and password in order to create a
    long-lived authentication token that can be used for further actions.
    
    This function is not available to most third party applications,
    which typically authenticate using OAuth as
    described at
    <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
    If you believe that your application requires permission to authenticate
    using username and password instead of OAuth, please contact Evernote
    developer support by visiting
    <a href="http://dev.evernote.com">dev.evernote.com</a>.
    
    @param username
      The username or registered email address of the account to
      authenticate against.
    
    @param password
      The plaintext password to check against the account.  Since
      this is not protected by the EDAM protocol, this information must be
      provided over a protected transport (i.e. SSL).
    
    @param consumerKey
      The "consumer key" portion of the API key issued to the client application
      by Evernote.
    
    @param consumerSecret
      The "consumer secret" portion of the API key issued to the client application
      by Evernote.
    
    @param deviceIdentifier
      An optional string, no more than 32 characters in length, that uniquely identifies
      the device from which the authentication is being performed. This string allows
      the service to return the same authentication token when a given application
      requests authentication repeatedly from the same device. This may happen when the
      user logs out of an application and then logs back in, or when the application is
      uninstalled and later reinstalled. If no reliable device identifier can be created,
      this value should be omitted. If set, the device identifier must be between
      1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
      EDAM_DEVICE_ID_REGEX.
    
    @param deviceDescription
      A description of the device from which the authentication is being performed.
      This field is displayed to the user in a list of authorized applications to
      allow them to distinguish between multiple tokens issued to the same client
      application on different devices. For example, the Evernote iOS client on
      a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
      "Bob's iPad". The device description must be between 1 and
      EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
      expression EDAM_DEVICE_DESCRIPTION_REGEX.
    
    @param supportsTwoFactor
      Whether the calling application supports two-factor authentication. If this
      parameter is false, this method will fail with the error code INVALID_AUTH and the
      parameter "password" when called for a user who has enabled two-factor
      authentication.
    
    @return
      <p>The result of the authentication. The level of detail provided in the returned
      AuthenticationResult.User structure depends on the access level granted by
      calling application's API key.</p>
      <p>If the user has two-factor authentication enabled,
      AuthenticationResult.secondFactorRequired will be set and
      AuthenticationResult.authenticationToken will contain a short-lived token
      that may only be used to complete the two-factor authentication process by calling
      UserStore.completeTwoFactorAuthentication.</p>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
      <li> DATA_REQUIRED "password" - password is empty
      <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
      <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
      <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
      <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
      <li> INVALID_AUTH "username" - username not found
      <li> INVALID_AUTH "password" - password did not match
      <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
    </ul>
    
    Parameters:
     - username
     - password
     - consumerKey
     - consumerSecret
     - deviceIdentifier
     - deviceDescription
     - supportsTwoFactor
    """
    pass

  def completeTwoFactorAuthentication(self, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription):
    """
    Complete the authentication process when a second factor is required. This
    call is made after a successful call to authenticate or authenticateLongSession
    when the authenticating user has enabled two-factor authentication.
    
    @param authenticationToken An authentication token returned by a previous
      call to UserStore.authenticate or UserStore.authenticateLongSession that
      could not be completed in a single call because a second factor was required.
    
    @param oneTimeCode The one time code entered by the user. This value is delivered
      out-of-band, typically via SMS or an authenticator application.
    
    @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
    
    @param deviceDescription See the corresponding parameter in authenticateLongSession.
    
    @return
      The result of the authentication. The level of detail provided in the returned
      AuthenticationResult.User structure depends on the access level granted by the
      calling application's API key. If the initial authentication call was made to
      authenticateLongSession, the AuthenticationResult will contain a long-lived
      authentication token.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
      <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
      <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
      <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
      <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
      <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
      <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
         two-factor authentication.</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - oneTimeCode
     - deviceIdentifier
     - deviceDescription
    """
    pass

  def revokeLongSession(self, authenticationToken):
    """
    Revoke an existing long lived authentication token. This can be used to
    revoke OAuth tokens or tokens created by calling authenticateLongSession,
    and allows a user to effectively log out of Evernote from the perspective
    of the application that holds the token. The authentication token that is
    passed is immediately revoked and may not be used to call any authenticated
    EDAM function.
    
    @param authenticationToken the authentication token to revoke.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
      <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
      <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
      <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
        is already revoked.
    </ul>
    
    Parameters:
     - authenticationToken
    """
    pass

  def authenticateToBusiness(self, authenticationToken):
    """
    This is used to take an existing authentication token that grants access
    to an individual user account (returned from 'authenticate',
    'authenticateLongSession' or an OAuth authorization) and obtain an additional
    authentication token that may be used to access business notebooks if the user
    is a member of an Evernote Business account.
    
    The resulting authentication token may be used to make NoteStore API calls
    against the business using the NoteStore URL returned in the result.
    
    @param authenticationToken
      The authentication token for the user. This may not be a shared authentication
      token (returned by NoteStore.authenticateToSharedNotebook or
      NoteStore.authenticateToSharedNote) or a business authentication token.
    
    @return
      The result of the authentication, with the token granting access to the
      business in the result's 'authenticationToken' field. The URL that must
      be used to access the business account NoteStore will be returned in the
      result's 'noteStoreUrl' field.  The 'User' field will
      not be set in the result.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
           is a shared or business authentication token. </li>
      <li> PERMISSION_DENIED "Business" - the user identified by the provided
           authentication token is not currently a member of a business. </li>
      <li> PERMISSION_DENIED "Business.status" - the business that the user is a
           member of is not currently in an active status. </li>
    </ul>
    
    Parameters:
     - authenticationToken
    """
    pass

  def refreshAuthentication(self, authenticationToken):
    """
    This is used to take an existing authentication token (returned from
    'authenticate') and exchange it for a newer token which will not expire
    as soon.  This must be invoked before the previous token expires.
    
    This function is only availabe to Evernote's internal applications.
    
    @param authenticationToken
      The previous authentication token from the authenticate() result.
    
    @return
      The result of the authentication, with the new token in
      the result's 'authenticationToken' field.  The 'User' field will
      not be set in the result.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getUser(self, authenticationToken):
    """
    Returns the User corresponding to the provided authentication token,
    or throws an exception if this token is not valid.
    The level of detail provided in the returned User structure depends on
    the access level granted by the token, so a web service client may receive
    fewer fields than an integrated desktop client.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getPublicUserInfo(self, username):
    """
    Asks the UserStore about the publicly available location information for
    a particular username.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
    </ul>
    
    Parameters:
     - username
    """
    pass

  def getPremiumInfo(self, authenticationToken):
    """
    Returns information regarding a user's Premium account corresponding to the
    provided authentication token, or throws an exception if this token is not
    valid.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getNoteStoreUrl(self, authenticationToken):
    """
    Returns the URL that should be used to talk to the NoteStore for the
    account represented by the provided authenticationToken.
    This method isn't needed by most clients, who can retrieve the correct
    NoteStore URL from the AuthenticationResult returned from the authenticate
    or refreshAuthentication calls. This method is typically only needed
    to look up the correct URL for a long-lived session token (e.g. for an
    OAuth web service).
    
    Parameters:
     - authenticationToken
    """
    pass


class Client(Iface):
  """
  Service:  UserStore
  <p>
  The UserStore service is primarily used by EDAM clients to establish
  authentication via username and password over a trusted connection (e.g.
  SSL).  A client's first call to this interface should be checkVersion() to
  ensure that the client's software is up to date.
  </p>
  All calls which require an authenticationToken may throw an
  EDAMUserException for the following reasons:
   <ul>
    <li> AUTH_EXPIRED "authenticationToken" - token has expired
    <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    <li> DATA_REQUIRED "authenticationToken" - token is empty
    <li> INVALID_AUTH "authenticationToken" - token signature is invalid
  </ul>
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def checkVersion(self, clientName, edamVersionMajor, edamVersionMinor):
    """
    This should be the first call made by a client to the EDAM service.  It
    tells the service what protocol version is used by the client.  The
    service will then return true if the client is capable of talking to
    the service, and false if the client's protocol version is incompatible
    with the service, so the client must upgrade.  If a client receives a
    false value, it should report the incompatibility to the user and not
    continue with any more EDAM requests (UserStore or NoteStore).
    
    @param clientName
      This string provides some information about the client for
      tracking/logging on the service.  It should provide information about
      the client's software and platform. The structure should be:
      application/version; platform/version; [ device/version ]
      E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
    
    @param edamVersionMajor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MAJOR
      constant for the client.
    
    @param edamVersionMinor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MINOR
      constant for the client.
    
    Parameters:
     - clientName
     - edamVersionMajor
     - edamVersionMinor
    """
    self.send_checkVersion(clientName, edamVersionMajor, edamVersionMinor)
    return self.recv_checkVersion()

  def send_checkVersion(self, clientName, edamVersionMajor, edamVersionMinor):
    self._oprot.writeMessageBegin('checkVersion', TMessageType.CALL, self._seqid)
    args = checkVersion_args()
    args.clientName = clientName
    args.edamVersionMajor = edamVersionMajor
    args.edamVersionMinor = edamVersionMinor
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_checkVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = checkVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "checkVersion failed: unknown result");

  def getBootstrapInfo(self, locale):
    """
    This provides bootstrap information to the client. Various bootstrap
    profiles and settings may be used by the client to configure itself.
    
    @param locale
      The client's current locale, expressed in language[_country]
      format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      language and country codes.
    
    @return
      The bootstrap information suitable for this client.
    
    Parameters:
     - locale
    """
    self.send_getBootstrapInfo(locale)
    return self.recv_getBootstrapInfo()

  def send_getBootstrapInfo(self, locale):
    self._oprot.writeMessageBegin('getBootstrapInfo', TMessageType.CALL, self._seqid)
    args = getBootstrapInfo_args()
    args.locale = locale
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBootstrapInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBootstrapInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBootstrapInfo failed: unknown result");

  def authenticate(self, username, password, consumerKey, consumerSecret, supportsTwoFactor):
    """
    This is used to check a username and password in order to create a
    short-lived authentication session that can be used for further actions.
    
    This function is only available to Evernote's internal applications.
    Third party applications must authenticate using OAuth as
    described at
    <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
    
    @param username
      The username (not numeric user ID) for the account to
      authenticate against.  This function will also accept the user's
      registered email address in this parameter.
    
    @param password
      The plaintext password to check against the account.  Since
      this is not protected by the EDAM protocol, this information must be
      provided over a protected transport (e.g. SSL).
    
    @param consumerKey
      The "consumer key" portion of the API key issued to the client application
      by Evernote.
    
    @param consumerSecret
      The "consumer secret" portion of the API key issued to the client application
      by Evernote.
    
    @param supportsTwoFactor
      Whether the calling application supports two-factor authentication. If this
      parameter is false, this method will fail with the error code INVALID_AUTH and the
      parameter "password" when called for a user who has enabled two-factor
      authentication.
    
    @return
      <p>The result of the authentication.  If the authentication was successful,
      the AuthenticationResult.user field will be set with the full information
      about the User.</p>
      <p>If the user has two-factor authentication enabled,
      AuthenticationResult.secondFactorRequired will be set and
      AuthenticationResult.authenticationToken will contain a short-lived token
      that may only be used to complete the two-factor authentication process by calling
      UserStore.completeTwoFactorAuthentication.</p>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
      <li> DATA_REQUIRED "password" - password is empty
      <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      <li> INVALID_AUTH "username" - username not found
      <li> INVALID_AUTH "password" - password did not match
      <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
    </ul>
    
    Parameters:
     - username
     - password
     - consumerKey
     - consumerSecret
     - supportsTwoFactor
    """
    self.send_authenticate(username, password, consumerKey, consumerSecret, supportsTwoFactor)
    return self.recv_authenticate()

  def send_authenticate(self, username, password, consumerKey, consumerSecret, supportsTwoFactor):
    self._oprot.writeMessageBegin('authenticate', TMessageType.CALL, self._seqid)
    args = authenticate_args()
    args.username = username
    args.password = password
    args.consumerKey = consumerKey
    args.consumerSecret = consumerSecret
    args.supportsTwoFactor = supportsTwoFactor
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticate failed: unknown result");

  def authenticateLongSession(self, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor):
    """
    This is used to check a username and password in order to create a
    long-lived authentication token that can be used for further actions.
    
    This function is not available to most third party applications,
    which typically authenticate using OAuth as
    described at
    <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
    If you believe that your application requires permission to authenticate
    using username and password instead of OAuth, please contact Evernote
    developer support by visiting
    <a href="http://dev.evernote.com">dev.evernote.com</a>.
    
    @param username
      The username or registered email address of the account to
      authenticate against.
    
    @param password
      The plaintext password to check against the account.  Since
      this is not protected by the EDAM protocol, this information must be
      provided over a protected transport (i.e. SSL).
    
    @param consumerKey
      The "consumer key" portion of the API key issued to the client application
      by Evernote.
    
    @param consumerSecret
      The "consumer secret" portion of the API key issued to the client application
      by Evernote.
    
    @param deviceIdentifier
      An optional string, no more than 32 characters in length, that uniquely identifies
      the device from which the authentication is being performed. This string allows
      the service to return the same authentication token when a given application
      requests authentication repeatedly from the same device. This may happen when the
      user logs out of an application and then logs back in, or when the application is
      uninstalled and later reinstalled. If no reliable device identifier can be created,
      this value should be omitted. If set, the device identifier must be between
      1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
      EDAM_DEVICE_ID_REGEX.
    
    @param deviceDescription
      A description of the device from which the authentication is being performed.
      This field is displayed to the user in a list of authorized applications to
      allow them to distinguish between multiple tokens issued to the same client
      application on different devices. For example, the Evernote iOS client on
      a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
      "Bob's iPad". The device description must be between 1 and
      EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
      expression EDAM_DEVICE_DESCRIPTION_REGEX.
    
    @param supportsTwoFactor
      Whether the calling application supports two-factor authentication. If this
      parameter is false, this method will fail with the error code INVALID_AUTH and the
      parameter "password" when called for a user who has enabled two-factor
      authentication.
    
    @return
      <p>The result of the authentication. The level of detail provided in the returned
      AuthenticationResult.User structure depends on the access level granted by
      calling application's API key.</p>
      <p>If the user has two-factor authentication enabled,
      AuthenticationResult.secondFactorRequired will be set and
      AuthenticationResult.authenticationToken will contain a short-lived token
      that may only be used to complete the two-factor authentication process by calling
      UserStore.completeTwoFactorAuthentication.</p>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
      <li> DATA_REQUIRED "password" - password is empty
      <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
      <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
      <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
      <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
      <li> INVALID_AUTH "username" - username not found
      <li> INVALID_AUTH "password" - password did not match
      <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
    </ul>
    
    Parameters:
     - username
     - password
     - consumerKey
     - consumerSecret
     - deviceIdentifier
     - deviceDescription
     - supportsTwoFactor
    """
    self.send_authenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor)
    return self.recv_authenticateLongSession()

  def send_authenticateLongSession(self, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor):
    self._oprot.writeMessageBegin('authenticateLongSession', TMessageType.CALL, self._seqid)
    args = authenticateLongSession_args()
    args.username = username
    args.password = password
    args.consumerKey = consumerKey
    args.consumerSecret = consumerSecret
    args.deviceIdentifier = deviceIdentifier
    args.deviceDescription = deviceDescription
    args.supportsTwoFactor = supportsTwoFactor
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticateLongSession(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticateLongSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateLongSession failed: unknown result");

  def completeTwoFactorAuthentication(self, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription):
    """
    Complete the authentication process when a second factor is required. This
    call is made after a successful call to authenticate or authenticateLongSession
    when the authenticating user has enabled two-factor authentication.
    
    @param authenticationToken An authentication token returned by a previous
      call to UserStore.authenticate or UserStore.authenticateLongSession that
      could not be completed in a single call because a second factor was required.
    
    @param oneTimeCode The one time code entered by the user. This value is delivered
      out-of-band, typically via SMS or an authenticator application.
    
    @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
    
    @param deviceDescription See the corresponding parameter in authenticateLongSession.
    
    @return
      The result of the authentication. The level of detail provided in the returned
      AuthenticationResult.User structure depends on the access level granted by the
      calling application's API key. If the initial authentication call was made to
      authenticateLongSession, the AuthenticationResult will contain a long-lived
      authentication token.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
      <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
      <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
      <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
      <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
      <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
      <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
         two-factor authentication.</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - oneTimeCode
     - deviceIdentifier
     - deviceDescription
    """
    self.send_completeTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription)
    return self.recv_completeTwoFactorAuthentication()

  def send_completeTwoFactorAuthentication(self, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription):
    self._oprot.writeMessageBegin('completeTwoFactorAuthentication', TMessageType.CALL, self._seqid)
    args = completeTwoFactorAuthentication_args()
    args.authenticationToken = authenticationToken
    args.oneTimeCode = oneTimeCode
    args.deviceIdentifier = deviceIdentifier
    args.deviceDescription = deviceDescription
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_completeTwoFactorAuthentication(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = completeTwoFactorAuthentication_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "completeTwoFactorAuthentication failed: unknown result");

  def revokeLongSession(self, authenticationToken):
    """
    Revoke an existing long lived authentication token. This can be used to
    revoke OAuth tokens or tokens created by calling authenticateLongSession,
    and allows a user to effectively log out of Evernote from the perspective
    of the application that holds the token. The authentication token that is
    passed is immediately revoked and may not be used to call any authenticated
    EDAM function.
    
    @param authenticationToken the authentication token to revoke.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
      <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
      <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
      <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
        is already revoked.
    </ul>
    
    Parameters:
     - authenticationToken
    """
    self.send_revokeLongSession(authenticationToken)
    self.recv_revokeLongSession()

  def send_revokeLongSession(self, authenticationToken):
    self._oprot.writeMessageBegin('revokeLongSession', TMessageType.CALL, self._seqid)
    args = revokeLongSession_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revokeLongSession(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = revokeLongSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    return

  def authenticateToBusiness(self, authenticationToken):
    """
    This is used to take an existing authentication token that grants access
    to an individual user account (returned from 'authenticate',
    'authenticateLongSession' or an OAuth authorization) and obtain an additional
    authentication token that may be used to access business notebooks if the user
    is a member of an Evernote Business account.
    
    The resulting authentication token may be used to make NoteStore API calls
    against the business using the NoteStore URL returned in the result.
    
    @param authenticationToken
      The authentication token for the user. This may not be a shared authentication
      token (returned by NoteStore.authenticateToSharedNotebook or
      NoteStore.authenticateToSharedNote) or a business authentication token.
    
    @return
      The result of the authentication, with the token granting access to the
      business in the result's 'authenticationToken' field. The URL that must
      be used to access the business account NoteStore will be returned in the
      result's 'noteStoreUrl' field.  The 'User' field will
      not be set in the result.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
           is a shared or business authentication token. </li>
      <li> PERMISSION_DENIED "Business" - the user identified by the provided
           authentication token is not currently a member of a business. </li>
      <li> PERMISSION_DENIED "Business.status" - the business that the user is a
           member of is not currently in an active status. </li>
    </ul>
    
    Parameters:
     - authenticationToken
    """
    self.send_authenticateToBusiness(authenticationToken)
    return self.recv_authenticateToBusiness()

  def send_authenticateToBusiness(self, authenticationToken):
    self._oprot.writeMessageBegin('authenticateToBusiness', TMessageType.CALL, self._seqid)
    args = authenticateToBusiness_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticateToBusiness(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticateToBusiness_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToBusiness failed: unknown result");

  def refreshAuthentication(self, authenticationToken):
    """
    This is used to take an existing authentication token (returned from
    'authenticate') and exchange it for a newer token which will not expire
    as soon.  This must be invoked before the previous token expires.
    
    This function is only availabe to Evernote's internal applications.
    
    @param authenticationToken
      The previous authentication token from the authenticate() result.
    
    @return
      The result of the authentication, with the new token in
      the result's 'authenticationToken' field.  The 'User' field will
      not be set in the result.
    
    Parameters:
     - authenticationToken
    """
    self.send_refreshAuthentication(authenticationToken)
    return self.recv_refreshAuthentication()

  def send_refreshAuthentication(self, authenticationToken):
    self._oprot.writeMessageBegin('refreshAuthentication', TMessageType.CALL, self._seqid)
    args = refreshAuthentication_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_refreshAuthentication(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = refreshAuthentication_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "refreshAuthentication failed: unknown result");

  def getUser(self, authenticationToken):
    """
    Returns the User corresponding to the provided authentication token,
    or throws an exception if this token is not valid.
    The level of detail provided in the returned User structure depends on
    the access level granted by the token, so a web service client may receive
    fewer fields than an integrated desktop client.
    
    Parameters:
     - authenticationToken
    """
    self.send_getUser(authenticationToken)
    return self.recv_getUser()

  def send_getUser(self, authenticationToken):
    self._oprot.writeMessageBegin('getUser', TMessageType.CALL, self._seqid)
    args = getUser_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUser failed: unknown result");

  def getPublicUserInfo(self, username):
    """
    Asks the UserStore about the publicly available location information for
    a particular username.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
    </ul>
    
    Parameters:
     - username
    """
    self.send_getPublicUserInfo(username)
    return self.recv_getPublicUserInfo()

  def send_getPublicUserInfo(self, username):
    self._oprot.writeMessageBegin('getPublicUserInfo', TMessageType.CALL, self._seqid)
    args = getPublicUserInfo_args()
    args.username = username
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPublicUserInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPublicUserInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    if result.userException is not None:
      raise result.userException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicUserInfo failed: unknown result");

  def getPremiumInfo(self, authenticationToken):
    """
    Returns information regarding a user's Premium account corresponding to the
    provided authentication token, or throws an exception if this token is not
    valid.
    
    Parameters:
     - authenticationToken
    """
    self.send_getPremiumInfo(authenticationToken)
    return self.recv_getPremiumInfo()

  def send_getPremiumInfo(self, authenticationToken):
    self._oprot.writeMessageBegin('getPremiumInfo', TMessageType.CALL, self._seqid)
    args = getPremiumInfo_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPremiumInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPremiumInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPremiumInfo failed: unknown result");

  def getNoteStoreUrl(self, authenticationToken):
    """
    Returns the URL that should be used to talk to the NoteStore for the
    account represented by the provided authenticationToken.
    This method isn't needed by most clients, who can retrieve the correct
    NoteStore URL from the AuthenticationResult returned from the authenticate
    or refreshAuthentication calls. This method is typically only needed
    to look up the correct URL for a long-lived session token (e.g. for an
    OAuth web service).
    
    Parameters:
     - authenticationToken
    """
    self.send_getNoteStoreUrl(authenticationToken)
    return self.recv_getNoteStoreUrl()

  def send_getNoteStoreUrl(self, authenticationToken):
    self._oprot.writeMessageBegin('getNoteStoreUrl', TMessageType.CALL, self._seqid)
    args = getNoteStoreUrl_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteStoreUrl(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteStoreUrl_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteStoreUrl failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["checkVersion"] = Processor.process_checkVersion
    self._processMap["getBootstrapInfo"] = Processor.process_getBootstrapInfo
    self._processMap["authenticate"] = Processor.process_authenticate
    self._processMap["authenticateLongSession"] = Processor.process_authenticateLongSession
    self._processMap["completeTwoFactorAuthentication"] = Processor.process_completeTwoFactorAuthentication
    self._processMap["revokeLongSession"] = Processor.process_revokeLongSession
    self._processMap["authenticateToBusiness"] = Processor.process_authenticateToBusiness
    self._processMap["refreshAuthentication"] = Processor.process_refreshAuthentication
    self._processMap["getUser"] = Processor.process_getUser
    self._processMap["getPublicUserInfo"] = Processor.process_getPublicUserInfo
    self._processMap["getPremiumInfo"] = Processor.process_getPremiumInfo
    self._processMap["getNoteStoreUrl"] = Processor.process_getNoteStoreUrl

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_checkVersion(self, seqid, iprot, oprot):
    args = checkVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = checkVersion_result()
    result.success = self._handler.checkVersion(args.clientName, args.edamVersionMajor, args.edamVersionMinor)
    oprot.writeMessageBegin("checkVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBootstrapInfo(self, seqid, iprot, oprot):
    args = getBootstrapInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBootstrapInfo_result()
    result.success = self._handler.getBootstrapInfo(args.locale)
    oprot.writeMessageBegin("getBootstrapInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticate(self, seqid, iprot, oprot):
    args = authenticate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticate_result()
    try:
      result.success = self._handler.authenticate(args.username, args.password, args.consumerKey, args.consumerSecret, args.supportsTwoFactor)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticateLongSession(self, seqid, iprot, oprot):
    args = authenticateLongSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateLongSession_result()
    try:
      result.success = self._handler.authenticateLongSession(args.username, args.password, args.consumerKey, args.consumerSecret, args.deviceIdentifier, args.deviceDescription, args.supportsTwoFactor)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticateLongSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_completeTwoFactorAuthentication(self, seqid, iprot, oprot):
    args = completeTwoFactorAuthentication_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = completeTwoFactorAuthentication_result()
    try:
      result.success = self._handler.completeTwoFactorAuthentication(args.authenticationToken, args.oneTimeCode, args.deviceIdentifier, args.deviceDescription)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("completeTwoFactorAuthentication", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revokeLongSession(self, seqid, iprot, oprot):
    args = revokeLongSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revokeLongSession_result()
    try:
      self._handler.revokeLongSession(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("revokeLongSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticateToBusiness(self, seqid, iprot, oprot):
    args = authenticateToBusiness_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateToBusiness_result()
    try:
      result.success = self._handler.authenticateToBusiness(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticateToBusiness", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_refreshAuthentication(self, seqid, iprot, oprot):
    args = refreshAuthentication_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = refreshAuthentication_result()
    try:
      result.success = self._handler.refreshAuthentication(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("refreshAuthentication", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUser(self, seqid, iprot, oprot):
    args = getUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUser_result()
    try:
      result.success = self._handler.getUser(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPublicUserInfo(self, seqid, iprot, oprot):
    args = getPublicUserInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPublicUserInfo_result()
    try:
      result.success = self._handler.getPublicUserInfo(args.username)
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    oprot.writeMessageBegin("getPublicUserInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPremiumInfo(self, seqid, iprot, oprot):
    args = getPremiumInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPremiumInfo_result()
    try:
      result.success = self._handler.getPremiumInfo(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getPremiumInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteStoreUrl(self, seqid, iprot, oprot):
    args = getNoteStoreUrl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteStoreUrl_result()
    try:
      result.success = self._handler.getNoteStoreUrl(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getNoteStoreUrl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class checkVersion_args(object):
  """
  Attributes:
   - clientName
   - edamVersionMajor
   - edamVersionMinor
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientName', None, None, ), # 1
    (2, TType.I16, 'edamVersionMajor', None, 1, ), # 2
    (3, TType.I16, 'edamVersionMinor', None, 25, ), # 3
  )

  def __init__(self, clientName=None, edamVersionMajor=thrift_spec[2][4], edamVersionMinor=thrift_spec[3][4],):
    self.clientName = clientName
    self.edamVersionMajor = edamVersionMajor
    self.edamVersionMinor = edamVersionMinor

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.edamVersionMajor = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.edamVersionMinor = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkVersion_args')
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 1)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    if self.edamVersionMajor is not None:
      oprot.writeFieldBegin('edamVersionMajor', TType.I16, 2)
      oprot.writeI16(self.edamVersionMajor)
      oprot.writeFieldEnd()
    if self.edamVersionMinor is not None:
      oprot.writeFieldBegin('edamVersionMinor', TType.I16, 3)
      oprot.writeI16(self.edamVersionMinor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkVersion_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBootstrapInfo_args(object):
  """
  Attributes:
   - locale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'locale', None, None, ), # 1
  )

  def __init__(self, locale=None,):
    self.locale = locale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.locale = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBootstrapInfo_args')
    if self.locale is not None:
      oprot.writeFieldBegin('locale', TType.STRING, 1)
      oprot.writeString(self.locale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBootstrapInfo_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BootstrapInfo, BootstrapInfo.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BootstrapInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBootstrapInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticate_args(object):
  """
  Attributes:
   - username
   - password
   - consumerKey
   - consumerSecret
   - supportsTwoFactor
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'consumerKey', None, None, ), # 3
    (4, TType.STRING, 'consumerSecret', None, None, ), # 4
    (5, TType.BOOL, 'supportsTwoFactor', None, None, ), # 5
  )

  def __init__(self, username=None, password=None, consumerKey=None, consumerSecret=None, supportsTwoFactor=None,):
    self.username = username
    self.password = password
    self.consumerKey = consumerKey
    self.consumerSecret = consumerSecret
    self.supportsTwoFactor = supportsTwoFactor

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.consumerKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.consumerSecret = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.supportsTwoFactor = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticate_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.consumerKey is not None:
      oprot.writeFieldBegin('consumerKey', TType.STRING, 3)
      oprot.writeString(self.consumerKey)
      oprot.writeFieldEnd()
    if self.consumerSecret is not None:
      oprot.writeFieldBegin('consumerSecret', TType.STRING, 4)
      oprot.writeString(self.consumerSecret)
      oprot.writeFieldEnd()
    if self.supportsTwoFactor is not None:
      oprot.writeFieldBegin('supportsTwoFactor', TType.BOOL, 5)
      oprot.writeBool(self.supportsTwoFactor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticate_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateLongSession_args(object):
  """
  Attributes:
   - username
   - password
   - consumerKey
   - consumerSecret
   - deviceIdentifier
   - deviceDescription
   - supportsTwoFactor
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'consumerKey', None, None, ), # 3
    (4, TType.STRING, 'consumerSecret', None, None, ), # 4
    (5, TType.STRING, 'deviceIdentifier', None, None, ), # 5
    (6, TType.STRING, 'deviceDescription', None, None, ), # 6
    (7, TType.BOOL, 'supportsTwoFactor', None, None, ), # 7
  )

  def __init__(self, username=None, password=None, consumerKey=None, consumerSecret=None, deviceIdentifier=None, deviceDescription=None, supportsTwoFactor=None,):
    self.username = username
    self.password = password
    self.consumerKey = consumerKey
    self.consumerSecret = consumerSecret
    self.deviceIdentifier = deviceIdentifier
    self.deviceDescription = deviceDescription
    self.supportsTwoFactor = supportsTwoFactor

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.consumerKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.consumerSecret = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.deviceIdentifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.deviceDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.supportsTwoFactor = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateLongSession_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.consumerKey is not None:
      oprot.writeFieldBegin('consumerKey', TType.STRING, 3)
      oprot.writeString(self.consumerKey)
      oprot.writeFieldEnd()
    if self.consumerSecret is not None:
      oprot.writeFieldBegin('consumerSecret', TType.STRING, 4)
      oprot.writeString(self.consumerSecret)
      oprot.writeFieldEnd()
    if self.deviceIdentifier is not None:
      oprot.writeFieldBegin('deviceIdentifier', TType.STRING, 5)
      oprot.writeString(self.deviceIdentifier)
      oprot.writeFieldEnd()
    if self.deviceDescription is not None:
      oprot.writeFieldBegin('deviceDescription', TType.STRING, 6)
      oprot.writeString(self.deviceDescription)
      oprot.writeFieldEnd()
    if self.supportsTwoFactor is not None:
      oprot.writeFieldBegin('supportsTwoFactor', TType.BOOL, 7)
      oprot.writeBool(self.supportsTwoFactor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateLongSession_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateLongSession_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class completeTwoFactorAuthentication_args(object):
  """
  Attributes:
   - authenticationToken
   - oneTimeCode
   - deviceIdentifier
   - deviceDescription
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'oneTimeCode', None, None, ), # 2
    (3, TType.STRING, 'deviceIdentifier', None, None, ), # 3
    (4, TType.STRING, 'deviceDescription', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, oneTimeCode=None, deviceIdentifier=None, deviceDescription=None,):
    self.authenticationToken = authenticationToken
    self.oneTimeCode = oneTimeCode
    self.deviceIdentifier = deviceIdentifier
    self.deviceDescription = deviceDescription

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.oneTimeCode = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.deviceIdentifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.deviceDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('completeTwoFactorAuthentication_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.oneTimeCode is not None:
      oprot.writeFieldBegin('oneTimeCode', TType.STRING, 2)
      oprot.writeString(self.oneTimeCode)
      oprot.writeFieldEnd()
    if self.deviceIdentifier is not None:
      oprot.writeFieldBegin('deviceIdentifier', TType.STRING, 3)
      oprot.writeString(self.deviceIdentifier)
      oprot.writeFieldEnd()
    if self.deviceDescription is not None:
      oprot.writeFieldBegin('deviceDescription', TType.STRING, 4)
      oprot.writeString(self.deviceDescription)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class completeTwoFactorAuthentication_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('completeTwoFactorAuthentication_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeLongSession_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeLongSession_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeLongSession_result(object):
  """
  Attributes:
   - userException
   - systemException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, userException=None, systemException=None,):
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeLongSession_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToBusiness_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToBusiness_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToBusiness_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToBusiness_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshAuthentication_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshAuthentication_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshAuthentication_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshAuthentication_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUser_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUser_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUser_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.User, evernote.edam.type.ttypes.User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicUserInfo_args(object):
  """
  Attributes:
   - username
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
  )

  def __init__(self, username=None,):
    self.username = username

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicUserInfo_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicUserInfo_result(object):
  """
  Attributes:
   - success
   - notFoundException
   - systemException
   - userException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PublicUserInfo, PublicUserInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, notFoundException=None, systemException=None, userException=None,):
    self.success = success
    self.notFoundException = notFoundException
    self.systemException = systemException
    self.userException = userException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PublicUserInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicUserInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 1)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 3)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPremiumInfo_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPremiumInfo_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPremiumInfo_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.PremiumInfo, evernote.edam.type.ttypes.PremiumInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.PremiumInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPremiumInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteStoreUrl_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteStoreUrl_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteStoreUrl_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteStoreUrl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = TBase
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from thrift.Thrift import *
from thrift.protocol import TBinaryProtocol
from thrift.transport import TTransport

try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

class TBase(object):
  __slots__ = []

  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
              for key in self.__slots__ ]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True
    
  def __ne__(self, other):
    return not (self == other)
  
  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStruct(self, self.thrift_spec)

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStruct(self, self.thrift_spec)

class TExceptionBase(Exception):
  # old style class so python2.4 can raise exceptions derived from this
  #  This can't inherit from TBase because of that limitation.
  __slots__ = []
  
  __repr__ = TBase.__repr__.im_func
  __eq__ = TBase.__eq__.im_func
  __ne__ = TBase.__ne__.im_func
  read = TBase.read.im_func
  write = TBase.write.im_func
  

########NEW FILE########
__FILENAME__ = TBinaryProtocol
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TProtocol import *
from struct import pack, unpack

class TBinaryProtocol(TProtocolBase):

  """Binary implementation of the Thrift protocol driver."""

  # NastyHaxx. Python 2.4+ on 32-bit machines forces hex constants to be
  # positive, converting this into a long. If we hardcode the int value
  # instead it'll stay in 32 bit-land.

  # VERSION_MASK = 0xffff0000
  VERSION_MASK = -65536

  # VERSION_1 = 0x80010000
  VERSION_1 = -2147418112

  TYPE_MASK = 0x000000ff

  def __init__(self, trans, strictRead=False, strictWrite=True):
    TProtocolBase.__init__(self, trans)
    self.strictRead = strictRead
    self.strictWrite = strictWrite

  def writeMessageBegin(self, name, type, seqid):
    if self.strictWrite:
      self.writeI32(TBinaryProtocol.VERSION_1 | type)
      self.writeString(name)
      self.writeI32(seqid)
    else:
      self.writeString(name)
      self.writeByte(type)
      self.writeI32(seqid)

  def writeMessageEnd(self):
    pass

  def writeStructBegin(self, name):
    pass

  def writeStructEnd(self):
    pass

  def writeFieldBegin(self, name, type, id):
    self.writeByte(type)
    self.writeI16(id)

  def writeFieldEnd(self):
    pass

  def writeFieldStop(self):
    self.writeByte(TType.STOP);

  def writeMapBegin(self, ktype, vtype, size):
    self.writeByte(ktype)
    self.writeByte(vtype)
    self.writeI32(size)

  def writeMapEnd(self):
    pass

  def writeListBegin(self, etype, size):
    self.writeByte(etype)
    self.writeI32(size)

  def writeListEnd(self):
    pass

  def writeSetBegin(self, etype, size):
    self.writeByte(etype)
    self.writeI32(size)

  def writeSetEnd(self):
    pass

  def writeBool(self, bool):
    if bool:
      self.writeByte(1)
    else:
      self.writeByte(0)

  def writeByte(self, byte):
    buff = pack("!b", byte)
    self.trans.write(buff)

  def writeI16(self, i16):
    buff = pack("!h", i16)
    self.trans.write(buff)

  def writeI32(self, i32):
    buff = pack("!i", i32)
    self.trans.write(buff)

  def writeI64(self, i64):
    buff = pack("!q", i64)
    self.trans.write(buff)

  def writeDouble(self, dub):
    buff = pack("!d", dub)
    self.trans.write(buff)

  def writeString(self, str):
    self.writeI32(len(str))
    self.trans.write(str)

  def readMessageBegin(self):
    sz = self.readI32()
    if sz < 0:
      version = sz & TBinaryProtocol.VERSION_MASK
      if version != TBinaryProtocol.VERSION_1:
        raise TProtocolException(type=TProtocolException.BAD_VERSION, message='Bad version in readMessageBegin: %d' % (sz))
      type = sz & TBinaryProtocol.TYPE_MASK
      name = self.readString()
      seqid = self.readI32()
    else:
      if self.strictRead:
        raise TProtocolException(type=TProtocolException.BAD_VERSION, message='No protocol version header')
      name = self.trans.readAll(sz)
      type = self.readByte()
      seqid = self.readI32()
    return (name, type, seqid)

  def readMessageEnd(self):
    pass

  def readStructBegin(self):
    pass

  def readStructEnd(self):
    pass

  def readFieldBegin(self):
    type = self.readByte()
    if type == TType.STOP:
      return (None, type, 0)
    id = self.readI16()
    return (None, type, id)

  def readFieldEnd(self):
    pass

  def readMapBegin(self):
    ktype = self.readByte()
    vtype = self.readByte()
    size = self.readI32()
    return (ktype, vtype, size)

  def readMapEnd(self):
    pass

  def readListBegin(self):
    etype = self.readByte()
    size = self.readI32()
    return (etype, size)

  def readListEnd(self):
    pass

  def readSetBegin(self):
    etype = self.readByte()
    size = self.readI32()
    return (etype, size)

  def readSetEnd(self):
    pass

  def readBool(self):
    byte = self.readByte()
    if byte == 0:
      return False
    return True

  def readByte(self):
    buff = self.trans.readAll(1)
    val, = unpack('!b', buff)
    return val

  def readI16(self):
    buff = self.trans.readAll(2)
    val, = unpack('!h', buff)
    return val

  def readI32(self):
    buff = self.trans.readAll(4)
    val, = unpack('!i', buff)
    return val

  def readI64(self):
    buff = self.trans.readAll(8)
    val, = unpack('!q', buff)
    return val

  def readDouble(self):
    buff = self.trans.readAll(8)
    val, = unpack('!d', buff)
    return val

  def readString(self):
    len = self.readI32()
    str = self.trans.readAll(len)
    return str


class TBinaryProtocolFactory:
  def __init__(self, strictRead=False, strictWrite=True):
    self.strictRead = strictRead
    self.strictWrite = strictWrite

  def getProtocol(self, trans):
    prot = TBinaryProtocol(trans, self.strictRead, self.strictWrite)
    return prot


class TBinaryProtocolAccelerated(TBinaryProtocol):

  """C-Accelerated version of TBinaryProtocol.

  This class does not override any of TBinaryProtocol's methods,
  but the generated code recognizes it directly and will call into
  our C module to do the encoding, bypassing this object entirely.
  We inherit from TBinaryProtocol so that the normal TBinaryProtocol
  encoding can happen if the fastbinary module doesn't work for some
  reason.  (TODO(dreiss): Make this happen sanely in more cases.)

  In order to take advantage of the C module, just use
  TBinaryProtocolAccelerated instead of TBinaryProtocol.

  NOTE:  This code was contributed by an external developer.
         The internal Thrift team has reviewed and tested it,
         but we cannot guarantee that it is production-ready.
         Please feel free to report bugs and/or success stories
         to the public mailing list.
  """

  pass


class TBinaryProtocolAcceleratedFactory:
  def getProtocol(self, trans):
    return TBinaryProtocolAccelerated(trans)

########NEW FILE########
__FILENAME__ = TCompactProtocol
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TProtocol import *
from struct import pack, unpack

__all__ = ['TCompactProtocol', 'TCompactProtocolFactory']

CLEAR = 0
FIELD_WRITE = 1
VALUE_WRITE = 2
CONTAINER_WRITE = 3
BOOL_WRITE = 4
FIELD_READ = 5
CONTAINER_READ = 6
VALUE_READ = 7
BOOL_READ = 8

def make_helper(v_from, container):
  def helper(func):
    def nested(self, *args, **kwargs):
      assert self.state in (v_from, container), (self.state, v_from, container)
      return func(self, *args, **kwargs)
    return nested
  return helper
writer = make_helper(VALUE_WRITE, CONTAINER_WRITE)
reader = make_helper(VALUE_READ, CONTAINER_READ)

def makeZigZag(n, bits):
  return (n << 1) ^ (n >> (bits - 1))

def fromZigZag(n):
  return (n >> 1) ^ -(n & 1)

def writeVarint(trans, n):
  out = []
  while True:
    if n & ~0x7f == 0:
      out.append(n)
      break
    else:
      out.append((n & 0xff) | 0x80)
      n = n >> 7
  trans.write(''.join(map(chr, out)))

def readVarint(trans):
  result = 0
  shift = 0
  while True:
    x = trans.readAll(1)
    byte = ord(x)
    result |= (byte & 0x7f) << shift
    if byte >> 7 == 0:
      return result
    shift += 7

class CompactType:
  STOP = 0x00
  TRUE = 0x01
  FALSE = 0x02
  BYTE = 0x03
  I16 = 0x04
  I32 = 0x05
  I64 = 0x06
  DOUBLE = 0x07
  BINARY = 0x08
  LIST = 0x09
  SET = 0x0A
  MAP = 0x0B
  STRUCT = 0x0C

CTYPES = {TType.STOP: CompactType.STOP,
          TType.BOOL: CompactType.TRUE, # used for collection
          TType.BYTE: CompactType.BYTE,
          TType.I16: CompactType.I16,
          TType.I32: CompactType.I32,
          TType.I64: CompactType.I64,
          TType.DOUBLE: CompactType.DOUBLE,
          TType.STRING: CompactType.BINARY,
          TType.STRUCT: CompactType.STRUCT,
          TType.LIST: CompactType.LIST,
          TType.SET: CompactType.SET,
          TType.MAP: CompactType.MAP
          }

TTYPES = {}
for k, v in CTYPES.items():
  TTYPES[v] = k
TTYPES[CompactType.FALSE] = TType.BOOL
del k
del v

class TCompactProtocol(TProtocolBase):
  "Compact implementation of the Thrift protocol driver."

  PROTOCOL_ID = 0x82
  VERSION = 1
  VERSION_MASK = 0x1f
  TYPE_MASK = 0xe0
  TYPE_SHIFT_AMOUNT = 5

  def __init__(self, trans):
    TProtocolBase.__init__(self, trans)
    self.state = CLEAR
    self.__last_fid = 0
    self.__bool_fid = None
    self.__bool_value = None
    self.__structs = []
    self.__containers = []

  def __writeVarint(self, n):
    writeVarint(self.trans, n)

  def writeMessageBegin(self, name, type, seqid):
    assert self.state == CLEAR
    self.__writeUByte(self.PROTOCOL_ID)
    self.__writeUByte(self.VERSION | (type << self.TYPE_SHIFT_AMOUNT))
    self.__writeVarint(seqid)
    self.__writeString(name)
    self.state = VALUE_WRITE

  def writeMessageEnd(self):
    assert self.state == VALUE_WRITE
    self.state = CLEAR

  def writeStructBegin(self, name):
    assert self.state in (CLEAR, CONTAINER_WRITE, VALUE_WRITE), self.state
    self.__structs.append((self.state, self.__last_fid))
    self.state = FIELD_WRITE
    self.__last_fid = 0

  def writeStructEnd(self):
    assert self.state == FIELD_WRITE
    self.state, self.__last_fid = self.__structs.pop()

  def writeFieldStop(self):
    self.__writeByte(0)

  def __writeFieldHeader(self, type, fid):
    delta = fid - self.__last_fid
    if 0 < delta <= 15:
      self.__writeUByte(delta << 4 | type)
    else:
      self.__writeByte(type)
      self.__writeI16(fid)
    self.__last_fid = fid

  def writeFieldBegin(self, name, type, fid):
    assert self.state == FIELD_WRITE, self.state
    if type == TType.BOOL:
      self.state = BOOL_WRITE
      self.__bool_fid = fid
    else:
      self.state = VALUE_WRITE
      self.__writeFieldHeader(CTYPES[type], fid)

  def writeFieldEnd(self):
    assert self.state in (VALUE_WRITE, BOOL_WRITE), self.state
    self.state = FIELD_WRITE

  def __writeUByte(self, byte):
    self.trans.write(pack('!B', byte))

  def __writeByte(self, byte):
    self.trans.write(pack('!b', byte))

  def __writeI16(self, i16):
    self.__writeVarint(makeZigZag(i16, 16))

  def __writeSize(self, i32):
    self.__writeVarint(i32)

  def writeCollectionBegin(self, etype, size):
    assert self.state in (VALUE_WRITE, CONTAINER_WRITE), self.state
    if size <= 14:
      self.__writeUByte(size << 4 | CTYPES[etype])
    else:
      self.__writeUByte(0xf0 | CTYPES[etype])
      self.__writeSize(size)
    self.__containers.append(self.state)
    self.state = CONTAINER_WRITE
  writeSetBegin = writeCollectionBegin
  writeListBegin = writeCollectionBegin

  def writeMapBegin(self, ktype, vtype, size):
    assert self.state in (VALUE_WRITE, CONTAINER_WRITE), self.state
    if size == 0:
      self.__writeByte(0)
    else:
      self.__writeSize(size)
      self.__writeUByte(CTYPES[ktype] << 4 | CTYPES[vtype])
    self.__containers.append(self.state)
    self.state = CONTAINER_WRITE

  def writeCollectionEnd(self):
    assert self.state == CONTAINER_WRITE, self.state
    self.state = self.__containers.pop()
  writeMapEnd = writeCollectionEnd
  writeSetEnd = writeCollectionEnd
  writeListEnd = writeCollectionEnd

  def writeBool(self, bool):
    if self.state == BOOL_WRITE:
        if bool:
            ctype = CompactType.TRUE
        else:
            ctype = CompactType.FALSE
        self.__writeFieldHeader(ctype, self.__bool_fid)
    elif self.state == CONTAINER_WRITE:
       if bool:
           self.__writeByte(CompactType.TRUE)
       else:
           self.__writeByte(CompactType.FALSE)
    else:
      raise AssertionError, "Invalid state in compact protocol"

  writeByte = writer(__writeByte)
  writeI16 = writer(__writeI16)

  @writer
  def writeI32(self, i32):
    self.__writeVarint(makeZigZag(i32, 32))

  @writer
  def writeI64(self, i64):
    self.__writeVarint(makeZigZag(i64, 64))

  @writer
  def writeDouble(self, dub):
    self.trans.write(pack('!d', dub))

  def __writeString(self, s):
    self.__writeSize(len(s))
    self.trans.write(s)
  writeString = writer(__writeString)

  def readFieldBegin(self):
    assert self.state == FIELD_READ, self.state
    type = self.__readUByte()
    if type & 0x0f == TType.STOP:
      return (None, 0, 0)
    delta = type >> 4
    if delta == 0:
      fid = self.__readI16()
    else:
      fid = self.__last_fid + delta
    self.__last_fid = fid
    type = type & 0x0f
    if type == CompactType.TRUE:
      self.state = BOOL_READ
      self.__bool_value = True
    elif type == CompactType.FALSE:
      self.state = BOOL_READ
      self.__bool_value = False
    else:
      self.state = VALUE_READ
    return (None, self.__getTType(type), fid)

  def readFieldEnd(self):
    assert self.state in (VALUE_READ, BOOL_READ), self.state
    self.state = FIELD_READ

  def __readUByte(self):
    result, = unpack('!B', self.trans.readAll(1))
    return result

  def __readByte(self):
    result, = unpack('!b', self.trans.readAll(1))
    return result

  def __readVarint(self):
    return readVarint(self.trans)

  def __readZigZag(self):
    return fromZigZag(self.__readVarint())

  def __readSize(self):
    result = self.__readVarint()
    if result < 0:
      raise TException("Length < 0")
    return result

  def readMessageBegin(self):
    assert self.state == CLEAR
    proto_id = self.__readUByte()
    if proto_id != self.PROTOCOL_ID:
      raise TProtocolException(TProtocolException.BAD_VERSION,
          'Bad protocol id in the message: %d' % proto_id)
    ver_type = self.__readUByte()
    type = (ver_type & self.TYPE_MASK) >> self.TYPE_SHIFT_AMOUNT
    version = ver_type & self.VERSION_MASK
    if version != self.VERSION:
      raise TProtocolException(TProtocolException.BAD_VERSION,
          'Bad version: %d (expect %d)' % (version, self.VERSION))
    seqid = self.__readVarint()
    name = self.__readString()
    return (name, type, seqid)

  def readMessageEnd(self):
    assert self.state == CLEAR
    assert len(self.__structs) == 0

  def readStructBegin(self):
    assert self.state in (CLEAR, CONTAINER_READ, VALUE_READ), self.state
    self.__structs.append((self.state, self.__last_fid))
    self.state = FIELD_READ
    self.__last_fid = 0

  def readStructEnd(self):
    assert self.state == FIELD_READ
    self.state, self.__last_fid = self.__structs.pop()

  def readCollectionBegin(self):
    assert self.state in (VALUE_READ, CONTAINER_READ), self.state
    size_type = self.__readUByte()
    size = size_type >> 4
    type = self.__getTType(size_type)
    if size == 15:
      size = self.__readSize()
    self.__containers.append(self.state)
    self.state = CONTAINER_READ
    return type, size
  readSetBegin = readCollectionBegin
  readListBegin = readCollectionBegin

  def readMapBegin(self):
    assert self.state in (VALUE_READ, CONTAINER_READ), self.state
    size = self.__readSize()
    types = 0
    if size > 0:
      types = self.__readUByte()
    vtype = self.__getTType(types)
    ktype = self.__getTType(types >> 4)
    self.__containers.append(self.state)
    self.state = CONTAINER_READ
    return (ktype, vtype, size)

  def readCollectionEnd(self):
    assert self.state == CONTAINER_READ, self.state
    self.state = self.__containers.pop()
  readSetEnd = readCollectionEnd
  readListEnd = readCollectionEnd
  readMapEnd = readCollectionEnd

  def readBool(self):
    if self.state == BOOL_READ:
      return self.__bool_value == CompactType.TRUE
    elif self.state == CONTAINER_READ:
      return self.__readByte() == CompactType.TRUE
    else:
      raise AssertionError, "Invalid state in compact protocol: %d" % self.state

  readByte = reader(__readByte)
  __readI16 = __readZigZag
  readI16 = reader(__readZigZag)
  readI32 = reader(__readZigZag)
  readI64 = reader(__readZigZag)

  @reader
  def readDouble(self):
    buff = self.trans.readAll(8)
    val, = unpack('!d', buff)
    return val

  def __readString(self):
    len = self.__readSize()
    return self.trans.readAll(len)
  readString = reader(__readString)

  def __getTType(self, byte):
    return TTYPES[byte & 0x0f]


class TCompactProtocolFactory:
  def __init__(self):
    pass

  def getProtocol(self, trans):
    return TCompactProtocol(trans)

########NEW FILE########
__FILENAME__ = TProtocol
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from thrift.Thrift import *

class TProtocolException(TException):

  """Custom Protocol Exception class"""

  UNKNOWN = 0
  INVALID_DATA = 1
  NEGATIVE_SIZE = 2
  SIZE_LIMIT = 3
  BAD_VERSION = 4

  def __init__(self, type=UNKNOWN, message=None):
    TException.__init__(self, message)
    self.type = type

class TProtocolBase:

  """Base class for Thrift protocol driver."""

  def __init__(self, trans):
    self.trans = trans

  def writeMessageBegin(self, name, type, seqid):
    pass

  def writeMessageEnd(self):
    pass

  def writeStructBegin(self, name):
    pass

  def writeStructEnd(self):
    pass

  def writeFieldBegin(self, name, type, id):
    pass

  def writeFieldEnd(self):
    pass

  def writeFieldStop(self):
    pass

  def writeMapBegin(self, ktype, vtype, size):
    pass

  def writeMapEnd(self):
    pass

  def writeListBegin(self, etype, size):
    pass

  def writeListEnd(self):
    pass

  def writeSetBegin(self, etype, size):
    pass

  def writeSetEnd(self):
    pass

  def writeBool(self, bool):
    pass

  def writeByte(self, byte):
    pass

  def writeI16(self, i16):
    pass

  def writeI32(self, i32):
    pass

  def writeI64(self, i64):
    pass

  def writeDouble(self, dub):
    pass

  def writeString(self, str):
    pass

  def readMessageBegin(self):
    pass

  def readMessageEnd(self):
    pass

  def readStructBegin(self):
    pass

  def readStructEnd(self):
    pass

  def readFieldBegin(self):
    pass

  def readFieldEnd(self):
    pass

  def readMapBegin(self):
    pass

  def readMapEnd(self):
    pass

  def readListBegin(self):
    pass

  def readListEnd(self):
    pass

  def readSetBegin(self):
    pass

  def readSetEnd(self):
    pass

  def readBool(self):
    pass

  def readByte(self):
    pass

  def readI16(self):
    pass

  def readI32(self):
    pass

  def readI64(self):
    pass

  def readDouble(self):
    pass

  def readString(self):
    pass

  def skip(self, type):
    if type == TType.STOP:
      return
    elif type == TType.BOOL:
      self.readBool()
    elif type == TType.BYTE:
      self.readByte()
    elif type == TType.I16:
      self.readI16()
    elif type == TType.I32:
      self.readI32()
    elif type == TType.I64:
      self.readI64()
    elif type == TType.DOUBLE:
      self.readDouble()
    elif type == TType.STRING:
      self.readString()
    elif type == TType.STRUCT:
      name = self.readStructBegin()
      while True:
        (name, type, id) = self.readFieldBegin()
        if type == TType.STOP:
          break
        self.skip(type)
        self.readFieldEnd()
      self.readStructEnd()
    elif type == TType.MAP:
      (ktype, vtype, size) = self.readMapBegin()
      for i in range(size):
        self.skip(ktype)
        self.skip(vtype)
      self.readMapEnd()
    elif type == TType.SET:
      (etype, size) = self.readSetBegin()
      for i in range(size):
        self.skip(etype)
      self.readSetEnd()
    elif type == TType.LIST:
      (etype, size) = self.readListBegin()
      for i in range(size):
        self.skip(etype)
      self.readListEnd()

  # tuple of: ( 'reader method' name, is_container boolean, 'writer_method' name )
  _TTYPE_HANDLERS = (
       (None, None, False), # 0 == TType,STOP
       (None, None, False), # 1 == TType.VOID # TODO: handle void?
       ('readBool', 'writeBool', False), # 2 == TType.BOOL
       ('readByte',  'writeByte', False), # 3 == TType.BYTE and I08
       ('readDouble', 'writeDouble', False), # 4 == TType.DOUBLE
       (None, None, False), # 5, undefined
       ('readI16', 'writeI16', False), # 6 == TType.I16
       (None, None, False), # 7, undefined
       ('readI32', 'writeI32', False), # 8 == TType.I32
       (None, None, False), # 9, undefined
       ('readI64', 'writeI64', False), # 10 == TType.I64
       ('readString', 'writeString', False), # 11 == TType.STRING and UTF7
       ('readContainerStruct', 'writeContainerStruct', True), # 12 == TType.STRUCT
       ('readContainerMap', 'writeContainerMap', True), # 13 == TType.MAP
       ('readContainerSet', 'writeContainerSet', True), # 14 == TType.SET
       ('readContainerList', 'writeContainerList', True), # 15 == TType.LIST
       (None, None, False), # 16 == TType.UTF8 # TODO: handle utf8 types?
       (None, None, False)# 17 == TType.UTF16 # TODO: handle utf16 types?
      )

  def readFieldByTType(self, ttype, spec):
    try:
      (r_handler, w_handler, is_container) = self._TTYPE_HANDLERS[ttype]
    except IndexError:
      raise TProtocolException(type=TProtocolException.INVALID_DATA,
                               message='Invalid field type %d' % (ttype))
    if r_handler is None:
      raise TProtocolException(type=TProtocolException.INVALID_DATA,
                               message='Invalid field type %d' % (ttype))
    reader = getattr(self, r_handler)
    if not is_container:
      return reader()
    return reader(spec)

  def readContainerList(self, spec):
    results = []
    ttype, tspec = spec[0], spec[1]
    r_handler = self._TTYPE_HANDLERS[ttype][0]
    reader = getattr(self, r_handler)
    (list_type, list_len) = self.readListBegin()
    if tspec is None:
      # list values are simple types
      for idx in xrange(list_len):
        results.append(reader())
    else:
      # this is like an inlined readFieldByTType
      container_reader = self._TTYPE_HANDLERS[list_type][0]
      val_reader = getattr(self, container_reader)
      for idx in xrange(list_len):
        val = val_reader(tspec)
        results.append(val)
    self.readListEnd()
    return results

  def readContainerSet(self, spec):
    results = set()
    ttype, tspec = spec[0], spec[1]
    r_handler = self._TTYPE_HANDLERS[ttype][0]
    reader = getattr(self, r_handler)
    (set_type, set_len) = self.readSetBegin()
    if tspec is None:
      # set members are simple types
      for idx in xrange(set_len):
        results.add(reader())
    else:
      container_reader = self._TTYPE_HANDLERS[set_type][0]
      val_reader = getattr(self, container_reader)
      for idx in xrange(set_len):
        results.add(val_reader(tspec)) 
    self.readSetEnd()
    return results

  def readContainerStruct(self, spec):
    (obj_class, obj_spec) = spec
    obj = obj_class()
    obj.read(self)
    return obj
  
  def readContainerMap(self, spec):
    results = dict()
    key_ttype, key_spec = spec[0], spec[1]
    val_ttype, val_spec = spec[2], spec[3]
    (map_ktype, map_vtype, map_len) = self.readMapBegin()
    # TODO: compare types we just decoded with thrift_spec and abort/skip if types disagree
    key_reader = getattr(self, self._TTYPE_HANDLERS[key_ttype][0])
    val_reader = getattr(self, self._TTYPE_HANDLERS[val_ttype][0])
    # list values are simple types
    for idx in xrange(map_len):
      if key_spec is None:
        k_val = key_reader()
      else:
        k_val = self.readFieldByTType(key_ttype, key_spec)
      if val_spec is None:
        v_val = val_reader()
      else:
        v_val = self.readFieldByTType(val_ttype, val_spec)
      # this raises a TypeError with unhashable keys types. i.e. d=dict(); d[[0,1]] = 2 fails
      results[k_val] = v_val
    self.readMapEnd()
    return results

  def readStruct(self, obj, thrift_spec):
    self.readStructBegin()
    while True:
      (fname, ftype, fid) = self.readFieldBegin()
      if ftype == TType.STOP:
        break
      try:
        field = thrift_spec[fid]
      except IndexError:
        self.skip(ftype)
      else:
        if field is not None and ftype == field[1]:
          fname = field[2]
          fspec = field[3]
          val = self.readFieldByTType(ftype, fspec)
          setattr(obj, fname, val)
        else:
          self.skip(ftype)
      self.readFieldEnd()
    self.readStructEnd()

  def writeContainerStruct(self, val, spec):
    val.write(self)

  def writeContainerList(self, val, spec):
    self.writeListBegin(spec[0], len(val))
    r_handler, w_handler, is_container  = self._TTYPE_HANDLERS[spec[0]]
    e_writer = getattr(self, w_handler)
    if not is_container:
      for elem in val:
        e_writer(elem)
    else:
      for elem in val:
        e_writer(elem, spec[1])
    self.writeListEnd()

  def writeContainerSet(self, val, spec):
    self.writeSetBegin(spec[0], len(val))
    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[spec[0]]
    e_writer = getattr(self, w_handler)
    if not is_container:
      for elem in val:
        e_writer(elem)
    else:
      for elem in val:
        e_writer(elem, spec[1])
    self.writeSetEnd()

  def writeContainerMap(self, val, spec):
    k_type = spec[0]
    v_type = spec[2]
    ignore, ktype_name, k_is_container = self._TTYPE_HANDLERS[k_type]
    ignore, vtype_name, v_is_container = self._TTYPE_HANDLERS[v_type]
    k_writer = getattr(self, ktype_name)
    v_writer = getattr(self, vtype_name)
    self.writeMapBegin(k_type, v_type, len(val))
    for m_key, m_val in val.iteritems():
      if not k_is_container:
        k_writer(m_key)
      else:
        k_writer(m_key, spec[1])
      if not v_is_container:
        v_writer(m_val)
      else:
        v_writer(m_val, spec[3])
    self.writeMapEnd()

  def writeStruct(self, obj, thrift_spec):
    self.writeStructBegin(obj.__class__.__name__)
    for field in thrift_spec:
      if field is None:
        continue
      fname = field[2]
      val = getattr(obj, fname)
      if val is None:
        # skip writing out unset fields
        continue
      fid = field[0]
      ftype = field[1]
      fspec = field[3]
      # get the writer method for this value
      self.writeFieldBegin(fname, ftype, fid)
      self.writeFieldByTType(ftype, val, fspec)
      self.writeFieldEnd()
    self.writeFieldStop()
    self.writeStructEnd()

  def writeFieldByTType(self, ttype, val, spec):
    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[ttype]
    writer = getattr(self, w_handler)
    if is_container:
      writer(val, spec)
    else:
      writer(val)

class TProtocolFactory:
  def getProtocol(self, trans):
    pass


########NEW FILE########
__FILENAME__ = THttpServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import BaseHTTPServer

from thrift.server import TServer
from thrift.transport import TTransport

class ResponseException(Exception):
  """Allows handlers to override the HTTP response

  Normally, THttpServer always sends a 200 response.  If a handler wants
  to override this behavior (e.g., to simulate a misconfigured or
  overloaded web server during testing), it can raise a ResponseException.
  The function passed to the constructor will be called with the
  RequestHandler as its only argument.
  """
  def __init__(self, handler):
    self.handler = handler


class THttpServer(TServer.TServer):
  """A simple HTTP-based Thrift server

  This class is not very performant, but it is useful (for example) for
  acting as a mock version of an Apache-based PHP Thrift endpoint."""

  def __init__(self, processor, server_address,
      inputProtocolFactory, outputProtocolFactory = None,
      server_class = BaseHTTPServer.HTTPServer):
    """Set up protocol factories and HTTP server.

    See BaseHTTPServer for server_address.
    See TServer for protocol factories."""

    if outputProtocolFactory is None:
      outputProtocolFactory = inputProtocolFactory

    TServer.TServer.__init__(self, processor, None, None, None,
        inputProtocolFactory, outputProtocolFactory)

    thttpserver = self

    class RequestHander(BaseHTTPServer.BaseHTTPRequestHandler):
      def do_POST(self):
        # Don't care about the request path.
        itrans = TTransport.TFileObjectTransport(self.rfile)
        otrans = TTransport.TFileObjectTransport(self.wfile)
        itrans = TTransport.TBufferedTransport(itrans, int(self.headers['Content-Length']))
        otrans = TTransport.TMemoryBuffer()
        iprot = thttpserver.inputProtocolFactory.getProtocol(itrans)
        oprot = thttpserver.outputProtocolFactory.getProtocol(otrans)
        try:
          thttpserver.processor.process(iprot, oprot)
        except ResponseException, exn:
          exn.handler(self)
        else:
          self.send_response(200)
          self.send_header("content-type", "application/x-thrift")
          self.end_headers()
          self.wfile.write(otrans.getvalue())

    self.httpd = server_class(server_address, RequestHander)

  def serve(self):
    self.httpd.serve_forever()

########NEW FILE########
__FILENAME__ = TNonblockingServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
"""Implementation of non-blocking server.

The main idea of the server is reciving and sending requests
only from main thread.

It also makes thread pool server in tasks terms, not connections.
"""
import threading
import socket
import Queue
import select
import struct
import logging

from thrift.transport import TTransport
from thrift.protocol.TBinaryProtocol import TBinaryProtocolFactory

__all__ = ['TNonblockingServer']

class Worker(threading.Thread):
    """Worker is a small helper to process incoming connection."""
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue

    def run(self):
        """Process queries from task queue, stop if processor is None."""
        while True:
            try:
                processor, iprot, oprot, otrans, callback = self.queue.get()
                if processor is None:
                    break
                processor.process(iprot, oprot)
                callback(True, otrans.getvalue())
            except Exception:
                logging.exception("Exception while processing request")
                callback(False, '')

WAIT_LEN = 0
WAIT_MESSAGE = 1
WAIT_PROCESS = 2
SEND_ANSWER = 3
CLOSED = 4

def locked(func):
    "Decorator which locks self.lock."
    def nested(self, *args, **kwargs):
        self.lock.acquire()
        try:
            return func(self, *args, **kwargs)
        finally:
            self.lock.release()
    return nested

def socket_exception(func):
    "Decorator close object on socket.error."
    def read(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except socket.error:
            self.close()
    return read

class Connection:
    """Basic class is represented connection.
    
    It can be in state:
        WAIT_LEN --- connection is reading request len.
        WAIT_MESSAGE --- connection is reading request.
        WAIT_PROCESS --- connection has just read whole request and 
            waits for call ready routine.
        SEND_ANSWER --- connection is sending answer string (including length
            of answer).
        CLOSED --- socket was closed and connection should be deleted.
    """
    def __init__(self, new_socket, wake_up):
        self.socket = new_socket
        self.socket.setblocking(False)
        self.status = WAIT_LEN
        self.len = 0
        self.message = ''
        self.lock = threading.Lock()
        self.wake_up = wake_up

    def _read_len(self):
        """Reads length of request.
        
        It's really paranoic routine and it may be replaced by 
        self.socket.recv(4)."""
        read = self.socket.recv(4 - len(self.message))
        if len(read) == 0:
            # if we read 0 bytes and self.message is empty, it means client close 
            # connection
            if len(self.message) != 0:
                logging.error("can't read frame size from socket")
            self.close()
            return
        self.message += read
        if len(self.message) == 4:
            self.len, = struct.unpack('!i', self.message)
            if self.len < 0:
                logging.error("negative frame size, it seems client"\
                    " doesn't use FramedTransport")
                self.close()
            elif self.len == 0:
                logging.error("empty frame, it's really strange")
                self.close()
            else:
                self.message = ''
                self.status = WAIT_MESSAGE

    @socket_exception
    def read(self):
        """Reads data from stream and switch state."""
        assert self.status in (WAIT_LEN, WAIT_MESSAGE)
        if self.status == WAIT_LEN:
            self._read_len()
            # go back to the main loop here for simplicity instead of
            # falling through, even though there is a good chance that
            # the message is already available
        elif self.status == WAIT_MESSAGE:
            read = self.socket.recv(self.len - len(self.message))
            if len(read) == 0:
                logging.error("can't read frame from socket (get %d of %d bytes)" %
                    (len(self.message), self.len))
                self.close()
                return
            self.message += read
            if len(self.message) == self.len:
                self.status = WAIT_PROCESS

    @socket_exception
    def write(self):
        """Writes data from socket and switch state."""
        assert self.status == SEND_ANSWER
        sent = self.socket.send(self.message)
        if sent == len(self.message):
            self.status = WAIT_LEN
            self.message = ''
            self.len = 0
        else:
            self.message = self.message[sent:]

    @locked
    def ready(self, all_ok, message):
        """Callback function for switching state and waking up main thread.
        
        This function is the only function witch can be called asynchronous.
        
        The ready can switch Connection to three states:
            WAIT_LEN if request was oneway.
            SEND_ANSWER if request was processed in normal way.
            CLOSED if request throws unexpected exception.
        
        The one wakes up main thread.
        """
        assert self.status == WAIT_PROCESS
        if not all_ok:
            self.close()
            self.wake_up()
            return
        self.len = ''
        if len(message) == 0:
            # it was a oneway request, do not write answer
            self.message = ''
            self.status = WAIT_LEN
        else:
            self.message = struct.pack('!i', len(message)) + message
            self.status = SEND_ANSWER
        self.wake_up()

    @locked
    def is_writeable(self):
        "Returns True if connection should be added to write list of select."
        return self.status == SEND_ANSWER

    # it's not necessary, but...
    @locked
    def is_readable(self):
        "Returns True if connection should be added to read list of select."
        return self.status in (WAIT_LEN, WAIT_MESSAGE)

    @locked
    def is_closed(self):
        "Returns True if connection is closed."
        return self.status == CLOSED

    def fileno(self):
        "Returns the file descriptor of the associated socket."
        return self.socket.fileno()

    def close(self):
        "Closes connection"
        self.status = CLOSED
        self.socket.close()

class TNonblockingServer:
    """Non-blocking server."""
    def __init__(self, processor, lsocket, inputProtocolFactory=None, 
            outputProtocolFactory=None, threads=10):
        self.processor = processor
        self.socket = lsocket
        self.in_protocol = inputProtocolFactory or TBinaryProtocolFactory()
        self.out_protocol = outputProtocolFactory or self.in_protocol
        self.threads = int(threads)
        self.clients = {}
        self.tasks = Queue.Queue()
        self._read, self._write = socket.socketpair()
        self.prepared = False

    def setNumThreads(self, num):
        """Set the number of worker threads that should be created."""
        # implement ThreadPool interface
        assert not self.prepared, "You can't change number of threads for working server"
        self.threads = num

    def prepare(self):
        """Prepares server for serve requests."""
        self.socket.listen()
        for _ in xrange(self.threads):
            thread = Worker(self.tasks)
            thread.setDaemon(True)
            thread.start()
        self.prepared = True

    def wake_up(self):
        """Wake up main thread.
        
        The server usualy waits in select call in we should terminate one.
        The simplest way is using socketpair.
        
        Select always wait to read from the first socket of socketpair.
        
        In this case, we can just write anything to the second socket from
        socketpair."""
        self._write.send('1')

    def _select(self):
        """Does select on open connections."""
        readable = [self.socket.handle.fileno(), self._read.fileno()]
        writable = []
        for i, connection in self.clients.items():
            if connection.is_readable():
                readable.append(connection.fileno())
            if connection.is_writeable():
                writable.append(connection.fileno())
            if connection.is_closed():
                del self.clients[i]
        return select.select(readable, writable, readable)
        
    def handle(self):
        """Handle requests.
       
        WARNING! You must call prepare BEFORE calling handle.
        """
        assert self.prepared, "You have to call prepare before handle"
        rset, wset, xset = self._select()
        for readable in rset:
            if readable == self._read.fileno():
                # don't care i just need to clean readable flag
                self._read.recv(1024) 
            elif readable == self.socket.handle.fileno():
                client = self.socket.accept().handle
                self.clients[client.fileno()] = Connection(client, self.wake_up)
            else:
                connection = self.clients[readable]
                connection.read()
                if connection.status == WAIT_PROCESS:
                    itransport = TTransport.TMemoryBuffer(connection.message)
                    otransport = TTransport.TMemoryBuffer()
                    iprot = self.in_protocol.getProtocol(itransport)
                    oprot = self.out_protocol.getProtocol(otransport)
                    self.tasks.put([self.processor, iprot, oprot, 
                                    otransport, connection.ready])
        for writeable in wset:
            self.clients[writeable].write()
        for oob in xset:
            self.clients[oob].close()
            del self.clients[oob]

    def close(self):
        """Closes the server."""
        for _ in xrange(self.threads):
            self.tasks.put([None, None, None, None, None])
        self.socket.close()
        self.prepared = False
        
    def serve(self):
        """Serve forever."""
        self.prepare()
        while True:
            self.handle()

########NEW FILE########
__FILENAME__ = TProcessPoolServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#


import logging
from multiprocessing import  Process, Value, Condition, reduction

from TServer import TServer
from thrift.transport.TTransport import TTransportException

class TProcessPoolServer(TServer):

    """
    Server with a fixed size pool of worker subprocesses which service requests.
    Note that if you need shared state between the handlers - it's up to you!
    Written by Dvir Volk, doat.com
    """

    def __init__(self, * args):
        TServer.__init__(self, *args)
        self.numWorkers = 10
        self.workers = []
        self.isRunning = Value('b', False)
        self.stopCondition = Condition()
        self.postForkCallback = None

    def setPostForkCallback(self, callback):
        if not callable(callback):
            raise TypeError("This is not a callback!")
        self.postForkCallback = callback

    def setNumWorkers(self, num):
        """Set the number of worker threads that should be created"""
        self.numWorkers = num

    def workerProcess(self):
        """Loop around getting clients from the shared queue and process them."""

        if self.postForkCallback:
            self.postForkCallback()

        while self.isRunning.value == True:
            try:
                client = self.serverTransport.accept()
                self.serveClient(client)
            except (KeyboardInterrupt, SystemExit):
                return 0
            except Exception, x:
                logging.exception(x)

    def serveClient(self, client):
        """Process input/output from a client for as long as possible"""
        itrans = self.inputTransportFactory.getTransport(client)
        otrans = self.outputTransportFactory.getTransport(client)
        iprot = self.inputProtocolFactory.getProtocol(itrans)
        oprot = self.outputProtocolFactory.getProtocol(otrans)

        try:
            while True:
                self.processor.process(iprot, oprot)
        except TTransportException, tx:
            pass
        except Exception, x:
            logging.exception(x)

        itrans.close()
        otrans.close()


    def serve(self):
        """Start a fixed number of worker threads and put client into a queue"""

        #this is a shared state that can tell the workers to exit when set as false
        self.isRunning.value = True

        #first bind and listen to the port
        self.serverTransport.listen()

        #fork the children
        for i in range(self.numWorkers):
            try:
                w = Process(target=self.workerProcess)
                w.daemon = True
                w.start()
                self.workers.append(w)
            except Exception, x:
                logging.exception(x)

        #wait until the condition is set by stop()

        while True:

            self.stopCondition.acquire()
            try:
                self.stopCondition.wait()
                break
            except (SystemExit, KeyboardInterrupt):
		break
            except Exception, x:
                logging.exception(x)

        self.isRunning.value = False

    def stop(self):
        self.isRunning.value = False
        self.stopCondition.acquire()
        self.stopCondition.notify()
        self.stopCondition.release()


########NEW FILE########
__FILENAME__ = TServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import logging
import sys
import os
import traceback
import threading
import Queue

from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol

class TServer:

  """Base interface for a server, which must have a serve method."""

  """ 3 constructors for all servers:
  1) (processor, serverTransport)
  2) (processor, serverTransport, transportFactory, protocolFactory)
  3) (processor, serverTransport,
      inputTransportFactory, outputTransportFactory,
      inputProtocolFactory, outputProtocolFactory)"""
  def __init__(self, *args):
    if (len(args) == 2):
      self.__initArgs__(args[0], args[1],
                        TTransport.TTransportFactoryBase(),
                        TTransport.TTransportFactoryBase(),
                        TBinaryProtocol.TBinaryProtocolFactory(),
                        TBinaryProtocol.TBinaryProtocolFactory())
    elif (len(args) == 4):
      self.__initArgs__(args[0], args[1], args[2], args[2], args[3], args[3])
    elif (len(args) == 6):
      self.__initArgs__(args[0], args[1], args[2], args[3], args[4], args[5])

  def __initArgs__(self, processor, serverTransport,
                   inputTransportFactory, outputTransportFactory,
                   inputProtocolFactory, outputProtocolFactory):
    self.processor = processor
    self.serverTransport = serverTransport
    self.inputTransportFactory = inputTransportFactory
    self.outputTransportFactory = outputTransportFactory
    self.inputProtocolFactory = inputProtocolFactory
    self.outputProtocolFactory = outputProtocolFactory

  def serve(self):
    pass

class TSimpleServer(TServer):

  """Simple single-threaded server that just pumps around one transport."""

  def __init__(self, *args):
    TServer.__init__(self, *args)

  def serve(self):
    self.serverTransport.listen()
    while True:
      client = self.serverTransport.accept()
      itrans = self.inputTransportFactory.getTransport(client)
      otrans = self.outputTransportFactory.getTransport(client)
      iprot = self.inputProtocolFactory.getProtocol(itrans)
      oprot = self.outputProtocolFactory.getProtocol(otrans)
      try:
        while True:
          self.processor.process(iprot, oprot)
      except TTransport.TTransportException, tx:
        pass
      except Exception, x:
        logging.exception(x)

      itrans.close()
      otrans.close()

class TThreadedServer(TServer):

  """Threaded server that spawns a new thread per each connection."""

  def __init__(self, *args, **kwargs):
    TServer.__init__(self, *args)
    self.daemon = kwargs.get("daemon", False)

  def serve(self):
    self.serverTransport.listen()
    while True:
      try:
        client = self.serverTransport.accept()
        t = threading.Thread(target = self.handle, args=(client,))
        t.setDaemon(self.daemon)
        t.start()
      except KeyboardInterrupt:
        raise
      except Exception, x:
        logging.exception(x)

  def handle(self, client):
    itrans = self.inputTransportFactory.getTransport(client)
    otrans = self.outputTransportFactory.getTransport(client)
    iprot = self.inputProtocolFactory.getProtocol(itrans)
    oprot = self.outputProtocolFactory.getProtocol(otrans)
    try:
      while True:
        self.processor.process(iprot, oprot)
    except TTransport.TTransportException, tx:
      pass
    except Exception, x:
      logging.exception(x)

    itrans.close()
    otrans.close()

class TThreadPoolServer(TServer):

  """Server with a fixed size pool of threads which service requests."""

  def __init__(self, *args, **kwargs):
    TServer.__init__(self, *args)
    self.clients = Queue.Queue()
    self.threads = 10
    self.daemon = kwargs.get("daemon", False)

  def setNumThreads(self, num):
    """Set the number of worker threads that should be created"""
    self.threads = num

  def serveThread(self):
    """Loop around getting clients from the shared queue and process them."""
    while True:
      try:
        client = self.clients.get()
        self.serveClient(client)
      except Exception, x:
        logging.exception(x)

  def serveClient(self, client):
    """Process input/output from a client for as long as possible"""
    itrans = self.inputTransportFactory.getTransport(client)
    otrans = self.outputTransportFactory.getTransport(client)
    iprot = self.inputProtocolFactory.getProtocol(itrans)
    oprot = self.outputProtocolFactory.getProtocol(otrans)
    try:
      while True:
        self.processor.process(iprot, oprot)
    except TTransport.TTransportException, tx:
      pass
    except Exception, x:
      logging.exception(x)

    itrans.close()
    otrans.close()

  def serve(self):
    """Start a fixed number of worker threads and put client into a queue"""
    for i in range(self.threads):
      try:
        t = threading.Thread(target = self.serveThread)
        t.setDaemon(self.daemon)
        t.start()
      except Exception, x:
        logging.exception(x)

    # Pump the socket for clients
    self.serverTransport.listen()
    while True:
      try:
        client = self.serverTransport.accept()
        self.clients.put(client)
      except Exception, x:
        logging.exception(x)


class TForkingServer(TServer):

  """A Thrift server that forks a new process for each request"""
  """
  This is more scalable than the threaded server as it does not cause
  GIL contention.

  Note that this has different semantics from the threading server.
  Specifically, updates to shared variables will no longer be shared.
  It will also not work on windows.

  This code is heavily inspired by SocketServer.ForkingMixIn in the
  Python stdlib.
  """

  def __init__(self, *args):
    TServer.__init__(self, *args)
    self.children = []

  def serve(self):
    def try_close(file):
      try:
        file.close()
      except IOError, e:
        logging.warning(e, exc_info=True)


    self.serverTransport.listen()
    while True:
      client = self.serverTransport.accept()
      try:
        pid = os.fork()

        if pid: # parent
          # add before collect, otherwise you race w/ waitpid
          self.children.append(pid)
          self.collect_children()

          # Parent must close socket or the connection may not get
          # closed promptly
          itrans = self.inputTransportFactory.getTransport(client)
          otrans = self.outputTransportFactory.getTransport(client)
          try_close(itrans)
          try_close(otrans)
        else:
          itrans = self.inputTransportFactory.getTransport(client)
          otrans = self.outputTransportFactory.getTransport(client)

          iprot = self.inputProtocolFactory.getProtocol(itrans)
          oprot = self.outputProtocolFactory.getProtocol(otrans)

          ecode = 0
          try:
            try:
              while True:
                self.processor.process(iprot, oprot)
            except TTransport.TTransportException, tx:
              pass
            except Exception, e:
              logging.exception(e)
              ecode = 1
          finally:
            try_close(itrans)
            try_close(otrans)

          os._exit(ecode)

      except TTransport.TTransportException, tx:
        pass
      except Exception, x:
        logging.exception(x)


  def collect_children(self):
    while self.children:
      try:
        pid, status = os.waitpid(0, os.WNOHANG)
      except os.error:
        pid = None

      if pid:
        self.children.remove(pid)
      else:
        break



########NEW FILE########
__FILENAME__ = Thrift
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import sys

class TType:
  STOP   = 0
  VOID   = 1
  BOOL   = 2
  BYTE   = 3
  I08    = 3
  DOUBLE = 4
  I16    = 6
  I32    = 8
  I64    = 10
  STRING = 11
  UTF7   = 11
  STRUCT = 12
  MAP    = 13
  SET    = 14
  LIST   = 15
  UTF8   = 16
  UTF16  = 17

  _VALUES_TO_NAMES = ( 'STOP',
                      'VOID',
                      'BOOL',
                      'BYTE',
                      'DOUBLE',
                      None,
                      'I16',
                      None,
                      'I32',
                      None,
                       'I64',
                       'STRING',
                       'STRUCT',
                       'MAP',
                       'SET',
                       'LIST',
                       'UTF8',
                       'UTF16' )

class TMessageType:
  CALL  = 1
  REPLY = 2
  EXCEPTION = 3
  ONEWAY = 4

class TProcessor:

  """Base class for procsessor, which works on two streams."""

  def process(iprot, oprot):
    pass

class TException(Exception):

  """Base class for all thrift exceptions."""

  # BaseException.message is deprecated in Python v[2.6,3.0)
  if (2,6,0) <= sys.version_info < (3,0):
    def _get_message(self):
	    return self._message
    def _set_message(self, message):
	    self._message = message
    message = property(_get_message, _set_message)

  def __init__(self, message=None):
    Exception.__init__(self, message)
    self.message = message

class TApplicationException(TException):

  """Application level thrift exceptions."""

  UNKNOWN = 0
  UNKNOWN_METHOD = 1
  INVALID_MESSAGE_TYPE = 2
  WRONG_METHOD_NAME = 3
  BAD_SEQUENCE_ID = 4
  MISSING_RESULT = 5
  INTERNAL_ERROR = 6
  PROTOCOL_ERROR = 7

  def __init__(self, type=UNKNOWN, message=None):
    TException.__init__(self, message)
    self.type = type

  def __str__(self):
    if self.message:
      return self.message
    elif self.type == self.UNKNOWN_METHOD:
      return 'Unknown method'
    elif self.type == self.INVALID_MESSAGE_TYPE:
      return 'Invalid message type'
    elif self.type == self.WRONG_METHOD_NAME:
      return 'Wrong method name'
    elif self.type == self.BAD_SEQUENCE_ID:
      return 'Bad sequence ID'
    elif self.type == self.MISSING_RESULT:
      return 'Missing result'
    else:
      return 'Default (unknown) TApplicationException'

  def read(self, iprot):
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    oprot.writeStructBegin('TApplicationException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

########NEW FILE########
__FILENAME__ = THttpClient
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TTransport import TTransportBase
from cStringIO import StringIO

import urlparse
import httplib
import warnings
import socket


class THttpClient(TTransportBase):

    """Http implementation of TTransport base."""

    def __init__(
        self,
        uri_or_host,
        port=None,
        path=None,
        proxy_host=None,
        proxy_port=None
    ):
        """THttpClient supports two different types constructor parameters.

        THttpClient(host, port, path) - deprecated
        THttpClient(uri)

        Only the second supports https."""

        """THttpClient supports proxy
        THttpClient(host, port, path, proxy_host, proxy_port) - deprecated
        ThttpClient(uri, None, None, proxy_host, proxy_port)"""

        if port is not None:
            warnings.warn(
                "Please use the THttpClient('http://host:port/path') syntax",
                DeprecationWarning,
                stacklevel=2)
            self.host = uri_or_host
            self.port = port
            assert path
            self.path = path
            self.scheme = 'http'
        else:
            parsed = urlparse.urlparse(uri_or_host)
            self.scheme = parsed.scheme
            assert self.scheme in ('http', 'https')
            if self.scheme == 'http':
                self.port = parsed.port or httplib.HTTP_PORT
            elif self.scheme == 'https':
                self.port = parsed.port or httplib.HTTPS_PORT
            self.host = parsed.hostname
            self.path = parsed.path
            if parsed.query:
                self.path += '?%s' % parsed.query

        if proxy_host is not None and proxy_port is not None:
            self.endpoint_host = proxy_host
            self.endpoint_port = proxy_port
            self.path = urlparse.urlunparse((
                self.scheme,
                "%s:%i" % (self.host, self.port),
                self.path,
                None,
                None,
                None
            ))
        else:
            self.endpoint_host = self.host
            self.endpoint_port = self.port

        self.__wbuf = StringIO()
        self.__http = None
        self.__timeout = None
        self.__headers = {}

    def open(self):
        protocol = httplib.HTTP if self.scheme == 'http' else httplib.HTTPS
        self.__http = protocol(self.endpoint_host, self.endpoint_port)

    def close(self):
        self.__http.close()
        self.__http = None

    def isOpen(self):
        return self.__http is not None

    def setTimeout(self, ms):
        if not hasattr(socket, 'getdefaulttimeout'):
            raise NotImplementedError

        if ms is None:
            self.__timeout = None
        else:
            self.__timeout = ms / 1000.0

    def read(self, sz):
        return self.__http.file.read(sz)

    def write(self, buf):
        self.__wbuf.write(buf)

    def __withTimeout(f):
        def _f(*args, **kwargs):
            orig_timeout = socket.getdefaulttimeout()
            socket.setdefaulttimeout(args[0].__timeout)
            result = f(*args, **kwargs)
            socket.setdefaulttimeout(orig_timeout)
            return result
        return _f

    def addHeaders(self, **kwargs):
        self.__headers.update(kwargs)

    def flush(self):
        if self.isOpen():
            self.close()
        self.open()

        # Pull data out of buffer
        data = self.__wbuf.getvalue()
        self.__wbuf = StringIO()

        # HTTP request
        self.__http.putrequest('POST', self.path)

        # Write headers
        self.__http.putheader('Host', self.host)
        self.__http.putheader('Content-Type', 'application/x-thrift')
        self.__http.putheader('Content-Length', str(len(data)))
        for key, value in self.__headers.iteritems():
            self.__http.putheader(key, value)
        self.__http.endheaders()

        # Write payload
        self.__http.send(data)

        # Get reply to flush the request
        self.code, self.message, self.headers = self.__http.getreply()

    # Decorate if we know how to timeout
    if hasattr(socket, 'getdefaulttimeout'):
        flush = __withTimeout(flush)

########NEW FILE########
__FILENAME__ = TSocket
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TTransport import *
import os
import errno
import socket
import sys

class TSocketBase(TTransportBase):
  def _resolveAddr(self):
    if self._unix_socket is not None:
      return [(socket.AF_UNIX, socket.SOCK_STREAM, None, None, self._unix_socket)]
    else:
      return socket.getaddrinfo(self.host, self.port, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_PASSIVE | socket.AI_ADDRCONFIG)

  def close(self):
    if self.handle:
      self.handle.close()
      self.handle = None

class TSocket(TSocketBase):
  """Socket implementation of TTransport base."""

  def __init__(self, host='localhost', port=9090, unix_socket=None):
    """Initialize a TSocket

    @param host(str)  The host to connect to.
    @param port(int)  The (TCP) port to connect to.
    @param unix_socket(str)  The filename of a unix socket to connect to.
                             (host and port will be ignored.)
    """

    self.host = host
    self.port = port
    self.handle = None
    self._unix_socket = unix_socket
    self._timeout = None

  def setHandle(self, h):
    self.handle = h

  def isOpen(self):
    return self.handle is not None

  def setTimeout(self, ms):
    if ms is None:
      self._timeout = None
    else:
      self._timeout = ms/1000.0

    if self.handle is not None:
      self.handle.settimeout(self._timeout)

  def open(self):
    try:
      res0 = self._resolveAddr()
      for res in res0:
        self.handle = socket.socket(res[0], res[1])
        self.handle.settimeout(self._timeout)
        try:
          self.handle.connect(res[4])
        except socket.error, e:
          if res is not res0[-1]:
            continue
          else:
            raise e
        break
    except socket.error, e:
      if self._unix_socket:
        message = 'Could not connect to socket %s' % self._unix_socket
      else:
        message = 'Could not connect to %s:%d' % (self.host, self.port)
      raise TTransportException(type=TTransportException.NOT_OPEN, message=message)

  def read(self, sz):
    try:
      buff = self.handle.recv(sz)
    except socket.error, e:
      if (e.args[0] == errno.ECONNRESET and
          (sys.platform == 'darwin' or sys.platform.startswith('freebsd'))):
        # freebsd and Mach don't follow POSIX semantic of recv
        # and fail with ECONNRESET if peer performed shutdown.
        # See corresponding comment and code in TSocket::read()
        # in lib/cpp/src/transport/TSocket.cpp.
        self.close()
        # Trigger the check to raise the END_OF_FILE exception below.
        buff = ''
      else:
        raise
    if len(buff) == 0:
      raise TTransportException(type=TTransportException.END_OF_FILE, message='TSocket read 0 bytes')
    return buff

  def write(self, buff):
    if not self.handle:
      raise TTransportException(type=TTransportException.NOT_OPEN, message='Transport not open')
    sent = 0
    have = len(buff)
    while sent < have:
      plus = self.handle.send(buff)
      if plus == 0:
        raise TTransportException(type=TTransportException.END_OF_FILE, message='TSocket sent 0 bytes')
      sent += plus
      buff = buff[plus:]

  def flush(self):
    pass

class TServerSocket(TSocketBase, TServerTransportBase):
  """Socket implementation of TServerTransport base."""

  def __init__(self, host=None, port=9090, unix_socket=None):
    self.host = host
    self.port = port
    self._unix_socket = unix_socket
    self.handle = None

  def listen(self):
    res0 = self._resolveAddr()
    for res in res0:
      if res[0] is socket.AF_INET6 or res is res0[-1]:
        break

    # We need remove the old unix socket if the file exists and
    # nobody is listening on it.
    if self._unix_socket:
      tmp = socket.socket(res[0], res[1])
      try:
        tmp.connect(res[4])
      except socket.error, err:
        eno, message = err.args
        if eno == errno.ECONNREFUSED:
          os.unlink(res[4])

    self.handle = socket.socket(res[0], res[1])
    self.handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    if hasattr(self.handle, 'settimeout'):
      self.handle.settimeout(None)
    self.handle.bind(res[4])
    self.handle.listen(128)

  def accept(self):
    client, addr = self.handle.accept()
    result = TSocket()
    result.setHandle(client)
    return result

########NEW FILE########
__FILENAME__ = TSSLSocket
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
import os
import socket
import ssl

from thrift.transport import TSocket
from thrift.transport.TTransport import TTransportException

class TSSLSocket(TSocket.TSocket):
  """
  SSL implementation of client-side TSocket

  This class creates outbound sockets wrapped using the
  python standard ssl module for encrypted connections.
  
  The protocol used is set using the class variable
  SSL_VERSION, which must be one of ssl.PROTOCOL_* and
  defaults to  ssl.PROTOCOL_TLSv1 for greatest security.
  """
  SSL_VERSION = ssl.PROTOCOL_TLSv1

  def __init__(self, host='localhost', port=9090, validate=True, ca_certs=None, unix_socket=None):
    """
    @param validate: Set to False to disable SSL certificate validation entirely.
    @type validate: bool
    @param ca_certs: Filename to the Certificate Authority pem file, possibly a
    file downloaded from: http://curl.haxx.se/ca/cacert.pem  This is passed to
    the ssl_wrap function as the 'ca_certs' parameter.
    @type ca_certs: str
    
    Raises an IOError exception if validate is True and the ca_certs file is
    None, not present or unreadable.
    """
    self.validate = validate
    self.is_valid = False
    self.peercert = None
    if not validate:
      self.cert_reqs = ssl.CERT_NONE
    else:
      self.cert_reqs = ssl.CERT_REQUIRED
    self.ca_certs = ca_certs
    if validate:
      if ca_certs is None or not os.access(ca_certs, os.R_OK):
        raise IOError('Certificate Authority ca_certs file "%s" is not readable, cannot validate SSL certificates.' % (ca_certs))
    TSocket.TSocket.__init__(self, host, port, unix_socket)

  def open(self):
    try:
      res0 = self._resolveAddr()
      for res in res0:
        sock_family, sock_type= res[0:2]
        ip_port = res[4]
        plain_sock = socket.socket(sock_family, sock_type)
        self.handle = ssl.wrap_socket(plain_sock, ssl_version=self.SSL_VERSION,
            do_handshake_on_connect=True, ca_certs=self.ca_certs, cert_reqs=self.cert_reqs) 
        self.handle.settimeout(self._timeout)
        try:
          self.handle.connect(ip_port)
        except socket.error, e:
          if res is not res0[-1]:
            continue
          else:
            raise e
        break
    except socket.error, e:
      if self._unix_socket:
        message = 'Could not connect to secure socket %s' % self._unix_socket
      else:
        message = 'Could not connect to %s:%d' % (self.host, self.port)
      raise TTransportException(type=TTransportException.NOT_OPEN, message=message)
    if self.validate:
      self._validate_cert()

  def _validate_cert(self):
    """internal method to validate the peer's SSL certificate, and to check the
    commonName of the certificate to ensure it matches the hostname we
    used to make this connection.  Does not support subjectAltName records
    in certificates.
    
    raises TTransportException if the certificate fails validation."""
    cert = self.handle.getpeercert()
    self.peercert = cert
    if 'subject' not in cert:
      raise TTransportException(type=TTransportException.NOT_OPEN,
                      message='No SSL certificate found from %s:%s' % (self.host, self.port))
    fields = cert['subject']
    for field in fields:
      # ensure structure we get back is what we expect
      if not isinstance(field, tuple):
        continue
      cert_pair = field[0]
      if len(cert_pair) < 2:
        continue
      cert_key, cert_value = cert_pair[0:2]
      if cert_key != 'commonName':
        continue
      certhost = cert_value
      if certhost == self.host:
        # success, cert commonName matches desired hostname
        self.is_valid = True
        return 
      else:
        raise TTransportException(type=TTransportException.UNKNOWN,
                          message='Host name we connected to "%s" doesn\'t match certificate provided commonName "%s"' % (self.host, certhost))
    raise TTransportException(type=TTransportException.UNKNOWN,
                      message='Could not validate SSL certificate from host "%s".  Cert=%s' % (self.host, cert))

class TSSLServerSocket(TSocket.TServerSocket):
  """
  SSL implementation of TServerSocket

  This uses the ssl module's wrap_socket() method to provide SSL
  negotiated encryption.
  """
  SSL_VERSION = ssl.PROTOCOL_TLSv1

  def __init__(self, host=None, port=9090, certfile='cert.pem', unix_socket=None):
    """Initialize a TSSLServerSocket
    
    @param certfile: The filename of the server certificate file, defaults to cert.pem
    @type certfile: str
    @param host: The hostname or IP to bind the listen socket to, i.e. 'localhost' for only allowing
    local network connections. Pass None to bind to all interfaces.
    @type host: str
    @param port: The port to listen on for inbound connections.
    @type port: int
    """
    self.setCertfile(certfile)
    TSocket.TServerSocket.__init__(self, host, port)

  def setCertfile(self, certfile):
    """Set or change the server certificate file used to wrap new connections.
    
    @param certfile: The filename of the server certificate, i.e. '/etc/certs/server.pem'
    @type certfile: str
    
    Raises an IOError exception if the certfile is not present or unreadable.
    """
    if not os.access(certfile, os.R_OK):
      raise IOError('No such certfile found: %s' % (certfile))
    self.certfile = certfile

  def accept(self):
    plain_client, addr = self.handle.accept()
    try:
      client = ssl.wrap_socket(plain_client, certfile=self.certfile,
                      server_side=True, ssl_version=self.SSL_VERSION)
    except ssl.SSLError, ssl_exc:
      # failed handshake/ssl wrap, close socket to client
      plain_client.close()
      # raise ssl_exc
      # We can't raise the exception, because it kills most TServer derived serve()
      # methods.
      # Instead, return None, and let the TServer instance deal with it in
      # other exception handling.  (but TSimpleServer dies anyway)
      return None 
    result = TSocket.TSocket()
    result.setHandle(client)
    return result

########NEW FILE########
__FILENAME__ = TTransport
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from cStringIO import StringIO
from struct import pack,unpack
from thrift.Thrift import TException

class TTransportException(TException):

  """Custom Transport Exception class"""

  UNKNOWN = 0
  NOT_OPEN = 1
  ALREADY_OPEN = 2
  TIMED_OUT = 3
  END_OF_FILE = 4

  def __init__(self, type=UNKNOWN, message=None):
    TException.__init__(self, message)
    self.type = type

class TTransportBase:

  """Base class for Thrift transport layer."""

  def isOpen(self):
    pass

  def open(self):
    pass

  def close(self):
    pass

  def read(self, sz):
    pass

  def readAll(self, sz):
    buff = ''
    have = 0
    while (have < sz):
      chunk = self.read(sz-have)
      have += len(chunk)
      buff += chunk

      if len(chunk) == 0:
        raise EOFError()

    return buff

  def write(self, buf):
    pass

  def flush(self):
    pass

# This class should be thought of as an interface.
class CReadableTransport:
  """base class for transports that are readable from C"""

  # TODO(dreiss): Think about changing this interface to allow us to use
  #               a (Python, not c) StringIO instead, because it allows
  #               you to write after reading.

  # NOTE: This is a classic class, so properties will NOT work
  #       correctly for setting.
  @property
  def cstringio_buf(self):
    """A cStringIO buffer that contains the current chunk we are reading."""
    pass

  def cstringio_refill(self, partialread, reqlen):
    """Refills cstringio_buf.

    Returns the currently used buffer (which can but need not be the same as
    the old cstringio_buf). partialread is what the C code has read from the
    buffer, and should be inserted into the buffer before any more reads.  The
    return value must be a new, not borrowed reference.  Something along the
    lines of self._buf should be fine.

    If reqlen bytes can't be read, throw EOFError.
    """
    pass

class TServerTransportBase:

  """Base class for Thrift server transports."""

  def listen(self):
    pass

  def accept(self):
    pass

  def close(self):
    pass

class TTransportFactoryBase:

  """Base class for a Transport Factory"""

  def getTransport(self, trans):
    return trans

class TBufferedTransportFactory:

  """Factory transport that builds buffered transports"""

  def getTransport(self, trans):
    buffered = TBufferedTransport(trans)
    return buffered


class TBufferedTransport(TTransportBase,CReadableTransport):

  """Class that wraps another transport and buffers its I/O.

  The implementation uses a (configurable) fixed-size read buffer
  but buffers all writes until a flush is performed.
  """

  DEFAULT_BUFFER = 4096

  def __init__(self, trans, rbuf_size = DEFAULT_BUFFER):
    self.__trans = trans
    self.__wbuf = StringIO()
    self.__rbuf = StringIO("")
    self.__rbuf_size = rbuf_size

  def isOpen(self):
    return self.__trans.isOpen()

  def open(self):
    return self.__trans.open()

  def close(self):
    return self.__trans.close()

  def read(self, sz):
    ret = self.__rbuf.read(sz)
    if len(ret) != 0:
      return ret

    self.__rbuf = StringIO(self.__trans.read(max(sz, self.__rbuf_size)))
    return self.__rbuf.read(sz)

  def write(self, buf):
    self.__wbuf.write(buf)

  def flush(self):
    out = self.__wbuf.getvalue()
    # reset wbuf before write/flush to preserve state on underlying failure
    self.__wbuf = StringIO()
    self.__trans.write(out)
    self.__trans.flush()

  # Implement the CReadableTransport interface.
  @property
  def cstringio_buf(self):
    return self.__rbuf

  def cstringio_refill(self, partialread, reqlen):
    retstring = partialread
    if reqlen < self.__rbuf_size:
      # try to make a read of as much as we can.
      retstring += self.__trans.read(self.__rbuf_size)

    # but make sure we do read reqlen bytes.
    if len(retstring) < reqlen:
      retstring += self.__trans.readAll(reqlen - len(retstring))

    self.__rbuf = StringIO(retstring)
    return self.__rbuf

class TMemoryBuffer(TTransportBase, CReadableTransport):
  """Wraps a cStringIO object as a TTransport.

  NOTE: Unlike the C++ version of this class, you cannot write to it
        then immediately read from it.  If you want to read from a
        TMemoryBuffer, you must either pass a string to the constructor.
  TODO(dreiss): Make this work like the C++ version.
  """

  def __init__(self, value=None):
    """value -- a value to read from for stringio

    If value is set, this will be a transport for reading,
    otherwise, it is for writing"""
    if value is not None:
      self._buffer = StringIO(value)
    else:
      self._buffer = StringIO()

  def isOpen(self):
    return not self._buffer.closed

  def open(self):
    pass

  def close(self):
    self._buffer.close()

  def read(self, sz):
    return self._buffer.read(sz)

  def write(self, buf):
    self._buffer.write(buf)

  def flush(self):
    pass

  def getvalue(self):
    return self._buffer.getvalue()

  # Implement the CReadableTransport interface.
  @property
  def cstringio_buf(self):
    return self._buffer

  def cstringio_refill(self, partialread, reqlen):
    # only one shot at reading...
    raise EOFError()

class TFramedTransportFactory:

  """Factory transport that builds framed transports"""

  def getTransport(self, trans):
    framed = TFramedTransport(trans)
    return framed


class TFramedTransport(TTransportBase, CReadableTransport):

  """Class that wraps another transport and frames its I/O when writing."""

  def __init__(self, trans,):
    self.__trans = trans
    self.__rbuf = StringIO()
    self.__wbuf = StringIO()

  def isOpen(self):
    return self.__trans.isOpen()

  def open(self):
    return self.__trans.open()

  def close(self):
    return self.__trans.close()

  def read(self, sz):
    ret = self.__rbuf.read(sz)
    if len(ret) != 0:
      return ret

    self.readFrame()
    return self.__rbuf.read(sz)

  def readFrame(self):
    buff = self.__trans.readAll(4)
    sz, = unpack('!i', buff)
    self.__rbuf = StringIO(self.__trans.readAll(sz))

  def write(self, buf):
    self.__wbuf.write(buf)

  def flush(self):
    wout = self.__wbuf.getvalue()
    wsz = len(wout)
    # reset wbuf before write/flush to preserve state on underlying failure
    self.__wbuf = StringIO()
    # N.B.: Doing this string concatenation is WAY cheaper than making
    # two separate calls to the underlying socket object. Socket writes in
    # Python turn out to be REALLY expensive, but it seems to do a pretty
    # good job of managing string buffer operations without excessive copies
    buf = pack("!i", wsz) + wout
    self.__trans.write(buf)
    self.__trans.flush()

  # Implement the CReadableTransport interface.
  @property
  def cstringio_buf(self):
    return self.__rbuf

  def cstringio_refill(self, prefix, reqlen):
    # self.__rbuf will already be empty here because fastbinary doesn't
    # ask for a refill until the previous buffer is empty.  Therefore,
    # we can start reading new frames immediately.
    while len(prefix) < reqlen:
      self.readFrame()
      prefix += self.__rbuf.getvalue()
    self.__rbuf = StringIO(prefix)
    return self.__rbuf


class TFileObjectTransport(TTransportBase):
  """Wraps a file-like object to make it work as a Thrift transport."""

  def __init__(self, fileobj):
    self.fileobj = fileobj

  def isOpen(self):
    return True

  def close(self):
    self.fileobj.close()

  def read(self, sz):
    return self.fileobj.read(sz)

  def write(self, buf):
    self.fileobj.write(buf)

  def flush(self):
    self.fileobj.flush()

########NEW FILE########
__FILENAME__ = TTwisted
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
from zope.interface import implements, Interface, Attribute
from twisted.internet.protocol import Protocol, ServerFactory, ClientFactory, \
    connectionDone
from twisted.internet import defer
from twisted.protocols import basic
from twisted.python import log
from twisted.web import server, resource, http

from thrift.transport import TTransport
from cStringIO import StringIO


class TMessageSenderTransport(TTransport.TTransportBase):

    def __init__(self):
        self.__wbuf = StringIO()

    def write(self, buf):
        self.__wbuf.write(buf)

    def flush(self):
        msg = self.__wbuf.getvalue()
        self.__wbuf = StringIO()
        self.sendMessage(msg)

    def sendMessage(self, message):
        raise NotImplementedError


class TCallbackTransport(TMessageSenderTransport):

    def __init__(self, func):
        TMessageSenderTransport.__init__(self)
        self.func = func

    def sendMessage(self, message):
        self.func(message)


class ThriftClientProtocol(basic.Int32StringReceiver):

    MAX_LENGTH = 2 ** 31 - 1

    def __init__(self, client_class, iprot_factory, oprot_factory=None):
        self._client_class = client_class
        self._iprot_factory = iprot_factory
        if oprot_factory is None:
            self._oprot_factory = iprot_factory
        else:
            self._oprot_factory = oprot_factory

        self.recv_map = {}
        self.started = defer.Deferred()

    def dispatch(self, msg):
        self.sendString(msg)

    def connectionMade(self):
        tmo = TCallbackTransport(self.dispatch)
        self.client = self._client_class(tmo, self._oprot_factory)
        self.started.callback(self.client)

    def connectionLost(self, reason=connectionDone):
        for k,v in self.client._reqs.iteritems():
            tex = TTransport.TTransportException(
                type=TTransport.TTransportException.END_OF_FILE,
                message='Connection closed')
            v.errback(tex)

    def stringReceived(self, frame):
        tr = TTransport.TMemoryBuffer(frame)
        iprot = self._iprot_factory.getProtocol(tr)
        (fname, mtype, rseqid) = iprot.readMessageBegin()

        try:
            method = self.recv_map[fname]
        except KeyError:
            method = getattr(self.client, 'recv_' + fname)
            self.recv_map[fname] = method

        method(iprot, mtype, rseqid)


class ThriftServerProtocol(basic.Int32StringReceiver):

    MAX_LENGTH = 2 ** 31 - 1

    def dispatch(self, msg):
        self.sendString(msg)

    def processError(self, error):
        self.transport.loseConnection()

    def processOk(self, _, tmo):
        msg = tmo.getvalue()

        if len(msg) > 0:
            self.dispatch(msg)

    def stringReceived(self, frame):
        tmi = TTransport.TMemoryBuffer(frame)
        tmo = TTransport.TMemoryBuffer()

        iprot = self.factory.iprot_factory.getProtocol(tmi)
        oprot = self.factory.oprot_factory.getProtocol(tmo)

        d = self.factory.processor.process(iprot, oprot)
        d.addCallbacks(self.processOk, self.processError,
            callbackArgs=(tmo,))


class IThriftServerFactory(Interface):

    processor = Attribute("Thrift processor")

    iprot_factory = Attribute("Input protocol factory")

    oprot_factory = Attribute("Output protocol factory")


class IThriftClientFactory(Interface):

    client_class = Attribute("Thrift client class")

    iprot_factory = Attribute("Input protocol factory")

    oprot_factory = Attribute("Output protocol factory")


class ThriftServerFactory(ServerFactory):

    implements(IThriftServerFactory)

    protocol = ThriftServerProtocol

    def __init__(self, processor, iprot_factory, oprot_factory=None):
        self.processor = processor
        self.iprot_factory = iprot_factory
        if oprot_factory is None:
            self.oprot_factory = iprot_factory
        else:
            self.oprot_factory = oprot_factory


class ThriftClientFactory(ClientFactory):

    implements(IThriftClientFactory)

    protocol = ThriftClientProtocol

    def __init__(self, client_class, iprot_factory, oprot_factory=None):
        self.client_class = client_class
        self.iprot_factory = iprot_factory
        if oprot_factory is None:
            self.oprot_factory = iprot_factory
        else:
            self.oprot_factory = oprot_factory

    def buildProtocol(self, addr):
        p = self.protocol(self.client_class, self.iprot_factory,
            self.oprot_factory)
        p.factory = self
        return p


class ThriftResource(resource.Resource):

    allowedMethods = ('POST',)

    def __init__(self, processor, inputProtocolFactory,
        outputProtocolFactory=None):
        resource.Resource.__init__(self)
        self.inputProtocolFactory = inputProtocolFactory
        if outputProtocolFactory is None:
            self.outputProtocolFactory = inputProtocolFactory
        else:
            self.outputProtocolFactory = outputProtocolFactory
        self.processor = processor

    def getChild(self, path, request):
        return self

    def _cbProcess(self, _, request, tmo):
        msg = tmo.getvalue()
        request.setResponseCode(http.OK)
        request.setHeader("content-type", "application/x-thrift")
        request.write(msg)
        request.finish()

    def render_POST(self, request):
        request.content.seek(0, 0)
        data = request.content.read()
        tmi = TTransport.TMemoryBuffer(data)
        tmo = TTransport.TMemoryBuffer()

        iprot = self.inputProtocolFactory.getProtocol(tmi)
        oprot = self.outputProtocolFactory.getProtocol(tmo)

        d = self.processor.process(iprot, oprot)
        d.addCallback(self._cbProcess, request, tmo)
        return server.NOT_DONE_YET

########NEW FILE########
__FILENAME__ = TZlibTransport
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
'''
TZlibTransport provides a compressed transport and transport factory
class, using the python standard library zlib module to implement
data compression.
'''

from __future__ import division
import zlib
from cStringIO import StringIO
from TTransport import TTransportBase, CReadableTransport

class TZlibTransportFactory(object):
  '''
  Factory transport that builds zlib compressed transports.
  
  This factory caches the last single client/transport that it was passed
  and returns the same TZlibTransport object that was created.
  
  This caching means the TServer class will get the _same_ transport
  object for both input and output transports from this factory.
  (For non-threaded scenarios only, since the cache only holds one object)
  
  The purpose of this caching is to allocate only one TZlibTransport where
  only one is really needed (since it must have separate read/write buffers),
  and makes the statistics from getCompSavings() and getCompRatio()
  easier to understand.
  '''

  # class scoped cache of last transport given and zlibtransport returned
  _last_trans = None
  _last_z = None

  def getTransport(self, trans, compresslevel=9):
    '''Wrap a transport , trans, with the TZlibTransport
    compressed transport class, returning a new
    transport to the caller.
    
    @param compresslevel: The zlib compression level, ranging
    from 0 (no compression) to 9 (best compression).  Defaults to 9.
    @type compresslevel: int
    
    This method returns a TZlibTransport which wraps the
    passed C{trans} TTransport derived instance.
    '''
    if trans == self._last_trans:
      return self._last_z
    ztrans = TZlibTransport(trans, compresslevel)
    self._last_trans = trans
    self._last_z = ztrans
    return ztrans


class TZlibTransport(TTransportBase, CReadableTransport):
  '''
  Class that wraps a transport with zlib, compressing writes
  and decompresses reads, using the python standard
  library zlib module.
  '''

  # Read buffer size for the python fastbinary C extension,
  # the TBinaryProtocolAccelerated class.
  DEFAULT_BUFFSIZE = 4096

  def __init__(self, trans, compresslevel=9):
    '''
    Create a new TZlibTransport, wrapping C{trans}, another
    TTransport derived object.
    
    @param trans: A thrift transport object, i.e. a TSocket() object.
    @type trans: TTransport
    @param compresslevel: The zlib compression level, ranging
    from 0 (no compression) to 9 (best compression).  Default is 9.
    @type compresslevel: int
    '''
    self.__trans = trans
    self.compresslevel = compresslevel
    self.__rbuf = StringIO()
    self.__wbuf = StringIO()
    self._init_zlib()
    self._init_stats()

  def _reinit_buffers(self):
    '''
    Internal method to initialize/reset the internal StringIO objects
    for read and write buffers.
    '''
    self.__rbuf = StringIO()
    self.__wbuf = StringIO()

  def _init_stats(self):
    '''
    Internal method to reset the internal statistics counters
    for compression ratios and bandwidth savings.
    '''
    self.bytes_in = 0
    self.bytes_out = 0
    self.bytes_in_comp = 0
    self.bytes_out_comp = 0

  def _init_zlib(self):
    '''
    Internal method for setting up the zlib compression and
    decompression objects.
    '''
    self._zcomp_read = zlib.decompressobj()
    self._zcomp_write = zlib.compressobj(self.compresslevel)

  def getCompRatio(self):
    '''
    Get the current measured compression ratios (in,out) from
    this transport.
    
    Returns a tuple of: 
    (inbound_compression_ratio, outbound_compression_ratio)
    
    The compression ratios are computed as:
        compressed / uncompressed

    E.g., data that compresses by 10x will have a ratio of: 0.10
    and data that compresses to half of ts original size will
    have a ratio of 0.5
    
    None is returned if no bytes have yet been processed in
    a particular direction.
    '''
    r_percent, w_percent = (None, None)
    if self.bytes_in > 0:
      r_percent = self.bytes_in_comp / self.bytes_in
    if self.bytes_out > 0:
      w_percent = self.bytes_out_comp / self.bytes_out
    return (r_percent, w_percent)

  def getCompSavings(self):
    '''
    Get the current count of saved bytes due to data
    compression.
    
    Returns a tuple of:
    (inbound_saved_bytes, outbound_saved_bytes)
    
    Note: if compression is actually expanding your
    data (only likely with very tiny thrift objects), then
    the values returned will be negative.
    '''
    r_saved = self.bytes_in - self.bytes_in_comp
    w_saved = self.bytes_out - self.bytes_out_comp
    return (r_saved, w_saved)

  def isOpen(self):
    '''Return the underlying transport's open status'''
    return self.__trans.isOpen()

  def open(self):
    """Open the underlying transport"""
    self._init_stats()
    return self.__trans.open()

  def listen(self):
    '''Invoke the underlying transport's listen() method'''
    self.__trans.listen()

  def accept(self):
    '''Accept connections on the underlying transport'''
    return self.__trans.accept()

  def close(self):
    '''Close the underlying transport,'''
    self._reinit_buffers()
    self._init_zlib()
    return self.__trans.close()

  def read(self, sz):
    '''
    Read up to sz bytes from the decompressed bytes buffer, and
    read from the underlying transport if the decompression
    buffer is empty.
    '''
    ret = self.__rbuf.read(sz)
    if len(ret) > 0:
      return ret
    # keep reading from transport until something comes back
    while True:
      if self.readComp(sz):
        break
    ret = self.__rbuf.read(sz)
    return ret

  def readComp(self, sz):
    '''
    Read compressed data from the underlying transport, then
    decompress it and append it to the internal StringIO read buffer
    '''
    zbuf = self.__trans.read(sz)
    zbuf = self._zcomp_read.unconsumed_tail + zbuf
    buf = self._zcomp_read.decompress(zbuf)
    self.bytes_in += len(zbuf)
    self.bytes_in_comp += len(buf)
    old = self.__rbuf.read()
    self.__rbuf = StringIO(old + buf)
    if len(old) + len(buf) == 0:
      return False
    return True

  def write(self, buf):
    '''
    Write some bytes, putting them into the internal write
    buffer for eventual compression.
    '''
    self.__wbuf.write(buf)

  def flush(self):
    '''
    Flush any queued up data in the write buffer and ensure the
    compression buffer is flushed out to the underlying transport
    '''
    wout = self.__wbuf.getvalue()
    if len(wout) > 0:
      zbuf = self._zcomp_write.compress(wout)
      self.bytes_out += len(wout)
      self.bytes_out_comp += len(zbuf)
    else:
      zbuf = ''
    ztail = self._zcomp_write.flush(zlib.Z_SYNC_FLUSH)
    self.bytes_out_comp += len(ztail)
    if (len(zbuf) + len(ztail)) > 0:
      self.__wbuf = StringIO()
      self.__trans.write(zbuf + ztail)
    self.__trans.flush()

  @property
  def cstringio_buf(self):
    '''Implement the CReadableTransport interface'''
    return self.__rbuf

  def cstringio_refill(self, partialread, reqlen):
    '''Implement the CReadableTransport interface for refill'''
    retstring = partialread
    if reqlen < self.DEFAULT_BUFFSIZE:
      retstring += self.read(self.DEFAULT_BUFFSIZE)
    while len(retstring) < reqlen:
      retstring += self.read(reqlen - len(retstring))
    self.__rbuf = StringIO(retstring)
    return self.__rbuf

########NEW FILE########
__FILENAME__ = TSCons
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from os import path
from SCons.Builder import Builder

def scons_env(env, add=''):
  opath = path.dirname(path.abspath('$TARGET'))
  lstr = 'thrift --gen cpp -o ' + opath + ' ' + add + ' $SOURCE'
  cppbuild = Builder(action = lstr)
  env.Append(BUILDERS = {'ThriftCpp' : cppbuild})

def gen_cpp(env, dir, file):
  scons_env(env)
  suffixes = ['_types.h', '_types.cpp']
  targets = map(lambda s: 'gen-cpp/' + file + s, suffixes)
  return env.ThriftCpp(targets, dir+file+'.thrift')

########NEW FILE########
__FILENAME__ = TSerialization
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from protocol import TBinaryProtocol
from transport import TTransport

def serialize(thrift_object, protocol_factory = TBinaryProtocol.TBinaryProtocolFactory()):
    transport = TTransport.TMemoryBuffer()
    protocol = protocol_factory.getProtocol(transport)
    thrift_object.write(protocol)
    return transport.getvalue()

def deserialize(base, buf, protocol_factory = TBinaryProtocol.TBinaryProtocolFactory()):
    transport = TTransport.TMemoryBuffer(buf)
    protocol = protocol_factory.getProtocol(transport)
    base.read(protocol)
    return base


########NEW FILE########
__FILENAME__ = EDAMTest
#
# A simple Evernote API demo script that lists all notebooks in the user's
# account and creates a simple test note in the default notebook.
#
# Before running this sample, you must fill in your Evernote developer token.
#
# To run (Unix):
#   export PYTHONPATH=../../lib; python EDAMTest.py
#

import hashlib
import binascii
import evernote.edam.userstore.constants as UserStoreConstants
import evernote.edam.type.ttypes as Types

from evernote.api.client import EvernoteClient

# Real applications authenticate with Evernote using OAuth, but for the
# purpose of exploring the API, you can get a developer token that allows
# you to access your own Evernote account. To get a developer token, visit
# https://sandbox.evernote.com/api/DeveloperToken.action
auth_token = "your developer token"

if auth_token == "your developer token":
    print "Please fill in your developer token"
    print "To get a developer token, visit " \
        "https://sandbox.evernote.com/api/DeveloperToken.action"
    exit(1)

# Initial development is performed on our sandbox server. To use the production
# service, change sandbox=False and replace your
# developer token above with a token from
# https://www.evernote.com/api/DeveloperToken.action
client = EvernoteClient(token=auth_token, sandbox=True)

user_store = client.get_user_store()

version_ok = user_store.checkVersion(
    "Evernote EDAMTest (Python)",
    UserStoreConstants.EDAM_VERSION_MAJOR,
    UserStoreConstants.EDAM_VERSION_MINOR
)
print "Is my Evernote API version up to date? ", str(version_ok)
print ""
if not version_ok:
    exit(1)

note_store = client.get_note_store()

# List all of the notebooks in the user's account
notebooks = note_store.listNotebooks()
print "Found ", len(notebooks), " notebooks:"
for notebook in notebooks:
    print "  * ", notebook.name

print
print "Creating a new note in the default notebook"
print

# To create a new note, simply create a new Note object and fill in
# attributes such as the note's title.
note = Types.Note()
note.title = "Test note from EDAMTest.py"

# To include an attachment such as an image in a note, first create a Resource
# for the attachment. At a minimum, the Resource contains the binary attachment
# data, an MD5 hash of the binary data, and the attachment MIME type.
# It can also include attributes such as filename and location.
image = open('enlogo.png', 'rb').read()
md5 = hashlib.md5()
md5.update(image)
hash = md5.digest()

data = Types.Data()
data.size = len(image)
data.bodyHash = hash
data.body = image

resource = Types.Resource()
resource.mime = 'image/png'
resource.data = data

# Now, add the new Resource to the note's list of resources
note.resources = [resource]

# To display the Resource as part of the note's content, include an <en-media>
# tag in the note's ENML content. The en-media tag identifies the corresponding
# Resource using the MD5 hash.
hash_hex = binascii.hexlify(hash)

# The content of an Evernote note is represented using Evernote Markup Language
# (ENML). The full ENML specification can be found in the Evernote API Overview
# at http://dev.evernote.com/documentation/cloud/chapters/ENML.php
note.content = '<?xml version="1.0" encoding="UTF-8"?>'
note.content += '<!DOCTYPE en-note SYSTEM ' \
    '"http://xml.evernote.com/pub/enml2.dtd">'
note.content += '<en-note>Here is the Evernote logo:<br/>'
note.content += '<en-media type="image/png" hash="' + hash_hex + '"/>'
note.content += '</en-note>'

# Finally, send the new note to Evernote using the createNote method
# The new Note object that is returned will contain server-generated
# attributes such as the new note's unique GUID.
created_note = note_store.createNote(note)

print "Successfully created a new note with GUID: ", created_note.guid

########NEW FILE########
__FILENAME__ = settings
# Django settings for evernote_oauth_sample project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': '',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '6%0s^4-@_16sk82@s_97!$%292(j^uaxuj(+0nxtl$n3#y+nr+'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

SESSION_ENGINE = "django.contrib.sessions.backends.cache"

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake'
    }
}

ROOT_URLCONF = 'evernote_oauth_sample.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'evernote_oauth_sample.wsgi.application'

import os
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    os.path.join(BASE_DIR, 'templates')
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'oauth'
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns(
    'oauth.views',
    url(r"^$", "index", name="evernote_index"),
    url(r"^auth/$", "auth", name="evernote_auth"),
    url(r"^callback/$", "callback", name="evernote_callback"),
    url(r"^reset/$", "reset", name="evernote_auth_reset"),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for evernote_oauth_sample project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault(
    "DJANGO_SETTINGS_MODULE", "evernote_oauth_sample.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "evernote_oauth_sample.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
from evernote.api.client import EvernoteClient

from django.core.urlresolvers import reverse
from django.shortcuts import render_to_response
from django.shortcuts import redirect

EN_CONSUMER_KEY = 'your consumer key'
EN_CONSUMER_SECRET = 'your consumer secret'


def get_evernote_client(token=None):
    if token:
        return EvernoteClient(token=token, sandbox=True)
    else:
        return EvernoteClient(
            consumer_key=EN_CONSUMER_KEY,
            consumer_secret=EN_CONSUMER_SECRET,
            sandbox=True
        )


def index(request):
    return render_to_response('oauth/index.html')


def auth(request):
    client = get_evernote_client()
    callbackUrl = 'http://%s%s' % (
        request.get_host(), reverse('evernote_callback'))
    request_token = client.get_request_token(callbackUrl)

    # Save the request token information for later
    request.session['oauth_token'] = request_token['oauth_token']
    request.session['oauth_token_secret'] = request_token['oauth_token_secret']

    # Redirect the user to the Evernote authorization URL
    return redirect(client.get_authorize_url(request_token))


def callback(request):
    try:
        client = get_evernote_client()
        client.get_access_token(
            request.session['oauth_token'],
            request.session['oauth_token_secret'],
            request.GET.get('oauth_verifier', '')
        )
    except KeyError:
        return redirect('/')

    note_store = client.get_note_store()
    notebooks = note_store.listNotebooks()

    return render_to_response('oauth/callback.html', {'notebooks': notebooks})


def reset(request):
    return redirect('/')

########NEW FILE########
__FILENAME__ = views
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPFound, HTTPBadRequest
from evernote.api.client import EvernoteClient


def _get_evernote_client(request):
    session = request.session
    access_token = session.get('access_token')

    if access_token:
        return EvernoteClient(
            token=access_token,
            sandbox=True)
    else:
        settings = request.registry.settings
        consumer_key = settings.get('evernote.consumer_key')
        consumer_secret = settings.get('evernote.consumer_secret')

        return EvernoteClient(
            consumer_key=consumer_key,
            consumer_secret=consumer_secret,
            sandbox=True)


@view_config(route_name='home', renderer='home.mak')
def home(request):
    return {}


@view_config(route_name='evernote_auth')
def evernote_oauth(request):
    session = request.session
    session.invalidate()

    client = _get_evernote_client(request)
    request_token = client.get_request_token(
        request.route_url('evernote_callback'))
    session['oauth_token'] = request_token['oauth_token']
    session['oauth_token_secret'] = request_token['oauth_token_secret']

    authorized_url = client.get_authorize_url(request_token)

    return HTTPFound(authorized_url)


@view_config(route_name='evernote_callback', renderer='callback.mak')
def evernote_callback(request):
    client = _get_evernote_client(request)
    session = request.session

    oauth_verifier = request.params.get('oauth_verifier')
    oauth_token = session.get('oauth_token')
    oauth_token_secret = session.get('oauth_token_secret')

    if oauth_verifier and oauth_token and oauth_token_secret:
        access_token = client.get_access_token(
            oauth_token,
            oauth_token_secret,
            oauth_verifier)

        session['access_token'] = access_token

        return HTTPFound('notebooks')

    return HTTPBadRequest(
        'oauth_verifier, oauth_token or oauth_token_secret not found')


@view_config(route_name='notebooks', renderer='notebooks.mak')
def notebooks(request):
    client = _get_evernote_client(request)
    note_store = client.get_note_store()
    return {'notebooks': note_store.listNotebooks()}


@view_config(route_name='evernote_auth_reset')
def evernote_oauth_rest(request):
    request.session.invalidate()
    return HTTPFound(request.route_url('home'))

########NEW FILE########
