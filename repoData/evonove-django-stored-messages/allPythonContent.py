__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# complexity documentation build configuration file, created by
# sphinx-quickstart on Tue Jul  9 22:26:36 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

cwd = os.getcwd()
parent = os.path.dirname(cwd)
sys.path.append(parent)

# django setup
from django.conf import settings
settings.configure()

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-stored-messages'
copyright = u'2013, evonove'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0.1'
# The full version, including alpha/beta/rc tags.
release = '1.0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-stored-messagesdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-stored-messages.tex', u'django-stored-messages Documentation',
   u'evonove', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-stored-messages', u'django-stored-messages Documentation',
     [u'evonove'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-stored-messages', u'django-stored-messages Documentation',
   u'evonove', 'django-stored-messages', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False
########NEW FILE########
__FILENAME__ = runtests
import sys
from optparse import OptionParser

try:
    from django.conf import settings

    INSTALLED_APPS = [
        "django.contrib.auth",
        "django.contrib.contenttypes",
        "django.contrib.sites",
        "django.contrib.messages",
        "django.contrib.sessions",
        "stored_messages",
    ]

    try:
        import rest_framework
        INSTALLED_APPS.append("rest_framework")
    except ImportError:
        pass

    import imp
    imp.find_module('django_nose')

    settings.configure(
        DEBUG=True,
        USE_TZ=True,
        DATABASES={
            "default": {
                "ENGINE": "django.db.backends.sqlite3",
            }
        },
        ROOT_URLCONF="stored_messages.urls",
        INSTALLED_APPS=INSTALLED_APPS,
        SITE_ID=1,
        NOSE_ARGS=['-s'],
        MESSAGE_STORAGE='stored_messages.storage.PersistentStorage',
        STORED_MESSAGES={
            'REDIS_URL': 'redis://localhost:6379/0',
        },
        MOCK_REDIS_SERVER=True,
    )

    from django_nose import NoseTestSuiteRunner
except ImportError:
    raise ImportError("To fix this error, run: pip install -r requirements-test.txt")


def run_tests(*test_args):
    if not test_args:
        test_args = ['tests']

    # Run tests
    test_runner = NoseTestSuiteRunner(verbosity=1)

    failures = test_runner.run_tests(test_args)
    sys.exit(failures)

if __name__ == '__main__':
    parser = OptionParser()
    (options, args) = parser.parse_args()
    run_tests(*args)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from .models import Inbox, Message, MessageArchive


admin.site.register(Inbox)
admin.site.register(Message)
admin.site.register(MessageArchive)

########NEW FILE########
__FILENAME__ = api

__all__ = (
    'add_message_for', 'broadcast_message',
    'mark_read', 'mark_all_read',
)

from stored_messages.compat import get_user_model
from .settings import stored_messages_settings
BackendClass = stored_messages_settings.STORAGE_BACKEND
backend = BackendClass()


def add_message_for(users, level, message_text, extra_tags='', fail_silently=False):
    """
    Send a message to a list of users without passing through `django.contrib.messages`

    :param users: an iterable containing the recipients of the messages
    :param level: message level
    :param message_text: the string containing the message
    :param extra_tags: like the Django api, a string containing extra tags for the message
    :param fail_silently: not used at the moment
    """
    m = backend.create_message(level, message_text, extra_tags)
    backend.archive_store(users, m)
    backend.inbox_store(users, m)


def broadcast_message(level, message_text, extra_tags='', fail_silently=False):
    """
    Send a message to all users aka broadcast.

    :param level: message level
    :param message_text: the string containing the message
    :param extra_tags: like the Django api, a string containing extra tags for the message
    :param fail_silently: not used at the moment
    """
    users = get_user_model().objects.all()
    add_message_for(users, level, message_text, extra_tags=extra_tags, fail_silently=fail_silently)


def mark_read(user, message):
    """
    Mark message instance as read for user.
    Returns True if the message was `unread` and thus actually marked as `read` or False in case
    it is already `read` or it does not exist at all.

    :param user: user instance for the recipient
    :param message: a Message instance to mark as read
    """
    backend.inbox_delete(user, message)


def mark_all_read(user):
    """
    Mark all message instances for a user as read.

    :param user: user instance for the recipient
    """
    backend.inbox_purge(user)

########NEW FILE########
__FILENAME__ = base

class StoredMessagesBackend(object):
    """

    """
    def create_message(self, level, msg_text, extra_tags):
        """
        Create and return a `Message` instance.
        Instance types depend on backends implementation.

        Params:
            `level`: message level (see django.contrib.messages)
            `msg_text`: what you think it is
            `extra_tags`: see django.contrib.messages

        Return:
            `Message` instance
        """
        raise NotImplementedError()

    def inbox_list(self, user):
        """
        Retrieve all the messages in `user`'s Inbox.

        Params:
            `user`: Django User instance

        Return:
            An iterable containing `Message` instances
        """
        raise NotImplementedError()

    def inbox_purge(self, user):
        """
        Delete all the messages in `user`'s Inbox.

        Params:
            user: Django User instance

        Return:
            None
        """
        raise NotImplementedError()

    def inbox_store(self, users, msg_instance):
        """
        Store a `Message` instance in the inbox for a list
        of users.

        Params:
            users: a list or iterable containing Django User instances
            msg_instance: Message instance to persist in inbox

        Return:
            None

        Raise:
            MessageTypeNotSupported if `msg_instance` cannot be managed by current backend
        """
        raise NotImplementedError()

    def inbox_delete(self, user, msg_id):
        """
        Remove a `Message` instance from `user`'s inbox.

        Params:
            user: Django User instance
            msg_id: Message identifier

        Return:
            None

        Raise:
            MessageDoesNotExist if msg_id was not found
        """
        raise NotImplementedError()

    def inbox_get(self, user, msg_id):
        """
        Retrieve a `Message` instance from `user`'s inbox.

        Params:
            user: Django User instance
            msg_id: Message identifier

        Return:
            A `Message` instance

        Raise:
            MessageDoesNotExist if msg_id was not found
        """

    def archive_store(self, users, msg_instance):
        """
        Store a `Message` instance in the archive for a list
        of users.

        Params:
            users: a list or iterable containing Django User instances
            msg_instance: Message instance to persist in archive

        Return:
            None

        Raise:
            MessageTypeNotSupported if `msg_instance` cannot be managed by current backend
        """
        raise NotImplementedError()

    def archive_list(self, user):
        """
        Retrieve all the messages in `user`'s archive.

        Params:
            user: Django User instance

        Return:
            An iterable containing `Message` instances
        """
        raise NotImplementedError()

    def can_handle(self, msg_instance):
        """
        Determine if this backend can handle messages
        of the same type of `msg_instance`.

        Params:
            `msg_instance`: `Message` instance

        Return:
            True if type is correct, False otherwise
        """
        raise NotImplementedError()

    def _flush(self):
        """
        Clear all backend data.
        Warning: heavily destructive! Here for convenience, not used by the API anyway.

        Params:
            None

        Return:
            None
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = backend
from ..base import StoredMessagesBackend
from ..exceptions import MessageTypeNotSupported, MessageDoesNotExist
from ...models import Inbox, Message, MessageArchive


class DefaultBackend(StoredMessagesBackend):
    """

    """
    def inbox_list(self, user):
        if user.is_anonymous():
            return Inbox.objects.none()
        inbox = Inbox.objects.filter(user=user).select_related("message")
        return [m.message for m in inbox]

    def inbox_purge(self, user):
        if user.is_authenticated():
            Inbox.objects.filter(user=user).delete()

    def inbox_store(self, users, msg_instance):
        if not self.can_handle(msg_instance):
            raise MessageTypeNotSupported()

        for user in users:
            Inbox.objects.get_or_create(user=user, message=msg_instance)

    def inbox_delete(self, user, msg_id):
        try:
            inbox_m = Inbox.objects.filter(user=user, message=msg_id).get()
            inbox_m.delete()
        except Inbox.DoesNotExist:
            raise MessageDoesNotExist("Message with id %s does not exist" % msg_id)

    def inbox_get(self, user, msg_id):
        try:
            return Inbox.objects.get(pk=msg_id).message
        except Inbox.DoesNotExist:
            raise MessageDoesNotExist("Message with id %s does not exist" % msg_id)

    def create_message(self, level, msg_text, extra_tags=''):
        m_instance = Message.objects.create(message=msg_text, level=level, tags=extra_tags)
        return m_instance

    def archive_store(self, users, msg_instance):
        if not self.can_handle(msg_instance):
            raise MessageTypeNotSupported()

        for user in users:
            MessageArchive.objects.create(user=user, message=msg_instance)

    def archive_list(self, user):
        return list(MessageArchive.objects.filter(user=user))

    def can_handle(self, message):
        return isinstance(message, Message)

    def _flush(self):
        Inbox.objects.all().delete()
        MessageArchive.objects.all().delete()
        Message.objects.all().delete()

########NEW FILE########
__FILENAME__ = exceptions


class MessageTypeNotSupported(Exception):
    pass


class MessageDoesNotExist(Exception):
    pass

########NEW FILE########
__FILENAME__ = backend
from __future__ import unicode_literals

from django.utils import timezone
from django.utils.encoding import force_text
from django.core.serializers.json import DjangoJSONEncoder

import json
from collections import namedtuple
import hashlib

from ..exceptions import MessageTypeNotSupported, MessageDoesNotExist
from ..base import StoredMessagesBackend
from ...settings import stored_messages_settings

try:
    # Let django project bootstrap anyway when not using this backend
    import redis
except ImportError:
    pass


Message = namedtuple('Message', ['id', 'message', 'level', 'tags', 'date'])


class RedisBackend(StoredMessagesBackend):
    """

    """
    def __init__(self):
        self.client = redis.StrictRedis.from_url(stored_messages_settings.REDIS_URL)

    def _flush(self):
        self.client.flushdb()

    def _toJSON(self, msg_instance):
        """
        Dump a Message instance into a JSON string
        """
        return json.dumps(msg_instance._asdict(), cls=DjangoJSONEncoder)

    def _fromJSON(self, json_msg):
        """
        Return a Message instance built from data contained in a JSON string
        """
        return Message(**json.loads(force_text(json_msg)))

    def _store(self, key_tpl, users, msg_instance):
        """
        boilerplate
        """
        if not self.can_handle(msg_instance):
            raise MessageTypeNotSupported()

        for user in users:
            self.client.rpush(key_tpl % user.pk, self._toJSON(msg_instance))

    def _list(self, key_tpl, user):
        """
        boilerplate
        """
        ret = []
        for msg_json in self.client.lrange(key_tpl % user.pk, 0, -1):
            ret.append(self._fromJSON(msg_json))
        return ret

    def create_message(self, level, msg_text, extra_tags=''):
        """
        Message instances are namedtuples of type `Message`.
        The date field is already serialized in datetime.isoformat ECMA-262 format
        """
        now = timezone.now()
        r = now.isoformat()
        if now.microsecond:
            r = r[:23] + r[26:]
        if r.endswith('+00:00'):
            r = r[:-6] + 'Z'

        fingerprint = r + msg_text

        msg_id = hashlib.sha256(fingerprint.encode('ascii', 'ignore')).hexdigest()
        return Message(id=msg_id, message=msg_text, level=level, tags=extra_tags, date=r)

    def inbox_list(self, user):
        if user.is_anonymous():
            return []
        return self._list('user:%d:notifications', user)

    def inbox_purge(self, user):
        if user.is_authenticated():
            self.client.delete('user:%d:notifications' % user.pk)

    def inbox_store(self, users, msg_instance):
        self._store('user:%d:notifications', users, msg_instance)

    def inbox_delete(self, user, msg_id):
        for m in self._list('user:%d:notifications', user):
            if m.id == msg_id:
                return self.client.lrem('user:%d:notifications' % user.pk, 0, json.dumps(m._asdict()))
        raise MessageDoesNotExist("Message with id %s does not exist" % msg_id)

    def inbox_get(self, user, msg_id):
        for m in self._list('user:%d:notifications', user):
            if m.id == msg_id:
                return m
        raise MessageDoesNotExist("Message with id %s does not exist" % msg_id)

    def archive_store(self, users, msg_instance):
        self._store('user:%d:archive', users, msg_instance)

    def archive_list(self, user):
        return self._list('user:%d:archive', user)

    def can_handle(self, msg_instance):
        return isinstance(msg_instance, Message)

########NEW FILE########
__FILENAME__ = compat
"""
The `compat` module provides support for backwards compatibility with older
versions of django and python..
"""

from __future__ import unicode_literals

import django
from django.conf import settings

# Django 1.5 add support for custom auth user model
if django.VERSION >= (1, 5):
    AUTH_USER_MODEL = settings.AUTH_USER_MODEL
else:
    AUTH_USER_MODEL = 'auth.User'

try:
    from django.contrib.auth import get_user_model
except ImportError:
    from django.contrib.auth.models import User
    get_user_model = lambda: User

########NEW FILE########
__FILENAME__ = constants
from django.contrib.messages.constants import *

STORED_DEBUG = DEBUG+1
STORED_INFO = INFO+1
STORED_SUCCESS = SUCCESS+1
STORED_WARNING = WARNING+1
STORED_ERROR = ERROR+1

DEFAULT_TAGS.update({
    STORED_DEBUG: 'persisted debug',
    STORED_INFO: 'persisted info',
    STORED_SUCCESS: 'persisted success',
    STORED_WARNING: 'persisted warning',
    STORED_ERROR: 'persisted error',
})

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals

from django.db import models
from django.utils import timezone
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _

from .compat import AUTH_USER_MODEL
from .settings import stored_messages_settings


@python_2_unicode_compatible
class Message(models.Model):
    """
    This model represents a message on the database. Fields are the same as in
    `contrib.messages`
    """
    message = models.TextField()
    level = models.IntegerField()
    tags = models.TextField()
    date = models.DateTimeField(default=timezone.now)

    def __str__(self):
        return self.message


@python_2_unicode_compatible
class MessageArchive(models.Model):
    """
    This model holds all the messages users received. Corresponding
    database table will grow indefinitely depending on messages traffic.
    """
    user = models.ForeignKey(AUTH_USER_MODEL)
    message = models.ForeignKey(Message)

    def __str__(self):
        return "[%s] %s" % (self.user, self.message)


@python_2_unicode_compatible
class Inbox(models.Model):
    """
    Inbox messages are stored in this model until users read them. Once read,
    inbox messages are deleted. Inbox messages have an expire time, after
    that they could be removed by a proper django command. We do not expect
    database table corresponding to this model to grow much.
    """
    user = models.ForeignKey(AUTH_USER_MODEL)
    message = models.ForeignKey(Message)

    class Meta:
        verbose_name_plural = _('inboxes')

    def expired(self):
        expiration_date = self.message.date + timezone.timedelta(
            days=stored_messages_settings.INBOX_EXPIRE_DAYS)
        return expiration_date <= timezone.now()
    expired.boolean = True  # show a nifty icon in the admin

    def __str__(self):
        return "[%s] %s" % (self.user, self.message)

########NEW FILE########
__FILENAME__ = serializers
from rest_framework import serializers


class InboxSerializer(serializers.Serializer):
    id = serializers.CharField()
    message = serializers.CharField()
    level = serializers.IntegerField()
    date = serializers.DateTimeField()

########NEW FILE########
__FILENAME__ = settings
"""
This module is largely inspired by django-rest-framework settings.

Settings for the Stored Messages framework are all namespaced in the
STORED_MESSAGES setting.
For example your project's `settings.py` file might look like this::

    STORED_MESSAGES = {
        'INBOX_EXPIRE_DAYS': 30,
    }

This module provides the `stored_messages_settings` object, that is used to
access Stored Messages framework settings, checking for user settings first,
then falling back to the defaults.
"""
from __future__ import unicode_literals

from django.conf import settings
from django.utils import six, importlib

from .constants import *

USER_SETTINGS = getattr(settings, 'STORED_MESSAGES', None)
MESSAGE_TAGS = getattr(settings, 'MESSAGE_TAGS', {})

DEFAULTS = {
    'STORE_LEVELS': (
        STORED_DEBUG,
        STORED_INFO,
        STORED_SUCCESS,
        STORED_WARNING,
        STORED_ERROR,
    ),
    'MESSAGE_TAGS': MESSAGE_TAGS.update({
        STORED_DEBUG: 'stored debug',
        STORED_INFO: 'stored info',
        STORED_SUCCESS: 'stored success',
        STORED_WARNING: 'stored warning',
        STORED_ERROR: 'stored error',
    }),
    'INBOX_EXPIRE_DAYS': 30,
    'STORAGE_BACKEND': 'stored_messages.backends.DefaultBackend',
    # Only for Redis backend
    'REDIS_URL': 'redis://username:password@localhost:6379/0',
}

# List of settings that cannot be empty
MANDATORY = (

)

# List of settings that may be in string import notation.
IMPORT_STRINGS = (
    'STORAGE_BACKEND',
)


def perform_import(val, setting_name):
    """
    If the given setting is a string import notation,
    then perform the necessary import or imports.
    """
    if isinstance(val, six.string_types):
        return import_from_string(val, setting_name)
    elif isinstance(val, (list, tuple)):
        return [import_from_string(item, setting_name) for item in val]
    return val


def import_from_string(val, setting_name):
    """
    Attempt to import a class from a string representation.
    """
    try:
        parts = val.split('.')
        module_path, class_name = '.'.join(parts[:-1]), parts[-1]
        module = importlib.import_module(module_path)
        return getattr(module, class_name)
    except ImportError as e:
        msg = "Could not import '%s' for setting '%s'. %s: %s." % (val, setting_name,
                                                                   e.__class__.__name__, e)
        raise ImportError(msg)


class StoredMessagesSettings(object):
    """
    A settings object, that allows settings to be accessed as properties.

    Any setting with string import paths will be automatically resolved
    and return the class, rather than the string literal.
    """

    def __init__(self, user_settings=None, defaults=None, import_strings=None, mandatory=None):
        self.user_settings = user_settings or {}
        self.defaults = defaults or {}
        self.import_strings = import_strings or ()
        self.mandatory = mandatory or ()

    def __getattr__(self, attr):
        if attr not in self.defaults.keys():
            raise AttributeError("Invalid Stored Messages setting: '%s'" % attr)

        try:
            # Check if present in user settings
            val = self.user_settings[attr]
        except KeyError:
            # Fall back to defaults
            val = self.defaults[attr]

        # Coerce import strings into classes
        if val and attr in self.import_strings:
            val = perform_import(val, attr)

        self.validate_setting(attr, val)

        # Cache the result
        setattr(self, attr, val)
        return val

    def validate_setting(self, attr, val):
        if not val and attr in self.mandatory:
            raise AttributeError("Stored Messages setting: '%s' is mandatory" % attr)


stored_messages_settings = StoredMessagesSettings(USER_SETTINGS, DEFAULTS, IMPORT_STRINGS,
                                                  MANDATORY)

########NEW FILE########
__FILENAME__ = storage
from django.contrib.messages.storage.fallback import FallbackStorage

from .settings import stored_messages_settings
from .backends.exceptions import MessageTypeNotSupported

BackendClass = stored_messages_settings.STORAGE_BACKEND


class StorageMixin(object):
    """
    This mixin implements a message storage compliant with
    `django.contrib.messages` which stores messages on the database when
    needed, delegating to the sibling class otherwise. Messages are stored
    only when the user is authenticated and the message level is configured
    for being persisted. The mixin can be derived together with another class
    implementing a storage, tipically one of the three provided by Django out
    of the box.
    """
    def __init__(self, request, *args, **kwargs):
        self.user = request.user
        self.backend = BackendClass()
        super(StorageMixin, self).__init__(request, *args, **kwargs)

    def _get(self, *args, **kwargs):
        """
        Retrieve unread messages for current user, both from the inbox and
        from other storages
        """
        messages, all_retrieved = super(StorageMixin, self)._get(*args, **kwargs)
        if self.user.is_authenticated():
            inbox_messages = self.backend.inbox_list(self.user)
        else:
            inbox_messages = []
        return messages + [im.message for im in inbox_messages], all_retrieved

    def add(self, level, message, extra_tags=''):
        """
        If the message level was configured for being stored and request.user
        is not anonymous, save it to the database. Otherwise, let some other
        class handle the message.

        Notice: controls like checking the message is not empty and the level
        is above the filter need to be performed here, but it could happen
        they'll be performed again later if the message does not need to be
        stored.
        """
        if not message:
            return
        # Check that the message level is not less than the recording level.
        level = int(level)
        if level < self.level:
            return
        # Check if the message doesn't have a level that needs to be persisted
        if level not in stored_messages_settings.STORE_LEVELS or self.user.is_anonymous():
            return super(StorageMixin, self).add(level, message, extra_tags)

        self.added_new = True
        m = self.backend.create_message(level, message, extra_tags)
        self.backend.archive_store([self.user], m)
        self._queued_messages.append(m)

    def _store(self, messages, response, *args, **kwargs):
        """
        persistent messages are already in the database inside the 'archive',
        so we can say they're already "stored".
        Here we put them in the inbox, or remove from the inbox in case the
        messages were iterated.

        messages contains only new msgs if self.used==True
        else contains both new and unread messages
        """
        contrib_messages = []
        if self.user.is_authenticated():
            if not messages:
                # erase inbox
                self.backend.inbox_purge(self.user)
            else:
                for m in messages:
                    try:
                        self.backend.inbox_store([self.user], m)
                    except MessageTypeNotSupported:
                        contrib_messages.append(m)

        super(StorageMixin, self)._store(contrib_messages, response, *args, **kwargs)

    def _prepare_messages(self, messages):
        """
        Like the base class method, prepares a list of messages for storage
        but avoid to do this for `models.Message` instances.
        """
        for message in messages:
            if not self.backend.can_handle(message):
                message._prepare()


class PersistentStorage(StorageMixin, FallbackStorage):
    """
    This class is provided for convenience: it implements `StorageMixin` which
    persists messages having a type configured to be persisted and passes
    other messages to `FallbackStorage`, one of the defaults provided by
    Django which stores messages inside cookies or sessions.
    """
    pass

########NEW FILE########
__FILENAME__ = stored_messages_tags
from __future__ import unicode_literals

from django import template

from ..models import Inbox, MessageArchive


register = template.Library()


@register.inclusion_tag("stored_messages/stored_messages_list.html", takes_context=True)
def stored_messages_list(context, num_elements=10):
    """
    Renders a list of unread stored messages for the current user
    """
    if "user" in context:
        user = context["user"]
        if user.is_authenticated():
            qs = Inbox.objects.select_related("message").filter(user=user)
            return {
                "messages": qs[:num_elements],
                "count": qs.count(),
            }


@register.assignment_tag(takes_context=True)
def stored_messages_count(context):
    """
    Renders a list of unread stored messages for the current user
    """
    if "user" in context:
        user = context["user"]
        if user.is_authenticated():
            return Inbox.objects.select_related("message").filter(user=user).count()


@register.inclusion_tag("stored_messages/stored_messages_list.html", takes_context=True)
def stored_messages_archive(context, num_elements=10):
    """
    Renders a list of archived messages for the current user
    """
    if "user" in context:
        user = context["user"]
        if user.is_authenticated():
            qs = MessageArchive.objects.select_related("message").filter(user=user)
            return {
                "messages": qs[:num_elements],
                "count": qs.count(),
            }

########NEW FILE########
__FILENAME__ = urls
"""
At the moment this module does something only when restframework is available
"""
from django.conf import settings

if 'rest_framework' in settings.INSTALLED_APPS:
    from rest_framework.routers import DefaultRouter
    from django.conf.urls import patterns, url, include
    from . import views

    router = DefaultRouter()
    router.register(r'inbox', views.InboxViewSet, base_name='inbox')

    urlpatterns = patterns(
        '',
        url(r'^', include(router.urls)),
        url(r'^mark_all_read/$', views.mark_all_read, name='mark_all_read'),
    )

########NEW FILE########
__FILENAME__ = views
from rest_framework import viewsets
from rest_framework.decorators import action, api_view
from rest_framework.response import Response

from django.contrib.auth.decorators import login_required

from .serializers import InboxSerializer
from .backends.exceptions import MessageDoesNotExist



class InboxViewSet(viewsets.ViewSet):
    """
    Provides `list` and `detail` actions, plus a `read` POST endpoint for
    marking inbox messages as read.
    """
    def list(self, request):
        from .settings import stored_messages_settings
        backend = stored_messages_settings.STORAGE_BACKEND()
        messages = backend.inbox_list(request.user)
        serializer = InboxSerializer(messages, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        from .settings import stored_messages_settings
        backend = stored_messages_settings.STORAGE_BACKEND()

        try:
            msg = backend.inbox_get(request.user, pk)
        except MessageDoesNotExist as e:
            return Response(e.message, status='404')

        serializer = InboxSerializer(msg, many=False)
        return Response(serializer.data)

    @action()
    def read(self, request, pk=None):
        """
        Mark the message as read (i.e. delete from inbox)
        """
        from .settings import stored_messages_settings
        backend = stored_messages_settings.STORAGE_BACKEND()

        try:
            backend.inbox_delete(request.user, pk)
        except MessageDoesNotExist as e:
            return Response(e.message, status='404')

        return Response({'status': 'message marked as read'})


@login_required
@api_view(['POST'])
def mark_all_read(request):
    """
    Mark all messages as read (i.e. delete from inbox) for current logged in user
    """
    from .settings import stored_messages_settings
    backend = stored_messages_settings.STORAGE_BACKEND()
    backend.inbox_purge(request.user)
    return Response({"message": "All messages read"})

########NEW FILE########
__FILENAME__ = test_api
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from . import BaseTest

from stored_messages import mark_read, add_message_for, broadcast_message, mark_all_read
from stored_messages.models import Inbox, MessageArchive
from stored_messages.compat import get_user_model
from stored_messages.backends.exceptions import MessageDoesNotExist
import stored_messages


class TestApi(BaseTest):
    def test_mark_as_read(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        inbox = Inbox.objects.filter(user=self.user)
        self.assertEqual(len(inbox), 1)
        mark_read(self.user, inbox.get().message)
        self.assertEqual(Inbox.objects.filter(user=self.user).count(), 0)

    def test_mark_as_read_idempotent(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        msg = MessageArchive.objects.filter(user=self.user).get()
        mark_read(self.user, msg)
        self.assertRaises(MessageDoesNotExist, mark_read, self.user, msg)

    def test_add_message_for(self):
        user2 = get_user_model().objects.create_user("another_user", "u@user.com", "123456")
        add_message_for([user2, self.user], stored_messages.STORED_ERROR, 'Multiple errors')
        self.assertEqual(Inbox.objects.count(), 2)
        self.assertEqual(MessageArchive.objects.count(), 2)

        self.assertEqual(Inbox.objects.get(user=user2.id).message.message, "Multiple errors")
        self.assertEqual(Inbox.objects.get(user=self.user).message.message, "Multiple errors")

        self.assertEqual(MessageArchive.objects.get(user=user2.id).message.message,
                         "Multiple errors")
        self.assertEqual(MessageArchive.objects.get(user=self.user).message.message,
                         "Multiple errors")

    def test_broadcast_message(self):
        user1 = get_user_model().objects.create_user("user1", "u1@user.com", "123456")
        user2 = get_user_model().objects.create_user("user2", "u2@user.com", "123456")
        user3 = get_user_model().objects.create_user("user3", "u3@user.com", "123456")

        broadcast_message( stored_messages.STORED_INFO, 'broadcast test message')
        self.assertEqual(Inbox.objects.get(user=user1.id).message.message, "broadcast test message")
        self.assertEqual(Inbox.objects.get(user=user2.id).message.message, "broadcast test message")
        self.assertEqual(Inbox.objects.get(user=user3.id).message.message, "broadcast test message")

        self.assertEqual(MessageArchive.objects.get(user=user1.id).message.message,
                         "broadcast test message")
        self.assertEqual(MessageArchive.objects.get(user=user2.id).message.message,
                         "broadcast test message")
        self.assertEqual(MessageArchive.objects.get(user=user3.id).message.message,
                         "broadcast test message")

    def test_mark_all_read(self):
        for i in range(20):
            stored_messages.add_message_for([self.user], stored_messages.INFO, "unicode message ❤")
        inbox = Inbox.objects.filter(user=self.user)
        self.assertEqual(len(inbox), 20)
        mark_all_read(self.user)
        self.assertEqual(Inbox.objects.filter(user=self.user).count(), 0)

########NEW FILE########
__FILENAME__ = test_default_backend
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from . import BaseTest

from django.contrib.auth.models import AnonymousUser

from stored_messages.backends.exceptions import MessageTypeNotSupported, MessageDoesNotExist
from stored_messages.backends.default import DefaultBackend
from stored_messages.models import Message, Inbox, MessageArchive
from stored_messages import STORED_ERROR


class TestDefaultBackend(BaseTest):
    def setUp(self):
        super(TestDefaultBackend, self).setUp()
        self.backend = DefaultBackend()
        self.message = self.backend.create_message(STORED_ERROR, 'A message for you ♡')
        self.anon = AnonymousUser()

    def test_inbox_store(self):
        self.backend.inbox_store([self.user], self.message)
        m = Inbox.objects.filter(user=self.user).get()
        self.assertEqual(m.message, self.message)
        self.assertRaises(MessageTypeNotSupported, self.backend.inbox_store, [], {})

    def test_inbox_list(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you ♡♡♡')
        self.backend.inbox_store([self.user], message)
        self.backend.inbox_store([self.user], self.message)
        messages = self.backend.inbox_list(self.user)
        self.assertEqual(messages[0], message)
        self.assertEqual(messages[1], self.message)
        self.assertEqual(len(self.backend.inbox_list(self.anon)), 0)

    def test_inbox_purge(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.backend.inbox_store([self.user], self.message)
        self.backend.inbox_store([self.user], message)
        self.backend.inbox_purge(self.user)
        self.assertEqual(len(self.backend.inbox_list(self.user)), 0)
        self.backend.inbox_purge(self.anon)

    def test_inbox_delete(self):
        self.backend.inbox_store([self.user], self.message)
        self.backend.inbox_delete(self.user, self.message.id)
        self.assertEqual(len(self.backend.inbox_list(self.user)), 0)
        self.assertRaises(MessageDoesNotExist, self.backend.inbox_delete, self.user, -1)

    def test_archive_store(self):
        self.backend.archive_store([self.user], self.message)
        m = MessageArchive.objects.filter(user=self.user).all()[0]
        self.assertEqual(m.message, self.message)
        self.assertRaises(MessageTypeNotSupported, self.backend.archive_store, [], {})

    def test_archive_list(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.backend.archive_store([self.user], message)
        self.backend.archive_store([self.user], self.message)
        messages = self.backend.archive_list(self.user)
        self.assertEqual(messages[0].message, message)
        self.assertEqual(messages[1].message, self.message)

    def test_create_message(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.assertIsInstance(message, Message)

    def test_inbox_get(self):
        self.backend.inbox_store([self.user], self.message)
        m = self.backend.inbox_get(self.user, self.message.id)
        self.assertEqual(m, self.message)
        self.assertRaises(MessageDoesNotExist, self.backend.inbox_get, self.user, -1)

    def test_can_handle(self):
        self.assertFalse(self.backend.can_handle({}))
        self.assertTrue(self.backend.can_handle(self.message))

########NEW FILE########
__FILENAME__ = test_models
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from . import BaseTest

from django.utils.timezone import timedelta, now
from django.contrib.messages.storage import default_storage

from stored_messages import add_message, STORED_ERROR
from stored_messages.models import MessageArchive, Inbox


class TestInbox(BaseTest):
    def test_expire(self):
        self.request._messages = default_storage(self.request)
        add_message(self.request, STORED_ERROR, "an SOS to the world ☢")
        ma = MessageArchive.objects.all()[0]
        ma.message.date = now() - timedelta(days=365)
        ma.message.save()
        inbox = Inbox.objects.create(user=ma.user, message=ma.message)
        self.assertTrue(inbox.expired())

########NEW FILE########
__FILENAME__ = test_redis_backend
from . import BaseTest

import unittest
import mock

from django.conf import settings
from django.core.cache import cache
from django.contrib.auth.models import AnonymousUser

from stored_messages.backends.exceptions import MessageTypeNotSupported, MessageDoesNotExist
from stored_messages.backends.redis import RedisBackend
from stored_messages.backends.redis.backend import Message

from stored_messages import STORED_ERROR


class RedisMock(object):
    """
    Mock the Redis server instance with Django in-memory cache
    """
    def rpush(self, key, data):
        l = cache.get(key)
        if l is None:
            l = []
        l.append(data)
        cache.set(key, l)

    def lrange(self, key, *args, **kwargs):
        return cache.get(key) or []

    def delete(self, key):
        cache.delete(key)

    def lrem(self, key, count, data):
        l = cache.get(key)
        l.remove(data)
        cache.set(key, l)

    def flushdb(self):
        cache.clear()

    @staticmethod
    def from_url(*args, **kwargs):
        return RedisMock()

    def StrictRedis(self, *args, **kwargs):
        return self


try:
    from stored_messages.backends.redis.backend import redis
    REDISPY_MISSING = False

    if getattr(settings, 'MOCK_REDIS_SERVER', True):
        patcher = mock.patch('stored_messages.backends.redis.backend.redis')
        redis = patcher.start()
        redis.StrictRedis = RedisMock

except ImportError:
    REDISPY_MISSING = True


@unittest.skipIf(REDISPY_MISSING, "redis-py not installed")
class TestRedisBackend(BaseTest):
    def setUp(self):
        super(TestRedisBackend, self).setUp()
        self.client = redis.StrictRedis.from_url(settings.STORED_MESSAGES['REDIS_URL'])
        self.backend = RedisBackend()
        self.backend._flush()
        self.message = self.backend.create_message(STORED_ERROR, 'A message for you')
        self.anon = AnonymousUser()

    def test_inbox_store(self):
        self.backend.inbox_store([self.user], self.message)
        data = self.client.lrange('user:%d:notifications' % self.user.pk, 0, -1).pop()
        self.assertEqual(self.backend._fromJSON(data), self.message)
        self.assertRaises(MessageTypeNotSupported, self.backend.inbox_store, [], {})

    def test_inbox_list(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.backend.inbox_store([self.user], message)
        self.backend.inbox_store([self.user], self.message)
        messages = self.backend.inbox_list(self.user)
        self.assertEqual(messages[0], message)
        self.assertEqual(messages[1], self.message)
        self.assertEqual(self.backend.inbox_list(self.anon), [])

    def test_inbox_purge(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.backend.inbox_store([self.user], self.message)
        self.backend.inbox_store([self.user], message)
        self.backend.inbox_purge(self.user)
        self.assertEqual(len(self.backend.inbox_list(self.user)), 0)
        self.backend.inbox_purge(self.anon)

    def test_inbox_delete(self):
        self.backend.inbox_store([self.user], self.message)
        self.backend.inbox_delete(self.user, self.message.id)
        self.assertEqual(len(self.backend.inbox_list(self.user)), 0)
        self.assertRaises(MessageDoesNotExist, self.backend.inbox_delete, self.user, -1)

    def test_archive_store(self):
        self.backend.archive_store([self.user], self.message)
        data = self.client.lrange('user:%d:archive' % self.user.pk, 0, -1).pop()
        self.assertEqual(self.backend._fromJSON(data), self.message)
        self.assertRaises(MessageTypeNotSupported, self.backend.archive_store, [], {})

    def test_archive_list(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.backend.archive_store([self.user], message)
        self.backend.archive_store([self.user], self.message)
        messages = self.backend.archive_list(self.user)
        self.assertEqual(messages[0], message)
        self.assertEqual(messages[1], self.message)

    def test_create_message(self):
        message = self.backend.create_message(STORED_ERROR, 'Another message for you')
        self.assertIsInstance(message, Message)

    def test_inbox_get(self):
        self.backend.inbox_store([self.user], self.message)
        m = self.backend.inbox_get(self.user, self.message.id)
        self.assertEqual(m, self.message)
        self.assertRaises(MessageDoesNotExist, self.backend.inbox_get, self.user, -1)

    def test_can_handle(self):
        self.assertFalse(self.backend.can_handle({}))
        self.assertTrue(self.backend.can_handle(self.message))

########NEW FILE########
__FILENAME__ = test_restapi
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from . import BackendBaseTest

from django.core.urlresolvers import reverse
from django.test.utils import override_settings
from unittest import skipUnless

import json

from stored_messages.constants import STORED_ERROR

try:
    import rest_framework
    rest_framework_installed = True
except ImportError:
    rest_framework_installed = False


@skipUnless(rest_framework_installed, "Django restframework is not installed")
class TestRESTApi(BackendBaseTest):
    def test_list(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        self.client.get('/create')
        r = self.client.get(reverse('stored_messages:inbox-list'))
        messages = json.loads(r.content.decode('utf-8'))
        self.assertEqual(len(messages), 2)
        self.assertEqual(messages[0]['message'], 'an error ☢')
        self.assertEqual(messages[1]['message'], 'an error ☢')
        self.assertEqual(messages[0]['level'], STORED_ERROR)
        self.assertEqual(messages[1]['level'], STORED_ERROR)

    def test_retrieve(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        r = self.client.get(reverse('stored_messages:inbox-list'))
        messages = json.loads(r.content.decode('utf-8'))
        id = messages[0]['id']

        r = self.client.get(reverse('stored_messages:inbox-detail', kwargs={'pk':id}))

        message = json.loads(r.content.decode('utf-8'))
        self.assertEqual(message['message'], 'an error ☢')
        self.assertEqual(message['id'], id)

    def test_make_read(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        r = self.client.get(reverse('stored_messages:inbox-list'))
        messages = json.loads(r.content.decode('utf-8'))
        self.assertEqual(len(messages), 1)
        msg_id = messages[0]['id']
        r = self.client.post(reverse('stored_messages:inbox-read', args=(msg_id,)))
        self.assertEqual(r.status_code, 200)
        r = self.client.get(reverse('stored_messages:inbox-list'))
        messages = json.loads(r.content.decode('utf-8'))
        self.assertEqual(len(messages), 0)

    def test_anon(self):
        self.client.get('/create')
        r = self.client.get(reverse('stored_messages:inbox-list'))
        messages = json.loads(r.content.decode('utf-8'))
        self.assertEqual(len(messages), 0)

    def test_mark_all_read(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        r = self.client.post(reverse('stored_messages:mark_all_read'))
        self.assertEqual(r.status_code, 200)
        r = self.client.get(reverse('stored_messages:inbox-list'))
        messages = json.loads(r.content.decode('utf-8'))
        self.assertEqual(len(messages), 0)


@skipUnless(rest_framework_installed, "Django restframework is not installed")
@override_settings(STORED_MESSAGES={'STORAGE_BACKEND': 'stored_messages.backends.RedisBackend'})
class TestRESTApiWithRedis(TestRESTApi):
    pass

########NEW FILE########
__FILENAME__ = test_storage
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from . import BackendBaseTest

from django.contrib.messages.storage import default_storage
from django.test.utils import override_settings

from stored_messages import add_message, get_messages, STORED_ERROR, DEBUG, ERROR

import mock


class TestStorage(BackendBaseTest):
    """
    Test Storage class using default backend
    """
    def test_store(self):
        self.request._messages = default_storage(self.request)
        self.request._messages.level = DEBUG
        add_message(self.request, STORED_ERROR, "an SOS to the world ☢")
        add_message(self.request, DEBUG, "this won't be persisted ☢")
        self.assertEqual(len(get_messages(self.request)), 2)
        self.assertEqual(len(self.backend.archive_list(self.user)), 1)

    def test_store_with_middleware(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        inbox_msg = len(self.backend.inbox_list(self.user))
        self.assertEqual(inbox_msg, 1)
        self.client.get('/consume')
        self.assertEqual(len(self.backend.inbox_list(self.user)), 0)
        self.assertEqual(len(self.backend.archive_list(self.user)), 1)

    def test_store_keep_unread(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create')
        self.client.get('/consume', data={'keep_storage': True})
        self.assertEqual(len(self.backend.inbox_list(self.user)), 1)
        self.assertEqual(len(self.backend.archive_list(self.user)), 1)

    def test_store_anonymous(self):
        self.request.user = mock.MagicMock(wraps=self.user)
        self.request.user.is_anonymous.return_value = True
        self.request.user.is_authenticated.return_value = False
        self.request._messages = default_storage(self.request)
        add_message(self.request, STORED_ERROR, "an SOS to the world ☢")
        add_message(self.request, ERROR, "this error won't be persisted ☢")
        storage = get_messages(self.request)
        self.assertEqual(len(storage), 2)

    def test_add_empty(self):
        self.request._messages = default_storage(self.request)
        add_message(self.request, DEBUG, '')
        self.assertEqual(len(get_messages(self.request)), 0)

    def test_add_mixed(self):
        self.client.login(username='test_user', password='123456')
        self.client.get('/create_mixed')
        self.client.get('/consume')
        self.assertEqual(len(self.backend.inbox_list(self.user)), 0)


@override_settings(STORED_MESSAGES={'STORAGE_BACKEND': 'stored_messages.backends.RedisBackend'})
class TestStorageWithRedis(TestStorage):
    """
    Test Storage class using Redis backend
    """
    pass
########NEW FILE########
__FILENAME__ = test_templatetags
# -*- coding: utf-8 -*-

from __future__ import unicode_literals

from django.template import RequestContext, Template

from . import BaseTest

import stored_messages


class TestStoredMessagesTags(BaseTest):
    def _create_messages(self):
        # create a message
        for i in range(20):
            stored_messages.add_message_for([self.user], stored_messages.INFO, "unicode message ❤")

    def test_stored_messages_list(self):
        self._create_messages()

        t = Template("{% load stored_messages_tags %}"
                     "{% stored_messages_list 15 %}")
        render = t.render(RequestContext(self.request))
        self.assertInHTML("<li>[test_user] unicode message ❤</li>", render, 15)

    def test_stored_messages_archive(self):
        self._create_messages()

        t = Template("{% load stored_messages_tags %}"
                     "{% stored_messages_archive 15 %}")
        render = t.render(RequestContext(self.request))
        self.assertInHTML("<li>[test_user] unicode message ❤</li>", render, 15)

    def test_stored_messages_count(self):
        self._create_messages()

        t = Template("{% load stored_messages_tags %}"
                     "{% stored_messages_count as count %}"
                     "<p>There are {{ count }} messages</p>")
        render = t.render(RequestContext(self.request))
        self.assertInHTML("<p>There are 20 messages</p>", render, 1)

    def test_stored_messages_list_empty_for_unauthenticated_user(self):
        stored_messages.add_message_for([self.user], stored_messages.INFO, "unicode message ❤")

        t = Template("{% load stored_messages_tags %}"
                     "{% stored_messages_list 15 %}")
        render = t.render(RequestContext(self.factory.get("/")))

        self.assertInHTML("<li>[test_user] unicode message ❤</li>", render, 0)

    def test_stored_messages_archive_empty_for_unauthenticated_user(self):
        stored_messages.add_message_for([self.user], stored_messages.INFO, "unicode message ❤")

        t = Template("{% load stored_messages_tags %}"
                     "{% stored_messages_archive 15 %}")
        render = t.render(RequestContext(self.factory.get("/")))

        self.assertInHTML("<li>[test_user] unicode message ❤</li>", render, 0)

    def assertInHTML(self, needle, haystack, count=None, msg_prefix=''):
        import django
        if django.VERSION < (1, 5):
            real_count = haystack.count(needle)
            return self.assertEqual(real_count, count)
        else:
            return super(TestStoredMessagesTags, self).assertInHTML(
                needle, haystack, count, msg_prefix)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url, include
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns(
    '',
    url(r'^consume$', 'tests.views.message_view'),
    url(r'^create$', 'tests.views.message_create'),
    url(r'^create_mixed$', 'tests.views.message_create_mixed'),
    url(r'^messages', include('stored_messages.urls', namespace='stored_messages'))
)

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from django.http import HttpResponse

import stored_messages


def message_view(request):
    keep_storage = request.GET.get('keep_storage', False)
    storage = stored_messages.get_messages(request)
    for message in storage:
        pass
    if keep_storage:
        storage.used = False
    return HttpResponse()


def message_create(request):
    stored_messages.add_message(request, stored_messages.STORED_ERROR, "an error ☢")
    stored_messages.add_message(request, stored_messages.STORED_DEBUG, "a debug message ☢")
    return HttpResponse()


def message_create_mixed(request):
    stored_messages.add_message(request, stored_messages.STORED_ERROR, "an error ☢")
    stored_messages.add_message(request, stored_messages.ERROR, "an error not persisted ☢")
    return HttpResponse()

########NEW FILE########
