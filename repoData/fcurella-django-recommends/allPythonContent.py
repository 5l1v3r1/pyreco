__FILENAME__ = conf
from __future__ import unicode_literals
# -*- coding: utf-8 -*-
#
# django-recommends documentation build configuration file, created by
# sphinx-quickstart on Mon Nov 21 12:16:20 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.dirname(os.path.abspath('.')))
sys.path.insert(
    0,
    os.path.join(os.path.dirname(os.path.abspath('.')),
                 'example_project'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'example_project.settings'

# -- General configuration -----------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'django-recommends'
copyright = '2011, Flavio Curella'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
from recommends import VERSION

version = '.'.join([str(n) for n in VERSION[:2]])
# The full version, including alpha/beta/rc tags.
release = '.'.join([str(n) for n in VERSION])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-recommendsdoc'


# -- Options for LaTeX output --------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'django-recommends.tex', 'django-recommends Documentation',
     'Flavio Curella', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True


# -- Options for manual page output --------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-recommends', u'django-recommends Documentation',
     ['Flavio Curella'], 1)
]

# If true, show URL addresses after external links.
# man_show_urls = False


# -- Options for Texinfo output ------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'django-recommends', 'django-recommends Documentation',
     'Flavio Curella', 'django-recommends', 'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
# texinfo_appendices = []

# If false, no module index is generated.
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------

# Bibliographic Dublin Core info.
epub_title = 'django-recommends'
epub_author = 'Flavio Curella'
epub_publisher = 'Flavio Curella'
epub_copyright = '2011, Flavio Curella'

# The language of the text. It defaults to the language option
# or en if the language is not set.
# epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
# epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
# epub_identifier = ''

# A unique identification for the text.
# epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
# epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
# epub_post_files = []

# A list of files that should not be packed into the epub file.
# epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
# epub_tocdepth = 3

# Allow duplicate toc entries.
# epub_tocdup = True

########NEW FILE########
__FILENAME__ = base
class BaseAlgorithm(object):
    """
    """

    _cache = {}

    def clear_cache(self):
        self._cache = {}

    @property
    def cache(self):
        return self._cache

    def calculate_similarities(self, vote_list, verbose=0):
        """
        Must return an dict of similarities for every object:

        Accepts a vote matrix representing votes with the following schema:

        ::

            [
                (<user1>, "<object_identifier1>", <score>),
                (<user1>, "<object_identifier2>", <score>),
            ]

        Output must be a dictionary with the following schema:

        ::

            [
                ("<object_identifier1>", [
                                ("<related_object_identifier2>", <score>),
                                ("<related_object_identifier3>", <score>),
                ]),
                ("<object_identifier2>", [
                                ("<related_object_identifier1>", <score>),
                                ("<related_object_identifier3>", <score>),
                ]),
            ]

        """
        raise NotImplemented

    def calculate_recommendations(self, vote_list, itemMatch):
        """
        ``itemMatch`` is supposed to be the result of ``calculate_similarities()``

        Returns a list of recommendations:

        ::

            [
                (<user1>, [
                    ("<object_identifier1>", <score>),
                    ("<object_identifier2>", <score>),
                ]),
                (<user2>, [
                    ("<object_identifier1>", <score>),
                    ("<object_identifier2>", <score>),
                ]),
            ]

        """
        raise NotImplemented

########NEW FILE########
__FILENAME__ = ghetto
from collections import defaultdict
import math
from recommends.similarities import sim_distance
from recommends.converters import convert_vote_list_to_userprefs, convert_vote_list_to_itemprefs
from .base import BaseAlgorithm


class GhettoAlgorithm(BaseAlgorithm):
    """
    """
    similarity = sim_distance

    def top_matches(self, prefs, p1):
        """
        Returns the best matches for p1 from the prefs dictionary.
        """
        return [(p2, self.similarity(prefs[p1], prefs[p2])) for p2 in prefs if p2 != p1]

    def calculate_similarities(self, vote_list, verbose=0):
        # Invert the preference matrix to be item-centric
        itemPrefs = convert_vote_list_to_itemprefs(vote_list)
        itemMatch = {}
        for item in itemPrefs:
            # Find the most similar items to this one
            itemMatch[item] = self.top_matches(itemPrefs, item)
        iteritems = itemMatch.items()
        return iteritems

    def get_recommended_items(self, vote_list, itemMatch, itemIgnored, user):
        prefs = convert_vote_list_to_userprefs(vote_list)
        itemMatch = dict(itemMatch)

        if user in prefs:
            userRatings = prefs[user]
            scores = defaultdict(int)
            totalSim = defaultdict(int)

            # Loop over items rated by this user
            for (item, rating) in userRatings.iteritems():
                # Loop over items similar to this one
                for (item2, similarity) in itemMatch[item]:
                    # Skip ignored items
                    if user.pk in itemIgnored and item2 in itemIgnored[user.pk]:
                        continue
                    # Ignore if this user has already rated this item
                    if not math.isnan(similarity) and item2 not in userRatings:
                        # Weighted sum of rating times similarity
                        scores[item2] += similarity * rating

                        # Sum of all the similarities
                        totalSim[item2] += similarity

            # Divide each total score by total weighting to get an average
            rankings = ((item, (score / totalSim[item])) for item, score in scores.iteritems() if totalSim[item] != 0)
            return rankings
        return []

    def calculate_recommendations(self, vote_list, itemMatch, itemIgnored):
        """
        ``itemMatch`` is supposed to be the result of ``calculate_similarities()``

        Returns a list of recommendations:

        ::

            [
                (<user1>, [
                    ("<object_identifier1>", <score>),
                    ("<object_identifier2>", <score>),
                ]),
                (<user2>, [
                    ("<object_identifier1>", <score>),
                    ("<object_identifier2>", <score>),
                ]),
            ]

        """
        recommendations = []
        users = set(map(lambda x: x[0], vote_list))
        for user in users:
            rankings = self.get_recommended_items(vote_list, itemMatch, itemIgnored, user)
            recommendations.append((user, rankings))
        return recommendations

########NEW FILE########
__FILENAME__ = pyrecsys
from recsys.datamodel.data import Data
from recsys.algorithm.factorize import SVD
from .base import BaseAlgorithm
from recommends.converters import convert_vote_list_to_itemprefs


class RecSysAlgorithm(BaseAlgorithm):
    def __init__(self, k=100, *args, **kwargs):
        self.k = k
        super(RecSysAlgorithm, self).__init__(*args, **kwargs)

    @property
    def svd(self):
        return self.cache.get('svd', None)

    def setup_svd(self, vote_list):
        if self.svd is None:
            self.cache['svd'] = SVD()
            data = Data()

            for vote in vote_list:
                user_id = vote[0].id
                item_id = vote[1]
                value = float(vote[2])
                data.add_tuple((value, item_id, user_id))  # Tuple format is: <value, row, column>
            self.cache['svd'].set_data(data)
            self.cache['svd'].compute(k=self.k, min_values=1)
        return self.svd

    def calculate_similarities(self, vote_list, verbose=0):
        svd = self.setup_svd(vote_list)

        itemPrefs = convert_vote_list_to_itemprefs(vote_list)
        itemMatch = {}
        for item in itemPrefs:
            itemMatch[item] = svd.similar(item)
        iteritems = itemMatch.items()
        return iteritems

    def calculate_recommendations(self, vote_list, itemMatch, itemIgnored):
        svd = self.setup_svd(vote_list)

        recommendations = []
        users = set(map(lambda x: x[0], vote_list))
        for user in users:
            try:
                rankings = svd.recommend(user.id, only_unknowns=True, is_row=False)
                recommendations.append((user, rankings))
            except KeyError:
                pass
        return recommendations

########NEW FILE########
__FILENAME__ = converters
from collections import defaultdict
from django.db import models


def model_path(obj):
    return '%s.%s' % (obj._meta.app_label, obj._meta.object_name.lower())


class IdentifierManager(object):
    _sites = None
    _ctypes = None

    @property
    def sites(self):
        if self._sites is None:
            from django.contrib.sites.models import Site

            self._sites = dict([(s.id, s) for s in Site.objects.all()])
        return self._sites

    @property
    def ctypes(self):
        if self._ctypes is None:
            from django.contrib.contenttypes.models import ContentType

            self._ctypes = dict([("%s.%s" % (c.app_label, c.model), c) for c in ContentType.objects.all()])
        return self._ctypes

    def resolve_identifier(self, identifier):
        """
        The opposite of ``get_identifier()``
        """
        app_module, site_id, object_id = identifier.split(':')
        app_label, model = app_module.split('.')
        site = self.sites[int(site_id)]
        ModelClass = models.get_model(app_label, model)
        model = ModelClass.objects.get(pk=object_id)
        return model, site

    def identifier_to_dict(self, identifier, score=None, related=False):
        """
        The opposite of ``get_identifier()``
        """
        app_module, site_id, object_id = identifier.split(':')
        ctype = self.ctypes[app_module]

        if related:
            spec = {
                'related_object_ctype': ctype.id,
                'related_object_id': int(object_id),
                'related_object_site': int(site_id)
            }
        else:
            spec = {
                'object_ctype': ctype.id,
                'object_id': int(object_id),
                'object_site': int(site_id)
            }
        if score is not None:
            spec['score'] = score

        return spec

    def get_identifier(self, obj, site_id):
        """
        Given a Django Model, returns a string identifier in the format
        <app_label>.<model>:<site_id>:<object_id>.
        """
        return "%s:%s:%s" % (model_path(obj), site_id, obj.id)


def convert_vote_list_to_userprefs(vote_list):
    """
    Return a user-centerd prefernce matrix.

    ``vote_list must be`` composed of (user_id, object_identifier, rating)

    ``object_identifier`` is any string that uniquely identifies the object ie:
    <app_label>.<model>:<object_id>.

    The ``utils.get_identifier`` method is provided as convenience for creating such identifiers.
    """
    prefs = defaultdict(dict)
    for pref in vote_list:
        prefs[pref[0]][pref[1]] = pref[2]
    return prefs


def convert_vote_list_to_itemprefs(vote_list):
    """
    Return a item-centerd prefernce matrix.

    ``vote_list must be`` composed of (user_id, object_identifier, rating)

    ``object_identifier`` is any string that uniquely identifies the object ie:
    <app_label>.<model>:<object_id>.

    The ``utils.get_identifier`` method is provided as convenience for creating such identifiers.
    """
    prefs = defaultdict(dict)
    for pref in vote_list:
        prefs[pref[1]][pref[0]] = pref[2]
    return prefs


def similary_results_to_itemMatch(qs, provider):
    itemMatch = defaultdict(list)
    for i in qs:
        site = i.related_object_site
        item = provider.get_identifier(i.get_object(), site)
        similarity = i.score
        item2 = provider.get_identifier(i.get_related_object(), site)

        itemMatch[item].append((similarity, item2))

    return itemMatch

########NEW FILE########
__FILENAME__ = recommends_precompute
from django.core.management.base import BaseCommand
from recommends.tasks import recommends_precompute

from datetime import datetime
import dateutil.relativedelta
from optparse import make_option

import warnings


class Command(BaseCommand):
    help = 'Calculate recommendations and similarities based on ratings'
    option_list = BaseCommand.option_list + (
        make_option('--verbose',
            action='store_true',
            dest='verbose',
            default=False,
            help='verbose mode'
        ),
    )

    def handle(self, *args, **options):
        verbosity = int(options.get('verbosity', 0))
        if options['verbose']:
            warnings.warn('The `--verbose` option is being deprecated and it will be removed in the next release. Use `--verbosity` instead.', PendingDeprecationWarning)
            verbosity = 1

        if verbosity == 0:
            # avoids allocating the results
            recommends_precompute()
        else:
            self.stdout.write("\nCalculation Started.\n")
            start_time = datetime.now()
            results = recommends_precompute()
            end_time = datetime.now()
            if verbosity > 1:
                for r in results:
                    self.stdout.write(
                        "%d similarities and %d recommendations saved.\n"
                        % (r['similar_count'], r['recommend_count']))
            rd = dateutil.relativedelta.relativedelta(end_time, start_time)
            self.stdout.write(
                "Calculation finished in %d years, %d months, %d days, %d hours, %d minutes and %d seconds\n"
                % (rd.years, rd.months, rd.days, rd.hours, rd.minutes, rd.seconds))

########NEW FILE########
__FILENAME__ = managers
from recommends.utils import ctypes_dict


class CachedContentTypesMixin():
    _ctypes = None

    @property
    def ctypes(self):
        if self._ctypes is None:
            self._ctypes = ctypes_dict()
        return self._ctypes

    def get_ctype_id_for_obj(self, obj):
        app_label = obj._meta.app_label
        module_name = obj._meta.module_name
        return self.ctypes["%s.%s" % (app_label, module_name)]


class DictStorageManager(object, CachedContentTypesMixin):
    def similarity_for_objects(self, object_target, object_target_site, object_related, object_related_site):
        object_ctype_id = self.get_ctype_id_for_obj(object_target)
        object_id = object_target.id

        related_object_ctype_id = self.get_ctype_id_for_obj(object_related)
        related_object_id = object_related.id

        return dict(
            object_ctype=object_ctype_id,
            object_id=object_id,
            object_site=object_target_site.id,
            related_object_ctype=related_object_ctype_id,
            related_object_id=related_object_id,
            related_object_site=object_related_site.id,
        )

    def suggestion_for_object(self, user, object_recommended, object_site):
        object_ctype_id = self.get_ctype_id_for_obj(object_recommended)
        object_id = object_recommended.id

        return dict(
            object_ctype=object_ctype_id,
            object_id=object_id,
            object_site=object_site.id,
            user=user.id,
        )

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals
from django.contrib.contenttypes.models import ContentType
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible
class MockModel(object):
    _object = None

    def __init__(self, **kwargs):
        self.__dict__ = kwargs

    def __str__(self):
        return "Mock for content object %s" % self.object

    def __repr__(self):
        return "<%s>" % self.__str__()

    @property
    def object(self):
        if self._object is None:
            ModelClass = ContentType.objects.get(pk=self.object_ctype).model_class()
            self._object = ModelClass.objects.get(pk=self.object_id)
        return self._object


@python_2_unicode_compatible
class MockSimilarity(MockModel):
    _related_object = None

    @property
    def related_object(self):
        if self._related_object is None:
            ModelClass = ContentType.objects.get(pk=self.related_object_ctype).model_class()
            self._related_object = ModelClass.objects.get(pk=self.related_object_id)
        return self._related_object

    def __str__(self):
        return "Similarity between %s and %s" % (self.object, self.related_object)

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings


RECOMMENDS_TASK_RUN = getattr(settings, 'RECOMMENDS_TASK_RUN', True)
RECOMMENDS_TASK_CRONTAB = getattr(settings, 'RECOMMENDS_TASK_CRONTAB', {'hour': '*/24'})
RECOMMENDS_CACHE_TEMPLATETAGS_TIMEOUT = getattr(settings, 'RECOMMENDS_CACHE_TEMPLATETAGS_TIMEOUT', 60)
RECOMMENDS_STORAGE_BACKEND = getattr(settings, 'RECOMMENDS_STORAGE_BACKEND', 'recommends.storages.djangoorm.storage.DjangoOrmStorage')
RECOMMENDS_STORAGE_LOGGING_THRESHOLD = getattr(settings, 'RECOMMENDS_STORAGE_LOGGING_THRESHOLD', 1000)
RECOMMENDS_LOGGER_NAME = getattr(settings, 'RECOMMENDS_LOGGER_NAME', 'recommends')
RECOMMENDS_TASK_EXPIRES = getattr(settings, 'RECOMMENDS_TASK_EXPIRES', None)

########NEW FILE########
__FILENAME__ = similarities
from math import sqrt


@staticmethod
def sim_distance(p1, p2):
    """Returns a distance-based similarity score for p1 and p2"""
    # Get the list of shared_items
    si = [item for item in p1 if item in p2]

    if len(si) != 0:
        squares = [pow(p1[item] - p2[item], 2) for item in si]
        # Add up the squares of all the differences
        sum_of_squares = sum(squares)
        return 1 / (1 + sqrt(sum_of_squares))
    return 0


@staticmethod
def sim_pearson(p1, p2):
    """
    Returns the Pearson correlation coefficient for p1 and p2
    """
    # Get the list of mutually rated items
    si = [item for item in p1 if item in p2]

    # Find the number of elements
    n = len(si)

    # if they have no ratings in common, return 0
    if n != 0:
        # Add up all the preferences
        sum1 = sum([p1[it] for it in si])
        sum2 = sum([p2[it] for it in si])

        # Sum up the squares
        sum1Sq = sum([pow(p1[it], 2) for it in si])
        sum2Sq = sum([pow(p2[it], 2) for it in si])

        # Sum up the products
        pSum = sum([p1[it] * p2[it] for it in si])

        # Calculate Pearson score
        num = pSum - (sum1 * sum2 / n)
        den = sqrt((sum1Sq - pow(sum1, 2) / n) * (sum2Sq - pow(sum2, 2) / n))
        if den == 0:
            return 0
        r = num / den
        return r
    return 0

########NEW FILE########
__FILENAME__ = base
from recommends.converters import IdentifierManager


class BaseRecommendationStorage(object):
    threshold_similarities = 0
    threshold_recommendations = 0

    def __init__(self, settings=None):
        self.identifier_manager = IdentifierManager()
        self.settings = settings

    def get_identifier(self, obj, site_id=None, rating=None, *args, **kwargs):
        """
        Given an object and optional parameters, returns a string identifying the object uniquely.
        """
        if rating is not None:
            site_id = self.get_rating_site(rating).id
        if site_id is None:
            site_id = self.settings.SITE_ID
        return self.identifier_manager.get_identifier(obj, site_id)

    def resolve_identifier(self, identifier):
        """
        This method is the opposite of ``get_identifier``.
        It resolve the object's identifier to an actual model.
        """
        return self.identifier_manager.resolve_identifier(identifier)

    def get_similarities_for_object(self, obj, limit, raw_id=False):
        """
        if raw_id = False:
            Returns a list of ``Similarity`` objects for given ``obj``, ordered by score.
        else:
            Returns a list of similar ``model`` ids[pk] for given ``obj``, ordered by score.

            Example:

        ::

            [
                {
                    "related_object_id": XX, "contect_type_id": XX
                },
                ..
            ]
        """
        raise NotImplementedError

    def get_recommendations_for_user(self, user, limit, raw_id=False):
        """
        if raw_id = False:
            Returns a list of ``Recommendation`` objects for given ``user``, ordered by score.
        else:
            Returns a list of recommended ``model`` ids[pk] for given ``user``, ordered by score.

            Example:

        ::
            [
                {
                    "object_id": XX, "contect_type_id": XX
                },
                ..
            ]
        """
        raise NotImplementedError

    def store_similarities(self, itemMatch):
        raise NotImplementedError

    def store_recommendations(self, recommendations):
        """
        Stores all the recommendations.

        ``recommendations`` is an iterable with the following schema:

        ::

            (
                (
                    <user>,
                    (
                        (<object_identifier>, <score>),
                        (<object_identifier>, <score>)
                    ),
                )
            )
        """
        raise NotImplementedError

    def get_votes(self):
        """
        Optional.

        Retrieves the vote matrix saved by ``store_votes``.

        You won't usually need to implement this method, because you want to use fresh data.
        But it might be useful if you want some kind of heavy caching, maybe for testing purposes.
        """
        raise NotImplementedError

    def store_votes(self, iterable):
        """
        Optional.

        Saves the vote matrix.

        You won't usually need to implement this method, because you want to use fresh data.
        But it might be useful if you want to dump the votes on somewhere, maybe for testing purposes.

        ``iterable`` is the vote matrix, expressed as a list of tuples with the following schema:

        ::

            [
                ("<user_id1>", "<object_identifier1>", <score>),
                ("<user_id1>", "<object_identifier2>", <score>),
                ("<user_id2>", "<object_identifier1>", <score>),
                ("<user_id2>", "<object_identifier2>", <score>),
            ]
        """
        raise NotImplementedError

    def remove_recommendation(self, obj):
        """
        Deletes all recommendations for object ``obj``.
        """
        raise NotImplementedError

    def remove_similarity(self, obj):
        """
        Deletes all similarities that have object ``obj`` as source or target.
        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from .models import Similarity, Recommendation


class SimilarityAdmin(admin.ModelAdmin):
    list_display = ('object', 'object_site', 'related_object', 'related_object_site', 'score')
    list_filter = ('object_site',)
admin.site.register(Similarity, SimilarityAdmin)


class RecommendationAdmin(admin.ModelAdmin):
    list_display = ('user', 'score', 'object', 'object_site')
    list_filter = ('object_site',)
admin.site.register(Recommendation, RecommendationAdmin)

########NEW FILE########
__FILENAME__ = managers
from django.conf import settings
from django.db import models
from recommends.managers import CachedContentTypesMixin


class RecommendsManager(models.Manager, CachedContentTypesMixin):
    def filter_for_model(self, model):
        ctype_id = self.get_ctype_id_for_obj(model)
        return self.filter(object_ctype=ctype_id)

    def filter_for_object(self, obj):
        return self.filter_for_model(obj).filter(object_id=obj.id)


class SimilarityManager(RecommendsManager):
    def filter_for_related_model(self, related_model):
        ctype_id = self.get_ctype_id_for_obj(related_model)
        return self.filter(related_object_ctype=ctype_id)

    def filter_for_related_object(self, related_obj):
        return self.filter_for_related_model(related_obj).filter(related_object_id=related_obj.id)

    def filter_by_couple(self, target_object, related_obj):
        related_ctype_id = self.get_ctype_id_for_obj(related_obj)

        return self.filter_for_object(target_object).filter(
            related_object_ctype=related_ctype_id,
            related_object_id=related_obj.id
        )

    def get_query_set(self):
        return super(SimilarityManager, self).get_query_set().filter(score__isnull=False)

    def get_or_create_for_objects(self, object_target, object_target_site, object_related, object_related_site):
        object_ctype_id = self.get_ctype_id_for_obj(object_target)
        object_id = object_target.id

        related_object_ctype_id = self.get_ctype_id_for_obj(object_related)
        related_object_id = object_related.id

        return self.get_or_create(
            object_ctype=object_ctype_id,
            object_id=object_id,
            object_site=object_target_site.id,
            related_object_ctype=related_object_ctype_id,
            related_object_id=related_object_id,
            related_object_site=object_related_site.id
        )

    def set_score_for_objects(self, object_target, object_target_site, object_related, object_related_site, score):
        if score == 0:
            self.filter_by_couple(object_target, object_related).filter(
                object_site=object_target_site.id,
                related_object_site=object_related_site.id
            ).delete()
            return None

        result, created = self.get_or_create_for_objects(object_target, object_target_site, object_related, object_related_site)
        result.score = score
        result.save()
        return result

    def similar_to(self, obj, site=None, **kwargs):
        if site is None and 'related_object_site' not in kwargs:
            kwargs['related_object_site'] = settings.SITE_ID
        return self.filter_for_object(obj).filter(**kwargs)


class RecommendationManager(RecommendsManager):
    def get_query_set(self):
        return super(RecommendationManager, self).get_query_set().filter(score__isnull=False)

    def get_or_create_for_object(self, user, object_recommended, object_site):
        object_ctype_id = self.get_ctype_id_for_obj(object_recommended)
        object_id = object_recommended.id

        return self.get_or_create(
            object_ctype=object_ctype_id,
            object_id=object_id,
            object_site=object_site.id,
            user=user.id
        )

    def set_score_for_object(self, user, object_recommended, object_site, score):
        if score == 0:
            self.filter_for_object(object_recommended).filter(user=user.id).delete()
            return None

        result, created = self.get_or_create_for_object(user, object_recommended, object_site)
        result.score = score
        result.save()
        return result

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals
from django.db import models
from django.contrib.contenttypes import generic
from .managers import RecommendsManager, SimilarityManager, RecommendationManager
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible
class RecommendsBaseModel(models.Model):
    """(RecommendsBaseModel description)"""
    object_ctype = models.PositiveIntegerField()
    object_id = models.PositiveIntegerField()
    object_site = models.PositiveIntegerField()
    object = generic.GenericForeignKey('object_ctype', 'object_id')

    objects = RecommendsManager()

    class Meta:
        abstract = True
        unique_together = ('object_ctype', 'object_id', 'object_site')

    def __str__(self):
        return "RecommendsBaseModel"


@python_2_unicode_compatible
class Similarity(RecommendsBaseModel):
    """How much an object is similar to another"""

    score = models.FloatField(null=True, blank=True, default=None)

    related_object_ctype = models.PositiveIntegerField()
    related_object_id = models.PositiveIntegerField()
    related_object_site = models.PositiveIntegerField()
    related_object = generic.GenericForeignKey('related_object_ctype', 'related_object_id')

    objects = SimilarityManager()

    class Meta:
        verbose_name_plural = 'similarities'
        unique_together = ('object_ctype', 'object_id', 'object_site', 'related_object_ctype', 'related_object_id', 'related_object_site')
        ordering = ['-score']

    def __str__(self):
        return "Similarity between %s and %s" % (self.object, self.related_object)


@python_2_unicode_compatible
class Recommendation(RecommendsBaseModel):
    """Recommended an object for a particular user"""
    user = models.PositiveIntegerField()
    score = models.FloatField(null=True, blank=True, default=None)

    objects = RecommendationManager()

    class Meta:
        unique_together = ('object_ctype', 'object_id', 'user')
        ordering = ['-score']

    def __str__(self):
        return "Recommendation for user %s" % (self.user)

########NEW FILE########
__FILENAME__ = routers
from .settings import RECOMMENDS_STORAGE_DATABASE_ALIAS


class RecommendsRouter(object):
    def db_for_read(self, model, **hints):
        "Point all operations on recommends models to RECOMMENDS_STORAGE_DATABASE_NAME"
        if model._meta.app_label == 'recommends':
            return RECOMMENDS_STORAGE_DATABASE_ALIAS
        return None

    def db_for_write(self, model, **hints):
        "Point all operations on recommends models to RECOMMENDS_STORAGE_DATABASE_NAME"
        if model._meta.app_label == 'recommends':
            return RECOMMENDS_STORAGE_DATABASE_ALIAS
        return None

    def allow_relation(self, obj1, obj2, **hints):
        "Allow any relation if a model in recommends is involved"
        if obj1._meta.app_label == 'recommends' or obj2._meta.app_label == 'recommends':
            return True
        return None

    def allow_syncdb(self, db, model):
        "Make sure the recommends app only appears on the RECOMMENDS_STORAGE_DATABASE_NAME db"
        if db == RECOMMENDS_STORAGE_DATABASE_ALIAS:
            return model._meta.app_label == 'recommends'
        elif model._meta.app_label == 'recommends':
            return False
        return None

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

RECOMMENDS_STORAGE_DATABASE_ALIAS = getattr(settings, 'RECOMMENDS_STORAGE_DATABASE_ALIAS', 'recommends')
RECOMMENDS_STORAGE_COMMIT_THRESHOLD = getattr(settings, 'RECOMMENDS_STORAGE_COMMIT_THRESHOLD', 1000)

########NEW FILE########
__FILENAME__ = storage
import logging
import math
from django.db import transaction
from recommends.storages.base import BaseRecommendationStorage
from recommends.settings import RECOMMENDS_LOGGER_NAME
from .settings import RECOMMENDS_STORAGE_COMMIT_THRESHOLD
from .models import Similarity, Recommendation


logger = logging.getLogger(RECOMMENDS_LOGGER_NAME)


class DjangoOrmStorage(BaseRecommendationStorage):
    def get_similarities_for_object(self, obj, limit=10, raw_id=False):
        object_site_id = self.settings.SITE_ID
        qs = Similarity.objects.similar_to(
            obj,
            related_object_site=object_site_id,
            score__gt=0).order_by('-score')
        if raw_id:
            qs = qs.extra(
                select={'contect_type_id': 'object_ctype'}).values(
                    'related_object_id', 'contect_type_id'
                )
        return qs[:limit]

    def get_recommendations_for_user(self, user, limit=10, raw_id=False):
        object_site_id = self.settings.SITE_ID
        qs = Recommendation.objects.filter(
            user=user.id,
            object_site=object_site_id).order_by('-score')
        if raw_id:
            qs = qs.extra(
                select={'contect_type_id': 'object_ctype'}).values(
                    'object_id', 'contect_type_id'
                )
        return qs[:limit]

    def get_votes(self):
        pass

    def store_votes(self, iterable):
        pass

    @transaction.commit_manually
    def store_similarities(self, itemMatch):
        try:
            logger.info('saving similarities')
            count = 0
            for object_id, scores in itemMatch:
                object_target, object_target_site = self.resolve_identifier(
                    object_id)

                for related_object_id, score in scores:
                    if not math.isnan(score) and score > self.threshold_similarities:
                        object_related, object_related_site = self.resolve_identifier(
                            related_object_id)
                        if object_target != object_related:
                            count = count + 1
                            Similarity.objects.set_score_for_objects(
                                object_target=object_target,
                                object_target_site=object_target_site,
                                object_related=object_related,
                                object_related_site=object_related_site,
                                score=score
                            )
                            if count % RECOMMENDS_STORAGE_COMMIT_THRESHOLD == 0:
                                logger.debug(
                                    'saved %s similarities...' %
                                    count)
                                transaction.commit()
        finally:
            logger.info('saved %s similarities...' % count)
            transaction.commit()

    @transaction.commit_manually
    def store_recommendations(self, recommendations):
        try:
            logger.info('saving recommendations')
            count = 0
            for (user, rankings) in recommendations:
                for object_id, score in rankings:
                    if not math.isnan(score) and score > self.threshold_recommendations:
                        count = count + 1
                        object_recommended, site = self.resolve_identifier(
                            object_id)
                        Recommendation.objects.set_score_for_object(
                            user=user,
                            object_recommended=object_recommended,
                            object_site=site,
                            score=score
                        )
                        if count % RECOMMENDS_STORAGE_COMMIT_THRESHOLD == 0:
                            logger.debug('saved %s recommendations...' % count)
                            transaction.commit()
        finally:
            logger.info('saved %s recommendations...' % count)
            transaction.commit()

    def remove_recommendations(self, obj):
        Recommendation.objects.filter_for_object(obj=obj).delete()

    def remove_similarities(self, obj):
        Similarity.objects.filter_for_object(obj=obj).delete()
        Similarity.objects.filter_for_related_object(related_obj=obj).delete()

########NEW FILE########
__FILENAME__ = managers
from recommends.managers import DictStorageManager


class MongoStorageManager(DictStorageManager):
    def filter_for_object(self, obj):
        ctype_id = self.get_ctype_id_for_obj(obj)
        return {'object_ctype': ctype_id, 'object_id': obj.id}

    def filter_for_related_object(self, related_obj):
        ctype_id = self.get_ctype_id_for_obj(related_obj)
        return {'related_object_ctype': ctype_id, 'related_object_id': related_obj.id}

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

RECOMMENDS_STORAGE_MONGODB_DATABASE_DEFAULT = {
    'HOST': 'localhost',
    'PORT': 27017,
    'NAME': 'recommends',
}
RECOMMENDS_STORAGE_MONGODB_DATABASE = getattr(settings, 'RECOMMENDS_STORAGE_MONGODB_DATABASE', RECOMMENDS_STORAGE_MONGODB_DATABASE_DEFAULT)
RECOMMENDS_STORAGE_MONGODB_SIMILARITY_COLLECTION = getattr(settings, 'RECOMMENDS_STORAGE_MONGODB_SIMILARITY_COLLECTION', 'similarity')
RECOMMENDS_STORAGE_MONGODB_RECOMMENDATION_COLLECTION = getattr(settings, 'RECOMMENDS_STORAGE_MONGODB_RECOMMENDATION_COLLECTION', 'recommendation')
RECOMMENDS_STORAGE_MONGODB_FSYNC = getattr(settings, 'RECOMMENDS_STORAGE_MONGODB_FSYNC', False)

########NEW FILE########
__FILENAME__ = storage
import logging
import math
import pymongo
from recommends.models import MockModel, MockSimilarity
from recommends.storages.base import BaseRecommendationStorage
from recommends.settings import RECOMMENDS_LOGGER_NAME, RECOMMENDS_STORAGE_LOGGING_THRESHOLD
from .settings import (
    RECOMMENDS_STORAGE_MONGODB_DATABASE,
    RECOMMENDS_STORAGE_MONGODB_SIMILARITY_COLLECTION,
    RECOMMENDS_STORAGE_MONGODB_RECOMMENDATION_COLLECTION,
    RECOMMENDS_STORAGE_MONGODB_FSYNC
)
from .managers import MongoStorageManager


logger = logging.getLogger(RECOMMENDS_LOGGER_NAME)


class MongoStorage(BaseRecommendationStorage):
    manager = MongoStorageManager()

    def _get_mock_models(self, spec, collection_name, limit, raw_id, mock_class=MockModel):
        connection = pymongo.Connection(RECOMMENDS_STORAGE_MONGODB_DATABASE['HOST'], RECOMMENDS_STORAGE_MONGODB_DATABASE['PORT'])
        db = connection[RECOMMENDS_STORAGE_MONGODB_DATABASE['NAME']]
        collection = db[collection_name]

        documents = collection.find(spec, limit=limit, sort=[('score', pymongo.DESCENDING)])
        if raw_id:
            if mock_class is MockModel:
                return [{
                        'object_id': item['object_id'],
                        'contect_type_id': item['object_ctype']}
                        for item in documents]
            elif mock_class is MockSimilarity:
                return [{
                    'related_object_id': item['related_object_id'],
                    'contect_type_id': item['object_ctype']}
                    for item in documents]
        return map(lambda x: mock_class(**x), documents)

    def get_similarities_for_object(self, obj, limit=10, raw_id=False):
        object_site_id = self.settings.SITE_ID
        spec = dict(related_object_site=object_site_id, **self.manager.filter_for_object(obj))
        collection_name = RECOMMENDS_STORAGE_MONGODB_SIMILARITY_COLLECTION

        return self._get_mock_models(spec, collection_name, limit, raw_id, mock_class=MockSimilarity)

    def get_recommendations_for_user(self, user, limit=10, raw_id=False):
        spec = {'user': user.id, 'object_site': self.settings.SITE_ID}
        collection_name = RECOMMENDS_STORAGE_MONGODB_RECOMMENDATION_COLLECTION

        return self._get_mock_models(spec, collection_name, limit, raw_id)

    def get_votes(self):
        pass

    def store_votes(self, iterable):
        pass

    def store_similarities(self, itemMatch):
        connection = pymongo.Connection(RECOMMENDS_STORAGE_MONGODB_DATABASE['HOST'], RECOMMENDS_STORAGE_MONGODB_DATABASE['PORT'])
        db = connection[RECOMMENDS_STORAGE_MONGODB_DATABASE['NAME']]
        collection = db[RECOMMENDS_STORAGE_MONGODB_SIMILARITY_COLLECTION]

        logger.info('saving similarities')
        count = 0

        for object_id, scores in itemMatch:
            object_target, object_target_site = self.resolve_identifier(object_id)

            for related_object_id, score in scores:
                if not math.isnan(score) and score > self.threshold_similarities:
                    object_related, object_related_site = self.resolve_identifier(related_object_id)
                    if object_target != object_related:
                        spec = self.manager.similarity_for_objects(object_target=object_target, object_target_site=object_target_site, object_related=object_related, object_related_site=object_related_site)
                        collection.update(spec, {'$set': {'score': score}}, upsert=True, fsync=RECOMMENDS_STORAGE_MONGODB_FSYNC)
                        count = count + 1

                        if count % RECOMMENDS_STORAGE_LOGGING_THRESHOLD == 0:
                            logger.debug('saved %s similarities...' % count)

        logger.info('saved %s similarities...' % count)

    def store_recommendations(self, recommendations):
        connection = pymongo.Connection(RECOMMENDS_STORAGE_MONGODB_DATABASE['HOST'], RECOMMENDS_STORAGE_MONGODB_DATABASE['PORT'])
        db = connection[RECOMMENDS_STORAGE_MONGODB_DATABASE['NAME']]
        collection = db[RECOMMENDS_STORAGE_MONGODB_RECOMMENDATION_COLLECTION]

        logger.info('saving recommendation')
        count = 0

        for (user, rankings) in recommendations:
            for object_id, score in rankings:
                if not math.isnan(score) and score > self.threshold_recommendations:
                    count = count + 1
                    object_recommended, site = self.resolve_identifier(object_id)
                    spec = self.manager.suggestion_for_object(
                        user=user,
                        object_recommended=object_recommended,
                        object_site=site
                    )
                    collection.update(spec, {'$set': {'score': score}}, upsert=True, fsync=RECOMMENDS_STORAGE_MONGODB_FSYNC)

                    if count % RECOMMENDS_STORAGE_LOGGING_THRESHOLD == 0:
                        logger.debug('saved %s recommendations...' % count)
        logger.info('saved %s recommendation...' % count)

    def remove_recommendations(self, obj):
        connection = pymongo.Connection(RECOMMENDS_STORAGE_MONGODB_DATABASE['HOST'], RECOMMENDS_STORAGE_MONGODB_DATABASE['PORT'])
        db = connection[RECOMMENDS_STORAGE_MONGODB_DATABASE['NAME']]
        collection = db[RECOMMENDS_STORAGE_MONGODB_RECOMMENDATION_COLLECTION]
        collection.remove(self.manager.filter_for_object(obj), fsync=RECOMMENDS_STORAGE_MONGODB_FSYNC)

    def remove_similarities(self, obj):
        connection = pymongo.Connection(RECOMMENDS_STORAGE_MONGODB_DATABASE['HOST'], RECOMMENDS_STORAGE_MONGODB_DATABASE['PORT'])
        db = connection[RECOMMENDS_STORAGE_MONGODB_DATABASE['NAME']]

        collection = db[RECOMMENDS_STORAGE_MONGODB_SIMILARITY_COLLECTION]

        collection.remove(self.manager.filter_for_object(obj), fsync=RECOMMENDS_STORAGE_MONGODB_FSYNC)
        collection.remove(self.manager.filter_for_related_object(obj), fsync=RECOMMENDS_STORAGE_MONGODB_FSYNC)

########NEW FILE########
__FILENAME__ = managers
from recommends.managers import DictStorageManager


class RedisStorageManager(DictStorageManager):
    def similarity_for_objects(self, score, *args, **kwargs):
        spec = super(RedisStorageManager, self).similarity_for_objects(*args, **kwargs)
        spec['score'] = score
        return spec

    def filter_for_object(self, obj):
        ctype_id = self.get_ctype_id_for_obj(obj)
        return {'object_ctype': ctype_id, 'object_id': obj.id}

    def filter_for_related_object(self, related_obj):
        ctype_id = self.get_ctype_id_for_obj(related_obj)
        return {'related_object_ctype': ctype_id, 'related_object_id': related_obj.id}

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

RECOMMENDS_STORAGE_REDIS_DATABASE_DEFAULT = {
    'HOST': 'localhost',
    'PORT': 6379,
    'NAME': 0
}

RECOMMENDS_STORAGE_REDIS_DATABASE = getattr(settings, 'RECOMMENDS_STORAGE_REDIS_DATABASE', RECOMMENDS_STORAGE_REDIS_DATABASE_DEFAULT)

########NEW FILE########
__FILENAME__ = storage
import logging
import math
import redis
from recommends.models import MockModel, MockSimilarity
from recommends.storages.base import BaseRecommendationStorage
from recommends.settings import RECOMMENDS_LOGGER_NAME, RECOMMENDS_STORAGE_LOGGING_THRESHOLD
from .settings import RECOMMENDS_STORAGE_REDIS_DATABASE
from .managers import RedisStorageManager


logger = logging.getLogger(RECOMMENDS_LOGGER_NAME)


class RedisStorage(BaseRecommendationStorage):
    manager = RedisStorageManager()

    _redis = None

    @property
    def redis(self):
        if self._redis is None:
            self._redis = redis.StrictRedis(host=RECOMMENDS_STORAGE_REDIS_DATABASE['HOST'], port=RECOMMENDS_STORAGE_REDIS_DATABASE['PORT'], db=RECOMMENDS_STORAGE_REDIS_DATABASE['NAME'])
        return self._redis

    def _get_mock_models(self, dicts, mock_class=MockModel):
        return map(lambda x: mock_class(**x), dicts)

    def get_similarities_for_object(self, obj, limit=10, raw_id=False):
        r = self.redis

        object_id = self.get_identifier(obj)
        key = 'recommends:similarity:%s' % object_id
        scores = r.zrevrangebyscore(key, min=0, max=1, num=limit, start=0, withscores=True)

        similarity_dicts = []
        for identifier, score in scores:
            similarity_dict = self.identifier_manager.identifier_to_dict(object_id)
            similarity_dict.update(self.identifier_manager.identifier_to_dict(identifier, score, related=True))
            similarity_dicts.append(similarity_dict)
        if raw_id:
            return [{
                'related_object_id': item['related_object_id'],
                'contect_type_id': item['object_ctype']}
                for item in similarity_dicts][:limit]
        return self._get_mock_models(similarity_dicts, mock_class=MockSimilarity)

    def get_recommendations_for_user(self, user, limit=10, raw_id=False):
        r = self.redis
        key = 'recommends:recommendation:%s' % user.id
        scores = r.zrevrangebyscore(key, min=0, max=1, num=limit, start=0, withscores=True)

        recommendation_dicts = [self.identifier_manager.identifier_to_dict(object_id, score) for object_id, score in scores]
        if raw_id:
            return [{
                    'object_id': item['object_id'],
                    'contect_type_id': item['object_ctype']}
                    for item in recommendation_dicts][:limit]
        return self._get_mock_models(recommendation_dicts, mock_class=MockModel)

    def get_votes(self):
        pass

    def store_votes(self, iterable):
        pass

    def store_similarities(self, itemMatch):
        r = self.redis

        logger.info('saving similarities')
        count = 0

        for object_id, scores in itemMatch:
            object_target, object_target_site = self.resolve_identifier(object_id)

            for related_object_id, score in scores:
                if not math.isnan(score) and score > self.threshold_similarities:
                    object_related, object_related_site = self.resolve_identifier(related_object_id)
                    if object_target != object_related:
                        key = 'recommends:similarity:%s' % object_id
                        r.zadd(key, score, related_object_id)

                        rev_key = 'recommends:similarity_reverse:%s' % related_object_id
                        r.sadd(rev_key, object_id)

                        index_key = 'recommends:similarity:index'
                        r.sadd(index_key, object_id)

                        count = count + 1

                        if count % RECOMMENDS_STORAGE_LOGGING_THRESHOLD == 0:
                            logger.debug('saved %s similarities...' % count)
        logger.info('saved %s similarities...' % count)

    def store_recommendations(self, recommendations):
        r = self.redis

        logger.info('saving recommendation')
        count = 0

        for (user, rankings) in recommendations:
            for object_id, score in rankings:
                if not math.isnan(score) and score > self.threshold_recommendations:
                    key = 'recommends:recommendation:%s' % user.id
                    r.zadd(key, score, object_id)

                    rev_key = 'recommends:recommendation_reverse:%s' % object_id
                    r.zadd(rev_key, score, user.id)

                    index_key = 'recommends:recommendation:index'
                    r.sadd(index_key, object_id)

                    count = count + 1
                    if count % RECOMMENDS_STORAGE_LOGGING_THRESHOLD == 0:
                        logger.debug('saved %s recommendations...' % count)
        logger.info('saved %s recommendation...' % count)

    def remove_similarities(self, obj):
        r = self.redis
        object_id = self.get_identifier(obj)
        key = 'recommends:similarity:%s' % object_id
        r.delete(key)

        rev_key = 'recommends:similarity_reverse:%s' % object_id
        values = r.smembers(rev_key)
        for value in values:
            r.zrem('recommends:similarity:%s' % value, object_id)
        r.delete(rev_key)

        index_key = 'recommends:similarity:index'
        r.srem(index_key, object_id)

    def remove_recommendations(self, obj):
        r = self.redis
        object_id = self.get_identifier(obj)

        rev_key = 'recommends:recommendation_reverse:%s' % object_id
        user_ids = r.zrevrangebyscore(rev_key, min=0, max=1, start=0, num=r.zcount(rev_key, min=0, max=1))
        for user_id in user_ids:
            r.zrem('recommends:recommendation:%s' % user_id, object_id)
        r.delete(rev_key)

        index_key = 'recommends:recommendation:index'
        r.srem(index_key, object_id)

########NEW FILE########
__FILENAME__ = tasks
from celery.task import task, periodic_task
from celery.schedules import crontab
from .utils import filelock

from .settings import RECOMMENDS_TASK_RUN, RECOMMENDS_TASK_CRONTAB, RECOMMENDS_TASK_EXPIRES


def recommends_precompute():
    results = []
    from .providers import recommendation_registry

    # I know this is weird, but it's faster (tested on CPyhton 2.6.5)
    def _precompute(provider_instance):
        results.append(provider_instance.precompute())

    with filelock('recommends_precompute.lock'):
        [_precompute(provider_instance)
         for provider_instance in recommendation_registry.get_vote_providers()]

    return results

if RECOMMENDS_TASK_RUN:
    @periodic_task(name='recommends_precompute', run_every=crontab(**RECOMMENDS_TASK_CRONTAB), expires=RECOMMENDS_TASK_EXPIRES)
    def _recommends_precompute():
        recommends_precompute()


@task(name='remove_suggestions')
def remove_suggestions(rated_model, object_id):
    from django.db.models import get_model
    from recommends.providers import recommendation_registry

    ObjectClass = get_model(*rated_model.split('.'))
    provider_instance = recommendation_registry.get_provider_for_content(
        ObjectClass)
    obj = ObjectClass.objects.get(pk=object_id)

    provider_instance.storage.remove_recommendations(obj)


@task(name='remove_similarities')
def remove_similarities(rated_model, object_id):
    from django.db.models import get_model
    from recommends.providers import recommendation_registry

    ObjectClass = get_model(*rated_model.split('.'))
    provider_instance = recommendation_registry.get_provider_for_content(
        ObjectClass)
    obj = ObjectClass.objects.get(pk=object_id)

    provider_instance.storage.remove_similarities(obj)

########NEW FILE########
__FILENAME__ = recommends
from ..providers import recommendation_registry
from ..settings import RECOMMENDS_CACHE_TEMPLATETAGS_TIMEOUT
from django import template
from django.core.cache import cache
from django.conf import settings
from django.db import models
register = template.Library()


@register.filter
def similarities(obj, limit=5):
    """
    Returns a list of Similarity objects, representing how much an object is similar to the given one.

    Usage:

    ::

        {% for similarity in myobj|similar:5 %}
            {{ similarity.related_object }}
        {% endfor %}
    """
    if isinstance(obj, models.Model):
        cache_key = 'recommends:similarities:%s:%s.%s:%s:%s' % (settings.SITE_ID, obj._meta.app_label, obj._meta.object_name.lower(), obj.id, limit)
        similarities = cache.get(cache_key)
        if similarities is None:
            provider = recommendation_registry.get_provider_for_content(obj)
            similarities = provider.storage.get_similarities_for_object(obj, int(limit))
            cache.set(cache_key, similarities, RECOMMENDS_CACHE_TEMPLATETAGS_TIMEOUT)
        return similarities


class SuggestionNode(template.Node):
    def __init__(self, varname, limit):
        self.varname = varname
        self.limit = limit

    def render(self, context):
        user = context['user']
        if user.is_authenticated():  # We need an id after all
            cache_key = 'recommends:recommendations:%s:%s:%s' % (settings.SITE_ID, user.id, self.limit)
            suggestions = cache.get(cache_key)
            if suggestions is None:
                suggestions = set()
                for provider in recommendation_registry.providers:
                    suggestions.update(provider.storage.get_recommendations_for_user(user, int(self.limit)))
                cache.set(cache_key, suggestions, RECOMMENDS_CACHE_TEMPLATETAGS_TIMEOUT)
            context[self.varname] = suggestions
        return ''


@register.tag()
def suggested(parser, token):
    """
    Returns a list of Recommendation (suggestions of objects) for the current user.

    Usage:

    ::

        {% suggested as suggestions [limit 5]  %}
        {% for suggested in suggestions %}
            {{ suggested.object }}
        {% endfor %}
    """
    bits = token.contents.split()
    varname = bits[2]
    try:
        limit = int(bits[4])
    except IndexError:
        limit = 5
    return SuggestionNode(varname, limit)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from .models import RecProduct, RecVote

admin.site.register(RecProduct)
admin.site.register(RecVote)

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals
from django.db import models
from django.contrib.sites.models import Site
from django.contrib.auth import models as auth_models
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible
class RecProduct(models.Model):
    """A generic Product"""
    name = models.CharField(blank=True, max_length=100)
    sites = models.ManyToManyField(Site)

    class Meta:
        app_label = 'recommends'

    def __str__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('product_detail', [self.id])

    def sites_str(self):
        return ', '.join([s.name for s in self.sites.all()])
    sites_str.short_description = 'sites'


@python_2_unicode_compatible
class RecVote(models.Model):
    """A Vote on a Product"""
    user = models.ForeignKey(auth_models.User, related_name='rec_votes')
    product = models.ForeignKey(RecProduct)
    site = models.ForeignKey(Site)
    score = models.FloatField()

    class Meta:
        app_label = 'recommends'

    def __str__(self):
        return "Vote"

########NEW FILE########
__FILENAME__ = providers
from django.conf import settings
from django.contrib.auth.models import User
from recommends.providers import RecommendationProvider
from recommends.providers import recommendation_registry
try:
    from recommends.storages.mongodb.storage import MongoStorage
except ImportError:
    MongoStorage = None
try:
    from recommends.storages.redis.storage import RedisStorage
except ImportError:
    RedisStorage = None
try:
    from recommends.algorithms.pyrecsys import RecSysAlgorithm
except ImportError:
    RecSysAlgorithm = None
try:
    from recommends.tasks import recommends_precompute
except ImportError:
    recommends_precompute = None

if recommends_precompute is not None:
    from recommends.tests.tests import RecommendsTestCase

from recommends.tests.models import RecProduct, RecVote


class ProductRecommendationProvider(RecommendationProvider):

    def get_users(self):
        return User.objects.filter(is_active=True, rec_votes__isnull=False).distinct()

    def get_items(self):
        return RecProduct.objects.all()

    def get_ratings(self, obj):
        return RecVote.objects.filter(product=obj)

    def get_rating_score(self, rating):
        return rating.score

    def get_rating_site(self, rating):
        return rating.site

    def get_rating_user(self, rating):
        return rating.user

    def get_rating_item(self, rating):
        return rating.product

recommendation_registry.register(
    RecVote,
    [RecProduct],
    ProductRecommendationProvider)


class GhettoRecommendationProvider(RecommendationProvider):

    def get_users(self):
        return User.objects.filter(is_active=True, rec_votes__isnull=False).distinct()

    def get_items(self):
        return RecProduct.objects.all()

    def get_ratings(self, obj):
        return RecVote.objects.filter(product=obj)

    def get_rating_score(self, rating):
        return rating.score

    def get_rating_site(self, rating):
        return rating.site

    def get_rating_user(self, rating):
        return rating.user

    def get_rating_item(self, rating):
        return rating.product


if recommends_precompute is not None and RecSysAlgorithm is not None and getattr(settings, 'RECOMMENDS_TEST_RECSYS', False):
    class RecSysRecommendationProvider(ProductRecommendationProvider):
        algorithm = RecSysAlgorithm()

    class RecSysAlgoTestCase(RecommendsTestCase):
        results = {
            'len_recommended': 4,
            'len_similar_to_mug': 5
        }

        def setUp(self):
            recommendation_registry.unregister(
                RecVote,
                [RecProduct],
                ProductRecommendationProvider)
            recommendation_registry.register(
                RecVote,
                [RecProduct],
                RecSysRecommendationProvider)
            super(RecSysAlgoTestCase, self).setUp()

        def tearDown(self):
            super(RecSysAlgoTestCase, self).tearDown()
            recommendation_registry.unregister(
                RecVote,
                [RecProduct],
                RecSysRecommendationProvider)
            recommendation_registry.register(
                RecVote,
                [RecProduct],
                ProductRecommendationProvider)

if recommends_precompute is not None and RedisStorage is not None and getattr(settings, 'RECOMMENDS_TEST_REDIS', False):
    class RedisRecommendationProvider(GhettoRecommendationProvider):
        storage = RedisStorage(settings=settings)

    class RecommendsRedisStorageTestCase(RecommendsTestCase):

        def setUp(self):
            recommendation_registry.unregister(
                RecVote,
                [RecProduct],
                ProductRecommendationProvider)
            recommendation_registry.register(
                RecVote,
                [RecProduct],
                RedisRecommendationProvider)
            super(RecommendsRedisStorageTestCase, self).setUp()

        def tearDown(self):
            super(RecommendsRedisStorageTestCase, self).tearDown()
            recommendation_registry.unregister(
                RecVote,
                [RecProduct],
                RedisRecommendationProvider)
            recommendation_registry.register(
                RecVote,
                [RecProduct],
                ProductRecommendationProvider)

if recommends_precompute is not None and MongoStorage is not None and getattr(settings, 'RECOMMENDS_TEST_MONGO', False):
    class MongoRecommendationProvider(GhettoRecommendationProvider):
        storage = MongoStorage(settings=settings)

    class RecommendsMongoStorageTestCase(RecommendsTestCase):

        def setUp(self):
            recommendation_registry.unregister(
                RecVote,
                [RecProduct],
                ProductRecommendationProvider)
            recommendation_registry.register(
                RecVote,
                [RecProduct],
                MongoRecommendationProvider)
            super(RecommendsMongoStorageTestCase, self).setUp()

        def tearDown(self):
            super(RecommendsMongoStorageTestCase, self).tearDown()
            recommendation_registry.unregister(
                RecVote,
                [RecProduct],
                MongoRecommendationProvider)
            recommendation_registry.register(
                RecVote,
                [RecProduct],
                ProductRecommendationProvider)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import sys
from os import path

from django.conf import settings

PROJECT_DIR = path.dirname(path.realpath(__file__))


settings.configure(
    DATABASES={
        'default': {'ENGINE': 'django.db.backends.sqlite3'}
    },
    INSTALLED_APPS=[
        'django.contrib.auth',
        'django.contrib.sessions',
        'django.contrib.contenttypes',
        'django.contrib.sites',
        'recommends',
        'recommends.storages.djangoorm',
        'recommends.tests',
    ],
    ROOT_URLCONF='recommends.tests.urls',
    TEMPLATE_DIRS=(
        path.join(PROJECT_DIR, 'templates'),
    ),
    BROKER_URL='redis://localhost:6379/0',
    CELERY_ALWAYS_EAGER=True,
    ALLOWED_HOSTS=['*'],
    SITE_ID=1,
    RECOMMENDS_TEST_REDIS=True,
    RECOMMENDS_TEST_MONGO=True,
    RECOMMENDS_TEST_RECSYS=True,
    RECOMMENDS_STORAGE_MONGODB_FSYNC=True,
    RECOMMENDS_TASK_RUN=True,
)


def runtests(*test_args):
    import django.test.utils
    runner_class = django.test.utils.get_runner(settings)
    test_runner = runner_class(verbosity=1, interactive=True)
    failures = test_runner.run_tests(['recommends'])
    sys.exit(failures)

if __name__ == '__main__':
    runtests()

########NEW FILE########
__FILENAME__ = settings
from os import path
# Django settings for example_project project.
PROJECT_DIR = path.dirname(path.realpath(__file__))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
    #    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '91tj&kv4c5(8f1t_@c0hs-%bkp7r4e*bmjet3ph=8-6iw#v7kq'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
    #     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'recommends.tests.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    path.join(PROJECT_DIR, 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'recommends',
    'recommends.storages.djangoorm',
    'recommends.tests',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}

CELERY_ALWAYS_EAGER = True
ALLOWED_HOSTS = ['*']

BROKER_URL = 'redis://localhost:6379/0'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': ':memory:',
        # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',
        # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',
        # Set to empty string for default. Not used with sqlite3.
    }
}

RECOMMENDS_TEST_RECSYS = True

########NEW FILE########
__FILENAME__ = tests
import timeit
from django.test import TestCase
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.test import Client
from recommends.providers import recommendation_registry
from recommends.tasks import recommends_precompute
from .models import RecProduct, RecVote
from django.test.utils import override_settings
import os


@override_settings(CELERY_DB_REUSE_MAX=200, LANGUAGES=(
    ('en', 'English'),),
    LANGUAGE_CODE='en',
    TEMPLATE_DIRS=(
        os.path.join(os.path.dirname(__file__), 'templates'),),
    TEMPLATE_LOADERS=('django.template.loaders.filesystem.Loader',),
    USE_TZ=False, )
class RecommendsTestCase(TestCase):
    fixtures = ['products.json']
    urls = 'recommends.tests.urls'

    results = {
        'len_recommended': 2,
        'len_similar_to_mug': 2
    }

    def setUp(self):
        self.client = Client()
        self.mug = RecProduct.objects.get(name='Coffee Mug')
        self.orange_juice = RecProduct.objects.get(name='Orange Juice')
        self.wine = RecProduct.objects.get(name='Bottle of Red Wine')
        RecProduct.objects.get(name='1lb Tenderloin Steak').delete()
        self.user1 = User.objects.get(username='user1')

        from django.template import loader
        loader.template_source_loaders = None

        self.provider = recommendation_registry.get_provider_for_content(RecProduct)
        recommends_precompute()

    def tearDown(self):
        from django.template import loader
        loader.template_source_loaders = None
        super(RecommendsTestCase, self).tearDown()

    def isObjectWithIdExists(self, object_id):
        return RecProduct.objects.filter(id=object_id).exists()

    def test_similarities(self):
        # test similarities objects
        similar_to_mug = self.provider.storage.get_similarities_for_object(self.mug)
        self.assertNotEquals(len(similar_to_mug), 0)
        self.assertEquals(len(similar_to_mug), self.results['len_similar_to_mug'])
        self.assertTrue(self.wine in [s.related_object for s in similar_to_mug])
        # Make sure we didn't get all 0s
        zero_scores = filter(lambda x: x.score == 0, similar_to_mug)
        self.assertNotEquals(len(zero_scores), len(similar_to_mug))

    def test_similarities_raw_ids(self):
        # test similarities raw ids
        similar_to_mug_ids = self.provider.storage.get_similarities_for_object(self.mug, raw_id=True)
        self.assertNotEquals(len(similar_to_mug_ids), 0)
        self.assertEquals(len(similar_to_mug_ids), self.results['len_similar_to_mug'])
        similar_to_mug_related_ids = [item['related_object_id'] for item in similar_to_mug_ids]
        self.assertTrue(self.wine.id in similar_to_mug_related_ids)
        self.assertTrue(all([self.isObjectWithIdExists(related_object_id) for related_object_id in similar_to_mug_related_ids]))

    def test_recommendation(self):
        # test recommendations
        recommendations = self.provider.storage.get_recommendations_for_user(self.user1)
        self.assertNotEquals(len(recommendations), 0)
        self.assertEquals(len(recommendations), self.results['len_recommended'])
        self.assertTrue(self.wine in [s.object for s in recommendations])
        # Make sure we didn't get all 0s
        zero_scores = filter(lambda x: x.score == 0, recommendations)
        self.assertNotEquals(len(zero_scores), len(recommendations))
        # Make sure we don't recommend item that the user already have
        self.assertFalse(self.mug in [v.product for v in RecVote.objects.filter(user=self.user1)])

    def test_recommendation_raw_ids(self):
        # test recommendation raw ids
        recommendation_ids = self.provider.storage.get_recommendations_for_user(self.user1, raw_id=True)
        self.assertNotEquals(len(recommendation_ids), 0)
        self.assertEquals(len(recommendation_ids), self.results['len_recommended'])
        recommendation_object_ids = [item['object_id'] for item in recommendation_ids]
        self.assertTrue(self.wine.id in recommendation_object_ids)
        self.assertTrue(all([self.isObjectWithIdExists(object_id) for object_id in recommendation_object_ids]))

    def test_views(self):
        self.client.login(username='user1', password='user1')

        response = self.client.get(self.mug.get_absolute_url())
        self.assertTrue(self.orange_juice.get_absolute_url() in response.content)

    def _test_performance(self):
        stmt = """recommends_precompute()"""
        setup = """from recommends.tasks import recommends_precompute"""
        print "timing..."
        times = timeit.repeat(stmt, setup, number=100)
        print times


class RecommendsListenersTestCase(TestCase):
    fixtures = ['products.json']

    def setUp(self):
        self.client = Client()
        self.mug = RecProduct.objects.get(name='Coffee Mug')
        self.orange_juice = RecProduct.objects.get(name='Orange Juice')
        self.wine = RecProduct.objects.get(name='Bottle of Red Wine')
        self.steak = RecProduct.objects.get(name='1lb Tenderloin Steak')
        self.user1 = User.objects.get(username='user1')

        self.provider = recommendation_registry.get_provider_for_content(RecProduct)

        recommends_precompute()

    def test_listeners(self):
        self.client.login(username='user1', password='user1')
        response = self.client.get(reverse('home'))

        self.vote = RecVote.objects.create(
            user=self.user1,
            product=self.steak,
            site_id=1,
            score=1
        )

        response = self.client.get(reverse('home'))
        steak_url = self.steak.get_absolute_url()
        self.assertTrue(steak_url in response.content)
        recommendations = self.provider.storage.get_recommendations_for_user(self.user1)
        steak_recs = filter(lambda x: x.object_id == self.steak.id, recommendations)
        self.assertEqual(1L, len(steak_recs))

        self.steak.delete()

        response = self.client.get(reverse('home'))
        self.assertFalse(steak_url in response.content)
        recommendations = self.provider.storage.get_recommendations_for_user(self.user1)
        steak_recs = filter(lambda x: x.object_id == self.steak.id, recommendations)
        self.assertEqual(0L, len(steak_recs))

    def tearDown(self):
        self.vote.delete()
        recommends_precompute()

########NEW FILE########
__FILENAME__ = urls
try:
    from django.conf.urls.defaults import patterns, include, url
except ImportError:
    from django.conf.urls import patterns, include, url
from django.views.generic import TemplateView, DetailView
from .models import RecProduct


# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'example_project.views.home', name='home'),
    # url(r'^example_project/',
    # include('example_project.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/',
    # include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    url(r'^login/',
        'recommends.tests.views.login', name='login'),
    url(r'^product/(?P<pk>\d+)/$',
        DetailView.as_view(
            model=RecProduct), name='product_detail'),
    url(r'^$', TemplateView.as_view(
        template_name='home.html'), name='home'),
)

########NEW FILE########
__FILENAME__ = views
# Create your views here.
from django.contrib.auth import authenticate, login as _login
from django.http import HttpResponseRedirect


def login(request):
    username = request.POST['username']
    password = request.POST['password']
    user = authenticate(username=username, password=password)
    if user is not None:
        if user.is_active:
            _login(request, user)
            # redirect to a success page.
        else:
            # Return a 'disabled account' error message
            pass
    else:
        pass
        # Return an 'invalid login' error message.
    return HttpResponseRedirect(request.POST.get('next', '/'))

########NEW FILE########
__FILENAME__ = utils
import contextlib
import errno
import os
import time
import tempfile
from django.utils import importlib


def import_from_classname(class_name_str):
    module, class_name = class_name_str.rsplit('.', 1)
    Class = getattr(importlib.import_module(module), class_name)
    return Class


def ctypes_dict():
    from django.contrib.contenttypes.models import ContentType

    values = ContentType.objects.values_list('app_label', 'model', 'id')
    ctypes = {}
    [ctypes.update({"%s.%s" % x[:2]: x[2]}) for x in values]
    return ctypes


@contextlib.contextmanager
def filelock(name, wait_delay=.1):
    path = os.path.join(tempfile.gettempdir(), name)
    while True:
        try:
            fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_RDWR)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
            time.sleep(wait_delay)
            continue
        else:
            break
    try:
        yield fd
    finally:
        os.close(fd)
        os.unlink(path)

########NEW FILE########
