__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# ToscaWidgets 2 documentation build configuration file, created by
# sphinx-quickstart on Tue Mar 10 11:38:11 2009.
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# General configuration
# ---------------------
# import Cloud
import cloud_sptheme as csp

# ... some contents omitted ...

# set the html theme
html_theme = "cloud"

# ... some contents omitted ...

# set the theme path to point to cloud's theme data
html_theme_path = [csp.get_theme_dir()]

# [optional] set some of the options listed above...
html_theme_options = {
    "sidebarwidth":     "200px",
    "max_width":        "900px",
    "compact_width":    "800px",
    "minimal_width":    "700px",

    # Style it like Fedora..
    "bodyfont":         "Cantarell",

    "highlightcolor":   "#4FAF4F",

    "sidebarbgcolor":   "#FEFEFE",
    "sidebartrimcolor": "#FEFEFE",

    "sectionbgcolor":   "#FEFEFE",
    "sectiontrimcolor": "#FEFEFE",
    "sectiontextcolor": "#444444",

    "relbarbgcolor":    "#FEFEFE",
    "relbartextcolor":  "#444444",
    "relbarlinkcolor":  "#444444",

    "bgcolor":          "#FEFEFE",
    "textcolor":        "#444444",
    "linkcolor":        "#060",  # First Green

    "headtextcolor":    "#444444",
    "headlinkcolor":    "#444444",

    #"codebgcolor"
    #"codetextcolor"
    "codetrimcolor":    "#060",  # First Green

    "footerbgcolor":    "#FEFEFE",

}


# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Fedora Messaging'
copyright = u'2012 - 2014 Red Hat, Inc. and others.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

# TODO -- read this from the README.rst file
version = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'site.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    '**': [
        'fedmsg-logo.html',
        'localtoc.html',
        'relations.html',
        'githubedit.html',
    ],
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'fedmsg'

########NEW FILE########
__FILENAME__ = fedmsg_koji
# Koji callback for sending notifications about events to the fedmsg messagebus
# Copyright (c) 2009-2012 Red Hat, Inc.
#
# Authors:
#     Ralph Bean <rbean@redhat.com>
#     Mike Bonnet <mikeb@redhat.com>

from koji.plugin import callbacks
from koji.plugin import callback
from koji.plugin import ignore_error

import fedmsg
import kojihub
import re

# Talk to the fedmsg-relay
fedmsg.init(name='relay_inbound', cert_prefix='koji', active=True)

MAX_KEY_LENGTH = 255


def camel_to_dots(name):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1.\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1.\2', s1).lower()


def get_message_body(topic, *args, **kws):
    msg = {}

    if topic == 'package.list.change':
        msg['tag'] = kws['tag']['name']
        msg['package'] = kws['package']['name']
    elif topic == 'task.state.change':
        msg['method'] = kws['info']['method']
        msg['attribute'] = kws['attribute']
        msg['old'] = kws['old']
        msg['new'] = kws['new']
        msg['owner'] = kojihub.get_user(kws['info']['owner'])['name']
        msg['id'] = kws['info']['id']
    elif topic == 'build.state.change':
        info = kws['info']
        msg['name'] = info['name']
        msg['version'] = info['version']
        msg['release'] = info['release']
        msg['attribute'] = kws['attribute']
        msg['old'] = kws['old']
        msg['new'] = kws['new']
    elif topic == 'import':
        msg['type'] = kws['type']
    elif topic in ('tag', 'untag'):
        msg['tag'] = kws['tag']['name']
        build = kws['build']
        msg['name'] = build['name']
        msg['version'] = build['version']
        msg['release'] = build['release']
        msg['user'] = kws['user']['name']
    elif topic == 'repo.init':
        msg['tag'] = kws['tag']['name']
    elif topic == 'repo.done':
        msg['tag'] = kws['repo']['tag_name']

    return msg


# This callback gets run for every koji event that starts with "post"
@callback(*[c for c in callbacks.keys() if c.startswith('post')])
@ignore_error
def send_message(cbtype, *args, **kws):
    if cbtype.startswith('post'):
        msgtype = cbtype[4:]
    else:
        msgtype = cbtype[3:]

    topic = camel_to_dots(msgtype)
    body = get_message_body(topic, *args, **kws)

    fedmsg.publish(topic=topic, msg=body, modname='koji')

########NEW FILE########
__FILENAME__ = mass-sub
#!/usr/bin/env python
""" Subscribe to the public gateway N times.

It echoes a command to watch a count of file descriptors.  Run it.  When its
maxxed out, that's when its time to echo a message remotely.

scp this to remote worker nodes and launch them all at the same time with
"./master.sh"

"""

import sys
import os
import time
import zmq
import socket
import threading


# this is dumb!
N = 63

prefix = '[' + socket.gethostname().center(15) + ']'

ctx = zmq.Context()

start = time.time()


class ThreadedJob(threading.Thread):
    def run(self):
        self.ctx = ctx
        self.s = self.ctx.socket(zmq.SUB)
        connect_to = "tcp://hub.fedoraproject.org:9940"
        self.s.connect(connect_to)
        self.s.setsockopt(zmq.SUBSCRIBE, '')
        topic, msg = self.s.recv_multipart()
        sys.stdout.flush()

threads = [ThreadedJob() for i in range(N)]
for thread in threads:
    thread.start()

pid = os.getpid()
print prefix, "Checking pid", pid
target = 200
length = 0
while length <= target:
    length = len(os.listdir("/proc/%i/fd/" % os.getpid()))
    print prefix, length, "is less than", target
    time.sleep(1)

print prefix, "ready to receive..."

for thread in threads:
    thread.join()

print prefix, "Done."

########NEW FILE########
__FILENAME__ = announce
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import sys

import fedmsg
from fedmsg.commands import BaseCommand


class AnnounceCommand(BaseCommand):
    """
    Emit an announcement message to the FI bus.

    Example::

        $ echo "Fedora Core 4 has been declared GOLD" | fedmsg-announce \
                --link http://fedoraproject.org/news

    Technically this command is a simpler version of fedmsg-logger that emits
    on a special topic.  It is expected that :term:`routing_policy` is
    specified such that only restricted parties can issue fedmsg announcements.

    This command expects its message to come from stdin.
    """

    name = "fedmsg-announce"
    extra_args = [
        (['--link'], {
            'dest': 'link',
            'metavar': "URL",
            'default': None,
            'help': "Specify a link to go along with the announcement.",
        }),
    ]

    def run(self):
        # This specifies that a special certificate should be used to sign this
        # message.  At the sysadmin level, you are responsible for taking care
        # of two things:
        #   1) That the announce cert is readable only by appropriate persons.
        #   2) That the routing_policy is setup so that "announce.announcement"
        #      messages are valid only if signed by such a certificate.
        self.config['cert_prefix'] = "announce"

        # This just specifies that we should be talking to the fedmsg-relay.
        self.config['active'] = True
        self.config['name'] = 'relay_inbound'
        fedmsg.init(**self.config)

        # Read in and setup our message.  Include --link, even if it is None.
        message = "\n".join(map(str.strip, sys.stdin.readlines()))
        msg = dict(message=message, link=self.config['link'])

        # Fire!
        fedmsg.publish(modname="announce", topic="announcement", msg=msg)


def announce():
    command = AnnounceCommand()
    command.execute()

########NEW FILE########
__FILENAME__ = collectd
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import datetime
import socket
import time

import fedmsg
import fedmsg.meta

from fedmsg.commands import BaseCommand
from fedmsg.consumers import FedmsgConsumer
from moksha.hub.api import PollingProducer


class CollectdConsumer(FedmsgConsumer):
    config_key = "fedmsg.commands.collectd.enabled"
    validate_messages = False

    def __init__(self, hub):
        self.hub = hub

        # The consumer should pick up *all* messages.
        self.topic = self.hub.config.get('topic_prefix', 'org.fedoraproject')
        if not self.topic.endswith('*'):
            self.topic += '*'

        super(CollectdConsumer, self).__init__(hub)
        self._dict = dict([
            (p.__name__.lower(), 0) for p in fedmsg.meta.processors
        ])
        self.host = socket.gethostname().split('.')[0]

    def consume(self, msg):
        processor = fedmsg.meta.msg2processor(msg, **self.hub.config)
        modname = processor.__name__.lower()
        self._dict[modname] += 1

    def dump(self):
        """ Called by CollectdProducer every `n` seconds. """

        # Print out the collectd feedback.
        # This is sent to stdout while other log messages are sent to stderr.
        for k, v in sorted(self._dict.items()):
            print self.formatter(k, v)

        # Reset each entry to zero
        for k, v in sorted(self._dict.items()):
            self._dict[k] = 0

    def formatter(self, key, value):
        """ Format messages for collectd to consume. """
        template = "PUTVAL {host}/fedmsg/fedmsg_wallboard-{key} " +\
            "interval={interval} {timestamp}:{value}"
        timestamp = int(time.time())
        interval = self.hub.config['collectd_interval']
        return template.format(
            host=self.host,
            timestamp=timestamp,
            value=value,
            interval=interval,
            key=key,
        )


class CollectdProducer(PollingProducer):
    # "Frequency" is set later at runtime.
    def poll(self):
        self.hub.consumers[0].dump()


class CollectdCommand(BaseCommand):
    """ Print machine-readable information for collectd to monitor the bus. """
    name = "fedmsg-collectd"
    extra_args = [
        (['--collectd-interval'], {
            'dest': 'collectd_interval',
            'type': int,
            'help': 'Number of seconds to sleep between collectd updates.',
            'default': 2,
        }),
    ]

    def run(self):
        # Initialize the processors before CollectdConsumer is instantiated.
        fedmsg.meta.make_processors(**self.config)

        # Do just like in fedmsg.commands.hub and mangle fedmsg-config.py
        # to work with moksha's expected configuration.
        moksha_options = dict(
            mute=True,  # Disable some warnings.
            zmq_subscribe_endpoints=','.join(
                ','.join(bunch) for bunch in self.config['endpoints'].values()
            ),
        )
        self.config.update(moksha_options)
        self.config[CollectdConsumer.config_key] = True

        CollectdProducer.frequency = datetime.timedelta(
            seconds=self.config['collectd_interval']
        )

        from moksha.hub import main
        main(self.config, [CollectdConsumer], [CollectdProducer],
             framework=False)


def collectd():
    command = CollectdCommand()
    command.execute()

########NEW FILE########
__FILENAME__ = config
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
# Copyright (C) 2014 Nicolas Dandrimont <olasd@debian.org>
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#           Nicolas Dandrimont <olasd@debian.org>
#
from __future__ import print_function

import argparse
import six
import sys
import textwrap

import fedmsg.config
import fedmsg.encoding


def config():
    __doc__ = """
    Query or print the parsed fedmsg-config.

    fedmsg-config is a simple utility that prints out the contents of
    the fully parsed fedmsg config as a JSON dictionary.

    The tool allows you to query a specific configuration key with the
    --query option. It returns an error code of 1 if the key isn't
    found.

    In query mode, the configuration key has the following syntax:
    foo.bar.baz retrieves the value of config["foo"]["bar"]["baz"]

    If the configuration value is an atomic value, it is printed
    directly. If the value is a list, each item gets printed line by
    line. Else, the value is printed as a JSON dictionary.
    """

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        prog=sys.argv[0],
    )

    parser.add_argument(
        '--config-filename',
        dest='config_filename',
        help="Config file to use.",
        default=None,
    )

    parser.add_argument(
        '--disable-defaults',
        dest='disable_defaults',
        help="Disable the configuration defaults.",
        action="store_true",
    )

    parser.add_argument(
        '--query',
        dest='query',
        help="The key to dump from the given config.",
        type=str,
        default=None
    )

    args = parser.parse_args()

    filenames = None
    if args.config_filename:
        filenames = [args.config_filename]

    config = fedmsg.config.load_config(
        extra_args=[],
        doc=__doc__,
        filenames=filenames,
        disable_defaults=args.disable_defaults,
    )

    cur = config

    if args.query:
        cur = fedmsg.utils.dict_query(cur, args.query)[args.query]
        if cur is None:
            print ("Key `%s` does not exist in config" % args.query,
                   file=sys.stderr)
            sys.exit(1)

    if isinstance(cur, list):
        for i in cur:
            print(i)
    elif isinstance(cur, six.string_types):
        print(cur)
    else:
        print(fedmsg.encoding.pretty_dumps(cur))

########NEW FILE########
__FILENAME__ = gateway
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
"""
"""

import fedmsg
from fedmsg.commands import BaseCommand
from fedmsg.consumers.gateway import GatewayConsumer


class GatewayCommand(BaseCommand):
    """ Rebroadcast messages to a special zmq endpoint.

    A repeater that rebroadcasts all messages received to a special zmq
    endpoint.  This is used to get messages from inside Fedora Infrastructure
    out to users.  Its communication is uni-directional.  It does not relay
    messages from "outside the bus" back in.

    The special zmq endpoint is specified by the presence of
    :term:`fedmsg.consumers.gateway.port` in the config.

    This service is what makes using ":doc:`consuming`" outside the
    VPN/firewalled bus environment possible.
    """
    name = 'fedmsg-gateway'
    daemonizable = True
    extra_args = []

    def run(self):
        # Do just like in fedmsg.commands.hub and mangle fedmsg-config.py
        # to work with moksha's expected configuration.
        moksha_options = dict(
            zmq_subscribe_endpoints=','.join(
                ','.join(bunch) for bunch in
                self.config['endpoints'].values()
            ),
        )
        self.config.update(moksha_options)

        # Flip the special bit that allows the GatewayConsumer to run
        self.config[GatewayConsumer.config_key] = True

        from moksha.hub import main
        main(
            # Pass in our config dict
            options=self.config,
            # Only run this *one* consumer
            consumers=[GatewayConsumer],
            # Tell moksha to quiet its logging.
            framework=False,
        )


def gateway():
    command = GatewayCommand()
    command.execute()

########NEW FILE########
__FILENAME__ = hub
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import fedmsg
from fedmsg.utils import load_class
from fedmsg.commands import BaseCommand


class HubCommand(BaseCommand):
    """ Run the fedmsg hub.

    ``fedmsg-hub`` is the all-purpose daemon.  This should be run on every host
    that has services which declare their own consumers.  ``fedmsg-hub`` will
    listen to every endpoint discovered by :mod:`fedmsg.config` and forward
    messages in-process to the locally-declared consumers.  It is a thin
    wrapper over a moksha-hub.

    Other commands like ``fedmsg-irc`` are just specialized, restricted
    versions of ``fedmsg-hub``.  ``fedmsg-hub`` is the most general/abstract.

    ``fedmsg-hub`` also houses the functions to run a websocket server.

    """
    name = 'fedmsg-hub'
    daemonizable = True
    extra_args = [
        (['--with-consumers'], {
            'dest': 'explicit_hub_consumers',
            'type': str,
            'help': 'A comma-delimited list of conumers to run.',
            'default': None,
        }),
        (['--websocket-server-port'], {
            'dest': 'moksha.livesocket.websocket.port',
            'type': int,
            'help': 'Port on which to host the websocket server.',
            'default': None,
        }),
    ]

    def run(self):
        # Check if the user wants the websocket server to run
        if self.config['moksha.livesocket.websocket.port']:
            self.config['moksha.livesocket.backend'] = 'websocket'

        # If the user wants to override any consumers installed on the system
        # and *only* run the ones they want to, they can do that.
        consumers = None
        if self.config['explicit_hub_consumers']:
            locations = self.config['explicit_hub_consumers'].split(',')
            locations = [load_class(location) for location in locations]

        # Rephrase the fedmsg-config.py config as moksha *.ini format.
        # Note that the hub we kick off here cannot send any message.  You
        # should use fedmsg.publish(...) still for that.
        moksha_options = dict(
            zmq_subscribe_endpoints=','.join(
                ','.join(bunch) for bunch in self.config['endpoints'].values()
            ),
        )
        self.config.update(moksha_options)

        from moksha.hub import main
        main(
            # Pass in our config dict
            options=self.config,
            # Only run the specified consumers if any are so specified.
            consumers=consumers,
            # Tell moksha to quiet its logging.
            framework=False,
        )


def hub():
    command = HubCommand()
    command.execute()

########NEW FILE########
__FILENAME__ = ircbot
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#           Ryan Brown
#
# -*- coding; utf-8 -*-
"""
Description: A bot that takes a config and puts messages matching given
regexes in specified IRC channels.  See :term:`irc` for options.

Think of it like a one-way firehose that spews fedmsg messages to IRC.
"""

from fedmsg.commands import BaseCommand
from fedmsg.consumers.ircbot import IRCBotConsumer


class IRCCommand(BaseCommand):
    """ Relay messages from the bus to any number of IRC channels.

    This is highly configurable by way of the :term:`irc` config value.
    """

    name = "fedmsg-irc"
    extra_args = []
    daemonizable = True

    def run(self):
        # Do just like in fedmsg.commands.hub and mangle fedmsg-config.py to
        # work with moksha's expected configuration.
        moksha_options = dict(
            zmq_subscribe_endpoints=','.join(
                ','.join(bunch) for bunch in self.config['endpoints'].values()
            ),
        )
        self.config.update(moksha_options)

        self.config[IRCBotConsumer.config_key] = True

        from moksha.hub import main
        main(
            # Pass in our config dict
            options=self.config,
            # Only run this *one* consumer
            consumers=[IRCBotConsumer],
            # Tell moksah to quiet its logging
            framework=False,
        )


def ircbot():
    command = IRCCommand()
    command.execute()

########NEW FILE########
__FILENAME__ = logger
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import sys

import fedmsg
import fedmsg.encoding
from fedmsg.commands import BaseCommand


class LoggerCommand(BaseCommand):
    """
    Emit log messages to the FI bus.

    If the fedmsg-relay service is not running at the address specified in
    the config, then this command will *hang* until that service becomes
    available.

    If --message is not specified, this command accepts messages from stdin.

    Some examples::

        $ echo '{"a": 1}; | fedmsg-logger --json-input
        $ echo "Hai there." | fedmsg-logger --modname=git --topic=repo.update
        $ fedmsg-logger --message="This is a message."
        $ fedmsg-logger --message='{"a": 1}' --json-input

    Note that when using --json-input, you must send valid JSON, including
    the use of double quotes as opposed to single quotes:

        '{"a": 1}' is good.
        "{'a': 1}" is bad.

    """
    name = 'fedmsg-logger'
    extra_args = [
        (['--message'], {
            'dest': 'logger_message',
            'help': "The message to send.",
        }),
        (['--json-input'], {
            'dest': 'json_input',
            'action': 'store_true',
            'default': False,
            'help': "Take each line of input as JSON.",
        }),
        (['--topic'], {
            'dest': 'topic',
            'metavar': "TOPIC",
            'default': "log",
            'help': "Think org.fedoraproject.dev.logger.TOPIC",
        }),
        (['--modname'], {
            'dest': 'modname',
            'metavar': "MODNAME",
            'default': "logger",
            'help': "More control over the topic. Think org.fp.MODNAME.TOPIC.",
        }),
        (['--cert-prefix'], {
            'dest': 'cert_prefix',
            'metavar': "CERT_PREFIX",
            'default': "shell",
            'help': "Specify a different cert from /etc/pki/fedmsg",
        }),
    ]

    def _log_message(self, kw, message):
        if kw['json_input']:
            msg = fedmsg.encoding.loads(message)
        else:
            msg = {'log': message}

        fedmsg.publish(
            topic=kw['topic'],
            msg=msg,
            modname=kw['modname'],
        )

    def __init__(self):
        super(LoggerCommand, self).__init__()

    def run(self):
        self.config['active'] = True
        self.config['name'] = 'relay_inbound'
        fedmsg.init(**self.config)

        if self.config.get('logger_message'):
            self._log_message(self.config, self.config.get('logger_message'))
        else:
            line = sys.stdin.readline()
            while line:
                self._log_message(self.config, line.strip())
                line = sys.stdin.readline()


def logger():
    command = LoggerCommand()
    return command.execute()

########NEW FILE########
__FILENAME__ = relay
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
"""
"""

import zmq

from fedmsg.commands import BaseCommand
from fedmsg.consumers.relay import RelayConsumer

from kitchen.iterutils import iterate


class RelayCommand(BaseCommand):
    """ Relay connections from active loggers to the bus.

    ``fedmsg-relay`` is a service which binds to two ports, listens for
    messages on one and emits them on the other.  ``fedmsg-logger``
    requires that an instance of ``fedmsg-relay`` be running *somewhere*
    and that it's inbound address be listed in the config as one of the entries
    in :term:`relay_inbound`.

    ``fedmsg-relay`` becomes a necessity for integration points that cannot
    bind consistently to and serve from a port.  See :doc:`topology` for the
    mile-high view.  More specifically, ``fedmsg-relay`` is a
    SUB.bind()->PUB.bind() relay.
    """
    daemonizable = True
    name = 'fedmsg-relay'

    def run(self):
        # Do just like in fedmsg.commands.hub and mangle fedmsg.d/ to work
        # with moksha's expected configuration.
        moksha_options = dict(
            zmq_subscribe_endpoints=",".join(list(iterate(
                self.config['relay_inbound']
            ))),
            zmq_subscribe_method="bind",
        )
        self.config.update(moksha_options)

        # Flip the special bit that allows the RelayConsumer to run
        self.config[RelayConsumer.config_key] = True

        from moksha.hub import main
        for publish_endpoint in self.config['endpoints']['relay_outbound']:
            self.config['zmq_publish_endpoints'] = publish_endpoint
            try:
                return main(
                    # Pass in our config dict
                    options=self.config,
                    # Only run this *one* consumer
                    consumers=[RelayConsumer],
                    # Tell moksha to quiet its logging.
                    framework=False,
                )
            except zmq.ZMQError:
                self.log.debug("Failed to bind to %r" % publish_endpoint)

        raise IOError("Failed to bind to any outbound endpoints.")


def relay():
    command = RelayCommand()
    return command.execute()

########NEW FILE########
__FILENAME__ = tail
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>

import pprint
import re
import time
import sys

import pygments
import pygments.lexers
import pygments.formatters

import fedmsg
import fedmsg.encoding
import fedmsg.meta
from fedmsg.commands import BaseCommand


class TailCommand(BaseCommand):
    """ Watch all endpoints on the bus and print each message to stdout. """

    name = "fedmsg-tail"
    extra_args = [
        (['--topic'], {
            'dest': 'topic',
            'help': 'The topic pattern to listen for.  Everything by default.',
            'default': '',
        }),
        (['--query'], {
            'dest': 'query',
            'help': 'Displays only the element of the message specified.',
            'type': str,
            'default': None
        }),
        (['--pretty'], {
            'dest': 'pretty',
            'help': 'Pretty print the JSON messages.',
            'default': False,
            'action': 'store_true',
        }),
        (['--really-pretty'], {
            'dest': 'really_pretty',
            'help': 'Extra-pretty print the JSON messages.',
            'default': False,
            'action': 'store_true',
        }),
        (['--terse'], {
            'dest': 'terse',
            'help': 'Print "english" representations of messages only.',
            'default': False,
            'action': 'store_true',
        }),
        (['--exclude'], {
            'dest': 'exclusive_regexp',
            'metavar': 'REGEXP',
            'help': 'Only show topics that do not match the supplied regexp.',
            'default': '_heartbeat',
        }),
        (['--include'], {
            'dest': 'inclusive_regexp',
            'metavar': 'REGEXP',
            'help': 'Only show topics that match the supplied regexp.',
            'default': '^((?!_heartbeat).)*$',
        }),
        (['--users'], {
            'dest': 'users',
            'metavar': 'USERS',
            'default': None,
            'help': 'A comma-separated list of usernames.  Show only messages'
            'related to these users.',
        }),
        (['--packages'], {
            'dest': 'packages',
            'metavar': 'PACKAGES',
            'default': None,
            'help': 'A comma-separated list of packages.  Show only messages'
            'related to these packages.',
        }),
    ]

    def run(self):
        # Disable sending
        self.config['publish_endpoint'] = None

        # Disable timeouts.  We want to tail forever!
        self.config['timeout'] = 0

        # Even though fedmsg-tail won't be sending any messages, give it a
        # name to conform with the other commands.
        self.config['name'] = 'relay_inbound'

        # Tail is never going to send any messages, so we suppress warnings
        # about having no publishing sockets established.
        self.config['mute'] = True

        fedmsg.init(**self.config)

        # Build a message formatter
        formatter = lambda d: d
        if self.config['pretty']:
            def formatter(d):
                d['timestamp'] = time.ctime(d['timestamp'])
                d = fedmsg.crypto.strip_credentials(d)
                return "\n" + pprint.pformat(d)

        if self.config['really_pretty']:
            def formatter(d):
                d = fedmsg.crypto.strip_credentials(d)
                fancy = pygments.highlight(
                    fedmsg.encoding.pretty_dumps(d),
                    pygments.lexers.JavascriptLexer(),
                    pygments.formatters.TerminalFormatter()
                ).strip()
                return "\n" + fancy

        if self.config['query']:
            def formatter(d):
                result = fedmsg.utils.dict_query(d, self.config['query'])
                return ", ".join([unicode(value) for value in result.values()])

        if self.config['terse']:
            formatter = lambda d: "\n" + fedmsg.meta.msg2repr(d, **self.config)

        # Build regular expressions for use in our loop.
        exclusive_regexp = re.compile(self.config['exclusive_regexp'])
        inclusive_regexp = re.compile(self.config['inclusive_regexp'])

        # Build username and package filter sets for use in our loop.
        users, packages = set(), set()
        if self.config['users']:
            users = set(map(str.strip, self.config['users'].split(',')))
        if self.config['packages']:
            packages = set(map(str.strip, self.config['packages'].split(',')))

        # Only initialize this if we have to
        if users or packages or self.config['terse']:
            fedmsg.meta.make_processors(**self.config)

        # Spin up a zmq.Poller and yield messages
        for name, ep, topic, message in fedmsg.tail_messages(**self.config):
            if exclusive_regexp.search(topic):
                continue

            if not inclusive_regexp.search(topic):
                continue

            if users:
                actual = fedmsg.meta.msg2usernames(message, **self.config)
                if not users.intersection(actual):
                    continue

            if packages:
                actual = fedmsg.meta.msg2packages(message, **self.config)
                if not packages.intersection(actual):
                    continue

            output = formatter(message)
            if output:
                self.log.info(output)


def tail():
    command = TailCommand()
    return command.execute()

########NEW FILE########
__FILENAME__ = trigger
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>

import re
import subprocess
import sys

import fedmsg
import fedmsg.encoding
from fedmsg.commands import BaseCommand


class TriggerCommand(BaseCommand):
    """ Run a command whenever certain messages arrive.

    Feed the message to the given command over stdin.
    """

    name = "fedmsg-trigger"
    extra_args = [
        (['--topic'], {
            'dest': 'topic',
            'help': 'The topic pattern to listen for.  Everything by default.',
            'default': '',
        }),
        (['--exclude'], {
            'dest': 'exclusive_regexp',
            'metavar': 'REGEXP',
            'help': 'Only show topics that do not match the supplied regexp.',
            'default': '_heartbeat',
        }),
        (['--include'], {
            'dest': 'inclusive_regexp',
            'metavar': 'REGEXP',
            'help': 'Only show topics that match the supplied regexp.',
            'default': '^((?!_heartbeat).)*$',
        }),
        (['--command'], {
            'dest': 'command',
            'metavar': 'COMMAND',
            'help': 'Command to run when a message matches our criteria.',
            'default': None,
        }),
    ]

    def run_command(self, command, message):
        """ Use subprocess; feed the message to our command over stdin """
        proc = subprocess.Popen([
            'echo \'%s\' | %s' % (fedmsg.encoding.dumps(message), command)
        ], shell=True, executable='/bin/bash')
        return proc.wait()

    def run(self):

        # This is a "required" option... :P
        if not self.config['command']:
            self.log.error("You must provide a --command to run.")
            sys.exit(1)

        # Disable sending
        self.config['publish_endpoint'] = None

        # Disable timeouts.  We want to tail forever!
        self.config['timeout'] = 0

        # Even though fedmsg-trigger won't be sending any messages, give it a
        # name to conform with the other commands.
        self.config['name'] = 'relay_inbound'

        # Tail is never going to send any messages, so we suppress warnings
        # about having no publishing sockets established.
        self.config['mute'] = True

        fedmsg.init(**self.config)

        exclusive_regexp = re.compile(self.config['exclusive_regexp'])
        inclusive_regexp = re.compile(self.config['inclusive_regexp'])

        for name, ep, topic, message in fedmsg.tail_messages(**self.config):
            if exclusive_regexp.search(topic):
                continue

            if not inclusive_regexp.search(topic):
                continue

            result = self.run_command(self.config['command'], message)

            if result != 0:
                self.log.info("Command returned error code %r" % result)


def trigger():
    command = TriggerCommand()
    return command.execute()

########NEW FILE########
__FILENAME__ = config
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
""" :mod:`fedmsg.config` handles loading, processing and validation of
all configuration.

The configuration values used at runtime are determined by checking in
the following order

    - Built-in defaults
    - Config file (/etc/fedmsg-config.py)
    - Command line arguments

For example, if a config value does not appear in either the config file or on
the command line, then the built-in default is used.  If a value appears in
both the config file and as a command line argument, then the command line
value is used.

You can print the runtime configuration to the terminal by using the
``fedmsg-config`` command implemented by
:func:`fedmsg.commands.config.config`.
"""

import argparse
import collections
import copy
import os
import sys
import textwrap
import warnings

from kitchen.iterutils import iterate
from fedmsg.encoding import pretty_dumps


VALID_ENVIRONMENTS = ['dev', 'stg', 'prod']
bare_format = "[%(asctime)s][%(name)10s %(levelname)7s] %(message)s"

defaults = dict(
    topic_prefix="org.fedoraproject",
    environment="dev",
    io_threads=1,
    post_init_sleep=0.5,
    timeout=2,
    print_config=False,
    high_water_mark=0,  # zero means no limit
    zmq_linger=1000,    # Wait one second before timing out on fedmsg-relay
    active=False,       # generally only true for fedmsg-logger
    persistent_store=None,  # an object.  See the fedmsg.replay module.
    logging=dict(
        version=1,
        formatters=dict(
            bare={
                "datefmt": "%Y-%m-%d %H:%M:%S",
                "format": bare_format
            },
        ),
        handlers=dict(
            console={
                "class": "logging.StreamHandler",
                "formatter": "bare",
                "level": "INFO",
                "stream": "ext://sys.stdout",
            }
        ),
        loggers=dict(
            fedmsg={
                "level": "INFO",
                "propagate": False,
                "handlers": ["console"],
            },
            moksha={
                "level": "INFO",
                "propagate": False,
                "handlers": ["console"],
            },
        ),
    ),
)

__cache = {}


def load_config(extra_args=None,
                doc=None,
                filenames=None,
                invalidate_cache=False,
                fedmsg_command=False,
                disable_defaults=False):
    """ Setup a runtime config dict by integrating the following sources
    (ordered by precedence):

      - defaults (unless disable_defaults = True)
      - config file
      - command line arguments

    If the ``fedmsg_command`` argument is False, no command line arguments are
    checked.

    """
    global __cache

    if invalidate_cache:
        __cache = {}

    if __cache:
        return __cache

    # Coerce defaults if arguments are not supplied.
    extra_args = extra_args or []
    doc = doc or ""

    if not disable_defaults:
        config = copy.deepcopy(defaults)
    else:
        config = {}

    config.update(_process_config_file(filenames=filenames))

    # This is optional (and defaults to false) so that only 'fedmsg-*' commands
    # are required to provide these arguments.
    # For instance, the moksha-hub command takes a '-v' argument and internally
    # makes calls to fedmsg.  We don't want to impose all of fedmsg's CLI
    # option constraints on programs that use fedmsg, so we make it optional.
    if fedmsg_command:
        config.update(_process_arguments(extra_args, doc, config))

    # If the user specified a config file on the command line, then start over
    # but read in that file instead.
    if not filenames and config.get('config_filename', None):
        return load_config(extra_args, doc,
                           filenames=[config['config_filename']])

    # Just a little debug option.  :)
    if config.get('print_config'):
        print(pretty_dumps(config))
        sys.exit(0)

    if config.get('environment', 'prod') not in VALID_ENVIRONMENTS:
        raise ValueError("%r not one of %r" % (
            config['environment'], VALID_ENVIRONMENTS))

    if not disable_defaults and 'endpoints' not in config:
        raise ValueError("No config value 'endpoints' found.")

    if not isinstance(config.get('endpoints', {}), dict):
        raise ValueError("The 'endpoint' config value must be a dict.")

    if 'endpoints' in config:
        config['endpoints'] = dict([
            (k, list(iterate(v))) for k, v in config['endpoints'].items()
        ])

    if 'srv_endpoints' in config and len(config['srv_endpoints']) > 0:
        from dns.resolver import query, NXDOMAIN, Timeout, NoNameservers
        for e in config['srv_endpoints']:
            urls = []
            try:
                records = query('_fedmsg._tcp.{0}'.format(e), 'SRV')
            except NXDOMAIN:
                warnings.warn("There is no appropriate SRV records " +
                              "for {0}".format(e))
                continue
            except Timeout:
                warnings.warn("The DNS query for the SRV records of" +
                              " {0} timed out.".format(e))
                continue
            except NoNameservers:
                warnings.warn("No name server is available, please " +
                              "check the configuration")
                break

            for rec in records:
                urls.append('tcp://{hostname}:{port}'.format(
                    hostname=rec.target.to_text(),
                    port=rec.port
                ))
            config['endpoints'][e] = list(iterate(urls))

    if 'topic_prefix_re' not in config and 'topic_prefix' in config:
        # Turn "org.fedoraproject" into "org\.fedoraproject\.(dev|stg|prod)"
        config['topic_prefix_re'] = config['topic_prefix'].replace('.', '\.')\
            + '\.(%s)' % '|'.join(VALID_ENVIRONMENTS)

    __cache = config
    return config


def build_parser(declared_args, doc, config=None, prog=None):
    """ Return the global :class:`argparse.ArgumentParser` used by all fedmsg
    commands.

    Extra arguments can be supplied with the `declared_args` argument.
    """

    config = config or copy.deepcopy(defaults)
    prog = prog or sys.argv[0]

    parser = argparse.ArgumentParser(
        description=textwrap.dedent(doc),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        prog=prog,
    )

    parser.add_argument(
        '--io-threads',
        dest='io_threads',
        type=int,
        help="Number of io threads for 0mq to use",
        default=config['io_threads'],
    )
    parser.add_argument(
        '--topic-prefix',
        dest='topic_prefix',
        type=str,
        help="Prefix for the topic of each message sent.",
        default=config['topic_prefix'],
    )
    parser.add_argument(
        '--post-init-sleep',
        dest='post_init_sleep',
        type=float,
        help="Number of seconds to sleep after initializing.",
        default=config['post_init_sleep'],
    )
    parser.add_argument(
        '--config-filename',
        dest='config_filename',
        help="Config file to use.",
        default=None,
    )
    parser.add_argument(
        '--print-config',
        dest='print_config',
        help='Simply print out the configuration and exit.  No action taken.',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '--timeout',
        dest='timeout',
        help="Timeout in seconds for any blocking zmq operations.",
        type=float,
        default=config['timeout'],
    )
    parser.add_argument(
        '--high-water-mark',
        dest='high_water_mark',
        help="Limit on the number of messages in the queue before blocking.",
        type=int,
        default=config['high_water_mark'],
    )
    parser.add_argument(
        '--linger',
        dest='zmq_linger',
        help="Number of milliseconds to wait before timing out connections.",
        type=int,
        default=config['zmq_linger'],
    )

    for args, kwargs in declared_args:
        # Replace the hard-coded extra_args default with the config file value
        # (if it exists)
        if all([k in kwargs for k in ['dest', 'default']]):
            kwargs['default'] = config.get(
                kwargs['dest'], kwargs['default'])

        # Having slurped smart defaults from the config file, add the CLI arg.
        parser.add_argument(*args, **kwargs)

    return parser


def _process_arguments(declared_args, doc, config):
    parser = build_parser(declared_args, doc, config)
    args = parser.parse_args()
    return dict(args._get_kwargs())


def _gather_configs_in(directory):
    """ Return list of fully qualified python filenames in the given dir """
    try:
        return [
            os.path.join(directory, fname)
            for fname in os.listdir(directory)
            if fname.endswith('.py')
        ]
    except OSError:
        return []


def _recursive_update(d1, d2):
    """ Little helper function that does what d1.update(d2) does,
    but works nice and recursively with dicts of dicts of dicts.

    It's not necessarily very efficient.
    """

    for k in set(d1).intersection(d2):
        if isinstance(d1[k], dict) and isinstance(d2[k], dict):
            d1[k] = _recursive_update(d1[k], d2[k])
        else:
            d1[k] = d2[k]

    for k in set(d2).difference(d1):
        d1[k] = d2[k]

    return d1


def execfile(fname, variables):
    """ This is builtin in python2, but we have to roll our own on py3. """
    with open(fname) as f:
        code = compile(f.read(), fname, 'exec')
        exec(code, variables)


def _process_config_file(filenames=None):

    filenames = filenames or []

    # Validate that these files are really files
    for fname in filenames:
        if not os.path.isfile(fname):
            raise ValueError("%r is not a file." % fname)

    # If nothing specified, look in the default locations
    if not filenames:
        filenames = [
            '/etc/fedmsg-config.py',
            os.path.expanduser('~/.fedmsg-config.py'),
            os.getcwd() + '/fedmsg-config.py',
        ]
        folders = ["/etc/fedmsg.d/", os.path.expanduser('~/.fedmsg.d/'),
                   os.getcwd() + '/fedmsg.d/', ]
        if 'VIRTUAL_ENV' in os.environ:
            folders.append(os.path.join(
                os.environ['VIRTUAL_ENV'], 'etc/fedmsg.d'))

        filenames = sum(map(_gather_configs_in, folders), []) + filenames

    # Each .ini file should really be a python module that
    # builds a config dict.
    config = {}
    for fname in filenames:
        if os.path.isfile(fname):
            variables = {}
            try:
                execfile(fname, variables)
                config = _recursive_update(config, variables['config'])
            except IOError as e:
                warnings.warn(str(e))

    return config

########NEW FILE########
__FILENAME__ = dummy
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import fedmsg

from fedmsg.consumers import FedmsgConsumer

import logging


class DummyConsumer(FedmsgConsumer):
    config_key = 'fedmsg.consumers.dummy.enabled'

    def __init__(self, hub):
        self.hub = hub
        self.DBSession = None

        # The consumer should pick up *all* messages.
        self.topic = self.hub.config.get('topic_prefix', 'org.fedoraproject')
        if not self.topic.endswith('*'):
            self.topic += '*'

        return super(DummyConsumer, self).__init__(hub)

    def consume(self, msg):
        # Do nothing.
        log = logging.getLogger("moksha.hub")
        log.debug("Duhhhh... got: %r" % msg)

########NEW FILE########
__FILENAME__ = gateway
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import fedmsg
import threading
import weakref
import zmq

from fedmsg.consumers import FedmsgConsumer


class GatewayConsumer(FedmsgConsumer):
    config_key = 'fedmsg.consumers.gateway.enabled'
    jsonify = False

    def __init__(self, hub):
        self.hub = hub

        # The consumer should pick up *all* messages.
        self.topic = self.hub.config.get('topic_prefix', 'org.fedoraproject')
        if not self.topic.endswith('*'):
            self.topic += '*'

        super(GatewayConsumer, self).__init__(hub)

        # If fedmsg doesn't think we should be enabled, then we should quit
        # before setting up all the extra special zmq machinery.
        # _initialized is set in moksha.api.hub.consumer
        if not getattr(self, "_initialized", False):
            return

        self.port = hub.config['fedmsg.consumers.gateway.port']
        self.validate_signatures = False
        self._setup_special_gateway_socket()

        # Register a destructor?  This might be a bad idea inside Twisted.
        weakref.ref(threading.current_thread(), self.destroy)

    def _setup_special_gateway_socket(self):
        self.log.info("Setting up special gateway socket on " +
                      "port %r" % self.port)
        self._context = zmq.Context(1)
        self.gateway_socket = self._context.socket(zmq.PUB)

        # Set this to an absurdly high number to increase the number of clients
        # we can serve.  To be effective, also increase nofile for fedmsg in
        # /etc/security/limits.conf to near fs.file-limit.  Try 160000.
        hwm = self.hub.config['fedmsg.consumers.gateway.high_water_mark']
        if hasattr(zmq, 'HWM'):
            # zeromq2
            self.gateway_socket.setsockopt(zmq.HWM, hwm)
        else:
            # zeromq3
            self.gateway_socket.setsockopt(zmq.SNDHWM, hwm)
            self.gateway_socket.setsockopt(zmq.RCVHWM, hwm)

        self.gateway_socket.bind("tcp://*:{port}".format(port=self.port))
        self.log.info("Gateway socket established.")

    def destroy(self):
        self.log.info("Destroying GatewayConsumer")
        if getattr(self, 'gateway_socket', None):
            self.gateway_socket.close()
            self.gateway_socket = None

        if getattr(self, '_context', None):
            self._context.term()
            self._context = None

    def consume(self, msg):
        self.log.debug("Gateway: %r" % msg.topic)
        self.gateway_socket.send_multipart([
            msg.topic.encode('utf-8'),
            msg.body.encode('utf-8'),
        ])

########NEW FILE########
__FILENAME__ = ircbot
# -*- coding; utf-8 -*-
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#           Ryan Brown
""" A bot that takes a config and puts messages matching given
regexes in specified IRC channels.
"""

import fedmsg
import fedmsg.encoding
import fedmsg.meta
from fedmsg.meta import _

import copy
import re
import time
import pygments
import pygments.lexers
import pygments.formatters

from fedmsg.consumers import FedmsgConsumer

from twisted.words.protocols import irc
from twisted.internet import protocol
from twisted.internet import reactor
from twisted.internet import defer

import logging
log = logging.getLogger(__name__)


mirc_colors = {
    "white": 0,
    "black": 1,
    "blue": 2,
    "green": 3,
    "red": 4,
    "brown": 5,
    "purple": 6,
    "orange": 7,
    "yellow": 8,
    "light green": 9,
    "teal": 10,
    "light cyan": 11,
    "light blue": 12,
    "pink": 13,
    "grey": 14,
    "light grey": 15,
}


def ircprettify(title, subtitle, link="", config=None):
    def markup(s, color):
        return "\x03%i%s\x03" % (mirc_colors[color], s)

    config = config or {}

    if link:
        link = markup(link, "teal")
    else:
        link = ""

    color_lookup = config.get('irc_color_lookup', {})
    title_color = color_lookup.get(title.split('.')[0], "light grey")
    title = markup(title, title_color)

    fmt = u"{title} -- {subtitle} {link}"
    return fmt.format(title=title, subtitle=subtitle, link=link)


class FedMsngr(irc.IRCClient):
    # The 0.6 seconds here is empircally guessed so we don't get dropped by
    # freenode.  FIXME - this should be pulled from the config.
    lineRate = 0.6
    sourceURL = "http://github.com/fedora-infra/fedmsg"

    def __init__(self, *args, **kw):
        super(FedMsgnr, self).__init__(*args, **kw)

    def _get_nickname(self):
        return self.factory.nickname
    nickname = property(_get_nickname)

    def __init__(self, *args, **kwargs):
        self._modecallback = {}

    def signedOn(self):
        self.join(self.factory.channel)
        log.info("Signed on as %s." % (self.nickname,))

    def joined(self, channel):
        log.info("Joined %s." % (channel,))
        self.factory.parent_consumer.add_irc_client(self)

        def got_modes(modelist):
            modes = ''.join(modelist)
            if 'c' in modes:
                log.info("%s has +c is on. No prettiness" % channel)
                self.factory.pretty = False
        self.modes(channel).addCallback(got_modes)

    def modes(self, channel):
        channel = channel.lower()
        d = defer.Deferred()
        if channel not in self._modecallback:
            self._modecallback[channel] = ([], [])
        self._modecallback[channel][0].append(d)
        self.sendLine("MODE %s" % channel)
        return d

    def irc_RPL_CHANNELMODEIS(self, prefix, params):
        """ Handy reference for IRC mnemonics
        www.irchelp.org/irchelp/rfc/chapter4.html#c4_2_3 """
        channel = params[1].lower()
        modes = params[2]
        if channel not in self._modecallback:
            return
        n = self._modecallback[channel][1]
        n.append(modes)
        callbacks, modelist = self._modecallback[channel]

        for cb in callbacks:
            cb.callback(modelist)
        del self._modecallback[channel]


class FedMsngrFactory(protocol.ClientFactory):
    protocol = FedMsngr

    def __init__(self, channel, nickname, filters,
                 pretty, terse, parent_consumer):
        self.channel = channel
        self.nickname = nickname
        self.filters = filters
        self.pretty = pretty
        self.terse = terse
        self.parent_consumer = parent_consumer
        self.log = logging.getLogger("moksha.hub")

    def clientConnectionLost(self, connector, reason):
        self.log.warning("Lost connection (%s), reconnecting." % (reason,))
        self.parent_consumer.del_irc_clients(factory=self)
        connector.connect()

    def clientConnectionFailed(self, connector, reason):
        self.log.error("Could not connect: %s" % (reason,))


class IRCBotConsumer(FedmsgConsumer):
    validate_signatures = False
    config_key = 'fedmsg.consumers.ircbot.enabled'

    def __init__(self, hub):
        self.hub = hub
        self.DBSession = None
        self.irc_clients = []

        # The consumer should pick up *all* messages.
        self.topic = self.hub.config.get('topic_prefix', 'org.fedoraproject')
        if not self.topic.endswith('*'):
            self.topic += '*'

        super(IRCBotConsumer, self).__init__(hub)
        fedmsg.meta.make_processors(**hub.config)

        if not getattr(self, '_initialized', False):
            return

        irc_settings = hub.config.get('irc')
        for settings in irc_settings:
            network = settings.get('network', 'irc.freenode.net')
            port = settings.get('port', 6667)
            channel = settings.get('channel', None)
            if not channel:
                self.log.error("No channel specified.  Ignoring entry.")
                continue

            if not channel.startswith("#"):
                channel = "#" + channel

            nickname = settings.get('nickname', "fedmsg-bot")
            pretty = settings.get('make_pretty', False)
            terse = settings.get('make_terse', False)
            timeout = settings.get('timeout', 120)

            filters = self.compile_filters(settings.get('filters', None))

            factory = FedMsngrFactory(channel, nickname, filters,
                                      pretty, terse, self)
            reactor.connectTCP(network, port, factory, timeout=timeout)

    def add_irc_client(self, client):
        self.irc_clients.append(client)

    def del_irc_clients(self, client=None, factory=None):
        if factory:
            self.irc_clients = [
                c for c in self.irc_clients
                if c.factory != factory
            ]

        if client and client in self.irc_clients:
            self.irc_clients.remove(client)

    def compile_filters(self, filters):
        compiled_filters = dict(topic=[], body=[])

        for tag, flist in filters.items():
            for f in flist:
                compiled_filters[tag].append(re.compile(f))

        return compiled_filters

    def apply_filters(self, filters, topic, msg):
        for f in filters.get('topic', []):
            if f and re.search(f, topic):
                return False
        for f in filters.get('body', []):
            if f and re.search(f, str(msg)):
                return False
        return True

    def prettify(self, topic, msg, pretty=False, terse=False):
        if terse:
            if pretty:
                if (self.hub.config.get('validate_signatures')
                    and not fedmsg.crypto.validate(msg, **self.hub.config)):
                    # If we're validating signatures the message is invalid,
                    # then be careful with it and don't pass it to fedmsg.meta.
                    title = topic
                    if 'signature' not in msg:
                        subtitle = _("(unsigned)")
                    else:
                        subtitle = _("(invalid signature!)")
                    link = None
                else:
                    # Otherwise, either we aren't validating signatures, or we
                    # are and the message passed validation.
                    title = fedmsg.meta.msg2title(msg, **self.hub.config)
                    subtitle = fedmsg.meta.msg2subtitle(msg, **self.hub.config)
                    link = fedmsg.meta.msg2link(msg, **self.hub.config)

                return ircprettify(
                    title=title,
                    subtitle=subtitle,
                    link=link,
                    config=self.hub.config,
                )
            else:
                return fedmsg.meta.msg2repr(msg, **self.hub.config)

        msg = copy.deepcopy(msg)

        if msg.get('topic', None):
            msg.pop('topic')

        if msg.get('timestamp', None):
            msg['timestamp'] = time.ctime(msg['timestamp'])

        if pretty:
            msg = pygments.highlight(
                fedmsg.encoding.pretty_dumps(msg),
                pygments.lexers.JavascriptLexer(),
                pygments.formatters.TerminalFormatter()
            ).strip().encode('UTF-8')

        return "{0:<30} {1}".format(topic, msg)

    def consume(self, msg):
        """ Forward on messages from the bus to all IRC connections. """
        log.debug("Got message %r" % msg)
        topic, body = msg.get('topic'), msg.get('body')

        for client in self.irc_clients:
            if not client.factory.filters or (
                client.factory.filters and
                self.apply_filters(client.factory.filters, topic, body)
            ):
                raw_msg = self.prettify(
                    topic=topic,
                    msg=body,
                    pretty=client.factory.pretty,
                    terse=client.factory.terse,
                )
                send = getattr(client, self.hub.config['irc_method'], 'notice')
                send(client.factory.channel, raw_msg.encode('utf-8'))

                backlog = self.incoming.qsize()
                if backlog and (backlog % 20) == 0:
                    warning = "* backlogged by %i messages" % backlog
                    self.log.warning(warning)
                    send(client.factory.channel, warning.encode('utf-8'))

########NEW FILE########
__FILENAME__ = relay
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import fedmsg
import logging

from fedmsg.consumers import FedmsgConsumer

log = logging.getLogger(__name__)


class RelayConsumer(FedmsgConsumer):
    config_key = 'fedmsg.consumers.relay.enabled'

    def __init__(self, hub):
        self.hub = hub
        self.DBSession = None

        # The consumer should pick up *all* messages.
        self.topic = self.hub.config.get('topic_prefix', 'org.fedoraproject')
        if not self.topic.endswith('*'):
            self.topic += '*'

        super(RelayConsumer, self).__init__(hub)

        self.validate_signatures = False

    def consume(self, msg):
        ## FIXME - for some reason twisted is screwing up fedmsg.
        #fedmsg.__context.publisher.send_multipart(
        #    [msg['topic'], fedmsg.encoding.dumps(msg['body'])]
        #)
        #
        # We have to do this instead.  This works for the fedmsg-relay service
        # since it doesn't need to do any formatting of the message.  It just
        # forwards raw messages.
        #
        # This isn't scalable though.  It needs to be solved for future
        # consumers to use the nice fedmsg.send_message interface we use
        # everywhere else.

        log.debug("Got message %r" % msg)
        self.hub.send_message(topic=msg['topic'], message=msg['body'])

########NEW FILE########
__FILENAME__ = core
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#

import getpass
import socket
import threading
import datetime
import six
import time
import uuid
import warnings
import weakref
import zmq

from kitchen.iterutils import iterate
from kitchen.text.converters import to_bytes

import fedmsg.encoding
import fedmsg.crypto

from fedmsg.utils import (
    set_high_water_mark,
    guess_calling_module,
    set_tcp_keepalive,
    set_tcp_reconnect,
)

from fedmsg.replay import check_for_replay

import logging


class FedMsgContext(object):
    # A counter for messages sent.
    _i = 0

    def __init__(self, **config):
        super(FedMsgContext, self).__init__()
        self.log = logging.getLogger("fedmsg")

        self.c = config
        self.hostname = socket.gethostname().split('.', 1)[0]

        # Prepare our context and publisher
        self.context = zmq.Context(config['io_threads'])
        method = ['bind', 'connect'][config['active']]

        # If no name is provided, use the calling module's __name__ to decide
        # which publishing endpoint to use.
        if not config.get("name", None):
            module_name = guess_calling_module(default="fedmsg")
            config["name"] = module_name + '.' + self.hostname

            if any(map(config["name"].startswith, ['fedmsg'])):
                config["name"] = None

        # Do a little special-case mangling.  We never want to "listen" to the
        # relay_inbound address, but in the special case that we want to emit
        # our messages there, we add it to the :term:`endpoints` dict so that
        # the code below where we "Actually set up our publisher" can be
        # simplified.  See Issue #37 - http://bit.ly/KN6dEK
        if config.get('active', False):
            # If the user has called us with "active=True" then presumably they
            # have given us a "name" as well.
            name = config.get("name", "relay_inbound")
            config['endpoints'][name] = config[name]

        # Actually set up our publisher
        if (
            not config.get("mute", False) and
            config.get("name", None) and
            config.get("endpoints", None) and
            config['endpoints'].get(config['name'])
        ):
            # Construct it.
            self.publisher = self.context.socket(zmq.PUB)

            set_high_water_mark(self.publisher, config)
            set_tcp_keepalive(self.publisher, config)

            # Set a zmq_linger, thus doing a little bit more to ensure that our
            # message gets to the fedmsg-relay (*if* we're talking to the relay
            # which is the case when method == 'connect').
            if method == 'connect':
                self.publisher.setsockopt(zmq.LINGER, config['zmq_linger'])

            # "Listify" our endpoints.  If we're given a list, good.  If we're
            # given a single item, turn it into a list of length 1.
            config['endpoints'][config['name']] = list(iterate(
                config['endpoints'][config['name']]))

            # Try endpoint after endpoint in the list of endpoints.  If we
            # succeed in establishing one, then stop.  *That* is our publishing
            # endpoint.
            _established = False
            for endpoint in config['endpoints'][config['name']]:

                if method == 'bind':
                    endpoint = "tcp://*:{port}".format(
                        port=endpoint.rsplit(':')[-1]
                    )

                try:
                    # Call either bind or connect on the new publisher.
                    # This will raise an exception if there's another process
                    # already using the endpoint.
                    getattr(self.publisher, method)(endpoint)
                    # If we can do this successfully, then stop trying.
                    _established = True
                    break
                except zmq.ZMQError:
                    # If we fail to bind or connect, there's probably another
                    # process already using that endpoint port.  Try the next
                    # one.
                    pass

            # If we make it through the loop without establishing our
            # connection, then there are not enough endpoints listed in the
            # config for the number of processes attempting to use fedmsg.
            if not _established:
                raise IOError(
                    "Couldn't find an available endpoint "
                    "for name %r" % config.get("name", None))

        elif config.get('mute', False):
            # Our caller doesn't intend to send any messages.  Pass silently.
            pass
        else:
            # Something is wrong.
            warnings.warn(
                "fedmsg is not configured to send any messages "
                "for name %r" % config.get("name", None))

        # Cleanup.  See http://bit.ly/SaGeOr for discussion.
        weakref.ref(threading.current_thread(), self.destroy)

        # Sleep just to make sure that the socket gets set up before anyone
        # tries anything.  This is a documented zmq 'feature'.
        time.sleep(config['post_init_sleep'])

    def destroy(self):
        """ Destroy a fedmsg context """

        if getattr(self, 'publisher', None):
            self.publisher.close()
            self.publisher = None

        if getattr(self, 'context', None):
            self.context.term()
            self.context = None

    def send_message(self, topic=None, msg=None, modname=None):
        warnings.warn(".send_message is deprecated.", DeprecationWarning)

        return self.publish(topic, msg, modname)

    def publish(self, topic=None, msg=None, modname=None):
        """ Send a message over the publishing zeromq socket.

          >>> import fedmsg
          >>> fedmsg.publish(topic='testing', modname='test', msg={
          ...     'test': "Hello World",
          ... })

        The above snippet will send the message ``'{test: "Hello World"}'``
        over the ``<topic_prefix>.dev.test.testing`` topic.

        This function (and other API functions) do a little bit more
        heavy lifting than they let on.  If the "zeromq context" is not yet
        initialized, :func:`fedmsg.init` is called to construct it and
        store it as :data:`fedmsg.__local.__context` before anything else is
        done.

        The ``modname`` argument will be omitted in most use cases.  By
        default, ``fedmsg`` will try to guess the name of the module that
        called it and use that to produce an intelligent topic.  Specifying
        ``modname`` explicitly overrides this behavior.

        The fully qualified topic of a message is constructed out of the
        following pieces:

         <:term:`topic_prefix`>.<:term:`environment`>.<``modname``>.<``topic``>

        ----

        **An example from Fedora Tagger -- SQLAlchemy encoding**

        Here's an example from
        `fedora-tagger <http://github.com/fedora-infra/fedora-tagger>`_ that
        sends the information about a new tag over
        ``org.fedoraproject.{dev,stg,prod}.fedoratagger.tag.update``::

          >>> import fedmsg
          >>> fedmsg.publish(topic='tag.update', msg={
          ...     'user': user,
          ...     'tag': tag,
          ... })

        Note that the `tag` and `user` objects are SQLAlchemy objects defined
        by tagger.  They both have ``.__json__()`` methods which
        :func:`fedmsg.publish` uses to encode both objects as stringified
        JSON for you.  Under the hood, specifically, ``.publish`` uses
        :mod:`fedmsg.encoding` to do this.

        ``fedmsg`` has also guessed the module name (``modname``) of it's
        caller and inserted it into the topic for you.  The code from which
        we stole the above snippet lives in
        ``fedoratagger.controllers.root``.  ``fedmsg`` figured that out and
        stripped it down to just ``fedoratagger`` for the final topic of
        ``org.fedoraproject.{dev,stg,prod}.fedoratagger.tag.update``.

        ----

        **Shell Usage**

        You could also use the ``fedmsg-logger`` from a shell script like so::

            $ echo "Hello, world." | fedmsg-logger --topic testing
            $ echo '{"foo": "bar"}' | fedmsg-logger --json-input

        """

        topic = topic or 'unspecified'
        msg = msg or dict()

        # If no modname is supplied, then guess it from the call stack.
        modname = modname or guess_calling_module(default="fedmsg")
        topic = '.'.join([modname, topic])

        if topic[:len(self.c['topic_prefix'])] != self.c['topic_prefix']:
            topic = '.'.join([
                self.c['topic_prefix'],
                self.c['environment'],
                topic,
            ])

        if isinstance(topic, six.text_type):
            topic = to_bytes(topic, encoding='utf8', nonstring="passthru")

        year = datetime.datetime.now().year

        self._i += 1
        msg = dict(
            topic=topic.decode('utf-8'),
            msg=msg,
            timestamp=int(time.time()),
            msg_id=str(year) + '-' + str(uuid.uuid4()),
            i=self._i,
            username=getpass.getuser(),
        )

        # Find my message-signing cert if I need one.
        if self.c.get('sign_messages', False):
            if not self.c.get("crypto_backend") == "gpg":
                if 'cert_prefix' in self.c:
                    cert_index = "%s.%s" % (self.c['cert_prefix'],
                                            self.hostname)
                else:
                    cert_index = self.c['name']
                    if cert_index == 'relay_inbound':
                        cert_index = "shell.%s" % self.hostname

                self.c['certname'] = self.c['certnames'][cert_index]
            else:
                self.c['gpg_signing_key'] = self.c['gpg_keys'][cert_index]

        if self.c.get('sign_messages', False):
            msg = fedmsg.crypto.sign(msg, **self.c)

        store = self.c.get('persistent_store', None)
        if store:
            # Add the seq_id field
            msg = store.add(msg)

        self.publisher.send_multipart(
            [topic, fedmsg.encoding.dumps(msg).encode('utf-8')],
            flags=zmq.NOBLOCK,
        )

    def tail_messages(self, topic="", passive=False, **kw):
        """ Tail messages on the bus.

        Generator that yields tuples of the form:
        ``(name, endpoint, topic, message)``
        """

        # TODO -- do the zmq_strict logic dance with "topic" here.
        # It is buried in moksha.hub, but we need it to work the same way
        # here.

        # TODO -- the 'passive' here and the 'active' are ambiguous.  They
        # don't actually mean the same thing.  This should be resolved.
        method = passive and 'bind' or 'connect'

        failed_hostnames = []
        subs = {}
        watched_names = {}
        for _name, endpoint_list in self.c['endpoints'].iteritems():
            # Listify endpoint_list in case it is a single string
            endpoint_list = iterate(endpoint_list)
            for endpoint in endpoint_list:
                # First, some sanity checking.  zeromq will potentially
                # segfault if we don't do this check.
                hostname = endpoint.split(':')[1][2:]
                if hostname in failed_hostnames:
                    continue

                if hostname != '*':
                    try:
                        socket.gethostbyname_ex(hostname)
                    except:
                        failed_hostnames.append(hostname)
                        self.log.warn("Couldn't resolve %r" % hostname)
                        continue

                # OK, sanity checks pass.  Create the subscriber and connect.
                subscriber = self.context.socket(zmq.SUB)
                subscriber.setsockopt(zmq.SUBSCRIBE, topic)

                set_high_water_mark(subscriber, self.c)
                set_tcp_keepalive(subscriber, self.c)
                set_tcp_reconnect(subscriber, self.c)

                getattr(subscriber, method)(endpoint)
                subs[subscriber] = (_name, endpoint)
            if _name in self.c.get("replay_endpoints", {}):
                # At first we don't know where the sequence is at.
                watched_names[_name] = -1

        # Register the sockets we just built with a zmq Poller.
        poller = zmq.Poller()
        for subscriber in subs:
            poller.register(subscriber, zmq.POLLIN)

        # TODO -- what if user wants to pass in validate_signatures in **kw?
        validate = self.c.get('validate_signatures', False)

        # Poll that poller.  This is much more efficient than it used to be.
        try:
            while True:
                sockets = dict(poller.poll())
                for s in sockets:
                    _name, ep = subs[s]
                    _topic, message = s.recv_multipart()
                    msg = fedmsg.encoding.loads(message)
                    if not validate or fedmsg.crypto.validate(msg, **self.c):
                        # If there is even a slight change of replay, use
                        # check_for_replay
                        if len(self.c.get('replay_endpoints', {})) > 0:
                            for m in check_for_replay(
                                    _name, watched_names,
                                    msg, self.c, self.context):

                                # Revalidate all the replayed messages.
                                if not validate or \
                                        fedmsg.crypto.validate(m, **self.c):
                                    yield _name, ep, m['topic'], m
                                else:
                                    warnings.warn("!! invalid message " +
                                                  "received: %r" % msg)
                        else:
                            yield _name, ep, _topic, msg
                    else:
                        # Else.. we are supposed to be validating, but the
                        # message failed validation.

                        # Warn, but don't throw an exception.  Keep tailing.
                        warnings.warn("!! invalid message received: %r" % msg)

        finally:
            for subscriber in subs:
                subscriber.close()

########NEW FILE########
__FILENAME__ = gpg
# This file is part of fedmsg.
# Copyright (C) 2013-2014 Simon Chopin <chopin.simon@gmail.com>
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Simon Chopin <chopin.simon@gmail.com>
#           Ralph Bean <rbean@redhat.com>

import os
import os.path
import tempfile
import shutil
import six
import subprocess

from base64 import b64encode, b64decode

import logging
log = logging.getLogger(__name__)


class GpgBinaryError(Exception):
    pass


class Context(object):
    def __init__(self, keyrings=None, homedir=None):
        self.homedir = homedir or os.path.expanduser(u'~/.gnupg/')
        self.keyrings = keyrings or []

    def _get_keyrings_cl(self, keyrings):
        cl = []
        if keyrings:
            keyrings = self.keyrings + keyrings
        else:
            keyrings = self.keyrings
        for k in keyrings:
            cl.extend(["--keyring", k])
        return cl

    def verify(self, data, signature=None, keyrings=None, homedir=None):
        '''
        `data` <string> the data to verify.
        `signature` <string> The signature, if detached from the data.
        `keyrings` <list of string> Additional keyrings to search in.
        `homedir` <string> Override the configured homedir.
        '''

        if isinstance(data, six.text_type):
            data = data.encode('utf-8')

        tmpdir = tempfile.mkdtemp()
        data_file, data_path = tempfile.mkstemp(dir=tmpdir)
        data_file = os.fdopen(data_file, 'wb')
        data_file.write(data)
        data_file.close()
        if signature:
            sig_file, sig_path = tempfile.mkstemp(dir=tmpdir)
            sig_file = os.fdopen(sig_file, 'wb')
            sig_file.write(signature)
            sig_file.close()
        else:
            sig_path = None
        try:
            return self.verify_from_file(
                data_path,
                sig_path=sig_path,
                keyrings=keyrings,
                homedir=homedir
            )
        finally:
            shutil.rmtree(tmpdir)

    def verify_from_file(self, data_path,
                         sig_path=None, keyrings=None, homedir=None):
        '''
        `data_path` <string> The path to the data to verify.
        `sig_path` <string> The signature file, if detached from the data.
        `keyrings` <list of string> Additional keyrings to search in.
        `homedir` <string> Override the configured homedir.
        '''
        cmd_line = ['gpg', '--homedir', homedir or self.homedir]
        cmd_line.extend(self._get_keyrings_cl(keyrings))

        cmd_line.append('--verify')
        if sig_path:
            cmd_line.extend([sig_path, data_path])
        else:
            cmd_line.append(data_path)

        p = subprocess.Popen(cmd_line, stderr=subprocess.PIPE)
        stdout, stderr = p.communicate()
        if p.returncode:
            raise GpgBinaryError(stderr)
        return True

    def clearsign(self, data, fingerprint, keyrings=None, homedir=None):

        if isinstance(data, six.text_type):
            data = data.encode('utf-8')

        cmd_line = ['gpg', '--homedir', homedir or self.homedir]
        cmd_line.extend(self._get_keyrings_cl(keyrings))

        cmd_line.extend(['--local-user', fingerprint, '--clearsign'])
        p = subprocess.Popen(
            cmd_line,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        stdout, stderr = p.communicate(data)
        if p.returncode:
            raise GpgBinaryError(stderr)
        return stdout

    def sign(self, data, fingerprint, keyrings=None, homedir=None):

        if isinstance(data, six.text_type):
            data = data.encode('utf-8')

        cmd_line = ['gpg', '--homedir', homedir or self.homedir]
        cmd_line.extend(self._get_keyrings_cl(keyrings))

        cmd_line.extend(['--local-user', fingerprint, '--detach-sign'])
        p = subprocess.Popen(
            cmd_line,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        stdout, stderr = p.communicate(data)
        if p.returncode:
            raise GpgBinaryError(stderr)
        return stdout

# Here comes the part actually relevent to fedmsg
""" ``fedmsg.crypto.gpg`` - GnuPG backend for :mod:`fedmsg.crypto` """
import fedmsg.encoding
_ctx = Context()


def sign(message, gpg_home=None, gpg_signing_key=None, **config):
    """ Insert a new field into the message dict and return it.

    The new field is:

        - 'signature' - the computed GPG message digest of the JSON repr
          of the `msg` field.
    """

    if gpg_home is None or gpg_signing_key is None:
        raise ValueError("You must set the gpg_home \
                         and gpg_signing_key keyword arguments.")

    message['crypto'] = 'gpg'

    signature = _ctx.sign(
        fedmsg.encoding.dumps(message['msg']),
        gpg_signing_key,
        homedir=gpg_home
    )
    return dict(list(message.items()) + [('signature', b64encode(signature))])


def validate(message, gpg_home=None, **config):
    """ Return true or false if the message is signed appropriately.

    Two things must be true:

        1) The signature must be valid (obviously)
        2) The signing key must be in the local keyring
           as defined by the `gpg_home` config value.
    """
    if gpg_home is None:
        raise ValueError("You must set the gpg_home keyword argument.")
    try:
        _ctx.verify(
            fedmsg.encoding.dumps(message['msg']),
            b64decode(message['signature']),
            homedir=gpg_home
        )
        return True
    except GpgBinaryError as e:
        log.warn("Failed validation. {0}".format(six.text_type(message)))
        return False

########NEW FILE########
__FILENAME__ = x509
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
""" ``fedmsg.crypto.x509`` - X.509 backend for :mod:`fedmsg.crypto`.  """


import os
import requests
import time

import fedmsg.crypto
import fedmsg.encoding

import logging
log = logging.getLogger(__name__)

try:
    import M2Crypto
    # FIXME - m2ext will be unnecessary once the following bug is closed.
    # https://bugzilla.osafoundation.org/show_bug.cgi?id=11690
    import m2ext
    disabled = False
except ImportError as e:
    logging.basicConfig()
    log.warn("Crypto disabled %r" % e)
    disabled = True


def sign(message, ssldir=None, certname=None, **config):
    """ Insert two new fields into the message dict and return it.

    Those fields are:

        - 'signature' - the computed RSA message digest of the JSON repr.
        - 'certificate' - the base64 X509 certificate of the sending host.
    """

    if disabled:
        return message

    if ssldir is None or certname is None:
        error = "You must set the ssldir and certname keyword arguments."
        raise ValueError(error)

    message['crypto'] = 'x509'

    certificate = M2Crypto.X509.load_cert(
        "%s/%s.crt" % (ssldir, certname)).as_pem()
    # Opening this file requires elevated privileges in stg/prod.
    rsa_private = M2Crypto.RSA.load_key(
        "%s/%s.key" % (ssldir, certname))

    digest = M2Crypto.EVP.MessageDigest('sha1')
    digest.update(fedmsg.encoding.dumps(message))

    signature = rsa_private.sign(digest.digest())

    # Return a new dict containing the pairs in the original message as well
    # as the new authn fields.
    return dict(message.items() + [
        ('signature', signature.encode('base64')),
        ('certificate', certificate.encode('base64')),
    ])


def validate(message, ssldir=None, **config):
    """ Return true or false if the message is signed appropriately.

    Four things must be true:

      1) The X509 cert must be signed by our CA
      2) The cert must not be in our CRL.
      3) We must be able to verify the signature using the RSA public key
         contained in the X509 cert.
      4) The topic of the message and the CN on the cert must appear in the
         :term:`routing_policy` dict.

    """

    if ssldir is None:
        raise ValueError("You must set the ssldir keyword argument.")

    def fail(reason):
        log.warn("Failed validation.  %s" % reason)
        return False

    if disabled:
        fail("M2Crypto and/or m2ext missing!")

    # Some sanity checking
    for field in ['signature', 'certificate']:
        if not field in message:
            return fail("No %r field found." % field)
        if not isinstance(message[field], basestring):
            return fail("msg[%r] is not a string" % field)

    # Peal off the auth datums
    decode = lambda obj: obj.decode('base64')
    signature, certificate = map(decode, (
        message['signature'], message['certificate']))
    message = fedmsg.crypto.strip_credentials(message)

    # Build an X509 object
    cert = M2Crypto.X509.load_cert_string(certificate)

    # Validate the cert.  Make sure it is signed by our CA.
    #   validate_certificate will one day be a part of M2Crypto.SSL.Context
    #   https://bugzilla.osafoundation.org/show_bug.cgi?id=11690

    default_ca_cert_loc = 'https://fedoraproject.org/fedmsg/ca.crt'
    cafile = _load_remote_cert(
        config.get('ca_cert_location', default_ca_cert_loc),
        config.get('ca_cert_cache', '/etc/pki/fedmsg/ca.crt'),
        config.get('ca_cert_cache_expiry', 0),
        **config)

    ctx = m2ext.SSL.Context()
    ctx.load_verify_locations(cafile=cafile)
    if not ctx.validate_certificate(cert):
        return fail("X509 certificate is not valid.")

    # Load and check against the CRL
    crl = _load_remote_cert(
        config.get('crl_location', 'https://fedoraproject.org/fedmsg/crl.pem'),
        config.get('crl_cache', '/var/cache/fedmsg/crl.pem'),
        config.get('crl_cache_expiry', 1800),
        **config)
    crl = M2Crypto.X509.load_crl(crl)

    # FIXME -- We need to check that the CRL is signed by our own CA.
    # See https://bugzilla.osafoundation.org/show_bug.cgi?id=12954#c2
    #if not ctx.validate_certificate(crl):
    #    return fail("X509 CRL is not valid.")

    # FIXME -- we check the CRL, but by doing string comparison ourselves.
    # This is not what we want to be doing.
    # There is a patch into M2Crypto to handle this for us.  We should use it
    # once its integrated upstream.
    # See https://bugzilla.osafoundation.org/show_bug.cgi?id=12954#c2
    revoked_serials = [long(line.split(': ')[1].strip(), base=16)
                       for line in crl.as_text().split('\n')
                       if 'Serial Number:' in line]
    if cert.get_serial_number() in revoked_serials:
        return fail("X509 certificate is in the Revocation List (CRL)")

    # If the cert is good, then test to see if the signature in the messages
    # matches up with the provided cert.
    rsa_public = cert.get_pubkey().get_rsa()
    digest = M2Crypto.EVP.MessageDigest('sha1')
    digest.update(fedmsg.encoding.dumps(message))
    try:
        if not rsa_public.verify(digest.digest(), signature):
            raise M2Crypto.RSA.RSAError("RSA signature failed to validate.")
    except M2Crypto.RSA.RSAError as e:
        return fail(str(e))

    # Now we know that the cert is valid.  The message is *authenticated*.
    # * Next step:  Authorization *

    # Load our policy from the config dict.
    routing_policy = config.get('routing_policy', {})

    # Determine the name of the signer of the message.
    # This will be something like "shell-pkgs01.stg.phx2.fedoraproject.org"
    subject = cert.get_subject()
    signer = subject.get_entries_by_nid(subject.nid['CN'])[0]\
        .get_data().as_text()

    # Perform the authz dance
    # Do we have a list of permitted senders for the topic of this message?
    if message.get('topic') in routing_policy:
        # If so.. is the signer one of those permitted senders?
        if signer in routing_policy[message['topic']]:
            # We are good.  The signer of this message is explicitly
            # whitelisted to send on this topic in our config policy.
            pass
        else:
            # We have a policy for this topic and $homeboy isn't on the list.
            return fail("Authorization/routing_policy error.  "
                        "Topic %r.  Signer %r." % (message['topic'], signer))
    else:
        # We don't have a policy for this topic.  How we react next for an
        # underspecified routing_policy is based on a configuration option.

        # Ideally, we are in nitpicky mode.  We leave it disabled while
        # standing up fedmsg across our environment so that we can build our
        # policy without having the whole thing come crashing down.
        if config.get('routing_nitpicky', False):
            # We *are* in nitpicky mode.  We don't have an entry in the
            # routing_policy for the topic of this message.. and *nobody*
            # gets in without a pass.  That means that we fail the message.
            return fail("Authorization/routing_policy underspecified.")
        else:
            # We are *not* in nitpicky mode.  We don't have an entry in the
            # routing_policy for the topic of this message.. but we don't
            # really care.  We pass on the message and ultimately return
            # True later on.
            pass

    return True


def _load_remote_cert(location, cache, cache_expiry, **config):
    """ Get a fresh copy from fp.o/fedmsg/crl.pem if ours is getting stale.

    Return the local filename.
    """

    try:
        modtime = os.stat(cache).st_mtime
    except OSError:
        # File does not exist yet.
        modtime = 0

    if (
        (not modtime and not cache_expiry) or
        (cache_expiry and time.time() - modtime > cache_expiry)
    ):
        try:
            response = requests.get(location)
            with open(cache, 'w') as f:
                f.write(response.content)
        except requests.exceptions.ConnectionError:
            log.warn("Could not access %r" % location)
        except IOError as e:
            # If we couldn't write to the specified cache location, try a
            # similar place but inside our home directory instead.
            cache = os.path.expanduser("~/.local" + cache)
            usr_dir = '/'.join(cache.split('/')[:-1])

            if not os.path.isdir(usr_dir):
                os.makedirs(usr_dir)

            with open(cache, 'w') as f:
                f.write(response.content)

    return cache

########NEW FILE########
__FILENAME__ = sqla
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
""" :mod:`fedmsg.encoding.sqla` houses utility functions for JSONifying
sqlalchemy models that do not define their own ``.__json__()`` methods.

Use at your own risk.  :func:`fedmsg.encoding.sqla.to_json` will expose all
attributes and relations of your sqlalchemy object and may expose information
you not want it to.  See :doc:`crypto` for considerations.
"""

try:
    from sqlalchemy.orm import class_mapper
    from sqlalchemy.orm.properties import RelationshipProperty
except ImportError:
    pass


def to_json(obj, seen=None):
    """ Returns a dict representation of the object.

    Recursively evaluates to_json(...) on its relationships.
    """

    if not seen:
        seen = []

    properties = list(class_mapper(type(obj)).iterate_properties)
    relationships = [
        p.key for p in properties if type(p) is RelationshipProperty
    ]
    attrs = [
        p.key for p in properties if p.key not in relationships
    ]

    d = dict([(attr, getattr(obj, attr)) for attr in attrs])

    for attr in relationships:
        d[attr] = expand(obj, getattr(obj, attr), seen)

    return d


def expand(obj, relation, seen):
    """ Return the to_json or id of a sqlalchemy relationship. """

    if hasattr(relation, 'all'):
        relation = relation.all()

    if hasattr(relation, '__iter__'):
        return [expand(obj, item, seen) for item in relation]

    if type(relation) not in seen:
        return to_json(relation, seen + [type(obj)])
    else:
        return relation.id

########NEW FILE########
__FILENAME__ = announce
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
from fedmsg.meta.base import BaseProcessor


class AnnounceProcessor(BaseProcessor):
    __name__ = "announce"
    __description__ = "Official Fedora Announcements"
    __link__ = "http://fedoraproject.org/"
    __docs__ = "http://fedoraproject.org/"
    __obj__ = "Announcements"

    def subtitle(self, msg, **config):
        return msg['msg']['message']

    def link(self, msg, **config):
        return msg['msg']['link']

    def usernames(self, msg, **config):
        return set([msg['username']])

########NEW FILE########
__FILENAME__ = base
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#           Luke Macken <lmacken@redhat.com>

import re


class BaseProcessor(object):
    """ Base Processor.  Without being extended, this doesn't actually handle
    any messages.

    Processors require that an ``internationalization_callable`` be passed to
    them at instantiation.  Internationalization is often done at import time,
    but we handle it at runtime so that a single process may translate fedmsg
    messages into multiple languages.  Think: an IRC bot that runs
    #fedora-fedmsg, #fedora-fedmsg-es, #fedora-fedmsg-it.  Or: a twitter bot
    that posts to multiple language-specific accounts.

    That feature is currently unused, but fedmsg.meta supports future
    internationalization (there may be bugs to work out).

    """

    # These six properties must be overridden by child-classes.
    # They can be used by applications to give more context to messages.  If
    # the BodhiProcessor can handle a message, then our caller's code can use
    # these attributes to say "btw, this message is from Bodhi, the Fedora
    # update system.  It lives at https://admin.fedoraproject.org/updates/
    # and you can read more about it at http://fedoraproject.org/wiki/Bodhi"
    __name__ = None
    __description__ = None
    __link__ = None
    __docs__ = None
    __obj__ = None
    __icon__ = None

    # An automatically generated regex to match messages for this processor
    __prefix__ = None

    def __init__(self, internationalization_callable, **config):
        self._ = internationalization_callable
        if not self.__name__:
            raise ValueError("Must declare a __name__")
        if not self.__description__:
            raise ValueError("Must declare a __description__")
        if not self.__link__:
            raise ValueError("Must declare a __link__")
        if not self.__docs__:
            raise ValueError("Must declare a __docs__")
        if not self.__obj__:
            raise ValueError("Must declare a __obj__")

        # Build a regular expression used to match message topics for us
        self.__prefix__ = re.compile('^%s\.(%s)(\.(.*))?$' % (
            config['topic_prefix_re'], self.__name__.lower()))

    def handle_msg(self, msg, **config):
        """
        If we can handle the given message, return the remainder of the topic.
        """
        match = self.__prefix__.match(msg['topic'])
        if match:
            return match.groups()[-1]

    def title(self, msg, **config):
        return '.'.join(msg['topic'].split('.')[3:])

    def subtitle(self, msg, **config):
        """ Return a "subtitle" for the message. """
        return ""

    def link(self, msg, **config):
        """ Return a "link" for the message. """
        return ""

    def icon(self, msg, **config):
        """ Return a "icon" for the message. """
        return self.__icon__

    def secondary_icon(self, msg, **config):
        """ Return a "secondary icon" for the message. """

    def usernames(self, msg, **config):
        """ Return a set of FAS usernames associated with a message. """
        return set()

    def packages(self, msg, **config):
        """ Return a set of package names associated with a message. """
        return set()

    def objects(self, msg, **config):
        """ Return a set of objects associated with a message. """
        return set()

    def emails(self, msg, **config):
        """ Return a dict of emails associated with a message. """
        return dict()

    def avatars(self, msg, **config):
        """ Return a dict of avatar URLs associated with a message. """
        return dict()

########NEW FILE########
__FILENAME__ = default
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
from fedmsg.meta.base import BaseProcessor


class DefaultProcessor(BaseProcessor):
    __name__ = "unhandled"
    __description__ = "fedmsg doesn't know how to handle this message"
    __link__ = "http://github.com/fedora-infra/fedmsg"
    __docs__ = "http://fedmsg.rtfd.org"
    __obj__ = "Everything Else"

########NEW FILE########
__FILENAME__ = logger
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
from fedmsg.meta.base import BaseProcessor


class LoggerProcessor(BaseProcessor):
    __name__ = "logger"
    __description__ = "miscellaneous Fedora Infrastructure shell scripts"
    __link__ = "http://fedoraproject.org/wiki/Infrastructure"
    __docs__ = "http://fedoraproject.org/wiki/Infrastructure"
    __obj__ = "System Logs"

    def subtitle(self, msg, **config):
        if 'logger.log' in msg['topic']:
            if 'log' in msg['msg']:
                result = msg['msg']['log']
            else:
                result = self._("<custom JSON message>")
            return result + " (%s)" % msg.get('username', 'none')
        else:
            return self._("<unhandled log message>")

    def usernames(self, msg, **config):
        if 'username' in msg:
            return set([msg['username']])
        else:
            # *OLD* messages in datanommer's db don't have a username.
            return set()

########NEW FILE########
__FILENAME__ = sqlstore
# This file is part of fedmsg
# Copyright (C) 2013 Simon Chopin <chopin.simon@gmail.com>
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Simon Chopin <chopin.simon@gmail.com>
#

from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()

from sqlalchemy import Column, Integer, String, Text, DateTime, or_
from sqlalchemy.orm import sessionmaker

from datetime import datetime
import json


class SqlMessage(Base):
    # This should probably be customizeable?
    __tablename__ = "fedmsg_messages"

    seq_id = Column(Integer, primary_key=True)
    uuid = Column(String(36))
    topic = Column(String)
    timestamp = Column(DateTime)
    # The raw message, including the metadata (signature, topic, etc)
    msg = Column(Text)


class SqlStore(object):
    def __init__(self, engine):
        self.engine = engine
        self.session_class = sessionmaker(bind=engine)
        Base.metadata.create_all(engine)

    def add(self, msg):
        session = self.session_class()
        msg_object = SqlMessage(
            uuid=msg['msg_id'],
            timestamp=datetime.fromtimestamp(msg['timestamp']),
            topic=msg['topic'],
            # We still have to add the seq_id field
            msg=""
        )
        session.add(msg_object)
        session.commit()
        msg['seq_id'] = msg_object.seq_id
        msg_object.msg = json.dumps(msg)
        session.commit()
        session.close()
        return msg

    def _query_seq_ids(self, arg):
        return SqlMessage.seq_id.in_(arg)

    def _query_seq_id(self, arg):
        return SqlMessage.seq_id == arg

    def _query_seq_id_range(self, arg):
        try:
            sid_beg, sid_end = arg
        except (TypeError, ValueError):
            raise ValueError('Ill-format "sed_id_range" field')
        return SqlMessage.sed_id.between(sid_beg, sid_end)

    def _query_msg_ids(self, arg):
        return SqlMessage.uuid.in_(arg)

    def _query_msg_id(self, arg):
        return SqlMessage.uuid == arg

    def _query_time(self, arg):
        try:
            time_beg, time_end = arg
        except (TypeError, ValueError):
            raise ValueError('Ill-format "time" field')
        return SqlMessage.timestamp.between(
            datetime.fromtimestamp(time_beg),
            datetime.fromtimestamp(time_end)
        )

    def get(self, query):
        predicates = []

        for key, value in query.items():
            fn = getattr(self, '_query_{0}'.format(key), None)
            if not fn:
                raise ValueError('Unsupported field: "key"')
            try:
                predicates.append(fn(value))
            except ValueError:
                raise
            except Exception:
                raise ValueError('Something went wrong when processing '
                                 'the field "{0}"'.format(key))

        session = self.session_class()

        ret = [json.loads(m[0])
               for m in session.query(SqlMessage.msg)
               .filter(or_(*predicates)).all()]
        session.close()
        if len(ret) == 0:
            raise ValueError('There was no match for the given query')
        return ret

########NEW FILE########
__FILENAME__ = common
import os
import socket
import fedmsg.config


def load_config(name='fedmsg-test-config.py'):
    here = os.path.sep.join(__file__.split(os.path.sep)[:-1])
    test_config = os.path.sep.join([here, name])

    config = fedmsg.config.load_config(
        [],
        "awesome",
        filenames=[
            test_config,
        ],
        invalidate_cache=True
    )

    # Enable all of our test consumers so they can do their thing.
    config['test_consumer_enabled'] = True

    # TODO -- this appears everywhere and should be encapsulated in a func
    # Massage the fedmsg config into the moksha config.
    config['zmq_subscribe_endpoints'] = ','.join(
        ','.join(bunch) for bunch in config['endpoints'].values()
    )
    hub_name = "twisted.%s" % socket.gethostname().split('.', 1)[0]
    config['zmq_publish_endpoints'] = ','.join(
        config['endpoints'][hub_name]
    )
    return config

########NEW FILE########
__FILENAME__ = fedmsg-test-config
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
""" Test config. """
import os
import socket
import random

SEP = os.path.sep
here = os.getcwd()
hostname = socket.gethostname().split('.', 1)[0]

ssl_enabled_for_tests = True
try:
    import M2Crypto
    import m2ext
except ImportError:
    ssl_enabled_for_tests = False

# Pick random ports for the tests so travis-ci doesn't flip out.
port = random.randint(4000, 20000)

gpg_key_unittest = 'FBDA 92E4 338D FFD9 EB83  F8F6 3FBD B725 DA19 B4EC'
gpg_key_main = 'FBDA 92E4 338D FFD9 EB83  F8F6 3FBD B725 DA19 B4EC'

config = dict(
    topic_prefix="com.test_prefix",
    endpoints={
        "unittest.%s" % hostname: [
            "tcp://*:%i" % (port + 1),
            "tcp://*:%i" % (port + 2),
        ],
        "twisted.%s" % hostname: [
            "tcp://*:%i" % (port + 3),
        ],
        "__main__.%s" % hostname: [
            "tcp://*:%i" % (port + 4),
            "tcp://*:%i" % (port + 5),
            "tcp://*:%i" % (port + 6),
            "tcp://*:%i" % (port + 7),
            "tcp://*:%i" % (port + 8),
            "tcp://*:%i" % (port + 9),
        ],
        "unittest2.%s" % hostname: [
            "tcp://*:%i" % (port + 10),
            "tcp://*:%i" % (port + 11),
        ],
        # Guarantee that we don't fall over with a bogus endpoint.
        "blah.%s": "tcp://www.flugle.horn:88",
    },
    relay_inbound=["tcp://127.0.0.1:%i" % (port - 1)],
    replay_endpoints={
        'unittest.%s' % hostname: "tcp://127.0.0.1:%i" % (port + 1),
        'unittest2.%s' % hostname: "tcp://127.0.0.1:%i" % (port + 2),
    },
    persistent_store=None,
    environment="dev",
    high_water_mark=0,
    io_threads=1,
    irc=[],
    zmq_enabled=True,
    zmq_strict=False,

    zmq_reconnect_ivl=100,
    zmq_reconnect_ivl_max=1000,

    # SSL stuff.
    sign_messages=ssl_enabled_for_tests,
    validate_signatures=ssl_enabled_for_tests,
    ssldir=SEP.join([here, 'test_certs/keys']),

    crl_location="http://threebean.org/fedmsg-tests/crl.pem",
    crl_cache="/tmp/crl.pem",
    crl_cache_expiry=10,

    certnames={
        "unittest.%s" % hostname: "shell-app01.phx2.fedoraproject.org",
        "unittest2.%s" % hostname: "shell-app01.phx2.fedoraproject.org",
        "__main__.%s" % hostname: "shell-app01.phx2.fedoraproject.org",
        # In prod/stg, map hostname to the name of the cert in ssldir.
        # Unfortunately, we can't use socket.getfqdn()
        #"app01.stg": "app01.stg.phx2.fedoraproject.org",
    },
    gpg_keys={
        "unittest.%s" % hostname: gpg_key_unittest,
        "unittest2.%s" % hostname: gpg_key_unittest,
        "__main__.%s" % hostname: gpg_key_main,
    }
)

########NEW FILE########
__FILENAME__ = test_commands
import unittest
from mock import Mock
from mock import patch
from datetime import datetime
import time
import json
import os

import fedmsg
import fedmsg.core
import fedmsg.config
import fedmsg.commands

from fedmsg.commands.logger import LoggerCommand
from fedmsg.commands.tail import TailCommand
from fedmsg.commands.relay import RelayCommand
from fedmsg.commands.config import config as config_command
import fedmsg.consumers.relay

from nose.tools import eq_

import threading

import six

CONF_FILE = os.path.join(os.path.dirname(__file__), "fedmsg.d", "ircbot.py")


class TestCommands(unittest.TestCase):
    def setUp(self):
        self.local = threading.local()

        # Crazy.  I'm sorry.
        os.environ['TZ'] = 'US/Central'
        time.tzset()

    def tearDown(self):
        del self.local
        self.local = None

    @patch("sys.argv", new_callable=lambda: ["fedmsg-logger"])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_logger_basic(self, stdout, argv):

        test_input = "a message for you"

        if six.PY3:
            stdin = lambda: six.StringIO(test_input)
        else:
            stdin = lambda: six.StringIO(test_input.encode('utf-8'))

        msgs = []

        def mock_publish(context, topic=None, msg=None, modname=None):
            msgs.append(msg)

        config = {}
        with patch("fedmsg.__local", self.local):
            with patch("fedmsg.config.__cache", config):
                with patch("fedmsg.core.FedMsgContext.publish", mock_publish):
                    with patch("sys.stdin", new_callable=stdin):
                        command = LoggerCommand()
                        command.execute()

        eq_(msgs, [{'log': test_input}])

    @patch("sys.argv", new_callable=lambda: ["fedmsg-logger", "--json-input"])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_logger_json(self, stdout, argv):

        test_input_dict = {"hello": "world"}
        test_input = json.dumps(test_input_dict)

        if six.PY3:
            stdin = lambda: six.StringIO(test_input)
        else:
            stdin = lambda: six.StringIO(test_input.encode('utf-8'))

        msgs = []

        def mock_publish(context, topic=None, msg=None, modname=None):
            msgs.append(msg)

        config = {}
        with patch("fedmsg.__local", self.local):
            with patch("fedmsg.config.__cache", config):
                with patch("fedmsg.core.FedMsgContext.publish", mock_publish):
                    with patch("sys.stdin", new_callable=stdin):
                        command = LoggerCommand()
                        command.execute()

        eq_(msgs, [test_input_dict])

    @patch("sys.argv", new_callable=lambda: ["fedmsg-tail"])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_tail_basic(self, stdout, argv):
        def mock_tail(self, topic="", passive=False, **kw):
            yield ("name", "endpoint", "topic", dict(topic="topic"))

        config = {}
        with patch("fedmsg.__local", self.local):
            with patch("fedmsg.config.__cache", config):
                with patch("fedmsg.core.FedMsgContext.tail_messages",
                           mock_tail):
                    command = fedmsg.commands.tail.TailCommand()
                    command.execute()

        output = stdout.getvalue()
        expected = "{'topic': 'topic'}\n"
        assert(output.endswith(expected))

    @patch("sys.argv", new_callable=lambda: ["fedmsg-tail", "--pretty"])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_tail_pretty(self, stdout, argv):
        msgs = []

        def mock_tail(self, topic="", passive=False, **kw):
            msg = dict(
                msg=dict(hello="world"),
                msg_id='2ad5aaf8-68af-4a6d-9196-2a8b43a73238',
                timestamp=1354563717.472648,  # Once upon a time...
                topic="org.threebean.prod.testing",
            )

            yield ("name", "endpoint", "topic", msg)

        config = {}
        with patch("fedmsg.__local", self.local):
            with patch("fedmsg.config.__cache", config):
                with patch("fedmsg.core.FedMsgContext.tail_messages",
                           mock_tail):
                    command = fedmsg.commands.tail.TailCommand()
                    command.execute()

        output = stdout.getvalue()
        expected = "{'msg': {'hello': 'world'},"
        assert(expected in output)

    @patch("sys.argv", new_callable=lambda: ["fedmsg-tail", "--really-pretty"])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_tail_really_pretty(self, stdout, argv):
        msgs = []

        def mock_tail(self, topic="", passive=False, **kw):
            msg = dict(
                msg=dict(hello="world"),
                msg_id='2ad5aaf8-68af-4a6d-9196-2a8b43a73238',
                timestamp=1354563717.472648,  # Once upon a time...
                topic="org.threebean.prod.testing",
            )

            yield ("name", "endpoint", "topic", msg)

        config = {}
        with patch("fedmsg.__local", self.local):
            with patch("fedmsg.config.__cache", config):
                with patch("fedmsg.core.FedMsgContext.tail_messages",
                           mock_tail):
                    command = fedmsg.commands.tail.TailCommand()
                    command.execute()

        output = stdout.getvalue()
        expected = \
            '\x1b[33m"hello"\x1b[39;49;00m:\x1b[39;49;00m \x1b[39;49;00m' + \
            '\x1b[33m"world"\x1b[39;49;00m'

        assert(expected in output)

    @patch("sys.argv", new_callable=lambda: ["fedmsg-relay"])
    def test_relay(self, argv):
        actual_options = []

        def mock_main(options, consumers, framework):
            actual_options.append(options)

        config = {}
        with patch("fedmsg.__local", self.local):
            with patch("fedmsg.config.__cache", config):
                with patch("moksha.hub.main", mock_main):
                    command = fedmsg.commands.relay.RelayCommand()
                    command.execute()

        actual_options = actual_options[0]
        assert(
            fedmsg.consumers.relay.RelayConsumer.config_key in actual_options
        )
        assert(
            actual_options[fedmsg.consumers.relay.RelayConsumer.config_key]
        )

    @patch("sys.argv", new_callable=lambda: ["fedmsg-config"])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_config_basic(self, stdout, argv):
        with patch('fedmsg.config.__cache', {}):
            config_command()

        output = stdout.getvalue()
        output_conf = json.loads(output)

        with patch('fedmsg.config.__cache', {}):
            fedmsg_conf = fedmsg.config.load_config()

        eq_(output_conf, fedmsg_conf)

    @patch("sys.argv", new_callable=lambda: [
        "fedmsg-config", "--query", "endpoints",
    ])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_config_query(self, stdout, argv):
        with patch('fedmsg.config.__cache', {}):
            config_command()

        output = stdout.getvalue()
        output_conf = json.loads(output)

        with patch('fedmsg.config.__cache', {}):
            fedmsg_conf = fedmsg.config.load_config()

        eq_(output_conf, fedmsg_conf["endpoints"])

    @patch("sys.argv", new_callable=lambda: [
        "fedmsg-config", "--query", "endpoints.broken",
    ])
    @patch("sys.stdout", new_callable=six.StringIO)
    @patch("sys.stderr", new_callable=six.StringIO)
    def test_config_query_broken(self, stderr, stdout, argv):
        try:
            with patch('fedmsg.config.__cache', {}):
                config_command()
        except SystemExit as exc:
            eq_(exc.code, 1)
        else:
            output = "output: %r, error: %r" % (
                stdout.getvalue(), stderr.getvalue())
            assert False, output

        output = stdout.getvalue()
        error = stderr.getvalue()

        eq_(output.strip(), "")
        eq_(error.strip(), "Key `endpoints.broken` does not exist in config")

    @patch("sys.argv", new_callable=lambda: [
        "fedmsg-config", "--disable-defaults", "--config-filename", CONF_FILE,
    ])
    @patch("sys.stdout", new_callable=six.StringIO)
    def test_config_single_file(self, stdout, argv):
        with patch('fedmsg.config.__cache', {}):
            config_command()

        output = stdout.getvalue()
        output_conf = json.loads(output)

        with patch('fedmsg.config.__cache', {}):
            fedmsg_conf = fedmsg.config.load_config(
                filenames=[CONF_FILE],
                disable_defaults=True,
            )

        eq_(output_conf, fedmsg_conf)

########NEW FILE########
__FILENAME__ = test_config
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
""" Tests for fedmsg.config """

import unittest
from nose.tools import eq_

import fedmsg.config
from fedmsg.tests.common import load_config


class RecursiveUpdateBase(unittest.TestCase):
    originals = None
    expected = None

    def test_match(self):
        """ Does fedmsg.config._recursive_update produce the expected result?
        """

        if None in (self.originals, self.expected):
            return

        actual = dict()
        for o in self.originals:
            actual = fedmsg.config._recursive_update(actual, o)

        eq_(actual, self.expected)


class TestSimpleOne(RecursiveUpdateBase):
    originals = [dict(a=2)]
    expected = dict(a=2)


class TestSimpleTwo(RecursiveUpdateBase):
    originals = [
        dict(a=2),
        dict(b=3),
    ]
    expected = dict(a=2, b=3)


class TestOverwrite(RecursiveUpdateBase):
    originals = [
        dict(a=2),
        dict(a=3),
    ]
    expected = dict(a=3)


class TestMerge(RecursiveUpdateBase):
    originals = [
        dict(a=dict(a=2)),
        dict(a=dict(b=3)),
    ]
    expected = dict(a=dict(a=2, b=3))


class TestConfig(unittest.TestCase):
    """Test for try out the function iterate in
    endpoints config"""

    def test_config(self):
        config = load_config()
        endpoints = config['endpoints']

        for key, value in endpoints.items():
            assert isinstance(value, list), value


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_core
import unittest

import mock
import warnings
from fedmsg.core import FedMsgContext
from fedmsg.tests.common import load_config


class TestCore(unittest.TestCase):
    def setUp(self):
        config = load_config()
        config['io_threads'] = 1
        self.ctx = FedMsgContext(**config)

    def test_send_message(self):
        """send_message is deprecated

        It tests
        - deprecation warning showing up appropriately
        - that we call publish method behind the scene
        """
        fake_topic = "org.fedoraproject.prod.compose.rawhide.complete"
        fake_msg = "{'arch'': 's390', 'branch': 'rawhide', 'log': 'done'}"
        self.ctx.publish = mock.Mock(spec_set=FedMsgContext.publish)
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            self.ctx.send_message(topic=fake_topic, msg=fake_msg)
            assert len(w) == 1
            assert str(w[0].message) == ".send_message is deprecated."
            assert self.ctx.publish.called
            topic, msg, modname = self.ctx.publish.call_args[0]
            assert topic == fake_topic
            assert msg == fake_msg
            assert modname is None

########NEW FILE########
__FILENAME__ = test_crypto_gpg
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import os
import functools

from nose.tools import raises
from nose.exc import SkipTest

try:
    from nose.tools.nontrivial import make_decorator
except ImportError:
    # It lives here in older versions of nose (el6)
    from nose.tools import make_decorator

import unittest

import fedmsg.crypto.gpg

SEP = os.path.sep
here = SEP.join(__file__.split(SEP)[:-1])

data_dir = SEP.join((here, 'test_certs', 'gpg'))
keyrings = []
clear_data_path = os.path.join(data_dir, "test_data")
secret_fp = 'FBDA 92E4 338D FFD9 EB83  F8F6 3FBD B725 DA19 B4EC'


def skip_on_travis(fn):
    """ A decorator that just skips some tests on travis-ci.org """
    @functools.wraps(fn)
    def newfunc(self, *args, **kw):
        if os.environ.get('TRAVIS', None):
            raise SkipTest("gpg permissions are weird on travis-ci.org")
        return fn(self, *args, **kw)
    return make_decorator(fn)(newfunc)


class TestGpg(unittest.TestCase):
    def setUp(self):
        self.ctx = fedmsg.crypto.gpg.Context(keyrings=keyrings,
                                             homedir=data_dir)

    def test_verif_detach_sig(self):
        signature_path = os.path.join(data_dir, "test_data.sig")
        self.ctx.verify(open(clear_data_path, 'r').read(),
                        signature=open(signature_path, 'rb').read())
        self.ctx.verify_from_file(clear_data_path, sig_path=signature_path)

    @raises(fedmsg.crypto.gpg.GpgBinaryError)
    def test_corrupt_detach_sig(self):
        signature_path = os.path.join(data_dir, "corrupt.sig")
        self.ctx.verify_from_file(clear_data_path, sig_path=signature_path)

    @skip_on_travis
    def test_sign_cleartext(self):
        test_data = u'I can haz a signature?'
        signed_text = self.ctx.clearsign(test_data, fingerprint=secret_fp)
        self.ctx.verify(signed_text)

    @skip_on_travis
    def test_sign_detached(self):
        test_data = u'I can haz a signature?'
        signature = self.ctx.sign(test_data, fingerprint=secret_fp)
        self.ctx.verify(test_data, signature)


import fedmsg.crypto


class TestCryptoGPG(unittest.TestCase):
    def setUp(self):
        gpg_key = 'FBDA 92E4 338D FFD9 EB83  F8F6 3FBD B725 DA19 B4EC'
        self.config = {
            'crypto_backend': 'gpg',
            'gpg_home': SEP.join((here, 'test_certs', 'gpg')),
            'gpg_signing_key': gpg_key
        }

    def tearDown(self):
        self.config = None

    @skip_on_travis
    def test_full_circle(self):
        """ Try to sign and validate a message. """
        message = dict(msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        assert fedmsg.crypto.validate(signed, **self.config)

    @skip_on_travis
    def test_failed_validation(self):
        message = dict(msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        # space aliens read data off the wire and inject incorrect data
        signed['msg'] = "eve wuz here"
        assert not fedmsg.crypto.validate(signed, **self.config)

    def tearDown(self):
        # We have to reset the implementation in fedmsg.crypto
        # otherwise all the other tests will use the gpg backend
        fedmsg.crypto._implementation = None


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_crypto_switching
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import six
import os

import nose.tools.nontrivial

try:
    # For python-2.6, so we can do skipTest
    import unittest2 as unittest
except ImportError:
    import unittest

import fedmsg.crypto

SEP = os.path.sep
here = SEP.join(__file__.split(SEP)[:-1])


def skip_if_missing_x509_libs(f):
    def _wrapper(self, *args, **kw):
        try:
            import M2Crypto
            import m2ext
        except ImportError as e:
            self.skipTest(six.text_type(e))

        return f(self, *args, **kw)

    return nose.tools.nontrivial.make_decorator(f)(_wrapper)


class TestCryptoSwitching(unittest.TestCase):

    def setUp(self):
        self.config = {
            # Normally this is /var/lib/puppet/ssl
            'ssldir': SEP.join((here, 'test_certs/keys')),
            # Normally this is 'app01.stg.phx2.fedoraproject.org'
            'certname': 'shell-app01.phx2.fedoraproject.org',
            'crl_location': "http://threebean.org/fedmsg-tests/crl.pem",
            'crl_cache': "/tmp/crl.pem",
            'crl_cache_expiry': 10,

            # But *not* x509
            'crypto_validate_backends': ['gpg'],
        }
        # Need to reset this global
        fedmsg.crypto._validate_implementations = None

    def tearDown(self):
        self.config = None
        # Need to reset this global
        fedmsg.crypto._validate_implementations = None

    @skip_if_missing_x509_libs
    def test_invalid_validator(self):
        """ Try to verify an x509 message when only gpg is allowed. """
        message = dict(msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        assert not fedmsg.crypto.validate(signed, **self.config)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_crypto_x509
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import os
import shutil
import six

import nose.tools.nontrivial

try:
    # For python-2.6, so we can do skipTest
    import unittest2 as unittest
except ImportError:
    import unittest

import fedmsg.crypto

SEP = os.path.sep
here = SEP.join(__file__.split(SEP)[:-1])


def skip_if_missing_libs(f):
    def _wrapper(self, *args, **kw):
        try:
            import M2Crypto
            import m2ext
        except ImportError as e:
            self.skipTest(six.text_type(e))

        return f(self, *args, **kw)

    return nose.tools.nontrivial.make_decorator(f)(_wrapper)


class TestCryptoX509(unittest.TestCase):

    def setUp(self):
        self.config = {
            # Normally this is /var/lib/puppet/ssl
            'ssldir': SEP.join((here, 'test_certs/keys')),
            # Normally this is 'app01.stg.phx2.fedoraproject.org'
            'certname': 'shell-app01.phx2.fedoraproject.org',

            'ca_cert_cache': '/var/tmp/fedmsg-ca.crt',
            'ca_cert_cache_expiry': 10000,

            'crl_location': "http://threebean.org/fedmsg-tests/crl.pem",
            'crl_cache': "/var/tmp/crl.pem",
            'crl_cache_expiry': 10000,
            'crypto_validate_backends': ['x509'],
        }
        # Need to reset this global
        fedmsg.crypto._validate_implementations = None
        shutil.copy(
            src=SEP.join([self.config['ssldir'], 'ca.crt']),
            dst=self.config['ca_cert_cache'],
        )
        shutil.copy(
            src=SEP.join([self.config['ssldir'], 'crl.pem']),
            dst=self.config['crl_cache'],
        )

    def tearDown(self):
        os.remove(self.config['ca_cert_cache'])
        os.remove(self.config['crl_cache'])
        self.config = None
        # Need to reset this global
        fedmsg.crypto._validate_implementations = None

    @skip_if_missing_libs
    def test_full_circle(self):
        """ Try to sign and validate a message. """
        message = dict(msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        assert fedmsg.crypto.validate(signed, **self.config)

    @skip_if_missing_libs
    def test_failed_validation(self):
        """ Try to fail validation. """
        message = dict(msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        # space aliens read data off the wire and inject incorrect data
        signed['msg'] = "eve wuz here"
        assert not fedmsg.crypto.validate(signed, **self.config)

    @skip_if_missing_libs
    def test_signed_by_true(self):
        """ Try to succeed at specific-signer validation. """
        message = dict(topic='biz.bar', msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        signer = "shell-app01.phx2.fedoraproject.org"
        res = fedmsg.crypto.validate_signed_by(signed, signer, **self.config)
        assert res

    @skip_if_missing_libs
    def test_signed_by_false(self):
        """ Try to fail at specific-signer validation. """
        message = dict(topic='biz.bar', msg='awesome')
        signed = fedmsg.crypto.sign(message, **self.config)
        signer = "shell-app02.phx2.fedoraproject.org"
        res = fedmsg.crypto.validate_signed_by(signed, signer, **self.config)
        assert not res


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_hub
# This file *was* a part of Moksha.
# Copyright (C) 2008 - 2014  Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

try:
    # For python-2.6, so we can do skipTest
    import unittest2 as unittest
except ImportError:
    import unittest

import os
import socket

from time import sleep, time
from uuid import uuid4

from moksha.hub.tests.test_hub import simulate_reactor
from moksha.hub.hub import MokshaHub
from moksha.hub import CentralMokshaHub
from fedmsg.core import FedMsgContext

from nose.tools import eq_, assert_true, assert_false, raises

import fedmsg.config
import fedmsg.consumers
import fedmsg.encoding

from fedmsg.tests.common import load_config


# Some constants used throughout the hub tests
sleep_duration = 0.25
secret = "secret_message"


@raises(KeyError)
def test_init_missing_cert():
    """ Try to initialize the context with a nonexistant cert. """
    config = load_config()
    config['name'] = "failboat"
    config['sign_messages'] = True
    context = FedMsgContext(**config)
    context.publish(topic='awesome', msg=dict(foo='bar'))


class TestHub(unittest.TestCase):

    def setUp(self):
        config = load_config()
        self.hub = CentralMokshaHub(config=config)
        self.context = FedMsgContext(**config)

        # fully qualified
        self.fq_topic = "com.test_prefix.dev.%s.foo" % unittest.__name__
        # short version
        self.topic = "foo"

    def tearDown(self):
        self.context.destroy()
        self.hub.close()

    def test_send_recv(self):
        """ Send a message and receive it.

        Admittedly, this is not a unit test, but an integration test.

        It tests:

            - Sending a message.
            - Receiving a message.
            - Encoding *and* decoding.

        """
        messages_received = []

        def callback(json):
            messages_received.append(fedmsg.encoding.loads(json.body))

        self.hub.subscribe(topic=self.fq_topic, callback=callback)
        sleep(sleep_duration)

        self.context.publish(topic=self.topic, msg=secret)

        simulate_reactor(sleep_duration)
        sleep(sleep_duration)

        eq_(len(messages_received), 1)
        eq_(messages_received[0]['msg'], secret)

    def fake_register_consumer(self, cons):
        """ Fake register a consumer, not by entry-point like usual.

        Normally, consumers are identified by the hub by way of entry-points
        Ideally, this test would register the TestConsumer on the
        moksha.consumers entry point, and the hub would pick it up.
        I'm not sure how to do that, so we're going to fake it and manually
        add this consumer to the list of consumers of which the Hub is aware.
        """
        self.hub.topics[cons.topic] = self.hub.topics.get(cons.topic, [])
        self.hub.topics[cons.topic].append(cons(self.hub).consume)
        sleep(sleep_duration)

    def test_consumer(self):
        """ Check that a consumer can get messages. """
        obj = {'secret': secret}
        messages_received = []

        class TestConsumer(fedmsg.consumers.FedmsgConsumer):
            topic = self.fq_topic
            config_key = "test_consumer_enabled"

            def _consume(self, message):
                messages_received.append(
                    message['body']['msg']
                )

        self.fake_register_consumer(TestConsumer)

        # Now, send a generic message to that topic, and see if the consumer
        # processed it.
        self.context.publish(topic=self.topic, msg=obj)

        simulate_reactor(sleep_duration)
        sleep(sleep_duration)
        simulate_reactor(sleep_duration)
        sleep(sleep_duration)

        eq_(len(messages_received), 1)
        eq_(messages_received[0], obj)

    def test_double_consumers(self):
        """ Check that two consumers can get messages. """
        obj = {'secret': secret}
        messages_received = []

        class TestConsumer1(fedmsg.consumers.FedmsgConsumer):
            topic = self.fq_topic
            config_key = "test_consumer_enabled"

            def _consume(self, message):
                messages_received.append(
                    message['body']['msg']
                )

        class TestConsumer2(fedmsg.consumers.FedmsgConsumer):
            topic = self.fq_topic
            config_key = "test_consumer_enabled"

            def _consume(self, message):
                messages_received.append(
                    message['body']['msg']
                )

        self.fake_register_consumer(TestConsumer1)
        self.fake_register_consumer(TestConsumer2)

        # Now, send a generic message to that topic, and see if the consumer
        # processed it.
        self.context.publish(topic=self.topic, msg=obj)

        simulate_reactor(sleep_duration)
        sleep(sleep_duration)

        eq_(len(messages_received), 2)
        eq_(messages_received[0], obj)
        eq_(messages_received[1], obj)

    def test_consumer_failed_validation(self):
        """ Check that a consumer won't consume invalid message. """

        # TODO -- now that moksha.hub is doing its internal threading/queueing
        # behavior, this feature of fedmsg is a bit more difficult to test.
        raise self.skipTest("Not sure how to test this behavior now.")

        obj = {'secret': secret}
        messages_received = []

        class TestConsumer(fedmsg.consumers.FedmsgConsumer):
            topic = self.fq_topic
            config_key = "test_consumer_enabled"

            def _consume(self, message):
                messages_received.append(
                    message['body']['msg']
                )

            def validate(self, message):
                raise RuntimeWarning("Marking message as invalid.")

        self.fake_register_consumer(TestConsumer)
        self.context.publish(topic=self.topic, msg=obj)
        simulate_reactor(sleep_duration)
        sleep(sleep_duration)

        # Verify that we received no message.
        eq_(len(messages_received), 0)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_meta
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
""" Tests for fedmsg.meta """

import os
import unittest

from nose import SkipTest
from nose.tools import eq_

try:
    from nose.tools.nontrivial import make_decorator
except ImportError:
    # It lives here in older versions of nose (el6)
    from nose.tools import make_decorator

import fedmsg.meta

from fedmsg.tests.common import load_config


def skip_on(attributes):
    """ A test decorator that will skip if any of the named attributes
    are left unspecified (are None-valued).
    """
    def wrapper(func):
        @make_decorator(func)
        def inner(self):
            for attr in attributes:
                if getattr(self, attr) is None:
                    raise SkipTest("%r left unspecified" % attr)
            return func(self)
        return inner
    return wrapper


def skip_if_fedmsg_meta_FI_is_present(f):
    """ A test decorator that will skip if fedmsg_meta_fedora_infrastructure
    is installed.

    The presence of that module will screw up some tests.
    """
    def _wrapper(self, *args, **kw):
        try:
            import fedmsg_meta_fedora_infrastructure
            raise SkipTest("fedmsg_meta_FI is present")
        except ImportError:
            pass

        return f(self, *args, **kw)

    return make_decorator(f)(_wrapper)


class TestForWarning(unittest.TestCase):
    def setUp(self):
        dirname = os.path.abspath(os.path.dirname(__file__))
        self.config = fedmsg.config.load_config(
            filenames=[os.path.join(dirname, "fedmsg-test-config.py")],
            invalidate_cache=True,
        )
        self.config['topic_prefix'] = 'org.fedoraproject'
        self.config['topic_prefix_re'] = '^org\.fedoraproject\.(dev|stg|prod)'

    @skip_if_fedmsg_meta_FI_is_present
    def test_for_no_plugins(self):
        """ Test that we print a warning if no plugin is installed """
        messages = []

        def mocked_warning(message):
            messages.append(message)

        expected = 'No fedmsg.meta plugins found.  fedmsg.meta.msg2* crippled'
        original = fedmsg.meta.log.warn
        try:
            fedmsg.meta.log.warn = mocked_warning
            fedmsg.meta.make_processors(**self.config)
            eq_(messages, [expected])
        finally:
            fedmsg.meta.log.warn = original


class TestProcessorRegex(unittest.TestCase):
    def setUp(self):
        dirname = os.path.abspath(os.path.dirname(__file__))
        self.config = fedmsg.config.load_config(
            filenames=[os.path.join(dirname, "fedmsg-test-config.py")],
            invalidate_cache=True,
        )
        self.config['topic_prefix'] = 'org.fedoraproject'
        self.config['topic_prefix_re'] = '^org\.fedoraproject\.(dev|stg|prod)'

        class MyGitProcessor(fedmsg.meta.base.BaseProcessor):
            __name__ = 'git'
            __description__ = 'This processor handles git messages'
            __link__ = 'http://fedmsg.com'
            __docs__ = 'http://fedmsg.com'
            __obj__ = 'git commits'

        self.proc = MyGitProcessor(lambda x: x, **self.config)

    def test_processor_handle_hit(self):
        """ Test that a proc can handle what it should. """
        fake_message = {
            'topic': 'org.fedoraproject.dev.git.push',
        }
        result = self.proc.handle_msg(fake_message, **self.config)
        assert result, "Proc didn't say it could handle the message."

    def test_processor_handle_miss(self):
        """ Test that a proc says it won't handle what it shouldn't. """
        fake_message = {
            'topic': 'org.fedoraproject.dev.github.push',
        }
        result = self.proc.handle_msg(fake_message, **self.config)
        assert not result, "Proc falsely claimed it could handle the msg."


class Base(unittest.TestCase):
    msg = None
    expected_title = None
    expected_subti = None
    expected_link = None
    expected_icon = None
    expected_secondary_icon = None
    expected_usernames = None
    expected_packages = None
    expected_objects = None
    expected_emails = None
    expected_avatars = None

    def setUp(self):
        dirname = os.path.abspath(os.path.dirname(__file__))
        self.config = fedmsg.config.load_config(
            filenames=[os.path.join(dirname, "fedmsg-test-config.py")],
            invalidate_cache=True,
        )
        self.config['topic_prefix'] = 'org.fedoraproject'
        self.config['topic_prefix_re'] = '^org\.fedoraproject\.(dev|stg|prod)'
        fedmsg.meta.make_processors(**self.config)

    @skip_on(['msg', 'expected_title'])
    def test_title(self):
        """ Does fedmsg.meta produce the expected title? """
        actual_title = fedmsg.meta.msg2title(self.msg, **self.config)
        eq_(actual_title, self.expected_title)

    @skip_on(['msg', 'expected_subti'])
    def test_subtitle(self):
        """ Does fedmsg.meta produce the expected subtitle? """
        actual_subti = fedmsg.meta.msg2subtitle(self.msg, **self.config)
        eq_(actual_subti, self.expected_subti)

    @skip_on(['msg', 'expected_link'])
    def test_link(self):
        """ Does fedmsg.meta produce the expected link? """
        actual_link = fedmsg.meta.msg2link(self.msg, **self.config)
        eq_(actual_link, self.expected_link)

    @skip_on(['msg', 'expected_icon'])
    def test_icon(self):
        """ Does fedmsg.meta produce the expected icon? """
        actual_icon = fedmsg.meta.msg2icon(self.msg, **self.config)
        eq_(actual_icon, self.expected_icon)

    @skip_on(['msg', 'expected_secondary_icon'])
    def test_secondary_icon(self):
        """ Does fedmsg.meta produce the expected secondary icon? """
        actual_icon = fedmsg.meta.msg2secondary_icon(self.msg, **self.config)
        eq_(actual_icon, self.expected_secondary_icon)

    @skip_on(['msg', 'expected_usernames'])
    def test_usernames(self):
        """ Does fedmsg.meta produce the expected list of usernames? """
        actual_usernames = fedmsg.meta.msg2usernames(self.msg, **self.config)
        eq_(actual_usernames, self.expected_usernames)

    @skip_on(['msg', 'expected_packages'])
    def test_packages(self):
        """ Does fedmsg.meta produce the expected list of packages? """
        actual_packages = fedmsg.meta.msg2packages(self.msg, **self.config)
        eq_(actual_packages, self.expected_packages)

    @skip_on(['msg', 'expected_objects'])
    def test_objects(self):
        """ Does fedmsg.meta produce the expected list of objects? """
        actual_objects = fedmsg.meta.msg2objects(self.msg, **self.config)
        eq_(actual_objects, self.expected_objects)

    @skip_on(['msg', 'expected_emails'])
    def test_emails(self):
        """ Does fedmsg.meta produce the expected list of emails? """
        actual_emails = fedmsg.meta.msg2emails(self.msg, **self.config)
        eq_(actual_emails, self.expected_emails)

    @skip_on(['msg', 'expected_avatars'])
    def test_avatars(self):
        """ Does fedmsg.meta produce the expected list of avatars? """
        actual_avatars = fedmsg.meta.msg2avatars(self.msg, **self.config)
        eq_(actual_avatars, self.expected_avatars)


class TestUnhandled(Base):
    expected_title = "unhandled_service.some_event"
    expected_subti = ""
    msg = {
        "topic": "org.fedoraproject.stg.unhandled_service.some_event"
    }


class TestAnnouncement(Base):
    expected_title = "announce.announcement"
    expected_subti = 'hello, world.'
    expected_link = 'foo'
    expected_usernames = set(['ralph'])

    msg = {
        "i": 1,
        "timestamp": 1344352873.714926,
        "topic": "org.fedoraproject.dev.announce.announcement",
        "msg": {
            "message": "hello, world.",
            "link": "foo",
        },
        'username': 'ralph',
    }


class TestLoggerNormal(Base):
    expected_title = "logger.log"
    expected_subti = 'hello, world. (ralph)'
    expected_usernames = set(['ralph'])

    msg = {
        "i": 1,
        "timestamp": 1344352873.714926,
        "topic": "org.fedoraproject.dev.logger.log",
        "msg": {
            "log": "hello, world."
        },
        'username': 'ralph',
    }


class TestLoggerJSON(Base):
    expected_title = "logger.log"
    expected_subti = '<custom JSON message> (root)'
    expected_usernames = set(['root'])

    msg = {
        "i": 1,
        "timestamp": 1344352929.415939,
        "topic": "org.fedoraproject.dev.logger.log",
        "msg": {
            "foo": "bar"
        },
        'username': 'root',
    }


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_replay
# This file is part of fedmsg.
# Copyright (C) 2013 Simon Chopin <chopin.simon@gmail.com
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors: Simon Chopin <chopin.simon@gmail.com>
#
''' Tests for fedmsg.replay '''

import sys

if sys.version_info[0] == 2 and sys.version_info[1] < 7:
    import unittest2 as unittest
else:
    import unittest

from nose.tools import raises
from mock import Mock, call

import json
import time
from datetime import datetime
import zmq
import socket
from threading import Thread, Event

from fedmsg.tests.common import load_config

from fedmsg.replay import ReplayContext, get_replay

from fedmsg.replay.sqlstore import SqlStore, SqlMessage
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

hostname = socket.gethostname().split('.', 1)[0]
local_name = '{0}.{1}'.format(unittest.__name__, hostname)


@raises(KeyError)
def test_init_missing_endpoint():
    """ Try to initialize the context with a nonexistant service name. """
    config = load_config()
    config['persistent_store'] = Mock()
    config['name'] = "failboat"
    context = ReplayContext(**config)


@raises(ValueError)
def test_init_missing_store():
    config = load_config()
    context = ReplayContext(**config)


@raises(IOError)
def test_init_invalid_endpoint():
    try:
        config = load_config()
        config['name'] = local_name
        config['persistent_store'] = Mock()
        tmp = zmq.Context()
        placeholder = tmp.socket(zmq.REP)
        placeholder.bind('tcp://*:{0}'.format(
            config["replay_endpoints"][local_name].rsplit(':')[-1]
        ))
        context = ReplayContext(**config)
    finally:
        placeholder.close()


class TestReplayContext(unittest.TestCase):
    def setUp(self):
        self.config = load_config()
        self.config['name'] = local_name
        self.config['persistent_store'] = Mock()
        self.replay_context = ReplayContext(**self.config)
        self.request_context = zmq.Context()
        self.request_socket = self.request_context.socket(zmq.REQ)
        self.request_socket.connect(
            self.config['replay_endpoints'][local_name])

    def tearDown(self):
        self.request_socket.close()
        self.replay_context.publisher.close()

    def test_get_replay(self):
        # Setup the store to return what we ask.
        answer = [{'foo': 'bar'}]
        self.config['persistent_store'].get = Mock(side_effect=[answer])
        # Doesn't matter what we send as long as it is legit JSON,
        # since the store is mocked
        self.request_socket.send(u'{"id": 1}'.encode('utf-8'))
        self.replay_context._req_rep_cycle()

        rep = self.request_socket.recv_multipart()
        print(rep)
        print(answer)

        assert len(answer) == len(rep)
        for r, a in zip(rep, answer):
            self.assertDictEqual(json.loads(r.decode('utf-8')), a)

    def test_get_error(self):
        # Setup the store to return what we ask.
        answer = ValueError('No luck!')
        self.config['persistent_store'].get = Mock(side_effect=[answer])
        # Doesn't matter what we send as long as it is legit JSON,
        # since the store is mocked
        self.request_socket.send(u'{"id": 1}'.encode('utf-8'))
        self.replay_context._req_rep_cycle()

        rep = self.request_socket.recv_multipart()
        print(rep)

        assert len(rep) == 1 and "error: 'No luck!'" == rep[0].decode('utf-8')


class TestSqlStore(unittest.TestCase):
    def setUp(self):
        self.engine = create_engine('sqlite:///:memory:')
        self.store = SqlStore(self.engine)
        msgs = [
            {
                "i": 0,
                "topic": "org.foo.bar",
                "msg_id": "11111111-1111-1111-1111-111111111111",
                "timestamp": 2,
                "seq_id": 1,
                "msg": {"foo": "bar"},
            },
            {
                "i": 1,
                "topic": "org.foo.bar",
                "msg_id": "22222222-2222-2222-2222-222222222222",
                "timestamp": 10,
                "seq_id": 2,
                "msg": {"foo": "baz"},
            }
        ]
        session = self.store.session_class()
        for m in msgs:
            session.add(SqlMessage(
                seq_id=m['seq_id'],
                uuid=m['msg_id'],
                timestamp=datetime.fromtimestamp(m['timestamp']),
                topic=m['topic'],
                msg=json.dumps(m)
            ))
        session.commit()

    def test_add(self):
        orig_msg = {
            "i": 2,
            "topic": "org.foo.bar",
            "msg_id": "33333333-3333-3333-3333-333333333333",
            "timestamp": 20,
            "msg": {"foo": "foo"}
        }
        # make a copy to avoid squewing the comparison
        ret = self.store.add(dict(orig_msg))

        orig_msg['seq_id'] = 3
        self.assertDictEqual(ret, orig_msg)

        session = self.store.session_class()
        sql_msg = session.query(SqlMessage)\
            .filter(SqlMessage.seq_id == 3).one()
        self.assertDictEqual(json.loads(sql_msg.msg), orig_msg)

    def test_get_seq_id(self):
        first = self.store.get({"seq_id": 1})
        assert len(first) == 1 and first[0]['i'] == 0

    def test_get_time(self):
        first, second = self.store.get({"time": [0, 15]})
        assert (
            (first['i'] == 0 and second['i'] == 1) or
            (first['i'] == 1 and second['i'] == 0))

    @raises(ValueError)
    def test_get_wrong_seq_id(self):
        first = self.store.get({"seq_id": 18})

    @raises(ValueError)
    def test_get_illformed_time(self):
        first, second = self.store.get({"time": [0, 15, 3]})


class ReplayThread(Thread):
    def __init__(self, context):
        self.stop = Event()
        self.context = context
        super(ReplayThread, self).__init__()

    def run(self):
        try:
            while not self.stop.is_set():
                self.context._req_rep_cycle()
        finally:
            self.context.publisher.close()


class TestGetReplay(unittest.TestCase):
    def setUp(self):
        self.config = load_config()
        self.config['name'] = local_name
        self.config['mute'] = True
        self.config['persistent_store'] = Mock()
        self.replay_context = ReplayContext(**self.config)
        self.replay_thread = ReplayThread(self.replay_context)
        self.context = zmq.Context()

    def tearDown(self):
        self.replay_thread.stop.set()

    @raises(IOError)
    def test_get_replay_no_available_endpoint(self):
        #self.replay_thread.start()
        msgs = list(get_replay(
            "phony", {"seq_ids": [1, 2]}, self.config, self.context
        ))

    @raises(ValueError)
    def test_get_replay_wrong_query(self):
        # We don't actually test with a wrong query, we just throw back an
        # error from the store.
        self.config['persistent_store'].get = Mock(
            side_effect=[ValueError("this is an error")])
        self.replay_thread.start()
        msgs = list(get_replay(
            local_name, {"seq_ids": [1, 2]}, self.config, self.context
        ))

    def test_get_replay(self):
        # As before, the correctness of the query doesn't matter much
        # since it is taken care of on the server side.
        orig_msg = {
            "i": 2,
            "seq_id": 3,
            "topic": "org.foo.bar",
            "msg_id": "33333333-3333-3333-3333-333333333333",
            "timestamp": 20,
            "msg": {"foo": "foo"}
        }
        self.config['persistent_store'].get = Mock(side_effect=[[orig_msg]])
        self.replay_thread.start()
        msgs = list(get_replay(
            local_name, {"seq_id": 3}, self.config, self.context
        ))
        assert len(msgs) == 1
        self.assertDictEqual(msgs[0], orig_msg)

########NEW FILE########
__FILENAME__ = test_threads
# This file *was* a part of Moksha.
# Copyright (C) 2008-2010  Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

try:
    # For python-2.6, so we can do skipTest
    import unittest2 as unittest
except ImportError:
    import unittest

import threading
import copy
import os
import socket

from time import sleep, time
from uuid import uuid4

from moksha.hub.tests.test_hub import simulate_reactor
from moksha.hub.hub import MokshaHub
from moksha.hub import CentralMokshaHub
from fedmsg.core import FedMsgContext

from nose.tools import eq_, assert_true, assert_false, raises

import fedmsg.config
import fedmsg.consumers
import fedmsg.encoding


# Some constants used throughout the hub tests
sleep_duration = 0.25
secret = "secret_message"


def load_config(name='fedmsg-test-config.py'):
    here = os.path.sep.join(__file__.split(os.path.sep)[:-1])
    test_config = os.path.sep.join([here, name])

    config = fedmsg.config.load_config(
        [],
        "awesome",
        filenames=[
            test_config,
        ],
        invalidate_cache=True
    )

    # TODO -- this appears everywhere and should be encapsulated in a func
    # Massage the fedmsg config into the moksha config.
    config['zmq_subscribe_endpoints'] = ','.join(
        ','.join(bunch) for bunch in config['endpoints'].values()
    )
    hub_name = "twisted.%s" % socket.gethostname().split('.', 1)[0]
    config['zmq_publish_endpoints'] = ','.join(
        config['endpoints'][hub_name]
    )
    config['sign_messages'] = False
    return config


class TestHub(unittest.TestCase):

    def setUp(self):
        config = load_config()
        self.config = config
        self.hub = CentralMokshaHub(config=config)

        # fully qualified
        self.fq_topic = "com.test_prefix.dev.threadtest.foo"
        # short version
        self.topic = "foo"

    def tearDown(self):
        self.hub.close()

    def test_multi_threaded(self):
        """ Send messages from 5 concurrent threads. """
        messages_received = []

        def callback(json):
            messages_received.append(fedmsg.encoding.loads(json.body))

        self.hub.subscribe(topic=self.fq_topic, callback=callback)
        sleep(sleep_duration)

        test_name = "__main__.%s" % socket.gethostname().split('.', 1)[0]
        self.config['name'] = test_name

        class Publisher(threading.Thread):
            def run(shmelf):
                config = copy.deepcopy(self.config)
                import fedmsg
                fedmsg.init(**config)
                fedmsg.publish(topic=self.topic, msg=secret,
                               modname="threadtest")

        threads = [Publisher() for i in range(5)]
        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()

        simulate_reactor(sleep_duration)
        sleep(sleep_duration)

        eq_(len(messages_received), 5)
        eq_(messages_received[0]['msg'], secret)

    def test_reinitialize(self):
        """ In a thread, try to destroy and re-init the API. """

        test_name = "__main__.%s" % socket.gethostname().split('.', 1)[0]
        self.config['name'] = test_name

        self.test_reinit_success = False

        class Publisher(threading.Thread):
            def run(shmelf):
                config = copy.deepcopy(self.config)
                import fedmsg
                fedmsg.init(**config)
                fedmsg.destroy()
                fedmsg.init(**config)
                fedmsg.destroy()
                fedmsg.init(**config)
                fedmsg.destroy()
                self.test_reinit_success = True

        thread = Publisher()
        thread.start()
        thread.join()

        assert(self.test_reinit_success)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils
from nose.tools import raises, eq_
from fedmsg.utils import load_class, dict_query


def test_load_class_succeed():
    cls = load_class("shelve:Shelf")
    from shelve import Shelf
    eq_(cls, Shelf)


@raises(ImportError)
def test_load_class_import_error():
    cls = load_class("thisisnotapackage:ThisIsNotAClass")


@raises(ImportError)
def test_load_class_attribute_error():
    cls = load_class("shelve:ThisIsNotAClass")


def test_dict_query_basic():
    dct = {
        'foo': {
            'bar': {
                'baz': 'wat',
            }
        }
    }
    key = 'foo.bar.baz'
    result = dict_query(dct, key)
    eq_(result, {key: 'wat'})


def test_dict_query_miss():
    dct = {
        'foo': {
            'bar': {
                'baz': 'wat',
            }
        }
    }
    key = 'foo.bar.zomg'
    result = dict_query(dct, key)
    eq_(result, {key: None})


def test_dict_query_fancy_one():
    dct = {
        'foo': {
            'bar': {
                'zip': 'zoom',
                'baz': 'wat',
            }
        }
    }
    key = 'foo.bar'
    result = dict_query(dct, key)
    eq_(result, {key: {'baz': 'wat', 'zip': 'zoom'}})


def test_dict_query_fancy_two():
    dct = {
        'foo': {
            'bar': {
                'zip': 'zoom',
                'baz': 'wat',
            },
            'har': 'loktar ogar',
        }
    }
    key1 = 'foo.bar'
    result = dict_query(dct, key1)
    eq_(result, {key1: {'baz': 'wat', 'zip': 'zoom'}})
    key2 = 'foo.har'
    result = dict_query(dct, key2)
    eq_(result, {key2: 'loktar ogar'})


@raises(ValueError)
def test_dict_query_weird_inputs():
    dct = {
        'foo': {
            'bar': {
                'baz': 'wat',
            },
        }
    }
    key = None
    result = dict_query(dct, key)
    eq_(result, {key: {'baz': 'wat', 'zip': 'zoom'}})

########NEW FILE########
__FILENAME__ = utils
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#

import six
import zmq
import logging
import inspect

try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict


def set_high_water_mark(socket, config):
    """ Set a high water mark on the zmq socket.  Do so in a way that is
    cross-compatible with zeromq2 and zeromq3.
    """

    if config['high_water_mark']:
        if hasattr(zmq, 'HWM'):
            # zeromq2
            socket.setsockopt(zmq.HWM, config['high_water_mark'])
        else:
            # zeromq3
            socket.setsockopt(zmq.SNDHWM, config['high_water_mark'])
            socket.setsockopt(zmq.RCVHWM, config['high_water_mark'])


# TODO -- this should be in kitchen, not fedmsg
def guess_calling_module(default=None):
    # Iterate up the call-stack and return the first new top-level module
    for frame in (f[0] for f in inspect.stack()):
        modname = frame.f_globals['__name__'].split('.')[0]
        if modname != "fedmsg":
            return modname

    # Otherwise, give up and just return the default.
    return default


def set_tcp_keepalive(socket, config):
    """ Set a series of TCP keepalive options on the socket if
    and only if
      1) they are specified explicitly in the config and
      2) the version of pyzmq has been compiled with support

    We ran into a problem in FedoraInfrastructure where long-standing
    connections between some hosts would suddenly drop off the
    map silently.  Because PUB/SUB sockets don't communicate
    regularly, nothing in the TCP stack would automatically try and
    fix the connection.  With TCP_KEEPALIVE options (introduced in
    libzmq 3.2 and pyzmq 2.2.0.1) hopefully that will be fixed.

    See the following
      - http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html
      - http://api.zeromq.org/3-2:zmq-setsockopt
    """

    keepalive_options = {
        # Map fedmsg config keys to zeromq socket constants
        'zmq_tcp_keepalive': 'TCP_KEEPALIVE',
        'zmq_tcp_keepalive_cnt': 'TCP_KEEPALIVE_CNT',
        'zmq_tcp_keepalive_idle': 'TCP_KEEPALIVE_IDLE',
        'zmq_tcp_keepalive_intvl': 'TCP_KEEPALIVE_INTVL',
    }
    for key, const in keepalive_options.items():
        if key in config:
            attr = getattr(zmq, const, None)
            if attr:
                socket.setsockopt(attr, config[key])


def set_tcp_reconnect(socket, config):
    """ Set a series of TCP reconnect options on the socket if
    and only if
      1) they are specified explicitly in the config and
      2) the version of pyzmq has been compiled with support

    Once our fedmsg bus grew to include many hundreds of endpoints, we started
    notices a *lot* of SYN-ACKs in the logs.  By default, if an endpoint is
    unavailable, zeromq will attempt to reconnect every 100ms until it gets a
    connection.  With this code, you can reconfigure that to back off
    exponentially to some max delay (like 1000ms) to reduce reconnect storm
    spam.

    See the following
      - http://api.zeromq.org/3-2:zmq-setsockopt
    """

    reconnect_options = {
        # Map fedmsg config keys to zeromq socket constants
        'zmq_reconnect_ivl': 'RECONNECT_IVL',
        'zmq_reconnect_ivl_max': 'RECONNECT_IVL_max',
    }
    for key, const in reconnect_options.items():
        if key in config:
            attr = getattr(zmq, const, None)
            if attr:
                socket.setsockopt(attr, config[key])


def load_class(location):
    """ Take a string of the form 'fedmsg.consumers.ircbot:IRCBotConsumer'
    and return the IRCBotConsumer class.
    """
    mod_name, cls_name = location = location.strip().split(':')
    tokens = mod_name.split('.')

    fromlist = '[]'
    if len(tokens) > 1:
        fromlist = '.'.join(tokens[:-1])

    module = __import__(mod_name, fromlist=fromlist)

    try:
        return getattr(module, cls_name)
    except AttributeError as e:
        raise ImportError("%r not found in %r" % (cls_name, mod_name))


def dict_query(dic, query):
    """ Query a dict with 'dotted notation'.  Returns an OrderedDict.

    A query of "foo.bar.baz" would retrieve 'wat' from this::

        dic = {
            'foo': {
                'bar': {
                    'baz': 'wat',
                }
            }
        }

    Multiple queries can be specified if comma-separated.  For instance, the
    query "foo.bar.baz,foo.bar.something_else" would return this::

        OrderedDict({
            "foo.bar.baz": "wat",
            "foo.bar.something_else": None,
        })

    """

    if not isinstance(query, six.string_types):
        raise ValueError("query must be a string, not %r" % type(query))

    def _browse(tokens, d):
        """ Recurse through a dict to retrieve a value. """
        current, rest = tokens[0], tokens[1:]

        if not rest:
            return d.get(current, None)

        if current in d:
            if isinstance(d[current], dict):
                return _browse(rest, d[current])
            elif rest:
                return None
            else:
                return d[current]

    keys = [key.strip().split('.') for key in query.split(',')]
    return OrderedDict([
        ('.'.join(tokens), _browse(tokens, dic)) for tokens in keys
    ])

########NEW FILE########
__FILENAME__ = base
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
config = dict(
    # Set this to dev if you're hacking on fedmsg or an app.
    # Set to stg or prod if running in the Fedora Infrastructure
    environment="dev",

    # Default is 0
    high_water_mark=0,
    io_threads=1,

    ## For the fedmsg-hub and fedmsg-relay. ##

    # We almost always want the fedmsg-hub to be sending messages with zmq as
    # opposed to amqp or stomp.
    zmq_enabled=True,

    # When subscribing to messages, we want to allow splats ('*') so we tell
    # the hub to not be strict when comparing messages topics to subscription
    # topics.
    zmq_strict=False,

    # Number of seconds to sleep after initializing waiting for sockets to sync
    post_init_sleep=0.5,

    # Wait a whole second to kill all the last io threads for messages to
    # exit our outgoing queue (if we have any).  This is in milliseconds.
    zmq_linger=1000,

    # See the following
    #   - http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html
    #   - http://api.zeromq.org/3-2:zmq-setsockopt
    zmq_tcp_keepalive=1,
    zmq_tcp_keepalive_cnt=3,
    zmq_tcp_keepalive_idle=60,
    zmq_tcp_keepalive_intvl=5,

    zmq_reconnect_ivl=100,
    zmq_reconnect_ivl_max=1000,
)

########NEW FILE########
__FILENAME__ = endpoints
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import socket
hostname = socket.gethostname().split('.', 1)[0]

config = dict(
    # This is a dict of possible addresses from which fedmsg can send
    # messages.  fedmsg.init(...) requires that a 'name' argument be passed
    # to it which corresponds with one of the keys in this dict.
    endpoints={
        # These are here so your local box can listen to the upstream
        # infrastructure's bus.  Cool, right?  :)
        "fedora-infrastructure": [
            "tcp://hub.fedoraproject.org:9940",
            #"tcp://stg.fedoraproject.org:9940",
        ],

        # For other, more 'normal' services, fedmsg will try to guess the
        # name of it's calling module to determine which endpoint definition
        # to use.  This can be overridden by explicitly providing the name in
        # the initial call to fedmsg.init(...).
        #"bodhi.%s" % hostname: ["tcp://127.0.0.1:3001"],
        #"fas.%s" % hostname: ["tcp://127.0.0.1:3002"],
        #"fedoratagger.%s" % hostname: ["tcp://127.0.0.1:3003"],
    },
)

########NEW FILE########
__FILENAME__ = gateway
config = {
    # This is the port for a special, outbound ZMQ pub socket on which we'll
    # rebroadcast everything on the fedmsg bus.
    'fedmsg.consumers.gateway.port': 9940,

    # Set this number to near, but not quite the fs.file-limit.  Try 160000.
    'fedmsg.consumers.gateway.high_water_mark': 10000,
}

########NEW FILE########
__FILENAME__ = ircbot
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
config = dict(
    irc=[
        dict(
            network='irc.freenode.net',
            port=6667,
            nickname='fedmsg-dev',
            channel='my-fedmsg-channel',
            timeout=120,
            make_pretty=True,
            make_terse=True,
            # Don't show the heartbeat... gross.
            filters=dict(
                topic=[],
                body=['lub-dub'],
            ),
        ),
    ],
    irc_color_lookup={
        "fas": "light blue",
        "bodhi": "green",
        "git": "red",
        "tagger": "brown",
        "wiki": "purple",
        "logger": "orange",
        "pkgdb": "teal",
        "buildsys": "yellow",
        "planet": "light green",
    },
    irc_method='notice',  # Either 'msg' or 'notice'
)

########NEW FILE########
__FILENAME__ = logging
# Setup fedmsg logging.
# See the following for constraints on this format http://bit.ly/Xn1WDn
bare_format = "[%(asctime)s][%(name)10s %(levelname)7s] %(message)s"

config = dict(
    logging=dict(
        version=1,
        formatters=dict(
            bare={
                "datefmt": "%Y-%m-%d %H:%M:%S",
                "format": bare_format
            },
        ),
        handlers=dict(
            console={
                "class": "logging.StreamHandler",
                "formatter": "bare",
                "level": "INFO",
                "stream": "ext://sys.stdout",
            }
        ),
        loggers=dict(
            fedmsg={
                "level": "INFO",
                "propagate": False,
                "handlers": ["console"],
            },
            moksha={
                "level": "INFO",
                "propagate": False,
                "handlers": ["console"],
            },
        ),
    ),
)

########NEW FILE########
__FILENAME__ = relay
# This file is part of fedmsg.
# Copyright (C) 2012 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#

config = dict(
    endpoints={
        # This is the output side of the relay to which all other
        # services can listen.
        "relay_outbound": [
            "tcp://127.0.0.1:4001",
        ],
    },

    # This is the address of an active->passive relay.  It is used for the
    # fedmsg-logger command which requires another service with a stable
    # listening address for it to send messages to.
    # It is also used by the git-hook, for the same reason.
    # It is also used by the mediawiki php plugin which, due to the oddities of
    # php, can't maintain a single passive-bind endpoint of it's own.
    relay_inbound=[
        "tcp://127.0.0.1:2003",
    ],
)

########NEW FILE########
__FILENAME__ = ssl
# This file is part of fedmsg.
# Copyright (C) 2012 - 2014 Red Hat, Inc.
#
# fedmsg is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# fedmsg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with fedmsg; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:  Ralph Bean <rbean@redhat.com>
#
import os
import socket

SEP = os.path.sep
here = os.getcwd()

config = dict(
    sign_messages=False,
    validate_signatures=True,

    # Use these implementations to sign and validate messages
    crypto_backend='x509',
    crypto_validate_backends=['x509'],

    ssldir="/etc/pki/fedmsg",
    crl_location="https://fedoraproject.org/fedmsg/crl.pem",
    crl_cache="/var/run/fedmsg/crl.pem",
    crl_cache_expiry=10,

    ca_cert_location="https://fedoraproject.org/fedmsg/ca.crt",
    ca_cert_cache="/var/run/fedmsg/ca.crt",
    ca_cert_cache_expiry=0,  # Never expires

    certnames={
        # In prod/stg, map hostname to the name of the cert in ssldir.
        # Unfortunately, we can't use socket.getfqdn()
        #"app01.stg": "app01.stg.phx2.fedoraproject.org",
    },

    # A mapping of fully qualified topics to a list of cert names for which
    # a valid signature is to be considered authorized.  Messages on topics not
    # listed here are considered automatically authorized.
    routing_policy={
        # Only allow announcements from production if they're signed by a
        # certain certificate.
        "org.fedoraproject.prod.announce.announcement": [
            "announce-lockbox.phx2.fedoraproject.org",
        ],
    },

    # Set this to True if you want messages to be dropped that aren't
    # explicitly whitelisted in the routing_policy.
    # When this is False, only messages that have a topic in the routing_policy
    # but whose cert names aren't in the associated list are dropped; messages
    # whose topics do not appear in the routing_policy are not dropped.
    routing_nitpicky=False,
)

########NEW FILE########
